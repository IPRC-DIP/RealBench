{"task": "aes_cipher_top", "codeid": 1, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg ld_r;\nreg [127:0] text_out;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        text_in_r <= 0;\n        sa <= 0;\n        dcnt <= 0;\n        ld_r <= 0;\n        text_out <= 0;\n    end else if (ld) begin\n        text_in_r <= text_in;\n        ld_r <= 1;\n    end else if (ld_r) begin\n        ld_r <= 0;\n        // Perform initial round key addition\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= text_in_r[8*i+j] ^ key[8*i+j];\n            end\n        end\n        dcnt <= 0xB; // Initial round counter value\n    end else begin\n        // Perform round operations\n        if (dcnt > 0) begin\n            // SubBytes transformation\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= aes_sbox(sa[i][j]);\n                end\n            end\n            // ShiftRows transformation\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    if (i > 0) begin\n                        sa[i][j] <= sa[i][j+1];\n                    end\n                end\n            end\n            // MixColumns transformation\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= (sa[i][j] << 1) ^ (sa[i][j] << 3) ^ (sa[i][j] << 2) ^ (sa[i][j] << 1);\n                end\n            end\n            // AddRoundKey transformation\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ aes_key_expand_128(key, dcnt);\n                end\n            end\n            dcnt <= dcnt - 1;\n        end else begin\n            // Final round operations\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= aes_sbox(sa[i][j]);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    if (i > 0) begin\n                        sa[i][j] <= sa[i][j+1];\n                    end\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ aes_key_expand_128(key, dcnt);\n                end\n            end\n            done <= 1;\n        end\n    end\n\n    // Output generation\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            text_out[8*i+j] <= sa[i][j];\n        end\n    end\n\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 2, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\nreg [127:0] text_in_r;\nreg [3:0] dcnt;\nreg ld_r;\n\nreg [3:0] sa[0:3][0:3];\n\nwire [7:0] sub_bytes_out[0:15];\nwire [7:0] shift_rows_out[0:3];\nwire [7:0] mix_columns_out[0:3];\nwire [7:0] add_round_key_out[0:3];\n\nassign text_out = {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                    sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                    sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                    sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n\nalways @(posedge clk) begin\n    if (rst) begin\n        dcnt <= 0;\n        ld_r <= 0;\n        text_in_r <= 0;\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= 0;\n            end\n        end\n    end else if (ld) begin\n        text_in_r <= text_in;\n        ld_r <= 1;\n    end else if (ld_r) begin\n        ld_r <= 0;\n    end else if (dcnt == 11) begin\n        done <= 1;\n    end else begin\n        if (dcnt == 0) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n            dcnt <= 0;\n        end else begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sub_bytes_out[4*i + j];\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= shift_rows_out[i][j];\n                end\n            end\n            if (dcnt!= 10) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= mix_columns_out[i][j];\n                    end\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= add_round_key_out[i][j];\n                end\n            end\n            dcnt <= dcnt - 1;\n        end\n    end\nend\n\naes_key_expand_128 aes_key_expand(\n   .clk(clk),\n   .kld(ld),\n   .key(key),\n   .wo_0(add_round_key_out[0]),\n   .wo_1(add_round_key_out[1]),\n   .wo_2(add_round_key_out[2]),\n   .wo_3(add_round_key_out[3])\n);\n\naes_sbox aes_sbox_0(\n   .a(text_in_r[0]),\n   .b(sub_bytes_out[0])\n);\n\naes_sbox aes_sbox_1(\n   .a(text_in_r[1]),\n   .b(sub_bytes_out[1])\n);\n\naes_sbox aes_sbox_2(\n   .a(text_in_r[2]),\n   .b(sub_bytes_out[2])\n);\n\naes_sbox aes_sbox_3(\n   .a(text_in_r[3]),\n   .b(sub_bytes_out[3])\n);\n\naes_sbox aes_sbox_4(\n   .a(text_in_r[4]),\n   .b(sub_bytes_out[4])\n);\n\naes_sbox aes_sbox_5(\n   .a(text_in_r[5]),\n   .b(sub_bytes_out[5])\n);\n\naes_sbox aes_sbox_6(\n   .a(text_in_r[6]),\n   .b(sub_bytes_out[6])\n);\n\naes_sbox aes_sbox_7(\n   .a(text_in_r[7]),\n   .b(sub_bytes_out[7])\n);\n\naes_sbox aes_sbox_8(\n   .a(text_in_r[8]),\n   .b(sub_bytes_out[8])\n);\n\naes_sbox aes_sbox_9(\n   .a(text_in_r[9]),\n   .b(sub_bytes_out[9])\n);\n\naes_sbox aes_sbox_10(\n   .a(text_in_r[10]),\n   .b(sub_bytes_out[10])\n);\n\naes_sbox aes_sbox_11(\n   .a(text_in_r[11]),\n   .b(sub_bytes_out[11])\n);\n\naes_sbox aes_sbox_12(\n   .a(text_in_r[12]),\n   .b(sub_bytes_out[12])\n);\n\naes_sbox aes_sbox_13(\n   .a(text_in_r[13]),\n   .b(sub_bytes_out[13])\n);\n\naes_sbox aes_sbox_14(\n   .a(text_in_r[14]),\n   .b(sub_bytes_out[14])\n);\n\naes_sbox aes_sbox_15(\n   .a(text_in_r[15]),\n   .b(sub_bytes_out[15])\n);\n\naes_shift_rows aes_shift_rows_0(\n   .a(text_in_r[0]),\n   .b(shift_rows_out[0])\n);\n\naes_shift_rows aes_shift_rows_1(\n   .a(text_in_r[1]),\n   .b(shift_rows_out[1])\n);\n\naes_shift_rows aes_shift_rows_2(\n   .a(text_in_r[2]),\n   .b(shift_rows_out[2])\n);\n\naes_shift_rows aes_shift_rows_3(\n   .a(text_in_r[3]),\n   .b(shift_rows_out[3])\n);\n\naes_mix_columns aes_mix_columns_0(\n   .a(text_in_r[0]),\n   .b(mix_columns_out[0])\n);\n\naes_mix_columns aes_mix_columns_1(\n   .a(text_in_r[1]),\n   .b(mix_columns_out[1])\n);\n\naes_mix_columns aes_mix_columns_2(\n   .a(text_in_r[2]),\n   .b(mix_columns_out[2])\n);\n\naes_mix_columns aes_mix_columns_3(\n   .a(text_in_r[3]),\n   .b(mix_columns_out[3])\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 3, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expand(\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(round_key_0),\n        .wo_1(round_key_1),\n        .wo_2(round_key_2),\n        .wo_3(round_key_3)\n    );\n\n    aes_sbox aes_sbox_0(\n        .a(sa[0][0]),\n        .b(sb[0])\n    );\n    aes_sbox aes_sbox_1(\n        .a(sa[0][1]),\n        .b(sb[1])\n    );\n    aes_sbox aes_sbox_2(\n        .a(sa[0][2]),\n        .b(sb[2])\n    );\n    aes_sbox aes_sbox_3(\n        .a(sa[0][3]),\n        .b(sb[3])\n    );\n    aes_sbox aes_sbox_4(\n        .a(sa[1][0]),\n        .b(sb[4])\n    );\n    aes_sbox aes_sbox_5(\n        .a(sa[1][1]),\n        .b(sb[5])\n    );\n    aes_sbox aes_sbox_6(\n        .a(sa[1][2]),\n        .b(sb[6])\n    );\n    aes_sbox aes_sbox_7(\n        .a(sa[1][3]),\n        .b(sb[7])\n    );\n    aes_sbox aes_sbox_8(\n        .a(sa[2][0]),\n        .b(sb[8])\n    );\n    aes_sbox aes_sbox_9(\n        .a(sa[2][1]),\n        .b(sb[9])\n    );\n    aes_sbox aes_sbox_10(\n        .a(sa[2][2]),\n        .b(sb[10])\n    );\n    aes_sbox aes_sbox_11(\n        .a(sa[2][3]),\n        .b(sb[11])\n    );\n    aes_sbox aes_sbox_12(\n        .a(sa[3][0]),\n        .b(sb[12])\n    );\n    aes_sbox aes_sbox_13(\n        .a(sa[3][1]),\n        .b(sb[13])\n    );\n    aes_sbox aes_sbox_14(\n        .a(sa[3][2]),\n        .b(sb[14])\n    );\n    aes_sbox aes_sbox_15(\n        .a(sa[3][3]),\n        .b(sb[15])\n    );\n\n    // State matrix initialization\n    initial begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] = 0;\n            end\n        end\n    end\n\n    // Round counter initialization\n    initial begin\n        dcnt = 11;\n    end\n\n    // Load operation\n    always @(posedge clk) begin\n        if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1;\n        end\n    end\n\n    // Round operation\n    always @(posedge clk) begin\n        if (ld_r) begin\n            // SubBytes\n            for (int i = 0; i < 16; i++) begin\n                sb[i] = aes_sbox_0.sb;\n                aes_sbox_0.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_1.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_2.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_3.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_4.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_5.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_6.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_7.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_8.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_9.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_10.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_11.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_12.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_13.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_14.a <= text_in_r[i*8+7:i*8];\n                aes_sbox_15.a <= text_in_r[i*8+7:i*8];\n            end\n\n            // ShiftRows\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] = text_in_r[(i+j)*8+7:(i+j)*8];\n                end\n            end\n\n            // MixColumns\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] = (sa[i][j] * 2) ^ (sa[i][j] * 3);\n                end\n            end\n\n            // AddRoundKey\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] = sa[i][j] ^ round_key_0[i*4+j];\n                end\n            end\n\n            ld_r <= 0;\n            dcnt <= dcnt - 1;\n        end\n    end\n\n    // Final round operation\n    always @(posedge clk) begin\n        if (dcnt == 0) begin\n            // Skip MixColumns\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] = text_in_r[(i+j)*8+7:(i+j)*8];\n                end\n            end\n\n            // ShiftRows\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] = text_in_r[(i+j)*8+7:(i+j)*8];\n                end\n            end\n\n            // AddRoundKey\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] = sa[i][j] ^ round_key_0[i*4+j];\n                end\n            end\n\n            done <= 1;\n            text_out <= text_in_r;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 4, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\nreg [127:0] text_in_r;\nreg [3:0] dcnt;\nreg ld_r;\nreg [3:0] sa[0:3][0:3];\nreg [7:0] text_out;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        text_in_r <= 0;\n        dcnt <= 0;\n        ld_r <= 0;\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= 0;\n            end\n        end\n    end else if (ld) begin\n        text_in_r <= text_in;\n        ld_r <= 1;\n        dcnt <= 0;\n    end else if (ld_r) begin\n        ld_r <= 0;\n        if (dcnt == 0) begin\n            // Initial round key addition\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i+j] ^ key[8*i+j];\n                end\n            end\n            dcnt <= 11; // 10 rounds + initial round\n        end else if (dcnt > 0) begin\n            // Standard round operations (Rounds 1-9)\n            SubBytes(sa);\n            ShiftRows(sa);\n            MixColumns(sa);\n            AddRoundKey(sa, dcnt);\n            dcnt <= dcnt - 1;\n        end else if (dcnt == 10) begin\n            // Final round operation (Round 10)\n            FinalRound(sa);\n            text_out <= sa[0][0] << 8*3 | sa[0][1] << 8*2 | sa[0][2] << 8*1 | sa[0][3];\n            done <= 1;\n        end\n    end\nend\n\n// SubBytes transformation\nmodule SubBytes(sa);\n    reg [7:0] sa[0:3][0:3];\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa[i][j] <= aes_sbox(sa[i][j]);\n        end\n    end\nendmodule\n\n// ShiftRows transformation\nmodule ShiftRows(sa);\n    reg [7:0] sa[0:3][0:3];\n    for (int i = 1; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa[i][j] <= {sa[i][j+1], sa[i][j]};\n        end\n    end\nendmodule\n\n// MixColumns transformation\nmodule MixColumns(sa);\n    reg [7:0] sa[0:3][0:3];\n    reg [7:0] temp[0:3][0:3];\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            temp[i][j] <= (sa[i][j] << 1) ^ (sa[i][j] << 2) ^ (sa[i][j] << 3) ^ (sa[i][j] << 1);\n        end\n    end\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa[i][j] <= temp[i][j];\n        end\n    end\nendmodule\n\n// AddRoundKey transformation\nmodule AddRoundKey(sa, dcnt);\n    reg [7:0] sa[0:3][0:3];\n    reg [7:0] key[0:3][0:3];\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa[i][j] <= sa[i][j] ^ key[i][j];\n        end\n    end\nendmodule\n\n// FinalRound transformation\nmodule FinalRound(sa);\n    reg [7:0] sa[0:3][0:3];\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa[i][j] <= sa[i][j];\n        end\n    end\nendmodule\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 5, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n            text_out <= 0;\n        end else if (ld) begin\n            text_in_r <= text_in;\n            dcnt <= 0;\n            ld_r <= 1;\n        end else if (ld_r) begin\n            ld_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n        end else if (dcnt < 10) begin\n            if (dcnt == 0) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] = sa[i][j] ^ key[8*i + j];\n                    end\n                end\n            end else begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] = subBytes(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] = shiftRows(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] = mixColumns(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] = sa[i][j] ^ key[8*i + j + 32*dcnt];\n                    end\n                end\n            end\n            dcnt <= dcnt + 1;\n        end else begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] = subBytes(sa[i][j]);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] = shiftRows(sa[i][j]);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] = sa[i][j] ^ key[8*i + j + 32*dcnt];\n                end\n            end\n            done <= 1;\n        end\n    end\n\n    assign text_out = {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                      sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                      sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                      sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n\n    function [7:0] subBytes([7:0] a);\n        case (a)\n            0: subBytes = 0x63;\n            1: subBytes = 0x7c;\n            2: subBytes = 0x77;\n            3: subBytes = 0x7b;\n            4: subBytes = 0xf2;\n            5: subBytes = 0x6b;\n            6: subBytes = 0x6f;\n            7: subBytes = 0xc5;\n            8: subBytes = 0x30;\n            9: subBytes = 0x01;\n            10: subBytes = 0x67;\n            11: subBytes = 0x2b;\n            12: subBytes = 0xfe;\n            13: subBytes = 0xd7;\n            14: subBytes = 0xab;\n            15: subBytes = 0x76;\n            16: subBytes = 0xca;\n            17: subBytes = 0x82;\n            18: subBytes = 0xc9;\n            19: subBytes = 0x7d;\n            20: subBytes = 0xfa;\n            21: subBytes = 0x59;\n            22: subBytes = 0x47;\n            23: subBytes = 0x01;\n            24: subBytes = 0x10;\n            25: subBytes = 0x03;\n            26: subBytes = 0x18;\n            27: subBytes = 0x90;\n            28: subBytes = 0x6d;\n            29: subBytes = 0x80;\n            30: subBytes = 0xe4;\n            31: subBytes = 0x5a;\n            32: subBytes = 0x0f;\n            33: subBytes = 0x9f;\n            34: subBytes = 0x96;\n            35: subBytes = 0xec;\n            36: subBytes = 0x6u;\n            37: subBytes = 0x73;\n            38: subBytes = 0x77;\n            39: subBytes = 0x7a;\n            40: subBytes = 0xb8;\n            41: subBytes = 0x84;\n            42: subBytes = 0xa3;\n            43: subBytes = 0x9e;\n            44: subBytes = 0x67;\n            45: subBytes = 0x94;\n            46: subBytes = 0x7c;\n            47: subBytes = 0x7b;\n            48: subBytes = 0xf0;\n            49: subBytes = 0xad;\n            50: subBytes = 0xd2;\n            51: subBytes = 0xa9;\n            52: subBytes = 0x6c;\n            53: subBytes = 0xa4;\n            54: subBytes = 0x72;\n            55: subBytes = 0xc0;\n            56: subBytes = 0xb7;\n            57: subBytes = 0xfd;\n            58: subBytes = 0x93;\n            59: subBytes = 0x26;\n            60: subBytes = 0x36;\n            61: subBytes = 0x3f;\n            62: subBytes = 0xf7;\n            63: subBytes = 0xcc;\n            64: subBytes = 0x34;\n            65: subBytes = 0xa5;\n            66: subBytes = 0xe1;\n            67: subBytes = 0x74;\n            68: subBytes = 0x4b;\n            69: subBytes = 0xbd;\n            70: subBytes = 0x8b;\n            71: subBytes = 0x40;\n            72: subBytes = 0x4a;\n            73: subBytes = 0x9a;\n            74: subBytes = 0x66;\n            75: subBytes = 0x11;\n            76: subBytes = 0x95;\n            77: subBytes = 0x98;\n            78: subBytes = 0x42;\n            79: subBytes = 0x0c;\n            80: subBytes = 0x4e;\n            81: subBytes = 0x8e;\n            82: subBytes = 0xba;\n            83: subBytes = 0x76;\n            84: subBytes = 0x5b;\n            85: subBytes = 0x54;\n            86: subBytes = 0x94;\n            87: subBytes = 0x17;\n            88: subBytes = 0x08;\n            89: subBytes = 0x2e;\n            90: subBytes = 0xae;\n            91: subBytes = 0x2a;\n            92: subBytes = 0x28;\n            93: subBytes = 0x3d;\n            94: subBytes = 0x44;\n            95: subBytes = 0xb5;\n            96: subBytes = 0x35;\n            97: subBytes = 0x4c;\n            98: subBytes = 0x9f;\n            99: subBytes = 0x3c;\n            100: subBytes = 0x92;\n            101: subBytes = 0x9d;\n            102: subBytes = 0x83;\n            103: subBytes = 0xc4;\n            104: subBytes = 0x1f;\n            105: subBytes = 0x82;\n            106: subBytes = 0xc9;\n            107: subBytes = 0x7d;\n            108: subBytes = 0xfa;\n            109: subBytes = 0x47;\n            110: subBytes = 0x01;\n            111: subBytes = 0x06;\n            112: subBytes = 0x58;\n            113: subBytes = 0x5a;\n            114: subBytes = 0x0c;\n            115: subBytes = 0xb3;\n            116: subBytes = 0xeb;\n            117: subBytes = 0x77;\n            118: subBytes = 0x18;\n            119: subBytes = 0x94;\n            120: subBytes = 0x35;\n            121: subBytes = 0x7c;\n            122: subBytes = 0x9c;\n            123: subBytes = 0x1b;\n            124: subBytes = 0x8a;\n            125: subBytes = 0x8d;\n            126: subBytes = 0x1f;\n            127: subBytes = 0x21;\n            default: subBytes = 0;\n        endcase\n    endfunction\n\n    function [7:0] shiftRows([7:0] a);\n        case (a[3:0])\n            0: shiftRows = a;\n            1: shiftRows = {a[1], a[2], a[3], a[0]};\n            2: shiftRows = {a[2], a[3], a[0], a[1]};\n            3: shiftRows = {a[3], a[0], a[1], a[2]};\n            default: shiftRows = a;\n        endcase\n    endfunction\n\n    function [7:0] mixColumns([7:0] a);\n        case (a[7:0])\n            0: mixColumns = 0x01;\n            1: mixColumns = 0x02;\n            2: mixColumns = 0x04;\n            3: mixColumns = 0x08;\n            4: mixColumns = 0x10;\n            5: mixColumns = 0x20;\n            6: mixColumns = 0x40;\n            7: mixColumns = 0x80;\n            8: mixColumns = 0x1b;\n            9: mixColumns = 0x36;\n            10: mixColumns = 0x6d;\n            11: mixColumns = 0xd8;\n            12: mixColumns = 0xab;\n            13: mixColumns = 0x4d;\n            14: mixColumns = 0x9a;\n            15: mixColumns = 0x2f;\n            default: mixColumns = 0;\n        endcase\n    endfunction\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 6, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n               sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n               sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n               sa[3][0], sa[3][1], sa[3][2], sa[3][3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa[0][0] <= 0;\n            sa[0][1] <= 0;\n            sa[0][2] <= 0;\n            sa[0][3] <= 0;\n            sa[1][0] <= 0;\n            sa[1][1] <= 0;\n            sa[1][2] <= 0;\n            sa[1][3] <= 0;\n            sa[2][0] <= 0;\n            sa[2][1] <= 0;\n            sa[2][2] <= 0;\n            sa[2][3] <= 0;\n            sa[3][0] <= 0;\n            sa[3][1] <= 0;\n            sa[3][2] <= 0;\n            sa[3][3] <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n            text_out <= 0;\n        end\n        else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1;\n            sa[0][0] <= text_in[7:0];\n            sa[0][1] <= text_in[15:8];\n            sa[0][2] <= text_in[23:16];\n            sa[0][3] <= text_in[31:24];\n            sa[1][0] <= text_in[39:32];\n            sa[1][1] <= text_in[47:40];\n            sa[1][2] <= text_in[55:48];\n            sa[1][3] <= text_in[63:56];\n            sa[2][0] <= text_in[71:64];\n            sa[2][1] <= text_in[79:72];\n            sa[2][2] <= text_in[87:80];\n            sa[2][3] <= text_in[95:88];\n            sa[3][0] <= text_in[103:96];\n            sa[3][1] <= text_in[111:104];\n            sa[3][2] <= text_in[119:112];\n            sa[3][3] <= text_in[127:120];\n            dcnt <= 0xB;\n        end\n        else if (dcnt > 0) begin\n            if (dcnt == 0) begin\n                // Initial round key addition\n                sa[0][0] <= sa[0][0] ^ key[7:0];\n                sa[0][1] <= sa[0][1] ^ key[15:8];\n                sa[0][2] <= sa[0][2] ^ key[23:16];\n                sa[0][3] <= sa[0][3] ^ key[31:24];\n                sa[1][0] <= sa[1][0] ^ key[39:32];\n                sa[1][1] <= sa[1][1] ^ key[47:40];\n                sa[1][2] <= sa[1][2] ^ key[55:48];\n                sa[1][3] <= sa[1][3] ^ key[63:56];\n                sa[2][0] <= sa[2][0] ^ key[71:64];\n                sa[2][1] <= sa[2][1] ^ key[79:72];\n                sa[2][2] <= sa[2][2] ^ key[87:80];\n                sa[2][3] <= sa[2][3] ^ key[95:88];\n                sa[3][0] <= sa[3][0] ^ key[103:96];\n                sa[3][1] <= sa[3][1] ^ key[111:104];\n                sa[3][2] <= sa[3][2] ^ key[119:112];\n                sa[3][3] <= sa[3][3] ^ key[127:120];\n                dcnt <= dcnt - 1;\n            end\n            else begin\n                // Standard round operations\n                // SubBytes\n                sa[0][0] <= aes_sbox(sa[0][0]);\n                sa[0][1] <= aes_sbox(sa[0][1]);\n                sa[0][2] <= aes_sbox(sa[0][2]);\n                sa[0][3] <= aes_sbox(sa[0][3]);\n                sa[1][0] <= aes_sbox(sa[1][0]);\n                sa[1][1] <= aes_sbox(sa[1][1]);\n                sa[1][2] <= aes_sbox(sa[1][2]);\n                sa[1][3] <= aes_sbox(sa[1][3]);\n                sa[2][0] <= aes_sbox(sa[2][0]);\n                sa[2][1] <= aes_sbox(sa[2][1]);\n                sa[2][2] <= aes_sbox(sa[2][2]);\n                sa[2][3] <= aes_sbox(sa[2][3]);\n                sa[3][0] <= aes_sbox(sa[3][0]);\n                sa[3][1] <= aes_sbox(sa[3][1]);\n                sa[3][2] <= aes_sbox(sa[3][2]);\n                sa[3][3] <= aes_sbox(sa[3][3]);\n                // ShiftRows\n                sa[1][0] <= {sa[1][3], sa[1][0], sa[1][1], sa[1][2]};\n                sa[2][0] <= {sa[2][2], sa[2][3], sa[2][0], sa[2][1]};\n                sa[3][0] <= {sa[3][1], sa[3][2], sa[3][3], sa[3][0]};\n                // MixColumns\n                sa[0][0] <= (sa[0][0] * 2 + sa[0][1] * 3) ^ (sa[0][2] * 2 + sa[0][3] * 3);\n                sa[0][1] <= (sa[0][1] * 2 + sa[0][2] * 3) ^ (sa[0][3] * 2 + sa[0][0] * 3);\n                sa[0][2] <= (sa[0][2] * 2 + sa[0][3] * 3) ^ (sa[0][0] * 2 + sa[0][1] * 3);\n                sa[0][3] <= (sa[0][3] * 2 + sa[0][0] * 3) ^ (sa[0][1] * 2 + sa[0][2] * 3);\n                sa[1][0] <= (sa[1][0] * 2 + sa[1][1] * 3) ^ (sa[1][2] * 2 + sa[1][3] * 3);\n                sa[1][1] <= (sa[1][1] * 2 + sa[1][2] * 3) ^ (sa[1][3] * 2 + sa[1][0] * 3);\n                sa[1][2] <= (sa[1][2] * 2 + sa[1][3] * 3) ^ (sa[1][0] * 2 + sa[1][1] * 3);\n                sa[1][3] <= (sa[1][3] * 2 + sa[1][0] * 3) ^ (sa[1][1] * 2 + sa[1][2] * 3);\n                sa[2][0] <= (sa[2][0] * 2 + sa[2][1] * 3) ^ (sa[2][2] * 2 + sa[2][3] * 3);\n                sa[2][1] <= (sa[2][1] * 2 + sa[2][2] * 3) ^ (sa[2][3] * 2 + sa[2][0] * 3);\n                sa[2][2] <= (sa[2][2] * 2 + sa[2][3] * 3) ^ (sa[2][0] * 2 + sa[2][1] * 3);\n                sa[2][3] <= (sa[2][3] * 2 + sa[2][0] * 3) ^ (sa[2][1] * 2 + sa[2][2] * 3);\n                sa[3][0] <= (sa[3][0] * 2 + sa[3][1] * 3) ^ (sa[3][2] * 2 + sa[3][3] * 3);\n                sa[3][1] <= (sa[3][1] * 2 + sa[3][2] * 3) ^ (sa[3][3] * 2 + sa[3][0] * 3);\n                sa[3][2] <= (sa[3][2] * 2 + sa[3][3] * 3) ^ (sa[3][0] * 2 + sa[3][1] * 3);\n                sa[3][3] <= (sa[3][3] * 2 + sa[3][0] * 3) ^ (sa[3][1] * 2 + sa[3][2] * 3);\n                // AddRoundKey\n                sa[0][0] <= sa[0][0] ^ aes_key_expand_128[dcnt][7:0];\n                sa[0][1] <= sa[0][1] ^ aes_key_expand_128[dcnt][15:8];\n                sa[0][2] <= sa[0][2] ^ aes_key_expand_128[dcnt][23:16];\n                sa[0][3] <= sa[0][3] ^ aes_key_expand_128[dcnt][31:24];\n                sa[1][0] <= sa[1][0] ^ aes_key_expand_128[dcnt][39:32];\n                sa[1][1] <= sa[1][1] ^ aes_key_expand_128[dcnt][47:40];\n                sa[1][2] <= sa[1][2] ^ aes_key_expand_128[dcnt][55:48];\n                sa[1][3] <= sa[1][3] ^ aes_key_expand_128[dcnt][63:56];\n                sa[2][0] <= sa[2][0] ^ aes_key_expand_128[dcnt][71:64];\n                sa[2][1] <= sa[2][1] ^ aes_key_expand_128[dcnt][79:72];\n                sa[2][2] <= sa[2][2] ^ aes_key_expand_128[dcnt][87:80];\n                sa[2][3] <= sa[2][3] ^ aes_key_expand_128[dcnt][95:88];\n                sa[3][0] <= sa[3][0] ^ aes_key_expand_128[dcnt][103:96];\n                sa[3][1] <= sa[3][1] ^ aes_key_expand_128[dcnt][111:104];\n                sa[3][2] <= sa[3][2] ^ aes_key_expand_128[dcnt][119:112];\n                sa[3][3] <= sa[3][3] ^ aes_key_expand_128[dcnt][127:120];\n                dcnt <= dcnt - 1;\n            end\n        end\n        else if (dcnt == 0) begin\n            // Final round operations\n            // ShiftRows\n            sa[1][0] <= {sa[1][3], sa[1][0], sa[1][1], sa[1][2]};\n            sa[2][0] <= {sa[2][2], sa[2][3], sa[2][0], sa[2][1]};\n            sa[3][0] <= {sa[3][1], sa[3][2], sa[3][3], sa[3][0]};\n            // AddRoundKey\n            sa[0][0] <= sa[0][0] ^ aes_key_expand_128[dcnt][7:0];\n            sa[0][1] <= sa[0][1] ^ aes_key_expand_128[dcnt][15:8];\n            sa[0][2] <= sa[0][2] ^ aes_key_expand_128[dcnt][23:16];\n            sa[0][3] <= sa[0][3] ^ aes_key_expand_128[dcnt][31:24];\n            sa[1][0] <= sa[1][0] ^ aes_key_expand_128[dcnt][39:32];\n            sa[1][1] <= sa[1][1] ^ aes_key_expand_128[dcnt][47:40];\n            sa[1][2] <= sa[1][2] ^ aes_key_expand_128[dcnt][55:48];\n            sa[1][3] <= sa[1][3] ^ aes_key_expand_128[dcnt][63:56];\n            sa[2][0] <= sa[2][0] ^ aes_key_expand_128[dcnt][71:64];\n            sa[2][1] <= sa[2][1] ^ aes_key_expand_128[dcnt][79:72];\n            sa[2][2] <= sa[2][2] ^ aes_key_expand_128[dcnt][87:80];\n            sa[2][3] <= sa[2][3] ^ aes_key_expand_128[dcnt][95:88];\n            sa[3][0] <= sa[3][0] ^ aes_key_expand_128[dcnt][103:96];\n            sa[3][1] <= sa[3][1] ^ aes_key_expand_128[dcnt][111:104];\n            sa[3][2] <= sa[3][2] ^ aes_key_expand_128[dcnt][119:112];\n            sa[3][3] <= sa[3][3] ^ aes_key_expand_128[dcnt][127:120];\n            // Output generation\n            text_out[7:0] <= sa[0][0];\n            text_out[15:8] <= sa[0][1];\n            text_out[23:16] <= sa[0][2];\n            text_out[31:24] <= sa[0][3];\n            text_out[39:32] <= sa[1][0];\n            text_out[47:40] <= sa[1][1];\n            text_out[55:48] <= sa[1][2];\n            text_out[63:56] <= sa[1][3];\n            text_out[71:64] <= sa[2][0];\n            text_out[79:72] <= sa[2][1];\n            text_out[87:80] <= sa[2][2];\n            text_out[95:88] <= sa[2][3];\n            text_out[103:96] <= sa[3][0];\n            text_out[111:104] <= sa[3][1];\n            text_out[119:112] <= sa[3][2];\n            text_out[127:120] <= sa[3][3];\n            done <= 1;\n        end\n    end\n\n    assign ld_r = ld_r & ~ld;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 7, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n            text_out <= 0;\n        end\n        else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1;\n        end\n        else if (ld_r) begin\n            ld_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n            dcnt <= 11;\n        end\n        else if (dcnt > 0) begin\n            dcnt <= dcnt - 1;\n            if (dcnt == 0) begin\n                done <= 1;\n            end\n            else if (dcnt == 10) begin\n                // Final round\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ aes_key_expand_128(key, dcnt);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        text_out[8*i + j] <= sa[i][j];\n                    end\n                end\n                done <= 1;\n            end\n            else begin\n                // Standard round\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= aes_subbytes(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= aes_shiftrows(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= aes_mixcolumns(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ aes_key_expand_128(key, dcnt);\n                    end\n                end\n            end\n        end\n    end\n\n    assign text_out = {text_out[127:128], text_out[127:128], text_out[127:128], text_out[127:128]};\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 8, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 4'd11;\n            ld_r <= 1'b0;\n        end\n        else if (ld) begin\n            ld_r <= 1'b1;\n            text_in_r <= text_in;\n        end\n        else if (ld_r) begin\n            ld_r <= 1'b0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n            dcnt <= 4'd11;\n        end\n        else if (dcnt > 0) begin\n            dcnt <= dcnt - 1;\n            if (dcnt == 0) begin\n                done <= 1'b1;\n                text_out <= text_in_r;\n            end\n            else begin\n                // SubBytes\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= aes_sbox(sa[i][j]);\n                    end\n                end\n                // ShiftRows\n                for (int i = 1; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= {sa[i][j+1], sa[i][j]};\n                    end\n                end\n                // MixColumns\n                for (int i = 0; i < 4; i++) begin\n                    reg [7:0] col[0:3];\n                    for (int j = 0; j < 4; j++) begin\n                        col[j] <= sa[i][j];\n                    end\n                    reg [7:0] out[0:3];\n                    out[0] <= (col[0] * 2 + col[1] * 3) ^ col[2] ^ col[3];\n                    out[1] <= (col[1] * 2 + col[2] * 3) ^ col[0] ^ col[3];\n                    out[2] <= (col[2] * 2 + col[3] * 3) ^ col[0] ^ col[1];\n                    out[3] <= (col[3] * 2 + col[0] * 3) ^ col[1] ^ col[2];\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= out[j];\n                    end\n                end\n                // AddRoundKey\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ aes_key_expansion(key, dcnt);\n                    end\n                end\n            end\n        end\n    end\n\n    assign text_out = text_in_r;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 9, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n               sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n               sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n               sa[3][0], sa[3][1], sa[3][2], sa[3][3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    wire [7:0] sbox_out[15:0];\n\n    assign done = (dcnt == 0);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out <= 0;\n        end\n        else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n        end\n        else if (ld_r) begin\n            ld_r <= 0;\n            // Initial round key addition\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] = text_in_r[8*i + j] ^ key[8*i + j];\n                end\n            end\n            dcnt <= 0xB;\n        end\n        else if (dcnt > 0) begin\n            // SubBytes transformation\n            for (int i = 0; i < 16; i++) begin\n                sbox_out[i] = aes_sbox(aes_sbox_in[i]);\n            end\n\n            // ShiftRows transformation\n            for (int i = 0; i < 4; i++) begin\n                if (i == 0) begin\n                    sa[i][0] <= sa[i][0];\n                end\n                else if (i == 1) begin\n                    sa[i][0] <= sa[i][3];\n                    sa[i][1] <= sa[i][0];\n                    sa[i][2] <= sa[i][1];\n                    sa[i][3] <= sa[i][2];\n                end\n                else if (i == 2) begin\n                    sa[i][0] <= sa[i][2];\n                    sa[i][1] <= sa[i][3];\n                    sa[i][2] <= sa[i][0];\n                    sa[i][3] <= sa[i][1];\n                end\n                else if (i == 3) begin\n                    sa[i][0] <= sa[i][3];\n                    sa[i][1] <= sa[i][0];\n                    sa[i][2] <= sa[i][1];\n                    sa[i][3] <= sa[i][2];\n                end\n            end\n\n            // MixColumns transformation\n            for (int i = 0; i < 4; i++) begin\n                wire [7:0] col[3];\n                col[0] = sa[i][0] ^ sa[i][1] ^ sa[i][2] ^ sa[i][3];\n                col[1] = sa[i][0] ^ sa[i][1] ^ sa[i][2] ^ sa[i][3];\n                col[2] = sa[i][0] ^ sa[i][1] ^ sa[i][2] ^ sa[i][3];\n                col[3] = sa[i][0] ^ sa[i][1] ^ sa[i][2] ^ sa[i][3];\n\n                sa[i][0] <= col[0] ^ (col[1] << 1) ^ (col[2] << 2) ^ (col[3] << 3);\n                sa[i][1] <= col[0] ^ (col[1] << 1) ^ (col[2] << 2) ^ (col[3] << 3);\n                sa[i][2] <= col[0] ^ (col[1] << 1) ^ (col[2] << 2) ^ (col[3] << 3);\n                sa[i][3] <= col[0] ^ (col[1] << 1) ^ (col[2] << 2) ^ (col[3] << 3);\n            end\n\n            // AddRoundKey transformation\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] = sa[i][j] ^ aes_key_expansion(dcnt, i, j);\n                end\n            end\n\n            dcnt <= dcnt - 1;\n        end\n    end\n\n    assign text_out = {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                      sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                      sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                      sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 10, "code": "module aes_cipher_top(\n    input  wire clk,\n    input  wire rst,\n    input  wire ld,\n    output wire done,\n    input  wire [127:0] key,\n    input  wire [127:0] text_in,\n    output wire [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n            text_out <= 0;\n        end\n        else if (ld) begin\n            text_in_r <= text_in;\n            sa <= text_in_r[127:128-8];\n            dcnt <= 0xB;\n            ld_r <= 1;\n        end\n        else if (ld_r) begin\n            ld_r <= 0;\n            sa <= sa + text_in_r[127:128-8];\n        end\n        else begin\n            case (dcnt)\n                0xB: begin\n                    // Initial round key addition\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] = sa[i][j] ^ key[8*i+j];\n                        end\n                    end\n                    dcnt <= dcnt + 1;\n                end\n                default: begin\n                    // Standard round operations\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] = subBytes(sa[i][j]);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] = shiftRows(sa[i][j]);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] = mixColumns(sa[i][j]);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] = addRoundKey(sa[i][j]);\n                        end\n                    end\n                    dcnt <= dcnt + 1;\n                end\n            endcase\n        end\n    end\n\n    assign done = (dcnt == 0);\n\n    assign text_out = {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                      sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                      sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                      sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 1, "code": "module aes_inv_cipher_top(\n    input  clk,\n    input  rst,\n    input  kld,\n    input  ld,\n    output done,\n    input  [127:0] key,\n    input  [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // Key Expansion Module\n    aes_key_expand_128 aes_key_exp(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    // Inverse S-box Modules\n    aes_inv_sbox us00(.a(sa[0][0]), .b(us00));\n    aes_inv_sbox us01(.a(sa[0][1]), .b(us01));\n    aes_inv_sbox us02(.a(sa[0][2]), .b(us02));\n    aes_inv_sbox us03(.a(sa[0][3]), .b(us03));\n    aes_inv_sbox us10(.a(sa[1][0]), .b(us10));\n    aes_inv_sbox us11(.a(sa[1][1]), .b(us11));\n    aes_inv_sbox us12(.a(sa[1][2]), .b(us12));\n    aes_inv_sbox us13(.a(sa[1][3]), .b(us13));\n    aes_inv_sbox us20(.a(sa[2][0]), .b(us20));\n    aes_inv_sbox us21(.a(sa[2][1]), .b(us21));\n    aes_inv_sbox us22(.a(sa[2][2]), .b(us22));\n    aes_inv_sbox us23(.a(sa[2][3]), .b(us23));\n    aes_inv_sbox us30(.a(sa[3][0]), .b(us30));\n    aes_inv_sbox us31(.a(sa[3][1]), .b(us31));\n    aes_inv_sbox us32(.a(sa[3][2]), .b(us32));\n    aes_inv_sbox us33(.a(sa[3][3]), .b(us33));\n\n    // State Transition Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end\n        else if (kld) begin\n            // Key loading\n            kcnt <= 10;\n            kb[10] <= wk0;\n            kb[9] <= wk1;\n            kb[8] <= wk2;\n            kb[7] <= wk3;\n        end\n        else if (ld) begin\n            // Data loading\n            ld_r <= 1;\n            text_in_r <= text_in;\n        end\n        else if (ld_r) begin\n            // Initial round key addition\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i+j];\n                end\n            end\n            ld_r <= 0;\n        end\n        else if (dcnt < 11) begin\n            // Standard round\n            InvShiftRows();\n            InvSubBytes();\n            AddRoundKey();\n            InvMixColumns();\n            dcnt <= dcnt + 1;\n        end\n        else begin\n            // Final round\n            InvShiftRows();\n            InvSubBytes();\n            AddRoundKey();\n            done <= 1;\n        end\n    end\n\n    // Inverse Shift Rows\n    task InvShiftRows();\n        for (int i = 1; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i][j+1];\n            end\n            sa[i][3] <= sa[i][0];\n        end\n    endtask\n\n    // Inverse SubBytes\n    task InvSubBytes();\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= us00(sa[i][j]);\n            end\n        end\n    endtask\n\n    // Add Round Key\n    task AddRoundKey();\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i][j] ^ kb[dcnt][8*i+j];\n            end\n        end\n    endtask\n\n    // Inverse Mix Columns\n    task InvMixColumns();\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa_next[i][j] <= (sa[i][j] * 0E) ^ (sa[i][j] * 0B) ^ (sa[i][j] * 0D) ^ (sa[i][j] * 0B);\n            end\n        end\n    endtask\n\n    // Output Generation\n    always @(posedge clk) begin\n        if (ld_r) begin\n            text_out <= text_in_r;\n        end\n        else if (dcnt == 11) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out[8*i+j] <= sa[i][j];\n                end\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 2, "code": "module aes_inv_cipher_top(\n    input  clk,\n    input  rst,\n    input  kld,\n    input  ld,\n    output done,\n    input  [127:0] key,\n    input  [127:0] text_in,\n    output [127:0] text_out\n);\n\n    // Registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expansion(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox us00(.a(sa[0][0]), .b(us00));\n    aes_inv_sbox us01(.a(sa[0][1]), .b(us01));\n    aes_inv_sbox us02(.a(sa[0][2]), .b(us02));\n    aes_inv_sbox us03(.a(sa[0][3]), .b(us03));\n    aes_inv_sbox us10(.a(sa[1][0]), .b(us10));\n    aes_inv_sbox us11(.a(sa[1][1]), .b(us11));\n    aes_inv_sbox us12(.a(sa[1][2]), .b(us12));\n    aes_inv_sbox us13(.a(sa[1][3]), .b(us13));\n    aes_inv_sbox us20(.a(sa[2][0]), .b(us20));\n    aes_inv_sbox us21(.a(sa[2][1]), .b(us21));\n    aes_inv_sbox us22(.a(sa[2][2]), .b(us22));\n    aes_inv_sbox us23(.a(sa[2][3]), .b(us23));\n    aes_inv_sbox us30(.a(sa[3][0]), .b(us30));\n    aes_inv_sbox us31(.a(sa[3][1]), .b(us31));\n    aes_inv_sbox us32(.a(sa[3][2]), .b(us32));\n    aes_inv_sbox us33(.a(sa[3][3]), .b(us33));\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out <= 0;\n        end\n        else if (kld) begin\n            // Key Load State\n            kcnt <= 10;\n            ld_r <= 1;\n        end\n        else if (ld) begin\n            // KeyExpansion State\n            if (kcnt > 0) begin\n                kcnt <= kcnt - 1;\n                kb[kcnt] <= wk3;\n            end\n            else begin\n                // KeyStored State\n                ld_r <= 0;\n                dcnt <= 1;\n            end\n        end\n        else if (dcnt < 11) begin\n            // InitialRound State\n            if (ld_r) begin\n                // Data Load\n                text_in_r <= text_in;\n                ld_r <= 0;\n            end\n            // StandardRound State\n            else begin\n                // InvShiftRows\n                sa[0][0] <= sa[0][0];\n                sa[0][1] <= sa[0][3];\n                sa[0][2] <= sa[0][2];\n                sa[0][3] <= sa[0][1];\n                sa[1][0] <= sa[1][3];\n                sa[1][1] <= sa[1][0];\n                sa[1][2] <= sa[1][1];\n                sa[1][3] <= sa[1][2];\n                sa[2][0] <= sa[2][2];\n                sa[2][1] <= sa[2][0];\n                sa[2][2] <= sa[2][3];\n                sa[2][3] <= sa[2][1];\n                sa[3][0] <= sa[3][1];\n                sa[3][1] <= sa[3][2];\n                sa[3][2] <= sa[3][3];\n                sa[3][3] <= sa[3][0];\n                // InvSubBytes\n                sa[0][0] <= us00;\n                sa[0][1] <= us01;\n                sa[0][2] <= us02;\n                sa[0][3] <= us03;\n                sa[1][0] <= us10;\n                sa[1][1] <= us11;\n                sa[1][2] <= us12;\n                sa[1][3] <= us13;\n                sa[2][0] <= us20;\n                sa[2][1] <= us21;\n                sa[2][2] <= us22;\n                sa[2][3] <= us23;\n                sa[3][0] <= us30;\n                sa[3][1] <= us31;\n                sa[3][2] <= us32;\n                sa[3][3] <= us33;\n                // AddRoundKey\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ kb[dcnt + j];\n                    end\n                end\n                // InvMixColumns\n                for (int i = 0; i < 4; i++) begin\n                    int out0 = 0;\n                    int out1 = 0;\n                    int out2 = 0;\n                    int out3 = 0;\n                    for (int j = 0; j < 4; j++) begin\n                        out0 = out0 ^ (sa[i][j] * 0x0E);\n                        out1 = out1 ^ (sa[i][j] * 0x0B);\n                        out2 = out2 ^ (sa[i][j] * 0x0D);\n                        out3 = out3 ^ (sa[i][j] * 0x09);\n                    end\n                    sa[i][0] <= out0;\n                    sa[i][1] <= out1;\n                    sa[i][2] <= out2;\n                    sa[i][3] <= out3;\n                end\n                dcnt <= dcnt + 1;\n            end\n        end\n        else begin\n            // FinalRound State\n            // InvShiftRows\n            sa[0][0] <= sa[0][0];\n            sa[0][1] <= sa[0][3];\n            sa[0][2] <= sa[0][2];\n            sa[0][3] <= sa[0][1];\n            sa[1][0] <= sa[1][3];\n            sa[1][1] <= sa[1][0];\n            sa[1][2] <= sa[1][1];\n            sa[1][3] <= sa[1][2];\n            sa[2][0] <= sa[2][2];\n            sa[2][1] <= sa[2][0];\n            sa[2][2] <= sa[2][3];\n            sa[2][3] <= sa[2][1];\n            sa[3][0] <= sa[3][1];\n            sa[3][1] <= sa[3][2];\n            sa[3][2] <= sa[3][3];\n            sa[3][3] <= sa[3][0];\n            // InvSubBytes\n            sa[0][0] <= us00;\n            sa[0][1] <= us01;\n            sa[0][2] <= us02;\n            sa[0][3] <= us03;\n            sa[1][0] <= us10;\n            sa[1][1] <= us11;\n            sa[1][2] <= us12;\n            sa[1][3] <= us13;\n            sa[2][0] <= us20;\n            sa[2][1] <= us21;\n            sa[2][2] <= us22;\n            sa[2][3] <= us23;\n            sa[3][0] <= us30;\n            sa[3][1] <= us31;\n            sa[3][2] <= us32;\n            sa[3][3] <= us33;\n            // AddRoundKey\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ kb[dcnt + j];\n                end\n            end\n            // Output Generation\n            text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                        sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                        sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                        sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n            done <= 1;\n        end\n    end\n\n    assign done = (dcnt == 11 && !ld_r);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 3, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox aes_inv_sbox[0:15] (\n        .a(sa[0][0]),\n        .b(us00)\n    );\n    aes_inv_sbox aes_inv_sbox[16:31] (\n        .a(sa[0][1]),\n        .b(us01)\n    );\n    aes_inv_sbox aes_inv_sbox[32:47] (\n        .a(sa[0][2]),\n        .b(us02)\n    );\n    aes_inv_sbox aes_inv_sbox[48:63] (\n        .a(sa[0][3]),\n        .b(us03)\n    );\n    aes_inv_sbox aes_inv_sbox[64:79] (\n        .a(sa[1][0]),\n        .b(us10)\n    );\n    aes_inv_sbox aes_inv_sbox[80:95] (\n        .a(sa[1][1]),\n        .b(us11)\n    );\n    aes_inv_sbox aes_inv_sbox[96:111] (\n        .a(sa[1][2]),\n        .b(us12)\n    );\n    aes_inv_sbox aes_inv_sbox[112:127] (\n        .a(sa[1][3]),\n        .b(us13)\n    );\n    aes_inv_sbox aes_inv_sbox[128:143] (\n        .a(sa[2][0]),\n        .b(us20)\n    );\n    aes_inv_sbox aes_inv_sbox[144:159] (\n        .a(sa[2][1]),\n        .b(us21)\n    );\n    aes_inv_sbox aes_inv_sbox[160:175] (\n        .a(sa[2][2]),\n        .b(us22)\n    );\n    aes_inv_sbox aes_inv_sbox[176:191] (\n        .a(sa[2][3]),\n        .b(us23)\n    );\n    aes_inv_sbox aes_inv_sbox[192:207] (\n        .a(sa[3][0]),\n        .b(us30)\n    );\n    aes_inv_sbox aes_inv_sbox[208:223] (\n        .a(sa[3][1]),\n        .b(us31)\n    );\n    aes_inv_sbox aes_inv_sbox[224:239] (\n        .a(sa[3][2]),\n        .b(us32)\n    );\n    aes_inv_sbox aes_inv_sbox[240:255] (\n        .a(sa[3][3]),\n        .b(us33)\n    );\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end\n        else if (kld) begin\n            // Key Load State\n            kcnt <= 0xA;\n            ld_r <= 1;\n        end\n        else if (ld) begin\n            // InitialRound State\n            if (dcnt == 0) begin\n                // Initial Round Key Addition\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= text_in_r[8 * (i * 4 + j) +: 8] ^ kb[10 + 4 * j + i];\n                    end\n                end\n                dcnt <= dcnt + 1;\n            end\n            else if (dcnt < 11) begin\n                // Standard Round State\n                // InvShiftRows\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        case (i)\n                            0: sa[i][j] <= sa[i][j];\n                            1: sa[i][j] <= sa[i][j + 3];\n                            2: sa[i][j] <= sa[i][j + 2];\n                            3: sa[i][j] <= sa[i][j + 1];\n                        endcase\n                    end\n                end\n                // InvSubBytes\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        case (sa[i][j])\n                            0: sa[i][j] <= us00;\n                            1: sa[i][j] <= us01;\n                            2: sa[i][j] <= us02;\n                            3: sa[i][j] <= us03;\n                            4: sa[i][j] <= us10;\n                            5: sa[i][j] <= us11;\n                            6: sa[i][j] <= us12;\n                            7: sa[i][j] <= us13;\n                            8: sa[i][j] <= us20;\n                            9: sa[i][j] <= us21;\n                            10: sa[i][j] <= us22;\n                            11: sa[i][j] <= us23;\n                            12: sa[i][j] <= us30;\n                            13: sa[i][j] <= us31;\n                            14: sa[i][j] <= us32;\n                            15: sa[i][j] <= us33;\n                        endcase\n                    end\n                end\n                // AddRoundKey\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ kb[10 + 4 * j + i];\n                    end\n                end\n                // InvMixColumns\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        case (i)\n                            0: sa[i][j] <= (sa[i][j] * 0x0E) ^ (sa[i + 1][j] * 0x0B) ^ (sa[i + 2][j] * 0x0D) ^ (sa[i + 3][j] * 0x09);\n                            1: sa[i][j] <= (sa[i][j] * 0x09) ^ (sa[i + 1][j] * 0x0E) ^ (sa[i + 2][j] * 0x0B) ^ (sa[i + 3][j] * 0x0D);\n                            2: sa[i][j] <= (sa[i][j] * 0x0D) ^ (sa[i + 1][j] * 0x09) ^ (sa[i + 2][j] * 0x0E) ^ (sa[i + 3][j] * 0x0B);\n                            3: sa[i][j] <= (sa[i][j] * 0x0B) ^ (sa[i + 1][j] * 0x0D) ^ (sa[i + 2][j] * 0x09) ^ (sa[i + 3][j] * 0x0E);\n                        endcase\n                    end\n                end\n                dcnt <= dcnt + 1;\n            end\n            else begin\n                // FinalRound State\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        case (i)\n                            0: sa[i][j] <= sa[i][j];\n                            1: sa[i][j] <= sa[i][j + 3];\n                            2: sa[i][j] <= sa[i][j + 2];\n                            3: sa[i][j] <= sa[i][j + 1];\n                        endcase\n                    end\n                end\n                // InvSubBytes\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        case (sa[i][j])\n                            0: sa[i][j] <= us00;\n                            1: sa[i][j] <= us01;\n                            2: sa[i][j] <= us02;\n                            3: sa[i][j] <= us03;\n                            4: sa[i][j] <= us10;\n                            5: sa[i][j] <= us11;\n                            6: sa[i][j] <= us12;\n                            7: sa[i][j] <= us13;\n                            8: sa[i][j] <= us20;\n                            9: sa[i][j] <= us21;\n                            10: sa[i][j] <= us22;\n                            11: sa[i][j] <= us23;\n                            12: sa[i][j] <= us30;\n                            13: sa[i][j] <= us31;\n                            14: sa[i][j] <= us32;\n                            15: sa[i][j] <= us33;\n                        endcase\n                    end\n                end\n                // AddRoundKey\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ kb[10 + 4 * j + i];\n                    end\n                end\n                dcnt <= dcnt + 1;\n            end\n        end\n        else if (dcnt == 11) begin\n            // Done State\n            done <= 1;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out[8 * (i * 4 + j) +: 8] <= sa[i][j];\n                end\n            end\n        end\n        else begin\n            // Idle State\n            done <= 0;\n        end\n    end\n\n    // Key Expansion\n    always @(posedge clk) begin\n        if (rst) begin\n            kcnt <= 0xA;\n            for (int i = 0; i < 11; i++) begin\n                kb[i] <= 0;\n            end\n        end\n        else if (kld) begin\n            kcnt <= 0xA;\n            for (int i = 0; i < 11; i++) begin\n                kb[i] <= 0;\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    kb[10 + 4 * j + i] <= wk3[32 * i + 8 * j +: 8];\n                end\n            end\n        end\n        else if (kcnt > 0) begin\n            kcnt <= kcnt - 1;\n        end\n    end\n\n    // Output Generation\n    always @(posedge clk) begin\n        if (rst) begin\n            text_out <= 0;\n        end\n        else if (ld) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out[8 * (i * 4 + j) +: 8] <= sa[i][j];\n                end\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 4, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // State Transition Diagram\n    enum logic [2:0] {IDLE, KeyLoad, KeyExpansion, KeyStored, InitialRound, StandardRound, FinalRound, Done} state;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expand_128 (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox aes_inv_sbox_00 (\n        .a(sa[0][0]),\n        .b(us00)\n    );\n    aes_inv_sbox aes_inv_sbox_01 (\n        .a(sa[0][1]),\n        .b(us01)\n    );\n    aes_inv_sbox aes_inv_sbox_02 (\n        .a(sa[0][2]),\n        .b(us02)\n    );\n    aes_inv_sbox aes_inv_sbox_03 (\n        .a(sa[0][3]),\n        .b(us03)\n    );\n    aes_inv_sbox aes_inv_sbox_10 (\n        .a(sa[1][0]),\n        .b(us10)\n    );\n    aes_inv_sbox aes_inv_sbox_11 (\n        .a(sa[1][1]),\n        .b(us11)\n    );\n    aes_inv_sbox aes_inv_sbox_12 (\n        .a(sa[1][2]),\n        .b(us12)\n    );\n    aes_inv_sbox aes_inv_sbox_13 (\n        .a(sa[1][3]),\n        .b(us13)\n    );\n    aes_inv_sbox aes_inv_sbox_20 (\n        .a(sa[2][0]),\n        .b(us20)\n    );\n    aes_inv_sbox aes_inv_sbox_21 (\n        .a(sa[2][1]),\n        .b(us21)\n    );\n    aes_inv_sbox aes_inv_sbox_22 (\n        .a(sa[2][2]),\n        .b(us22)\n    );\n    aes_inv_sbox aes_inv_sbox_23 (\n        .a(sa[2][3]),\n        .b(us23)\n    );\n    aes_inv_sbox aes_inv_sbox_30 (\n        .a(sa[3][0]),\n        .b(us30)\n    );\n    aes_inv_sbox aes_inv_sbox_31 (\n        .a(sa[3][1]),\n        .b(us31)\n    );\n    aes_inv_sbox aes_inv_sbox_32 (\n        .a(sa[3][2]),\n        .b(us32)\n    );\n    aes_inv_sbox aes_inv_sbox_33 (\n        .a(sa[3][3]),\n        .b(us33)\n    );\n\n    // State Matrix Initialization\n    always @(posedge clk) begin\n        if (rst) begin\n            state <= IDLE;\n            dcnt <= 0;\n            kcnt <= 10;\n            ld_r <= 0;\n            text_in_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end\n        else if (ld) begin\n            state <= KeyLoad;\n            dcnt <= 1;\n            kcnt <= 10;\n            ld_r <= 1;\n            text_in_r <= text_in;\n        end\n        else if (state == KeyLoad) begin\n            if (kld) begin\n                state <= KeyExpansion;\n                kcnt <= 10;\n            end\n        end\n        else if (state == KeyExpansion) begin\n            if (kcnt > 0) begin\n                kb[kcnt] <= wk3;\n                kcnt <= kcnt - 1;\n            end\n            else begin\n                state <= KeyStored;\n            end\n        end\n        else if (state == KeyStored) begin\n            if (ld) begin\n                state <= InitialRound;\n                dcnt <= 1;\n            end\n        end\n        else if (state == InitialRound) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8 * (i * 4 + j) + 7:8 * (i * 4 + j)];\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ kb[dcnt];\n                end\n            end\n            dcnt <= dcnt + 1;\n            state <= StandardRound;\n        end\n        else if (state == StandardRound) begin\n            if (dcnt < 11) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= InvShiftRows(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= InvSubBytes(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ kb[dcnt];\n                    end\n                end\n                dcnt <= dcnt + 1;\n            end\n            else begin\n                state <= FinalRound;\n            end\n        end\n        else if (state == FinalRound) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= InvShiftRows(sa[i][j]);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= InvSubBytes(sa[i][j]);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ kb[dcnt];\n                end\n            end\n            state <= Done;\n        end\n        else if (state == Done) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out[8 * (i * 4 + j) + 7:8 * (i * 4 + j)] <= sa[i][j];\n                end\n            end\n            done <= 1;\n            state <= IDLE;\n        end\n    end\n\n    // InvShiftRows\n    function [7:0] InvShiftRows([7:0] a);\n        case (a[7:4])\n            8'd0: InvShiftRows = a;\n            8'd1: InvShiftRows = {a[3], a[0], a[1], a[2]};\n            8'd2: InvShiftRows = {a[2], a[3], a[0], a[1]};\n            8'd3: InvShiftRows = {a[1], a[2], a[3], a[0]};\n            default: InvShiftRows = a;\n        endcase\n    endfunction\n\n    // InvSubBytes\n    function [7:0] InvSubBytes([7:0] a);\n        case (a)\n            8'd0: InvSubBytes = 8'd13;\n            8'd1: InvSubBytes = 8'd14;\n            8'd2: InvSubBytes = 8'd15;\n            8'd3: InvSubBytes = 8'd9;\n            8'd4: InvSubBytes = 8'd8;\n            8'd5: InvSubBytes = 8'd12;\n            8'd6: InvSubBytes = 8'd16;\n            8'd7: InvSubBytes = 8'd3;\n            8'd8: InvSubBytes = 8'd4;\n            8'd9: InvSubBytes = 8'd1;\n            8'd10: InvSubBytes = 8'd5;\n            8'd11: InvSubBytes = 8'd11;\n            8'd12: InvSubBytes = 8'd6;\n            8'd13: InvSubBytes = 8'd7;\n            8'd14: InvSubBytes = 8'd2;\n            8'd15: InvSubBytes = 8'd15;\n            default: InvSubBytes = a;\n        endcase\n    endfunction\n\n    // InvMixColumns\n    function [7:0] InvMixColumns([7:0] a);\n        case (a[7:4])\n            8'd0: InvMixColumns = {pmul_e(a[3]), pmul_b(a[2]), pmul_d(a[1]), pmul_9(a[0])};\n            8'd1: InvMixColumns = {pmul_9(a[3]), pmul_e(a[2]), pmul_b(a[1]), pmul_d(a[0])};\n            8'd2: InvMixColumns = {pmul_d(a[3]), pmul_9(a[2]), pmul_e(a[1]), pmul_b(a[0])};\n            8'd3: InvMixColumns = {pmul_b(a[3]), pmul_d(a[2]), pmul_9(a[1]), pmul_e(a[0])};\n            default: InvMixColumns = a;\n        endcase\n    endfunction\n\n    // Pre-computed polynomial multiplications\n    function [7:0] pmul_e([7:0] a);\n        case (a)\n            8'd0: pmul_e = 8'd14;\n            8'd1: pmul_e = 8'd9;\n            8'd2: pmul_e = 8'd13;\n            8'd3: pmul_e = 8'd12;\n            8'd4: pmul_e = 8'd8;\n            8'd5: pmul_e = 8'd7;\n            8'd6: pmul_e = 8'd4;\n            8'd7: pmul_e = 8'd1;\n            8'd8: pmul_e = 8'd15;\n            8'd9: pmul_e = 8'd14;\n            8'd10: pmul_e = 8'd13;\n            8'd11: pmul_e = 8'd12;\n            8'd12: pmul_e = 8'd11;\n            8'd13: pmul_e = 8'd10;\n            8'd14: pmul_e = 8'd9;\n            8'd15: pmul_e = 8'd8;\n            default: pmul_e = a;\n        endcase\n    endfunction\n\n    function [7:0] pmul_b([7:0] a);\n        case (a)\n            8'd0: pmul_b = 8'd9;\n            8'd1: pmul_b = 8'd14;\n            8'd2: pmul_b = 8'd15;\n            8'd3: pmul_b = 8'd12;\n            8'd4: pmul_b = 8'd8;\n            8'd5: pmul_b = 8'd16;\n            8'd6: pmul_b = 8'd3;\n            8'd7: pmul_b = 8'd10;\n            8'd8: pmul_b = 8'd6;\n            8'd9: pmul_b = 8'd13;\n            8'd10: pmul_b = 8'd1;\n            8'd11: pmul_b = 8'd4;\n            8'd12: pmul_b = 8'd11;\n            8'd13: pmul_b = 8'd15;\n            8'd14: pmul_b = 8'd14;\n            8'd15: pmul_b = 8'd8;\n            default: pmul_b = a;\n        endcase\n    endfunction\n\n    function [7:0] pmul_d([7:0] a);\n        case (a)\n            8'd0: pmul_d = 8'd13;\n            8'd1: pmul_d = 8'd8;\n            8'd2: pmul_d = 8'd11;\n            8'd3: pmul_d = 8'd6;\n            8'd4: pmul_d = 8'd3;\n            8'd5: pmul_d = 8'd4;\n            8'd6: pmul_d = 8'd1;\n            8'd7: pmul_d = 8'd12;\n            8'd8: pmul_d = 8'd5;\n            8'd9: pmul_d = 8'd9;\n            8'd10: pmul_d = 8'd14;\n            8'd11: pmul_d = 8'd15;\n            8'd12: pmul_d = 8'd10;\n            8'd13: pmul_d = 8'd7;\n            8'd14: pmul_d = 8'd16;\n            8'd15: pmul_d = 8'd13;\n            default: pmul_d = a;\n        endcase\n    endfunction\n\n    function [7:0] pmul_9([7:0] a);\n        case (a)\n            8'd0: pmul_9 = 8'd9;\n            8'd1: pmul_9 = 8'd2;\n            8'd2: pmul_9 = 8'd13;\n            8'd3: pmul_9 = 8'd8;\n            8'd4: pmul_9 = 8'd3;\n            8'd5: pmul_9 = 8'd4;\n            8'd6: pmul_9 = 8'd1;\n            8'd7: pmul_9 = 8'd12;\n            8'd8: pmul_9 = 8'd5;\n            8'd9: pmul_9 = 8'd9;\n            8'd10: pmul_9 = 8'd14;\n            8'd11: pmul_9 = 8'd15;\n            8'd12: pmul_9 = 8'd10;\n            8'd13: pmul_9 = 8'd7;\n            8'd14: pmul_9 = 8'd16;\n            8'd15: pmul_9 = 8'd13;\n            default: pmul_9 = a;\n        endcase\n    endfunction\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 5, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    wire [7:0] w3, w2, w1, w0;\n\n    // Key Expansion Module\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    // Inverse S-box Module\n    aes_inv_sbox aes_inv_sbox_00(\n        .a(sa[0][0]),\n        .b(us00)\n    );\n    aes_inv_sbox aes_inv_sbox_01(\n        .a(sa[0][1]),\n        .b(us01)\n    );\n    aes_inv_sbox aes_inv_sbox_02(\n        .a(sa[0][2]),\n        .b(us02)\n    );\n    aes_inv_sbox aes_inv_sbox_03(\n        .a(sa[0][3]),\n        .b(us03)\n    );\n    aes_inv_sbox aes_inv_sbox_10(\n        .a(sa[1][0]),\n        .b(us10)\n    );\n    aes_inv_sbox aes_inv_sbox_11(\n        .a(sa[1][1]),\n        .b(us11)\n    );\n    aes_inv_sbox aes_inv_sbox_12(\n        .a(sa[1][2]),\n        .b(us12)\n    );\n    aes_inv_sbox aes_inv_sbox_13(\n        .a(sa[1][3]),\n        .b(us13)\n    );\n    aes_inv_sbox aes_inv_sbox_20(\n        .a(sa[2][0]),\n        .b(us20)\n    );\n    aes_inv_sbox aes_inv_sbox_21(\n        .a(sa[2][1]),\n        .b(us21)\n    );\n    aes_inv_sbox aes_inv_sbox_22(\n        .a(sa[2][2]),\n        .b(us22)\n    );\n    aes_inv_sbox aes_inv_sbox_23(\n        .a(sa[2][3]),\n        .b(us23)\n    );\n    aes_inv_sbox aes_inv_sbox_30(\n        .a(sa[3][0]),\n        .b(us30)\n    );\n    aes_inv_sbox aes_inv_sbox_31(\n        .a(sa[3][1]),\n        .b(us31)\n    );\n    aes_inv_sbox aes_inv_sbox_32(\n        .a(sa[3][2]),\n        .b(us32)\n    );\n    aes_inv_sbox aes_inv_sbox_33(\n        .a(sa[3][3]),\n        .b(us33)\n    );\n\n    // InvShiftRows\n    always @(posedge clk) begin\n        if (ld_r == 1) begin\n            sa[0][0] <= text_in_r[7:0];\n            sa[0][1] <= text_in_r[15:8];\n            sa[0][2] <= text_in_r[23:16];\n            sa[0][3] <= text_in_r[31:24];\n            sa[1][0] <= text_in_r[39:32];\n            sa[1][1] <= text_in_r[47:40];\n            sa[1][2] <= text_in_r[55:48];\n            sa[1][3] <= text_in_r[63:56];\n            sa[2][0] <= text_in_r[79:72];\n            sa[2][1] <= text_in_r[87:80];\n            sa[2][2] <= text_in_r[95:88];\n            sa[2][3] <= text_in_r[103:96];\n            sa[3][0] <= text_in_r[111:104];\n            sa[3][1] <= text_in_r[119:112];\n            sa[3][2] <= text_in_r[127:120];\n        end else begin\n            // InvShiftRows\n            reg [7:0] temp;\n            temp[7:0] = sa[0][3];\n            sa[0][3] = sa[0][2];\n            sa[0][2] = sa[0][1];\n            sa[0][1] = sa[0][0];\n            sa[0][0] = temp[7:0];\n            temp[7:0] = sa[1][3];\n            sa[1][3] = sa[1][2];\n            sa[1][2] = sa[1][1];\n            sa[1][1] = sa[1][0];\n            sa[1][0] = temp[7:0];\n            temp[7:0] = sa[2][3];\n            sa[2][3] = sa[2][2];\n            sa[2][2] = sa[2][1];\n            sa[2][1] = sa[2][0];\n            sa[2][0] = temp[7:0];\n            temp[7:0] = sa[3][3];\n            sa[3][3] = sa[3][2];\n            sa[3][2] = sa[3][1];\n            sa[3][1] = sa[3][0];\n            sa[3][0] = temp[7:0];\n        end\n    end\n\n    // InvSubBytes\n    always @(posedge clk) begin\n        if (ld_r == 1) begin\n            sa[0][0] <= us00;\n            sa[0][1] <= us01;\n            sa[0][2] <= us02;\n            sa[0][3] <= us03;\n            sa[1][0] <= us10;\n            sa[1][1] <= us11;\n            sa[1][2] <= us12;\n            sa[1][3] <= us13;\n            sa[2][0] <= us20;\n            sa[2][1] <= us21;\n            sa[2][2] <= us22;\n            sa[2][3] <= us23;\n            sa[3][0] <= us30;\n            sa[3][1] <= us31;\n            sa[3][2] <= us32;\n            sa[3][3] <= us33;\n        end\n    end\n\n    // AddRoundKey\n    always @(posedge clk) begin\n        if (ld_r == 1) begin\n            sa[0][0] <= sa[0][0] ^ wk0[0];\n            sa[0][1] <= sa[0][1] ^ wk0[1];\n            sa[0][2] <= sa[0][2] ^ wk0[2];\n            sa[0][3] <= sa[0][3] ^ wk0[3];\n            sa[1][0] <= sa[1][0] ^ wk1[0];\n            sa[1][1] <= sa[1][1] ^ wk1[1];\n            sa[1][2] <= sa[1][2] ^ wk1[2];\n            sa[1][3] <= sa[1][3] ^ wk1[3];\n            sa[2][0] <= sa[2][0] ^ wk2[0];\n            sa[2][1] <= sa[2][1] ^ wk2[1];\n            sa[2][2] <= sa[2][2] ^ wk2[2];\n            sa[2][3] <= sa[2][3] ^ wk2[3];\n            sa[3][0] <= sa[3][0] ^ wk3[0];\n            sa[3][1] <= sa[3][1] ^ wk3[1];\n            sa[3][2] <= sa[3][2] ^ wk3[2];\n            sa[3][3] <= sa[3][3] ^ wk3[3];\n        end\n    end\n\n    // InvMixColumns\n    always @(posedge clk) begin\n        if (ld_r == 1) begin\n            reg [7:0] temp;\n            temp[7:0] = sa[0][0];\n            sa[0][0] = (sa[0][0] << 1) ^ (sa[1][0] << 3) ^ (sa[2][0] << 2) ^ (sa[3][0] << 1);\n            sa[1][0] = (sa[0][1] << 1) ^ (sa[1][1] << 3) ^ (sa[2][1] << 2) ^ (sa[3][1] << 1);\n            sa[2][0] = (sa[0][2] << 1) ^ (sa[1][2] << 3) ^ (sa[2][2] << 2) ^ (sa[3][2] << 1);\n            sa[3][0] = (sa[0][3] << 1) ^ (sa[1][3] << 3) ^ (sa[2][3] << 2) ^ (sa[3][3] << 1);\n            temp[7:0] = sa[0][1];\n            sa[0][1] = (sa[0][1] << 1) ^ (sa[1][1] << 3) ^ (sa[2][1] << 2) ^ (sa[3][1] << 1);\n            sa[1][1] = (sa[0][2] << 1) ^ (sa[1][2] << 3) ^ (sa[2][2] << 2) ^ (sa[3][2] << 1);\n            sa[2][1] = (sa[0][3] << 1) ^ (sa[1][3] << 3) ^ (sa[2][3] << 2) ^ (sa[3][3] << 1);\n            sa[3][1] = (sa[0][0] << 1) ^ (sa[1][0] << 3) ^ (sa[2][0] << 2) ^ (sa[3][0] << 1);\n            temp[7:0] = sa[0][2];\n            sa[0][2] = (sa[0][2] << 1) ^ (sa[1][2] << 3) ^ (sa[2][2] << 2) ^ (sa[3][2] << 1);\n            sa[1][2] = (sa[0][3] << 1) ^ (sa[1][3] << 3) ^ (sa[2][3] << 2) ^ (sa[3][3] << 1);\n            sa[2][2] = (sa[0][0] << 1) ^ (sa[1][0] << 3) ^ (sa[2][0] << 2) ^ (sa[3][0] << 1);\n            sa[3][2] = (sa[0][1] << 1) ^ (sa[1][1] << 3) ^ (sa[2][1] << 2) ^ (sa[3][1] << 1);\n            temp[7:0] = sa[0][3];\n            sa[0][3] = (sa[0][3] << 1) ^ (sa[1][3] << 3) ^ (sa[2][3] << 2) ^ (sa[3][3] << 1);\n            sa[1][3] = (sa[0][0] << 1) ^ (sa[1][0] << 3) ^ (sa[2][0] << 2) ^ (sa[3][0] << 1);\n            sa[2][3] = (sa[0][1] << 1) ^ (sa[1][1] << 3) ^ (sa[2][1] << 2) ^ (sa[3][1] << 1);\n            sa[3][3] = (sa[0][2] << 1) ^ (sa[1][2] << 3) ^ (sa[2][2] << 2) ^ (sa[3][2] << 1);\n        end\n    end\n\n    // Output Generation\n    always @(posedge clk) begin\n        if (ld_r == 1) begin\n            text_out[7:0] = sa[0][0];\n            text_out[15:8] = sa[0][1];\n            text_out[23:16] = sa[0][2];\n            text_out[31:24] = sa[0][3];\n            text_out[39:32] = sa[1][0];\n            text_out[47:40] = sa[1][1];\n            text_out[55:48] = sa[1][2];\n            text_out[63:56] = sa[1][3];\n            text_out[79:72] = sa[2][0];\n            text_out[87:80] = sa[2][1];\n            text_out[95:88] = sa[2][2];\n            text_out[103:96] = sa[2][3];\n            text_out[111:104] = sa[3][0];\n            text_out[119:112] = sa[3][1];\n            text_out[127:120] = sa[3][2];\n        end\n    end\n\n    // State Transition Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            ld_r <= 0;\n            kcnt <= 10;\n            kb[10:0] <= 0;\n            text_in_r <= 0;\n            text_out <= 0;\n        end else if (kld) begin\n            kcnt <= 10;\n            kb[10:0] <= 0;\n            text_in_r <= 0;\n            ld_r <= 0;\n        end else if (ld) begin\n            ld_r <= 1;\n            dcnt <= 1;\n        end else if (dcnt == 11) begin\n            ld_r <= 0;\n            done <= 1;\n        end else if (ld_r == 1) begin\n            if (dcnt == 1) begin\n                // Initial Round\n                sa[0][0] <= text_in_r[7:0];\n                sa[0][1] <= text_in_r[15:8];\n                sa[0][2] <= text_in_r[23:16];\n                sa[0][3] <= text_in_r[31:24];\n                sa[1][0] <= text_in_r[39:32];\n                sa[1][1] <= text_in_r[47:40];\n                sa[1][2] <= text_in_r[55:48];\n                sa[1][3] <= text_in_r[63:56];\n                sa[2][0] <= text_in_r[79:72];\n                sa[2][1] <= text_in_r[87:80];\n                sa[2][2] <= text_in_r[95:88];\n                sa[2][3] <= text_in_r[103:96];\n                sa[3][0] <= text_in_r[111:104];\n                sa[3][1] <= text_in_r[119:112];\n                sa[3][2] <= text_in_r[127:120];\n                dcnt <= 2;\n            end else if (dcnt < 11) begin\n                // Standard Round\n                InvShiftRows;\n                InvSubBytes;\n                AddRoundKey;\n                InvMixColumns;\n                dcnt <= dcnt + 1;\n            end\n        end\n    end\n\n    // Key Expansion Buffer\n    always @(posedge clk) begin\n        if (kcnt == 10) begin\n            kb[10] <= wk0;\n            kcnt <= kcnt - 1;\n        end else if (kcnt > 0) begin\n            kb[kcnt] <= wk0;\n            kcnt <= kcnt - 1;\n        end\n    end\n\n    // Output Timing Control\n    always @(posedge clk) begin\n        if (ld_r == 1) begin\n            text_out <= sa_ark;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 6, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    wire [7:0] sa_ark[0:3][0:3];\n    wire [7:0] sa_next[0:3][0:3];\n\n    // Key Expansion Module\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    // Inverse S-box Module\n    aes_inv_sbox aes_inv_sbox[0:15] (\n        .a(sa[0][0]),\n        .b(us00),\n        .a(sa[0][1]),\n        .b(us01),\n        .a(sa[0][2]),\n        .b(us02),\n        .a(sa[0][3]),\n        .b(us03),\n        .a(sa[1][0]),\n        .b(us10),\n        .a(sa[1][1]),\n        .b(us11),\n        .a(sa[1][2]),\n        .b(us12),\n        .a(sa[1][3]),\n        .b(us13),\n        .a(sa[2][0]),\n        .b(us20),\n        .a(sa[2][1]),\n        .b(us21),\n        .a(sa[2][2]),\n        .b(us22),\n        .a(sa[2][3]),\n        .b(us23),\n        .a(sa[3][0]),\n        .b(us30),\n        .a(sa[3][1]),\n        .b(us31),\n        .a(sa[3][2]),\n        .b(us32),\n        .a(sa[3][3]),\n        .b(us33)\n    );\n\n    // Round Transformation\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out <= 0;\n            kcnt <= 10;\n            for (int i = 0; i < 16; i++) begin\n                sa[i] <= 0;\n            end\n        end\n        else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n            for (int i = 0; i < 16; i++) begin\n                sa[i] <= text_in_r[7*i +: 8];\n            end\n            dcnt <= 1;\n            kcnt <= 10;\n        end\n        else if (ld_r) begin\n            ld_r <= 0;\n            for (int i = 0; i < 16; i++) begin\n                sa[i] <= text_in_r[7*i +: 8];\n            end\n        end\n        else if (dcnt < 11) begin\n            InvShiftRows(sa);\n            InvSubBytes(sa);\n            AddRoundKey(sa, wk3, wk2, wk1, wk0);\n            InvMixColumns(sa);\n            dcnt <= dcnt + 1;\n        end\n        else if (dcnt == 11) begin\n            InvShiftRows(sa);\n            InvSubBytes(sa);\n            AddRoundKey(sa, wk3, wk2, wk1, wk0);\n            text_out <= sa[0][0] << 120 | sa[1][0] << 112 | sa[2][0] << 104 | sa[3][0] << 96 |\n                        sa[0][1] << 88 | sa[1][1] << 80 | sa[2][1] << 72 | sa[3][1] << 64 |\n                        sa[0][2] << 56 | sa[1][2] << 48 | sa[2][2] << 40 | sa[3][2] << 32 |\n                        sa[0][3] << 24 | sa[1][3] << 16 | sa[2][3] << 8  | sa[3][3];\n            done <= 1;\n        end\n        else begin\n            done <= 0;\n        end\n    end\n\n    // InvShiftRows\n    task InvShiftRows();\n        for (int i = 1; i < 4; i++) begin\n            for (int j = 3; j >= i; j--) begin\n                sa[i][j] <= sa[i][j-1];\n            end\n        end\n    endtask\n\n    // InvSubBytes\n    task InvSubBytes();\n        for (int i = 0; i < 16; i++) begin\n            case (sa[i])\n                0: us[i] <= 0x52;\n                1: us[i] <= 0x09;\n                2: us[i] <= 0x6a;\n                3: us[i] <= 0xd5;\n                4: us[i] <= 0x30;\n                5: us[i] <= 0x5a;\n                6: us[i] <= 0x0a;\n                7: us[i] <= 0x0d;\n                8: us[i] <= 0x2f;\n                9: us[i] <= 0x8d;\n                10: us[i] <= 0x71;\n                11: us[i] <= 0x4d;\n                12: us[i] <= 0x93;\n                13: us[i] <= 0x17;\n                14: us[i] <= 0x38;\n                15: us[i] <= 0x7b;\n                default: us[i] <= 0;\n            endcase\n        end\n    endtask\n\n    // AddRoundKey\n    task AddRoundKey();\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa_ark[i][j] <= sa[i][j] ^ wk3[8*i + j];\n            end\n        end\n    endtask\n\n    // InvMixColumns\n    task InvMixColumns();\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa_next[i][j] <= (pmul_e(sa_ark[i][j]) << 1) ^ (pmul_b(sa_ark[i][j]) << 1) ^ (pmul_d(sa_ark[i][j]) << 1) ^ (pmul_9(sa_ark[i][j]) << 1) ^ sa_ark[i][j];\n            end\n        end\n    endtask\n\n    // Key Expansion Buffer\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < 11; i++) begin\n                kb[i] <= 0;\n            end\n        end\n        else if (kld) begin\n            for (int i = 0; i < 11; i++) begin\n                kb[i] <= wk3[32*i +: 32];\n            end\n        end\n    end\n\n    // Output Generation\n    always @(posedge clk) begin\n        if (rst) begin\n            text_out <= 0;\n        end\n        else if (ld) begin\n            text_out <= sa[0][0] << 120 | sa[1][0] << 112 | sa[2][0] << 104 | sa[3][0] << 96 |\n                        sa[0][1] << 88 | sa[1][1] << 80 | sa[2][1] << 72 | sa[3][1] << 64 |\n                        sa[0][2] << 56 | sa[1][2] << 48 | sa[2][2] << 40 | sa[3][2] << 32 |\n                        sa[0][3] << 24 | sa[1][3] << 16 | sa[2][3] << 8  | sa[3][3];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 7, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox us00(.a(sa[0][0]), .b(sb00));\n    aes_inv_sbox us01(.a(sa[0][1]), .b(sb01));\n    aes_inv_sbox us02(.a(sa[0][2]), .b(sb02));\n    aes_inv_sbox us03(.a(sa[0][3]), .b(sb03));\n    aes_inv_sbox us10(.a(sa[1][0]), .b(sb10));\n    aes_inv_sbox us11(.a(sa[1][1]), .b(sb11));\n    aes_inv_sbox us12(.a(sa[1][2]), .b(sb12));\n    aes_inv_sbox us13(.a(sa[1][3]), .b(sb13));\n    aes_inv_sbox us20(.a(sa[2][0]), .b(sb20));\n    aes_inv_sbox us21(.a(sa[2][1]), .b(sb21));\n    aes_inv_sbox us22(.a(sa[2][2]), .b(sb22));\n    aes_inv_sbox us23(.a(sa[2][3]), .b(sb23));\n    aes_inv_sbox us30(.a(sa[3][0]), .b(sb30));\n    aes_inv_sbox us31(.a(sa[3][1]), .b(sb31));\n    aes_inv_sbox us32(.a(sa[3][2]), .b(sb32));\n    aes_inv_sbox us33(.a(sa[3][3]), .b(sb33));\n\n    // State Transition Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_out <= 0;\n        end\n        else if (kld) begin\n            kcnt <= 0xA;\n            ld_r <= 0;\n        end\n        else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n            dcnt <= 1;\n        end\n        else if (dcnt == 0) begin\n            ld_r <= 0;\n            dcnt <= dcnt + 1;\n        end\n        else if (dcnt == 11) begin\n            done <= 1;\n            ld_r <= 0;\n        end\n        else begin\n            dcnt <= dcnt + 1;\n        end\n    end\n\n    // Key Expansion Logic\n    always @(posedge clk) begin\n        if (kld) begin\n            kcnt <= 0xA;\n            kb[10] <= wk3;\n            kb[9] <= wk2;\n            kb[8] <= wk1;\n            kb[7] <= wk0;\n            for (int i = 6; i >= 0; i--) begin\n                kb[i] <= kb[i+1];\n            end\n        end\n        else if (kcnt > 0) begin\n            kcnt <= kcnt - 1;\n        end\n    end\n\n    // Round Transformation Logic\n    always @(posedge clk) begin\n        if (ld_r) begin\n            // InvShiftRows\n            sa[0][0] <= text_in_r[7:0];\n            sa[0][1] <= text_in_r[15:8];\n            sa[0][2] <= text_in_r[23:16];\n            sa[0][3] <= text_in_r[31:24];\n            sa[1][0] <= text_in_r[39:32];\n            sa[1][1] <= text_in_r[47:40];\n            sa[1][2] <= text_in_r[55:48];\n            sa[1][3] <= text_in_r[63:56];\n            sa[2][0] <= text_in_r[79:72];\n            sa[2][1] <= text_in_r[87:80];\n            sa[2][2] <= text_in_r[95:88];\n            sa[2][3] <= text_in_r[103:96];\n            sa[3][0] <= text_in_r[111:104];\n            sa[3][1] <= text_in_r[119:112];\n            sa[3][2] <= text_in_r[127:120];\n            sa[3][3] <= text_in_r[135:128];\n\n            // InvSubBytes\n            sb00 <= us00.b;\n            sb01 <= us01.b;\n            sb02 <= us02.b;\n            sb03 <= us03.b;\n            sb10 <= us10.b;\n            sb11 <= us11.b;\n            sb12 <= us12.b;\n            sb13 <= us13.b;\n            sb20 <= us20.b;\n            sb21 <= us21.b;\n            sb22 <= us22.b;\n            sb23 <= us23.b;\n            sb30 <= us30.b;\n            sb31 <= us31.b;\n            sb32 <= us32.b;\n            sb33 <= us33.b;\n\n            // AddRoundKey\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ kb[dcnt + j * 4 + i];\n                end\n            end\n\n            // InvMixColumns\n            sa_next[0] <= (sa[0][0] * 0x0E) ^ (sa[1][0] * 0x0B) ^ (sa[2][0] * 0x0D) ^ (sa[3][0] * 0x09);\n            sa_next[1] <= (sa[0][1] * 0x0E) ^ (sa[1][1] * 0x0B) ^ (sa[2][1] * 0x0D) ^ (sa[3][1] * 0x09);\n            sa_next[2] <= (sa[0][2] * 0x0D) ^ (sa[1][2] * 0x09) ^ (sa[2][2] * 0x0E) ^ (sa[3][2] * 0x0B);\n            sa_next[3] <= (sa[0][3] * 0x09) ^ (sa[1][3] * 0x0E) ^ (sa[2][3] * 0x0B) ^ (sa[3][3] * 0x0D);\n\n            // Update State Matrix\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa_next[i][j];\n                end\n            end\n        end\n        else begin\n            // InvShiftRows\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    if (i == 0) begin\n                        sa[i][j] <= sa[i][j];\n                    end\n                    else if (i == 1) begin\n                        sa[i][j] <= sa[i][j + 3];\n                    end\n                    else if (i == 2) begin\n                        sa[i][j] <= sa[i][j + 2];\n                    end\n                    else if (i == 3) begin\n                        sa[i][j] <= sa[i][j + 1];\n                    end\n                end\n            end\n\n            // InvSubBytes\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= us[i * 4 + j].b;\n                end\n            end\n\n            // AddRoundKey\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ kb[dcnt + j * 4 + i];\n                end\n            end\n\n            // InvMixColumns\n            sa_next[0] <= (sa[0][0] * 0x0E) ^ (sa[1][0] * 0x0B) ^ (sa[2][0] * 0x0D) ^ (sa[3][0] * 0x09);\n            sa_next[1] <= (sa[0][1] * 0x0E) ^ (sa[1][1] * 0x0B) ^ (sa[2][1] * 0x0D) ^ (sa[3][1] * 0x09);\n            sa_next[2] <= (sa[0][2] * 0x0D) ^ (sa[1][2] * 0x09) ^ (sa[2][2] * 0x0E) ^ (sa[3][2] * 0x0B);\n            sa_next[3] <= (sa[0][3] * 0x09) ^ (sa[1][3] * 0x0E) ^ (sa[2][3] * 0x0B) ^ (sa[3][3] * 0x0D);\n\n            // Update State Matrix\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa_next[i][j];\n                end\n            end\n        end\n    end\n\n    // Output Logic\n    always @(posedge clk) begin\n        if (ld_r) begin\n            text_out <= text_in_r;\n        end\n        else begin\n            text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                        sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                        sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                        sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 8, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    wire [7:0] sa_ark[0:3][0:3];\n    wire [7:0] sa_next[0:3][0:3];\n\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox us00(\n        .a(sa[0][0]),\n        .b(sa_ark[0][0])\n    );\n    aes_inv_sbox us01(\n        .a(sa[0][1]),\n        .b(sa_ark[0][1])\n    );\n    aes_inv_sbox us02(\n        .a(sa[0][2]),\n        .b(sa_ark[0][2])\n    );\n    aes_inv_sbox us03(\n        .a(sa[0][3]),\n        .b(sa_ark[0][3])\n    );\n    aes_inv_sbox us10(\n        .a(sa[1][0]),\n        .b(sa_ark[1][0])\n    );\n    aes_inv_sbox us11(\n        .a(sa[1][1]),\n        .b(sa_ark[1][1])\n    );\n    aes_inv_sbox us12(\n        .a(sa[1][2]),\n        .b(sa_ark[1][2])\n    );\n    aes_inv_sbox us13(\n        .a(sa[1][3]),\n        .b(sa_ark[1][3])\n    );\n    aes_inv_sbox us20(\n        .a(sa[2][0]),\n        .b(sa_ark[2][0])\n    );\n    aes_inv_sbox us21(\n        .a(sa[2][1]),\n        .b(sa_ark[2][1])\n    );\n    aes_inv_sbox us22(\n        .a(sa[2][2]),\n        .b(sa_ark[2][2])\n    );\n    aes_inv_sbox us23(\n        .a(sa[2][3]),\n        .b(sa_ark[2][3])\n    );\n    aes_inv_sbox us30(\n        .a(sa[3][0]),\n        .b(sa_ark[3][0])\n    );\n    aes_inv_sbox us31(\n        .a(sa[3][1]),\n        .b(sa_ark[3][1])\n    );\n    aes_inv_sbox us32(\n        .a(sa[3][2]),\n        .b(sa_ark[3][2])\n    );\n    aes_inv_sbox us33(\n        .a(sa[3][3]),\n        .b(sa_ark[3][3])\n    );\n\n    assign sa_ark[0][0] = us00.b;\n    assign sa_ark[0][1] = us01.b;\n    assign sa_ark[0][2] = us02.b;\n    assign sa_ark[0][3] = us03.b;\n    assign sa_ark[1][0] = us10.b;\n    assign sa_ark[1][1] = us11.b;\n    assign sa_ark[1][2] = us12.b;\n    assign sa_ark[1][3] = us13.b;\n    assign sa_ark[2][0] = us20.b;\n    assign sa_ark[2][1] = us21.b;\n    assign sa_ark[2][2] = us22.b;\n    assign sa_ark[2][3] = us23.b;\n    assign sa_ark[3][0] = us30.b;\n    assign sa_ark[3][1] = us31.b;\n    assign sa_ark[3][2] = us32.b;\n    assign sa_ark[3][3] = us33.b;\n\n    assign sa_next[0][0] = sa_ark[0][0];\n    assign sa_next[0][1] = sa_ark[0][1];\n    assign sa_next[0][2] = sa_ark[0][2];\n    assign sa_next[0][3] = sa_ark[0][3];\n    assign sa_next[1][0] = sa_ark[1][0];\n    assign sa_next[1][1] = sa_ark[1][1];\n    assign sa_next[1][2] = sa_ark[1][2];\n    assign sa_next[1][3] = sa_ark[1][3];\n    assign sa_next[2][0] = sa_ark[2][0];\n    assign sa_next[2][1] = sa_ark[2][1];\n    assign sa_next[2][2] = sa_ark[2][2];\n    assign sa_next[2][3] = sa_ark[2][3];\n    assign sa_next[3][0] = sa_ark[3][0];\n    assign sa_next[3][1] = sa_ark[3][1];\n    assign sa_next[3][2] = sa_ark[3][2];\n    assign sa_next[3][3] = sa_ark[3][3];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end else if (kld) begin\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_in_r <= key;\n        end else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n        end else if (ld_r) begin\n            ld_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j:8*i + j];\n                end\n            end\n        end else if (dcnt < 11) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa_next[i][j];\n                end\n            end\n            dcnt <= dcnt + 1;\n        end else begin\n            done <= 1;\n        end\n    end\n\n    assign text_out = {sa[3][0], sa[3][1], sa[3][2], sa[3][3],\n                      sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                      sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                      sa[0][0], sa[0][1], sa[0][2], sa[0][3]};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 9, "code": "module aes_inv_cipher_top(\n    input  clk,\n    input  rst,\n    input  kld,\n    input  ld,\n    output done,\n    input  [127:0] key,\n    input  [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    wire [7:0] sa_ark[0:3][0:3];\n    wire [7:0] sa_next[0:3][0:3];\n\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox aes_inv_sbox[0:15] (\n        .clk(clk),\n        .a(sa[0][0]),\n        .b(us00)\n    );\n    aes_inv_sbox aes_inv_sbox[16] (\n        .clk(clk),\n        .a(sa[0][1]),\n        .b(us01)\n    );\n    aes_inv_sbox aes_inv_sbox[17] (\n        .clk(clk),\n        .a(sa[0][2]),\n        .b(us02)\n    );\n    aes_inv_sbox aes_inv_sbox[18] (\n        .clk(clk),\n        .a(sa[0][3]),\n        .b(us03)\n    );\n    aes_inv_sbox aes_inv_sbox[19] (\n        .clk(clk),\n        .a(sa[1][0]),\n        .b(us10)\n    );\n    aes_inv_sbox aes_inv_sbox[20] (\n        .clk(clk),\n        .a(sa[1][1]),\n        .b(us11)\n    );\n    aes_inv_sbox aes_inv_sbox[21] (\n        .clk(clk),\n        .a(sa[1][2]),\n        .b(us12)\n    );\n    aes_inv_sbox aes_inv_sbox[22] (\n        .clk(clk),\n        .a(sa[1][3]),\n        .b(us13)\n    );\n    aes_inv_sbox aes_inv_sbox[23] (\n        .clk(clk),\n        .a(sa[2][0]),\n        .b(us20)\n    );\n    aes_inv_sbox aes_inv_sbox[24] (\n        .clk(clk),\n        .a(sa[2][1]),\n        .b(us21)\n    );\n    aes_inv_sbox aes_inv_sbox[25] (\n        .clk(clk),\n        .a(sa[2][2]),\n        .b(us22)\n    );\n    aes_inv_sbox aes_inv_sbox[26] (\n        .clk(clk),\n        .a(sa[2][3]),\n        .b(us23)\n    );\n    aes_inv_sbox aes_inv_sbox[27] (\n        .clk(clk),\n        .a(sa[3][0]),\n        .b(us30)\n    );\n    aes_inv_sbox aes_inv_sbox[28] (\n        .clk(clk),\n        .a(sa[3][1]),\n        .b(us31)\n    );\n    aes_inv_sbox aes_inv_sbox[29] (\n        .clk(clk),\n        .a(sa[3][2]),\n        .b(us32)\n    );\n    aes_inv_sbox aes_inv_sbox[30] (\n        .clk(clk),\n        .a(sa[3][3]),\n        .b(us33)\n    );\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 10;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end else if (kld) begin\n            kcnt <= 10;\n            ld_r <= 0;\n            text_in_r <= text_in;\n        end else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n        end else if (ld_r) begin\n            ld_r <= 0;\n            text_in_r <= text_in;\n        end else if (dcnt < 11) begin\n            ld_r <= 0;\n            if (kcnt > 0) begin\n                kcnt <= kcnt - 1;\n            end\n            if (kcnt == 0) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= kb[10 - kcnt + i * 4 + j];\n                    end\n                end\n            end else begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa_next[i][j];\n                    end\n                end\n            end\n            if (dcnt == 0) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ wk3[i * 4 + j];\n                    end\n                end\n            end else begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa_ark[i][j];\n                    end\n                end\n            end\n            dcnt <= dcnt + 1;\n        end else begin\n            dcnt <= 0;\n            kcnt <= 10;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            done <= 0;\n        end else if (dcnt == 11) begin\n            done <= 1;\n        end else begin\n            done <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_out <= 0;\n        end else if (ld_r) begin\n            text_out <= text_in_r;\n        end else if (dcnt < 11) begin\n            text_out <= text_out_r;\n        end else begin\n            text_out <= 0;\n        end\n    end\n\n    assign sa_ark[0][0] = sa[0][0] ^ wk3[0];\n    assign sa_ark[0][1] = sa[0][1] ^ wk3[1];\n    assign sa_ark[0][2] = sa[0][2] ^ wk3[2];\n    assign sa_ark[0][3] = sa[0][3] ^ wk3[3];\n    assign sa_ark[1][0] = sa[1][0] ^ wk3[4];\n    assign sa_ark[1][1] = sa[1][1] ^ wk3[5];\n    assign sa_ark[1][2] = sa[1][2] ^ wk3[6];\n    assign sa_ark[1][3] = sa[1][3] ^ wk3[7];\n    assign sa_ark[2][0] = sa[2][0] ^ wk3[8];\n    assign sa_ark[2][1] = sa[2][1] ^ wk3[9];\n    assign sa_ark[2][2] = sa[2][2] ^ wk3[10];\n    assign sa_ark[2][3] = sa[2][3] ^ wk3[11];\n    assign sa_ark[3][0] = sa[3][0] ^ wk3[12];\n    assign sa_ark[3][1] = sa[3][1] ^ wk3[13];\n    assign sa_ark[3][2] = sa[3][2] ^ wk3[14];\n    assign sa_ark[3][3] = sa[3][3] ^ wk3[15];\n\n    assign sa_next[0][0] = (sa[0][0] << 3) | (sa[1][0] >> 2) | (sa[2][0] >> 1) | (sa[3][0] << 1);\n    assign sa_next[0][1] = (sa[0][1] << 3) | (sa[1][1] >> 2) | (sa[2][1] >> 1) | (sa[3][1] << 1);\n    assign sa_next[0][2] = (sa[0][2] << 3) | (sa[1][2] >> 2) | (sa[2][2] >> 1) | (sa[3][2] << 1);\n    assign sa_next[0][3] = (sa[0][3] << 3) | (sa[1][3] >> 2) | (sa[2][3] >> 1) | (sa[3][3] << 1);\n    assign sa_next[1][0] = (sa[0][0] << 2) | (sa[1][0] << 1) | (sa[2][0] >> 1) | (sa[3][0] >> 3);\n    assign sa_next[1][1] = (sa[0][1] << 2) | (sa[1][1] << 1) | (sa[2][1] >> 1) | (sa[3][1] >> 3);\n    assign sa_next[1][2] = (sa[0][2] << 2) | (sa[1][2] << 1) | (sa[2][2] >> 1) | (sa[3][2] >> 3);\n    assign sa_next[1][3] = (sa[0][3] << 2) | (sa[1][3] << 1) | (sa[2][3] >> 1) | (sa[3][3] >> 3);\n    assign sa_next[2][0] = (sa[0][0] << 1) | (sa[1][0] >> 1) | (sa[2][0] >> 3) | (sa[3][0] << 2);\n    assign sa_next[2][1] = (sa[0][1] << 1) | (sa[1][1] >> 1) | (sa[2][1] >> 3) | (sa[3][1] << 2);\n    assign sa_next[2][2] = (sa[0][2] << 1) | (sa[1][2] >> 1) | (sa[2][2] >> 3) | (sa[3][2] << 2);\n    assign sa_next[2][3] = (sa[0][3] << 1) | (sa[1][3] >> 1) | (sa[2][3] >> 3) | (sa[3][3] << 2);\n    assign sa_next[3][0] = (sa[0][0] >> 1) | (sa[1][0] >> 3) | (sa[2][0] << 2) | (sa[3][0] << 3);\n    assign sa_next[3][1] = (sa[0][1] >> 1) | (sa[1][1] >> 3) | (sa[2][1] << 2) | (sa[3][1] << 3);\n    assign sa_next[3][2] = (sa[0][2] >> 1) | (sa[1][2] >> 3) | (sa[2][2] << 2) | (sa[3][2] << 3);\n    assign sa_next[3][3] = (sa[0][3] >> 1) | (sa[1][3] >> 3) | (sa[2][3] << 2) | (sa[3][3] << 3);\n\n    assign us00 = aes_inv_sbox[0].b;\n    assign us01 = aes_inv_sbox[1].b;\n    assign us02 = aes_inv_sbox[2].b;\n    assign us03 = aes_inv_sbox[3].b;\n    assign us10 = aes_inv_sbox[4].b;\n    assign us11 = aes_inv_sbox[5].b;\n    assign us12 = aes_inv_sbox[6].b;\n    assign us13 = aes_inv_sbox[7].b;\n    assign us20 = aes_inv_sbox[8].b;\n    assign us21 = aes_inv_sbox[9].b;\n    assign us22 = aes_inv_sbox[10].b;\n    assign us23 = aes_inv_sbox[11].b;\n    assign us30 = aes_inv_sbox[12].b;\n    assign us31 = aes_inv_sbox[13].b;\n    assign us32 = aes_inv_sbox[14].b;\n    assign us33 = aes_inv_sbox[15].b;\n\n    assign wk0 = aes_key_expand_128.wk0;\n    assign wk1 = aes_key_expand_128.wk1;\n    assign wk2 = aes_key_expand_128.wk2;\n    assign wk3 = aes_key_expand_128.wk3;\n\n    assign kb[10] = wk3;\n    for (int i = 9; i > 0; i--) begin\n        assign kb[i] = (kb[i + 1] << 8) | (kb[i + 1] >> 24);\n    end\n\n    assign text_out_r = {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                         sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                         sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                         sa[0][3], sa[1][3], sa[2][3], sa[3][3],\n                         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 1, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the inverse S-box table\n    reg [7:0] inv_sbox_table [255:0];\n\n    // Initialize the inverse S-box table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox_table[i] = i;\n        end\n    end\n\n    // Perform the inverse S-box transformation\n    assign b = inv_sbox_table[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 2, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the inverse S-box table\n    reg [7:0] inv_sbox_table [255:0];\n\n    // Initialize the inverse S-box table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox_table[i] = i;\n        end\n    end\n\n    // Perform the inverse S-box transformation\n    assign b = inv_sbox_table[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 3, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] inv_sbox_table [0:255];\n\ninitial begin\n    for (int i = 0; i < 256; i++) begin\n        inv_sbox_table[i] = i;\n    end\nend\n\nalways_comb begin\n    b = inv_sbox_table[a];\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 4, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] inv_sbox_table [255:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox_table[i] = i;\n        end\n    end\n\n    assign b = inv_sbox_table[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 5, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] inv_sbox_table [255:0];\n\ninitial begin\n    for (int i = 0; i < 256; i++) begin\n        inv_sbox_table[i] = i;\n    end\nend\n\nalways_comb begin\n    b = inv_sbox_table[a];\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 6, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] inv_sbox_table [255:0];\n\ninitial begin\n    for (int i = 0; i < 256; i++) begin\n        inv_sbox_table[i] = i;\n    end\nend\n\nalways_comb begin\n    b = inv_sbox_table[a];\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 7, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the inverse S-box table\n    reg [7:0] inv_sbox [256:0];\n\n    // Initialize the inverse S-box table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = i;\n        end\n    end\n\n    // Perform the inverse S-box transformation\n    assign b = inv_sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 8, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the inverse S-box table\n    reg [7:0] inv_sbox_table [255:0];\n\n    // Initialize the inverse S-box table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox_table[i] = i;\n        end\n    end\n\n    // Define the inverse affine transformation matrix\n    reg [7:0] affine_matrix [8:0] = {\n        0, 0, 1, 0, 0, 1, 0, 1,\n        1, 0, 0, 1, 0, 0, 1, 0,\n        0, 1, 0, 0, 1, 0, 0, 1,\n        1, 0, 1, 0, 0, 1, 0, 0,\n        0, 0, 1, 0, 1, 0, 0, 1,\n        1, 0, 0, 1, 0, 1, 0, 0,\n        0, 1, 0, 0, 1, 0, 1, 0,\n        1, 0, 1, 0, 0, 1, 0, 0\n    };\n\n    // Define the inverse affine transformation constant vector\n    reg [7:0] affine_constant = 5;\n\n    // Define the multiplicative inverse in GF(2^8)\n    reg [7:0] multiplicative_inverse [255:0];\n\n    // Initialize the multiplicative inverse table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            multiplicative_inverse[i] = i;\n        end\n    end\n\n    // Define the irreducible polynomial\n    reg [7:0] irreducible_polynomial = 8'b100011011;\n\n    // Define the ROM structure\n    reg [7:0] rom [255:0];\n\n    // Initialize the ROM table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            rom[i] = inv_sbox_table[i];\n        end\n    end\n\n    // Perform the inverse S-box transformation\n    always @(*) begin\n        b = rom[a];\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 9, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] inv_sbox[256:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = i;\n        end\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 10, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] inv_sbox [256:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = i;\n        end\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 11, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] inv_sbox[255:0];\n\ninitial begin\n    for (int i = 0; i < 256; i++) begin\n        inv_sbox[i] = i;\n    end\nend\n\nalways @(*) begin\n    b = inv_sbox[a];\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 12, "code": "Here is the Verilog code for the aes_inv_sbox module:\n```\nmodule aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the inverse S-box table\n    reg [7:0] inv_sbox_table [255:0];\n\n    // Initialize the inverse S-box table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox_table[i] = i;\n        end\n    end\n\n    // Define the inverse affine transformation matrix\n    reg [7:0] affine_matrix [8:0] = {\n        8'b00000001, 8'b00000010, 8'b00000100, 8'b00001000, 8'b00010000, 8'b00100000, 8'b01000000, 8'b10000000,\n        8'b00000001, 8'b00000010, 8'b00000100, 8'b00001000, 8'b00010000, 8'b00100000, 8'b01000000, 8'b10000000,\n        8'b00000001, 8'b00000010, 8'b00000100, 8'b00001000, 8'b00010000, 8'b00100000, 8'b01000000, 8'b10000000,\n        8'b00000001, 8'b00000010, 8'b00000100, 8'b00001000, 8'b00010000, 8'b00100000, 8'b01000000, 8'b10000000,\n        8'b00000001, 8'b00000010, 8'b00000100, 8'b00001000, 8'b00010000, 8'b00100000, 8'b01000000, 8'b10000000,\n        8'b00000001, 8'b00000010, 8'b00000100, 8'b00001000, 8'b00010000, 8'b00100000, 8'b01000000, 8'b10000000,\n        8'b00000001, 8'b00000010, 8'b00000100, 8'b00001000, 8'b00010000, 8'b00100000, 8'b01000000, 8'b10000000,\n        8'b00000001, 8'b00000010, 8'b00000100, 8'b00001000, 8'b00010000, 8'b00100000, 8'b01000000, 8'b10000000\n    };\n\n    // Define the inverse S-box constant vector\n    reg [7:0] inv_sbox_const = 8'b00000101;\n\n    // Perform the inverse S-box transformation\n    assign b = inv_sbox_table[a] ^ inv_sbox_const;\n\nendmodule\n```\nNote that this code uses a ROM-based implementation of the inverse S-box, where the `inv_sbox_table` array stores the pre-calculated inverse transformation results for all possible input values. The `affine_matrix` and `inv_sbox_const` arrays are used to perform the inverse affine transformation, but they are not actually used in this implementation since the ROM-based approach is used instead.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 13, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] inv_sbox[256:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = i;\n        end\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 14, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] inv_sbox_table [255:0];\n\ninitial begin\n    for (int i = 0; i < 256; i++) begin\n        inv_sbox_table[i] = i;\n    end\nend\n\nalways_comb begin\n    b = inv_sbox_table[a];\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 15, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] inv_sbox_table [255:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox_table[i] = i;\n        end\n    end\n\n    assign b = inv_sbox_table[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 1, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w0, w1, w2, w3;\n    reg [31:0] rcon;\n    reg [7:0] sbox_out[4];\n\n    assign wo_0 = w0;\n    assign wo_1 = w1;\n    assign wo_2 = w2;\n    assign wo_3 = w3;\n\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            w0 <= {key[127:96], 8'b0};\n            w1 <= {key[95:64], 8'b0};\n            w2 <= {key[63:32], 8'b0};\n            w3 <= {key[31:0], 8'b0};\n        end\n        else\n        begin\n            w0 <= w0 ^ (rcon ^ aes_sbox({w3[7:0], w2[7:0], w1[7:0], w0[7:0]}));\n            w1 <= w1 ^ (rcon ^ aes_sbox({w3[15:8], w2[15:8], w1[15:8], w0[15:8]}));\n            w2 <= w2 ^ (rcon ^ aes_sbox({w3[23:16], w2[23:16], w1[23:16], w0[23:16]}));\n            w3 <= w3 ^ (rcon ^ aes_sbox({w3[31:24], w2[31:24], w1[31:24], w0[31:24]}));\n            rcon <= rcon << 1;\n            if (rcon[31])\n                rcon <= rcon ^ 0x01100000;\n        end\n    end\n\n    aes_rcon aes_rcon_inst(\n       .clk(clk),\n       .kld(kld),\n       .out(rcon)\n    );\n\n    aes_sbox aes_sbox_inst0(\n       .a(w3[7:0]),\n       .b(sbox_out[0])\n    );\n\n    aes_sbox aes_sbox_inst1(\n       .a(w3[15:8]),\n       .b(sbox_out[1])\n    );\n\n    aes_sbox aes_sbox_inst2(\n       .a(w3[23:16]),\n       .b(sbox_out[2])\n    );\n\n    aes_sbox aes_sbox_inst3(\n       .a(w3[31:24]),\n       .b(sbox_out[3])\n    );\n\n    rot_word rot_word_inst(\n       .a(w3),\n       .b(w3_rot)\n    );\n\n    assign w3_rot = {w3[15:8], w3[7:0]};\n\n    assign sbox_out[0] = aes_sbox_inst0.b;\n    assign sbox_out[1] = aes_sbox_inst1.b;\n    assign sbox_out[2] = aes_sbox_inst2.b;\n    assign sbox_out[3] = aes_sbox_inst3.b;\n\nendmodule\n\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [31:0] rcon;\n\n    always @(posedge clk)\n    begin\n        if (kld)\n            rcon <= 0;\n        else\n        begin\n            rcon <= rcon << 1;\n            if (rcon[31])\n                rcon <= rcon ^ 0x01100000;\n        end\n    end\n\n    assign out = rcon;\n\nendmodule\n\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[256];\n\n    initial\n    begin\n        for (int i = 0; i < 256; i++)\n        begin\n            sbox[i] = i;\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule rot_word(\n    input [31:0] a,\n    output [31:0] b\n);\n\n    assign b = {a[15:8], a[7:0]};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 2, "code": "Here is the Verilog code for the aes_key_expand_128 module:\n```\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [31:0] w0, w1, w2, w3;\nreg [31:0] rcon;\nreg [7:0] sbox_out [0:3];\n\n// S-box module\naes_sbox aes_sbox_inst0 (\n    .a(key[31:24]),\n    .b(sbox_out[0])\n);\n\naes_sbox aes_sbox_inst1 (\n    .a(key[23:16]),\n    .b(sbox_out[1])\n);\n\naes_sbox aes_sbox_inst2 (\n    .a(key[15:8]),\n    .b(sbox_out[2])\n);\n\naes_sbox aes_sbox_inst3 (\n    .a(key[7:0]),\n    .b(sbox_out[3])\n);\n\n// Round constant generator\naes_rcon aes_rcon_inst (\n    .clk(clk),\n    .kld(kld),\n    .out(rcon)\n);\n\n// Key loading operation\nalways @(posedge clk)\nif (kld)\nbegin\n    w0 <= {key[127:96], key[95:64]};\n    w1 <= {key[63:32], key[31:0]};\n    w2 <= {32'd0, 32'd0, 32'd0, 32'd0};\n    w3 <= {32'd0, 32'd0, 32'd0, 32'd0};\nend\n\n// Key expansion operation\nalways @(posedge clk)\nif (!kld)\nbegin\n    // Perform byte reordering and S-box transformation\n    reg [7:0] reordered_bytes [0:3];\n    reordered_bytes[0] = {sbox_out[0], sbox_out[1], sbox_out[2], sbox_out[3]};\n    reordered_bytes[1] = {sbox_out[1], sbox_out[2], sbox_out[3], sbox_out[0]};\n    reordered_bytes[2] = {sbox_out[2], sbox_out[3], sbox_out[0], sbox_out[1]};\n    reordered_bytes[3] = {sbox_out[3], sbox_out[0], sbox_out[1], sbox_out[2]};\n\n    // Perform S-box transformation\n    reg [7:0] sbox_result [0:3];\n    for (i = 0; i < 4; i++)\n    begin\n        sbox_result[i] = aes_sbox_inst{i}.b;\n    end\n\n    // XOR with round constant\n    reg [31:0] temp;\n    temp = w3;\n    temp[31:24] = temp[31:24] ^ rcon;\n    temp[23:16] = temp[23:16] ^ reordered_bytes[0];\n    temp[15:8] = temp[15:8] ^ reordered_bytes[1];\n    temp[7:0] = temp[7:0] ^ reordered_bytes[2];\n\n    // Update round keys\n    w0 <= temp;\n    w1 <= w0 ^ reordered_bytes[3];\n    w2 <= w1 ^ temp;\n    w3 <= w2 ^ reordered_bytes[3];\nend\n\n// Output round keys\nassign wo_0 = w0;\nassign wo_1 = w1;\nassign wo_2 = w2;\nassign wo_3 = w3;\n\nendmodule\n```\nNote that this code assumes that the `aes_sbox` and `aes_rcon` modules are already implemented and available. The `aes_sbox` module is assumed to have a 1-bit input `a` and an 8-bit output `b`, and the `aes_rcon` module is assumed to have a 1-bit input `kld` and a 32-bit output `out`.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 3, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w0, w1, w2, w3;\n    reg [31:0] rcon;\n    reg [7:0] sbox_out[4];\n\n    aes_rcon aes_rcon_inst(\n       .clk(clk),\n       .kld(kld),\n       .out(rcon)\n    );\n\n    aes_sbox aes_sbox_inst0(\n       .a(key[31:24]),\n       .b(sbox_out[0])\n    );\n\n    aes_sbox aes_sbox_inst1(\n       .a(key[23:16]),\n       .b(sbox_out[1])\n    );\n\n    aes_sbox aes_sbox_inst2(\n       .a(key[15:8]),\n       .b(sbox_out[2])\n    );\n\n    aes_sbox aes_sbox_inst3(\n       .a(key[7:0]),\n       .b(sbox_out[3])\n    );\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w0 <= key[127:96];\n            w1 <= key[95:64];\n            w2 <= key[63:32];\n            w3 <= key[31:0];\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n        end else begin\n            w0 <= w3 ^ (sbox_out[0] ^ rcon);\n            w1 <= w2 ^ w3 ^ (sbox_out[1] ^ rcon);\n            w2 <= w1 ^ w3 ^ (sbox_out[2] ^ rcon);\n            w3 <= w0 ^ w1 ^ w2 ^ (sbox_out[3] ^ rcon);\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n        end\n    end\n\nendmodule\n\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [31:0] rcon_val;\n    reg [7:0] rcon_byte;\n    reg [3:0] rcon_counter;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcon_counter <= 0;\n            rcon_val <= 0;\n        end else begin\n            rcon_counter <= rcon_counter + 1;\n            case (rcon_counter)\n                1: rcon_byte = 1;\n                2: rcon_byte = 2;\n                3: rcon_byte = 3;\n                4: rcon_byte = 4;\n                5: rcon_byte = 5;\n                6: rcon_byte = 6;\n                7: rcon_byte = 7;\n                8: rcon_byte = 8;\n                9: rcon_byte = 9;\n                10: rcon_byte = 10;\n                11: rcon_byte = 11;\n                12: rcon_byte = 12;\n                13: rcon_byte = 13;\n                14: rcon_byte = 14;\n                15: rcon_byte = 15;\n                default: rcon_byte = 0;\n            endcase\n            rcon_val <= {rcon_byte, rcon_byte, rcon_byte, rcon_byte, 0, 0, 0, 0};\n            out <= rcon_val;\n        end\n    end\n\nendmodule\n\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[256];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n        end\n        for (int i = 0; i < 256; i++) begin\n            for (int j = 0; j < 8; j++) begin\n                if (sbox[i][j] == 0) begin\n                    sbox[i][j] = 0;\n                end else if (sbox[i][j] == 1) begin\n                    sbox[i][j] = 14;\n                end else if (sbox[i][j] == 2) begin\n                    sbox[i][j] = 9;\n                end else if (sbox[i][j] == 3) begin\n                    sbox[i][j] = 13;\n                end else if (sbox[i][j] == 4) begin\n                    sbox[i][j] = 8;\n                end else if (sbox[i][j] == 5) begin\n                    sbox[i][j] = 12;\n                end else if (sbox[i][j] == 6) begin\n                    sbox[i][j] = 4;\n                end else if (sbox[i][j] == 7) begin\n                    sbox[i][j] = 2;\n                end else if (sbox[i][j] == 8) begin\n                    sbox[i][j] = 1;\n                end else if (sbox[i][j] == 9) begin\n                    sbox[i][j] = 6;\n                end else if (sbox[i][j] == 10) begin\n                    sbox[i][j] = 11;\n                end else if (sbox[i][j] == 11) begin\n                    sbox[i][j] = 3;\n                end else if (sbox[i][j] == 12) begin\n                    sbox[i][j] = 7;\n                end else if (sbox[i][j] == 13) begin\n                    sbox[i][j] = 5;\n                end else if (sbox[i][j] == 14) begin\n                    sbox[i][j] = 15;\n                end else if (sbox[i][j] == 15) begin\n                    sbox[i][j] = 10;\n                end\n            end\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 4, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w0, w1, w2, w3;\n    reg [31:0] rcon;\n    reg [7:0] sbox_out[4];\n\n    aes_rcon aes_rcon_inst(\n       .clk(clk),\n       .kld(kld),\n       .out(rcon)\n    );\n\n    aes_sbox aes_sbox_inst0(\n       .a(key[31:24]),\n       .b(sbox_out[0])\n    );\n\n    aes_sbox aes_sbox_inst1(\n       .a(key[23:16]),\n       .b(sbox_out[1])\n    );\n\n    aes_sbox aes_sbox_inst2(\n       .a(key[15:8]),\n       .b(sbox_out[2])\n    );\n\n    aes_sbox aes_sbox_inst3(\n       .a(key[7:0]),\n       .b(sbox_out[3])\n    );\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w0 <= key[127:96];\n            w1 <= key[95:64];\n            w2 <= key[63:32];\n            w3 <= key[31:0];\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n        end else begin\n            w0 <= w3 ^ (sbox_out[0] ^ rcon);\n            w1 <= w3 ^ (w0 ^ sbox_out[1]);\n            w2 <= w3 ^ (w0 ^ w1 ^ sbox_out[2]);\n            w3 <= w3 ^ (w0 ^ w1 ^ w2 ^ sbox_out[3]);\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n            rcon <= rcon << 8 | aes_rcon_inst.out;\n        end\n    end\n\nendmodule\n\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [31:0] rcon_val;\n    reg [7:0] rcon_byte;\n    reg [3:0] rcon_counter;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcon_counter <= 0;\n            rcon_val <= 0;\n        end else begin\n            rcon_counter <= rcon_counter + 1;\n            case (rcon_counter)\n                1: rcon_byte <= 1;\n                2: rcon_byte <= 2;\n                3: rcon_byte <= 3;\n                4: rcon_byte <= 1;\n                5: rcon_byte <= 2;\n                6: rcon_byte <= 3;\n                7: rcon_byte <= 1;\n                8: rcon_byte <= 2;\n                9: rcon_byte <= 3;\n                10: rcon_byte <= 1;\n                11: rcon_byte <= 2;\n                12: rcon_byte <= 3;\n                13: rcon_byte <= 1;\n                14: rcon_byte <= 2;\n                15: rcon_byte <= 3;\n                default: rcon_byte <= 0;\n            endcase\n            rcon_val <= {rcon_byte, rcon_val[31:8]};\n            out <= rcon_val;\n        end\n    end\n\nendmodule\n\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[256];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n        end\n    end\n\n    always_comb begin\n        b = sbox[a];\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 5, "code": "module aes_key_expand_128(\n    input  wire clk,\n    input  wire kld,\n    input  wire [127:0] key,\n    output wire [31:0] wo_0,\n    output wire [31:0] wo_1,\n    output wire [31:0] wo_2,\n    output wire [31:0] wo_3\n);\n\nreg [31:0] w0, w1, w2, w3;\nreg [31:0] rcon;\nreg [7:0]  sbox_result[4];\n\n// Load initial key\nalways @(posedge clk)\nif (kld)\nbegin\n    w0 <= key[31:0];\n    w1 <= key[63:32];\n    w2 <= key[95:64];\n    w3 <= key[127:96];\nend\n\n// Perform key expansion\nalways @(posedge clk)\nif (!kld)\nbegin\n    // Perform byte reordering and S-box transformation\n    sbox_result[0] = aes_sbox(w3[7:0]);\n    sbox_result[1] = aes_sbox(w3[15:8]);\n    sbox_result[2] = aes_sbox(w3[23:16]);\n    sbox_result[3] = aes_sbox(w3[31:24]);\n\n    // XOR with current round constant\n    rcon = aes_rcon(kld);\n\n    // Generate new round key\n    w0 <= w3 ^ (w2 ^ sbox_result[0] ^ rcon);\n    w1 <= w3 ^ (w1 ^ sbox_result[1] ^ rcon);\n    w2 <= w3 ^ (w0 ^ sbox_result[2] ^ rcon);\n    w3 <= w3 ^ (w1 ^ sbox_result[3] ^ rcon);\nend\n\n// Output round keys\nassign wo_0 = w0;\nassign wo_1 = w1;\nassign wo_2 = w2;\nassign wo_3 = w3;\n\nendmodule\n\nmodule aes_rcon(\n    input  wire clk,\n    input  wire kld,\n    output wire [31:0] out\n);\n\nreg [31:0] rcon_value;\n\nalways @(posedge clk)\nif (kld)\nbegin\n    rcon_value <= 0;\nend\nelse\nbegin\n    rcon_value <= rcon_value << 1;\n    rcon_value[0] <= rcon_value[0] ^ (rcon_value[31] ^ 1);\nend\n\nassign out = rcon_value;\n\nendmodule\n\nmodule aes_sbox(\n    input  wire [7:0] a,\n    output wire [7:0] b\n);\n\n// S-box lookup table\nreg [7:0] sbox_table[256];\n\ninitial\nbegin\n    // Initialize S-box lookup table\n    for (int i = 0; i < 256; i++)\n    begin\n        sbox_table[i] = i;\n    end\nend\n\n// Perform S-box substitution\nassign b = sbox_table[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 6, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    // Define round constants\n    reg [31:0] rcon;\n\n    // Define S-box\n    reg [7:0] sbox [255:0];\n\n    // Define key registers\n    reg [31:0] key_reg [4:0];\n\n    // Define round counter\n    reg [3:0] round_counter;\n\n    // Define byte reordering\n    reg [7:0] byte_reorder [3:0];\n\n    // Define S-box transformation result\n    reg [7:0] sbox_result [3:0];\n\n    // Define round constant update\n    reg [31:0] rcon_update;\n\n    // Define key expansion algorithm\n    reg [31:0] w [11:0];\n\n    // Initialize round counter\n    assign round_counter = 0;\n\n    // Initialize key registers\n    always @(posedge clk) begin\n        if (kld) begin\n            key_reg[0] <= key[127:96];\n            key_reg[1] <= key[95:64];\n            key_reg[2] <= key[63:32];\n            key_reg[3] <= key[31:0];\n            round_counter <= 0;\n        end\n    end\n\n    // Initialize S-box\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = aes_sbox(i);\n        end\n    end\n\n    // Initialize round constant\n    initial begin\n        rcon = 0;\n        for (int i = 0; i < 10; i++) begin\n            rcon = {rcon[30:0], i};\n        end\n    end\n\n    // Generate round constants\n    always @(posedge clk) begin\n        if (kld) begin\n            rcon <= 0;\n        end else if (round_counter < 10) begin\n            rcon <= {rcon[30:0], round_counter};\n            round_counter <= round_counter + 1;\n        end\n    end\n\n    // Perform key expansion\n    always @(posedge clk) begin\n        if (kld) begin\n            // Load key into registers\n            key_reg[0] <= key[127:96];\n            key_reg[1] <= key[95:64];\n            key_reg[2] <= key[63:32];\n            key_reg[3] <= key[31:0];\n            round_counter <= 0;\n        end else if (round_counter < 11) begin\n            // Perform byte reordering\n            byte_reorder[0] <= key_reg[3][7:0];\n            byte_reorder[1] <= key_reg[3][15:8];\n            byte_reorder[2] <= key_reg[3][23:16];\n            byte_reorder[3] <= key_reg[3][31:24];\n\n            // Perform S-box transformation\n            sbox_result[0] <= sbox[byte_reorder[0]];\n            sbox_result[1] <= sbox[byte_reorder[1]];\n            sbox_result[2] <= sbox[byte_reorder[2]];\n            sbox_result[3] <= sbox[byte_reorder[3]];\n\n            // Perform XOR with round constant\n            w[round_counter] <= key_reg[round_counter] ^ sbox_result;\n\n            // Update key registers\n            key_reg[round_counter + 1] <= key_reg[round_counter];\n\n            // Update round counter\n            round_counter <= round_counter + 1;\n        end\n\n        // Output round keys\n        wo_0 <= w[round_counter];\n        wo_1 <= w[round_counter + 1];\n        wo_2 <= w[round_counter + 2];\n        wo_3 <= w[round_counter + 3];\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 7, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w0, w1, w2, w3;\n    reg [31:0] rcon;\n    reg [7:0] sbox_out [0:3];\n\n    // S-box module\n    aes_sbox sbox(\n        .a(key[31:24]),\n        .b(sbox_out[0])\n    );\n    aes_sbox sbox1(\n        .a(key[23:16]),\n        .b(sbox_out[1])\n    );\n    aes_sbox sbox2(\n        .a(key[15:8]),\n        .b(sbox_out[2])\n    );\n    aes_sbox sbox3(\n        .a(key[7:0]),\n        .b(sbox_out[3])\n    );\n\n    // Round constant generator\n    aes_rcon rcon_gen(\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    // Key loading operation\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            w0 <= {key[127:96], 32'd0};\n            w1 <= {key[95:64], 32'd0};\n            w2 <= {key[63:32], 32'd0};\n            w3 <= {key[31:0], 32'd0};\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n        end\n    end\n\n    // Key expansion operation\n    always @(posedge clk)\n    begin\n        if (!kld)\n        begin\n            // Perform byte reordering and S-box transformation\n            sbox_out[0] <= {sbox_out[1], sbox_out[2], sbox_out[3], sbox_out[0]};\n            sbox_out[1] <= {sbox_out[2], sbox_out[3], sbox_out[0], sbox_out[1]};\n            sbox_out[2] <= {sbox_out[3], sbox_out[0], sbox_out[1], sbox_out[2]};\n            sbox_out[3] <= {sbox_out[0], sbox_out[1], sbox_out[2], sbox_out[3]};\n\n            // XOR with current round constant\n            w0 <= w3 ^ (rcon << 24);\n            w1 <= w2 ^ (rcon << 16) ^ w0;\n            w2 <= w1 ^ (rcon << 8) ^ w0;\n            w3 <= w0 ^ rcon ^ w1 ^ w2;\n        end\n    end\n\n    // Output round keys\n    assign wo_0 = w0;\n    assign wo_1 = w1;\n    assign wo_2 = w2;\n    assign wo_3 = w3;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 8, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w0, w1, w2, w3;\n    reg [31:0] rcon;\n    reg [7:0] sbox_out[16:0];\n\n    // S-box module\n    aes_sbox sbox(\n        .a(key[31:24]),\n        .b(sbox_out[0])\n    );\n\n    aes_sbox sbox1(\n        .a(key[23:16]),\n        .b(sbox_out[1])\n    );\n\n    aes_sbox sbox2(\n        .a(key[15:8]),\n        .b(sbox_out[2])\n    );\n\n    aes_sbox sbox3(\n        .a(key[7:0]),\n        .b(sbox_out[3])\n    );\n\n    // Round constant generator\n    aes_rcon rcon(\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    // Key loading operation\n    always @(posedge clk)\n    if (kld) begin\n        w0 <= {key[127:96], 0, 0, 0};\n        w1 <= {key[95:64], 0, 0, 0};\n        w2 <= {key[63:32], 0, 0, 0};\n        w3 <= {key[31:0], 0, 0, 0};\n    end\n\n    // Key expansion operation\n    always @(posedge clk)\n    if (!kld) begin\n        // Perform byte reordering and S-box transformation\n        reg [7:0] temp[3:0];\n        temp[0] = {sbox_out[0], sbox_out[1], sbox_out[2], sbox_out[3]};\n        temp[1] = {sbox_out[4], sbox_out[5], sbox_out[6], sbox_out[7]};\n        temp[2] = {sbox_out[8], sbox_out[9], sbox_out[10], sbox_out[11]};\n        temp[3] = {sbox_out[12], sbox_out[13], sbox_out[14], sbox_out[15]};\n\n        // XOR with current round constant\n        temp[0] = temp[0] ^ rcon;\n        temp[1] = temp[1] ^ temp[0];\n        temp[2] = temp[2] ^ temp[1];\n        temp[3] = temp[3] ^ temp[2];\n\n        // New round key generation sequence\n        w0 <= {temp[2], temp[3], temp[0], temp[1]};\n        w1 <= {temp[3], temp[0], temp[1], temp[2]};\n        w2 <= {temp[1], temp[2], temp[0], temp[3]};\n        w3 <= {temp[0], temp[1], temp[2], temp[3]};\n    end\n\n    // Output round keys\n    assign wo_0 = w0;\n    assign wo_1 = w1;\n    assign wo_2 = w2;\n    assign wo_3 = w3;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 9, "code": "Here is the Verilog code for the aes_key_expand_128 module:\n```\nmodule aes_key_expand_128(\n    input  clk,\n    input  kld,\n    input  [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w0, w1, w2, w3;\n    reg [31:0] rcon;\n    reg [7:0] sbox[256:0];\n    reg [7:0] temp[4:0];\n\n    // S-box lookup table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = aes_sbox(i);\n        end\n    end\n\n    // Round constant generator\n    aes_rcon rcon_gen(\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    // Key loading operation\n    always @(posedge clk) begin\n        if (kld) begin\n            w0 <= {key[127:96], 8'b0};\n            w1 <= {key[95:64], 8'b0};\n            w2 <= {key[63:32], 8'b0};\n            w3 <= {key[31:0], 8'b0};\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n        end\n    end\n\n    // Key expansion operation\n    always @(posedge clk) begin\n        if (!kld) begin\n            // Perform byte reordering and S-box transformation\n            temp[0] = {w3[7:0], w3[15:8], w3[23:16], w3[31:24]};\n            temp[1] = {w2[7:0], w2[15:8], w2[23:16], w2[31:24]};\n            temp[2] = {w1[7:0], w1[15:8], w1[23:16], w1[31:24]};\n            temp[3] = {w0[7:0], w0[15:8], w0[23:16], w0[31:24]};\n\n            for (int i = 0; i < 4; i++) begin\n                temp[i] = aes_sbox(temp[i]);\n            end\n\n            // XOR with current round constant\n            temp[0] = temp[0] ^ rcon;\n            temp[1] = temp[1] ^ temp[0];\n            temp[2] = temp[2] ^ temp[0] ^ temp[1];\n            temp[3] = temp[3] ^ temp[0] ^ temp[1] ^ temp[2];\n\n            // Update round keys\n            w0 <= temp[0];\n            w1 <= temp[1];\n            w2 <= temp[2];\n            w3 <= temp[3];\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n        end\n    end\n\nendmodule\n```\nNote that this code assumes that the `aes_sbox` and `aes_rcon` modules are already implemented and available. The `aes_sbox` module is responsible for performing the S-box substitution operation, and the `aes_rcon` module generates the round constants.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 10, "code": "module aes_key_expand_128(\n    input  wire clk,\n    input  wire kld,\n    input  wire [127:0] key,\n    output wire [31:0] wo_0,\n    output wire [31:0] wo_1,\n    output wire [31:0] wo_2,\n    output wire [31:0] wo_3\n);\n\n    // Registers\n    reg [31:0] w0, w1, w2, w3;\n\n    // S-box module\n    aes_sbox sbox0(.a(key[31:24]), .b(w0[31:24]));\n    aes_sbox sbox1(.a(key[23:16]), .b(w0[23:16]));\n    aes_sbox sbox2(.a(key[15:8]), .b(w0[15:8]));\n    aes_sbox sbox3(.a(key[7:0]), .b(w0[7:0]));\n\n    // Round constant generator\n    aes_rcon rcon(.clk(clk), .kld(kld), .out(rcon_val));\n\n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            w0 <= {key[127:96], key[95:64], key[63:32], key[31:0]};\n            w1 <= {key[95:64], key[63:32], key[31:0], 0};\n            w2 <= {key[63:32], key[31:0], 0, 0};\n            w3 <= {key[31:0], 0, 0, 0};\n        end else begin\n            // Perform byte reordering and S-box transformation\n            w0 <= {w1[23:16], w1[15:8], w1[7:0], w0[31:24]};\n            w0 <= sbox0.b | w0;\n            w0 <= w0 ^ rcon_val;\n\n            // Generate new round key\n            w1 <= w0 ^ w2;\n            w2 <= w1 ^ w3;\n            w3 <= w2 ^ w0;\n        end\n    end\n\n    // Output round keys\n    assign wo_0 = w0;\n    assign wo_1 = w1;\n    assign wo_2 = w2;\n    assign wo_3 = w3;\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input  wire clk,\n    input  wire kld,\n    output wire [31:0] out\n);\n\n    reg [31:0] rcon_val;\n    reg [7:0] counter;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            counter <= 0;\n            rcon_val <= 0;\n        end else begin\n            counter <= counter + 1;\n            case (counter)\n                1: rcon_val <= 0x01;\n                2: rcon_val <= 0x02;\n                3: rcon_val <= 0x04;\n                4: rcon_val <= 0x08;\n                5: rcon_val <= 0x10;\n                6: rcon_val <= 0x20;\n                7: rcon_val <= 0x40;\n                8: rcon_val <= 0x80;\n                9: rcon_val <= 0x1b;\n                10: rcon_val <= 0x36;\n                11: rcon_val <= 0x6c;\n                12: rcon_val <= 0xd8;\n                13: rcon_val <= 0xab;\n                14: rcon_val <= 0x4d;\n                15: rcon_val <= 0x9a;\n                16: rcon_val <= 0x2f;\n                17: rcon_val <= 0x5e;\n                18: rcon_val <= 0xbc;\n                19: rcon_val <= 0x63;\n                20: rcon_val <= 0xc6;\n                21: rcon_val <= 0xd8;\n                22: rcon_val <= 0xbe;\n                23: rcon_val <= 0xe0;\n                24: rcon_val <= 0xfe;\n                25: rcon_val <= 0x37;\n                26: rcon_val <= 0x6d;\n                27: rcon_val <= 0xd9;\n                28: rcon_val <= 0x8b;\n                29: rcon_val <= 0x2f;\n                30: rcon_val <= 0x5e;\n                31: rcon_val <= 0xbc;\n                32: rcon_val <= 0x63;\n                33: rcon_val <= 0xc6;\n                34: rcon_val <= 0xd8;\n                35: rcon_val <= 0xbe;\n                36: rcon_val <= 0xe0;\n                37: rcon_val <= 0xfe;\n                38: rcon_val <= 0x37;\n                39: rcon_val <= 0x6d;\n                40: rcon_val <= 0xd9;\n                41: rcon_val <= 0x8b;\n                42: rcon_val <= 0x2f;\n                43: rcon_val <= 0x5e;\n                44: rcon_val <= 0xbc;\n                45: rcon_val <= 0x63;\n                46: rcon_val <= 0xc6;\n                47: rcon_val <= 0xd8;\n                48: rcon_val <= 0xbe;\n                49: rcon_val <= 0xe0;\n                50: rcon_val <= 0xfe;\n                51: rcon_val <= 0x37;\n                52: rcon_val <= 0x6d;\n                53: rcon_val <= 0xd9;\n                54: rcon_val <= 0x8b;\n                55: rcon_val <= 0x2f;\n                56: rcon_val <= 0x5e;\n                57: rcon_val <= 0xbc;\n                58: rcon_val <= 0x63;\n                59: rcon_val <= 0xc6;\n                60: rcon_val <= 0xd8;\n                61: rcon_val <= 0xbe;\n                62: rcon_val <= 0xe0;\n                63: rcon_val <= 0xfe;\n                default: rcon_val <= 0;\n            endcase\n        end\n    end\n\n    assign out = rcon_val;\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input  wire [7:0] a,\n    output wire [7:0] b\n);\n\n    // S-box values\n    localparam SBOX_0 = 8'b0x63;\n    localparam SBOX_1 = 8'b0x12;\n    localparam SBOX_2 = 8'b0x8;\n    localparam SBOX_3 = 8'b0xb;\n    localparam SBOX_4 = 8'b0x6;\n    localparam SBOX_5 = 8'b0x9;\n    localparam SBOX_6 = 8'b0x0;\n    localparam SBOX_7 = 8'b0xdc;\n    localparam SBOX_8 = 8'b0xbe;\n    localparam SBOX_9 = 8'b0x1b;\n    localparam SBOX_10 = 8'b0x10;\n    localparam SBOX_11 = 8'b0x36;\n    localparam SBOX_12 = 8'b0xd;\n    localparam SBOX_13 = 8'b0x51;\n    localparam SBOX_14 = 8'b0x21;\n    localparam SBOX_15 = 8'b0xb7;\n    localparam SBOX_16 = 8'b0xb3;\n    localparam SBOX_17 = 8'b0x73;\n    localparam SBOX_18 = 8'b0x2d;\n    localparam SBOX_19 = 8'b0x0b;\n    localparam SBOX_20 = 8'b0x62;\n    localparam SBOX_21 = 8'b0x9a;\n    localparam SBOX_22 = 8'b0x00;\n    localparam SBOX_23 = 8'b0x66;\n    localparam SBOX_24 = 8'b0x3c;\n    localparam SBOX_25 = 8'b0x46;\n    localparam SBOX_26 = 8'b0x47;\n    localparam SBOX_27 = 8'b0x18;\n    localparam SBOX_28 = 8'b0x6c;\n    localparam SBOX_29 = 8'b0x04;\n    localparam SBOX_30 = 8'b0x30;\n    localparam SBOX_31 = 8'b0xc8;\n    localparam SBOX_32 = 8'b0x43;\n    localparam SBOX_33 = 8'b0x13;\n    localparam SBOX_34 = 8'b0x99;\n    localparam SBOX_35 = 8'b0x32;\n    localparam SBOX_36 = 8'b0x15;\n    localparam SBOX_37 = 8'b0x16;\n    localparam SBOX_38 = 8'b0x65;\n    localparam SBOX_39 = 8'b0x39;\n    localparam SBOX_40 = 8'b0x4a;\n    localparam SBOX_41 = 8'b0x4c;\n    localparam SBOX_42 = 8'b0x55;\n    localparam SBOX_43 = 8'b0x2a;\n    localparam SBOX_44 = 8'b0x57;\n    localparam SBOX_45 = 8'b0xe;\n    localparam SBOX_46 = 8'b0xb2;\n    localparam SBOX_47 = 8'b0x60;\n    localparam SBOX_48 = 8'b0x97;\n    localparam SBOX_49 = 8'b0x35;\n    localparam SBOX_50 = 8'b0x31;\n    localparam SBOX_51 = 8'b0x29;\n    localparam SBOX_52 = 8'b0x15;\n    localparam SBOX_53 = 8'b0x05;\n    localparam SBOX_54 = 8'b0x02;\n    localparam SBOX_55 = 8'b0xc;\n    localparam SBOX_56 = 8'b0xb;\n    localparam SBOX_57 = 8'b0x66;\n    localparam SBOX_58 = 8'b0x28;\n    localparam SBOX_59 = 8'b0x99;\n    localparam SBOX_60 = 8'b0x1b;\n    localparam SBOX_61 = 8'b0x74;\n    localparam SBOX_62 = 8'b0x8;\n    localparam SBOX_63 = 8'b0xb;\n    localparam SBOX_64 = 8'b0x0;\n    localparam SBOX_65 = 8'b0xc1;\n    localparam SBOX_66 = 8'b0x59;\n    localparam SBOX_67 = 8'b0xf;\n    localparam SBOX_68 = 8'b0x6f;\n    localparam SBOX_69 = 8'b0x25;\n    localparam SBOX_70 = 8'b0x52;\n    localparam SBOX_71 = 8'b0x7a;\n    localparam SBOX_72 = 8'b0x85;\n    localparam SBOX_73 = 8'b0x95;\n    localparam SBOX_74 = 8'b0x3b;\n    localparam SBOX_75 = 8'b0x33;\n    localparam SBOX_76 = 8'b0x41;\n    localparam SBOX_77 = 8'b0x99;\n    localparam SBOX_78 = 8'b0x67;\n    localparam SBOX_79 = 8'b0x48;\n    localparam SBOX_80 = 8'b0x04;\n    localparam SBOX_81 = 8'b0x50;\n    localparam SBOX_82 = 8'b0x36;\n    localparam SBOX_83 = 8'b0xc5;\n    localparam SBOX_84 = 8'b0xd8;\n    localparam SBOX_85 = 8'b0x9d;\n    localparam SBOX_86 = 8'b0x83;\n    localparam SBOX_87 = 8'b0x5b;\n    localparam SBOX_88 = 8'b0xa1;\n    localparam SBOX_89 = 8'b0x2a;\n    localparam SBOX_90 = 8'b0x6c;\n    localparam SBOX_91 = 8'b0x41;\n    localparam SBOX_92 = 8'b0x99;\n    localparam SBOX_93 = 8'b0x32;\n    localparam SBOX_94 = 8'b0x5a;\n    localparam SBOX_95 = 8'b0x0;\n    localparam SBOX_96 = 8'b0x0;\n    localparam SBOX_97 = 8'b0x0;\n    localparam SBOX_98 = 8'b0x0;\n    localparam SBOX_99 = 8'b0x0;\n    localparam SBOX_100 = 8'b0x0;\n    localparam SBOX_101 = 8'b0x0;\n    localparam SBOX_102 = 8'b0x0;\n    localparam SBOX_103 = 8'b0x0;\n    localparam SBOX_104 = 8'b0x0;\n    localparam SBOX_105 = 8'b0x0;\n    localparam SBOX_106 = 8'b0x0;\n    localparam SBOX_107 = 8'b0x0;\n    localparam SBOX_108 = 8'b0x0;\n    localparam SBOX_109 = 8'b0x0;\n    localparam SBOX_110 = 8'b0x0;\n    localparam SBOX_111 = 8'b0x0;\n    localparam SBOX_112 = 8'b0x0;\n    localparam SBOX_113 = 8'b0x0;\n    localparam SBOX_114 = 8'b0x0;\n    localparam SBOX_115 = 8'b0x0;\n    localparam SBOX_116 = 8'b0x0;\n    localparam SBOX_117 = 8'b0x0;\n    localparam SBOX_118 = 8'b0x0;\n    localparam SBOX_119 = 8'b0x0;\n    localparam SBOX_120 = 8'b0x0;\n    localparam SBOX_121 = 8'b0x0;\n    localparam SBOX_122 = 8'b0x0;\n    localparam SBOX_123 = 8'b0x0;\n    localparam SBOX_124 = 8'b0x0;\n    localparam SBOX_125 = 8'b0x0;\n    localparam SBOX_126 = 8'b0x0;\n    localparam SBOX_127 = 8'b0x0;\n\n    // S-box lookup table\n    localparam SBOX_LUT = {\n        SBOX_0, SBOX_1, SBOX_2, SBOX_3,\n        SBOX_4, SBOX_5, SBOX_6, SBOX_7,\n        SBOX_8, SBOX_9, SBOX_10, SBOX_11,\n        SBOX_12, SBOX_13, SBOX_14, SBOX_15,\n        SBOX_16, SBOX_17, SBOX_18, SBOX_19,\n        SBOX_20, SBOX_21, SBOX_22, SBOX_23,\n        SBOX_24, SBOX_25, SBOX_26, SBOX_27,\n        SBOX_28, SBOX_29, SBOX_30, SBOX_31,\n        SBOX_32, SBOX_33, SBOX_34, SBOX_35,\n        SBOX_36, SBOX_37, SBOX_38, SBOX_39,\n        SBOX_40, SBOX_41, SBOX_42, SBOX_43,\n        SBOX_44, SBOX_45, SBOX_46, SBOX_47,\n        SBOX_48, SBOX_49, SBOX_50, SBOX_51,\n        SBOX_52, SBOX_53, SBOX_54, SBOX_55,\n        SBOX_56, SBOX_57, SBOX_58, SBOX_59,\n        SBOX_60, SBOX_61, SBOX_62, SBOX_63,\n        SBOX_64, SBOX_65, SBOX_66, SBOX_67,\n        SBOX_68, SBOX_69, SBOX_70, SBOX_71,\n        SBOX_72, SBOX_73, SBOX_74, SBOX_75,\n        SBOX_76, SBOX_77, SBOX_78, SBOX_79,\n        SBOX_80, SBOX_81, SBOX_82, SBOX_83,\n        SBOX_84, SBOX_85, SBOX_86, SBOX_87,\n        SBOX_88, SBOX_89, SBOX_90, SBOX_91,\n        SBOX_92, SBOX_93, SBOX_94, SBOX_95,\n        SBOX_96, SBOX_97, SBOX_98, SBOX_99,\n        SBOX_100, SBOX_101, SBOX_102, SBOX_103,\n        SBOX_104, SBOX_105, SBOX_106, SBOX_107,\n        SBOX_108, SBOX_109, SBOX_110, SBOX_111,\n        SBOX_112, SBOX_113, SBOX_114, SBOX_115,\n        SBOX_116, SBOX_117, SBOX_118, SBOX_119,\n        SBOX_120, SBOX_121, SBOX_122, SBOX_123,\n        SBOX_124, SBOX_125, SBOX_126, SBOX_127\n    };\n\n    // S-box transformation\n    assign b = SBOX_LUT[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 11, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\nreg [31:0] w[4];\nreg [7:0] rcon;\nreg [7:0] sbox[256];\nreg [7:0] byte_reorder[4];\n\n// S-box module\naes_sbox aes_sbox_inst(\n   .a(byte_reorder[0]),\n   .b(sbox[byte_reorder[0]])\n);\n\n// Round constant generator\naes_rcon aes_rcon_inst(\n   .clk(clk),\n   .kld(kld),\n   .out(rcon)\n);\n\n// Key loading operation\nalways @(posedge clk)\nbegin\n    if (kld)\n    begin\n        w[0] <= {key[127:96], key[95:64], key[63:32], key[31:0]};\n        w[1] <= {key[95:64], key[63:32], key[31:0], 0};\n        w[2] <= {key[63:32], key[31:0], 0, 0};\n        w[3] <= {key[31:0], 0, 0, 0};\n        wo_0 <= w[0];\n        wo_1 <= w[1];\n        wo_2 <= w[2];\n        wo_3 <= w[3];\n    end\nend\n\n// Key expansion operation\nalways @(posedge clk)\nbegin\n    if (!kld)\n    begin\n        w[0] <= w[3] ^ aes_sbox_inst.sbox[byte_reorder[0]] ^ rcon;\n        w[1] <= w[3] ^ w[0] ^ aes_sbox_inst.sbox[byte_reorder[1]] ^ rcon;\n        w[2] <= w[3] ^ w[0] ^ w[1] ^ aes_sbox_inst.sbox[byte_reorder[2]] ^ rcon;\n        w[3] <= w[3] ^ w[0] ^ w[1] ^ w[2] ^ aes_sbox_inst.sbox[byte_reorder[3]] ^ rcon;\n        wo_0 <= w[0];\n        wo_1 <= w[1];\n        wo_2 <= w[2];\n        wo_3 <= w[3];\n    end\nend\n\n// S-box transformation\nalways @*\nbegin\n    byte_reorder[0] = w[0][7:0];\n    byte_reorder[1] = w[0][15:8];\n    byte_reorder[2] = w[0][23:16];\n    byte_reorder[3] = w[0][31:24];\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 12, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w0, w1, w2, w3;\n    reg [31:0] rcon;\n    reg [7:0] sbox_out[4];\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w0 <= {key[127:96], 8'b0};\n            w1 <= {key[95:64], 8'b0};\n            w2 <= {key[63:32], 8'b0};\n            w3 <= {key[31:0], 8'b0};\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n        end else begin\n            w0 <= w3 ^ aes_sbox(RotWord(w3)) ^ rcon;\n            w1 <= w2 ^ aes_sbox(RotWord(w2)) ^ w0 ^ rcon;\n            w2 <= w1 ^ aes_sbox(RotWord(w1)) ^ w0 ^ w1 ^ rcon;\n            w3 <= w0 ^ aes_sbox(RotWord(w0)) ^ w0 ^ w1 ^ w2 ^ rcon;\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n            rcon <= aes_rcon(rcon);\n        end\n    end\n\n    function [7:0] RotWord([7:0] w);\n        begin\n            RotWord = {w[6:0], w[7]};\n        end\n    endfunction\n\n    function [7:0] aes_sbox([7:0] a);\n        begin\n            case (a)\n                8'b10100000: aes_sbox = 8'b10001101;\n                8'b11000001: aes_sbox = 8'b01001110;\n                8'b11100010: aes_sbox = 8'b00110100;\n                8'b11110011: aes_sbox = 8'b01111001;\n                8'b11111000: aes_sbox = 8'b10110110;\n                8'b11111101: aes_sbox = 8'b11010101;\n                8'b11111110: aes_sbox = 8'b01011100;\n                8'b11111111: aes_sbox = 8'b01100101;\n                default: aes_sbox = a;\n            endcase\n        end\n    endfunction\n\n    module aes_rcon(\n        input clk,\n        input kld,\n        output [31:0] out\n    );\n        reg [31:0] rcon;\n        integer i;\n\n        always @(posedge clk) begin\n            if (kld) begin\n                rcon <= 32'h01;\n            end else begin\n                rcon <= rcon << 1;\n                if (rcon[31]) begin\n                    rcon[31:24] <= {rcon[31:24] ^ 0x01, rcon[23:0]};\n                end\n            end\n        end\n\n        assign out = rcon;\n    endmodule\n\n    module aes_sbox(\n        input [7:0] a,\n        output [7:0] b\n    );\n        reg [7:0] sbox_out[4];\n\n        always @(*) begin\n            case (a)\n                8'b10100000: b = 8'b10001101;\n                8'b11000001: b = 8'b01001110;\n                8'b11100010: b = 8'b00110100;\n                8'b11110011: b = 8'b01111001;\n                8'b11111000: b = 8'b10110110;\n                8'b11111101: b = 8'b11010101;\n                8'b11111110: b = 8'b01011100;\n                8'b11111111: b = 8'b01100101;\n                default: b = a;\n            endcase\n        end\n    endmodule\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 13, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\n    reg [31:0] w0, w1, w2, w3;\n    reg [31:0] rcon;\n    reg [7:0] sbox_out[4];\n\n    aes_rcon aes_rcon_inst(\n       .clk(clk),\n       .kld(kld),\n       .out(rcon)\n    );\n\n    aes_sbox aes_sbox_inst0(\n       .a(key[31:24]),\n       .b(sbox_out[0])\n    );\n\n    aes_sbox aes_sbox_inst1(\n       .a(key[23:16]),\n       .b(sbox_out[1])\n    );\n\n    aes_sbox aes_sbox_inst2(\n       .a(key[15:8]),\n       .b(sbox_out[2])\n    );\n\n    aes_sbox aes_sbox_inst3(\n       .a(key[7:0]),\n       .b(sbox_out[3])\n    );\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w0 <= key[127:96];\n            w1 <= key[95:64];\n            w2 <= key[63:32];\n            w3 <= key[31:0];\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n        end else begin\n            w0 <= w0 ^ (w3 ^ aes_sbox_inst0.b);\n            w1 <= w1 ^ (w3 ^ aes_sbox_inst0.b ^ aes_sbox_inst1.b);\n            w2 <= w2 ^ (w3 ^ aes_sbox_inst0.b ^ aes_sbox_inst1.b ^ aes_sbox_inst2.b);\n            w3 <= w3 ^ (w0 ^ aes_sbox_inst0.b ^ aes_sbox_inst1.b ^ aes_sbox_inst2.b ^ aes_sbox_inst3.b ^ rcon);\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 14, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w0, w1, w2, w3;\n    reg [31:0] rcon;\n    reg [7:0] sbox_result[4];\n\n    // S-box module\n    aes_sbox sbox(\n       .a(key[7:0]),\n       .b(sbox_result[0])\n    );\n\n    aes_sbox sbox1(\n       .a(key[15:8]),\n       .b(sbox_result[1])\n    );\n\n    aes_sbox sbox2(\n       .a(key[23:16]),\n       .b(sbox_result[2])\n    );\n\n    aes_sbox sbox3(\n       .a(key[31:24]),\n       .b(sbox_result[3])\n    );\n\n    // Round constant generator\n    aes_rcon rcon_gen(\n       .clk(clk),\n       .kld(kld),\n       .out(rcon)\n    );\n\n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            w0 <= key[127:96];\n            w1 <= key[95:64];\n            w2 <= key[63:32];\n            w3 <= key[31:0];\n        end else begin\n            w0 <= w0 ^ (w3 ^ sbox_result[0] ^ rcon);\n            w1 <= w1 ^ (w3 ^ (sbox_result[0] ^ sbox_result[1]) ^ rcon);\n            w2 <= w2 ^ (w3 ^ (sbox_result[0] ^ sbox_result[1] ^ sbox_result[2]) ^ rcon);\n            w3 <= w3 ^ (w3 ^ (sbox_result[0] ^ sbox_result[1] ^ sbox_result[2] ^ sbox_result[3]) ^ rcon);\n        end\n    end\n\n    // Output round key words\n    assign wo_0 = w0;\n    assign wo_1 = w1;\n    assign wo_2 = w2;\n    assign wo_3 = w3;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 15, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w0, w1, w2, w3;\n    reg [31:0] rcon;\n    reg [7:0] sbox[256];\n    reg [7:0] key_byte[4];\n\n    // S-box module\n    aes_sbox sbox_module(\n        .a(key_byte[0]),\n        .b(sbox[0])\n    );\n    aes_sbox sbox_module_1(\n        .a(key_byte[1]),\n        .b(sbox[1])\n    );\n    aes_sbox sbox_module_2(\n        .a(key_byte[2]),\n        .b(sbox[2])\n    );\n    aes_sbox sbox_module_3(\n        .a(key_byte[3]),\n        .b(sbox[3])\n    );\n\n    // Round constant generator\n    aes_rcon rcon_module(\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    // Key loading operation\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            w0 <= {key[127:96], 32'b0};\n            w1 <= {key[95:64], 32'b0};\n            w2 <= {key[63:32], 32'b0};\n            w3 <= {key[31:0], 32'b0};\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n        end\n        else\n        begin\n            // Perform expansion\n            w0 <= w3;\n            w1 <= w0 ^ (w1 ^ sbox[0]);\n            w2 <= w1 ^ (w2 ^ sbox[1]);\n            w3 <= w2 ^ (w3 ^ sbox[2]);\n        end\n    end\n\n    // S-box transformation\n    assign key_byte[0] = w0[7:0];\n    assign key_byte[1] = w0[15:8];\n    assign key_byte[2] = w1[7:0];\n    assign key_byte[3] = w1[15:8];\n\n    // Round constant operation\n    assign rcon = rcon_module.out;\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n    reg [31:0] count = 1;\n    reg [31:0] rcon_val = 1;\n\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            count <= 1;\n            rcon_val <= 1;\n        end\n        else\n        begin\n            count <= count + 1;\n            case (count)\n                1: rcon_val <= 1;\n                2: rcon_val <= 2;\n                3: rcon_val <= 3;\n                4: rcon_val <= 4;\n                5: rcon_val <= 5;\n                6: rcon_val <= 10;\n                7: rcon_val <= 11;\n                8: rcon_val <= 13;\n                9: rcon_val <= 14;\n                10: rcon_val <= 15;\n                11: rcon_val <= 16;\n                12: rcon_val <= 17;\n                13: rcon_val <= 19;\n                14: rcon_val <= 21;\n                15: rcon_val <= 22;\n                16: rcon_val <= 23;\n                17: rcon_val <= 24;\n                18: rcon_val <= 25;\n                19: rcon_val <= 27;\n                20: rcon_val <= 28;\n                21: rcon_val <= 30;\n                22: rcon_val <= 31;\n                23: rcon_val <= 32;\n                24: rcon_val <= 33;\n                25: rcon_val <= 35;\n                26: rcon_val <= 36;\n                27: rcon_val <= 38;\n                28: rcon_val <= 39;\n                29: rcon_val <= 41;\n                30: rcon_val <= 42;\n                31: rcon_val <= 43;\n                32: rcon_val <= 45;\n                33: rcon_val <= 46;\n                34: rcon_val <= 48;\n                35: rcon_val <= 49;\n                36: rcon_val <= 51;\n                37: rcon_val <= 52;\n                38: rcon_val <= 53;\n                39: rcon_val <= 55;\n                40: rcon_val <= 56;\n                41: rcon_val <= 58;\n                42: rcon_val <= 59;\n                43: rcon_val <= 61;\n                44: rcon_val <= 62;\n                45: rcon_val <= 63;\n                46: rcon_val <= 64;\n                47: rcon_val <= 65;\n                48: rcon_val <= 67;\n                49: rcon_val <= 68;\n                50: rcon_val <= 70;\n                51: rcon_val <= 71;\n                52: rcon_val <= 73;\n                53: rcon_val <= 74;\n                54: rcon_val <= 76;\n                55: rcon_val <= 77;\n                56: rcon_val <= 79;\n                57: rcon_val <= 80;\n                58: rcon_val <= 81;\n                59: rcon_val <= 83;\n                60: rcon_val <= 84;\n                61: rcon_val <= 86;\n                62: rcon_val <= 87;\n                63: rcon_val <= 89;\n                64: rcon_val <= 90;\n                65: rcon_val <= 92;\n                66: rcon_val <= 93;\n                67: rcon_val <= 95;\n                68: rcon_val <= 96;\n                69: rcon_val <= 98;\n                70: rcon_val <= 99;\n                71: rcon_val <= 101;\n                72: rcon_val <= 102;\n                73: rcon_val <= 104;\n                74: rcon_val <= 105;\n                75: rcon_val <= 107;\n                76: rcon_val <= 108;\n                77: rcon_val <= 110;\n                78: rcon_val <= 111;\n                79: rcon_val <= 113;\n                80: rcon_val <= 114;\n                81: rcon_val <= 116;\n                82: rcon_val <= 117;\n                83: rcon_val <= 119;\n                84: rcon_val <= 120;\n                85: rcon_val <= 122;\n                86: rcon_val <= 123;\n                87: rcon_val <= 125;\n                88: rcon_val <= 126;\n                89: rcon_val <= 128;\n                90: rcon_val <= 129;\n                91: rcon_val <= 131;\n                92: rcon_val <= 132;\n                93: rcon_val <= 134;\n                94: rcon_val <= 135;\n                95: rcon_val <= 137;\n                96: rcon_val <= 138;\n                97: rcon_val <= 140;\n                98: rcon_val <= 141;\n                99: rcon_val <= 143;\n                100: rcon_val <= 144;\n                101: rcon_val <= 146;\n                102: rcon_val <= 147;\n                103: rcon_val <= 149;\n                104: rcon_val <= 150;\n                105: rcon_val <= 152;\n                106: rcon_val <= 153;\n                107: rcon_val <= 155;\n                108: rcon_val <= 156;\n                109: rcon_val <= 158;\n                110: rcon_val <= 159;\n                111: rcon_val <= 161;\n                112: rcon_val <= 162;\n                113: rcon_val <= 164;\n                114: rcon_val <= 165;\n                115: rcon_val <= 167;\n                116: rcon_val <= 168;\n                117: rcon_val <= 170;\n                118: rcon_val <= 171;\n                119: rcon_val <= 173;\n                120: rcon_val <= 174;\n                121: rcon_val <= 176;\n                122: rcon_val <= 177;\n                123: rcon_val <= 179;\n                124: rcon_val <= 180;\n                125: rcon_val <= 182;\n                126: rcon_val <= 183;\n                127: rcon_val <= 185;\n                128: rcon_val <= 186;\n                129: rcon_val <= 188;\n                130: rcon_val <= 189;\n                131: rcon_val <= 191;\n                132: rcon_val <= 192;\n                133: rcon_val <= 194;\n                134: rcon_val <= 195;\n                135: rcon_val <= 197;\n                136: rcon_val <= 198;\n                137: rcon_val <= 200;\n                138: rcon_val <= 201;\n                139: rcon_val <= 203;\n                140: rcon_val <= 204;\n                141: rcon_val <= 206;\n                142: rcon_val <= 207;\n                143: rcon_val <= 209;\n                144: rcon_val <= 210;\n                145: rcon_val <= 212;\n                146: rcon_val <= 213;\n                147: rcon_val <= 215;\n                148: rcon_val <= 216;\n                149: rcon_val <= 218;\n                150: rcon_val <= 219;\n                151: rcon_val <= 221;\n                152: rcon_val <= 222;\n                153: rcon_val <= 224;\n                154: rcon_val <= 225;\n                155: rcon_val <= 227;\n                156: rcon_val <= 228;\n                157: rcon_val <= 230;\n                158: rcon_val <= 231;\n                159: rcon_val <= 233;\n                160: rcon_val <= 234;\n                161: rcon_val <= 236;\n                162: rcon_val <= 237;\n                163: rcon_val <= 239;\n                164: rcon_val <= 240;\n                165: rcon_val <= 242;\n                166: rcon_val <= 243;\n                167: rcon_val <= 245;\n                168: rcon_val <= 246;\n                169: rcon_val <= 248;\n                170: rcon_val <= 249;\n                171: rcon_val <= 251;\n                172: rcon_val <= 252;\n                173: rcon_val <= 254;\n                174: rcon_val <= 255;\n                default: rcon_val <= 0;\n            endcase\n            out <= rcon_val;\n        end\n    end\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n    case (a)\n        8'h00: b = 8'h63;\n        8'h01: b = 8'h7c;\n        8'h02: b = 8'h77;\n        8'h03: b = 8'e7;\n        8'h04: b = 8'bf;\n        8'h05: b = 8'c6;\n        8'h06: b = 8'9f;\n        8'h07: b = 8'ef;\n        8'h08: b = 8'ee;\n        8'h09: b = 8'ab;\n        8'h0a: b = 8'4b;\n        8'h0b: b = 8'4d;\n        8'h0c: b = 8'93;\n        8'h0d: b = 8'9d;\n        8'h0e: b = 8'af;\n        8'h0f: b = 8'bd;\n        8'h10: b = 8'be;\n        8'h11: b = 8'7f;\n        8'h12: b = 8'3f;\n        8'h13: b = 8'8f;\n        8'h14: b = 8'34;\n        8'h15: b = 8'32;\n        8'h16: b = 8'6a;\n        8'h17: b = 8'28;\n        8'h18: b = 8'1b;\n        8'h19: b = 8'15;\n        8'h1a: b = 8'04;\n        8'h1b: b = 8'0c;\n        8'h1c: b = 8'18;\n        8'h1d: b = 8'35;\n        8'h1e: b = 8'2f;\n        8'h1f: b = 8'8e;\n        8'h20: b = 8'37;\n        8'h21: b = 8'1d;\n        8'h22: b = 8'2e;\n        8'h23: b = 8'7f;\n        8'h24: b = 8'3d;\n        8'h25: b = 8'9d;\n        8'h26: b = 8'1f;\n        8'h27: b = 8'37;\n        8'h28: b = 8'6d;\n        8'h29: b = 8'5b;\n        8'h2a: b = 8'9b;\n        8'h2b: b = 8'85;\n        8'h2c: b = 8'4b;\n        8'h2d: b = 8'8a;\n        8'h2e: b = 8'1d;\n        8'h2f: b = 8'4d;\n        8'h30: b = 8'9a;\n        8'h31: b = 8'47;\n        8'h32: b = 8'17;\n        8'h33: b = 8'9c;\n        8'h34: b = 8'b7;\n        8'h35: b = 8'df;\n        8'h36: b = 8'3f;\n        8'h37: b = 8'15;\n        8'h38: b = 8'6d;\n        8'h39: b = 8'9d;\n        8'h3a: b = 8'83;\n        8'h3b: b = 8'2c;\n        8'h3c: b = 8'1f;\n        8'h3d: b = 8'12;\n        8'h3e: b = 8'1b;\n        8'h3f: b = 8'6b;\n        default: b = 8'h00;\n    endcase\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 1, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 4'b0000;\n        rcon <= 32'h00000001;\n    end else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            4'b0000: rcon <= 32'h00000001;\n            4'b0001: rcon <= 32'h00000002;\n            4'b0010: rcon <= 32'h00000004;\n            4'b0011: rcon <= 32'h00000008;\n            4'b0100: rcon <= 32'h00000010;\n            4'b0101: rcon <= 32'h00000020;\n            4'b0110: rcon <= 32'h00000040;\n            4'b0111: rcon <= 32'h00000080;\n            4'b1000: rcon <= 32'h0000001b;\n            4'b1001: rcon <= 32'h00000036;\n            default: rcon <= 32'h00000000;\n        endcase\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 2, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        rcon <= 32'h01000000;\n    end else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon <= 32'h02000000;\n            2: rcon <= 32'h04000000;\n            3: rcon <= 32'h08000000;\n            4: rcon <= 32'h10000000;\n            5: rcon <= 32'h20000000;\n            6: rcon <= 32'h40000000;\n            7: rcon <= 32'h80000000;\n            8: rcon <= 32'h1b000000;\n            9: rcon <= 32'h36000000;\n            default: rcon <= 32'h00000000;\n        endcase\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 3, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\ninitial begin\n    rcnt = 4'b0000;\n    rcon = 32'h00000001;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 4'b0000;\n        rcon <= 32'h00000001;\n    end\n    else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            4'b0000: rcon <= 32'h00000001;\n            4'b0001: rcon <= 32'h00000002;\n            4'b0010: rcon <= 32'h00000004;\n            4'b0011: rcon <= 32'h00000008;\n            4'b0100: rcon <= 32'h00000010;\n            4'b0101: rcon <= 32'h00000020;\n            4'b0110: rcon <= 32'h00000040;\n            4'b0111: rcon <= 32'h00000080;\n            4'b1000: rcon <= 32'h0000001b;\n            4'b1001: rcon <= 32'h00000036;\n            default: rcon <= 32'h00000000;\n        endcase\n    end\nend\n\nassign out = rcon;\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 4, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        rcon <= 32'h01000000;\n    end else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon <= 32'h02000000;\n            2: rcon <= 32'h04000000;\n            3: rcon <= 32'h08000000;\n            4: rcon <= 32'h10000000;\n            5: rcon <= 32'h20000000;\n            6: rcon <= 32'h40000000;\n            7: rcon <= 32'h80000000;\n            8: rcon <= 32'h1b000000;\n            9: rcon <= 32'h36000000;\n            default: rcon <= 32'h00000000;\n        endcase\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 5, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        rcon <= 32'h01000000;\n    end else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon <= 32'h02000000;\n            2: rcon <= 32'h04000000;\n            3: rcon <= 32'h08000000;\n            4: rcon <= 32'h10000000;\n            5: rcon <= 32'h20000000;\n            6: rcon <= 32'h40000000;\n            7: rcon <= 32'h80000000;\n            8: rcon <= 32'h1b000000;\n            9: rcon <= 32'h36000000;\n            default: rcon <= 32'h00000000;\n        endcase\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 6, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\ninitial begin\n    rcnt = 0;\n    rcon = 32'h01_00_00_00;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        rcon <= 32'h01_00_00_00;\n    end\n    else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon <= 32'h02_00_00_00;\n            2: rcon <= 32'h04_00_00_00;\n            3: rcon <= 32'h08_00_00_00;\n            4: rcon <= 32'h10_00_00_00;\n            5: rcon <= 32'h20_00_00_00;\n            6: rcon <= 32'h40_00_00_00;\n            7: rcon <= 32'h80_00_00_00;\n            8: rcon <= 32'h1b_00_00_00;\n            9: rcon <= 32'h36_00_00_00;\n            default: rcon <= 32'h00_00_00_00;\n        endcase\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 7, "code": "module aes_rcon(\n    input  wire clk,\n    input  wire kld,\n    output reg [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\ninitial begin\n    rcnt = 0;\n    rcon = 32'h01_00_00_00;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        rcon <= 32'h01_00_00_00;\n    end else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon <= 32'h02_00_00_00;\n            2: rcon <= 32'h04_00_00_00;\n            3: rcon <= 32'h08_00_00_00;\n            4: rcon <= 32'h10_00_00_00;\n            5: rcon <= 32'h20_00_00_00;\n            6: rcon <= 32'h40_00_00_00;\n            7: rcon <= 32'h80_00_00_00;\n            8: rcon <= 32'h1b_00_00_00;\n            9: rcon <= 32'h36_00_00_00;\n            default: rcon <= 32'h00_00_00_00;\n        endcase\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 8, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\ninitial begin\n    rcnt = 0;\n    rcon = 32'h01_00_00_00;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        rcon <= 32'h01_00_00_00;\n    end\n    else begin\n        rcnt <= rcnt + 1;\n        if (rcnt > 9) begin\n            rcon <= 32'h00_00_00_00;\n        end\n        else begin\n            rcon <= {rcon[7:0], rcon[7:0] << 8};\n        end\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 9, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output reg[31:0] out\n);\n\nreg[3:0] rcnt;\nreg[7:0] rcon;\n\ninitial begin\n    rcnt = 0;\n    out = 32'h01_00_00_00;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        out <= 32'h01_00_00_00;\n    end else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon = 8'h02;\n            2: rcon = 8'h04;\n            3: rcon = 8'h08;\n            4: rcon = 8'h10;\n            5: rcon = 8'h20;\n            6: rcon = 8'h40;\n            7: rcon = 8'h80;\n            8: rcon = 8'h1b;\n            9: rcon = 8'h36;\n            default: rcon = 8'h00;\n        endcase\n        out <= {24'b0, rcon};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 10, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\ninitial begin\n    rcnt = 0;\n    rcon = 32'h01;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        rcon <= 32'h01000000;\n    end\n    else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon <= 32'h00000002;\n            2: rcon <= 32'h00000004;\n            3: rcon <= 32'h00000008;\n            4: rcon <= 32'h00000010;\n            5: rcon <= 32'h00000020;\n            6: rcon <= 32'h00000040;\n            7: rcon <= 32'h00000080;\n            8: rcon <= 32'h0000001b;\n            9: rcon <= 32'h00000036;\n            default: rcon <= 32'h00000000;\n        endcase\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 11, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\ninitial begin\n    rcnt = 0;\n    rcon = 32'h01_00_00_00;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        rcon <= 32'h01_00_00_00;\n    end\n    else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon <= 32'h02_00_00_00;\n            2: rcon <= 32'h04_00_00_00;\n            3: rcon <= 32'h08_00_00_00;\n            4: rcon <= 32'h10_00_00_00;\n            5: rcon <= 32'h20_00_00_00;\n            6: rcon <= 32'h40_00_00_00;\n            7: rcon <= 32'h80_00_00_00;\n            8: rcon <= 32'h1b_00_00_00;\n            9: rcon <= 32'h36_00_00_00;\n            default: rcon <= 32'h00_00_00_00;\n        endcase\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 12, "code": "module aes_rcon(\n    input  wire clk,\n    input  wire kld,\n    output reg [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon [0:9];\n\ninitial begin\n    for (int i = 0; i <= 9; i++) begin\n        rcon[i] = 32'h00000001;\n        for (int j = 1; j <= i; j++) begin\n            rcon[i] = rcon[i] << 1;\n            if (rcon[i][7] == 1'b1) begin\n                rcon[i] = rcon[i] ^ 32'h011b;\n            end\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (kld == 1'b1) begin\n        rcnt <= 4'b0000;\n        out <= 32'h00000001;\n    end\n    else begin\n        if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            out <= rcon[rcnt];\n        end\n        else begin\n            rcnt <= rcnt + 1;\n            out <= 32'h00000000;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 13, "code": "module aes_rcon (\n    input  wire clk,\n    input  wire kld,\n    output reg [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [7:0] rcon;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        out <= 32'h01000000;\n    end\n    else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            4'd0: rcon = 8'h01;\n            4'd1: rcon = 8'h02;\n            4'd2: rcon = 8'h04;\n            4'd3: rcon = 8'h08;\n            4'd4: rcon = 8'h10;\n            4'd5: rcon = 8'h20;\n            4'd6: rcon = 8'h40;\n            4'd7: rcon = 8'h80;\n            4'd8: rcon = 8'h1b;\n            4'd9: rcon = 8'h36;\n            default: rcon = 8'h00;\n        endcase\n        out <= {24{1'b0}, rcon};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 14, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [7:0] rcon;\n\ninitial begin\n    rcnt = 0;\n    out = 32'h01_00_00_00;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        out <= 32'h01_00_00_00;\n    end else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon = 8'h02;\n            2: rcon = 8'h04;\n            3: rcon = 8'h08;\n            4: rcon = 8'h10;\n            5: rcon = 8'h20;\n            6: rcon = 8'h40;\n            7: rcon = 8'h80;\n            8: rcon = 8'h1b;\n            9: rcon = 8'h36;\n            default: rcon = 8'h00;\n        endcase\n        out <= {24'b0, rcon};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 1, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table\n    reg [7:0] sbox[256] = {\n        //... lookup table values...\n    };\n\n    // Affine transformation constants\n    reg [7:0] c = 8'h63;\n\n    // Compute S-box value\n    reg [7:0] sbox_value;\n\n    // Compute multiplicative inverse\n    reg [7:0] inverse;\n\n    // Compute affine transformation\n    reg [7:0] affine;\n\n    // Compute final result\n    reg [7:0] result;\n\n    // Compute S-box value\n    assign sbox_value = sbox[a];\n\n    // Compute multiplicative inverse\n    assign inverse = a == 8'h00? 8'h00 : sbox[255 - a];\n\n    // Compute affine transformation\n    assign affine = {\n        inverse[0] ^ inverse[4] ^ inverse[5] ^ inverse[6] ^ inverse[7] ^ c[0],\n        inverse[1] ^ inverse[5] ^ inverse[6] ^ inverse[7] ^ c[1],\n        inverse[2] ^ inverse[3] ^ inverse[6] ^ inverse[7] ^ c[2],\n        inverse[3] ^ inverse[4] ^ inverse[5] ^ inverse[7] ^ c[3],\n        inverse[4] ^ inverse[5] ^ inverse[6] ^ inverse[7] ^ c[4],\n        inverse[5] ^ inverse[6] ^ inverse[7] ^ c[5],\n        inverse[6] ^ inverse[7] ^ c[6],\n        inverse[7] ^ c[7]\n    };\n\n    // Compute final result\n    assign result = sbox_value ^ affine;\n\n    // Output result\n    assign b = result;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 2, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the S-box values\n    reg [7:0] sbox_values [255:0];\n\n    // Initialize the S-box values\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox_values[i] = i;\n        end\n    end\n\n    // Define the affine transformation matrix\n    reg [7:0] affine_matrix [7:0];\n\n    // Initialize the affine transformation matrix\n    initial begin\n        affine_matrix[0] = 8'h63;\n        affine_matrix[1] = 8'h0;\n        affine_matrix[2] = 8'h0;\n        affine_matrix[3] = 8'h0;\n        affine_matrix[4] = 8'h0;\n        affine_matrix[5] = 8'h0;\n        affine_matrix[6] = 8'h0;\n        affine_matrix[7] = 8'h0;\n    end\n\n    // Define the multiplicative inverse function\n    function [7:0] multiplicative_inverse(input [7:0] a);\n        reg [7:0] temp;\n        temp = a;\n        for (int i = 0; i < 8; i++) begin\n            if (temp[7] == 1) begin\n                temp = temp ^ 8'h1b;\n            end\n            temp = temp >> 1;\n        end\n        return temp;\n    endfunction\n\n    // Define the affine transformation function\n    function [7:0] affine_transform(input [7:0] a);\n        reg [7:0] temp;\n        temp = a;\n        for (int i = 0; i < 8; i++) begin\n            temp[i] = temp[i] ^ temp[i+4] ^ temp[i+5] ^ temp[i+6] ^ temp[i+7] ^ affine_matrix[i];\n        end\n        return temp;\n    endfunction\n\n    // Define the S-box function\n    function [7:0] sbox(input [7:0] a);\n        reg [7:0] temp;\n        temp = multiplicative_inverse(a);\n        temp = affine_transform(temp);\n        return temp;\n    endfunction\n\n    // Assign the S-box value to the output\n    assign b = sbox_values[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 3, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the S-box values\n    localparam [7:0] sbox_values[256] = {\n        0x63, 0x5c, 0x37, 0x2a, 0x7d, 0xfa, 0x7f, 0x9f,\n        0x25, 0x8e, 0x78, 0x6c, 0x5e, 0x5a, 0x35, 0x4d,\n        0x45, 0x41, 0x4f, 0x31, 0x0a, 0x1a, 0x28, 0x0e,\n        0x5b, 0x8f, 0x0d, 0x0b, 0x0c, 0x18, 0x8a, 0x6d,\n        0x8d, 0x8b, 0x0f, 0x5d, 0x3a, 0x9f, 0x21, 0x1b,\n        0x76, 0x6f, 0x36, 0x56, 0x0a, 0x7a, 0x4a, 0x4c,\n        0x4e, 0x6a, 0x5c, 0x9c, 0x2e, 0x2d, 0x2c, 0x2f,\n        0x2b, 0x2a, 0x2g, 0x2h, 0x2i, 0x2j, 0x2k, 0x2l,\n        0x2m, 0x2n, 0x2o, 0x2p, 0x2q, 0x2r, 0x2s, 0x2t,\n        0x2u, 0x2v, 0x2w, 0x2x, 0x2y, 0x2z, 0x30, 0x31,\n        0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,\n        0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41,\n        0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,\n        0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51,\n        0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,\n        0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61,\n        0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,\n        0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71,\n        0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,\n        0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81,\n        0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,\n        0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91,\n        0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,\n        0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1,\n        0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9,\n        0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1,\n        0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9,\n        0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1,\n        0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9,\n        0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1,\n        0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9,\n        0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1,\n        0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,\n        0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1,\n        0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9,\n        0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff\n    };\n\n    // Define the affine transformation constants\n    localparam [7:0] affine_constants = 8'h63;\n\n    // Calculate the output byte\n    assign b = sbox_values[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 4, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table\n    reg [7:0] sbox [255:0];\n\n    // Initialize S-box values\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n            // Apply S-box transformation\n            for (int j = 0; j < 8; j++) begin\n                sbox[i] = sbox[i] ^ (sbox[i] << 1) ^ (sbox[i] << 2) ^ (sbox[i] << 3) ^ (sbox[i] << 4);\n            end\n            // Apply affine transformation\n            for (int j = 0; j < 8; j++) begin\n                sbox[i] = sbox[i] ^ (sbox[i] >> 1) ^ (sbox[i] >> 2) ^ (sbox[i] >> 3) ^ (sbox[i] >> 4) ^ 0x63;\n            end\n        end\n    end\n\n    // Output the substituted byte\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 5, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the S-box values\n    reg [7:0] sbox [255:0];\n\n    // Initialize the S-box values\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n            for (int j = 0; j < 8; j++) begin\n                sbox[i] = sbox[i] << 1;\n                if (sbox[i] & 0x80) begin\n                    sbox[i] = sbox[i] ^ 0x1b;\n                end\n            end\n        end\n    end\n\n    // Define the affine transformation constants\n    reg [7:0] c = 8'd63;\n\n    // Perform the S-box transformation\n    always @(*) begin\n        b = sbox[a];\n        for (int i = 0; i < 8; i++) begin\n            b[i] = b[i] ^ b[(i + 4) % 8] ^ b[(i + 5) % 8] ^ b[(i + 6) % 8] ^ b[(i + 7) % 8] ^ c[i];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 6, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the S-box values\n    reg [7:0] sbox [255:0];\n\n    // Initialize the S-box values\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n            // Perform the S-box transformation\n            for (int j = 0; j < 8; j++) begin\n                sbox[i] = sbox[i] ^ (sbox[i] << j);\n            end\n            // Apply the affine transformation\n            for (int j = 0; j < 8; j++) begin\n                sbox[i] = sbox[i] ^ ((sbox[i] >> j) & 1);\n            end\n        end\n    end\n\n    // Output the substituted byte\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 7, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table\n    reg [7:0] sbox [255:0];\n\n    // Initialize the S-box table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n            for (int j = 0; j < 8; j++) begin\n                sbox[i] = sbox[i] << 1;\n                if (sbox[i] & 0x80) sbox[i] ^= 0x11b;\n            end\n            sbox[i] ^= 0x63;\n        end\n    end\n\n    // Compute the S-box output\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 8, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the S-box table\n    reg [7:0] sbox [255:0];\n\n    // Initialize the S-box table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n            for (int j = 0; j < 8; j++) begin\n                sbox[i] = sbox[i] ^ (sbox[i] >> j);\n            end\n            sbox[i] = sbox[i] ^ 0x11b;\n        end\n    end\n\n    // Compute the multiplicative inverse in GF(2^8)\n    reg [7:0] inv_a;\n\n    assign inv_a = sbox[a];\n\n    // Apply the affine transformation\n    assign b = inv_a ^ (inv_a >> 4) ^ (inv_a >> 5) ^ (inv_a >> 6) ^ (inv_a >> 7) ^ 0x63;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 9, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the S-box values\n    reg [7:0] sbox_values[256] = {\n        //... (insert 256 S-box values here)\n    };\n\n    // Use a lookup table to store all the S-box outputs values for their corresponding inputs\n    assign b = sbox_values[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 10, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table\n    reg [7:0] sbox [255:0];\n\n    // Initialize S-box values\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n            for (int j = 0; j < 8; j++) begin\n                if (sbox[i] & (1 << j)) begin\n                    sbox[i] = sbox[i] ^ (1 << (j + 1));\n                end\n            end\n            sbox[i] = sbox[i] ^ 0x11b;\n            sbox[i] = sbox[i] ^ (sbox[i] << 1);\n            sbox[i] = sbox[i] ^ (sbox[i] << 2);\n            sbox[i] = sbox[i] ^ (sbox[i] << 4);\n            sbox[i] = sbox[i] ^ (sbox[i] << 5);\n            sbox[i] = sbox[i] ^ (sbox[i] << 7);\n            sbox[i] = sbox[i] ^ 0x63;\n        end\n    end\n\n    // S-box lookup\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 15, "code": "module aes_rcon(\n    input  wire clk,\n    input  wire kld,\n    output wire [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\ninitial begin\n    rcnt = 0;\n    rcon = 32'h01_00_00_00;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        rcon <= 32'h01_00_00_00;\n    end else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon <= 32'h02_00_00_00;\n            2: rcon <= 32'h04_00_00_00;\n            3: rcon <= 32'h08_00_00_00;\n            4: rcon <= 32'h10_00_00_00;\n            5: rcon <= 32'h20_00_00_00;\n            6: rcon <= 32'h40_00_00_00;\n            7: rcon <= 32'h80_00_00_00;\n            8: rcon <= 32'h1b_00_00_00;\n            9: rcon <= 32'h36_00_00_00;\n            default: rcon <= 32'h00_00_00_00;\n        endcase\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 16, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\ninitial begin\n    rcnt = 0;\n    rcon = 32'h01_00_00_00;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        rcon <= 32'h01_00_00_00;\n    end\n    else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon <= 32'h02_00_00_00;\n            2: rcon <= 32'h04_00_00_00;\n            3: rcon <= 32'h08_00_00_00;\n            4: rcon <= 32'h10_00_00_00;\n            5: rcon <= 32'h20_00_00_00;\n            6: rcon <= 32'h40_00_00_00;\n            7: rcon <= 32'h80_00_00_00;\n            8: rcon <= 32'h1b_00_00_00;\n            9: rcon <= 32'h36_00_00_00;\n            default: rcon <= 32'h00_00_00_00;\n        endcase\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 11, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n// Define the S-box values\nreg [7:0] sbox_values[256];\n\n// Initialize the S-box values\ninitial begin\n    for (int i = 0; i < 256; i++) begin\n        sbox_values[i] = i;\n        // Apply the S-box transformation\n        for (int j = 0; j < 8; j++) begin\n            sbox_values[i][j] = (sbox_values[i][j] ^ sbox_values[i][(j + 4) % 8] ^ sbox_values[i][(j + 5) % 8] ^ sbox_values[i][(j + 6) % 8] ^ sbox_values[i][(j + 7) % 8] ^ 0x63[j]);\n        end\n    end\nend\n\n// Lookup table implementation\nassign b = sbox_values[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 12, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table\n    reg [7:0] sbox [255:0];\n\n    // Initialize S-box values\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n            // Apply S-box transformation\n            for (int j = 0; j < 8; j++) begin\n                if (i & (1 << j)) begin\n                    sbox[i] = sbox[i] ^ (1 << j);\n                end\n            end\n            // Apply affine transformation\n            for (int j = 0; j < 8; j++) begin\n                if (sbox[i] & (1 << j)) begin\n                    sbox[i] = sbox[i] ^ (1 << (j + 4)) ^ (1 << (j + 5)) ^ (1 << (j + 6)) ^ (1 << (j + 7)) ^ 0x63;\n                end\n            end\n        end\n    end\n\n    // Output the substituted byte\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 13, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n// Define the S-box table\nreg [7:0] sbox [255:0];\n\n// Initialize the S-box table\ninitial begin\n    for (int i = 0; i < 256; i++) begin\n        sbox[i] = i;\n        sbox[i] = sbox[i] ^ (sbox[i] << 1) ^ (sbox[i] << 2) ^ (sbox[i] << 3) ^ (sbox[i] << 4);\n        sbox[i] = sbox[i] ^ (sbox[i] << 8) ^ (sbox[i] << 4) ^ (sbox[i] << 5) ^ (sbox[i] << 6) ^ (sbox[i] << 7);\n        sbox[i] = sbox[i] ^ 0x63;\n    end\nend\n\n// Perform the S-box transformation\nassign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 14, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the S-box values\n    reg [7:0] sbox [255:0];\n\n    // Initialize the S-box values\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n            for (int j = 0; j < 8; j++) begin\n                sbox[i] = sbox[i] ^ (sbox[i] << j);\n            end\n            sbox[i] = sbox[i] ^ 0x11b;\n        end\n    end\n\n    // Perform the S-box substitution\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 17, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\ninitial begin\n    rcnt = 0;\n    rcon = 32'h01_00_00_00;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        rcon <= 32'h01_00_00_00;\n    end\n    else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon <= 32'h02_00_00_00;\n            2: rcon <= 32'h04_00_00_00;\n            3: rcon <= 32'h08_00_00_00;\n            4: rcon <= 32'h10_00_00_00;\n            5: rcon <= 32'h20_00_00_00;\n            6: rcon <= 32'h40_00_00_00;\n            7: rcon <= 32'h80_00_00_00;\n            8: rcon <= 32'h1b_00_00_00;\n            9: rcon <= 32'h36_00_00_00;\n            default: rcon <= 32'h00_00_00_00;\n        endcase\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 18, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [7:0] rcon;\n\ninitial\nbegin\n    rcnt = 4'b0000;\n    rcon = 8'h01;\nend\n\nalways @(posedge clk)\nbegin\n    if (kld)\n    begin\n        rcnt <= 4'b0000;\n        rcon <= 8'h01;\n        out <= 32'h01000000;\n    end\n    else\n    begin\n        rcnt <= rcnt + 4'b0001;\n        case (rcnt)\n            4'b0000: rcon <= 8'h01;\n            4'b0001: rcon <= 8'h02;\n            4'b0010: rcon <= 8'h04;\n            4'b0011: rcon <= 8'h08;\n            4'b0100: rcon <= 8'h10;\n            4'b0101: rcon <= 8'h20;\n            4'b0110: rcon <= 8'h40;\n            4'b0111: rcon <= 8'h80;\n            4'b1000: rcon <= 8'h1b;\n            4'b1001: rcon <= 8'h36;\n            default: rcon <= 8'h00;\n        endcase\n        out <= {24'b000000000000000000000000, rcon};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 16, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the inverse S-box values\n    reg [7:0] inv_sbox_values [255:0];\n\n    // Initialize the inverse S-box values\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox_values[i] = i;\n        end\n    end\n\n    // Define the inverse affine transformation matrix\n    reg [7:0] affine_matrix [8:0] = {\n        8'b00000000, 8'b00000000, 8'b00000001, 8'b00000000, 8'b00000000, 8'b00000001, 8'b00000000, 8'b00000001,\n        8'b00000000, 8'b00000010, 8'b00000000, 8'b00000000, 8'b00000010, 8'b00000000, 8'b00000000, 8'b00000010,\n        8'b00000001, 8'b00000000, 8'b00000010, 8'b00000000, 8'b00000000, 8'b00000010, 8'b00000000, 8'b00000001,\n        8'b00000000, 8'b00000100, 8'b00000000, 8'b00000000, 8'b00000100, 8'b00000000, 8'b00000000, 8'b00000100,\n        8'b00000010, 8'b00000000, 8'b00000100, 8'b00000000, 8'b00000000, 8'b00000100, 8'b00000000, 8'b00000010,\n        8'b00000001, 8'b00000010, 8'b00000100, 8'b00000000, 8'b00000000, 8'b00000100, 8'b00000000, 8'b00000001,\n        8'b00000000, 8'b00001000, 8'b00000000, 8'b00000000, 8'b00001000, 8'b00000000, 8'b00000000, 8'b00001000,\n        8'b00000010, 8'b00000000, 8'b00001000, 8'b00000000, 8'b00000000, 8'b00001000, 8'b00000000, 8'b00000010,\n        8'b00000001, 8'b00001000, 8'b00001000, 8'b00000000, 8'b00000000, 8'b00001000, 8'b00000000, 8'b00000001\n    };\n\n    // Define the inverse S-box constant\n    reg [7:0] inv_sbox_constant = 8'h05;\n\n    // Perform the inverse affine transformation\n    assign b = {affine_matrix[a[7:0]] ^ inv_sbox_constant};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 15, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n// Define the S-box values\nreg [7:0] sbox [255:0];\n\n// Initialize the S-box values\ninitial begin\n    for (int i = 0; i < 256; i++) begin\n        sbox[i] = i;\n        // Apply the affine transformation\n        for (int j = 0; j < 8; j++) begin\n            sbox[i] = sbox[i] ^ (sbox[i + 4] ^ sbox[i + 5] ^ sbox[i + 6] ^ sbox[i + 7] ^ (i >> j & 1) ? 1 : 0);\n        end\n    end\nend\n\n// Output the substituted byte\nassign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 11, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expand(\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    aes_sbox aes_sbox_0(\n        .a(a),\n        .b(b)\n    );\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 11;\n            ld_r <= 0;\n            text_in_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end\n        else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n            dcnt <= 11;\n        end\n        else if (dcnt > 0) begin\n            // SubBytes\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    a <= sa[i][j];\n                    b <= aes_sbox_0.b;\n                    sa[i][j] <= b;\n                end\n            end\n\n            // ShiftRows\n            for (int i = 1; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j + 1];\n                end\n            end\n\n            // MixColumns\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= (sa[i][j] ^ (sa[i + 1][j] << 1) ^ (sa[i + 2][j] << 2) ^ (sa[i + 3][j] << 3));\n                end\n            end\n\n            // AddRoundKey\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ wo_0[8*i + j];\n                end\n            end\n\n            dcnt <= dcnt - 1;\n        end\n        else begin\n            // Final Round\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ wo_0[8*i + j];\n                end\n            end\n\n            // Output Generation\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out[8*i + j] <= sa[i][j];\n                end\n            end\n\n            done <= 1;\n        end\n    end\n\n    // Output\n    assign text_out = text_out;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 10, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb[10:0];\nreg [3:0] kcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Submodules\naes_key_expand_128 aes_key_expand_128(\n   .clk(clk),\n   .kld(kld),\n   .key(key),\n   .wo_0(wk0),\n   .wo_1(wk1),\n   .wo_2(wk2),\n   .wo_3(wk3)\n);\n\naes_inv_sbox aes_inv_sbox[0:15];\n\n// State Transition Diagram\nalways @(posedge clk) begin\n    if (rst) begin\n        // Reset state\n        dcnt <= 0;\n        kcnt <= 0xA;\n        ld_r <= 0;\n        text_in_r <= 0;\n        text_out <= 0;\n        for (int i = 0; i < 16; i++) begin\n            aes_inv_sbox[i].a <= 0;\n            aes_inv_sbox[i].b <= 0;\n        end\n    end else if (kld) begin\n        // Key load state\n        kcnt <= 10;\n        ld_r <= 1;\n    end else if (ld) begin\n        // Data load state\n        ld_r <= 1;\n        text_in_r <= text_in;\n    end else if (dcnt < 11) begin\n        // Standard round state\n        ld_r <= 0;\n        if (dcnt == 0) begin\n            // Initial round key addition\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n            dcnt <= dcnt + 1;\n        end else begin\n            // Standard round transformations\n            InvShiftRows();\n            InvSubBytes();\n            AddRoundKey();\n            InvMixColumns();\n            dcnt <= dcnt + 1;\n        end\n    end else begin\n        // Final round state\n        InvShiftRows();\n        InvSubBytes();\n        AddRoundKey();\n        dcnt <= dcnt + 1;\n        if (dcnt == 11) begin\n            // Done state\n            done <= 1;\n            for (int i = 0; i < 16; i++) begin\n                aes_inv_sbox[i].a <= 0;\n                aes_inv_sbox[i].b <= 0;\n            end\n        end\n    end\nend\n\n// InvShiftRows Operation\ntask InvShiftRows();\n    for (int i = 1; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa[i][j] <= sa[i-1][j+3];\n        end\n    end\nendtask\n\n// InvSubBytes Operation\ntask InvSubBytes();\n    for (int i = 0; i < 16; i++) begin\n        aes_inv_sbox[i].a <= sa[i/4][i%4];\n        aes_inv_sbox[i].b <= aes_inv_sbox[i].a;\n    end\nendtask\n\n// AddRoundKey Operation\ntask AddRoundKey();\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa[i][j] <= sa[i][j] ^ kb[dcnt][8*i + j];\n        end\n    end\nendtask\n\n// InvMixColumns Operation\ntask InvMixColumns();\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa[i][j] <= sa[i][j] ^ pmul_e(sa[0][j]) ^ pmul_b(sa[1][j]) ^ pmul_d(sa[2][j]) ^ pmul_9(sa[3][j]);\n        end\n    end\nendtask\n\n// Output Generation\nalways @(posedge clk) begin\n    if (ld_r) begin\n        text_out <= text_in_r;\n    end else begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                text_out[8*i + j] <= sa[i][j];\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 16, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the S-box values\n    localparam [7:0] sbox_values[256] = {\n        // ... S-box values for each input byte ...\n    };\n\n    // Define the affine transformation constants\n    localparam [7:0] c = 8'b00000011;\n\n    // Compute the S-box value for the input byte\n    assign b = sbox_values[a];\n\n    // Apply the affine transformation\n    assign b = b ^ (b >> 4) ^ (b >> 5) ^ (b >> 6) ^ (b >> 7) ^ c;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 16, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [31:0] w0, w1, w2, w3;\nreg [127:0] key_reg;\nreg [3:0] round;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        key_reg[127:96] <= key[127:96];\n        key_reg[95:64] <= key[95:64];\n        key_reg[63:32] <= key[63:32];\n        key_reg[31:0] <= key[31:0];\n        w0 <= key_reg[31:0];\n        w1 <= key_reg[63:32];\n        w2 <= key_reg[95:64];\n        w3 <= key_reg[127:96];\n        wo_0 <= w0;\n        wo_1 <= w1;\n        wo_2 <= w2;\n        wo_3 <= w3;\n    end else begin\n        w0 <= w3 ^ aes_sbox(RotWord(w0)) ^ aes_rcon(round);\n        w1 <= w2 ^ aes_sbox(RotWord(w1)) ^ aes_rcon(round);\n        w2 <= w3 ^ aes_sbox(RotWord(w2)) ^ aes_rcon(round);\n        w3 <= w0 ^ aes_sbox(RotWord(w3)) ^ aes_rcon(round);\n        wo_0 <= w0;\n        wo_1 <= w1;\n        wo_2 <= w2;\n        wo_3 <= w3;\n        round <= round + 1;\n    end\nend\n\nfunction [7:0] RotWord([7:0] w);\n    return {w[1:7], w[0]};\nendfunction\n\nfunction [7:0] aes_sbox([7:0] a);\n    case (a)\n        8'h2: return 8'h5;\n        8'h6: return 8'h9;\n        8'h3: return 8'ha;\n        8'h5: return 8'he;\n        8'hb: return 8'hc;\n        8'ha: return 8'xf;\n        8'xe: return 8'x9;\n        8'x9: return 8'x2;\n        8'x0: return 8'x6;\n        8'x6: return 8'x4;\n        8'x4: return 8'xc;\n        8'xc: return 8'x3;\n        8'x3: return 8'xf;\n        8'xf: return 8'x8;\n        8'x8: return 8'x1;\n        8'x1: return 8'xd;\n        8'xd: return 8'x0;\n        default: return a;\n    endcase\nendfunction\n\nfunction [7:0] aes_rcon([3:0] round);\n    case (round)\n        4'h0: return 8'h01;\n        4'h1: return 8'h02;\n        4'h2: return 8'h04;\n        4'h3: return 8'h08;\n        4'h4: return 8'h10;\n        4'h5: return 8'h20;\n        4'h6: return 8'h40;\n        4'h7: return 8'h80;\n        4'h8: return 8'h1b;\n        4'h9: return 8'h36;\n        4'ha: return 8'h6c;\n        4'hb: return 8'hd8;\n        4'hc: return 8'xab;\n        4'hd: return 8'x4d;\n        4'he: return 8'x9a;\n        4'hf: return 8'x2f;\n        default: return 8'h00;\n    endcase\nendfunction\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 17, "code": "module aes_key_expand_128(\n    input  wire clk,\n    input  wire kld,\n    input  wire [127:0] key,\n    output wire [31:0] wo_0,\n    output wire [31:0] wo_1,\n    output wire [31:0] wo_2,\n    output wire [31:0] wo_3\n);\n\n    reg [31:0] w0, w1, w2, w3;\n\n    wire [31:0] rcon;\n\n    // S-box module\n    aes_sbox sbox0(.a(key[31:24]), .b(w0[7:0]));\n    aes_sbox sbox1(.a(key[23:16]), .b(w0[15:8]));\n    aes_sbox sbox2(.a(key[15:8]), .b(w0[23:16]));\n    aes_sbox sbox3(.a(key[7:0]), .b(w0[31:24]));\n\n    // Round constant generator\n    aes_rcon rcon_gen(.clk(clk), .kld(kld), .out(rcon));\n\n    // Key loading operation\n    always @(posedge clk)\n    if (kld)\n    begin\n        w0 <= {key[127:96], 32'd0};\n        w1 <= {key[95:64], 32'd0};\n        w2 <= {key[63:32], 32'd0};\n        w3 <= {key[31:0], 32'd0};\n        wo_0 <= w0;\n        wo_1 <= w1;\n        wo_2 <= w2;\n        wo_3 <= w3;\n    end\n\n    // Key expansion operation\n    always @(posedge clk)\n    if (!kld)\n    begin\n        // Perform byte reordering and S-box transformation\n        w0 <= {w0[7:0], w0[15:8], w0[23:16], w0[31:24]};\n        w0 <= sbox0.b | w0;\n\n        // XOR with current round constant\n        w0 <= w0 ^ rcon;\n\n        // New round key generation sequence\n        w1 <= w1 ^ w0 ^ w3;\n        w2 <= w2 ^ w0 ^ w1 ^ w3;\n        w3 <= w3 ^ w0 ^ w1 ^ w2;\n    end\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input  wire clk,\n    input  wire kld,\n    output wire [31:0] out\n);\n\n    reg [31:0] counter = 1;\n\n    always @(posedge clk)\n    if (kld)\n        counter <= 1;\n    else\n    begin\n        counter <= counter << 1;\n        if (counter[31])\n            counter <= counter ^ 0x01100000;\n    end\n\n    assign out = counter;\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input  wire [7:0] a,\n    output wire [7:0] b\n);\n\n    // S-box lookup table\n    reg [7:0] sbox_lookup [256:0];\n\n    initial\n    begin\n        // Initialize S-box lookup table\n        for (int i = 0; i < 256; i++)\n        begin\n            sbox_lookup[i] = i;\n        end\n    end\n\n    assign b = sbox_lookup[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 11, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb[10:0];\nreg [3:0] kcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Submodules\naes_key_expand_128 aes_key_expand_128(\n   .clk(clk),\n   .kld(kld),\n   .key(key),\n   .wo_0(wk0),\n   .wo_1(wk1),\n   .wo_2(wk2),\n   .wo_3(wk3)\n);\n\naes_inv_sbox aes_inv_sbox[0:15];\n\n// State Transition Diagram\nalways @(posedge clk) begin\n    if (rst) begin\n        dcnt <= 0;\n        kcnt <= 0xA;\n        ld_r <= 0;\n        text_in_r <= 0;\n        for (int i = 0; i < 16; i++) begin\n            aes_inv_sbox[i].a <= 0;\n            aes_inv_sbox[i].b <= 0;\n        end\n    end else if (ld_r) begin\n        // Key Load State\n        if (kcnt == 0) begin\n            // Key Stored State\n            kcnt <= 0xA;\n            ld_r <= 0;\n        end else if (kcnt > 0) begin\n            // Key Expansion State\n            kcnt <= kcnt - 1;\n        end else if (dcnt == 0) begin\n            // Initial Round State\n            dcnt <= dcnt + 1;\n        end else if (dcnt < 11) begin\n            // Standard Round State\n            dcnt <= dcnt + 1;\n        end else begin\n            // Final Round State\n            dcnt <= 11;\n        end\n    end else if (ld) begin\n        // Data Load State\n        ld_r <= 1;\n        text_in_r <= text_in;\n    end else if (dcnt == 11) begin\n        // Done State\n        done <= 1;\n    end else begin\n        // Idle State\n        done <= 0;\n    end\n\n    // Round Counter and Control Logic\n    if (dcnt == 0) begin\n        // Initial Round State\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= text_in_r[8*i + j:8*i + j];\n            end\n        end\n    end else if (dcnt < 11) begin\n        // Standard Round State\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa_next[i][j];\n            end\n        end\n    end else begin\n        // Final Round State\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa_next[i][j];\n            end\n        end\n    end\n\n    // InvShiftRows Operation\n    if (dcnt == 0) begin\n        // Initial Round State\n        for (int i = 1; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i-1][j];\n            end\n        end\n    end else if (dcnt < 11) begin\n        // Standard Round State\n        for (int i = 1; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i-1][j];\n            end\n        end\n    end\n\n    // InvSubBytes Operation\n    for (int i = 0; i < 16; i++) begin\n        aes_inv_sbox[i].a <= sa[i/4][i%4];\n        aes_inv_sbox[i].b <= aes_inv_sbox[i].b;\n    end\n\n    // AddRoundKey Operation\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa[i][j] <= sa[i][j] ^ wk3[8*i + j:8*i + j];\n        end\n    end\n\n    // InvMixColumns Operation\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa_next[i][j] <= pmul_e(sa[i][j]) ^ pmul_b(sa[i][j]) ^ pmul_d(sa[i][j]) ^ pmul_9(sa[i][j]);\n        end\n    end\n\n    // Output Mapping Process\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            text_out[8*(3-i) + j:8*(3-i) + j] <= sa[3-i][j];\n        end\n    end\nend\n\n// Output Timing Control\nalways @(posedge clk) begin\n    if (rst) begin\n        done <= 0;\n    end else if (ld_r) begin\n        done <= 0;\n    end else if (dcnt == 11) begin\n        done <= 1;\n    end else begin\n        done <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 17, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table\n    reg [7:0] sbox [255:0];\n\n    // Initialize S-box values\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n            for (int j = 0; j < 8; j++) begin\n                sbox[i] = sbox[i] ^ (sbox[i] << j);\n            end\n            sbox[i] = sbox[i] ^ (sbox[i] >> 1);\n            sbox[i] = sbox[i] ^ (sbox[i] >> 2);\n            sbox[i] = sbox[i] ^ (sbox[i] >> 4);\n            sbox[i] = sbox[i] ^ (sbox[i] >> 8);\n            sbox[i] = sbox[i] ^ (sbox[i] >> 16);\n            sbox[i] = sbox[i] ^ 0x11b;\n        end\n    end\n\n    // Affine transformation\n    assign b = sbox[a] ^ (sbox[a] << 4) ^ (sbox[a] << 5) ^ (sbox[a] << 6) ^ (sbox[a] << 7) ^ 0x63;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 12, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    // Registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox aes_inv_sbox[0:15] (\n        .a(sa[0][0]),\n        .b(us00)\n    );\n    aes_inv_sbox aes_inv_sbox[1:15] (\n        .a(sa[0][1]),\n        .b(us01)\n    );\n    aes_inv_sbox aes_inv_sbox[16:31] (\n        .a(sa[0][2]),\n        .b(us02)\n    );\n    aes_inv_sbox aes_inv_sbox[32:47] (\n        .a(sa[0][3]),\n        .b(us03)\n    );\n    aes_inv_sbox aes_inv_sbox[48:63] (\n        .a(sa[1][0]),\n        .b(us10)\n    );\n    aes_inv_sbox aes_inv_sbox[64:79] (\n        .a(sa[1][1]),\n        .b(us11)\n    );\n    aes_inv_sbox aes_inv_sbox[80:95] (\n        .a(sa[1][2]),\n        .b(us12)\n    );\n    aes_inv_sbox aes_inv_sbox[96:111] (\n        .a(sa[1][3]),\n        .b(us13)\n    );\n    aes_inv_sbox aes_inv_sbox[112:127] (\n        .a(sa[2][0]),\n        .b(us20)\n    );\n    aes_inv_sbox aes_inv_sbox[128:143] (\n        .a(sa[2][1]),\n        .b(us21)\n    );\n    aes_inv_sbox aes_inv_sbox[144:159] (\n        .a(sa[2][2]),\n        .b(us22)\n    );\n    aes_inv_sbox aes_inv_sbox[160:175] (\n        .a(sa[2][3]),\n        .b(us23)\n    );\n    aes_inv_sbox aes_inv_sbox[176:191] (\n        .a(sa[3][0]),\n        .b(us30)\n    );\n    aes_inv_sbox aes_inv_sbox[192:207] (\n        .a(sa[3][1]),\n        .b(us31)\n    );\n    aes_inv_sbox aes_inv_sbox[208:223] (\n        .a(sa[3][2]),\n        .b(us32)\n    );\n    aes_inv_sbox aes_inv_sbox[224:239] (\n        .a(sa[3][3]),\n        .b(us33)\n    );\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 4'b0;\n            kcnt <= 4'b10;\n            ld_r <= 1'b0;\n            text_in_r <= 128'b0;\n            text_out <= 128'b0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 8'b0;\n                end\n            end\n        end\n        else if (kld) begin\n            // Key Load State\n            kcnt <= kcnt + 1;\n            if (kcnt == 10) begin\n                // KeyExpansion State\n                aes_key_expand_128.key <= key;\n                kcnt <= 4'b0;\n            end\n        end\n        else if (ld) begin\n            // InitialRound State\n            ld_r <= 1'b1;\n            text_in_r <= text_in;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[7 + (i * 4) + j];\n                end\n            end\n            dcnt <= 4'b1;\n            ld_r <= 1'b0;\n        end\n        else if (dcnt == 10) begin\n            // FinalRound State\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ wk3[7 + (i * 4) + j];\n                end\n            end\n            dcnt <= 4'b0;\n            done <= 1'b1;\n        end\n        else begin\n            // StandardRound State\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ wk3[7 + (i * 4) + j];\n                end\n            end\n            dcnt <= dcnt + 1;\n        end\n    end\n\n    // InvShiftRows\n    always @(posedge clk) begin\n        if (ld_r) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[1][j] <= sa[1][j] ^ sa[3][j];\n                    sa[2][j] <= sa[2][j] ^ sa[3][j];\n                    sa[3][j] <= sa[3][j] ^ sa[2][j];\n                end\n            end\n        end\n    end\n\n    // InvSubBytes\n    always @(posedge clk) begin\n        if (ld_r) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= aes_inv_sbox[i * 4 + j].b;\n                end\n            end\n        end\n    end\n\n    // AddRoundKey\n    always @(posedge clk) begin\n        if (ld_r) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ wk3[7 + (i * 4) + j];\n                end\n            end\n        end\n    end\n\n    // InvMixColumns\n    always @(posedge clk) begin\n        if (ld_r) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_next[i][j] <= (sa[i][j] ^ (sa[i][j - 1] << 1) ^ (sa[i][j - 1] << 2) ^ (sa[i][j - 1] << 3) ^ (sa[i][j - 1] << 1)) ^ (sa[i][j - 1] << 2) ^ (sa[i][j - 1] << 3) ^ (sa[i][j - 1] << 1) ^ (sa[i][j - 1] << 2) ^ (sa[i][j - 1] << 3);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa_next[i][j];\n                end\n            end\n        end\n    end\n\n    // Output Generation\n    always @(posedge clk) begin\n        if (ld_r) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out[7 + (i * 4) + j] <= sa[i][j];\n                end\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 12, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg ld_r;\nreg [127:0] text_out;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        text_in_r <= 0;\n        sa <= 0;\n        dcnt <= 0;\n        ld_r <= 0;\n        text_out <= 0;\n    end else begin\n        if (ld) begin\n            text_in_r <= text_in;\n            sa <= text_in_r[7:0];\n            sa[1] <= text_in_r[15:8];\n            sa[2] <= text_in_r[23:16];\n            sa[3] <= text_in_r[31:24];\n            ld_r <= 1;\n        end else begin\n            if (ld_r) begin\n                ld_r <= 0;\n            end else begin\n                if (dcnt == 0) begin\n                    // Initial round key addition\n                    sa[0] <= sa[0] ^ key[7:0];\n                    sa[1] <= sa[1] ^ key[15:8];\n                    sa[2] <= sa[2] ^ key[23:16];\n                    sa[3] <= sa[3] ^ key[31:24];\n                    dcnt <= 11; // 10 rounds + initial round\n                end else if (dcnt > 0) begin\n                    // Standard round operations\n                    sa[0] <= SubBytes(sa[0]);\n                    sa[1] <= SubBytes(sa[1]);\n                    sa[2] <= SubBytes(sa[2]);\n                    sa[3] <= SubBytes(sa[3]);\n                    ShiftRows(sa);\n                    MixColumns(sa);\n                    AddRoundKey(sa, key);\n                    dcnt <= dcnt - 1;\n                end else begin\n                    // Final round operation\n                    sa[0] <= SubBytes(sa[0]);\n                    sa[1] <= SubBytes(sa[1]);\n                    sa[2] <= SubBytes(sa[2]);\n                    sa[3] <= SubBytes(sa[3]);\n                    ShiftRows(sa);\n                    AddRoundKey(sa, key);\n                    text_out <= sa[0] << 8 | sa[1] << 16 | sa[2] << 24 | sa[3];\n                    done <= 1;\n                end\n            end\n        end\n    end\nend\n\n// SubBytes transformation\nmodule SubBytes(\n    input [7:0] a,\n    output [7:0] b\n);\n    assign b = aes_sbox(a);\nendmodule\n\n// ShiftRows transformation\nmodule ShiftRows(\n    input [7:0] sa[0:3][0:3],\n    output [7:0] sa_out[0:3][0:3]\n);\n    assign sa_out[0] = sa[0];\n    assign sa_out[1] = sa[1] << 8 | sa[0] >> 2;\n    assign sa_out[2] = sa[2] << 16 | sa[1] >> 4 | sa[0] >> 6;\n    assign sa_out[3] = sa[3] << 24 | sa[2] >> 8 | sa[1] >> 10 | sa[0] >> 14;\nendmodule\n\n// MixColumns transformation\nmodule MixColumns(\n    input [7:0] sa[0:3][0:3],\n    output [7:0] sa_out[0:3][0:3]\n);\n    reg [7:0] out[0:3];\n    assign out[0] = (sa[0] << 1) ^ (sa[1] << 1) ^ (sa[2] << 1) ^ (sa[3] << 1);\n    assign out[1] = (sa[0] << 2) ^ (sa[1] << 2) ^ (sa[2] << 2) ^ (sa[3] << 2);\n    assign out[2] = (sa[0] << 3) ^ (sa[1] << 3) ^ (sa[2] << 3) ^ (sa[3] << 3);\n    assign out[3] = (sa[0] << 4) ^ (sa[1] << 4) ^ (sa[2] << 4) ^ (sa[3] << 4);\n    assign sa_out[0] = out[0];\n    assign sa_out[1] = out[1];\n    assign sa_out[2] = out[2];\n    assign sa_out[3] = out[3];\nendmodule\n\n// AddRoundKey transformation\nmodule AddRoundKey(\n    input [7:0] sa[0:3][0:3],\n    input [7:0] key,\n    output [7:0] sa_out[0:3][0:3]\n);\n    assign sa_out[0] = sa[0] ^ key;\n    assign sa_out[1] = sa[1] ^ key;\n    assign sa_out[2] = sa[2] ^ key;\n    assign sa_out[3] = sa[3] ^ key;\nendmodule\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 17, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the inverse S-box table\n    localparam [7:0] inv_sbox_table[256] = {\n        //... define the 256 entries of the inverse S-box table...\n        // For example:\n        8'h52, 8'h09, 8'h1f, 8'h21, 8'h10, 8'hee, 8'h80, 8'hc1,\n        8'hc6, 8'hc5, 8'hc9, 8'hc2, 8'hcf, 8'hc3, 8'hc4, 8'hc7\n    };\n\n    // Use a ROM to implement the inverse S-box\n    rom inv_sbox_rom(\n       .address(a),\n       .dataout(b)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 18, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n// S-box lookup table\nreg [7:0] sbox[256];\n\n// Initialize S-box table\ninitial begin\n    for (int i = 0; i < 256; i++) begin\n        sbox[i] = i;\n    end\nend\n\n// Affine transformation constants\nreg [7:0] c = 8'h63;\n\n// S-box transformation\nassign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 19, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [7:0] rcon;\n\ninitial begin\n    rcnt = 0;\n    out = 32'h01_00_00_00;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        out <= 32'h01_00_00_00;\n    end else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon = 2;\n            2: rcon = 2 * 2;\n            3: rcon = 2 * 2 * 2;\n            4: rcon = 2 * 2 * 2 * 2;\n            5: rcon = 2 * 2 * 2 * 2 * 2;\n            6: rcon = 2 * 2 * 2 * 2 * 2 * 2;\n            7: rcon = 2 * 2 * 2 * 2 * 2 * 2 * 2;\n            8: rcon = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2;\n            9: rcon = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2;\n            10: rcon = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2;\n            default: rcon = 0;\n        endcase\n        out <= {24'b0, rcon};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 18, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the inverse S-box table\n    reg [7:0] inv_sbox_table [255:0];\n\n    // Initialize the inverse S-box table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox_table[i] = i;\n        end\n    end\n\n    // Perform the inverse S-box transformation\n    assign b = inv_sbox_table[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 13, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\nreg [3:0] dcnt;\nreg [3:0] kcnt;\nreg [127:0] kb[10:0];\nreg ld_r;\nreg [127:0] text_in_r;\nreg [127:0] text_out_r;\n\n// Key Expansion Module\naes_key_expand_128 aes_key_expand_128_module(\n   .clk(clk),\n   .kld(kld),\n   .key(key),\n   .wo_0(wk0),\n   .wo_1(wk1),\n   .wo_2(wk2),\n   .wo_3(wk3)\n);\n\n// Inverse S-box Module\naes_inv_sbox aes_inv_sbox_module(\n   .clk(clk),\n   .a(_sr),\n   .b(_sub)\n);\n\n// State Matrix Registers\nreg [7:0] sa[0:3][0:3];\n\n// Round Counter and Control Logic\nalways @(posedge clk) begin\n    if (rst) begin\n        dcnt <= 0;\n        kcnt <= 0xA;\n        ld_r <= 0;\n    end else if (ld) begin\n        dcnt <= 1;\n        ld_r <= 1;\n    end else if (dcnt == 11) begin\n        done <= 1;\n    end else begin\n        dcnt <= dcnt + 1;\n        ld_r <= 0;\n    end\nend\n\n// Key Buffer Control Logic\nalways @(posedge clk) begin\n    if (rst) begin\n        kcnt <= 0xA;\n    end else if (kld) begin\n        kcnt <= kcnt - 1;\n    end else if (kcnt == 0) begin\n        kcnt <= 0xA;\n    end\nend\n\n// Key Buffer Storage Process\nalways @(posedge clk) begin\n    if (kcnt == 10) begin\n        kb[10] <= wk0;\n    end else if (kcnt == 9) begin\n        kb[9] <= wk1;\n    end else if (kcnt == 8) begin\n        kb[8] <= wk2;\n    end else if (kcnt == 7) begin\n        kb[7] <= wk3;\n    end else if (kcnt == 6) begin\n        kb[6] <= wk0;\n    end else if (kcnt == 5) begin\n        kb[5] <= wk1;\n    end else if (kcnt == 4) begin\n        kb[4] <= wk2;\n    end else if (kcnt == 3) begin\n        kb[3] <= wk3;\n    end else if (kcnt == 2) begin\n        kb[2] <= wk0;\n    end else if (kcnt == 1) begin\n        kb[1] <= wk1;\n    end else if (kcnt == 0) begin\n        kb[0] <= wk2;\n    end\nend\n\n// Round Transformation Implementation\nalways @(posedge clk) begin\n    if (rst) begin\n        sa[0][0] <= 0;\n        sa[0][1] <= 0;\n        sa[0][2] <= 0;\n        sa[0][3] <= 0;\n        sa[1][0] <= 0;\n        sa[1][1] <= 0;\n        sa[1][2] <= 0;\n        sa[1][3] <= 0;\n        sa[2][0] <= 0;\n        sa[2][1] <= 0;\n        sa[2][2] <= 0;\n        sa[2][3] <= 0;\n        sa[3][0] <= 0;\n        sa[3][1] <= 0;\n        sa[3][2] <= 0;\n        sa[3][3] <= 0;\n    end else if (ld_r) begin\n        // InvShiftRows\n        sa[1][0] <= sa[1][3];\n        sa[1][1] <= sa[1][2];\n        sa[1][2] <= sa[1][1];\n        sa[1][3] <= sa[1][0];\n        sa[2][0] <= sa[2][3];\n        sa[2][1] <= sa[2][2];\n        sa[2][2] <= sa[2][1];\n        sa[2][3] <= sa[2][0];\n        sa[3][0] <= sa[3][3];\n        sa[3][1] <= sa[3][2];\n        sa[3][2] <= sa[3][1];\n        sa[3][3] <= sa[3][0];\n        \n        // InvSubBytes\n        for (i = 0; i < 4; i++) begin\n            for (j = 0; j < 4; j++) begin\n                _sr <= sa[i][j];\n                _sub <= aes_inv_sbox_module.b;\n                sa[i][j] <= _sub;\n            end\n        end\n        \n        // AddRoundKey\n        for (i = 0; i < 4; i++) begin\n            for (j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i][j] ^ kb[dcnt][i*4+j];\n            end\n        end\n        \n        // InvMixColumns\n        for (i = 0; i < 4; i++) begin\n            _sr <= sa[i][0];\n            _sub <= pmul_e(_sr) ^ pmul_b(_sr) ^ pmul_d(_sr) ^ pmul_9(_sr);\n            sa[i][0] <= _sub;\n            _sr <= sa[i][1];\n            _sub <= pmul_e(_sr) ^ pmul_b(_sr) ^ pmul_d(_sr) ^ pmul_9(_sr);\n            sa[i][1] <= _sub;\n            _sr <= sa[i][2];\n            _sub <= pmul_e(_sr) ^ pmul_b(_sr) ^ pmul_d(_sr) ^ pmul_9(_sr);\n            sa[i][2] <= _sub;\n            _sr <= sa[i][3];\n            _sub <= pmul_e(_sr) ^ pmul_b(_sr) ^ pmul_d(_sr) ^ pmul_9(_sr);\n            sa[i][3] <= _sub;\n        end\n    end else begin\n        // InvMixColumns\n        for (i = 0; i < 4; i++) begin\n            _sr <= sa[i][0];\n            _sub <= pmul_e(_sr) ^ pmul_b(_sr) ^ pmul_d(_sr) ^ pmul_9(_sr);\n            sa[i][0] <= _sub;\n            _sr <= sa[i][1];\n            _sub <= pmul_e(_sr) ^ pmul_b(_sr) ^ pmul_d(_sr) ^ pmul_9(_sr);\n            sa[i][1] <= _sub;\n            _sr <= sa[i][2];\n            _sub <= pmul_e(_sr) ^ pmul_b(_sr) ^ pmul_d(_sr) ^ pmul_9(_sr);\n            sa[i][2] <= _sub;\n            _sr <= sa[i][3];\n            _sub <= pmul_e(_sr) ^ pmul_b(_sr) ^ pmul_d(_sr) ^ pmul_9(_sr);\n            sa[i][3] <= _sub;\n        end\n    end\nend\n\n// Final Output Generation\nalways @(posedge clk) begin\n    if (rst) begin\n        text_out <= 0;\n    end else if (ld_r) begin\n        // Output Mapping Process\n        for (i = 0; i < 4; i++) begin\n            for (j = 0; j < 4; j++) begin\n                text_out_r[i*4+j] <= sa[i][j];\n            end\n        end\n        // Output Timing Control\n        text_out <= text_out_r;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 13, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg ld_r;\nreg [127:0] text_out;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        text_in_r <= 0;\n        sa <= 0;\n        dcnt <= 0;\n        ld_r <= 0;\n        text_out <= 0;\n    end else begin\n        if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1;\n        end else begin\n            ld_r <= 0;\n        end\n        if (ld_r) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[(i*4+j)*8+:8];\n                end\n            end\n            ld_r <= 0;\n        end\n        if (dcnt == 0) begin\n            // Initial round key addition\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ key[(i*4+j)*8+:8];\n                end\n            end\n            dcnt <= 0xb;\n        end else if (dcnt > 0) begin\n            // SubBytes, ShiftRows, MixColumns, AddRoundKey\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= aes_sbox(sa[i][j]);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] << j;\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= (sa[i][j] * 0x02) ^ (sa[i][j] * 0x03);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ aes_key_expand_128(key, dcnt);\n                end\n            end\n            dcnt <= dcnt - 1;\n        end else begin\n            // Final round\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= aes_sbox(sa[i][j]);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] << j;\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ aes_key_expand_128(key, dcnt);\n                end\n            end\n            text_out <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out[(i*4+j)*8+:8] <= sa[i][j];\n                end\n            end\n            done <= 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 19, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n// Define the S-box table\nreg [7:0] sbox_table [255:0];\n\n// Initialize the S-box table\ninitial begin\n    for (int i = 0; i < 256; i++) begin\n        sbox_table[i] = i;\n    end\nend\n\n// Perform the S-box transformation\nalways @(*) begin\n    b = sbox_table[a];\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 18, "code": "module aes_key_expand_128(\n    input  clk,\n    input  kld,\n    input  [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    // Registers to store the input key\n    reg [31:0] key_reg_0;\n    reg [31:0] key_reg_1;\n    reg [31:0] key_reg_2;\n    reg [31:0] key_reg_3;\n\n    // Round constant generator\n    wire [31:0] rcon;\n\n    // S-box transformation\n    wire [7:0] sbox_out_0;\n    wire [7:0] sbox_out_1;\n    wire [7:0] sbox_out_2;\n    wire [7:0] sbox_out_3;\n\n    // S-box modules\n    aes_sbox sbox_0(.a(key_reg_0[7:0]), .b(sbox_out_0));\n    aes_sbox sbox_1(.a(key_reg_0[15:8]), .b(sbox_out_1));\n    aes_sbox sbox_2(.a(key_reg_0[23:16]), .b(sbox_out_2));\n    aes_sbox sbox_3(.a(key_reg_0[31:24]), .b(sbox_out_3));\n\n    // Round constant generator\n    aes_rcon rcon_gen(.clk(clk), .kld(kld), .out(rcon));\n\n    // Key loading operation\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            key_reg_0 <= key[127:96];\n            key_reg_1 <= key[95:64];\n            key_reg_2 <= key[63:32];\n            key_reg_3 <= key[31:0];\n        end\n    end\n\n    // Key expansion operation\n    always @(posedge clk)\n    begin\n        if (!kld)\n        begin\n            // Perform byte reordering and S-box transformation\n            wire [7:0] reordered_byte_0 = {key_reg_3[7:0], key_reg_3[15:8], key_reg_3[23:16], key_reg_3[31:24]};\n            wire [7:0] reordered_byte_1 = {key_reg_2[7:0], key_reg_2[15:8], key_reg_2[23:16], key_reg_2[31:24]};\n            wire [7:0] reordered_byte_2 = {key_reg_1[7:0], key_reg_1[15:8], key_reg_1[23:16], key_reg_1[31:24]};\n            wire [7:0] reordered_byte_3 = {key_reg_0[7:0], key_reg_0[15:8], key_reg_0[23:16], key_reg_0[31:24]};\n\n            sbox_0.a <= reordered_byte_0;\n            sbox_1.a <= reordered_byte_1;\n            sbox_2.a <= reordered_byte_2;\n            sbox_3.a <= reordered_byte_3;\n\n            // Perform S-box transformation\n            sbox_out_0 = sbox_0.b;\n            sbox_out_1 = sbox_1.b;\n            sbox_out_2 = sbox_2.b;\n            sbox_out_3 = sbox_3.b;\n\n            // XOR with round constant\n            wire [31:0] xor_result_0 = key_reg_3 ^ rcon;\n            wire [31:0] xor_result_1 = key_reg_2 ^ xor_result_0 ^ sbox_out_0;\n            wire [31:0] xor_result_2 = key_reg_1 ^ xor_result_1 ^ sbox_out_1;\n            wire [31:0] xor_result_3 = key_reg_0 ^ xor_result_2 ^ sbox_out_2 ^ sbox_out_3;\n\n            // Update round keys\n            key_reg_0 <= xor_result_0;\n            key_reg_1 <= xor_result_1;\n            key_reg_2 <= xor_result_2;\n            key_reg_3 <= xor_result_3;\n        end\n    end\n\n    // Output round keys\n    assign wo_0 = key_reg_0;\n    assign wo_1 = key_reg_1;\n    assign wo_2 = key_reg_2;\n    assign wo_3 = key_reg_3;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 20, "code": "module aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table\n    localparam [7:0] sbox[256] = {\n        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x5A, 0x9C, 0x82, 0xC9, 0x7D, 0x6F, 0x9F, 0x89, 0x4D, 0x33,\n        0x65, 0x46, 0x18, 0x35, 0xB9, 0x56, 0x4F, 0xE8, 0x5C, 0x0C, 0x81, 0x49, 0x97, 0x32, 0x5B, 0x36,\n        0x19, 0x1D, 0x9E, 0x59, 0x14, 0x04, 0x68, 0x5F, 0xB8, 0x3A, 0x9D, 0x6E, 0x6C, 0x0D, 0x2D, 0xD2,\n        0x52, 0x3B, 0x21, 0x10, 0x48, 0x46, 0xD3, 0xC8, 0xF8, 0x5E, 0x15, 0x4F, 0x16, 0x8F, 0x3C, 0x56,\n        0x1F, 0x21, 0x6A, 0x56, 0x26, 0xD3, 0xCB, 0xEB, 0x68, 0x1A, 0x01, 0x33, 0x3A, 0x92, 0x56, 0x0E,\n        0xB7, 0x62, 0x9A, 0x84, 0x90, 0x50, 0x6C, 0x37, 0x4F, 0x75, 0x8C, 0x9B, 0x8A, 0x0B, 0x1E, 0x8A,\n        0x1C, 0x82, 0x7B, 0x3D, 0x63, 0x1A, 0x9D, 0x1B, 0x4C, 0x8D, 0x0F, 0x6B, 0xCE, 0x4B, 0x0B, 0x83,\n        0x13, 0x55, 0x6B, 0x8A, 0x0C, 0x6F, 0x0F, 0x92, 0x9D, 0x38, 0x4A, 0x4C, 0x5E, 0x5C, 0x85, 0x1D,\n        0x6A, 0x86, 0x8D, 0x64, 0x4B, 0x55, 0x21, 0x0C, 0x7C, 0x1F, 0x4D, 0x0B, 0x1A, 0x19, 0x14, 0x23,\n        0x00, 0x4A, 0x4C, 0x55, 0x2A, 0x8B, 0x3C, 0x41, 0x4F, 0x50, 0x9F, 0x2F, 0x6D, 0x3E, 0x5A, 0x0C,\n        0x5F, 0x0B, 0x46, 0x62, 0x34, 0x79, 0x20, 0x4C, 0x5B, 0x0C, 0x7A, 0x7D, 0x3A, 0x9F, 0x74, 0x8C,\n        0x4B, 0x8A, 0x1F, 0x4D, 0x2C, 0x33, 0x8A, 0x1D, 0x4E, 0x42, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F\n    };\n\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 14, "code": "module aes_cipher_top(\n    input  wire clk,\n    input  wire rst,\n    input  wire ld,\n    output wire done,\n    input  wire [127:0] key,\n    input  wire [127:0] text_in,\n    output wire [127:0] text_out\n);\n\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg ld_r;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        text_in_r <= 0;\n        sa <= 0;\n        dcnt <= 0;\n        ld_r <= 0;\n    end else begin\n        if (ld) begin\n            text_in_r <= text_in;\n            sa <= key[127:128] & {4{1'b1}};\n            dcnt <= 0xB;\n            ld_r <= 1;\n        end else begin\n            if (dcnt > 0) begin\n                ld_r <= 0;\n                if (dcnt == 0) begin\n                    sa <= SubBytes(sa);\n                    sa <= ShiftRows(sa);\n                    if (dcnt == 9) begin\n                        sa <= MixColumns(sa);\n                    end\n                    sa <= AddRoundKey(sa);\n                    dcnt <= dcnt - 1;\n                end else begin\n                    sa <= SubBytes(sa);\n                    sa <= ShiftRows(sa);\n                    sa <= MixColumns(sa);\n                    sa <= AddRoundKey(sa);\n                    dcnt <= dcnt - 1;\n                end\n            end else begin\n                ld_r <= 0;\n                done <= 1;\n            end\n        end\n    end\nend\n\nassign text_out = sa[0][0] | {3{sa[0][1]}} | {2{sa[0][2]}} | sa[0][3] |\n                   sa[1][0] | {3{sa[1][1]}} | {2{sa[1][2]}} | sa[1][3] |\n                   sa[2][0] | {3{sa[2][1]}} | {2{sa[2][2]}} | sa[2][3] |\n                   sa[3][0] | {3{sa[3][1]}} | {2{sa[3][2]}} | sa[3][3];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 14, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    // Registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox aes_inv_sbox[0:15] (\n        .a(sa[0][0]),\n        .b(us00)\n    );\n    aes_inv_sbox aes_inv_sbox[1:15] (\n        .a(sa[0][1]),\n        .b(us01)\n    );\n    aes_inv_sbox aes_inv_sbox[16:31] (\n        .a(sa[0][2]),\n        .b(us02)\n    );\n    aes_inv_sbox aes_inv_sbox[32:47] (\n        .a(sa[0][3]),\n        .b(us03)\n    );\n    aes_inv_sbox aes_inv_sbox[48:63] (\n        .a(sa[1][0]),\n        .b(us10)\n    );\n    aes_inv_sbox aes_inv_sbox[64:79] (\n        .a(sa[1][1]),\n        .b(us11)\n    );\n    aes_inv_sbox aes_inv_sbox[80:95] (\n        .a(sa[1][2]),\n        .b(us12)\n    );\n    aes_inv_sbox aes_inv_sbox[96:111] (\n        .a(sa[1][3]),\n        .b(us13)\n    );\n    aes_inv_sbox aes_inv_sbox[112:127] (\n        .a(sa[2][0]),\n        .b(us20)\n    );\n    aes_inv_sbox aes_inv_sbox[128:143] (\n        .a(sa[2][1]),\n        .b(us21)\n    );\n    aes_inv_sbox aes_inv_sbox[144:159] (\n        .a(sa[2][2]),\n        .b(us22)\n    );\n    aes_inv_sbox aes_inv_sbox[160:175] (\n        .a(sa[2][3]),\n        .b(us23)\n    );\n    aes_inv_sbox aes_inv_sbox[176:191] (\n        .a(sa[3][0]),\n        .b(us30)\n    );\n    aes_inv_sbox aes_inv_sbox[192:207] (\n        .a(sa[3][1]),\n        .b(us31)\n    );\n    aes_inv_sbox aes_inv_sbox[208:223] (\n        .a(sa[3][2]),\n        .b(us32)\n    );\n    aes_inv_sbox aes_inv_sbox[224:239] (\n        .a(sa[3][3]),\n        .b(us33)\n    );\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end\n        else if (kld) begin\n            // Key Loading\n            kcnt <= kcnt + 1;\n            if (kcnt == 0xA) begin\n                // Key Expansion\n                aes_key_expand_128.key <= key;\n                kcnt <= 0;\n            end\n        end\n        else if (ld) begin\n            // Data Loading\n            text_in_r <= text_in;\n            ld_r <= 1;\n        end\n        else if (ld_r) begin\n            // Initial Round\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8 * (i * 4 + j) +: 8];\n                end\n            end\n            ld_r <= 0;\n            dcnt <= 1;\n        end\n        else if (dcnt < 11) begin\n            // Standard Round\n            // InvShiftRows\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    if (i == 0) begin\n                        sa[i][j] <= sa[i][j];\n                    end\n                    else if (i == 1) begin\n                        sa[i][j] <= sa[i][(j + 3) % 4];\n                    end\n                    else if (i == 2) begin\n                        sa[i][j] <= sa[i][(j + 2) % 4];\n                    end\n                    else if (i == 3) begin\n                        sa[i][j] <= sa[i][(j + 1) % 4];\n                    end\n                end\n            end\n            // InvSubBytes\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= aes_inv_sbox[i * 4 + j].b;\n                end\n            end\n            // AddRoundKey\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ wk3[8 * (i * 4 + j) +: 8];\n                end\n            end\n            // InvMixColumns\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    int k;\n                    for (k = 0; k < 4; k++) begin\n                        sa[i][j] <= sa[i][j] ^ pmul_e[sa[k][j]] ^ pmul_b[sa[k][j]] ^ pmul_d[sa[k][j]] ^ pmul_9[sa[k][j]];\n                    end\n                end\n            end\n            dcnt <= dcnt + 1;\n        end\n        else begin\n            // Final Round\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ wk3[8 * (i * 4 + j) +: 8];\n                end\n            end\n            done <= 1;\n        end\n    end\n\n    // Output Generation\n    always @(posedge clk) begin\n        if (ld_r) begin\n            text_out <= 0;\n        end\n        else if (dcnt == 11) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out[8 * (j * 4 + i) +: 8] <= sa[i][j];\n                end\n            end\n        end\n    end\n\n    // Completion Signal\n    always @(posedge clk) begin\n        if (rst) begin\n            done <= 0;\n        end\n        else if (ld_r) begin\n            done <= 0;\n        end\n        else if (dcnt == 11) begin\n            done <= 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 20, "code": "module aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        rcon <= 32'h01000000;\n    end else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            1: rcon <= 32'h02000000;\n            2: rcon <= 32'h04000000;\n            3: rcon <= 32'h08000000;\n            4: rcon <= 32'h10000000;\n            5: rcon <= 32'h20000000;\n            6: rcon <= 32'h40000000;\n            7: rcon <= 32'h80000000;\n            8: rcon <= 32'h1b000000;\n            9: rcon <= 32'h36000000;\n            default: rcon <= 32'h00000000;\n        endcase\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 15, "code": "module aes_inv_cipher_top(\n    input  wire clk,\n    input  wire rst,\n    input  wire kld,\n    input  wire ld,\n    output wire done,\n    input  wire [127:0] key,\n    input  wire [127:0] text_in,\n    output wire [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    // Key Expansion Module\n    aes_key_expand_128 aes_key_expand_128(\n       .clk(clk),\n       .kld(kld),\n       .key(key),\n       .wo_0(wk0),\n       .wo_1(wk1),\n       .wo_2(wk2),\n       .wo_3(wk3)\n    );\n\n    // Inverse S-box Module\n    aes_inv_sbox aes_inv_sbox[0:15];\n    for (genvar i = 0; i < 16; i++) begin\n        aes_inv_sbox[i].a(a[i]);\n        aes_inv_sbox[i].b(b[i]);\n    end\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n        end else if (kld) begin\n            // Key Load State\n            kcnt <= 0xA;\n            ld_r <= 0;\n        end else if (ld) begin\n            // Initial Round State\n            dcnt <= 1;\n            ld_r <= 1;\n        end else if (dcnt == 11) begin\n            // Final Round State\n            ld_r <= 0;\n        end else if (ld_r) begin\n            // Data Load State\n            text_in_r <= text_in;\n            ld_r <= 0;\n        end else if (dcnt < 11) begin\n            // Standard Round State\n            dcnt <= dcnt + 1;\n        end\n    end\n\n    // Round Counter and Control Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n        end else if (kld) begin\n            // Key Load State\n            kcnt <= 0xA;\n        end else if (ld) begin\n            // Initial Round State\n            dcnt <= 1;\n        end else if (dcnt == 11) begin\n            // Final Round State\n            done <= 1;\n        end else if (ld_r) begin\n            // Data Load State\n            ld_r <= 0;\n        end else if (dcnt < 11) begin\n            // Standard Round State\n            dcnt <= dcnt + 1;\n        end\n    end\n\n    // InvShiftRows Operation\n    always @(posedge clk) begin\n        if (rst) begin\n            sa[0][0] <= 0;\n            sa[0][1] <= 0;\n            sa[0][2] <= 0;\n            sa[0][3] <= 0;\n            sa[1][0] <= 0;\n            sa[1][1] <= 0;\n            sa[1][2] <= 0;\n            sa[1][3] <= 0;\n            sa[2][0] <= 0;\n            sa[2][1] <= 0;\n            sa[2][2] <= 0;\n            sa[2][3] <= 0;\n            sa[3][0] <= 0;\n            sa[3][1] <= 0;\n            sa[3][2] <= 0;\n            sa[3][3] <= 0;\n        end else if (ld_r) begin\n            // Data Load State\n            sa[0][0] <= text_in_r[127:120];\n            sa[0][1] <= text_in_r[119:112];\n            sa[0][2] <= text_in_r[111:104];\n            sa[0][3] <= text_in_r[103:96];\n            sa[1][0] <= text_in_r[95:88];\n            sa[1][1] <= text_in_r[87:80];\n            sa[1][2] <= text_in_r[79:72];\n            sa[1][3] <= text_in_r[71:64];\n            sa[2][0] <= text_in_r[63:56];\n            sa[2][1] <= text_in_r[55:48];\n            sa[2][2] <= text_in_r[47:40];\n            sa[2][3] <= text_in_r[39:32];\n            sa[3][0] <= text_in_r[31:24];\n            sa[3][1] <= text_in_r[23:16];\n            sa[3][2] <= text_in_r[15:8];\n            sa[3][3] <= text_in_r[7:0];\n            ld_r <= 0;\n        end else if (dcnt == 0) begin\n            // Initial Round State\n            sa[0][0] <= sa[0][0];\n            sa[0][1] <= sa[0][1];\n            sa[0][2] <= sa[0][2];\n            sa[0][3] <= sa[0][3];\n            sa[1][0] <= sa[1][0];\n            sa[1][1] <= sa[1][1];\n            sa[1][2] <= sa[1][2];\n            sa[1][3] <= sa[1][3];\n            sa[2][0] <= sa[2][0];\n            sa[2][1] <= sa[2][1];\n            sa[2][2] <= sa[2][2];\n            sa[2][3] <= sa[2][3];\n            sa[3][0] <= sa[3][0];\n            sa[3][1] <= sa[3][1];\n            sa[3][2] <= sa[3][2];\n            sa[3][3] <= sa[3][3];\n        end else if (dcnt > 0) begin\n            // Standard Round State\n            // InvShiftRows Operation\n            // Cyclic right shift\n            sa[1][0] <= sa[3][0];\n            sa[1][1] <= sa[3][1];\n            sa[1][2] <= sa[3][2];\n            sa[1][3] <= sa[3][3];\n            sa[2][0] <= sa[3][3];\n            sa[2][1] <= sa[3][0];\n            sa[2][2] <= sa[3][1];\n            sa[2][3] <= sa[3][2];\n            sa[3][0] <= sa[2][0];\n            sa[3][1] <= sa[2][1];\n            sa[3][2] <= sa[2][2];\n            sa[3][3] <= sa[2][3];\n        end\n    end\n\n    // InvSubBytes Operation\n    always @(posedge clk) begin\n        if (rst) begin\n            for (genvar i = 0; i < 16; i++) begin\n                aes_inv_sbox[i].a <= 0;\n                aes_inv_sbox[i].b <= 0;\n            end\n        end else if (ld_r) begin\n            // Data Load State\n            for (genvar i = 0; i < 16; i++) begin\n                aes_inv_sbox[i].a <= sa[i][0];\n                aes_inv_sbox[i].b <= aes_inv_sbox[i].b;\n            end\n            ld_r <= 0;\n        end else if (dcnt == 0) begin\n            // Initial Round State\n            for (genvar i = 0; i < 16; i++) begin\n                aes_inv_sbox[i].a <= sa[i][0];\n                aes_inv_sbox[i].b <= aes_inv_sbox[i].b;\n            end\n        end else if (dcnt > 0) begin\n            // Standard Round State\n            for (genvar i = 0; i < 16; i++) begin\n                aes_inv_sbox[i].a <= sa[i][0];\n                aes_inv_sbox[i].b <= aes_inv_sbox[i].b;\n            end\n        end\n    end\n\n    // AddRoundKey Operation\n    always @(posedge clk) begin\n        if (rst) begin\n            sa_ark <= 0;\n        end else if (ld_r) begin\n            // Data Load State\n            sa_ark <= text_in_r;\n            ld_r <= 0;\n        end else if (dcnt == 0) begin\n            // Initial Round State\n            sa_ark <= text_in_r;\n        end else if (dcnt > 0) begin\n            // Standard Round State\n            // XOR each state matrix byte with the corresponding round key byte\n            for (genvar i = 0; i < 4; i++) begin\n                for (genvar j = 0; j < 4; j++) begin\n                    sa_ark[i*4+j] <= sa[i][j] ^ wk3[i*4+j];\n                end\n            end\n        end\n    end\n\n    // InvMixColumns Operation\n    always @(posedge clk) begin\n        if (rst) begin\n            sa_next <= 0;\n        end else if (ld_r) begin\n            // Data Load State\n            sa_next <= text_in_r;\n            ld_r <= 0;\n        end else if (dcnt == 0) begin\n            // Initial Round State\n            sa_next <= text_in_r;\n        end else if (dcnt > 0) begin\n            // Standard Round State\n            // Processed independently for each column\n            // Uses pre-computed GF(2^8) multiplication functions (pmul_e/b/d/9)\n            for (genvar i = 0; i < 4; i++) begin\n                for (genvar j = 0; j < 4; j++) begin\n                    sa_next[i*4+j] <= (pmul_e[sa[i][j]] ^ pmul_b[sa[i][j]] ^ pmul_d[sa[i][j]] ^ pmul_9[sa[i][j]]) ^ wk3[i*4+j];\n                end\n            end\n        end\n    end\n\n    // Final Output Generation\n    always @(posedge clk) begin\n        if (rst) begin\n            text_out_r <= 0;\n        end else if (ld_r) begin\n            // Data Load State\n            text_out_r <= text_in_r;\n            ld_r <= 0;\n        end else if (dcnt == 11) begin\n            // Final Round State\n            // Output mapping process\n            // Maps the round key addition result (sa_ark) of the last round to text_out\n            // In column-major order, opposite to the input mapping\n            // From sa00 to sa30, then shift right\n            text_out_r <= sa_ark;\n        end\n    end\n\n    // Output Timing Control\n    always @(posedge clk) begin\n        if (rst) begin\n            done <= 0;\n        end else if (ld_r) begin\n            // Data Load State\n            done <= 0;\n        end else if (dcnt == 11) begin\n            // Final Round State\n            done <= 1;\n        end\n    end\n\n    // Output Data Organization\n    always @(posedge clk) begin\n        if (rst) begin\n            text_out <= 0;\n        end else if (ld_r) begin\n            // Data Load State\n            text_out <= text_in_r;\n            ld_r <= 0;\n        end else if (dcnt == 11) begin\n            // Final Round State\n            // The highest byte (text_out[127:120]) comes from sa00\n            // The lowest byte (text_out[7:0]) comes from sa33\n            // Bytes are arranged in column-major order\n            text_out <= text_out_r;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 15, "code": "module aes_cipher_top(\n    input  wire clk,\n    input  wire rst,\n    input  wire ld,\n    output wire done,\n    input  wire [127:0] key,\n    input  wire [127:0] text_in,\n    output wire [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n            text_out <= 0;\n        end\n        else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1;\n            dcnt <= 0;\n        end\n        else if (ld_r) begin\n            ld_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n            dcnt <= 0;\n        end\n        else if (dcnt < 10) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= aes_subbytes(sa[i][j]);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                sa[i][0] <= aes_shiftrows(sa[i][0]);\n                sa[i][1] <= aes_shiftrows(sa[i][1]);\n                sa[i][2] <= aes_shiftrows(sa[i][2]);\n                sa[i][3] <= aes_shiftrows(sa[i][3]);\n            end\n            if (dcnt < 9) begin\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][0] <= aes_mixcolumns(sa[i][0]);\n                    sa[i][1] <= aes_mixcolumns(sa[i][1]);\n                    sa[i][2] <= aes_mixcolumns(sa[i][2]);\n                    sa[i][3] <= aes_mixcolumns(sa[i][3]);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ aes_addroundkey(sa[i][j], dcnt);\n                end\n            end\n            dcnt <= dcnt + 1;\n        end\n        else begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= aes_shiftrows(sa[i][j]);\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ aes_addroundkey(sa[i][j], dcnt);\n                end\n            end\n            text_out <= 0;\n            done <= 1;\n        end\n    end\n\n    assign text_out = {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                      sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                      sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                      sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n\nendmodule\n\nmodule aes_subbytes(\n    input  wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] sbox[256];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = aes_sbox(i);\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_shiftrows(\n    input  wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] temp;\n\n    always @(*) begin\n        case (a[3:0])\n            0: temp = a;\n            1: temp = {a[1], a[2], a[3], a[0]};\n            2: temp = {a[2], a[3], a[0], a[1]};\n            3: temp = {a[3], a[0], a[1], a[2]};\n            default: temp = a;\n        endcase\n        b = temp;\n    end\n\nendmodule\n\nmodule aes_mixcolumns(\n    input  wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] temp;\n\n    always @(*) begin\n        case (a[3:0])\n            0: begin\n                temp[0] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[1] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[2] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[3] = a[0] ^ a[1] ^ a[2] ^ a[3];\n            end\n            1: begin\n                temp[0] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[1] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[2] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[3] = a[0] ^ a[1] ^ a[2] ^ a[3];\n            end\n            2: begin\n                temp[0] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[1] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[2] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[3] = a[0] ^ a[1] ^ a[2] ^ a[3];\n            end\n            3: begin\n                temp[0] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[1] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[2] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[3] = a[0] ^ a[1] ^ a[2] ^ a[3];\n            end\n            default: begin\n                temp[0] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[1] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[2] = a[0] ^ a[1] ^ a[2] ^ a[3];\n                temp[3] = a[0] ^ a[1] ^ a[2] ^ a[3];\n            end\n        endcase\n        b = temp;\n    end\n\nendmodule\n\nmodule aes_addroundkey(\n    input  wire [7:0] a,\n    input  wire [7:0] k,\n    output wire [7:0] b\n);\n\n    assign b = a ^ k;\n\nendmodule\n\nmodule aes_sbox(\n    input  wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] sbox[256];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n        end\n        for (int i = 0; i < 256; i++) begin\n            for (int j = 0; j < 8; j++) begin\n                if (sbox[i] & (1 << j)) begin\n                    sbox[i] = sbox[i] ^ (1 << (j + 1));\n                end\n            end\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_key_expand_128(\n    input  wire clk,\n    input  wire kld,\n    input  wire [127:0] key,\n    output wire [31:0] wo_0,\n    output wire [31:0] wo_1,\n    output wire [31:0] wo_2,\n    output wire [31:0] wo_3\n);\n\n    reg [127:0] key_expanded;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            key_expanded = key;\n        end\n        else begin\n            wo_0 <= key_expanded[31:0];\n            wo_1 <= key_expanded[63:32];\n            wo_2 <= key_expanded[95:64];\n            wo_3 <= key_expanded[127:96];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 16, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // aes_key_expand_128 module\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(round_key_0),\n        .wo_1(round_key_1),\n        .wo_2(round_key_2),\n        .wo_3(round_key_3)\n    );\n\n    // aes_sbox module\n    aes_sbox aes_sbox_0(\n        .a(sa[0][0]),\n        .b(sb[0])\n    );\n    aes_sbox aes_sbox_1(\n        .a(sa[0][1]),\n        .b(sb[1])\n    );\n    aes_sbox aes_sbox_2(\n        .a(sa[0][2]),\n        .b(sb[2])\n    );\n    aes_sbox aes_sbox_3(\n        .a(sa[0][3]),\n        .b(sb[3])\n    );\n    aes_sbox aes_sbox_4(\n        .a(sa[1][0]),\n        .b(sb[4])\n    );\n    aes_sbox aes_sbox_5(\n        .a(sa[1][1]),\n        .b(sb[5])\n    );\n    aes_sbox aes_sbox_6(\n        .a(sa[1][2]),\n        .b(sb[6])\n    );\n    aes_sbox aes_sbox_7(\n        .a(sa[1][3]),\n        .b(sb[7])\n    );\n    aes_sbox aes_sbox_8(\n        .a(sa[2][0]),\n        .b(sb[8])\n    );\n    aes_sbox aes_sbox_9(\n        .a(sa[2][1]),\n        .b(sb[9])\n    );\n    aes_sbox aes_sbox_10(\n        .a(sa[2][2]),\n        .b(sb[10])\n    );\n    aes_sbox aes_sbox_11(\n        .a(sa[2][3]),\n        .b(sb[11])\n    );\n    aes_sbox aes_sbox_12(\n        .a(sa[3][0]),\n        .b(sb[12])\n    );\n    aes_sbox aes_sbox_13(\n        .a(sa[3][1]),\n        .b(sb[13])\n    );\n    aes_sbox aes_sbox_14(\n        .a(sa[3][2]),\n        .b(sb[14])\n    );\n    aes_sbox aes_sbox_15(\n        .a(sa[3][3]),\n        .b(sb[15])\n    );\n\n    // SubBytes transformation\n    assign sb[0] = aes_sbox_0.b;\n    assign sb[1] = aes_sbox_1.b;\n    assign sb[2] = aes_sbox_2.b;\n    assign sb[3] = aes_sbox_3.b;\n    assign sb[4] = aes_sbox_4.b;\n    assign sb[5] = aes_sbox_5.b;\n    assign sb[6] = aes_sbox_6.b;\n    assign sb[7] = aes_sbox_7.b;\n    assign sb[8] = aes_sbox_8.b;\n    assign sb[9] = aes_sbox_9.b;\n    assign sb[10] = aes_sbox_10.b;\n    assign sb[11] = aes_sbox_11.b;\n    assign sb[12] = aes_sbox_12.b;\n    assign sb[13] = aes_sbox_13.b;\n    assign sb[14] = aes_sbox_14.b;\n    assign sb[15] = aes_sbox_15.b;\n\n    // ShiftRows transformation\n    assign sa[0][0] = sa[0][0];\n    assign sa[0][1] = sa[0][1];\n    assign sa[0][2] = sa[0][2];\n    assign sa[0][3] = sa[0][3];\n    assign sa[1][0] = sa[1][1];\n    assign sa[1][1] = sa[1][2];\n    assign sa[1][2] = sa[1][3];\n    assign sa[1][3] = sa[1][0];\n    assign sa[2][0] = sa[2][2];\n    assign sa[2][1] = sa[2][3];\n    assign sa[2][2] = sa[2][0];\n    assign sa[2][3] = sa[2][1];\n    assign sa[3][0] = sa[3][3];\n    assign sa[3][1] = sa[3][0];\n    assign sa[3][2] = sa[3][1];\n    assign sa[3][3] = sa[3][2];\n\n    // MixColumns transformation\n    assign sa[0][0] = (sa[0][0] * 2 + sa[0][1] * 3 + sa[0][2] + sa[0][3]) ^ (sa[1][0] * 2 + sa[1][1] * 3 + sa[1][2] + sa[1][3]);\n    assign sa[0][1] = (sa[0][0] + sa[0][1] * 2 + sa[0][2] * 3 + sa[0][3]) ^ (sa[1][0] + sa[1][1] * 2 + sa[1][2] * 3 + sa[1][3]);\n    assign sa[0][2] = (sa[0][0] + sa[0][1] + sa[0][2] * 2 + sa[0][3] * 3) ^ (sa[1][0] + sa[1][1] + sa[1][2] * 2 + sa[1][3] * 3);\n    assign sa[0][3] = (sa[0][0] * 3 + sa[0][1] + sa[0][2] + sa[0][3] * 2) ^ (sa[1][0] * 3 + sa[1][1] + sa[1][2] + sa[1][3] * 2);\n    assign sa[1][0] = (sa[1][0] * 2 + sa[1][1] * 3 + sa[1][2] + sa[1][3]) ^ (sa[2][0] * 2 + sa[2][1] * 3 + sa[2][2] + sa[2][3]);\n    assign sa[1][1] = (sa[1][0] + sa[1][1] * 2 + sa[1][2] * 3 + sa[1][3]) ^ (sa[2][0] + sa[2][1] * 2 + sa[2][2] * 3 + sa[2][3]);\n    assign sa[1][2] = (sa[1][0] + sa[1][1] + sa[1][2] * 2 + sa[1][3] * 3) ^ (sa[2][0] + sa[2][1] + sa[2][2] * 2 + sa[2][3] * 3);\n    assign sa[1][3] = (sa[1][0] * 3 + sa[1][1] + sa[1][2] + sa[1][3] * 2) ^ (sa[2][0] * 3 + sa[2][1] + sa[2][2] + sa[2][3] * 2);\n    assign sa[2][0] = (sa[2][0] * 2 + sa[2][1] * 3 + sa[2][2] + sa[2][3]) ^ (sa[3][0] * 2 + sa[3][1] * 3 + sa[3][2] + sa[3][3]);\n    assign sa[2][1] = (sa[2][0] + sa[2][1] * 2 + sa[2][2] * 3 + sa[2][3]) ^ (sa[3][0] + sa[3][1] * 2 + sa[3][2] * 3 + sa[3][3]);\n    assign sa[2][2] = (sa[2][0] + sa[2][1] + sa[2][2] * 2 + sa[2][3] * 3) ^ (sa[3][0] + sa[3][1] + sa[3][2] * 2 + sa[3][3] * 3);\n    assign sa[2][3] = (sa[2][0] * 3 + sa[2][1] + sa[2][2] + sa[2][3] * 2) ^ (sa[3][0] * 3 + sa[3][1] + sa[3][2] + sa[3][3] * 2);\n    assign sa[3][0] = (sa[3][0] * 2 + sa[3][1] * 3 + sa[3][2] + sa[3][3]) ^ (sa[0][0] * 2 + sa[0][1] * 3 + sa[0][2] + sa[0][3]);\n    assign sa[3][1] = (sa[3][0] + sa[3][1] * 2 + sa[3][2] * 3 + sa[3][3]) ^ (sa[0][0] + sa[0][1] * 2 + sa[0][2] * 3 + sa[0][3]);\n    assign sa[3][2] = (sa[3][0] + sa[3][1] + sa[3][2] * 2 + sa[3][3] * 3) ^ (sa[0][0] + sa[0][1] + sa[0][2] * 2 + sa[0][3] * 3);\n    assign sa[3][3] = (sa[3][0] * 3 + sa[3][1] + sa[3][2] + sa[3][3] * 2) ^ (sa[0][0] * 3 + sa[0][1] + sa[0][2] + sa[0][3] * 2);\n\n    // AddRoundKey transformation\n    assign sa[0][0] = sa[0][0] ^ round_key_0[0];\n    assign sa[0][1] = sa[0][1] ^ round_key_0[1];\n    assign sa[0][2] = sa[0][2] ^ round_key_0[2];\n    assign sa[0][3] = sa[0][3] ^ round_key_0[3];\n    assign sa[1][0] = sa[1][0] ^ round_key_0[4];\n    assign sa[1][1] = sa[1][1] ^ round_key_0[5];\n    assign sa[1][2] = sa[1][2] ^ round_key_0[6];\n    assign sa[1][3] = sa[1][3] ^ round_key_0[7];\n    assign sa[2][0] = sa[2][0] ^ round_key_0[8];\n    assign sa[2][1] = sa[2][1] ^ round_key_0[9];\n    assign sa[2][2] = sa[2][2] ^ round_key_0[10];\n    assign sa[2][3] = sa[2][3] ^ round_key_0[11];\n    assign sa[3][0] = sa[3][0] ^ round_key_0[12];\n    assign sa[3][1] = sa[3][1] ^ round_key_0[13];\n    assign sa[3][2] = sa[3][2] ^ round_key_0[14];\n    assign sa[3][3] = sa[3][3] ^ round_key_0[15];\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 11;\n            ld_r <= 0;\n        end\n        else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n        end\n        else if (ld_r) begin\n            ld_r <= 0;\n            dcnt <= dcnt - 1;\n        end\n        else if (dcnt == 0) begin\n            done <= 1;\n            text_out <= text_in_r;\n        end\n        else if (dcnt > 0) begin\n            // SubBytes transformation\n            sa[0][0] <= sb[0];\n            sa[0][1] <= sb[1];\n            sa[0][2] <= sb[2];\n            sa[0][3] <= sb[3];\n            sa[1][0] <= sb[4];\n            sa[1][1] <= sb[5];\n            sa[1][2] <= sb[6];\n            sa[1][3] <= sb[7];\n            sa[2][0] <= sb[8];\n            sa[2][1] <= sb[9];\n            sa[2][2] <= sb[10];\n            sa[2][3] <= sb[11];\n            sa[3][0] <= sb[12];\n            sa[3][1] <= sb[13];\n            sa[3][2] <= sb[14];\n            sa[3][3] <= sb[15];\n\n            // ShiftRows transformation\n            assign sa[0][0] = sa[0][0];\n            assign sa[0][1] = sa[0][1];\n            assign sa[0][2] = sa[0][2];\n            assign sa[0][3] = sa[0][3];\n            assign sa[1][0] = sa[1][1];\n            assign sa[1][1] = sa[1][2];\n            assign sa[1][2] = sa[1][3];\n            assign sa[1][3] = sa[1][0];\n            assign sa[2][0] = sa[2][2];\n            assign sa[2][1] = sa[2][3];\n            assign sa[2][2] = sa[2][0];\n            assign sa[2][3] = sa[2][1];\n            assign sa[3][0] = sa[3][3];\n            assign sa[3][1] = sa[3][0];\n            assign sa[3][2] = sa[3][1];\n            assign sa[3][3] = sa[3][2];\n\n            // MixColumns transformation\n            assign sa[0][0] = (sa[0][0] * 2 + sa[0][1] * 3 + sa[0][2] + sa[0][3]) ^ (sa[1][0] * 2 + sa[1][1] * 3 + sa[1][2] + sa[1][3]);\n            assign sa[0][1] = (sa[0][0] + sa[0][1] * 2 + sa[0][2] * 3 + sa[0][3]) ^ (sa[1][0] + sa[1][1] * 2 + sa[1][2] * 3 + sa[1][3]);\n            assign sa[0][2] = (sa[0][0] + sa[0][1] + sa[0][2] * 2 + sa[0][3] * 3) ^ (sa[1][0] + sa[1][1] + sa[1][2] * 2 + sa[1][3] * 3);\n            assign sa[0][3] = (sa[0][0] * 3 + sa[0][1] + sa[0][2] + sa[0][3] * 2) ^ (sa[1][0] * 3 + sa[1][1] + sa[1][2] + sa[1][3] * 2);\n            assign sa[1][0] = (sa[1][0] * 2 + sa[1][1] * 3 + sa[1][2] + sa[1][3]) ^ (sa[2][0] * 2 + sa[2][1] * 3 + sa[2][2] + sa[2][3]);\n            assign sa[1][1] = (sa[1][0] + sa[1][1] * 2 + sa[1][2] * 3 + sa[1][3]) ^ (sa[2][0] + sa[2][1] * 2 + sa[2][2] * 3 + sa[2][3]);\n            assign sa[1][2] = (sa[1][0] + sa[1][1] + sa[1][2] * 2 + sa[1][3] * 3) ^ (sa[2][0] + sa[2][1] + sa[2][2] * 2 + sa[2][3] * 3);\n            assign sa[1][3] = (sa[1][0] * 3 + sa[1][1] + sa[1][2] + sa[1][3] * 2) ^ (sa[2][0] * 3 + sa[2][1] + sa[2][2] + sa[2][3] * 2);\n            assign sa[2][0] = (sa[2][0] * 2 + sa[2][1] * 3 + sa[2][2] + sa[2][3]) ^ (sa[3][0] * 2 + sa[3][1] * 3 + sa[3][2] + sa[3][3]);\n            assign sa[2][1] = (sa[2][0] + sa[2][1] * 2 + sa[2][2] * 3 + sa[2][3]) ^ (sa[3][0] + sa[3][1] * 2 + sa[3][2] * 3 + sa[3][3]);\n            assign sa[2][2] = (sa[2][0] + sa[2][1] + sa[2][2] * 2 + sa[2][3] * 3) ^ (sa[3][0] + sa[3][1] + sa[3][2] * 2 + sa[3][3] * 3);\n            assign sa[2][3] = (sa[2][0] * 3 + sa[2][1] + sa[2][2] + sa[2][3] * 2) ^ (sa[3][0] * 3 + sa[3][1] + sa[3][2] + sa[3][3] * 2);\n            assign sa[3][0] = (sa[3][0] * 2 + sa[3][1] * 3 + sa[3][2] + sa[3][3]) ^ (sa[0][0] * 2 + sa[0][1] * 3 + sa[0][2] + sa[0][3]);\n            assign sa[3][1] = (sa[3][0] + sa[3][1] * 2 + sa[3][2] * 3 + sa[3][3]) ^ (sa[0][0] + sa[0][1] * 2 + sa[0][2] * 3 + sa[0][3]);\n            assign sa[3][2] = (sa[3][0] + sa[3][1] + sa[3][2] * 2 + sa[3][3] * 3) ^ (sa[0][0] + sa[0][1] + sa[0][2] * 2 + sa[0][3] * 3);\n            assign sa[3][3] = (sa[3][0] * 3 + sa[3][1] + sa[3][2] + sa[3][3] * 2) ^ (sa[0][0] * 3 + sa[0][1] + sa[0][2] + sa[0][3] * 2);\n\n            // AddRoundKey transformation\n            assign sa[0][0] = sa[0][0] ^ round_key_0[0];\n            assign sa[0][1] = sa[0][1] ^ round_key_0[1];\n            assign sa[0][2] = sa[0][2] ^ round_key_0[2];\n            assign sa[0][3] = sa[0][3] ^ round_key_0[3];\n            assign sa[1][0] = sa[1][0] ^ round_key_0[4];\n            assign sa[1][1] = sa[1][1] ^ round_key_0[5];\n            assign sa[1][2] = sa[1][2] ^ round_key_0[6];\n            assign sa[1][3] = sa[1][3] ^ round_key_0[7];\n            assign sa[2][0] = sa[2][0] ^ round_key_0[8];\n            assign sa[2][1] = sa[2][1] ^ round_key_0[9];\n            assign sa[2][2] = sa[2][2] ^ round_key_0[10];\n            assign sa[2][3] = sa[2][3] ^ round_key_0[11];\n            assign sa[3][0] = sa[3][0] ^ round_key_0[12];\n            assign sa[3][1] = sa[3][1] ^ round_key_0[13];\n            assign sa[3][2] = sa[3][2] ^ round_key_0[14];\n            assign sa[3][3] = sa[3][3] ^ round_key_0[15];\n\n            // Final round operations\n            assign sa[0][0] = sa[0][0];\n            assign sa[0][1] = sa[0][1];\n            assign sa[0][2] = sa[0][2];\n            assign sa[0][3] = sa[0][3];\n            assign sa[1][0] = sa[1][1];\n            assign sa[1][1] = sa[1][2];\n            assign sa[1][2] = sa[1][3];\n            assign sa[1][3] = sa[1][0];\n            assign sa[2][0] = sa[2][2];\n            assign sa[2][1] = sa[2][3];\n            assign sa[2][2] = sa[2][0];\n            assign sa[2][3] = sa[2][1];\n            assign sa[3][0] = sa[3][3];\n            assign sa[3][1] = sa[3][0];\n            assign sa[3][2] = sa[3][1];\n            assign sa[3][3] = sa[3][2];\n\n            // Output generation\n            assign text_out = {sa[0][0], sa[1][0], sa[2][0], sa[3][0], sa[0][1], sa[1][1], sa[2][1], sa[3][1], sa[0][2], sa[1][2], sa[2][2], sa[3][2], sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n        end\n    end\n\n    // Output assignment\n    assign done = done;\n    assign text_out = text_out;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 17, "code": "module aes_cipher_top(\n    input  clk,\n    input  rst,\n    input  ld,\n    output done,\n    input  [127:0] key,\n    input  [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n            text_out <= 0;\n        end else if (ld) begin\n            text_in_r <= text_in;\n            sa <= text_in_r[127:128];\n            dcnt <= 0;\n            ld_r <= 1;\n        end else if (ld_r) begin\n            if (dcnt < 10) begin\n                ld_r <= 0;\n                sa <= aes_sbox(sa);\n                sa <= aes_shiftrows(sa);\n                sa <= aes_mixcolumns(sa);\n                sa <= aes_addroundkey(sa, aes_key_expand_128(key, dcnt));\n                dcnt <= dcnt + 1;\n            end else begin\n                ld_r <= 0;\n                sa <= aes_sbox(sa);\n                sa <= aes_shiftrows(sa);\n                sa <= aes_addroundkey(sa, aes_key_expand_128(key, dcnt));\n                text_out <= sa;\n                done <= 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // S-box implementation\n    always_comb begin\n        case (a)\n            8'h01: b = 8'h63;\n            8'h02: b = 8'h7c;\n            8'h03: b = 8'h77;\n            8'h04: b = 8'h7b;\n            8'h05: b = 8'hf2;\n            8'h06: b = 8'hc6;\n            8'h07: b = 8'he3;\n            8'h08: b = 8'xf7;\n            8'h09: b = 8'x7f;\n            8'h0a: b = 8'xc9;\n            8'h0b: b = 8'x9f;\n            8'h0c: b = 8'x89;\n            8'h0d: b = 8'x0d;\n            8'h0e: b = 8'x0a;\n            8'h0f: b = 8'x49;\n            8'h10: b = 8'x24;\n            8'h11: b = 8'x5a;\n            8'h12: b = 8'x65;\n            8'h13: b = 8'x19;\n            8'h14: b = 8'x1a;\n            8'h15: b = 8'x91;\n            8'h16: b = 8'x11;\n            8'h17: b = 8'x06;\n            8'h18: b = 8'xd3;\n            8'h19: b = 8'x8f;\n            8'h1a: b = 8'x4e;\n            8'h1b: b = 8'x36;\n            8'h1c: b = 8'x41;\n            8'h1d: b = 8'x75;\n            8'h1e: b = 8'x34;\n            8'h1f: b = 8'x9c;\n            8'h20: b = 8'x87;\n            8'h21: b = 8'x14;\n            8'h22: b = 8'x5e;\n            8'h23: b = 8'x35;\n            8'h24: b = 8'x6d;\n            8'h25: b = 8'xcb;\n            8'h26: b = 8'x94;\n            8'h27: b = 8'x4d;\n            8'h28: b = 8'x9d;\n            8'h29: b = 8'x1f;\n            8'h2a: b = 8'x79;\n            8'h2b: b = 8'x5f;\n            8'h2c: b = 8'x59;\n            8'h2d: b = 8'x47;\n            8'h2e: b = 8'x92;\n            8'h2f: b = 8'x6b;\n            8'h30: b = 8'xdc;\n            8'h31: b = 8'x22;\n            8'h32: b = 8'x7d;\n            8'h33: b = 8'x2a;\n            8'h34: b = 8'x1b;\n            8'h35: b = 8'x60;\n            8'h36: b = 8'x91;\n            8'h37: b = 8'x85;\n            8'h38: b = 8'xb5;\n            8'h39: b = 8'x0b;\n            8'h3a: b = 8'x0c;\n            8'h3b: b = 8'x38;\n            8'h3c: b = 8'x4b;\n            8'h3d: b = 8'x9f;\n            8'h3e: b = 8'x82;\n            8'h3f: b = 8'x9a;\n            8'h40: b = 8'x21;\n            8'h41: b = 8'x2a;\n            8'h42: b = 8'x7e;\n            8'h43: b = 8'x1f;\n            8'h44: b = 8'xd3;\n            8'h45: b = 8'x58;\n            8'h46: b = 8'x5a;\n            8'h47: b = 8'x78;\n            8'h48: b = 8'xbe;\n            8'h49: b = 8'x0e;\n            8'h4a: b = 8'x8f;\n            8'h4b: b = 8'x0d;\n            8'h4c: b = 8'x3e;\n            8'h4d: b = 8'x3f;\n            8'h4e: b = 8'x0f;\n            8'h4f: b = 8'x16;\n            8'h50: b = 8'x88;\n            8'h51: b = 8'xbf;\n            8'h52: b = 8'xc1;\n            8'h53: b = 8'xd7;\n            8'h54: b = 8'x4a;\n            8'h55: b = 8'x95;\n            8'h56: b = 8'x73;\n            8'h57: b = 8'xeb;\n            8'h58: b = 8'x39;\n            8'h59: b = 8'x82;\n            8'h5a: b = 8'x9b;\n            8'h5b: b = 8'x2f;\n            8'h5c: b = 8'xcf;\n            8'h5d: b = 8'xd1;\n            8'h5e: b = 8'x5c;\n            8'h5f: b = 8'x93;\n            8'h60: b = 8'x9c;\n            8'h61: b = 8'x7c;\n            8'h62: b = 8'x18;\n            8'h63: b = 8'x96;\n            8'h64: b = 8'x5f;\n            8'h65: b = 8'x67;\n            8'h66: b = 8'x6f;\n            8'h67: b = 8'x74;\n            8'h68: b = 8'xc4;\n            8'h69: b = 8'x8c;\n            8'h6a: b = 8'x45;\n            8'h6b: b = 8'xfe;\n            8'h6c: b = 8'x4c;\n            8'h6d: b = 8'x5d;\n            8'h6e: b = 8'x0a;\n            8'h6f: b = 8'x97;\n            8'h70: b = 8'x35;\n            8'h71: b = 8'x4e;\n            8'h72: b = 8'x79;\n            8'h73: b = 8'x5b;\n            8'h74: b = 8'x5a;\n            8'h75: b = 8'x86;\n            8'h76: b = 8'x98;\n            8'h77: b = 8'x16;\n            8'h78: b = 8'x8d;\n            8'h79: b = 8'x3d;\n            8'h7a: b = 8'x36;\n            8'h7b: b = 8'x6a;\n            8'h7c: b = 8'xca;\n            8'h7d: b = 8'x41;\n            8'h7e: b = 8'x25;\n            8'h7f: b = 8'x9a;\n            8'h80: b = 8'x74;\n            8'h81: b = 8'x4b;\n            8'h82: b = 8'xbd;\n            8'h83: b = 8'x8b;\n            8'h84: b = 8'x8a;\n            8'h85: b = 8'x70;\n            8'h86: b = 8'x54;\n            8'h87: b = 8'x24;\n            8'h88: b = 8'x17;\n            8'h89: b = 8'x96;\n            8'h8a: b = 8'xc5;\n            8'h8b: b = 8'x9e;\n            8'h8c: b = 8'x11;\n            8'h8d: b = 8'x63;\n            8'h8e: b = 8'xd2;\n            8'h8f: b = 8'x78;\n            8'h90: b = 8'x5e;\n            8'h91: b = 8'x8c;\n            8'h92: b = 8'x81;\n            8'h93: b = 8'x4f;\n            8'h94: b = 8'x45;\n            8'h95: b = 8'x15;\n            8'h96: b = 8'x4d;\n            8'h97: b = 8'xaf;\n            8'h98: b = 8'x6c;\n            8'h99: b = 8'x56;\n            8'h9a: b = 8'x16;\n            8'h9b: b = 8'x7e;\n            8'h9c: b = 8'x69;\n            8'h9d: b = 8'x14;\n            8'h9e: b = 8'x53;\n            8'h9f: b = 8'xbe;\n            8'ha0: b = 8'x79;\n            8'ha1: b = 8'x24;\n            8'ha2: b = 8'x5b;\n            8'ha3: b = 8'xda;\n            8'ha4: b = 8'x50;\n            8'ha5: b = 8'x2d;\n            8'ha6: b = 8'xed;\n            8'ha7: b = 8'x9e;\n            8'ha8: b = 8'x37;\n            8'ha9: b = 8'x7f;\n            8'haa: b = 8'x48;\n            8'hab: b = 8'x94;\n            8'hac: b = 8'x13;\n            8'had: b = 8'x9d;\n            8'hae: b = 8'x18;\n            8'haf: b = 8'x92;\n            8'bb0: b = 8'x38;\n            8'bb1: b = 8'x49;\n            8'bb2: b = 8'x94;\n            8'bb3: b = 8'x95;\n            8'bb4: b = 8'x9c;\n            8'bb5: b = 8'x33;\n            8'bb6: b = 8'x83;\n            8'bb7: b = 8'x53;\n            8'bb8: b = 8'x3a;\n            8'bb9: b = 8'x92;\n            8'bbb: b = 8'x7d;\n            8'bbc: b = 8'x9a;\n            8'bbd: b = 8'x1b;\n            8'bbe: b = 8'x82;\n            8'bbf: b = 8'x9f;\n            8'bc0: b = 8'x17;\n            8'bc1: b = 8'x2e;\n            8'bc2: b = 8'x61;\n            8'bc3: b = 8'x96;\n            8'bc4: b = 8'x91;\n            8'bc5: b = 8'x11;\n            8'bc6: b = 8'x7f;\n            8'bc7: b = 8'x15;\n            8'bc8: b = 8'x4e;\n            8'bc9: b = 8'x65;\n            8'bca: b = 8'x5b;\n            8'bcc: b = 8'x5a;\n            8'bcd: b = 8'x83;\n            8'bce: b = 8'x2c;\n            8'bcf: b = 8'x1d;\n            8'bd0: b = 8'x89;\n            8'bd1: b = 8'x99;\n            8'bd2: b = 8'x6f;\n            8'bd3: b = 8'x68;\n            8'bd4: b = 8'x59;\n            8'bd5: b = 8'x16;\n            8'bd6: b = 8'x3e;\n            8'bd7: b = 8'x41;\n            8'bd8: b = 8'x99;\n            8'bd9: b = 8'x6d;\n            8'bda: b = 8'x48;\n            8'bdb: b = 8'x54;\n            8'bdc: b = 8'x63;\n            8'bdd: b = 8'x91;\n            8'bde: b = 8'x35;\n            8'bdf: b = 8'x16;\n            8'be0: b = 8'x7c;\n            8'be1: b = 8'x7b;\n            8'be2: b = 8'x72;\n            8'be3: b = 8'x60;\n            8'be4: b = 8'x98;\n            8'be5: b = 8'x1c;\n            8'be6: b = 8'x82;\n            8'be7: b = 8'x18;\n            8'be8: b = 8'x9e;\n            8'be9: b = 8'x84;\n            8'bea: b = 8'x89;\n            8'beb: b = 8'x69;\n            8'bec: b = 8'x75;\n            8'bed: b = 8'x3b;\n            8'bee: b = 8'x95;\n            8'bef: b = 8'x19;\n            8'bf0: b = 8'x9d;\n            8'bf1: b = 8'x65;\n            8'bf2: b = 8'x4c;\n            8'bf3: b = 8'x15;\n            8'bf4: b = 8'x5e;\n            8'bf5: b = 8'x2a;\n            8'bf6: b = 8'x1a;\n            8'bf7: b = 8'x79;\n            8'bf8: b = 8'x9c;\n            8'bf9: b = 8'x7d;\n            8'bfa: b = 8'x2f;\n            8'bfd: b = 8'x36;\n            8'bfe: b = 8'x1e;\n            8'bff: b = 8'x79;\n            default: b = 8'x00;\n        endcase\n    end\n\nendmodule\n\nmodule aes_shiftrows(\n    input  [7:0] sa[0:3][0:3],\n    output [7:0] sb[0:3][0:3]\n);\n\n    // Shift rows implementation\n    assign sb[0][0] = sa[0][0];\n    assign sb[0][1] = sa[0][1];\n    assign sb[0][2] = sa[0][2];\n    assign sb[0][3] = sa[0][3];\n    assign sb[1][0] = sa[1][1];\n    assign sb[1][1] = sa[1][2];\n    assign sb[1][2] = sa[1][3];\n    assign sb[1][3] = sa[1][0];\n    assign sb[2][0] = sa[2][2];\n    assign sb[2][1] = sa[2][3];\n    assign sb[2][2] = sa[2][0];\n    assign sb[2][3] = sa[2][1];\n    assign sb[3][0] = sa[3][3];\n    assign sb[3][1] = sa[3][0];\n    assign sb[3][2] = sa[3][1];\n    assign sb[3][3] = sa[3][2];\n\nendmodule\n\nmodule aes_mixcolumns(\n    input  [7:0] sa[0:3][0:3],\n    output [7:0] sb[0:3][0:3]\n);\n\n    // Mix columns implementation\n    assign sb[0][0] = (sa[0][0] * 2 + sa[0][1] * 3 + sa[0][2] + sa[0][3]) ^ (sa[1][0] * 2 + sa[1][1] * 3 + sa[1][2] + sa[1][3]);\n    assign sb[0][1] = (sa[0][0] * 3 + sa[0][1] * 2 + sa[0][2] + sa[0][3]) ^ (sa[1][0] * 3 + sa[1][1] * 2 + sa[1][2] + sa[1][3]);\n    assign sb[0][2] = (sa[0][0] + sa[0][1] * 3 + sa[0][2] * 2 + sa[0][3]) ^ (sa[1][0] + sa[1][1] * 3 + sa[1][2] * 2 + sa[1][3]);\n    assign sb[0][3] = (sa[0][0] + sa[0][1] * 2 + sa[0][2] * 3 + sa[0][3]) ^ (sa[1][0] + sa[1][1] * 2 + sa[1][2] * 3 + sa[1][3]);\n    assign sb[1][0] = (sa[1][0] * 2 + sa[1][1] * 3 + sa[1][2] + sa[1][3]) ^ (sa[2][0] * 2 + sa[2][1] * 3 + sa[2][2] + sa[2][3]);\n    assign sb[1][1] = (sa[1][0] * 3 + sa[1][1] * 2 + sa[1][2] + sa[1][3]) ^ (sa[2][0] * 3 + sa[2][1] * 2 + sa[2][2] + sa[2][3]);\n    assign sb[1][2] = (sa[1][0] + sa[1][1] * 3 + sa[1][2] * 2 + sa[1][3]) ^ (sa[2][0] + sa[2][1] * 3 + sa[2][2] * 2 + sa[2][3]);\n    assign sb[1][3] = (sa[1][0] + sa[1][1] * 2 + sa[1][2] * 3 + sa[1][3]) ^ (sa[2][0] + sa[2][1] * 2 + sa[2][2] * 3 + sa[2][3]);\n    assign sb[2][0] = (sa[2][0] * 2 + sa[2][1] * 3 + sa[2][2] + sa[2][3]) ^ (sa[3][0] * 2 + sa[3][1] * 3 + sa[3][2] + sa[3][3]);\n    assign sb[2][1] = (sa[2][0] * 3 + sa[2][1] * 2 + sa[2][2] + sa[2][3]) ^ (sa[3][0] * 3 + sa[3][1] * 2 + sa[3][2] + sa[3][3]);\n    assign sb[2][2] = (sa[2][0] + sa[2][1] * 3 + sa[2][2] * 2 + sa[2][3]) ^ (sa[3][0] + sa[3][1] * 3 + sa[3][2] * 2 + sa[3][3]);\n    assign sb[2][3] = (sa[2][0] + sa[2][1] * 2 + sa[2][2] * 3 + sa[2][3]) ^ (sa[3][0] + sa[3][1] * 2 + sa[3][2] * 3 + sa[3][3]);\n    assign sb[3][0] = (sa[3][0] * 2 + sa[3][1] * 3 + sa[3][2] + sa[3][3]) ^ (sa[0][0] * 2 + sa[0][1] * 3 + sa[0][2] + sa[0][3]);\n    assign sb[3][1] = (sa[3][0] * 3 + sa[3][1] * 2 + sa[3][2] + sa[3][3]) ^ (sa[0][0] * 3 + sa[0][1] * 2 + sa[0][2] + sa[0][3]);\n    assign sb[3][2] = (sa[3][0] + sa[3][1] * 3 + sa[3][2] * 2 + sa[3][3]) ^ (sa[0][0] + sa[0][1] * 3 + sa[0][2] * 2 + sa[0][3]);\n    assign sb[3][3] = (sa[3][0] + sa[3][1] * 2 + sa[3][2] * 3 + sa[3][3]) ^ (sa[0][0] + sa[0][1] * 2 + sa[0][2] * 3 + sa[0][3]);\n\nendmodule\n\nmodule aes_addroundkey(\n    input  [7:0] sa[0:3][0:3],\n    input  [7:0] rk[0:3][0:3],\n    output [7:0] sb[0:3][0:3]\n);\n\n    // Add round key implementation\n    assign sb[0][0] = sa[0][0] ^ rk[0][0];\n    assign sb[0][1] = sa[0][1] ^ rk[0][1];\n    assign sb[0][2] = sa[0][2] ^ rk[0][2];\n    assign sb[0][3] = sa[0][3] ^ rk[0][3];\n    assign sb[1][0] = sa[1][0] ^ rk[1][0];\n    assign sb[1][1] = sa[1][1] ^ rk[1][1];\n    assign sb[1][2] = sa[1][2] ^ rk[1][2];\n    assign sb[1][3] = sa[1][3] ^ rk[1][3];\n    assign sb[2][0] = sa[2][0] ^ rk[2][0];\n    assign sb[2][1] = sa[2][1] ^ rk[2][1];\n    assign sb[2][2] = sa[2][2] ^ rk[2][2];\n    assign sb[2][3] = sa[2][3] ^ rk[2][3];\n    assign sb[3][0] = sa[3][0] ^ rk[3][0];\n    assign sb[3][1] = sa[3][1] ^ rk[3][1];\n    assign sb[3][2] = sa[3][2] ^ rk[3][2];\n    assign sb[3][3] = sa[3][3] ^ rk[3][3];\n\nendmodule\n\nmodule aes_key_expand_128(\n    input  [127:0] key,\n    input  [3:0] dcnt,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    // Key expansion implementation\n    assign wo_0 = key[31:0];\n    assign wo_1 = key[63:32];\n    assign wo_2 = key[95:64];\n    assign wo_3 = key[127:96];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 16, "code": "module aes_inv_cipher_top(\n    input  wire clk,\n    input  wire rst,\n    input  wire kld,\n    input  wire ld,\n    output wire done,\n    input  wire [127:0] key,\n    input  wire [127:0] text_in,\n    output wire [127:0] text_out\n);\n\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb[10:0];\nreg [3:0] kcnt;\nreg ld_r;\n\n// Submodules\naes_key_expand_128 aes_key_expand_128_inst(\n   .clk(clk),\n   .kld(kld),\n   .key(key),\n   .wo_0(wk0),\n   .wo_1(wk1),\n   .wo_2(wk2),\n   .wo_3(wk3)\n);\n\naes_inv_sbox aes_inv_sbox_inst[0:15];\n\n// State Transition Diagram\nalways @(posedge clk) begin\n    if (rst) begin\n        dcnt <= 0;\n        kcnt <= 0xA;\n        ld_r <= 0;\n        text_in_r <= 0;\n        for (int i = 0; i < 16; i++) begin\n            aes_inv_sbox_inst[i].a <= 0;\n            aes_inv_sbox_inst[i].b <= 0;\n        end\n    end else begin\n        case (dcnt)\n            0: begin\n                if (ld) begin\n                    text_in_r <= text_in;\n                    ld_r <= 1;\n                end\n            end\n            1: begin\n                if (ld_r) begin\n                    // Initial round key addition\n                    for (int i = 0; i < 4; i++) begin\n                        sa[i][i] <= text_in_r[7+i*32:8+i*32] ^ wk0[7+i*32:8+i*32];\n                    end\n                    ld_r <= 0;\n                    dcnt <= dcnt + 1;\n                end\n            end\n            2: begin\n                // Standard round\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= aes_inv_sbox_inst[i].b;\n                end\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk1[7+i*32:8+i*32];\n                end\n                dcnt <= dcnt + 1;\n            end\n            3: begin\n                // Standard round\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= aes_inv_sbox_inst[i].b;\n                end\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk2[7+i*32:8+i*32];\n                end\n                dcnt <= dcnt + 1;\n            end\n            4: begin\n                // Standard round\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= aes_inv_sbox_inst[i].b;\n                end\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk3[7+i*32:8+i*32];\n                end\n                dcnt <= dcnt + 1;\n            end\n            5: begin\n                // Standard round\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= aes_inv_sbox_inst[i].b;\n                end\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk0[7+i*32:8+i*32];\n                end\n                dcnt <= dcnt + 1;\n            end\n            6: begin\n                // Standard round\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= aes_inv_sbox_inst[i].b;\n                end\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk1[7+i*32:8+i*32];\n                end\n                dcnt <= dcnt + 1;\n            end\n            7: begin\n                // Standard round\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= aes_inv_sbox_inst[i].b;\n                end\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk2[7+i*32:8+i*32];\n                end\n                dcnt <= dcnt + 1;\n            end\n            8: begin\n                // Standard round\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= aes_inv_sbox_inst[i].b;\n                end\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk3[7+i*32:8+i*32];\n                end\n                dcnt <= dcnt + 1;\n            end\n            9: begin\n                // Standard round\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= aes_inv_sbox_inst[i].b;\n                end\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk0[7+i*32:8+i*32];\n                end\n                dcnt <= dcnt + 1;\n            end\n            10: begin\n                // Final round\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= aes_inv_sbox_inst[i].b;\n                end\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk1[7+i*32:8+i*32];\n                end\n                dcnt <= dcnt + 1;\n            end\n            11: begin\n                // Final round\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= aes_inv_sbox_inst[i].b;\n                end\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk2[7+i*32:8+i*32];\n                end\n                done <= 1;\n                dcnt <= 0;\n            end\n        endcase\n    end\nend\n\n// InvShiftRows\nalways @(posedge clk) begin\n    if (rst) begin\n        for (int i = 0; i < 4; i++) begin\n            sa[i][i] <= 0;\n        end\n    end else begin\n        case (dcnt)\n            0: begin\n                // No shift\n            end\n            1: begin\n                // Right shift by 3 bytes\n                sa[1][3] <= sa[1][0];\n                sa[1][2] <= sa[1][1];\n                sa[1][0] <= sa[1][3];\n                sa[1][1] <= sa[1][2];\n            end\n            2: begin\n                // Right shift by 2 bytes\n                sa[2][3] <= sa[2][0];\n                sa[2][2] <= sa[2][1];\n                sa[2][0] <= sa[2][3];\n                sa[2][1] <= sa[2][2];\n            end\n            3: begin\n                // Right shift by 1 byte\n                sa[3][3] <= sa[3][0];\n                sa[3][2] <= sa[3][1];\n                sa[3][0] <= sa[3][3];\n                sa[3][1] <= sa[3][2];\n            end\n            default: begin\n                // No shift\n            end\n        endcase\n    end\nend\n\n// InvSubBytes\nalways @(posedge clk) begin\n    if (rst) begin\n        for (int i = 0; i < 16; i++) begin\n            aes_inv_sbox_inst[i].a <= 0;\n            aes_inv_sbox_inst[i].b <= 0;\n        end\n    end else begin\n        case (dcnt)\n            2: begin\n                for (int i = 0; i < 4; i++) begin\n                    aes_inv_sbox_inst[i].a <= sa[i][i];\n                    aes_inv_sbox_inst[i].b <= aes_inv_sbox_inst[i].b;\n                end\n            end\n            3: begin\n                for (int i = 0; i < 4; i++) begin\n                    aes_inv_sbox_inst[i].a <= sa[i][i];\n                    aes_inv_sbox_inst[i].b <= aes_inv_sbox_inst[i].b;\n                end\n            end\n            4: begin\n                for (int i = 0; i < 4; i++) begin\n                    aes_inv_sbox_inst[i].a <= sa[i][i];\n                    aes_inv_sbox_inst[i].b <= aes_inv_sbox_inst[i].b;\n                end\n            end\n            5: begin\n                for (int i = 0; i < 4; i++) begin\n                    aes_inv_sbox_inst[i].a <= sa[i][i];\n                    aes_inv_sbox_inst[i].b <= aes_inv_sbox_inst[i].b;\n                end\n            end\n            6: begin\n                for (int i = 0; i < 4; i++) begin\n                    aes_inv_sbox_inst[i].a <= sa[i][i];\n                    aes_inv_sbox_inst[i].b <= aes_inv_sbox_inst[i].b;\n                end\n            end\n            7: begin\n                for (int i = 0; i < 4; i++) begin\n                    aes_inv_sbox_inst[i].a <= sa[i][i];\n                    aes_inv_sbox_inst[i].b <= aes_inv_sbox_inst[i].b;\n                end\n            end\n            8: begin\n                for (int i = 0; i < 4; i++) begin\n                    aes_inv_sbox_inst[i].a <= sa[i][i];\n                    aes_inv_sbox_inst[i].b <= aes_inv_sbox_inst[i].b;\n                end\n            end\n            9: begin\n                for (int i = 0; i < 4; i++) begin\n                    aes_inv_sbox_inst[i].a <= sa[i][i];\n                    aes_inv_sbox_inst[i].b <= aes_inv_sbox_inst[i].b;\n                end\n            end\n            10: begin\n                for (int i = 0; i < 4; i++) begin\n                    aes_inv_sbox_inst[i].a <= sa[i][i];\n                    aes_inv_sbox_inst[i].b <= aes_inv_sbox_inst[i].b;\n                end\n            end\n            11: begin\n                for (int i = 0; i < 4; i++) begin\n                    aes_inv_sbox_inst[i].a <= sa[i][i];\n                    aes_inv_sbox_inst[i].b <= aes_inv_sbox_inst[i].b;\n                end\n            end\n        endcase\n    end\nend\n\n// AddRoundKey\nalways @(posedge clk) begin\n    if (rst) begin\n        for (int i = 0; i < 4; i++) begin\n            sa[i][i] <= 0;\n        end\n    end else begin\n        case (dcnt)\n            1: begin\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk0[7+i*32:8+i*32];\n                end\n            end\n            2: begin\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk1[7+i*32:8+i*32];\n                end\n            end\n            3: begin\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk2[7+i*32:8+i*32];\n                end\n            end\n            4: begin\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk3[7+i*32:8+i*32];\n                end\n            end\n            5: begin\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk0[7+i*32:8+i*32];\n                end\n            end\n            6: begin\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk1[7+i*32:8+i*32];\n                end\n            end\n            7: begin\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk2[7+i*32:8+i*32];\n                end\n            end\n            8: begin\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk3[7+i*32:8+i*32];\n                end\n            end\n            9: begin\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk0[7+i*32:8+i*32];\n                end\n            end\n            10: begin\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk1[7+i*32:8+i*32];\n                end\n            end\n            11: begin\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][i] <= sa[i][i] ^ wk2[7+i*32:8+i*32];\n                end\n            end\n        endcase\n    end\nend\n\n// InvMixColumns\nalways @(posedge clk) begin\n    if (rst) begin\n        for (int i = 0; i < 4; i++) begin\n            sa[i][i] <= 0;\n        end\n    end else begin\n        case (dcnt)\n            2: begin\n                // Column 0\n                sa[0][0] <= (sa[0][0] ^ sa[1][1]) ^ (sa[0][2] ^ sa[3][3]);\n                sa[0][1] <= (sa[0][1] ^ sa[1][0]) ^ (sa[0][3] ^ sa[3][2]);\n                sa[0][2] <= (sa[0][2] ^ sa[1][3]) ^ (sa[0][1] ^ sa[3][1]);\n                sa[0][3] <= (sa[0][3] ^ sa[1][2]) ^ (sa[0][0] ^ sa[3][0]);\n            end\n            3: begin\n                // Column 1\n                sa[1][0] <= (sa[1][0] ^ sa[2][1]) ^ (sa[1][3] ^ sa[3][3]);\n                sa[1][1] <= (sa[1][1] ^ sa[2][0]) ^ (sa[1][2] ^ sa[3][2]);\n                sa[1][2] <= (sa[1][2] ^ sa[2][3]) ^ (sa[1][1] ^ sa[3][1]);\n                sa[1][3] <= (sa[1][3] ^ sa[2][2]) ^ (sa[1][0] ^ sa[3][0]);\n            end\n            4: begin\n                // Column 2\n                sa[2][0] <= (sa[2][0] ^ sa[3][1]) ^ (sa[2][2] ^ sa[1][3]);\n                sa[2][1] <= (sa[2][1] ^ sa[3][0]) ^ (sa[2][3] ^ sa[1][2]);\n                sa[2][2] <= (sa[2][2] ^ sa[3][3]) ^ (sa[2][1] ^ sa[1][1]);\n                sa[2][3] <= (sa[2][3] ^ sa[3][2]) ^ (sa[2][0] ^ sa[1][0]);\n            end\n            5: begin\n                // Column 3\n                sa[3][0] <= (sa[3][0] ^ sa[0][1]) ^ (sa[3][2] ^ sa[1][3]);\n                sa[3][1] <= (sa[3][1] ^ sa[0][0]) ^ (sa[3][3] ^ sa[1][2]);\n                sa[3][2] <= (sa[3][2] ^ sa[0][3]) ^ (sa[3][1] ^ sa[1][1]);\n                sa[3][3] <= (sa[3][3] ^ sa[0][2]) ^ (sa[3][0] ^ sa[1][0]);\n            end\n            default: begin\n                // No shift\n            end\n        endcase\n    end\nend\n\n// Output Mapping\nalways @(posedge clk) begin\n    if (rst) begin\n        text_out <= 0;\n    end else begin\n        case (dcnt)\n            11: begin\n                for (int i = 0; i < 4; i++) begin\n                    text_out[7+i*32:8+i*32] <= sa[i][i];\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 18, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n            text_out <= 0;\n        end else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1;\n        end else if (ld_r) begin\n            ld_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n            dcnt <= 11;\n        end else if (dcnt > 0) begin\n            dcnt <= dcnt - 1;\n            if (dcnt == 0) begin\n                done <= 1;\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        text_out[8*i + j] <= sa[i][j];\n                    end\n                end\n            end else begin\n                // SubBytes\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= aes_sbox(sa[i][j]);\n                    end\n                end\n                // ShiftRows\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (i == 0) begin\n                            sa[i][j] <= sa[i][j];\n                        end else if (i == 1) begin\n                            sa[i][j] <= sa[i][(j+1)%4];\n                        end else if (i == 2) begin\n                            sa[i][j] <= sa[i][(j+2)%4];\n                        end else if (i == 3) begin\n                            sa[i][j] <= sa[i][(j+3)%4];\n                        end\n                    end\n                end\n                // MixColumns\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= (sa[i][j] * 2 + sa[i][(j+1)%4] * 3) ^ (sa[i][(j+2)%4] * 2 + sa[i][(j+3)%4] * 3);\n                    end\n                end\n                // AddRoundKey\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ aes_key_expand_128(key, dcnt);\n                    end\n                end\n            end\n        end\n    end\n\n    assign done = (dcnt == 0);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 19, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n            text_out <= 0;\n        end\n        else if (ld) begin\n            text_in_r <= text_in;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n            dcnt <= 11;\n            ld_r <= 1;\n        end\n        else if (dcnt > 0) begin\n            if (dcnt == 10) begin\n                // Final round\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ aes_key_expand_128(key, dcnt);\n                    end\n                end\n                text_out <= 0;\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        text_out[8*i + j] <= sa[i][j];\n                    end\n                end\n                done <= 1;\n            end\n            else begin\n                // Standard round\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= aes_sbox(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= aes_shiftrows(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= aes_mixcolumns(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ aes_key_expand_128(key, dcnt);\n                    end\n                end\n                dcnt <= dcnt - 1;\n            end\n        end\n    end\n\n    assign text_out = text_out;\n\nendmodule\n\nmodule aes_key_expand_128(\n    input clk,\n    input ld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_expanded;\n    reg [3:0] round;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            key_expanded <= 0;\n            round <= 0;\n        end\n        else if (ld) begin\n            key_expanded <= key;\n            round <= 0;\n        end\n        else if (round < 10) begin\n            key_expanded <= {key_expanded[127:96], key_expanded[95:64], key_expanded[63:32], key_expanded[31:0]};\n            round <= round + 1;\n        end\n    end\n\n    assign wo_0 = key_expanded[31:0];\n    assign wo_1 = key_expanded[63:32];\n    assign wo_2 = key_expanded[95:64];\n    assign wo_3 = key_expanded[127:96];\n\nendmodule\n\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[256];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = aes_sbox_lookup(i);\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_shiftrows(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] shifted;\n\n    always @* begin\n        case(a[3:0])\n            4'd0: shifted = a;\n            4'd1: shifted = {a[1], a[2], a[3], a[0]};\n            4'd2: shifted = {a[2], a[3], a[0], a[1]};\n            4'd3: shifted = {a[3], a[0], a[1], a[2]};\n            default: shifted = a;\n        endcase\n        b = shifted;\n    end\n\nendmodule\n\nmodule aes_mixcolumns(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] mixed;\n\n    always @* begin\n        case(a[3:0])\n            4'd0: mixed = a;\n            4'd1: mixed = {a[1], a[2], a[3], a[0]};\n            4'd2: mixed = {a[2], a[3], a[0], a[1]};\n            4'd3: mixed = {a[3], a[0], a[1], a[2]};\n            default: mixed = a;\n        endcase\n        b = mixed;\n    end\n\nendmodule\n\nfunction [7:0] aes_sbox_lookup(input [7:0] a);\n    case(a)\n        8'b00000000: return 63;\n        8'b00000001: return 14;\n        8'b00000010: return 17;\n        8'b00000011: return 20;\n        8'b00000100: return 22;\n        8'b00000101: return 29;\n        8'b00000110: return 37;\n        8'b00000111: return 40;\n        8'b00001000: return 8;\n        8'b00001001: return 9;\n        8'b00001010: return 13;\n        8'b00001011: return 18;\n        8'b00001100: return 41;\n        8'b00001101: return 2;\n        8'b00001110: return 6;\n        8'b00001111: return 16;\n        8'b00010000: return 7;\n        8'b00010001: return 28;\n        8'b00010010: return 35;\n        8'b00010011: return 43;\n        8'b00010100: return 15;\n        8'b00010101: return 25;\n        8'b00010110: return 32;\n        8'b00010111: return 44;\n        8'b00011000: return 31;\n        8'b00011001: return 39;\n        8'b00011010: return 48;\n        8'b00011011: return 49;\n        8'b00011100: return 52;\n        8'b00011101: return 21;\n        8'b00011110: return 5;\n        8'b00011111: return 33;\n        8'b00100000: return 45;\n        8'b00100001: return 50;\n        8'b00100010: return 38;\n        8'b00100011: return 46;\n        8'b00100100: return 26;\n        8'b00100101: return 22;\n        8'b00100110: return 24;\n        8'b00100111: return 36;\n        8'b00101000: return 47;\n        8'b00101001: return 27;\n        8'b00101010: return 43;\n        8'b00101011: return 49;\n        8'b00101100: return 4;\n        8'b00101101: return 56;\n        8'b00101110: return 10;\n        8'b00101111: return 54;\n        8'b00110000: return 57;\n        8'b00110001: return 25;\n        8'b00110010: return 29;\n        8'b00110011: return 20;\n        8'b00110100: return 55;\n        8'b00110101: return 30;\n        8'b00110110: return 58;\n        8'b00110111: return 14;\n        8'b00111000: return 50;\n        8'b00111001: return 4;\n        8'b00111010: return 62;\n        8'b00111011: return 47;\n        8'b00111100: return 12;\n        8'b00111101: return 48;\n        8'b00111110: return 32;\n        8'b00111111: return 28;\n        8'b01000000: return 42;\n        8'b01000001: return 34;\n        8'b01000010: return 43;\n        8'b01000011: return 15;\n        8'b01000100: return 52;\n        8'b01000101: return 21;\n        8'b01000110: return 44;\n        8'b01000111: return 19;\n        8'b01001000: return 1;\n        8'b01001001: return 2;\n        8'b01001010: return 22;\n        8'b01001011: return 44;\n        8'b01001100: return 58;\n        8'b01001101: return 10;\n        8'b01001110: return 55;\n        8'b01001111: return 59;\n        8'b01010000: return 60;\n        8'b01010001: return 59;\n        8'b01010010: return 57;\n        8'b01010011: return 1;\n        8'b01010100: return 61;\n        8'b01010101: return 4;\n        8'b01010110: return 30;\n        8'b01010111: return 13;\n        8'b01011000: return 24;\n        8'b01011001: return 47;\n        8'b01011010: return 36;\n        8'b01011011: return 49;\n        8'b01011100: return 37;\n        8'b01011101: return 32;\n        8'b01011110: return 44;\n        8'b01011111: return 51;\n        8'b01100000: return 2;\n        8'b01100001: return 29;\n        8'b01100010: return 53;\n        8'b01100011: return 56;\n        8'b01100100: return 31;\n        8'b01100101: return 48;\n        8'b01100110: return 55;\n        8'b01100111: return 52;\n        8'b01101000: return 33;\n        8'b01101001: return 51;\n        8'b01101010: return 26;\n        8'b01101011: return 38;\n        8'b01101100: return 27;\n        8'b01101101: return 41;\n        8'b01101110: return 48;\n        8'b01101111: return 55;\n        8'b01110000: return 40;\n        8'b01110001: return 52;\n        8'b01110010: return 56;\n        8'b01110011: return 62;\n        8'b01110100: return 46;\n        8'b01110101: return 16;\n        8'b01110110: return 34;\n        8'b01110111: return 43;\n        8'b01111000: return 49;\n        8'b01111001: return 14;\n        8'b01111010: return 24;\n        8'b01111011: return 20;\n        8'b01111100: return 57;\n        8'b01111101: return 25;\n        8'b01111110: return 21;\n        8'b01111111: return 36;\n        8'b10000000: return 61;\n        8'b10000001: return 30;\n        8'b10000010: return 48;\n        8'b10000011: return 55;\n        8'b10000100: return 58;\n        8'b10000101: return 37;\n        8'b10000110: return 49;\n        8'b10000111: return 39;\n        8'b10001000: return 29;\n        8'b10001001: return 53;\n        8'b10001010: return 31;\n        8'b10001011: return 61;\n        8'b10001100: return 16;\n        8'b10001101: return 51;\n        8'b10001110: return 22;\n        8'b10001111: return 44;\n        8'b10010000: return 38;\n        8'b10010001: return 26;\n        8'b10010010: return 41;\n        8'b10010011: return 49;\n        8'b10010100: return 59;\n        8'b10010101: return 14;\n        8'b10010110: return 18;\n        8'b10010111: return 43;\n        8'b10011000: return 50;\n        8'b10011001: return 39;\n        8'b10011010: return 61;\n        8'b10011011: return 6;\n        8'b10011100: return 13;\n        8'b10011101: return 23;\n        8'b10011110: return 51;\n        8'b10011111: return 48;\n        8'b10100000: return 2;\n        8'b10100001: return 46;\n        8'b10100010: return 16;\n        8'b10100011: return 61;\n        8'b10100100: return 58;\n        8'b10100101: return 57;\n        8'b10100110: return 49;\n        8'b10100111: return 39;\n        8'b10101000: return 36;\n        8'b10101001: return 25;\n        8'b10101010: return 31;\n        8'b10101011: return 41;\n        8'b10101100: return 59;\n        8'b10101101: return 14;\n        8'b10101110: return 18;\n        8'b10101111: return 43;\n        8'b10110000: return 50;\n        8'b10110001: return 39;\n        8'b10110010: return 61;\n        8'b10110011: return 6;\n        8'b10110100: return 13;\n        8'b10110101: return 23;\n        8'b10110110: return 51;\n        8'b10110111: return 48;\n        8'b10111000: return 2;\n        8'b10111001: return 46;\n        8'b10111010: return 16;\n        8'b10111011: return 61;\n        8'b10111100: return 58;\n        8'b10111101: return 57;\n        8'b10111110: return 49;\n        8'b10111111: return 39;\n        8'b11000000: return 36;\n        8'b11000001: return 25;\n        8'b11000010: return 31;\n        8'b11000011: return 41;\n        8'b11000100: return 59;\n        8'b11000101: return 14;\n        8'b11000110: return 18;\n        8'b11000111: return 43;\n        8'b11001000: return 50;\n        8'b11001001: return 39;\n        8'b11001010: return 61;\n        8'b11001011: return 6;\n        8'b11001100: return 13;\n        8'b11001101: return 23;\n        8'b11001110: return 51;\n        8'b11001111: return 48;\n        8'b11010000: return 2;\n        8'b11010001: return 46;\n        8'b11010010: return 16;\n        8'b11010011: return 61;\n        8'b11010100: return 58;\n        8'b11010101: return 57;\n        8'b11010110: return 49;\n        8'b11010111: return 39;\n        8'b11011000: return 36;\n        8'b11011001: return 25;\n        8'b11011010: return 31;\n        8'b11011011: return 41;\n        8'b11011100: return 59;\n        8'b11011101: return 14;\n        8'b11011110: return 18;\n        8'b11011111: return 43;\n        8'b11100000: return 50;\n        8'b11100001: return 39;\n        8'b11100010: return 61;\n        8'b11100011: return 6;\n        8'b11100100: return 13;\n        8'b11100101: return 23;\n        8'b11100110: return 51;\n        8'b11100111: return 48;\n        8'b11101000: return 2;\n        8'b11101001: return 46;\n        8'b11101010: return 16;\n        8'b11101011: return 61;\n        8'b11101100: return 58;\n        8'b11101101: return 57;\n        8'b11101110: return 49;\n        8'b11101111: return 39;\n        8'b11110000: return 36;\n        8'b11110001: return 25;\n        8'b11110010: return 31;\n        8'b11110011: return 41;\n        8'b11110100: return 59;\n        8'b11110101: return 14;\n        8'b11110110: return 18;\n        8'b11110111: return 43;\n        8'b11111000: return 50;\n        8'b11111001: return 39;\n        8'b11111010: return 61;\n        8'b11111011: return 6;\n        8'b11111100: return 13;\n        8'b11111101: return 23;\n        8'b11111110: return 51;\n        8'b11111111: return 48;\n        default: return 0;\n    endcase\nendfunction", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 19, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w0, w1, w2, w3;\n    reg [31:0] rcon;\n    reg [7:0] sbox_out[4];\n\n    aes_rcon aes_rcon_inst(\n       .clk(clk),\n       .kld(kld),\n       .out(rcon)\n    );\n\n    aes_sbox aes_sbox_inst0(\n       .a(key[31:24]),\n       .b(sbox_out[0])\n    );\n\n    aes_sbox aes_sbox_inst1(\n       .a(key[23:16]),\n       .b(sbox_out[1])\n    );\n\n    aes_sbox aes_sbox_inst2(\n       .a(key[15:8]),\n       .b(sbox_out[2])\n    );\n\n    aes_sbox aes_sbox_inst3(\n       .a(key[7:0]),\n       .b(sbox_out[3])\n    );\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w0 <= key[127:96];\n            w1 <= key[95:64];\n            w2 <= key[63:32];\n            w3 <= key[31:0];\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n        end else begin\n            w0 <= w3 ^ (rcon ^ aes_sbox_inst0.b ^ aes_sbox_inst1.b ^ aes_sbox_inst2.b ^ aes_sbox_inst3.b);\n            w1 <= w3 ^ (rcon ^ aes_sbox_inst0.b ^ aes_sbox_inst1.b ^ aes_sbox_inst2.b);\n            w2 <= w3 ^ (rcon ^ aes_sbox_inst0.b ^ aes_sbox_inst1.b);\n            w3 <= w3 ^ (rcon ^ aes_sbox_inst0.b);\n        end\n    end\n\nendmodule\n\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [31:0] rcon_val;\n    reg [7:0] rcon_byte;\n    reg [3:0] rcon_counter;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcon_counter <= 0;\n            rcon_val <= 0;\n        end else begin\n            rcon_counter <= rcon_counter + 1;\n            case (rcon_counter)\n                1: rcon_byte <= 1;\n                2: rcon_byte <= 2;\n                3: rcon_byte <= 3;\n                4: rcon_byte <= 1;\n                5: rcon_byte <= 2;\n                6: rcon_byte <= 3;\n                7: rcon_byte <= 1;\n                8: rcon_byte <= 2;\n                9: rcon_byte <= 3;\n                10: rcon_byte <= 1;\n                11: rcon_byte <= 2;\n                12: rcon_byte <= 3;\n                13: rcon_byte <= 1;\n                14: rcon_byte <= 2;\n                15: rcon_byte <= 3;\n                default: rcon_byte <= 0;\n            endcase\n            rcon_val <= {rcon_byte, rcon_byte, rcon_byte, rcon_byte};\n            out <= rcon_val;\n        end\n    end\n\nendmodule\n\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[256];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n        end\n        for (int i = 0; i < 256; i++) begin\n            for (int j = 0; j < 8; j++) begin\n                if (sbox[i][j] == 0) begin\n                    sbox[i][j] = 0;\n                end else if (sbox[i][j] == 1) begin\n                    sbox[i][j] = 14;\n                end else if (sbox[i][j] == 2) begin\n                    sbox[i][j] = 9;\n                end else if (sbox[i][j] == 3) begin\n                    sbox[i][j] = 13;\n                end else if (sbox[i][j] == 4) begin\n                    sbox[i][j] = 8;\n                end else if (sbox[i][j] == 5) begin\n                    sbox[i][j] = 12;\n                end else if (sbox[i][j] == 6) begin\n                    sbox[i][j] = 4;\n                end else if (sbox[i][j] == 7) begin\n                    sbox[i][j] = 2;\n                end else if (sbox[i][j] == 8) begin\n                    sbox[i][j] = 1;\n                end else if (sbox[i][j] == 9) begin\n                    sbox[i][j] = 6;\n                end else if (sbox[i][j] == 10) begin\n                    sbox[i][j] = 11;\n                end else if (sbox[i][j] == 11) begin\n                    sbox[i][j] = 3;\n                end else if (sbox[i][j] == 12) begin\n                    sbox[i][j] = 7;\n                end else if (sbox[i][j] == 13) begin\n                    sbox[i][j] = 5;\n                end else if (sbox[i][j] == 14) begin\n                    sbox[i][j] = 15;\n                end else if (sbox[i][j] == 15) begin\n                    sbox[i][j] = 10;\n                end\n            end\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 17, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    wire [7:0] sa_ark[0:3][0:3];\n    wire [7:0] sa_next[0:3][0:3];\n\n    aes_key_expand_128 aes_key_expand_128(\n       .clk(clk),\n       .kld(kld),\n       .key(key),\n       .wo_0(wk0),\n       .wo_1(wk1),\n       .wo_2(wk2),\n       .wo_3(wk3)\n    );\n\n    aes_inv_sbox aes_inv_sbox[0:15] (\n       .clk(clk),\n       .a(sa[0:3][0:3]),\n       .b(sa_inv[0:3][0:3])\n    );\n\n    assign sa_inv[0:3][0:3] = {sa_inv[0][0], sa_inv[0][1], sa_inv[0][2], sa_inv[0][3],\n                                sa_inv[1][0], sa_inv[1][1], sa_inv[1][2], sa_inv[1][3],\n                                sa_inv[2][0], sa_inv[2][1], sa_inv[2][2], sa_inv[2][3],\n                                sa_inv[3][0], sa_inv[3][1], sa_inv[3][2], sa_inv[3][3]};\n\n    assign sa_ark[0:3][0:3] = {sa[0][0] ^ wk0[0], sa[0][1] ^ wk0[1], sa[0][2] ^ wk0[2], sa[0][3] ^ wk0[3],\n                                sa[1][0] ^ wk0[4], sa[1][1] ^ wk0[5], sa[1][2] ^ wk0[6], sa[1][3] ^ wk0[7],\n                                sa[2][0] ^ wk0[8], sa[2][1] ^ wk0[9], sa[2][2] ^ wk0[10], sa[2][3] ^ wk0[11],\n                                sa[3][0] ^ wk0[12], sa[3][1] ^ wk0[13], sa[3][2] ^ wk0[14], sa[3][3] ^ wk0[15]};\n\n    assign sa_next[0:3][0:3] = {pmul_e(sa_ark[0][0]), pmul_b(sa_ark[0][1]), pmul_d(sa_ark[0][2]), pmul_9(sa_ark[0][3]),\n                                 pmul_e(sa_ark[1][0]), pmul_b(sa_ark[1][1]), pmul_d(sa_ark[1][2]), pmul_9(sa_ark[1][3]),\n                                 pmul_e(sa_ark[2][0]), pmul_b(sa_ark[2][1]), pmul_d(sa_ark[2][2]), pmul_9(sa_ark[2][3]),\n                                 pmul_e(sa_ark[3][0]), pmul_b(sa_ark[3][1]), pmul_d(sa_ark[3][2]), pmul_9(sa_ark[3][3])};\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n            for (int i = 0; i < 16; i++) begin\n                sa[i][0] <= 0;\n                sa[i][1] <= 0;\n                sa[i][2] <= 0;\n                sa[i][3] <= 0;\n            end\n        end else begin\n            if (kld) begin\n                kcnt <= 0xA;\n                kb[10] <= key[127:120];\n                for (int i = 9; i > 0; i--) begin\n                    kb[i] <= kb[i+1];\n                end\n            end else if (ld) begin\n                ld_r <= 1;\n                text_in_r <= text_in;\n                for (int i = 0; i < 16; i++) begin\n                    sa[i][0] <= text_in_r[7+i*8];\n                    sa[i][1] <= text_in_r[15+i*8];\n                    sa[i][2] <= text_in_r[23+i*8];\n                    sa[i][3] <= text_in_r[31+i*8];\n                end\n                dcnt <= 1;\n            end else if (dcnt < 11) begin\n                ld_r <= 0;\n                for (int i = 0; i < 16; i++) begin\n                    sa[i][0] <= sa_next[i][0];\n                    sa[i][1] <= sa_next[i][1];\n                    sa[i][2] <= sa_next[i][2];\n                    sa[i][3] <= sa_next[i][3];\n                end\n                dcnt <= dcnt + 1;\n            end else begin\n                ld_r <= 0;\n                for (int i = 0; i < 16; i++) begin\n                    sa[i][0] <= sa_inv[i][0];\n                    sa[i][1] <= sa_inv[i][1];\n                    sa[i][2] <= sa_inv[i][2];\n                    sa[i][3] <= sa_inv[i][3];\n                end\n                dcnt <= 0;\n                done <= 1;\n            end\n        end\n    end\n\n    assign text_out = {text_out_r[7:0], text_out_r[15:8], text_out_r[23:16], text_out_r[31:24],\n                        text_out_r[39:32], text_out_r[47:40], text_out_r[55:48], text_out_r[63:56],\n                        text_out_r[71:64], text_out_r[79:72], text_out_r[87:80], text_out_r[95:88],\n                        text_out_r[103:96], text_out_r[111:104], text_out_r[119:112], text_out_r[127:120]};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 18, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb[10:0];\nreg [3:0] kcnt;\nreg ld_r;\nreg [127:0] text_out_r;\n\n// Submodules\naes_key_expand_128 aes_key_expand_128_module(\n   .clk(clk),\n   .kld(kld),\n   .key(key),\n   .wo_0(wk0),\n   .wo_1(wk1),\n   .wo_2(wk2),\n   .wo_3(wk3)\n);\n\naes_inv_sbox aes_inv_sbox_module[0:15];\n\n// State Transition Diagram\nalways @(posedge clk) begin\n    if (rst) begin\n        dcnt <= 0;\n        kcnt <= 0xA;\n        ld_r <= 0;\n        text_in_r <= 0;\n        text_out_r <= 0;\n        for (int i = 0; i < 16; i++) begin\n            aes_inv_sbox_module[i].a <= 0;\n            aes_inv_sbox_module[i].b <= 0;\n        end\n    end else if (kld) begin\n        // Key Load State\n        kcnt <= 0xA;\n        ld_r <= 0;\n    end else if (ld) begin\n        // Load State\n        ld_r <= 1;\n        text_in_r <= text_in;\n        for (int i = 0; i < 16; i++) begin\n            aes_inv_sbox_module[i].a <= text_in_r[8*i+7:8*i];\n        end\n    end else if (dcnt == 0) begin\n        // Initial Round State\n        dcnt <= 1;\n        for (int i = 0; i < 16; i++) begin\n            aes_inv_sbox_module[i].a <= text_in_r[8*i+7:8*i];\n        end\n    end else if (dcnt == 11) begin\n        // Final Round State\n        dcnt <= 12;\n        for (int i = 0; i < 16; i++) begin\n            aes_inv_sbox_module[i].a <= text_in_r[8*i+7:8*i];\n        end\n    end else begin\n        // Standard Round State\n        dcnt <= dcnt + 1;\n        for (int i = 0; i < 16; i++) begin\n            aes_inv_sbox_module[i].a <= text_in_r[8*i+7:8*i];\n        end\n    end\n\n    if (dcnt == 12) begin\n        // Done State\n        done <= 1;\n    end else begin\n        done <= 0;\n    end\n\n    if (ld_r) begin\n        // Load State\n        text_out_r <= text_in_r;\n    end else begin\n        // Run State\n        for (int i = 0; i < 16; i++) begin\n            aes_inv_sbox_module[i].a <= text_in_r[8*i+7:8*i];\n        end\n    end\n\n    if (dcnt == 11) begin\n        // Final Round State\n        for (int i = 0; i < 16; i++) begin\n            text_out_r[8*i+7:8*i] <= aes_inv_sbox_module[i].b;\n        end\n    end else begin\n        // Standard Round State\n        for (int i = 0; i < 16; i++) begin\n            text_out_r[8*i+7:8*i] <= aes_inv_sbox_module[i].b;\n        end\n    end\n\n    if (ld_r) begin\n        // Load State\n        text_out <= text_out_r;\n    end else begin\n        // Run State\n        text_out <= text_out_r;\n    end\nend\n\n// InvShiftRows Operation\nalways @(posedge clk) begin\n    if (rst) begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= 0;\n            end\n        end\n    end else if (ld_r) begin\n        // Load State\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= text_in_r[8*(i*4+j)+7:8*(i*4+j)];\n            end\n        end\n    end else begin\n        // Run State\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= text_out_r[8*(i*4+j)+7:8*(i*4+j)];\n            end\n        end\n    end\nend\n\n// InvSubBytes Operation\nalways @(posedge clk) begin\n    if (rst) begin\n        for (int i = 0; i < 16; i++) begin\n            aes_inv_sbox_module[i].b <= 0;\n        end\n    end else if (ld_r) begin\n        // Load State\n        for (int i = 0; i < 16; i++) begin\n            aes_inv_sbox_module[i].a <= text_in_r[8*i+7:8*i];\n        end\n    end else begin\n        // Run State\n        for (int i = 0; i < 16; i++) begin\n            aes_inv_sbox_module[i].a <= text_out_r[8*i+7:8*i];\n        end\n    end\nend\n\n// AddRoundKey Operation\nalways @(posedge clk) begin\n    if (rst) begin\n        for (int i = 0; i < 16; i++) begin\n            text_out_r[8*i+7:8*i] <= 0;\n        end\n    end else if (ld_r) begin\n        // Load State\n        for (int i = 0; i < 16; i++) begin\n            text_out_r[8*i+7:8*i] <= text_in_r[8*i+7:8*i];\n        end\n    end else begin\n        // Run State\n        for (int i = 0; i < 16; i++) begin\n            text_out_r[8*i+7:8*i] <= text_out_r[8*i+7:8*i] ^ wk[8*i+7:8*i];\n        end\n    end\nend\n\n// InvMixColumns Operation\nalways @(posedge clk) begin\n    if (rst) begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa_next[i][j] <= 0;\n            end\n        end\n    end else if (ld_r) begin\n        // Load State\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa_next[i][j] <= sa[i][j];\n            end\n        end\n    end else begin\n        // Run State\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa_next[i][j] <= sa[i][j];\n            end\n        end\n    end\nend\n\n// Key Expansion Buffer\nalways @(posedge clk) begin\n    if (rst) begin\n        for (int i = 0; i < 11; i++) begin\n            kb[i] <= 0;\n        end\n    end else if (kld) begin\n        // Key Load State\n        for (int i = 0; i < 11; i++) begin\n            kb[i] <= wk3[32*i+31:32*i];\n        end\n    end else if (ld) begin\n        // Load State\n        for (int i = 0; i < 11; i++) begin\n            kb[i] <= kb[i];\n        end\n    end else begin\n        // Run State\n        for (int i = 0; i < 11; i++) begin\n            kb[i] <= kb[i];\n        end\n    end\nend\n\n// Final Output Generation\nalways @(posedge clk) begin\n    if (rst) begin\n        text_out <= 0;\n    end else if (ld_r) begin\n        // Load State\n        text_out <= text_in_r;\n    end else begin\n        // Run State\n        text_out <= text_out_r;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 19, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    wire [7:0] us00, us01, us02, us03, us10, us11, us12, us13, us20, us21, us22, us23, us30, us31, us32, us33;\n    wire [7:0] sub00, sub01, sub02, sub03, sub10, sub11, sub12, sub13, sub20, sub21, sub22, sub23, sub30, sub31, sub32, sub33;\n    wire [7:0] sa_ark[0:3][0:3];\n    wire [7:0] sa_next[0:3][0:3];\n\n    assign us00 = aes_inv_sbox.us00(text_in_r[7:0]);\n    assign us01 = aes_inv_sbox.us01(text_in_r[15:8]);\n    assign us02 = aes_inv_sbox.us02(text_in_r[23:16]);\n    assign us03 = aes_inv_sbox.us03(text_in_r[31:24]);\n    assign us10 = aes_inv_sbox.us10(text_in_r[39:32]);\n    assign us11 = aes_inv_sbox.us11(text_in_r[47:40]);\n    assign us12 = aes_inv_sbox.us12(text_in_r[55:48]);\n    assign us13 = aes_inv_sbox.us13(text_in_r[63:56]);\n    assign us20 = aes_inv_sbox.us20(text_in_r[71:64]);\n    assign us21 = aes_inv_sbox.us21(text_in_r[79:72]);\n    assign us22 = aes_inv_sbox.us22(text_in_r[87:80]);\n    assign us23 = aes_inv_sbox.us23(text_in_r[95:88]);\n    assign us30 = aes_inv_sbox.us30(text_in_r[103:96]);\n    assign us31 = aes_inv_sbox.us31(text_in_r[111:104]);\n    assign us32 = aes_inv_sbox.us32(text_in_r[119:112]);\n    assign us33 = aes_inv_sbox.us33(text_in_r[127:120]);\n\n    assign sub00 = aes_inv_sbox.sub00(us00);\n    assign sub01 = aes_inv_sbox.sub01(us01);\n    assign sub02 = aes_inv_sbox.sub02(us02);\n    assign sub03 = aes_inv_sbox.sub03(us03);\n    assign sub10 = aes_inv_sbox.sub10(us10);\n    assign sub11 = aes_inv_sbox.sub11(us11);\n    assign sub12 = aes_inv_sbox.sub12(us12);\n    assign sub13 = aes_inv_sbox.sub13(us13);\n    assign sub20 = aes_inv_sbox.sub20(us20);\n    assign sub21 = aes_inv_sbox.sub21(us21);\n    assign sub22 = aes_inv_sbox.sub22(us22);\n    assign sub23 = aes_inv_sbox.sub23(us23);\n    assign sub30 = aes_inv_sbox.sub30(us30);\n    assign sub31 = aes_inv_sbox.sub31(us31);\n    assign sub32 = aes_inv_sbox.sub32(us32);\n    assign sub33 = aes_inv_sbox.sub33(us33);\n\n    assign sa_ark[0][0] = sub00 ^ kb[dcnt][0];\n    assign sa_ark[0][1] = sub01 ^ kb[dcnt][1];\n    assign sa_ark[0][2] = sub02 ^ kb[dcnt][2];\n    assign sa_ark[0][3] = sub03 ^ kb[dcnt][3];\n    assign sa_ark[1][0] = sub10 ^ kb[dcnt][4];\n    assign sa_ark[1][1] = sub11 ^ kb[dcnt][5];\n    assign sa_ark[1][2] = sub12 ^ kb[dcnt][6];\n    assign sa_ark[1][3] = sub13 ^ kb[dcnt][7];\n    assign sa_ark[2][0] = sub20 ^ kb[dcnt][8];\n    assign sa_ark[2][1] = sub21 ^ kb[dcnt][9];\n    assign sa_ark[2][2] = sub22 ^ kb[dcnt][10];\n    assign sa_ark[2][3] = sub23 ^ kb[dcnt][11];\n    assign sa_ark[3][0] = sub30 ^ kb[dcnt][12];\n    assign sa_ark[3][1] = sub31 ^ kb[dcnt][13];\n    assign sa_ark[3][2] = sub32 ^ kb[dcnt][14];\n    assign sa_ark[3][3] = sub33 ^ kb[dcnt][15];\n\n    assign sa_next[0][0] = aes_inv_mix_columns(sa_ark[0][0], sa_ark[1][0], sa_ark[2][0], sa_ark[3][0]);\n    assign sa_next[0][1] = aes_inv_mix_columns(sa_ark[0][1], sa_ark[1][1], sa_ark[2][1], sa_ark[3][1]);\n    assign sa_next[0][2] = aes_inv_mix_columns(sa_ark[0][2], sa_ark[1][2], sa_ark[2][2], sa_ark[3][2]);\n    assign sa_next[0][3] = aes_inv_mix_columns(sa_ark[0][3], sa_ark[1][3], sa_ark[2][3], sa_ark[3][3]);\n    assign sa_next[1][0] = aes_inv_mix_columns(sa_ark[1][0], sa_ark[2][0], sa_ark[3][0], sa_ark[0][0]);\n    assign sa_next[1][1] = aes_inv_mix_columns(sa_ark[1][1], sa_ark[2][1], sa_ark[3][1], sa_ark[0][1]);\n    assign sa_next[1][2] = aes_inv_mix_columns(sa_ark[1][2], sa_ark[2][2], sa_ark[3][2], sa_ark[0][2]);\n    assign sa_next[1][3] = aes_inv_mix_columns(sa_ark[1][3], sa_ark[2][3], sa_ark[3][3], sa_ark[0][3]);\n    assign sa_next[2][0] = aes_inv_mix_columns(sa_ark[2][0], sa_ark[3][0], sa_ark[0][0], sa_ark[1][0]);\n    assign sa_next[2][1] = aes_inv_mix_columns(sa_ark[2][1], sa_ark[3][1], sa_ark[0][1], sa_ark[1][1]);\n    assign sa_next[2][2] = aes_inv_mix_columns(sa_ark[2][2], sa_ark[3][2], sa_ark[0][2], sa_ark[1][2]);\n    assign sa_next[2][3] = aes_inv_mix_columns(sa_ark[2][3], sa_ark[3][3], sa_ark[0][3], sa_ark[1][3]);\n    assign sa_next[3][0] = aes_inv_mix_columns(sa_ark[3][0], sa_ark[0][0], sa_ark[1][0], sa_ark[2][0]);\n    assign sa_next[3][1] = aes_inv_mix_columns(sa_ark[3][1], sa_ark[0][1], sa_ark[1][1], sa_ark[2][1]);\n    assign sa_next[3][2] = aes_inv_mix_columns(sa_ark[3][2], sa_ark[0][2], sa_ark[1][2], sa_ark[2][2]);\n    assign sa_next[3][3] = aes_inv_mix_columns(sa_ark[3][3], sa_ark[0][3], sa_ark[1][3], sa_ark[2][3]);\n\n    assign text_out_r = {sa_next[3][3], sa_next[3][2], sa_next[3][1], sa_next[3][0],\n                         sa_next[2][3], sa_next[2][2], sa_next[2][1], sa_next[2][0],\n                         sa_next[1][3], sa_next[1][2], sa_next[1][1], sa_next[1][0],\n                         sa_next[0][3], sa_next[0][2], sa_next[0][1], sa_next[0][0]};\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 10;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n            for (int i = 0; i < 16; i++) begin\n                sa[i][0] <= 0;\n                sa[i][1] <= 0;\n                sa[i][2] <= 0;\n                sa[i][3] <= 0;\n            end\n        end else if (kld) begin\n            aes_key_expand_128.key <= key;\n            kcnt <= 10;\n            ld_r <= 0;\n        end else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1;\n        end else if (ld_r) begin\n            ld_r <= 0;\n            dcnt <= 1;\n        end else if (dcnt < 11) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa_next[i][j];\n                end\n            end\n            dcnt <= dcnt + 1;\n        end else begin\n            done <= 1;\n        end\n    end\n\n    assign text_out = text_out_r;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 20, "code": "module aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w0, w1, w2, w3;\n    reg [31:0] rcon;\n    reg [7:0] sbox_out[255:0];\n    reg [7:0] reordered_bytes[3:0];\n    reg [7:0] temp_bytes[3:0];\n    reg [7:0] transformed_bytes[3:0];\n    reg [7:0] round_constant;\n\n    // S-box module\n    aes_sbox aes_sbox_0(\n        .a(reordered_bytes[0]),\n        .b(transformed_bytes[0])\n    );\n\n    aes_sbox aes_sbox_1(\n        .a(reordered_bytes[1]),\n        .b(transformed_bytes[1])\n    );\n\n    aes_sbox aes_sbox_2(\n        .a(reordered_bytes[2]),\n        .b(transformed_bytes[2])\n    );\n\n    aes_sbox aes_sbox_3(\n        .a(reordered_bytes[3]),\n        .b(transformed_bytes[3])\n    );\n\n    // Round constant generator\n    aes_rcon aes_rcon_0(\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    // Key loading\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            w0 <= {key[127:96], 8'b0};\n            w1 <= {key[95:64], 8'b0};\n            w2 <= {key[63:32], 8'b0};\n            w3 <= {key[31:0], 8'b0};\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n        end\n        else\n        begin\n            // Perform byte reordering and S-box transformation\n            reordered_bytes[0] = {w3[7:0], w2[7:0], w1[7:0], w0[7:0]};\n            reordered_bytes[1] = {w3[15:8], w2[15:8], w1[15:8], w0[15:8]};\n            reordered_bytes[2] = {w3[23:16], w2[23:16], w1[23:16], w0[23:16]};\n            reordered_bytes[3] = {w3[31:24], w2[31:24], w1[31:24], w0[31:24]};\n\n            for (int i = 0; i < 4; i++)\n            begin\n                temp_bytes[i] = reordered_bytes[i];\n                transformed_bytes[i] = sbox_out[temp_bytes[i]];\n            end\n\n            // XOR with round constant\n            for (int i = 0; i < 4; i++)\n            begin\n                transformed_bytes[i] = transformed_bytes[i] ^ rcon;\n            end\n\n            // New round key generation\n            w0 = w3 ^ transformed_bytes[0];\n            w1 = w3 ^ w2 ^ transformed_bytes[0] ^ transformed_bytes[1];\n            w2 = w3 ^ w1 ^ transformed_bytes[0] ^ transformed_bytes[1] ^ transformed_bytes[2];\n            w3 = w3 ^ w2 ^ w1 ^ transformed_bytes[0] ^ transformed_bytes[1] ^ transformed_bytes[2] ^ transformed_bytes[3];\n\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n        end\n    end\n\n    // S-box lookup table\n    initial\n    begin\n        for (int i = 0; i < 256; i++)\n        begin\n            case (i)\n                0: sbox_out[i] = 9;\n                1: sbox_out[i] = 14;\n                2: sbox_out[i] = 17;\n                3: sbox_out[i] = 22;\n                4: sbox_out[i] = 31;\n                5: sbox_out[i] = 25;\n                6: sbox_out[i] = 39;\n                7: sbox_out[i] = 56;\n                8: sbox_out[i] = 62;\n                9: sbox_out[i] = 30;\n                10: sbox_out[i] = 57;\n                11: sbox_out[i] = 26;\n                12: sbox_out[i] = 22;\n                13: sbox_out[i] = 37;\n                14: sbox_out[i] = 47;\n                15: sbox_out[i] = 29;\n                16: sbox_out[i] = 53;\n                17: sbox_out[i] = 54;\n                18: sbox_out[i] = 24;\n                19: sbox_out[i] = 50;\n                20: sbox_out[i] = 35;\n                21: sbox_out[i] = 41;\n                22: sbox_out[i] = 48;\n                23: sbox_out[i] = 43;\n                24: sbox_out[i] = 15;\n                25: sbox_out[i] = 61;\n                26: sbox_out[i] = 28;\n                27: sbox_out[i] = 63;\n                28: sbox_out[i] = 58;\n                29: sbox_out[i] = 27;\n                30: sbox_out[i] = 21;\n                31: sbox_out[i] = 55;\n                32: sbox_out[i] = 14;\n                33: sbox_out[i] = 50;\n                34: sbox_out[i] = 40;\n                35: sbox_out[i] = 25;\n                36: sbox_out[i] = 52;\n                37: sbox_out[i] = 38;\n                38: sbox_out[i] = 56;\n                39: sbox_out[i] = 60;\n                40: sbox_out[i] = 49;\n                41: sbox_out[i] = 24;\n                42: sbox_out[i] = 13;\n                43: sbox_out[i] = 32;\n                44: sbox_out[i] = 51;\n                45: sbox_out[i] = 26;\n                46: sbox_out[i] = 57;\n                47: sbox_out[i] = 42;\n                48: sbox_out[i] = 49;\n                49: sbox_out[i] = 35;\n                50: sbox_out[i] = 12;\n                51: sbox_out[i] = 29;\n                52: sbox_out[i] = 39;\n                53: sbox_out[i] = 48;\n                54: sbox_out[i] = 30;\n                55: sbox_out[i] = 19;\n                56: sbox_out[i] = 34;\n                57: sbox_out[i] = 53;\n                58: sbox_out[i] = 46;\n                59: sbox_out[i] = 38;\n                60: sbox_out[i] = 8;\n                61: sbox_out[i] = 48;\n                62: sbox_out[i] = 24;\n                63: sbox_out[i] = 32;\n                64: sbox_out[i] = 40;\n                65: sbox_out[i] = 2;\n                66: sbox_out[i] = 39;\n                67: sbox_out[i] = 22;\n                68: sbox_out[i] = 15;\n                69: sbox_out[i] = 44;\n                70: sbox_out[i] = 20;\n                71: sbox_out[i] = 27;\n                72: sbox_out[i] = 31;\n                73: sbox_out[i] = 10;\n                74: sbox_out[i] = 55;\n                75: sbox_out[i] = 33;\n                76: sbox_out[i] = 51;\n                77: sbox_out[i] = 26;\n                78: sbox_out[i] = 56;\n                79: sbox_out[i] = 52;\n                80: sbox_out[i] = 21;\n                81: sbox_out[i] = 50;\n                82: sbox_out[i] = 16;\n                83: sbox_out[i] = 57;\n                84: sbox_out[i] = 41;\n                85: sbox_out[i] = 18;\n                86: sbox_out[i] = 56;\n                87: sbox_out[i] = 62;\n                88: sbox_out[i] = 60;\n                89: sbox_out[i] = 58;\n                90: sbox_out[i] = 37;\n                91: sbox_out[i] = 17;\n                92: sbox_out[i] = 48;\n                93: sbox_out[i] = 43;\n                94: sbox_out[i] = 49;\n                95: sbox_out[i] = 1;\n                96: sbox_out[i] = 47;\n                97: sbox_out[i] = 29;\n                98: sbox_out[i] = 25;\n                99: sbox_out[i] = 36;\n                100: sbox_out[i] = 44;\n                101: sbox_out[i] = 27;\n                102: sbox_out[i] = 61;\n                103: sbox_out[i] = 16;\n                104: sbox_out[i] = 51;\n                105: sbox_out[i] = 30;\n                106: sbox_out[i] = 41;\n                107: sbox_out[i] = 46;\n                108: sbox_out[i] = 52;\n                109: sbox_out[i] = 28;\n                110: sbox_out[i] = 21;\n                111: sbox_out[i] = 59;\n                112: sbox_out[i] = 38;\n                113: sbox_out[i] = 55;\n                114: sbox_out[i] = 15;\n                115: sbox_out[i] = 58;\n                116: sbox_out[i] = 14;\n                117: sbox_out[i] = 57;\n                118: sbox_out[i] = 49;\n                119: sbox_out[i] = 39;\n                120: sbox_out[i] = 34;\n                121: sbox_out[i] = 11;\n                122: sbox_out[i] = 35;\n                123: sbox_out[i] = 50;\n                124: sbox_out[i] = 32;\n                125: sbox_out[i] = 48;\n                126: sbox_out[i] = 20;\n                127: sbox_out[i] = 42;\n                128: sbox_out[i] = 38;\n                129: sbox_out[i] = 26;\n                130: sbox_out[i] = 33;\n                131: sbox_out[i] = 49;\n                132: sbox_out[i] = 24;\n                133: sbox_out[i] = 22;\n                134: sbox_out[i] = 40;\n                135: sbox_out[i] = 2;\n                136: sbox_out[i] = 61;\n                137: sbox_out[i] = 16;\n                138: sbox_out[i] = 31;\n                139: sbox_out[i] = 18;\n                140: sbox_out[i] = 44;\n                141: sbox_out[i] = 10;\n                142: sbox_out[i] = 23;\n                143: sbox_out[i] = 59;\n                144: sbox_out[i] = 46;\n                145: sbox_out[i] = 52;\n                146: sbox_out[i] = 25;\n                147: sbox_out[i] = 58;\n                148: sbox_out[i] = 1;\n                149: sbox_out[i] = 43;\n                150: sbox_out[i] = 54;\n                151: sbox_out[i] = 53;\n                152: sbox_out[i] = 48;\n                153: sbox_out[i] = 55;\n                154: sbox_out[i] = 33;\n                155: sbox_out[i] = 50;\n                156: sbox_out[i] = 29;\n                157: sbox_out[i] = 39;\n                158: sbox_out[i] = 56;\n                159: sbox_out[i] = 49;\n                160: sbox_out[i] = 36;\n                161: sbox_out[i] = 24;\n                162: sbox_out[i] = 42;\n                163: sbox_out[i] = 30;\n                164: sbox_out[i] = 51;\n                165: sbox_out[i] = 8;\n                166: sbox_out[i] = 20;\n                167: sbox_out[i] = 47;\n                168: sbox_out[i] = 32;\n                169: sbox_out[i] = 19;\n                170: sbox_out[i] = 46;\n                171: sbox_out[i] = 27;\n                172: sbox_out[i] = 56;\n                173: sbox_out[i] = 23;\n                174: sbox_out[i] = 51;\n                175: sbox_out[i] = 38;\n                176: sbox_out[i] = 22;\n                177: sbox_out[i] = 58;\n                178: sbox_out[i] = 41;\n                179: sbox_out[i] = 18;\n                180: sbox_out[i] = 48;\n                181: sbox_out[i] = 44;\n                182: sbox_out[i] = 39;\n                183: sbox_out[i] = 37;\n                184: sbox_out[i] = 33;\n                185: sbox_out[i] = 50;\n                186: sbox_out[i] = 52;\n                187: sbox_out[i] = 31;\n                188: sbox_out[i] = 55;\n                189: sbox_out[i] = 26;\n                190: sbox_out[i] = 49;\n                191: sbox_out[i] = 34;\n                192: sbox_out[i] = 21;\n                193: sbox_out[i] = 25;\n                194: sbox_out[i] = 59;\n                195: sbox_out[i] = 35;\n                196: sbox_out[i] = 42;\n                197: sbox_out[i] = 11;\n                198: sbox_out[i] = 53;\n                199: sbox_out[i] = 46;\n                200: sbox_out[i] = 20;\n                201: sbox_out[i] = 28;\n                202: sbox_out[i] = 45;\n                203: sbox_out[i] = 32;\n                204: sbox_out[i] = 51;\n                205: sbox_out[i] = 14;\n                206: sbox_out[i] = 57;\n                207: sbox_out[i] = 36;\n                208: sbox_out[i] = 22;\n                209: sbox_out[i] = 49;\n                210: sbox_out[i] = 13;\n                211: sbox_out[i] = 58;\n                212: sbox_out[i] = 55;\n                213: sbox_out[i] = 52;\n                214: sbox_out[i] = 25;\n                215: sbox_out[i] = 48;\n                216: sbox_out[i] = 2;\n                217: sbox_out[i] = 29;\n                218: sbox_out[i] = 44;\n                219: sbox_out[i] = 38;\n                220: sbox_out[i] = 53;\n                221: sbox_out[i] = 24;\n                222: sbox_out[i] = 50;\n                223: sbox_out[i] = 31;\n                224: sbox_out[i] = 47;\n                225: sbox_out[i] = 56;\n                226: sbox_out[i] = 15;\n                227: sbox_out[i] = 42;\n                228: sbox_out[i] = 33;\n                229: sbox_out[i] = 11;\n                230: sbox_out[i] = 39;\n                231: sbox_out[i] = 34;\n                232: sbox_out[i] = 49;\n                233: sbox_out[i] = 18;\n                234: sbox_out[i] = 51;\n                235: sbox_out[i] = 26;\n                236: sbox_out[i] = 48;\n                237: sbox_out[i] = 20;\n                238: sbox_out[i] = 58;\n                239: sbox_out[i] = 22;\n                240: sbox_out[i] = 41;\n                241: sbox_out[i] = 37;\n                242: sbox_out[i] = 59;\n                243: sbox_out[i] = 30;\n                244: sbox_out[i] = 52;\n                245: sbox_out[i] = 45;\n                246: sbox_out[i] = 19;\n                247: sbox_out[i] = 44;\n                248: sbox_out[i] = 35;\n                249: sbox_out[i] = 21;\n                250: sbox_out[i] = 46;\n                251: sbox_out[i] = 54;\n                252: sbox_out[i] = 28;\n                253: sbox_out[i] = 50;\n                254: sbox_out[i] = 36;\n                255: sbox_out[i] = 23;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [31:0] counter = 1;\n    reg [31:0] rcon;\n\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            counter <= 1;\n            rcon <= 1;\n        end\n        else\n        begin\n            counter <= counter + 1;\n            case (counter)\n                1: rcon <= 1;\n                2: rcon <= 2;\n                3: rcon <= 4;\n                4: rcon <= 8;\n                5: rcon <= 16;\n                6: rcon <= 32;\n                7: rcon <= 64;\n                8: rcon <= 128;\n                9: rcon <= 127;\n                10: rcon <= 255;\n                11: rcon <= 128;\n                12: rcon <= 192;\n                13: rcon <= 224;\n                14: rcon <= 3;\n                15: rcon <= 9;\n                16: rcon <= 13;\n                17: rcon <= 10;\n                18: rcon <= 1;\n                19: rcon <= 14;\n                20: rcon <= 15;\n                21: rcon <= 8;\n                22: rcon <= 6;\n                23: rcon <= 4;\n                24: rcon <= 11;\n                25: rcon <= 2;\n                26: rcon <= 12;\n                27: rcon <= 16;\n                28: rcon <= 7;\n                29: rcon <= 5;\n                30: rcon <= 0;\n                default: rcon <= 0;\n            endcase\n            out <= rcon;\n        end\n    end\n\nendmodule\n\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox_out[255:0];\n\n    initial\n    begin\n        for (int i = 0; i < 256; i++)\n        begin\n            case (i)\n                0: sbox_out[i] = 9;\n                1: sbox_out[i] = 14;\n                2: sbox_out[i] = 17;\n                3: sbox_out[i] = 22;\n                4: sbox_out[i] = 31;\n                5: sbox_out[i] = 25;\n                6: sbox_out[i] = 39;\n                7: sbox_out[i] = 56;\n                8: sbox_out[i] = 62;\n                9: sbox_out[i] = 30;\n                10: sbox_out[i] = 57;\n                11: sbox_out[i] = 26;\n                12: sbox_out[i] = 22;\n                13: sbox_out[i] = 37;\n                14: sbox_out[i] = 47;\n                15: sbox_out[i] = 29;\n                16: sbox_out[i] = 53;\n                17: sbox_out[i] = 54;\n                18: sbox_out[i] = 24;\n                19: sbox_out[i] = 50;\n                20: sbox_out[i] = 35;\n                21: sbox_out[i] = 41;\n                22: sbox_out[i] = 48;\n                23: sbox_out[i] = 43;\n                24: sbox_out[i] = 15;\n                25: sbox_out[i] = 61;\n                26: sbox_out[i] = 28;\n                27: sbox_out[i] = 63;\n                28: sbox_out[i] = 58;\n                29: sbox_out[i] = 27;\n                30: sbox_out[i] = 21;\n                31: sbox_out[i] = 55;\n                32: sbox_out[i] = 14;\n                33: sbox_out[i] = 50;\n                34: sbox_out[i] = 40;\n                35: sbox_out[i] = 25;\n                36: sbox_out[i] = 52;\n                37: sbox_out[i] = 38;\n                38: sbox_out[i] = 56;\n                39: sbox_out[i] = 60;\n                40: sbox_out[i] = 49;\n                41: sbox_out[i] = 24;\n                42: sbox_out[i] = 13;\n                43: sbox_out[i] = 32;\n                44: sbox_out[i] = 51;\n                45: sbox_out[i] = 26;\n                46: sbox_out[i] = 57;\n                47: sbox_out[i] = 42;\n                48: sbox_out[i] = 49;\n                49: sbox_out[i] = 35;\n                50: sbox_out[i] = 12;\n                51: sbox_out[i] = 29;\n                52: sbox_out[i] = 39;\n                53: sbox_out[i] = 48;\n                54: sbox_out[i] = 30;\n                55: sbox_out[i] = 19;\n                56: sbox_out[i] = 34;\n                57: sbox_out[i] = 53;\n                58: sbox_out[i] = 46;\n                59: sbox_out[i] = 38;\n                60: sbox_out[i] = 8;\n                61: sbox_out[i] = 48;\n                62: sbox_out[i] = 24;\n                63: sbox_out[i] = 32;\n                64: sbox_out[i] = 40;\n                65: sbox_out[i] = 2;\n                66: sbox_out[i] = 39;\n                67: sbox_out[i] = 22;\n                68: sbox_out[i] = 15;\n                69: sbox_out[i] = 44;\n                70: sbox_out[i] = 20;\n                71: sbox_out[i] = 27;\n                72: sbox_out[i] = 31;\n                73: sbox_out[i] = 10;\n                74: sbox_out[i] = 55;\n                75: sbox_out[i] = 33;\n                76: sbox_out[i] = 51;\n                77: sbox_out[i] = 26;\n                78: sbox_out[i] = 56;\n                79: sbox_out[i] = 52;\n                80: sbox_out[i] = 21;\n                81: sbox_out[i] = 50;\n                82: sbox_out[i] = 16;\n                83: sbox_out[i] = 57;\n                84: sbox_out[i] = 41;\n                85: sbox_out[i] = 18;\n                86: sbox_out[i] = 56;\n                87: sbox_out[i] = 62;\n                88: sbox_out[i] = 60;\n                89: sbox_out[i] = 58;\n                90: sbox_out[i] = 37;\n                91: sbox_out[i] = 17;\n                92: sbox_out[i] = 48;\n                93: sbox_out[i] = 43;\n                94: sbox_out[i] = 49;\n                95: sbox_out[i] = 1;\n                96: sbox_out[i] = 47;\n                97: sbox_out[i] = 29;\n                98: sbox_out[i] = 25;\n                99: sbox_out[i] = 36;\n                100: sbox_out[i] = 44;\n                101: sbox_out[i] = 27;\n                102: sbox_out[i] = 61;\n                103: sbox_out[i] = 16;\n                104: sbox_out[i] = 51;\n                105: sbox_out[i] = 30;\n                106: sbox_out[i] = 41;\n                107: sbox_out[i] = 46;\n                108: sbox_out[i] = 52;\n                109: sbox_out[i] = 28;\n                110: sbox_out[i] = 21;\n                111: sbox_out[i] = 59;\n                112: sbox_out[i] = 38;\n                113: sbox_out[i] = 55;\n                114: sbox_out[i] = 15;\n                115: sbox_out[i] = 58;\n                116: sbox_out[i] = 14;\n                117: sbox_out[i] = 57;\n                118: sbox_out[i] = 49;\n                119: sbox_out[i] = 39;\n                120: sbox_out[i] = 34;\n                121: sbox_out[i] = 11;\n                122: sbox_out[i] = 35;\n                123: sbox_out[i] = 50;\n                124: sbox_out[i] = 32;\n                125: sbox_out[i] = 48;\n                126: sbox_out[i] = 20;\n                127: sbox_out[i] = 42;\n                128: sbox_out[i] = 38;\n                129: sbox_out[i] = 26;\n                130: sbox_out[i] = 33;\n                131: sbox_out[i] = 49;\n                132: sbox_out[i] = 24;\n                133: sbox_out[i] = 22;\n                134: sbox_out[i] = 40;\n                135: sbox_out[i] = 2;\n                136: sbox_out[i] = 61;\n                137: sbox_out[i] = 16;\n                138: sbox_out[i] = 31;\n                139: sbox_out[i] = 18;\n                140: sbox_out[i] = 44;\n                141: sbox_out[i] = 10;\n                142: sbox_out[i] = 23;\n                143: sbox_out[i] = 59;\n                144: sbox_out[i] = 46;\n                145: sbox_out[i] = 52;\n                146: sbox_out[i] = 25;\n                147: sbox_out[i] = 58;\n                148: sbox_out[i] = 1;\n                149: sbox_out[i] = 43;\n                150: sbox_out[i] = 54;\n                151: sbox_out[i] = 53;\n                152: sbox_out[i] = 48;\n                153: sbox_out[i] = 55;\n                154: sbox_out[i] = 33;\n                155: sbox_out[i] = 50;\n                156: sbox_out[i] = 29;\n                157: sbox_out[i] = 39;\n                158: sbox_out[i] = 56;\n                159: sbox_out[i] = 49;\n                160: sbox_out[i] = 36;\n                161: sbox_out[i] = 24;\n                162: sbox_out[i] = 42;\n                163: sbox_out[i] = 30;\n                164: sbox_out[i] = 51;\n                165: sbox_out[i] = 8;\n                166: sbox_out[i] = 20;\n                167: sbox_out[i] = 47;\n                168: sbox_out[i] = 32;\n                169: sbox_out[i] = 19;\n                170: sbox_out[i] = 46;\n                171: sbox_out[i] = 27;\n                172: sbox_out[i] = 56;\n                173: sbox_out[i] = 23;\n                174: sbox_out[i] = 51;\n                175: sbox_out[i] = 38;\n                176: sbox_out[i] = 22;\n                177: sbox_out[i] = 58;\n                178: sbox_out[i] = 41;\n                179: sbox_out[i] = 18;\n                180: sbox_out[i] = 48;\n                181: sbox_out[i] = 44;\n                182: sbox_out[i] = 39;\n                183: sbox_out[i] = 37;\n                184: sbox_out[i] = 33;\n                185: sbox_out[i] = 50;\n                186: sbox_out[i] = 52;\n                187: sbox_out[i] = 31;\n                188: sbox_out[i] = 55;\n                189: sbox_out[i] = 26;\n                190: sbox_out[i] = 49;\n                191: sbox_out[i] = 34;\n                192: sbox_out[i] = 21;\n                193: sbox_out[i] = 25;\n                194: sbox_out[i] = 59;\n                195: sbox_out[i] = 35;\n                196: sbox_out[i] = 42;\n                197: sbox_out[i] = 11;\n                198: sbox_out[i] = 53;\n                199: sbox_out[i] = 46;\n                200: sbox_out[i] = 20;\n                201: sbox_out[i] = 28;\n                202: sbox_out[i] = 45;\n                203: sbox_out[i] = 32;\n                204: sbox_out[i] = 51;\n                205: sbox_out[i] = 14;\n                206: sbox_out[i] = 57;\n                207: sbox_out[i] = 36;\n                208: sbox_out[i] = 22;\n                209: sbox_out[i] = 49;\n                210: sbox_out[i] = 13;\n                211: sbox_out[i] = 58;\n                212: sbox_out[i] = 55;\n                213: sbox_out[i] = 52;\n                214: sbox_out[i] = 25;\n                215: sbox_out[i] = 48;\n                216: sbox_out[i] = 2;\n                217: sbox_out[i] = 29;\n                218: sbox_out[i] = 44;\n                219: sbox_out[i] = 38;\n                220: sbox_out[i] = 53;\n                221: sbox_out[i] = 24;\n                222: sbox_out[i] = 50;\n                223: sbox_out[i] = 31;\n                224: sbox_out[i] = 47;\n                225: sbox_out[i] = 56;\n                226: sbox_out[i] = 15;\n                227: sbox_out[i] = 42;\n                228: sbox_out[i] = 33;\n                229: sbox_out[i] = 11;\n                230: sbox_out[i] = 39;\n                231: sbox_out[i] = 34;\n                232: sbox_out[i] = 49;\n                233: sbox_out[i] = 18;\n                234: sbox_out[i] = 51;\n                235: sbox_out[i] = 26;\n                236: sbox_out[i] = 48;\n                237: sbox_out[i] = 20;\n                238: sbox_out[i] = 58;\n                239: sbox_out[i] = 22;\n                240: sbox_out[i] = 41;\n                241: sbox_out[i] = 37;\n                242: sbox_out[i] = 59;\n                243: sbox_out[i] = 30;\n                244: sbox_out[i] = 52;\n                245: sbox_out[i] = 45;\n                246: sbox_out[i] = 19;\n                247: sbox_out[i] = 44;\n                248: sbox_out[i] = 35;\n                249: sbox_out[i] = 21;\n                250: sbox_out[i] = 46;\n                251: sbox_out[i] = 54;\n                252: sbox_out[i] = 28;\n                253: sbox_out[i] = 50;\n                254: sbox_out[i] = 36;\n                255: sbox_out[i] = 23;\n            endcase\n        end\n    end\n\n    assign b = sbox_out[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 20, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n            text_out <= 0;\n        end else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1;\n        end else if (ld_r) begin\n            ld_r <= 0;\n            sa <= text_in_r;\n            dcnt <= 0xB;\n        end else if (dcnt == 0) begin\n            text_out <= text_in_r ^ key[127:80];\n            dcnt <= dcnt + 1;\n        end else if (dcnt < 10) begin\n            text_out <= aes_sbox(sa[0][0]) ^ aes_sbox(sa[0][1]) ^ aes_sbox(sa[0][2]) ^ aes_sbox(sa[0][3]) ^\n                        aes_sbox(sa[1][0]) ^ aes_sbox(sa[1][1]) ^ aes_sbox(sa[1][2]) ^ aes_sbox(sa[1][3]) ^\n                        aes_sbox(sa[2][0]) ^ aes_sbox(sa[2][1]) ^ aes_sbox(sa[2][2]) ^ aes_sbox(sa[2][3]) ^\n                        aes_sbox(sa[3][0]) ^ aes_sbox(sa[3][1]) ^ aes_sbox(sa[3][2]) ^ aes_sbox(sa[3][3]) ^\n                        key[79:32];\n            sa[0][0] <= aes_sbox(sa[0][0]);\n            sa[0][1] <= aes_sbox(sa[0][1]);\n            sa[0][2] <= aes_sbox(sa[0][2]);\n            sa[0][3] <= aes_sbox(sa[0][3]);\n            sa[1][0] <= aes_sbox(sa[1][0]);\n            sa[1][1] <= aes_sbox(sa[1][1]);\n            sa[1][2] <= aes_sbox(sa[1][2]);\n            sa[1][3] <= aes_sbox(sa[1][3]);\n            sa[2][0] <= aes_sbox(sa[2][0]);\n            sa[2][1] <= aes_sbox(sa[2][1]);\n            sa[2][2] <= aes_sbox(sa[2][2]);\n            sa[2][3] <= aes_sbox(sa[2][3]);\n            sa[3][0] <= aes_sbox(sa[3][0]);\n            sa[3][1] <= aes_sbox(sa[3][1]);\n            sa[3][2] <= aes_sbox(sa[3][2]);\n            sa[3][3] <= aes_sbox(sa[3][3]);\n            dcnt <= dcnt + 1;\n        end else begin\n            text_out <= aes_sbox(sa[0][0]) ^ aes_sbox(sa[0][1]) ^ aes_sbox(sa[0][2]) ^ aes_sbox(sa[0][3]) ^\n                        aes_sbox(sa[1][0]) ^ aes_sbox(sa[1][1]) ^ aes_sbox(sa[1][2]) ^ aes_sbox(sa[1][3]) ^\n                        aes_sbox(sa[2][0]) ^ aes_sbox(sa[2][1]) ^ aes_sbox(sa[2][2]) ^ aes_sbox(sa[2][3]) ^\n                        aes_sbox(sa[3][0]) ^ aes_sbox(sa[3][1]) ^ aes_sbox(sa[3][2]) ^ aes_sbox(sa[3][3]) ^\n                        key[31:0];\n            done <= 1;\n        end\n    end\n\n    assign text_out = {text_out[31:0], text_out[63:32], text_out[95:64], text_out[127:96]};\n\nendmodule\n\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    always @(*) begin\n        case (a)\n            8'h01: b = 8'h63;\n            8'h02: b = 8'h7c;\n            8'h03: b = 8'h77;\n            8'h04: b = 8'h7b;\n            8'h05: b = 8'hf2;\n            8'h06: b = 8'h6f;\n            8'h07: b = 8'hc6;\n            8'h08: b = 8'h9f;\n            8'h09: b = 8'h89;\n            8'h0a: b = 8'h0d;\n            8'h0b: b = 8'h09;\n            8'h0c: b = 8'h93;\n            8'h0d: b = 8'h4d;\n            8'h0e: b = 8'hac;\n            8'h0f: b = 8'h42;\n            8'h10: b = 8'hfa;\n            8'h11: b = 8'h3a;\n            8'h12: b = 8'h0c;\n            8'h13: b = 8'h4e;\n            8'h14: b = 8'h35;\n            8'h15: b = 8'h41;\n            8'h16: b = 8'h5a;\n            8'h17: b = 8'h5a;\n            8'h18: b = 8'h5a;\n            8'h19: b = 8'h5a;\n            8'h1a: b = 8'h5a;\n            8'h1b: b = 8'h5a;\n            8'h1c: b = 8'h5a;\n            8'h1d: b = 8'h5a;\n            8'h1e: b = 8'h5a;\n            8'h1f: b = 8'h5a;\n            8'h20: b = 8'h5a;\n            8'h21: b = 8'h5a;\n            8'h22: b = 8'h5a;\n            8'h23: b = 8'h5a;\n            8'h24: b = 8'h5a;\n            8'h25: b = 8'h5a;\n            8'h26: b = 8'h5a;\n            8'h27: b = 8'h5a;\n            8'h28: b = 8'h5a;\n            8'h29: b = 8'h5a;\n            8'h2a: b = 8'h5a;\n            8'h2b: b = 8'h5a;\n            8'h2c: b = 8'h5a;\n            8'h2d: b = 8'h5a;\n            8'h2e: b = 8'h5a;\n            8'h2f: b = 8'h5a;\n            8'h30: b = 8'h5a;\n            8'h31: b = 8'h5a;\n            8'h32: b = 8'h5a;\n            8'h33: b = 8'h5a;\n            8'h34: b = 8'h5a;\n            8'h35: b = 8'h5a;\n            8'h36: b = 8'h5a;\n            8'h37: b = 8'h5a;\n            8'h38: b = 8'h5a;\n            8'h39: b = 8'h5a;\n            8'h3a: b = 8'h5a;\n            8'h3b: b = 8'h5a;\n            8'h3c: b = 8'h5a;\n            8'h3d: b = 8'h5a;\n            8'h3e: b = 8'h5a;\n            8'h3f: b = 8'h5a;\n            8'h40: b = 8'h5a;\n            8'h41: b = 8'h5a;\n            8'h42: b = 8'h5a;\n            8'h43: b = 8'h5a;\n            8'h44: b = 8'h5a;\n            8'h45: b = 8'h5a;\n            8'h46: b = 8'h5a;\n            8'h47: b = 8'h5a;\n            8'h48: b = 8'h5a;\n            8'h49: b = 8'h5a;\n            8'h4a: b = 8'h5a;\n            8'h4b: b = 8'h5a;\n            8'h4c: b = 8'h5a;\n            8'h4d: b = 8'h5a;\n            8'h4e: b = 8'h5a;\n            8'h4f: b = 8'h5a;\n            8'h50: b = 8'h5a;\n            8'h51: b = 8'h5a;\n            8'h52: b = 8'h5a;\n            8'h53: b = 8'h5a;\n            8'h54: b = 8'h5a;\n            8'h55: b = 8'h5a;\n            8'h56: b = 8'h5a;\n            8'h57: b = 8'h5a;\n            8'h58: b = 8'h5a;\n            8'h59: b = 8'h5a;\n            8'h5a: b = 8'h5a;\n            8'h5b: b = 8'h5a;\n            8'h5c: b = 8'h5a;\n            8'h5d: b = 8'h5a;\n            8'h5e: b = 8'h5a;\n            8'h5f: b = 8'h5a;\n            8'h60: b = 8'h5a;\n            8'h61: b = 8'h5a;\n            8'h62: b = 8'h5a;\n            8'h63: b = 8'h5a;\n            8'h64: b = 8'h5a;\n            8'h65: b = 8'h5a;\n            8'h66: b = 8'h5a;\n            8'h67: b = 8'h5a;\n            8'h68: b = 8'h5a;\n            8'h69: b = 8'h5a;\n            8'h6a: b = 8'h5a;\n            8'h6b: b = 8'h5a;\n            8'h6c: b = 8'h5a;\n            8'h6d: b = 8'h5a;\n            8'h6e: b = 8'h5a;\n            8'h6f: b = 8'h5a;\n            8'h70: b = 8'h5a;\n            8'h71: b = 8'h5a;\n            8'h72: b = 8'h5a;\n            8'h73: b = 8'h5a;\n            8'h74: b = 8'h5a;\n            8'h75: b = 8'h5a;\n            8'h76: b = 8'h5a;\n            8'h77: b = 8'h5a;\n            8'h78: b = 8'h5a;\n            8'h79: b = 8'h5a;\n            8'h7a: b = 8'h5a;\n            8'h7b: b = 8'h5a;\n            8'h7c: b = 8'h5a;\n            8'h7d: b = 8'h5a;\n            8'h7e: b = 8'h5a;\n            8'h7f: b = 8'h5a;\n            8'h80: b = 8'h5a;\n            8'h81: b = 8'h5a;\n            8'h82: b = 8'h5a;\n            8'h83: b = 8'h5a;\n            8'h84: b = 8'h5a;\n            8'h85: b = 8'h5a;\n            8'h86: b = 8'h5a;\n            8'h87: b = 8'h5a;\n            8'h88: b = 8'h5a;\n            8'h89: b = 8'h5a;\n            8'h8a: b = 8'h5a;\n            8'h8b: b = 8'h5a;\n            8'h8c: b = 8'h5a;\n            8'h8d: b = 8'h5a;\n            8'h8e: b = 8'h5a;\n            8'h8f: b = 8'h5a;\n            8'h90: b = 8'h5a;\n            8'h91: b = 8'h5a;\n            8'h92: b = 8'h5a;\n            8'h93: b = 8'h5a;\n            8'h94: b = 8'h5a;\n            8'h95: b = 8'h5a;\n            8'h96: b = 8'h5a;\n            8'h97: b = 8'h5a;\n            8'h98: b = 8'h5a;\n            8'h99: b = 8'h5a;\n            8'h9a: b = 8'h5a;\n            8'h9b: b = 8'h5a;\n            8'h9c: b = 8'h5a;\n            8'h9d: b = 8'h5a;\n            8'h9e: b = 8'h5a;\n            8'h9f: b = 8'h5a;\n            8'ha0: b = 8'h5a;\n            8'ha1: b = 8'h5a;\n            8'ha2: b = 8'h5a;\n            8'ha3: b = 8'h5a;\n            8'ha4: b = 8'h5a;\n            8'ha5: b = 8'h5a;\n            8'ha6: b = 8'h5a;\n            8'ha7: b = 8'h5a;\n            8'ha8: b = 8'h5a;\n            8'ha9: b = 8'h5a;\n            8'haa: b = 8'h5a;\n            8'hab: b = 8'h5a;\n            8'hac: b = 8'h5a;\n            8'had: b = 8'h5a;\n            8'hae: b = 8'h5a;\n            8'haf: b = 8'h5a;\n            8'hb0: b = 8'h5a;\n            8'hb1: b = 8'h5a;\n            8'hb2: b = 8'h5a;\n            8'hb3: b = 8'h5a;\n            8'hb4: b = 8'h5a;\n            8'hb5: b = 8'h5a;\n            8'hb6: b = 8'h5a;\n            8'hb7: b = 8'h5a;\n            8'hb8: b = 8'h5a;\n            8'hb9: b = 8'h5a;\n            8'hba: b = 8'h5a;\n            8'hbb: b = 8'h5a;\n            8'hbc: b = 8'h5a;\n            8'hbd: b = 8'h5a;\n            8'hbe: b = 8'h5a;\n            8'hbf: b = 8'h5a;\n            8'hc0: b = 8'h5a;\n            8'hc1: b = 8'h5a;\n            8'hc2: b = 8'h5a;\n            8'hc3: b = 8'h5a;\n            8'hc4: b = 8'h5a;\n            8'hc5: b = 8'h5a;\n            8'hc6: b = 8'h5a;\n            8'hc7: b = 8'h5a;\n            8'hc8: b = 8'h5a;\n            8'hc9: b = 8'h5a;\n            8'hca: b = 8'h5a;\n            8'hcb: b = 8'h5a;\n            8'hcc: b = 8'h5a;\n            8'hcd: b = 8'h5a;\n            8'hce: b = 8'h5a;\n            8'hcf: b = 8'h5a;\n            8'hd0: b = 8'h5a;\n            8'hd1: b = 8'h5a;\n            8'hd2: b = 8'h5a;\n            8'hd3: b = 8'h5a;\n            8'hd4: b = 8'h5a;\n            8'hd5: b = 8'h5a;\n            8'hd6: b = 8'h5a;\n            8'hd7: b = 8'h5a;\n            8'hd8: b = 8'h5a;\n            8'hd9: b = 8'h5a;\n            8'hda: b = 8'h5a;\n            8'hdb: b = 8'h5a;\n            8'hdc: b = 8'h5a;\n            8'hdd: b = 8'h5a;\n            8'hde: b = 8'h5a;\n            8'hdf: b = 8'h5a;\n            8'he0: b = 8'h5a;\n            8'he1: b = 8'h5a;\n            8'he2: b = 8'h5a;\n            8'he3: b = 8'h5a;\n            8'he4: b = 8'h5a;\n            8'he5: b = 8'h5a;\n            8'he6: b = 8'h5a;\n            8'he7: b = 8'h5a;\n            8'he8: b = 8'h5a;\n            8'he9: b = 8'h5a;\n            8'hea: b = 8'h5a;\n            8'heb: b = 8'h5a;\n            8'hec: b = 8'h5a;\n            8'hed: b = 8'h5a;\n            8'hee: b = 8'h5a;\n            8'hef: b = 8'h5a;\n            8'hf0: b = 8'h5a;\n            8'hf1: b = 8'h5a;\n            8'hf2: b = 8'h5a;\n            8'hf3: b = 8'h5a;\n            8'hf4: b = 8'h5a;\n            8'hf5: b = 8'h5a;\n            8'hf6: b = 8'h5a;\n            8'hf7: b = 8'h5a;\n            8'hf8: b = 8'h5a;\n            8'hf9: b = 8'h5a;\n            8'hfa: b = 8'h5a;\n            8'hfb: b = 8'h5a;\n            8'hfc: b = 8'h5a;\n            8'hfd: b = 8'h5a;\n            8'hfe: b = 8'h5a;\n            8'hff: b = 8'h5a;\n            default: b = 8'h5a;\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 20, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox aes_inv_sbox_00(\n        .a(sa[0][0]),\n        .b(us00)\n    );\n    aes_inv_sbox aes_inv_sbox_01(\n        .a(sa[0][1]),\n        .b(us01)\n    );\n    aes_inv_sbox aes_inv_sbox_02(\n        .a(sa[0][2]),\n        .b(us02)\n    );\n    aes_inv_sbox aes_inv_sbox_03(\n        .a(sa[0][3]),\n        .b(us03)\n    );\n    aes_inv_sbox aes_inv_sbox_10(\n        .a(sa[1][0]),\n        .b(us10)\n    );\n    aes_inv_sbox aes_inv_sbox_11(\n        .a(sa[1][1]),\n        .b(us11)\n    );\n    aes_inv_sbox aes_inv_sbox_12(\n        .a(sa[1][2]),\n        .b(us12)\n    );\n    aes_inv_sbox aes_inv_sbox_13(\n        .a(sa[1][3]),\n        .b(us13)\n    );\n    aes_inv_sbox aes_inv_sbox_20(\n        .a(sa[2][0]),\n        .b(us20)\n    );\n    aes_inv_sbox aes_inv_sbox_21(\n        .a(sa[2][1]),\n        .b(us21)\n    );\n    aes_inv_sbox aes_inv_sbox_22(\n        .a(sa[2][2]),\n        .b(us22)\n    );\n    aes_inv_sbox aes_inv_sbox_23(\n        .a(sa[2][3]),\n        .b(us23)\n    );\n    aes_inv_sbox aes_inv_sbox_30(\n        .a(sa[3][0]),\n        .b(us30)\n    );\n    aes_inv_sbox aes_inv_sbox_31(\n        .a(sa[3][1]),\n        .b(us31)\n    );\n    aes_inv_sbox aes_inv_sbox_32(\n        .a(sa[3][2]),\n        .b(us32)\n    );\n    aes_inv_sbox aes_inv_sbox_33(\n        .a(sa[3][3]),\n        .b(us33)\n    );\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 4'b0;\n            kcnt <= 4'b10;\n            ld_r <= 1'b0;\n            text_in_r <= 128'b0;\n            text_out_r <= 128'b0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 8'b0;\n                end\n            end\n        end\n        else if (kld) begin\n            if (kcnt == 10) begin\n                kcnt <= 4'b0;\n                kb[10] <= wk3;\n                kb[9] <= wk2;\n                kb[8] <= wk1;\n                kb[7] <= wk0;\n            end\n            else begin\n                kcnt <= kcnt + 1;\n            end\n        end\n        else if (ld) begin\n            ld_r <= 1'b1;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n            text_in_r <= text_in;\n            dcnt <= 4'b1;\n            ld_r <= 1'b0;\n        end\n        else begin\n            if (dcnt == 11) begin\n                done <= 1'b1;\n            end\n            else begin\n                done <= 1'b0;\n            end\n            if (ld_r) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j + 1];\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    sa[3][i] <= sa[0][i];\n                end\n                if (dcnt == 1) begin\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ kb[dcnt];\n                        end\n                    end\n                end\n                else begin\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ kb[dcnt];\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us00;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us01;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us02;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us03;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us10;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us11;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us12;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us13;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us20;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us21;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us22;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us23;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us30;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us31;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us32;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ us33;\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ pmul_e(sa[i][j]);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ pmul_b(sa[i][j]);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ pmul_d(sa[i][j]);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ pmul_9(sa[i][j]);\n                        end\n                    end\n                end\n                dcnt <= dcnt + 1;\n            end\n        end\n    end\n\n    // Output Generation\n    always @(posedge clk) begin\n        if (ld_r) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out_r[8*i + j] <= sa[i][j];\n                end\n            end\n        end\n        else begin\n            text_out <= text_out_r;\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            if (kcnt == 10) begin\n                kcnt <= 4'b0;\n                kb[10] <= key[31:0];\n                kb[9] <= key[63:32];\n                kb[8] <= key[95:64];\n                kb[7] <= key[127:96];\n            end\n            else begin\n                kcnt <= kcnt + 1;\n            end\n        end\n        else begin\n            if (kcnt == 0) begin\n                wo_0 <= kb[10];\n                wo_1 <= kb[9];\n                wo_2 <= kb[8];\n                wo_3 <= kb[7];\n            end\n        end\n    end\n\nendmodule\n\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // Inverse S-box implementation\n    always_comb begin\n        case(a)\n            8'h01: b = 8'h0E;\n            8'h02: b = 8'h09;\n            8'h03: b = 8'h0D;\n            8'h04: b = 8'h0B;\n            8'h05: b = 8'h0F;\n            8'h06: b = 8'h0E;\n            8'h07: b = 8'h0C;\n            8'h08: b = 8'h1B;\n            8'h09: b = 8'h2F;\n            8'h0A: b = 8'h23;\n            8'h0B: b = 8'h26;\n            8'h0C: b = 8'h16;\n            8'h0D: b = 8'h0D;\n            8'h0E: b = 8'h19;\n            8'h0F: b = 8'h1B;\n            8'h10: b = 8'h10;\n            8'h11: b = 8'h15;\n            8'h12: b = 8'h12;\n            8'h13: b = 8'h8F;\n            8'h14: b = 8'h91;\n            8'h15: b = 8'h06;\n            8'h16: b = 8'hC1;\n            8'h17: b = 8'h84;\n            8'h18: b = 8'h69;\n            8'h19: b = 8'hE9;\n            8'h1A: b = 8'h2F;\n            8'h1B: b = 8'h65;\n            8'h1C: b = 8'h7A;\n            8'h1D: b = 8'hAE;\n            8'h1E: b = 8'h08;\n            8'h1F: b = 8'hCB;\n            8'h20: b = 8'hBE;\n            8'h21: b = 8'h4B;\n            8'h22: b = 8'hDC;\n            8'h23: b = 8'hFE;\n            8'h24: b = 8'h7F;\n            8'h25: b = 8'h49;\n            8'h26: b = 8'h6B;\n            8'h27: b = 8'h3F;\n            8'h28: b = 8'h31;\n            8'h29: b = 8'h36;\n            8'h2A: b = 8'h41;\n            8'h2B: b = 8'h4D;\n            8'h2C: b = 8'h53;\n            8'h2D: b = 8'h55;\n            8'h2E: b = 8'h2A;\n            8'h2F: b = 8'h2F;\n            8'h30: b = 8'h45;\n            8'h31: b = 8'h02;\n            8'h32: b = 8'h7C;\n            8'h33: b = 8'h07;\n            8'h34: b = 8'h18;\n            8'h35: b = 8'h33;\n            8'h36: b = 8'h5A;\n            8'h37: b = 8'h41;\n            8'h38: b = 8'h27;\n            8'h39: b = 8'h7C;\n            8'h3A: b = 8'h5E;\n            8'h3B: b = 8'h37;\n            8'h3C: b = 8'h3D;\n            8'h3D: b = 8'h4D;\n            8'h3E: b = 8'h50;\n            8'h3F: b = 8'h3C;\n            8'h40: b = 8'h9F;\n            8'h41: b = 8'hA1;\n            8'h42: b = 8'hA3;\n            8'h43: b = 8'h9C;\n            8'h44: b = 8'hA2;\n            8'h45: b = 8'hB7;\n            8'h46: b = 8'hED;\n            8'h47: b = 8'h79;\n            8'h48: b = 8'h5B;\n            8'h49: b = 8'hF8;\n            8'h4A: b = 8'h63;\n            8'h4B: b = 8'h6F;\n            8'h4C: b = 8'h75;\n            8'h4D: b = 8'h8A;\n            8'h4E: b = 8'h9C;\n            8'h4F: b = 8'h82;\n            8'h50: b = 8'h99;\n            8'h51: b = 8'hE4;\n            8'h52: b = 8'h65;\n            8'h53: b = 8'h4E;\n            8'h54: b = 8'hB6;\n            8'h55: b = 8'hD5;\n            8'h56: b = 8'h66;\n            8'h57: b = 8'h48;\n            8'h58: b = 8'hD4;\n            8'h59: b = 8'hC3;\n            8'h5A: b = 8'h42;\n            8'h5B: b = 8'hF0;\n            8'h5C: b = 8'hC1;\n            8'h5D: b = 8'hAF;\n            8'h5E: b = 8'hBD;\n            8'h5F: b = 8'h3B;\n            8'h60: b = 8'h26;\n            8'h61: b = 8'hB3;\n            8'h62: b = 8'hBB;\n            8'h63: b = 8'h4A;\n            8'h64: b = 8'h6C;\n            8'h65: b = 8'h78;\n            8'h66: b = 8'h5E;\n            8'h67: b = 8'h6A;\n            8'h68: b = 8'h0E;\n            8'h69: b = 8'h67;\n            8'h6A: b = 8'h0D;\n            8'h6B: b = 8'hFE;\n            8'h6C: b = 8'hB3;\n            8'h6D: b = 8'h73;\n            8'h6E: b = 8'h2D;\n            8'h6F: b = 8'h36;\n            8'h70: b = 8'hC2;\n            8'h71: b = 8'h9A;\n            8'h72: b = 8'h29;\n            8'h73: b = 8'hB0;\n            8'h74: b = 8'hEC;\n            8'h75: b = 8'h62;\n            8'h76: b = 8'hDE;\n            8'h77: b = 8'h68;\n            8'h78: b = 8'h05;\n            8'h79: b = 8'h33;\n            8'h7A: b = 8'h3C;\n            8'h7B: b = 8'h82;\n            8'h7C: b = 8'hC9;\n            8'h7D: b = 8'h7D;\n            8'h7E: b = 8'h1A;\n            8'h7F: b = 8'hF7;\n            8'h80: b = 8'h2C;\n            8'h81: b = 8'hB7;\n            8'h82: b = 8'h06;\n            8'h83: b = 8'h40;\n            8'h84: b = 8'h5A;\n            8'h85: b = 8'hF4;\n            8'h86: b = 8'h62;\n            8'h87: b = 8'hEF;\n            8'h88: b = 8'h23;\n            8'h89: b = 8'h93;\n            8'h8A: b = 8'h09;\n            8'h8B: b = 8'h19;\n            8'h8C: b = 8'hAB;\n            8'h8D: b = 8'h4B;\n            8'h8E: b = 8'hB2;\n            8'h8F: b = 8'hC6;\n            8'h90: b = 8'hE7;\n            8'h91: b = 8'h45;\n            8'h92: b = 8'h6D;\n            8'h93: b = 8'hA8;\n            8'h94: b = 8'hFF;\n            8'h95: b = 8'hE1;\n            8'h96: b = 8'h4D;\n            8'h97: b = 8'hB5;\n            8'h98: b = 8'h4C;\n            8'h99: b = 8'h5D;\n            8'h9A: b = 8'h00;\n            8'h9B: b = 8'hF9;\n            8'h9C: b = 8'h2F;\n            8'h9D: b = 8'hE5;\n            8'h9E: b = 8'h15;\n            8'h9F: b = 8'h6E;\n            8'hA0: b = 8'hC3;\n            8'hA1: b = 8'h41;\n            8'hA2: b = 8'hA7;\n            8'hA3: b = 8'hE2;\n            8'hA4: b = 8'h66;\n            8'hA5: b = 8'hCD;\n            8'hA6: b = 8'h0B;\n            8'hA7: b = 8'h2A;\n            8'hA8: b = 8'hF3;\n            8'hA9: b = 8'hC8;\n            8'hAA: b = 8'hD8;\n            8'hAB: b = 8'hT9;\n            8'hAC: b = 8'hB1;\n            8'hAD: b = 8'h6F;\n            8'hAE: b = 8'h5A;\n            8'hAF: b = 8'hE8;\n            8'hB0: b = 8'hCB;\n            8'hB1: b = 8'hEA;\n            8'hB2: b = 8'h3D;\n            8'hB3: b = 8'h0C;\n            8'hB4: b = 8'h13;\n            8'hB5: b = 8'h9F;\n            8'hB6: b = 8'h4F;\n            8'hB7: b = 8'h8D;\n            8'hB8: b = 8'hBD;\n            8'hB9: b = 8'h61;\n            8'hBA: b = 8'hC2;\n            8'hBB: b = 8'hE6;\n            8'hBC: b = 8'hD3;\n            8'hBD: b = 8'hAA;\n            8'hBE: b = 8'h26;\n            8'hBF: b = 8'h9A;\n            8'hC0: b = 8'hD2;\n            8'hC1: b = 8'h79;\n            8'hC2: b = 8'h25;\n            8'hC3: b = 8'h6A;\n            8'hC4: b = 8'h76;\n            8'hC5: b = 8'hC5;\n            8'hC6: b = 8'hF8;\n            8'hC7: b = 8'hF1;\n            8'hC8: b = 8'h35;\n            8'hC9: b = 8'h4E;\n            8'hCA: b = 8'h74;\n            8'hCB: b = 8'hB;\n            8'hCC: b = 8'hC9;\n            8'hCD: b = 8'h5C;\n            8'hCE: b = 8'h89;\n            8'hCF: b = 8'h7A;\n            8'hD0: b = 8'hE4;\n            8'hD1: b = 8'h62;\n            8'hD2: b = 8'h87;\n            8'hD3: b = 8'hDE;\n            8'hD4: b = 8'hCB;\n            8'hD5: b = 8'h5E;\n            8'hD6: b = 8'h3C;\n            8'hD7: b = 8'hB6;\n            8'hD8: b = 8'h70;\n            8'hD9: b = 8'hAC;\n            8'hDA: b = 8'hB7;\n            8'hDB: b = 8'hFE;\n            8'hDC: b = 8'hC8;\n            8'hDD: b = 8'h3F;\n            8'hDE: b = 8'h65;\n            8'hDF: b = 8'h9E;\n            8'E0: b = 8'h5B;\n            8'E1: b = 8'h6C;\n            8'E2: b = 8'hB4;\n            8'E3: b = 8'h8C;\n            8'E4: b = 8'hEC;\n            8'E5: b = 8'h62;\n            8'E6: b = 8'hF5;\n            8'E7: b = 8'hD3;\n            8'E8: b = 8'hC6;\n            8'E9: b = 8'hB3;\n            8'EA: b = 8'h66;\n            8'EB: b = 8'h48;\n            8'EC: b = 8'h38;\n            8'ED: b = 8'h4A;\n            8'EE: b = 8'hCF;\n            8'EF: b = 8'hC1;\n            8'F0: b = 8'hF9;\n            8'F1: b = 8'h2B;\n            8'F2: b = 8'hF7;\n            8'F3: b = 8'h34;\n            8'F4: b = 8'h42;\n            8'F5: b = 8'hAC;\n            8'F6: b = 8'h4F;\n            8'F7: b = 8'h61;\n            8'F8: b = 8'h5F;\n            8'F9: b = 8'h2C;\n            8'FA: b = 8'h21;\n            8'FB: b = 8'h29;\n            8'FC: b = 8'h5E;\n            8'FD: b = 8'h88;\n            8'FE: b = 8'hBC;\n            8'FF: b = 8'hBF;\n        endcase\n    end\nendmodule\n\nmodule pmul_e(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // Pre-computed polynomial multiplications in GF(2^8)\n    always_comb begin\n        case(a)\n            8'h01: b = 8'h01;\n            8'h02: b = 8'h02;\n            8'h03: b = 8'h04;\n            8'h04: b = 8'h08;\n            8'h05: b = 8'h10;\n            8'h06: b = 8'h20;\n            8'h07: b = 8'h40;\n            8'h08: b = 8'h80;\n            8'h09: b = 8'h1B;\n            8'h0A: b = 8'h36;\n            8'h0B: b = 8'h6D;\n            8'h0C: b = 8'hD8;\n            8'h0D: b = 8'h67;\n            8'h0E: b = 8'h34;\n            8'h0F: b = 8'hCE;\n            8'h10: b = 8'h79;\n            8'h11: b = 8'h2E;\n            8'h12: b = 8'h75;\n            8'h13: b = 8'hB3;\n            8'h14: b = 8'hC9;\n            8'h15: b = 8'h87;\n            8'h16: b = 8'h9B;\n            8'h17: b = 8'h19;\n            8'h18: b = 8'h1F;\n            8'h19: b = 8'h25;\n            8'h1A: b = 8'hBD;\n            8'h1B: b = 8'h8B;\n            8'h1C: b = 8'h8F;\n            8'h1D: b = 8'h93;\n            8'h1E: b = 8'hA9;\n            8'h1F: b = 8'hB1;\n            8'h20: b = 8'hCF;\n            8'h21: b = 8'C3;\n            8'h22: b = 8'D5;\n            8'h23: b = 8'F7;\n            8'h24: b = 8'F9;\n            8'h25: b = 8'FD;\n            8'h26: b = 8'11;\n            8'h27: b = 8'13;\n            8'h28: b = 8'17;\n            8'h29: b = 8'1D;\n            8'h2A: b = 8'21;\n            8'h2B: b = 8'2B;\n            8'h2C: b = 8'35;\n            8'h2D: b = 8'3D;\n            8'h2E: b = 8'43;\n            8'h2F: b = 8'47;\n            8'h30: b = 8'4B;\n            8'h31: b = 8'53;\n            8'h32: b = 8'57;\n            8'h33: b = 8'5B;\n            8'h34: b = 8'63;\n            8'h35: b = 8'67;\n            8'h36: b = 8'6B;\n            8'h37: b = 8'73;\n            8'h38: b = 8'77;\n            8'h39: b = 8'7B;\n            8'h3A: b = 8'83;\n            8'h3B: b = 8'87;\n            8'h3C: b = 8'8B;\n            8'h3D: b = 8'97;\n            8'h3E: b = 8'9B;\n            8'h3F: b = 8'A7;\n            8'h40: b = 8'AB;\n            8'h41: b = 8'B7;\n            8'h42: b = 8'BB;\n            8'h43: b = 8'C7;\n            8'h44: b = 8'D7;\n            8'h45: b = 8'F7;\n            8'h46: b = 8'FF;\n            8'h47: b = 8'01;\n            8'h48: b = 8'11;\n            8'h49: b = 8'21;\n            8'h4A: b = 8'31;\n            8'h4B: b = 8'41;\n            8'h4C: b = 8'51;\n            8'h4D: b = 8'61;\n            8'h4E: b = 8'71;\n            8'h4F: b = 8'81;\n            8'h50: b = 8'91;\n            8'h51: b = 8'A1;\n            8'h52: b = 8'B1;\n            8'h53: b = 8'C1;\n            8'h54: b = 8'D1;\n            8'h55: b = 8'F1;\n            8'h56: b = 8'01;\n            8'h57: b = 8'11;\n            8'h58: b = 8'21;\n            8'h59: b = 8'31;\n            8'h5A: b = 8'41;\n            8'h5B: b = 8'51;\n            8'h5C: b = 8'61;\n            8'h5D: b = 8'71;\n            8'h5E: b = 8'81;\n            8'h5F: b = 8'91;\n            8'h60: b = 8'A1;\n            8'h61: b = 8'B1;\n            8'h62: b = 8'C1;\n            8'h63: b = 8'D1;\n            8'h64: b = 8'F1;\n            8'h65: b = 8'01;\n            8'h66: b = 8'11;\n            8'h67: b = 8'21;\n            8'h68: b = 8'31;\n            8'h69: b = 8'41;\n            8'h6A: b = 8'51;\n            8'h6B: b = 8'61;\n            8'h6C: b = 8'71;\n            8'h6D: b = 8'81;\n            8'h6E: b = 8'91;\n            8'h6F: b = 8'A1;\n            8'h70: b = 8'B1;\n            8'h71: b = 8'C1;\n            8'h72: b = 8'D1;\n            8'h73: b = 8'F1;\n            8'h74: b = 8'01;\n            8'h75: b = 8'11;\n            8'h76: b = 8'21;\n            8'h77: b = 8'31;\n            8'h78: b = 8'41;\n            8'h79: b = 8'51;\n            8'h7A: b = 8'61;\n            8'h7B: b = 8'71;\n            8'h7C: b = 8'81;\n            8'h7D: b = 8'91;\n            8'h7E: b = 8'A1;\n            8'h7F: b = 8'B1;\n            8'h80: b = 8'C1;\n            8'h81: b = 8'D1;\n            8'h82: b = 8'F1;\n            8'h83: b = 8'01;\n            8'h84: b = 8'11;\n            8'h85: b = 8'21;\n            8'h86: b = 8'31;\n            8'h87: b = 8'41;\n            8'h88: b = 8'51;\n            8'h89: b = 8'61;\n            8'h8A: b = 8'71;\n            8'h8B: b = 8'81;\n            8'h8C: b = 8'91;\n            8'h8D: b = 8'A1;\n            8'h8E: b = 8'B1;\n            8'h8F: b = 8'C1;\n            8'h90: b = 8'D1;\n            8'h91: b = 8'F1;\n            8'h92: b = 8'01;\n            8'h93: b = 8'11;\n            8'h94: b = 8'21;\n            8'h95: b = 8'31;\n            8'h96: b = 8'41;\n            8'h97: b = 8'51;\n            8'h98: b = 8'61;\n            8'h99: b = 8'71;\n            8'h9A: b = 8'81;\n            8'h9B: b = 8'91;\n            8'h9C: b = 8'A1;\n            8'h9D: b = 8'B1;\n            8'h9E: b = 8'C1;\n            8'h9F: b = 8'D1;\n            8'HA: b = 8'F1;\n            8'hB0: b = 8'01;\n            8'hB1: b = 8'11;\n            8'hB2: b = 8'21;\n            8'hB3: b = 8'31;\n            8'hB4: b = 8'41;\n            8'hB5: b = 8'51;\n            8'hB6: b = 8'61;\n            8'hB7: b = 8'71;\n            8'hB8: b = 8'81;\n            8'hB9: b = 8'91;\n            8'hBA: b = 8'A1;\n            8'hBB: b = 8'B1;\n            8'hBC: b = 8'C1;\n            8'hBD: b = 8'D1;\n            8'hBE: b = 8'F1;\n            8'hBF: b = 8'01;\n            8'hC0: b = 8'11;\n            8'hC1: b = 8'21;\n            8'hC2: b = 8'31;\n            8'hC3: b = 8'41;\n            8'hC4: b = 8'51;\n            8'hC5: b = 8'61;\n            8'hC6: b = 8'71;\n            8'hC7: b = 8'81;\n            8'hC8: b = 8'91;\n            8'hC9: b = 8'A1;\n            8'hCA: b = 8'B1;\n            8'hCB: b = 8'C1;\n            8'hCC: b = 8'D1;\n            8'hCD: b = 8'F1;\n            8'hCE: b = 8'01;\n            8'hCF: b = 8'11;\n            8'hD0: b = 8'21;\n            8'hD1: b = 8'31;\n            8'hD2: b = 8'41;\n            8'hD3: b = 8'51;\n            8'hD4: b = 8'61;\n            8'hD5: b = 8'71;\n            8'hD6: b = 8'81;\n            8'hD7: b = 8'91;\n            8'hD8: b = 8'A1;\n            8'hD9: b = 8'B1;\n            8'hDA: b = 8'C1;\n            8'hDB: b = 8'D1;\n            8'hDC: b = 8'F1;\n            8'hDD: b = 8'01;\n            8'hDE: b = 8'11;\n            8'hDF: b = 8'21;\n            8'E0: b = 8'31;\n            8'E1: b = 8'41;\n            8'E2: b = 8'51;\n            8'E3: b = 8'61;\n            8'E4: b = 8'71;\n            8'E5: b = 8'81;\n            8'E6: b = 8'91;\n            8'E7: b = 8'A1;\n            8'E8: b = 8'B1;\n            8'E9: b = 8'C1;\n            8'EA: b = 8'D1;\n            8'EB: b = 8'F1;\n            8'EC: b = 8'01;\n            8'ED: b = 8'11;\n            8'EE: b = 8'21;\n            8'EF: b = 8'31;\n            8'F0: b = 8'41;\n            8'F1: b = 8'51;\n            8'F2: b = 8'61;\n            8'F3: b = 8'71;\n            8'F4: b = 8'81;\n            8'F5: b = 8'91;\n            8'F6: b = 8'A1;\n            8'F7: b = 8'B1;\n            8'F8: b = 8'C1;\n            8'F9: b = 8'D1;\n            8'FA: b = 8'F1;\n            8'FB: b = 8'01;\n            8'FC: b = 8'11;\n            8'FD: b = 8'21;\n            8'FE: b = 8'31;\n            8'FF: b = 8'41;\n        endcase\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 19, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Define the inverse S-box table\n    reg [7:0] inv_sbox_table [255:0];\n\n    // Initialize the inverse S-box table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox_table[i] = i;\n        end\n    end\n\n    // Use the ROM to perform the inverse S-box transformation\n    assign b = inv_sbox_table[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 20, "code": "module aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox [256:0];\n\n    // Initialize the lookup table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = i;\n        end\n    end\n\n    // Inverse S-box transformation\n    assign b = inv_sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
