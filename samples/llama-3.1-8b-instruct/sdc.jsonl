{"task": "sd_bd", "codeid": 1, "code": "module sd_bd(\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Import global variables from sd_defines.v\n    `include \"sd_defines.v\"\n\n    // Define BD_WIDTH and BD_SIZE\n    localparam BD_WIDTH = `BD_WIDTH;\n    localparam BD_SIZE = `BD_SIZE;\n\n    // Define RAM_MEM_WIDTH\n    localparam RAM_MEM_WIDTH = `RAM_MEM_WIDTH;\n\n    // Define counters and pointers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] new_bw;\n    reg [BD_WIDTH-1:0] write_cnt;\n    reg [BD_WIDTH-1:0] read_cnt;\n\n    // Define state machine states\n    enum state {INIT, WRITE, READ, RELEASE} current_state;\n\n    // Initialize state machine\n    initial current_state = INIT;\n\n    // State machine logic\n    always @(posedge clk) begin\n        case (current_state)\n            INIT: begin\n                free_bd <= BD_SIZE / 2;\n                m_wr_pnt <= 0;\n                s_rd_pnt <= 0;\n                write_cnt <= 0;\n                read_cnt <= 0;\n                new_bw <= 0;\n                ack_o_s <= 0;\n            end\n            WRITE: begin\n                if (we_m) begin\n                    if (free_bd > 0) begin\n                        if (BD_WIDTH == 32) begin\n                            if (write_cnt == 1) begin\n                                m_wr_pnt <= m_wr_pnt + 1;\n                                write_cnt <= 0;\n                                new_bw <= 1;\n                                free_bd <= free_bd - 1;\n                            end else begin\n                                write_cnt <= write_cnt + 1;\n                            end\n                        end else if (BD_WIDTH == 16) begin\n                            if (write_cnt == 3) begin\n                                m_wr_pnt <= m_wr_pnt + 1;\n                                write_cnt <= 0;\n                                new_bw <= 1;\n                                free_bd <= free_bd - 1;\n                            end else begin\n                                write_cnt <= write_cnt + 1;\n                            end\n                        end\n                    end\n                end\n            end\n            READ: begin\n                if (re_s) begin\n                    if (BD_WIDTH == 32) begin\n                        if (read_cnt == 1) begin\n                            dat_out_s <= bd_mem[s_rd_pnt];\n                            s_rd_pnt <= s_rd_pnt + 1;\n                            read_cnt <= 0;\n                            ack_o_s <= 1;\n                        end else begin\n                            read_cnt <= read_cnt + 1;\n                        end\n                    end else if (BD_WIDTH == 16) begin\n                        if (read_cnt == 3) begin\n                            dat_out_s <= bd_mem[s_rd_pnt];\n                            s_rd_pnt <= s_rd_pnt + 1;\n                            read_cnt <= 0;\n                            ack_o_s <= 1;\n                        end else begin\n                            read_cnt <= read_cnt + 1;\n                        end\n                    end\n                end\n            end\n            RELEASE: begin\n                if (a_cmp) begin\n                    free_bd <= free_bd + 1;\n                end\n            end\n        endcase\n    end\n\n    // Assign outputs\n    assign free_bd = free_bd;\n    assign ack_o_s = ack_o_s;\n    assign dat_out_s = dat_out_s;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 2, "code": "module sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Import sd_defines.v\n    `include \"sd_defines.v\"\n\n    // Local parameters\n    localparam BD_SIZE = 1 << BD_WIDTH;\n    localparam RAM_MEM_WIDTH = `RAM_MEM_WIDTH;\n    localparam MEM_OFFSET = `MEM_OFFSET;\n\n    // Registers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] free_bd_reg;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n    reg [RAM_MEM_WIDTH-1:0] dat_out_reg;\n    reg new_bw;\n    reg last_a_cmp;\n\n    // Initialize BD memory with zeros\n    initial begin\n        for (int i = 0; i < BD_SIZE; i++) begin\n            bd_mem[i] = 0;\n        end\n    end\n\n    // Initialize free_bd counter\n    initial begin\n        if (`BIG_ENDIAN) begin\n            free_bd_reg = BD_SIZE / 2;\n        end else begin\n            free_bd_reg = BD_SIZE / 4;\n        end\n    end\n\n    // Initialize write and read pointers\n    initial begin\n        m_wr_pnt = 0;\n        s_rd_pnt = 0;\n    end\n\n    // Initialize counters\n    initial begin\n        new_bw = 0;\n        last_a_cmp = 0;\n    end\n\n    // Clock domain crossing\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            free_bd_reg <= `BIG_ENDIAN ? BD_SIZE / 2 : BD_SIZE / 4;\n            new_bw <= 0;\n            last_a_cmp <= 0;\n        end\n    end\n\n    // Write Buffer Descriptor\n    always @(posedge clk) begin\n        if (we_m && free_bd_reg > 0) begin\n            if (`BIG_ENDIAN) begin\n                if (m_wr_pnt == BD_SIZE - 1) begin\n                    m_wr_pnt <= 0;\n                end else begin\n                    m_wr_pnt <= m_wr_pnt + 1;\n                end\n            end else begin\n                if (m_wr_pnt == BD_SIZE - 1) begin\n                    m_wr_pnt <= 0;\n                end else begin\n                    m_wr_pnt <= m_wr_pnt + 1;\n                end\n            end\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            new_bw <= 1;\n            free_bd_reg <= free_bd_reg - 1;\n        end\n    end\n\n    // Read Buffer Descriptor\n    always @(posedge clk) begin\n        if (re_s) begin\n            if (`BIG_ENDIAN) begin\n                if (s_rd_pnt == BD_SIZE - 1) begin\n                    s_rd_pnt <= 0;\n                end else begin\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end\n                dat_out_reg <= bd_mem[s_rd_pnt];\n            end else begin\n                if (s_rd_pnt == BD_SIZE - 1) begin\n                    s_rd_pnt <= 0;\n                end else begin\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end\n                dat_out_reg <= bd_mem[s_rd_pnt];\n                if (`BIG_ENDIAN) begin\n                    ack_o_s <= 0;\n                end else begin\n                    ack_o_s <= 1;\n                end\n            end\n        end\n    end\n\n    // Release Buffer Descriptor\n    always @(posedge clk) begin\n        if (a_cmp) begin\n            if (`BIG_ENDIAN) begin\n                free_bd_reg <= free_bd_reg + 1;\n            end else begin\n                if (last_a_cmp) begin\n                    free_bd_reg <= free_bd_reg + 1;\n                end\n            end\n        end\n    end\n\n    // Output data\n    assign dat_out_s = dat_out_reg;\n\n    // Output free_bd\n    assign free_bd = free_bd_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 3, "code": "module sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Import sd_defines.v\n    `include \"sd_defines.v\"\n\n    // Define BD_WIDTH and BD_SIZE\n    localparam BD_WIDTH = `BD_WIDTH;\n    localparam BD_SIZE = `BD_SIZE;\n\n    // Define RAM_MEM_WIDTH\n    localparam RAM_MEM_WIDTH = `RAM_MEM_WIDTH;\n\n    // Define counters and pointers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] new_bw;\n    reg [BD_WIDTH-1:0] free_bd_cnt;\n\n    // Define BD buffer\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n\n    // Initialize BD buffer\n    initial begin\n        for (int i = 0; i < BD_SIZE; i++) begin\n            bd_mem[i] = 0;\n        end\n    end\n\n    // Initialize counters and pointers\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            new_bw <= 0;\n            free_bd_cnt <= BD_SIZE / 2;\n        end\n    end\n\n    // Write Buffer Descriptor\n    always @(posedge clk) begin\n        if (we_m && free_bd_cnt > 0) begin\n            if (BD_WIDTH == 32) begin\n                if (m_wr_pnt == BD_SIZE-1) begin\n                    m_wr_pnt <= 0;\n                end else begin\n                    m_wr_pnt <= m_wr_pnt + 1;\n                end\n                if (m_wr_pnt == BD_SIZE-1) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                end\n            end else if (BD_WIDTH == 16) begin\n                if (m_wr_pnt == BD_SIZE-1) begin\n                    m_wr_pnt <= 0;\n                end else begin\n                    m_wr_pnt <= m_wr_pnt + 1;\n                end\n                if (m_wr_pnt == BD_SIZE-1) begin\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                end\n            end\n        end\n    end\n\n    // Read Buffer Descriptor\n    always @(posedge clk) begin\n        if (re_s) begin\n            if (BD_WIDTH == 32) begin\n                if (s_rd_pnt == BD_SIZE-1) begin\n                    s_rd_pnt <= 0;\n                end else begin\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end\n                if (s_rd_pnt == BD_SIZE-1) begin\n                    ack_o_s <= 1;\n                end\n            end else if (BD_WIDTH == 16) begin\n                if (s_rd_pnt == BD_SIZE-1) begin\n                    s_rd_pnt <= 0;\n                end else begin\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end\n                if (s_rd_pnt == BD_SIZE-1) begin\n                    ack_o_s <= 1;\n                end\n            end\n            dat_out_s <= bd_mem[s_rd_pnt];\n        end\n    end\n\n    // Release Buffer Descriptor\n    always @(posedge clk) begin\n        if (a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\n\n    // Output free_bd\n    assign free_bd = free_bd_cnt;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 4, "code": "module sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Import sd_defines.v\n    `include \"sd_defines.v\"\n\n    // Define BD_WIDTH and BD_SIZE\n    localparam BD_WIDTH = `BD_WIDTH;\n    localparam BD_SIZE = `BD_SIZE;\n\n    // Define RAM_MEM_WIDTH\n    localparam RAM_MEM_WIDTH = `RAM_MEM_WIDTH;\n\n    // Define counters and pointers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] new_bw;\n    reg [BD_WIDTH-1:0] free_bd_cnt;\n\n    // Define BD buffer\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n\n    // Initialize BD buffer\n    initial begin\n        for (int i = 0; i < BD_SIZE; i++) begin\n            bd_mem[i] = 0;\n        end\n    end\n\n    // Initialize counters and pointers\n    initial begin\n        m_wr_pnt = 0;\n        s_rd_pnt = 0;\n        new_bw = 0;\n        free_bd_cnt = BD_SIZE / 2; // 32-bit mode\n        // free_bd_cnt = BD_SIZE / 4; // 16-bit mode\n    end\n\n    // Write operation\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            new_bw <= 0;\n            free_bd_cnt <= BD_SIZE / 2; // 32-bit mode\n            // free_bd_cnt <= BD_SIZE / 4; // 16-bit mode\n        end else if (we_m) begin\n            if (free_bd_cnt > 0) begin\n                if (RAM_MEM_WIDTH == 32) begin\n                    // 32-bit mode\n                    if (m_wr_pnt == BD_SIZE - 1) begin\n                        m_wr_pnt <= 0;\n                    end else begin\n                        m_wr_pnt <= m_wr_pnt + 1;\n                    end\n                end else if (RAM_MEM_WIDTH == 16) begin\n                    // 16-bit mode\n                    if (m_wr_pnt == BD_SIZE - 1) begin\n                        m_wr_pnt <= 0;\n                    end else begin\n                        m_wr_pnt <= m_wr_pnt + 1;\n                    end\n                end\n                new_bw <= 1;\n                free_bd_cnt <= free_bd_cnt - 1;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge clk) begin\n        if (rst) begin\n            s_rd_pnt <= 0;\n            ack_o_s <= 0;\n        end else if (re_s) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                // 32-bit mode\n                if (s_rd_pnt == BD_SIZE - 1) begin\n                    s_rd_pnt <= 0;\n                end else begin\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end\n                dat_out_s <= bd_mem[s_rd_pnt];\n                ack_o_s <= 1;\n            end else if (RAM_MEM_WIDTH == 16) begin\n                // 16-bit mode\n                if (s_rd_pnt == BD_SIZE - 1) begin\n                    s_rd_pnt <= 0;\n                end else begin\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end\n                dat_out_s <= bd_mem[s_rd_pnt];\n                ack_o_s <= 1;\n            end\n        end\n    end\n\n    // Release BD operation\n    always @(posedge clk) begin\n        if (rst) begin\n            free_bd_cnt <= BD_SIZE / 2; // 32-bit mode\n            // free_bd_cnt <= BD_SIZE / 4; // 16-bit mode\n        end else if (a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\n\n    // Output free_bd\n    assign free_bd = free_bd_cnt;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 5, "code": "module sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Import sd_defines.v\n    `include \"sd_defines.v\"\n\n    // Define BD_WIDTH and BD_SIZE\n    localparam BD_WIDTH = `BD_WIDTH;\n    localparam BD_SIZE = `BD_SIZE;\n\n    // Define RAM_MEM_WIDTH\n    localparam RAM_MEM_WIDTH = `RAM_MEM_WIDTH;\n\n    // Define counters and pointers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] wr_cnt;\n    reg [BD_WIDTH-1:0] rd_cnt;\n    reg [BD_WIDTH-1:0] free_bd_cnt;\n\n    // Define BD memory\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n\n    // Define new_bd flag\n    reg new_bd;\n\n    // Define last_a_cmp flag\n    reg last_a_cmp;\n\n    // Define 16-bit mode flag\n    reg is_16bit_mode;\n\n    // Initialize BD memory\n    initial begin\n        for (int i = 0; i < BD_SIZE; i++) begin\n            bd_mem[i] = 0;\n        end\n    end\n\n    // Initialize counters and pointers\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            wr_cnt <= 0;\n            rd_cnt <= 0;\n            free_bd_cnt <= BD_SIZE / 2;\n            new_bd <= 0;\n            last_a_cmp <= 0;\n            is_16bit_mode <= 0;\n        end\n    end\n\n    // Write operation\n    always @(posedge clk) begin\n        if (we_m && free_bd_cnt > 0) begin\n            if (is_16bit_mode) begin\n                if (wr_cnt == 3) begin\n                    bd_mem[m_wr_pnt] <= dat_in_m;\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    wr_cnt <= 0;\n                    new_bd <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                end else begin\n                    wr_cnt <= wr_cnt + 1;\n                end\n            end else begin\n                if (wr_cnt == 1) begin\n                    bd_mem[m_wr_pnt] <= dat_in_m;\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    wr_cnt <= 0;\n                    new_bd <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                end else begin\n                    wr_cnt <= wr_cnt + 1;\n                end\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge clk) begin\n        if (re_s) begin\n            if (is_16bit_mode) begin\n                if (rd_cnt == 3) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    rd_cnt <= 0;\n                    ack_o_s <= 1;\n                end else begin\n                    rd_cnt <= rd_cnt + 1;\n                end\n            end else begin\n                if (rd_cnt == 1) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    rd_cnt <= 0;\n                    ack_o_s <= 1;\n                end else begin\n                    rd_cnt <= rd_cnt + 1;\n                end\n            end\n        end\n    end\n\n    // Release BD\n    always @(posedge clk) begin\n        if (a_cmp) begin\n            if (is_16bit_mode) begin\n                if (last_a_cmp) begin\n                    free_bd_cnt <= free_bd_cnt + 1;\n                end\n            end else begin\n                free_bd_cnt <= free_bd_cnt + 1;\n            end\n        end\n    end\n\n    // Update free_bd\n    assign free_bd = free_bd_cnt;\n\n    // Update last_a_cmp\n    always @(posedge clk) begin\n        if (a_cmp) begin\n            last_a_cmp <= 1;\n        end else begin\n            last_a_cmp <= 0;\n        end\n    end\n\n    // Update is_16bit_mode\n    always @(posedge clk) begin\n        if (rst) begin\n            is_16bit_mode <= 0;\n        end else if (a_cmp) begin\n            is_16bit_mode <= 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 6, "code": "module sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Import sd_defines.v\n    `include \"sd_defines.v\"\n\n    // Define BD_WIDTH and BD_SIZE\n    localparam BD_WIDTH = `BD_WIDTH;\n    localparam BD_SIZE = `BD_SIZE;\n\n    // Define RAM_MEM_WIDTH\n    localparam RAM_MEM_WIDTH = `RAM_MEM_WIDTH;\n\n    // Define counters and pointers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] new_bd;\n    reg [BD_WIDTH-1:0] free_bd_cnt;\n    reg [BD_WIDTH-1:0] write_cnt;\n    reg [BD_WIDTH-1:0] read_cnt;\n\n    // Define BD buffer\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n\n    // Initialize BD buffer\n    initial begin\n        for (int i = 0; i < BD_SIZE; i++) begin\n            bd_mem[i] = 0;\n        end\n    end\n\n    // Initialize counters and pointers\n    initial begin\n        m_wr_pnt = 0;\n        s_rd_pnt = 0;\n        new_bd = 0;\n        free_bd_cnt = BD_SIZE / 2; // 32-bit mode\n        write_cnt = 0;\n        read_cnt = 0;\n    end\n\n    // Clock and reset logic\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            new_bd <= 0;\n            free_bd_cnt <= BD_SIZE / 2; // 32-bit mode\n            write_cnt <= 0;\n            read_cnt <= 0;\n        end\n    end\n\n    // Write logic\n    always @(posedge clk) begin\n        if (we_m && free_bd_cnt > 0) begin\n            if (write_cnt == 0) begin\n                new_bd <= 1;\n                free_bd_cnt <= free_bd_cnt - 1;\n            end\n            if (write_cnt == 1) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_cnt <= write_cnt + 1;\n            end\n            if (write_cnt == 2) begin\n                if (BD_WIDTH == 16) begin\n                    bd_mem[m_wr_pnt] <= bd_mem[m_wr_pnt] | dat_in_m;\n                end\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_cnt <= 0;\n            end\n        end\n    end\n\n    // Read logic\n    always @(posedge clk) begin\n        if (re_s) begin\n            if (BD_WIDTH == 32) begin\n                if (read_cnt == 0) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_cnt <= read_cnt + 1;\n                end\n                if (read_cnt == 1) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_cnt <= read_cnt + 1;\n                end\n            end\n            if (BD_WIDTH == 16) begin\n                if (read_cnt == 0) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    ack_o_s <= 1;\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_cnt <= read_cnt + 1;\n                end\n                if (read_cnt == 1) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    ack_o_s <= 1;\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_cnt <= read_cnt + 1;\n                end\n                if (read_cnt == 2) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    ack_o_s <= 1;\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_cnt <= read_cnt + 1;\n                end\n                if (read_cnt == 3) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    ack_o_s <= 1;\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_cnt <= 0;\n                end\n            end\n        end\n    end\n\n    // Release BD logic\n    always @(posedge clk) begin\n        if (a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\n\n    // Output free_bd\n    assign free_bd = free_bd_cnt;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 7, "code": "module sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Import sd_defines.v\n    `include \"sd_defines.v\"\n\n    // Define BD_WIDTH and BD_SIZE\n    parameter BD_WIDTH = `BD_WIDTH;\n    parameter BD_SIZE = `BD_SIZE;\n\n    // Define RAM_MEM_WIDTH\n    parameter RAM_MEM_WIDTH = `RAM_MEM_WIDTH;\n\n    // Define counters and pointers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] new_bw;\n    reg [BD_WIDTH-1:0] free_bd_cnt;\n\n    // Define write and read counters\n    reg [BD_WIDTH-1:0] m_wr_cnt;\n    reg [BD_WIDTH-1:0] s_rd_cnt;\n\n    // Define BD buffer memory\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n\n    // Initialize BD buffer memory\n    initial begin\n        for (int i = 0; i < BD_SIZE; i++) begin\n            bd_mem[i] = 0;\n        end\n    end\n\n    // Initialize counters and pointers\n    initial begin\n        m_wr_pnt = 0;\n        s_rd_pnt = 0;\n        new_bw = 0;\n        free_bd_cnt = BD_SIZE / 2;\n        m_wr_cnt = 0;\n        s_rd_cnt = 0;\n    end\n\n    // Clock and reset logic\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            new_bw <= 0;\n            free_bd_cnt <= BD_SIZE / 2;\n            m_wr_cnt <= 0;\n            s_rd_cnt <= 0;\n        end\n    end\n\n    // Write logic\n    always @(posedge clk) begin\n        if (we_m) begin\n            if (free_bd_cnt > 0) begin\n                if (m_wr_cnt == 0) begin\n                    bd_mem[m_wr_pnt] <= dat_in_m;\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    m_wr_cnt <= m_wr_cnt + 1;\n                    if (m_wr_cnt == BD_SIZE / 2) begin\n                        new_bw <= 1;\n                        free_bd_cnt <= free_bd_cnt - 1;\n                        m_wr_cnt <= 0;\n                    end\n                end\n            end\n        end\n    end\n\n    // Read logic\n    always @(posedge clk) begin\n        if (re_s) begin\n            if (s_rd_cnt < BD_SIZE / 2) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                s_rd_cnt <= s_rd_cnt + 1;\n                if (s_rd_cnt == BD_SIZE / 2) begin\n                    ack_o_s <= 1;\n                    s_rd_cnt <= 0;\n                end\n            end\n        end\n    end\n\n    // Release BD logic\n    always @(posedge clk) begin\n        if (a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\n\n    // Output free_bd\n    assign free_bd = free_bd_cnt;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 8, "code": "module sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Import sd_defines.v\n    `include \"sd_defines.v\"\n\n    // Define BD_WIDTH and BD_SIZE\n    localparam BD_WIDTH = `BD_WIDTH;\n    localparam BD_SIZE = `BD_SIZE;\n\n    // Define RAM_MEM_WIDTH\n    localparam RAM_MEM_WIDTH = `RAM_MEM_WIDTH;\n\n    // Define counters and pointers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_cnt;\n    reg [BD_WIDTH-1:0] read_cnt;\n    reg [BD_WIDTH-1:0] free_bd_cnt;\n\n    // Define BD buffer\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n\n    // Initialize BD buffer\n    initial begin\n        for (int i = 0; i < BD_SIZE; i++) begin\n            bd_mem[i] = 0;\n        end\n    end\n\n    // Initialize counters and pointers\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_cnt <= 0;\n            read_cnt <= 0;\n            free_bd_cnt <= BD_SIZE / 2; // 32-bit mode\n        end\n    end\n\n    // Write Buffer Descriptor\n    always @(posedge clk) begin\n        if (we_m && free_bd_cnt > 0) begin\n            if (write_cnt == 2) begin // 32-bit mode\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_cnt <= 0;\n                free_bd_cnt <= free_bd_cnt - 1;\n            end\n            else if (write_cnt == 4) begin // 16-bit mode\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_cnt <= write_cnt + 1;\n                if (write_cnt == 4) begin\n                    bd_mem[m_wr_pnt] <= dat_in_m;\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    write_cnt <= 0;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                end\n            end\n            else begin\n                write_cnt <= write_cnt + 1;\n            end\n        end\n    end\n\n    // Read Buffer Descriptor\n    always @(posedge clk) begin\n        if (re_s) begin\n            if (read_cnt == 2) begin // 32-bit mode\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_cnt <= 0;\n                ack_o_s <= 1;\n            end\n            else if (read_cnt == 4) begin // 16-bit mode\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_cnt <= read_cnt + 1;\n                if (read_cnt == 4) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_cnt <= 0;\n                    ack_o_s <= 1;\n                end\n            end\n            else begin\n                read_cnt <= read_cnt + 1;\n            end\n        end\n    end\n\n    // Release Buffer Descriptor\n    always @(posedge clk) begin\n        if (a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\n\n    // Output free_bd\n    assign free_bd = free_bd_cnt;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] free_bd_reg;\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] new_bd;\n    reg [BD_WIDTH-1:0] write_cnt;\n    reg [BD_WIDTH-1:0] read_cnt;\n    reg [BD_WIDTH-1:0] last_a_cmp;\n    reg [BD_WIDTH-1:0] a_cmp_cnt;\n    reg [BD_WIDTH-1:0] ack_o_s_reg;\n\n    initial begin\n        free_bd_reg = BD_WIDTH'(BD_SIZE/2);\n        m_wr_pnt = 0;\n        s_rd_pnt = 0;\n        write_cnt = 0;\n        read_cnt = 0;\n        last_a_cmp = 0;\n        a_cmp_cnt = 0;\n        ack_o_s_reg = 0;\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            free_bd_reg <= BD_WIDTH'(BD_SIZE/2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_cnt <= 0;\n            read_cnt <= 0;\n            last_a_cmp <= 0;\n            a_cmp_cnt <= 0;\n            ack_o_s_reg <= 0;\n        end\n        else begin\n            if (we_m) begin\n                if (free_bd_reg > 0) begin\n                    if (write_cnt == BD_SIZE/2) begin\n                        new_bd <= 1;\n                        free_bd_reg <= free_bd_reg - 1;\n                    end\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    write_cnt <= write_cnt + 1;\n                end\n            end\n\n            if (re_s) begin\n                if (write_cnt == BD_SIZE/2) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_cnt <= read_cnt + 1;\n                    if (BD_WIDTH == 16) begin\n                        ack_o_s <= 1;\n                    end\n                end\n            end\n\n            if (a_cmp) begin\n                if (BD_WIDTH == 16) begin\n                    if (last_a_cmp == 0) begin\n                        last_a_cmp <= 1;\n                        a_cmp_cnt <= a_cmp_cnt + 1;\n                    end\n                end\n                else begin\n                    a_cmp_cnt <= a_cmp_cnt + 1;\n                end\n                if (a_cmp_cnt == BD_SIZE/2) begin\n                    free_bd_reg <= free_bd_reg + 1;\n                    a_cmp_cnt <= 0;\n                    last_a_cmp <= 0;\n                end\n            end\n\n            if (BD_WIDTH == 16) begin\n                if (read_cnt == BD_SIZE/4) begin\n                    ack_o_s_reg <= 0;\n                end\n            end\n        end\n    end\n\n    assign free_bd = free_bd_reg;\n    assign ack_o_s = ack_o_s_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 10, "code": "module sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    parameter BD_SIZE = 256;\n    parameter BD_WIDTH = $clog2(BD_SIZE);\n    parameter RAM_MEM_WIDTH = 32;\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] new_bd;\n    reg [BD_WIDTH-1:0] free_bd_cnt;\n    reg [BD_WIDTH-1:0] write_cnt;\n    reg [BD_WIDTH-1:0] read_cnt;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem[BD_SIZE-1:0];\n    reg [RAM_MEM_WIDTH-1:0] dat_out_reg;\n    reg [BD_WIDTH-1:0] last_a_cmp;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            new_bd <= 0;\n            free_bd_cnt <= BD_SIZE / 2;\n            write_cnt <= 0;\n            read_cnt <= 0;\n            last_a_cmp <= 0;\n            for (int i = 0; i < BD_SIZE; i++) begin\n                bd_mem[i] <= 0;\n            end\n        end\n        else begin\n            if (we_m) begin\n                if (free_bd_cnt > 0) begin\n                    if (write_cnt == 0) begin\n                        new_bd <= 1;\n                        free_bd_cnt <= free_bd_cnt - 1;\n                    end\n                    if (write_cnt == 1) begin\n                        bd_mem[m_wr_pnt] <= dat_in_m;\n                        write_cnt <= write_cnt + 1;\n                    end\n                    if (write_cnt == 2) begin\n                        bd_mem[m_wr_pnt + RAM_MEM_WIDTH-1] <= dat_in_m;\n                        write_cnt <= 0;\n                        m_wr_pnt <= m_wr_pnt + 1;\n                    end\n                end\n            end\n            if (re_s) begin\n                if (read_cnt == 0) begin\n                    dat_out_reg <= bd_mem[s_rd_pnt];\n                    read_cnt <= read_cnt + 1;\n                end\n                if (read_cnt == 1) begin\n                    dat_out_reg <= bd_mem[s_rd_pnt + RAM_MEM_WIDTH-1];\n                    read_cnt <= read_cnt + 1;\n                end\n                if (read_cnt == 2) begin\n                    dat_out_s <= dat_out_reg;\n                    read_cnt <= 0;\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end\n            end\n            if (a_cmp) begin\n                if (last_a_cmp == 0) begin\n                    free_bd_cnt <= free_bd_cnt + 1;\n                    last_a_cmp <= 1;\n                end\n            end\n        end\n    end\n\n    assign ack_o_s = (read_cnt == 2);\n    assign free_bd = free_bd_cnt;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nreg [BD_WIDTH-1:0] free_bd_reg;\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [BD_WIDTH-1:0] new_bw;\nreg [BD_WIDTH-1:0] last_a_cmp;\nreg [BD_WIDTH-1:0] write_cnt;\nreg [BD_WIDTH-1:0] read_cnt;\nreg [BD_WIDTH-1:0] bd_size;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        free_bd_reg <= BD_WIDTH;\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n        write_cnt <= 0;\n        read_cnt <= 0;\n        bd_size <= BD_SIZE;\n    end else begin\n        if (we_m && free_bd_reg > 0) begin\n            if (BD_WIDTH == 32) begin\n                if (write_cnt == 1) begin\n                    new_bw <= 1;\n                    free_bd_reg <= free_bd_reg - 1;\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    write_cnt <= 0;\n                end else begin\n                    write_cnt <= write_cnt + 1;\n                end\n            end else begin\n                if (write_cnt == 3) begin\n                    new_bw <= 1;\n                    free_bd_reg <= free_bd_reg - 1;\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    write_cnt <= 0;\n                end else begin\n                    write_cnt <= write_cnt + 1;\n                end\n            end\n        end\n\n        if (re_s) begin\n            if (BD_WIDTH == 32) begin\n                if (read_cnt == 1) begin\n                    ack_o_s <= 1;\n                    read_cnt <= 0;\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end else begin\n                    read_cnt <= read_cnt + 1;\n                end\n            end else begin\n                if (read_cnt == 3) begin\n                    ack_o_s <= 1;\n                    read_cnt <= 0;\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end else begin\n                    read_cnt <= read_cnt + 1;\n                end\n            end\n        end\n\n        if (a_cmp) begin\n            if (BD_WIDTH == 16) begin\n                last_a_cmp <= last_a_cmp + 1;\n                if (last_a_cmp == 1) begin\n                    free_bd_reg <= free_bd_reg + 1;\n                end\n            end\n        end\n    end\nend\n\nassign free_bd = free_bd_reg;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 12, "code": "module sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Import sd_defines.v\n    `include \"sd_defines.v\"\n\n    // Define BD_WIDTH and BD_SIZE\n    localparam BD_WIDTH = `BD_WIDTH;\n    localparam BD_SIZE = `BD_SIZE;\n\n    // Define RAM_MEM_WIDTH\n    localparam RAM_MEM_WIDTH = `RAM_MEM_WIDTH;\n\n    // Define counters and pointers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] m_wr_cnt;\n    reg [BD_WIDTH-1:0] s_rd_cnt;\n    reg [BD_WIDTH-1:0] free_bd_cnt;\n\n    // Define new_bd and last_a_cmp signals\n    reg new_bd;\n    reg last_a_cmp;\n\n    // Define BD memory\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n\n    // Initialize BD memory\n    initial begin\n        for (int i = 0; i < BD_SIZE; i++) begin\n            bd_mem[i] = 0;\n        end\n    end\n\n    // Initialize counters and pointers\n    initial begin\n        m_wr_pnt = 0;\n        s_rd_pnt = 0;\n        m_wr_cnt = 0;\n        s_rd_cnt = 0;\n        free_bd_cnt = BD_SIZE / 2; // 32-bit mode\n        // free_bd_cnt = BD_SIZE / 4; // 16-bit mode\n        new_bd = 0;\n        last_a_cmp = 0;\n    end\n\n    // Clock and reset logic\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            m_wr_cnt <= 0;\n            s_rd_cnt <= 0;\n            free_bd_cnt <= BD_SIZE / 2; // 32-bit mode\n            // free_bd_cnt <= BD_SIZE / 4; // 16-bit mode\n            new_bd <= 0;\n            last_a_cmp <= 0;\n        end\n    end\n\n    // Write logic\n    always @(posedge clk) begin\n        if (we_m) begin\n            if (free_bd_cnt > 0) begin\n                if (m_wr_cnt == 0) begin\n                    bd_mem[m_wr_pnt] <= dat_in_m;\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    m_wr_cnt <= m_wr_cnt + 1;\n                    if (m_wr_cnt == 2) begin // 32-bit mode\n                        m_wr_cnt <= 0;\n                        new_bd <= 1;\n                        free_bd_cnt <= free_bd_cnt - 1;\n                    end\n                    if (m_wr_cnt == 4) begin // 16-bit mode\n                        m_wr_cnt <= 0;\n                        new_bd <= 1;\n                        free_bd_cnt <= free_bd_cnt - 1;\n                    end\n                end\n            end\n        end\n    end\n\n    // Read logic\n    always @(posedge clk) begin\n        if (re_s) begin\n            if (s_rd_cnt == 0) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                s_rd_cnt <= s_rd_cnt + 1;\n                if (s_rd_cnt == 2) begin // 32-bit mode\n                    s_rd_cnt <= 0;\n                    ack_o_s <= 1;\n                end\n                if (s_rd_cnt == 4) begin // 16-bit mode\n                    s_rd_cnt <= 0;\n                    ack_o_s <= 1;\n                end\n            end\n        end\n    end\n\n    // Release BD logic\n    always @(posedge clk) begin\n        if (a_cmp) begin\n            if (last_a_cmp == 0) begin\n                free_bd_cnt <= free_bd_cnt + 1;\n                last_a_cmp <= 1;\n            end\n        end\n    end\n\n    // Update free_bd signal\n    assign free_bd = free_bd_cnt;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 13, "code": "module sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    parameter BD_SIZE = 256;\n    parameter RAM_MEM_WIDTH = 16;\n    parameter BD_WIDTH = $clog2(BD_SIZE);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] free_bd_cnt;\n    reg [BD_WIDTH-1:0] new_bw;\n    reg [BD_WIDTH-1:0] last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            free_bd_cnt <= BD_SIZE / 2;\n            new_bw <= 0;\n            last_a_cmp <= 0;\n        end\n        else begin\n            if (we_m) begin\n                if (free_bd_cnt > 0) begin\n                    if (RAM_MEM_WIDTH == 16) begin\n                        if (m_wr_pnt == BD_SIZE-1) m_wr_pnt <= 0;\n                        else m_wr_pnt <= m_wr_pnt + 1;\n                    end\n                    else begin\n                        if (m_wr_pnt == BD_SIZE-1) m_wr_pnt <= 0;\n                        else m_wr_pnt <= m_wr_pnt + 1;\n                    end\n                    new_bw <= 1;\n                    free_bd_cnt <= free_bd_cnt - 1;\n                end\n            end\n\n            if (re_s) begin\n                if (RAM_MEM_WIDTH == 16) begin\n                    if (s_rd_pnt == BD_SIZE-1) s_rd_pnt <= 0;\n                    else s_rd_pnt <= s_rd_pnt + 1;\n                    ack_o_s <= 1;\n                end\n                else begin\n                    if (s_rd_pnt == BD_SIZE-1) s_rd_pnt <= 0;\n                    else s_rd_pnt <= s_rd_pnt + 1;\n                end\n                dat_out_s <= bd_mem[s_rd_pnt];\n            end\n\n            if (a_cmp) begin\n                if (RAM_MEM_WIDTH == 16) begin\n                    if (last_a_cmp == 0) last_a_cmp <= 1;\n                    else last_a_cmp <= 0;\n                end\n                free_bd_cnt <= free_bd_cnt + 1;\n            end\n        end\n    end\n\n    assign free_bd = free_bd_cnt;\n\n    always @(posedge clk) begin\n        if (we_m) begin\n            if (RAM_MEM_WIDTH == 16) begin\n                if (new_bw) begin\n                    if (m_wr_pnt == BD_SIZE-1) m_wr_pnt <= 0;\n                    else m_wr_pnt <= m_wr_pnt + 1;\n                    new_bw <= 0;\n                end\n                if (m_wr_pnt < BD_SIZE) begin\n                    bd_mem[m_wr_pnt] <= dat_in_m;\n                end\n            end\n            else begin\n                if (new_bw) begin\n                    if (m_wr_pnt == BD_SIZE-1) m_wr_pnt <= 0;\n                    else m_wr_pnt <= m_wr_pnt + 1;\n                    new_bw <= 0;\n                end\n                if (m_wr_pnt < BD_SIZE) begin\n                    bd_mem[m_wr_pnt] <= dat_in_m;\n                end\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 14, "code": "module sd_bd(\n    input  clk,\n    input  rst,\n    input  we_m,\n    input  [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output [BD_WIDTH-1:0] free_bd,\n    input  re_s,\n    output ack_o_s,\n    input  a_cmp,\n    output [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    parameter BD_SIZE = 256;\n    parameter BD_WIDTH = $clog2(BD_SIZE);\n    parameter RAM_MEM_WIDTH = 32;\n    parameter RESEND_MAX_CNT = 255;\n\n    reg [BD_WIDTH-1:0] free_bd_reg;\n    reg [BD_WIDTH-1:0] m_wr_pnt_reg;\n    reg [BD_WIDTH-1:0] s_rd_pnt_reg;\n    reg [BD_WIDTH-1:0] new_bw_reg;\n    reg [BD_WIDTH-1:0] last_a_cmp_reg;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n    reg [RAM_MEM_WIDTH-1:0] dat_out_s_reg;\n    reg ack_o_s_reg;\n    reg a_cmp_reg;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            free_bd_reg <= BD_SIZE/2;\n            m_wr_pnt_reg <= 0;\n            s_rd_pnt_reg <= 0;\n            new_bw_reg <= 0;\n            last_a_cmp_reg <= 0;\n            ack_o_s_reg <= 0;\n            a_cmp_reg <= 0;\n        end else begin\n            if (we_m) begin\n                if (free_bd_reg > 0) begin\n                    if (BD_SIZE == 256) begin\n                        if (m_wr_pnt_reg == BD_SIZE-1) begin\n                            m_wr_pnt_reg <= 0;\n                        end else begin\n                            m_wr_pnt_reg <= m_wr_pnt_reg + 1;\n                        end\n                    end else begin\n                        if (m_wr_pnt_reg == BD_SIZE-1) begin\n                            m_wr_pnt_reg <= 0;\n                        end else begin\n                            m_wr_pnt_reg <= m_wr_pnt_reg + 1;\n                        end\n                    end\n                    new_bw_reg <= 1;\n                    free_bd_reg <= free_bd_reg - 1;\n                end\n            end\n\n            if (re_s) begin\n                if (BD_SIZE == 256) begin\n                    if (s_rd_pnt_reg == BD_SIZE-1) begin\n                        s_rd_pnt_reg <= 0;\n                    end else begin\n                        s_rd_pnt_reg <= s_rd_pnt_reg + 1;\n                    end\n                end else begin\n                    if (s_rd_pnt_reg == BD_SIZE-1) begin\n                        s_rd_pnt_reg <= 0;\n                    end else begin\n                        s_rd_pnt_reg <= s_rd_pnt_reg + 1;\n                    end\n                end\n                dat_out_s_reg <= bd_mem[s_rd_pnt_reg];\n                if (BD_SIZE == 256) begin\n                    ack_o_s_reg <= 1;\n                end\n            end\n\n            if (a_cmp) begin\n                if (BD_SIZE == 256) begin\n                    free_bd_reg <= free_bd_reg + 1;\n                end else begin\n                    last_a_cmp_reg <= 1;\n                end\n            end\n        end\n    end\n\n    assign free_bd = free_bd_reg;\n    assign dat_out_s = dat_out_s_reg;\n    assign ack_o_s = ack_o_s_reg;\n    assign a_cmp = a_cmp_reg;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < BD_SIZE; i++) begin\n                bd_mem[i] <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 15, "code": "module sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Import sd_defines.v\n    `include \"sd_defines.v\"\n\n    // Define BD_WIDTH and BD_SIZE\n    localparam BD_WIDTH = `BD_WIDTH;\n    localparam BD_SIZE = `BD_SIZE;\n\n    // Define RAM_MEM_WIDTH\n    localparam RAM_MEM_WIDTH = `RAM_MEM_WIDTH;\n\n    // Define counters and pointers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] new_bd;\n    reg [BD_WIDTH-1:0] free_bd_cnt;\n    reg [BD_WIDTH-1:0] write_cnt;\n    reg [BD_WIDTH-1:0] read_cnt;\n\n    // Define BD memory\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n\n    // Define 16-bit mode flag\n    reg mode_16bit;\n\n    // Initialize BD memory and counters\n    initial begin\n        for (int i = 0; i < BD_SIZE; i++) begin\n            bd_mem[i] = 0;\n        end\n        m_wr_pnt = 0;\n        s_rd_pnt = 0;\n        new_bd = 0;\n        free_bd_cnt = BD_SIZE / 2;\n        write_cnt = 0;\n        read_cnt = 0;\n        mode_16bit = 0;\n    end\n\n    // Clock and reset logic\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            new_bd <= 0;\n            free_bd_cnt <= BD_SIZE / 2;\n            write_cnt <= 0;\n            read_cnt <= 0;\n        end\n    end\n\n    // Write logic\n    always @(posedge clk) begin\n        if (we_m) begin\n            if (free_bd_cnt > 0) begin\n                if (mode_16bit) begin\n                    if (write_cnt == 3) begin\n                        bd_mem[m_wr_pnt] <= dat_in_m;\n                        new_bd <= 1;\n                        free_bd_cnt <= free_bd_cnt - 1;\n                        write_cnt <= 0;\n                    end else begin\n                        write_cnt <= write_cnt + 1;\n                    end\n                end else begin\n                    if (write_cnt == 1) begin\n                        bd_mem[m_wr_pnt] <= dat_in_m;\n                        new_bd <= 1;\n                        free_bd_cnt <= free_bd_cnt - 1;\n                        write_cnt <= 0;\n                    end else begin\n                        write_cnt <= write_cnt + 1;\n                    end\n                end\n            end\n            m_wr_pnt <= m_wr_pnt + 1;\n        end\n    end\n\n    // Read logic\n    always @(posedge clk) begin\n        if (re_s) begin\n            if (mode_16bit) begin\n                if (read_cnt == 3) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    ack_o_s <= 1;\n                    read_cnt <= 0;\n                end else begin\n                    read_cnt <= read_cnt + 1;\n                end\n            end else begin\n                if (read_cnt == 1) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    ack_o_s <= 1;\n                    read_cnt <= 0;\n                end else begin\n                    read_cnt <= read_cnt + 1;\n                end\n            end\n            s_rd_pnt <= s_rd_pnt + 1;\n        end\n    end\n\n    // Release BD logic\n    always @(posedge clk) begin\n        if (a_cmp) begin\n            free_bd_cnt <= free_bd_cnt + 1;\n        end\n    end\n\n    // Circular operation logic\n    always @(posedge clk) begin\n        if (m_wr_pnt == BD_SIZE - 1) begin\n            m_wr_pnt <= 0;\n        end\n        if (s_rd_pnt == BD_SIZE - 1) begin\n            s_rd_pnt <= 0;\n        end\n    end\n\n    // Output logic\n    assign free_bd = free_bd_cnt;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH - 1:0] dat_in_m,\n    output wire [BD_WIDTH - 1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH - 1:0] dat_out_s\n);\n\nreg [BD_WIDTH - 1:0] free_bd_reg;\nreg [BD_WIDTH - 1:0] m_wr_pnt_reg;\nreg [BD_WIDTH - 1:0] s_rd_pnt_reg;\nreg [BD_WIDTH - 1:0] new_bw_reg;\nreg [BD_WIDTH - 1:0] last_a_cmp_reg;\nreg [BD_WIDTH - 1:0] write_cnt_reg;\nreg [BD_WIDTH - 1:0] read_cnt_reg;\nreg [BD_WIDTH - 1:0] bd_size_reg;\n\ninitial begin\n    free_bd_reg = BD_WIDTH / 2;\n    m_wr_pnt_reg = 0;\n    s_rd_pnt_reg = 0;\n    new_bw_reg = 0;\n    last_a_cmp_reg = 0;\n    write_cnt_reg = 0;\n    read_cnt_reg = 0;\n    bd_size_reg = BD_SIZE;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        free_bd_reg <= BD_WIDTH / 2;\n        m_wr_pnt_reg <= 0;\n        s_rd_pnt_reg <= 0;\n        new_bw_reg <= 0;\n        last_a_cmp_reg <= 0;\n        write_cnt_reg <= 0;\n        read_cnt_reg <= 0;\n    end else begin\n        if (we_m) begin\n            if (free_bd_reg > 0) begin\n                if (BD_WIDTH == 32) begin\n                    if (write_cnt_reg == 1) begin\n                        m_wr_pnt_reg <= m_wr_pnt_reg + 1;\n                        new_bw_reg <= 1;\n                        free_bd_reg <= free_bd_reg - 1;\n                    end\n                end else if (BD_WIDTH == 16) begin\n                    if (write_cnt_reg == 3) begin\n                        m_wr_pnt_reg <= m_wr_pnt_reg + 1;\n                        new_bw_reg <= 1;\n                        free_bd_reg <= free_bd_reg - 1;\n                    end\n                end\n            end\n        end\n\n        if (re_s) begin\n            if (BD_WIDTH == 32) begin\n                if (read_cnt_reg == 1) begin\n                    dat_out_s <= bd_mem[s_rd_pnt_reg];\n                    s_rd_pnt_reg <= s_rd_pnt_reg + 1;\n                    read_cnt_reg <= 0;\n                    ack_o_s <= 1;\n                end\n            end else if (BD_WIDTH == 16) begin\n                if (read_cnt_reg == 3) begin\n                    dat_out_s <= bd_mem[s_rd_pnt_reg];\n                    s_rd_pnt_reg <= s_rd_pnt_reg + 1;\n                    read_cnt_reg <= 0;\n                    ack_o_s <= 1;\n                end\n            end\n        end\n\n        if (a_cmp) begin\n            if (BD_WIDTH == 16) begin\n                if (last_a_cmp_reg == 1) begin\n                    free_bd_reg <= free_bd_reg + 1;\n                end\n            end\n        end\n\n        if (m_wr_pnt_reg == bd_size_reg - 1) begin\n            m_wr_pnt_reg <= 0;\n        end\n\n        if (s_rd_pnt_reg == bd_size_reg - 1) begin\n            s_rd_pnt_reg <= 0;\n        end\n\n        if (new_bw_reg) begin\n            new_bw_reg <= 0;\n        end\n\n        if (write_cnt_reg == bd_size_reg - 1) begin\n            write_cnt_reg <= 0;\n        end\n\n        if (read_cnt_reg == bd_size_reg - 1) begin\n            read_cnt_reg <= 0;\n        end\n    end\nend\n\nassign free_bd = free_bd_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 17, "code": "module sd_bd(\n    input  wire clk,\n    input  wire rst,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire re_s,\n    output wire ack_o_s,\n    input  wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Import sd_defines.v\n    `include \"sd_defines.v\"\n\n    // Define BD_WIDTH and BD_SIZE\n    localparam BD_WIDTH = `BD_WIDTH;\n    localparam BD_SIZE = `BD_SIZE;\n\n    // Define RAM_MEM_WIDTH\n    localparam RAM_MEM_WIDTH = `RAM_MEM_WIDTH;\n\n    // Define counters and pointers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] wr_cnt;\n    reg [BD_WIDTH-1:0] rd_cnt;\n    reg [BD_WIDTH-1:0] free_bd_cnt;\n\n    // Define new_bd and last_a_cmp\n    reg new_bd;\n    reg last_a_cmp;\n\n    // Define BD buffer\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n\n    // Initialize BD buffer\n    initial begin\n        for (int i = 0; i < BD_SIZE; i++) begin\n            bd_mem[i] = 0;\n        end\n    end\n\n    // Initialize counters and pointers\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            wr_cnt <= 0;\n            rd_cnt <= 0;\n            free_bd_cnt <= BD_SIZE / 2;\n            new_bd <= 0;\n            last_a_cmp <= 0;\n        end\n    end\n\n    // Write Buffer Descriptor\n    always @(posedge clk) begin\n        if (we_m && free_bd_cnt > 0) begin\n            if (BD_WIDTH == 32) begin\n                if (wr_cnt == 1) begin\n                    bd_mem[m_wr_pnt] <= dat_in_m;\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    wr_cnt <= wr_cnt + 1;\n                    if (wr_cnt == 2) begin\n                        new_bd <= 1;\n                        free_bd_cnt <= free_bd_cnt - 1;\n                        wr_cnt <= 0;\n                    end\n                end\n            end else if (BD_WIDTH == 16) begin\n                if (wr_cnt == 4) begin\n                    bd_mem[m_wr_pnt] <= dat_in_m;\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    wr_cnt <= wr_cnt + 1;\n                    if (wr_cnt == 8) begin\n                        new_bd <= 1;\n                        free_bd_cnt <= free_bd_cnt - 1;\n                        wr_cnt <= 0;\n                    end\n                end\n            end\n        end\n    end\n\n    // Read Buffer Descriptor\n    always @(posedge clk) begin\n        if (re_s) begin\n            if (BD_WIDTH == 32) begin\n                if (rd_cnt == 1) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    rd_cnt <= rd_cnt + 1;\n                    if (rd_cnt == 2) begin\n                        ack_o_s <= 1;\n                        rd_cnt <= 0;\n                    end\n                end\n            end else if (BD_WIDTH == 16) begin\n                if (rd_cnt == 4) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    rd_cnt <= rd_cnt + 1;\n                    if (rd_cnt == 8) begin\n                        ack_o_s <= 1;\n                        rd_cnt <= 0;\n                    end\n                end\n            end\n        end\n    end\n\n    // Release Buffer Descriptor\n    always @(posedge clk) begin\n        if (a_cmp) begin\n            if (BD_WIDTH == 16) begin\n                if (last_a_cmp) begin\n                    free_bd_cnt <= free_bd_cnt + 1;\n                end\n            end\n        end\n    end\n\n    // Update free_bd\n    assign free_bd = free_bd_cnt;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 1, "code": "module sd_clock_divider(\n    input  wire  CLK,        // input clock signal\n    input  wire  [7:0]  DIVIDER,  // division ratio\n    input  wire  RST,        // asynchronous reset signal\n    output wire  SD_CLK     // output clock signal\n);\n\nreg  SD_CLK_O;  // output clock signal\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        SD_CLK_O <= 0;\n    end else begin\n        SD_CLK_O <= ~SD_CLK_O;\n    end\nend\n\nassign SD_CLK = SD_CLK_O;\n\n// Divider logic\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Reset divider\n        SD_CLK_O <= 0;\n    end else begin\n        // Count down to 0\n        if (SD_CLK_O == 0) begin\n            // Reset counter\n            SD_CLK_O <= DIVIDER;\n        end else begin\n            // Decrement counter\n            SD_CLK_O <= SD_CLK_O - 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 2, "code": "// sd_clock_divider.v\nmodule sd_clock_divider (\n  input  wire  CLK,  // input clock signal\n  input  wire  [7:0] DIVIDER,  // division ratio\n  input  wire  RST,  // asynchronous reset signal\n  output reg  SD_CLK  // output clock signal after division\n);\n\n  // clock divider\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      SD_CLK <= 1'b0;\n    end else begin\n      SD_CLK <= ~SD_CLK;\n      for (int i = 0; i < DIVIDER; i++) begin\n        SD_CLK <= SD_CLK;\n      end\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 3, "code": "module sd_clock_divider(\n    input  wire clk,\n    input  wire [7:0] divider,\n    input  wire rst,\n    output wire sd_clk\n);\n\nreg sd_clk_o;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        sd_clk_o <=  <= 1'b0;\n    end else begin\n        sd_clk_o  <= ~sd_clk_o;\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        sd_clk  <= 1'b0;\n    end else begin\n        if (divider == 0) begin\n            sd_clk  <= sd_clk_o;\n        end else begin\n            sd_clk  <= sd_clk_o;\n            sd_clk_o <= sd_clk_o;\n            for (int i = 0; i < divider; i++) begin\n                sd_clk_o <= sd_clk_o;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 4, "code": "Here is the Verilog code for the `sd_clock_divider` module based on the provided specification:\n```\nmodule sd_clock_divider(\n  input  wire CLK,\n  input  wire [7:0] DIVIDER,\n  input  wire RST,\n  output wire SD_CLK\n);\n\n  reg [31:0] count;\n\n  always @(posedge CLK) begin\n    if (RST) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\n  always @(posedge CLK) begin\n    if (count == (DIVIDER + 1)) begin\n      SD_CLK <= 1'b0;\n      count <= 0;\n    end else begin\n      SD_CLK <= 1'b1;\n    end\n  end\n\nendmodule\n```\nNote that I've assumed that the `count` register is 32 bits wide, as it needs to count up to `DIVIDER + 1`. Also, I've used a single clock edge to increment the `count` register, as specified in the clock and reset section of the specification.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 5, "code": "module sd_clock_divider(\n    input  wire clk,\n    input  wire [7:0] divider,\n    input  wire rst,\n    output wire sd_clk\n);\n\n    reg [31:0] count;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\n    assign sd_clk = (count == (divider + 1)) ? 1'b1 : 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 6, "code": "module sd_clock_divider(\n    input  wire  CLK,        // input clock signal\n    input  wire [7:0]  DIVIDER,  // division ratio\n    input  wire  RST,        // asynchronous reset signal\n    output wire  SD_CLK     // output clock signal after division\n);\n\n// Calculate the division ratio\nlocalparam  DIV = DIVIDER + 1;\n\n// Clock divider\nalways @(posedge CLK) begin\n    if (RST) begin\n        SD_CLK <= 0;\n    end else begin\n        SD_CLK <= ~SD_CLK;\n    end\nend\n\n// Counter\nreg [DIV-1:0] count;\n\nalways @(posedge CLK) begin\n    if (RST) begin\n        count <= 0;\n    end else begin\n        if (count == DIV - 1) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\n// Output clock signal\nassign SD_CLK = count == DIV - 1;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 7, "code": "Here is the Verilog code for the `sd_clock_divider` module based on the provided specification:\n```\nmodule sd_clock_divider(\n  input  wire CLK,\n  input  wire [7:0] DIVIDER,\n  input  wire RST,\n  output wire SD_CLK\n);\n\n  reg [31:0] count;\n  reg SD_CLK_O;\n\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      count <= 0;\n      SD_CLK_O <= 0;\n    end else begin\n      count <= count + 1;\n      if (count == DIVIDER) begin\n        SD_CLK_O <= ~SD_CLK_O;\n        count <= 0;\n      end\n    end\n  end\n\n  assign SD_CLK = SD_CLK_O;\n\nendmodule\n```\nNote that I've assumed that the `SD_CLK` output is a single bit, as specified in the interface section. If it's supposed to be a multi-bit signal, please let me know and I'll adjust the code accordingly.\n\nAlso, I've used the `posedge` and `posedge RST` sensitivity lists to ensure that the clock and reset signals are properly handled. The `count` register is used to keep track of the division ratio, and the `SD_CLK_O` register is used to store the output clock signal. The `assign` statement is used to assign the `SD_CLK_O` signal to the `SD_CLK` output.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 8, "code": "module sd_clock_divider(\n    input  wire clk,\n    input  wire [7:0] divider,\n    input  wire rst,\n    output wire sd_clk\n);\n\n    reg [31:0] count;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n            if (count == (divider + 1)) begin\n                count <= 0;\n                sd_clk <= ~sd_clk;\n            end\n        end\n    end\n\n    assign sd_clk = count[0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 9, "code": "Here is the Verilog code for the `sd_clock_divider` module:\n```\nmodule sd_clock_divider(\n  input  wire clk,\n  input  wire [7:0] divider,\n  input  wire rst,\n  output wire sd_clk\n);\n\n  reg [7:0] count;\n  reg [7:0] prev_count;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\n  assign sd_clk = (count == divider) ? 1'b1 : 1'b0;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      prev_count <= 0;\n    end else begin\n      prev_count <= count;\n    end\n  end\n\n  assign sd_clk = (prev_count == divider) ? 1'b1 : 1'b0;\n\nendmodule\n```\nNote that I've used the `posedge` event to detect the rising edge of the clock signal, as specified in the documentation. I've also used the `always` block to implement the clock divider logic, and the `assign` statement to drive the `sd_clk` output. The `prev_count` register is used to ensure that the `sd_clk` output is stable for one clock cycle before changing.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 10, "code": "module sd_clock_divider(\n    input  wire CLK,\n    input  wire [7:0] DIVIDER,\n    input  wire RST,\n    output wire SD_CLK\n);\n\n    reg [7:0] count;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\n    assign SD_CLK = (count == DIVIDER) ? CLK : 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 11, "code": "Here is the Verilog code for the `sd_clock_divider` module:\n```\nmodule sd_clock_divider (\n  input  wire CLK,\n  input  wire [7:0] DIVIDER,\n  input  wire RST,\n  output wire SD_CLK\n);\n\n  reg [31:0] count;\n\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\n  assign SD_CLK = (count == (DIVIDER + 1)) ? CLK : 1'b0;\n\nendmodule\n```\nNote that I've assumed that the `DIVIDER` input is an 8-bit value, as specified in the interface table. I've also assumed that the `count` register is a 32-bit register, which is sufficient to count up to the maximum value of `DIVIDER + 1`. The `SD_CLK` output is assigned to be the input `CLK` when the `count` register reaches the value of `DIVIDER + 1`, and 0 otherwise.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 12, "code": "module sd_clock_divider(\n    input  wire  CLK,\n    input  wire  [7:0] DIVIDER,\n    input  wire  RST,\n    output wire  SD_CLK\n);\n\n    reg [31:0] counter;\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    always @(*) begin\n        if (counter == (DIVIDER + 1)) begin\n            SD_CLK <= 1'b0;\n            counter <= 0;\n        end else begin\n            SD_CLK <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 13, "code": "module sd_clock_divider(\n    input  wire  clk_i,  // input clock signal\n    input  wire  [7:0]  divider_i,  // division ratio\n    input  wire  rst_i,  // asynchronous reset signal\n    output wire  sd_clk_o  // output clock signal\n);\n\n    // Calculate the division ratio\n    localparam int divider = divider_i + 1;\n\n    // Clock divider\n    always @(posedge clk_i) begin\n        if (rst_i) begin\n            sd_clk_o <= 0;\n        end else begin\n            sd_clk_o <= ~sd_clk_o;\n        end\n    end\n\n    // Clock divider counter\n    reg [31:0] cnt;\n\n    always @(posedge clk_i) begin\n        if (rst_i) begin\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n            if (cnt == divider) begin\n                cnt <= 0;\n                sd_clk_o <= ~sd_clk_o;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 14, "code": "module sd_clock_divider(\n    input  wire        CLK,\n    input  wire [7:0]  DIVIDER,\n    input  wire        RST,\n    output wire        SD_CLK\n);\n\n    reg [31:0] count;\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\n    always @(posedge CLK) begin\n        if (count == DIVIDER) begin\n            SD_CLK <= 1'b0;\n            count <= 0;\n        end else begin\n            SD_CLK <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 15, "code": "module sd_clock_divider(\n    input  wire  CLK,      // input clock signal\n    input  wire [7:0]  DIVIDER,  // division ratio\n    input  wire  RST,      // asynchronous reset signal\n    output wire  SD_CLK   // output clock signal\n);\n\nreg SD_CLK_O;\n\nalways @(posedge CLK or negedge RST) begin\n    if (!RST) begin\n        SD_CLK_O <= 0;\n    end else begin\n        SD_CLK_O <= SD_CLK_O? 0 : 1;\n    end\nend\n\nalways @(posedge CLK) begin\n    if (DIVIDER == 0) begin\n        SD_CLK_O <= 1;\n    end else begin\n        SD_CLK_O <= ~SD_CLK_O;\n    end\nend\n\nassign SD_CLK = SD_CLK_O;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 16, "code": "Here is the Verilog code for the `sd_clock_divider` module based on the provided specification:\n```\nmodule sd_clock_divider(\n  input  wire        CLK,\n  input  wire [7:0]  DIVIDER,\n  input  wire        RST,\n  output wire        SD_CLK\n);\n\n  reg [31:0] counter;\n\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      counter <= 0;\n    end else begin\n      counter <= counter + 1;\n    end\n  end\n\n  assign SD_CLK = (counter == (DIVIDER + 1)) ? 1'b1 : 1'b0;\n\nendmodule\n```\nNote that I've assumed that the `DIVIDER` input is an 8-bit value, and the `counter` register is a 32-bit register. The `SD_CLK` output is assigned a value of 1 when the `counter` register reaches the value of `DIVIDER + 1`, and 0 otherwise. The `RST` signal is used to reset the `counter` register to 0 when it is asserted high.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 17, "code": "Here is the Verilog code for the `sd_clock_divider` module:\n```\nmodule sd_clock_divider(\n  input  wire  CLK,\n  input  wire  [7:0] DIVIDER,\n  input  wire  RST,\n  output wire  SD_CLK\n);\n\n  reg [31:0] count;\n\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\n  assign SD_CLK = (count == DIVIDER) ? 1'b1 : 1'b0;\n\nendmodule\n```\nNote that I've assumed that the `DIVIDER` input is an 8-bit value, and that the `count` register is a 32-bit register. I've also assumed that the `SD_CLK` output should be a single bit. If these assumptions are incorrect, please let me know and I'll modify the code accordingly.\n\nAlso, I've used the `posedge` and `posedge` keywords to specify the clock edge sensitivity of the `always` block, as per the specification. I've also used the `assign` keyword to assign the value of `SD_CLK` based on the value of `count` and `DIVIDER`.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 18, "code": "module sd_clock_divider(\n    input  wire  clk_i,  // input clock\n    input  wire  [7:0]  divider_i,  // divider value\n    input  wire  rst_i,  // asynchronous reset\n    output wire  sd_clk_o  // output clock\n);\n\n// Define the clock divider\nwire clk_div;\n\nalways @(posedge clk_i) begin\n    if (rst_i) begin\n        clk_div <= 1'b0;\n    end else begin\n        clk_div <= ~clk_div;\n    end\nend\n\n// Define the clock divider counter\nreg [7:0] counter;\n\nalways @(posedge clk_i) begin\n    if (rst_i) begin\n        counter <= 8'b0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\n// Generate the output clock\nassign sd_clk_o = (counter == divider_i)? clk_div : 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 19, "code": "module sd_clock_divider(\n    input  wire  CLK,\n    input  wire [7:0] DIVIDER,\n    input  wire  RST,\n    output wire  SD_CLK\n);\n\n    reg [31:0] counter;\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            SD_CLK <= 0;\n        end else if (counter == DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 20, "code": "module sd_clock_divider(\n    input  wire clk,\n    input  wire [7:0] divider,\n    input  wire rst,\n    output wire sd_clk\n);\n\nreg sd_clk_o;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        sd_clk_o <= 0;\n    end else begin\n        sd_clk_o <= sd_clk_o + 1;\n    end\nend\n\nassign sd_clk = sd_clk_o;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        sd_clk_o <= 0;\n    end else begin\n        if (divider > 0) begin\n            sd_clk_o <= sd_clk_o + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 1, "code": "module sd_cmd_master(\n    input  wire  clk_pad_io,\n    input  wire  rst_pad_i,\n    input  wire  new_cmd,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire  arg_reg [31:0],\n    input  wire  cmd_set_reg [13:0],\n    input  wire  timeout_reg [15:0],\n    output reg  status_reg [15:0],\n    output reg  resp_1_reg [31:0],\n    output reg  err_int_reg [3:0],\n    output reg  normal_int_reg [15:0],\n    input  wire  err_int_rst,\n    input  wire  normal_int_rst,\n    output reg  settings [15:0],\n    output reg  go_idle_o,\n    output reg  cmd_out [39:0],\n    output reg  req_out,\n    output reg  ack_out,\n    input  wire  req_in,\n    input  wire  ack_in,\n    input  wire  cmd_in [39:0],\n    input  wire  serial_status [7:0],\n    input  wire  card_detect\n);\n\n    // Debounce Logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        else\n            begin\n                if (!card_detect)\n                    begin\n                        if (debounce < 4'b1111)\n                            debounce <= debounce + 1;\n                        else\n                            card_present <= 1;\n                    end\n                else\n                    debounce <= 0;\n            end\n    end\n\n    // Request and Acknowledge Synchronizers\n    reg req_q;\n    reg ack_q;\n    reg req_in_int;\n    reg ack_in_int;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            begin\n                req_q <= 0;\n                ack_q <= 0;\n                req_in_int <= 0;\n                ack_in_int <= 0;\n            end\n        else\n            begin\n                req_q <= req_in;\n                ack_q <= ack_in;\n                req_in_int <= req_q;\n                ack_in_int <= ack_q;\n            end\n    end\n\n    // Finite State Machine (FSM)\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            state <= 3'b001; // IDLE\n        else\n            state <= next_state;\n    end\n\n    always_comb\n    begin\n        case (state)\n            3'b001: // IDLE\n                if (new_cmd)\n                    next_state = 3'b010; // SETUP\n                else\n                    next_state = 3'b001; // IDLE\n            3'b010: // SETUP\n                if (ack_in_int)\n                    next_state = 3'b100; // EXECUTE\n                else\n                    next_state = 3'b010; // SETUP\n            3'b100: // EXECUTE\n                if (complete)\n                    next_state = 3'b001; // IDLE\n                else\n                    next_state = 3'b100; // EXECUTE\n            default: // Default to IDLE\n                next_state = 3'b001; // IDLE\n        endcase\n    end\n\n    // FSM State operation\n    reg [15:0] settings;\n    reg [39:0] cmd_out;\n    reg complete;\n    reg [7:0] response_size;\n    reg [15:0] resp_1_reg;\n    reg [3:0] err_int_reg;\n    reg [15:0] normal_int_reg;\n    reg [15:0] status_reg;\n    reg [7:0] serial_status;\n    reg [39:0] cmd_in;\n    reg [7:0] card_detect;\n    reg [15:0] watchdog_cnt;\n    reg [15:0] timeout_reg;\n    reg [3:0] crc_check_enable;\n    reg [3:0] index_check_enable;\n    reg [3:0] cie;\n    reg [3:0] ccrce;\n    reg [3:0] cte;\n    reg [3:0] ei;\n    reg [3:0] cc;\n    reg [3:0] dat_ava;\n    reg [3:0] crc_valid;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            begin\n                settings <= 0;\n                cmd_out <= 0;\n                complete <= 0;\n                response_size <= 0;\n                resp_1_reg <= 0;\n                err_int_reg <= 0;\n                normal_int_reg <= 0;\n                status_reg <= 0;\n                serial_status <= 0;\n                cmd_in <= 0;\n                card_detect <= 0;\n                watchdog_cnt <= 0;\n                crc_check_enable <= 0;\n                index_check_enable <= 0;\n                cie <= 0;\n                ccrce <= 0;\n                cte <= 0;\n                ei <= 0;\n                cc <= 0;\n                dat_ava <= 0;\n                crc_valid <= 0;\n                go_idle_o <= 0;\n                req_out <= 0;\n                ack_out <= 0;\n            end\n        else\n            begin\n                case (state)\n                    3'b001: // IDLE\n                        begin\n                            go_idle_o <= 0;\n                            req_out <= 0;\n                            ack_out <= 0;\n                            CICMD <= 0;\n                            if (req_in_int)\n                                begin\n                                    status_reg <= serial_status;\n                                    ack_out <= 1;\n                                end\n                        end\n                    3'b010: // SETUP\n                        begin\n                            NORMAL_INT_REG <= 0;\n                            ERR_INT_REG <= 0;\n                            index_check_enable <= CICE;\n                            crc_check_enable <= CRCE;\n                            response_size <= (RTS == 2'b10 || RTS == 2'b11) ? small_rsp : (RTS == 2'b01 ? big_rsp : 0);\n                            cmd_out[39:38] <= 2'b01;\n                            cmd_out[37:32] <= CMDI;\n                            cmd_out[31:0] <= ARG_REG;\n                            settings[14:13] <= WORD_SELECT;\n                            settings[12] <= data_read;\n                            settings[11] <= data_write;\n                            settings[10:8] <= 3'b111;\n                            settings[7] <= CRCE;\n                            settings[6:0] <= response_size;\n                            watchdog_cnt <= 0;\n                            CICMD <= 1;\n                        end\n                    3'b100: // EXECUTE\n                        begin\n                            watchdog_cnt <= watchdog_cnt + 1;\n                            if (watchdog_cnt > timeout_reg)\n                                begin\n                                    cte <= 1;\n                                    ei <= 1;\n                                    if (ack_in)\n                                        complete <= 1;\n                                    go_idle_o <= 1;\n                                end\n                            else\n                                begin\n                                    if (ack_in_int)\n                                        begin\n                                            req_out <= 1;\n                                            while (!ack_in)\n                                                begin\n                                                    req_out <= 1;\n                                                end\n                                        end\n                                    else if (req_in_int)\n                                        begin\n                                            serial_status <= serial_status;\n                                            ack_out <= 1;\n                                            if (dat_ava)\n                                                begin\n                                                    complete <= 1;\n                                                    ei <= 0;\n                                                    if (crc_check_enable && !crc_valid)\n                                                        begin\n                                                            ccrce <= 1;\n                                                            ei <= 1;\n                                                        end\n                                                    if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32]))\n                                                        begin\n                                                            cie <= 1;\n                                                            ei <= 1;\n                                                        end\n                                                    cc <= 1;\n                                                    if (response_size != 0)\n                                                        resp_1_reg <= cmd_in[31:0];\n                                                end\n                                        end\n                                end\n                        end\n                endcase\n            end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 2, "code": "module sd_cmd_master(\n    input  wire  clk_pad_io,\n    input  wire  rst_pad_i,\n    input  wire  new_cmd,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire  [31:0] arg_reg,\n    input  wire  [13:0] cmd_set_reg,\n    input  wire  [15:0] timeout_reg,\n    output wire  [15:0] status_reg,\n    output wire  [31:0] resp_1_reg,\n    output wire  [4:0]  err_int_reg,\n    output wire  [15:0] normal_int_reg,\n    input  wire  err_int_rst,\n    input  wire  normal_int_rst,\n    output wire  [15:0] settings,\n    output wire  go_idle_o,\n    output wire  [39:0] cmd_out,\n    output wire  req_out,\n    output wire  ack_out,\n    input  wire  req    input  wire  ack_in,\n    input  wire  [39:0] cmd_in,\n    input  wire  [7:0]  serial_status,\n    input  wire  card_detect\n);\n\n    // Debounce Logic\n    reg [3:0] debounce;\n    reg card_present;\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            debounce <= 0;\n            card_present <= 0;\n        end\n        else begin\n            if (!card_detect) begin\n                if (debounce < 4'b1111) debounce <= debounce + 1;\n                else card_present <= 1;\n            end\n            else begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    reg req_q;\n    reg ack_q;\n    reg req_in_int;\n    reg ack_in_int;\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            req_q <= 0;\n            ack_q <= 0;\n        end\n        else begin\n            req_q <= req_in;\n            ack_q <= ack_in;\n        end\n    end\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            req_in_int <= 0;\n            ack_in_int <= 0;\n        end\n        else begin\n            req_in_int <= req_q;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // Finite State Machine (FSM)\n    reg [2:0] state;\n    reg [2:0] next_state;\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) state <= 3'b001;\n        else state <= next_state;\n    end\n    always_comb begin\n        case (state)\n            3'b001: begin\n                if (new_cmd) next_state = 3'b010;\n                else next_state = 3'b001;\n            end\n            3'b010: begin\n                if (ack_in_int) next_state = 3'b100;\n                else next_state = 3'b010;\n            end\n            3'b100: begin\n                if (complete) next_state = 3'b001;\n                else next_state = 3'b100;\n            end\n            default: next_state = 3'b001;\n        endcase\n    end\n\n    // FSM State operation\n    reg [15:0] settings_reg;\n    reg [39:0] cmd_out_reg;\n    reg [7:0]  response_size;\n    reg complete;\n    reg [15:0] status;\n    reg [7:0]  serial_status_reg;\n    reg [39:0] cmd_in_reg;\n    reg [15:0] resp_1_reg_reg;\n    reg [4:0]  err_int_reg_reg;\n    reg [15:0] normal_int_reg_reg;\n    reg [15:0] watchdog_cnt;\n    reg [15:0] timeout_reg_reg;\n    reg [7:0]  crc_valid;\n    reg [7:0]  dat_ava;\n    reg [7:0]  index_check_enable;\n    reg [7:0]  crc_check_enable;\n    reg [7:0]  crce;\n    reg [7:0]  cie;\n    reg [7:0]  ccrce;\n    reg [7:0]  cte;\n    reg [7:0]  ei;\n    reg [7:0]  cc;\n    reg [7:0]  go_idle_o_reg;\n    reg [7:0]  req_out_reg;\n    reg [7:0]  ack_out_reg;\n    reg [7:0]  req_in_int_reg;\n    reg [7:0]  ack_in_int_reg;\n    reg [7:0]  settings_int;\n    reg [7:0]  cmd_out_int;\n    reg [7:0]  settings_int_reg;\n    reg [7:0]  cmd_out_int_reg;\n    reg [7:0]  settings_int_reg_reg;\n    reg [7:0]  cmd_out_int_reg_reg;\n    reg [7:0]  settings_int_reg_reg_reg;\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            settings_reg <= 0;\n            cmd_out_reg <= 0;\n            response_size <= 0;\n            complete <= 0;\n            status <= 0;\n            serial_status_reg <= 0;\n            cmd_in_reg <= 0;\n            resp_1_reg_reg <= 0;\n            err_int_reg_reg <= 0;\n            normal_int_reg_reg <= 0;\n            watchdog_cnt <= 0;\n            timeout_reg_reg <= 0;\n            crc_valid <= 0;\n            dat_ava <= 0;\n            index_check_enable <= 0;\n            crc_check_enable <= 0;\n            crce <= 0;\n            cie <= 0;\n            ccrce <= 0;\n            cte <= 0;\n            ei <= 0;\n            cc <= 0;\n            go_idle_o_reg <= 0;\n            req_out_reg <= 0;\n            ack_out_reg <= 0;\n            req_in_int_reg <= 0;\n            ack_in_int_reg <= 0;\n            settings_int <= 0;\n            cmd_out_int <= 0;\n            settings_int_reg <= 0;\n            cmd_out_int_reg <= 0;\n            settings_int_reg_reg <= 0;\n            cmd_out_int_reg_reg <= 0;\n            settings_int_reg_reg_reg <= 0;\n        end\n        else begin\n            case (state)\n                3'b001: begin\n                    go_idle_o_reg <= 0;\n                    req_out_reg <= 0;\n                    ack_out_reg <= 0;\n                    CICMD <= 0;\n                    if (req_in_int_reg) begin\n                        status <= serial_status_reg;\n                        ack_out_reg <= 1;\n                    end\n                end\n                3'b010: begin\n                    index_check_enable <= cmd_set_reg[4];\n                    crc_check_enable <= cmd_set_reg[3];\n                    cmd_out_int <= {2'b01, cmd_set_reg[13:8], arg_reg};\n                    response_size <= (cmd_set_reg[1:0] == 2'b10 || cmd_set_reg[1:0] == 2'b11) ? 7'b0101000 : (cmd_set_reg[1:0] == 2'b01) ? 7'b1111111 : 0;\n                    settings_int <= {14'b1111, cmd_set_reg[7:6], data_read, data_write, 3'b111, crc_check_enable, response_size};\n                    Watchdog_Cnt <= 0;\n                end\n                3'b100: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > timeout_reg_reg) begin\n                        cte <= 1;\n                        ei <= 1;\n                        if (ack_in_reg) complete <= 1;\n                        go_idle_o_reg <= 1;\n                    end\n                    if (ack_in_int_reg) begin\n                        req_out_reg <= 1;\n                    end\n                    else if (req_in_int_reg) begin\n                        status <= serial_status_reg;\n                        ack_out_reg <= 1;\n                        if (dat_ava) begin\n                            complete <= 1;\n                            ei <= 0;\n                            if (crc_check_enable && ~crc_valid) begin\n                                ccrce <= 1;\n                                ei <= 1;\n                            end\n                            if (index_check_enable && (cmd_out_int_reg_reg != cmd_in_reg[37:32])) begin\n                                cie <= 1;\n                                ei <= 1;\n                            end\n                            cc <= 1;\n                            if (response_size != 0) begin\n                                resp_1_reg_reg <= cmd_in_reg[31:0];\n                            end\n                        end\n                    end\n                end\n                default: begin\n                    go_idle_o_reg <= 0;\n                    req_out_reg <= 0;\n                    ack_out_reg <= 0;\n                    CICMD <= 0;\n                    if (req_in_int_reg) begin\n                        status <= serial_status_reg;\n                        ack_out_reg <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output Logic\n    assign status_reg = status;\n    assign resp_1_reg = resp_1_reg_reg;\n    assign err_int_reg = {4'b0000, cte, ccrce, cie};\n    assign normal_int_reg = {15'b0000000000000000, cc};\n    assign settings = settings_int_reg_reg_reg;\n    assign go_idle_o = go_idle_o_reg;\n    assign cmd_out = cmd_out_int_reg_reg;\n    assign req_out = req_out_reg;\n    assign ack_out = ack_out_reg;\n    assign req_in_int = req_in_int_reg;\n    assign ack_in_int = ack_in_int_reg;\n    assign settings_int = settings_int_reg_reg;\n    assign cmd_out_int = cmd_out_int_reg;\n    assign settings_int_reg = settings_int_reg_reg;\n    assign cmd_out_int_reg = cmd_out_int_reg_reg;\n    assign settings_int_reg_reg = settings_int_reg_reg_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 3, "code": "module sd_cmd_master(\n    input  wire clk_pad_io,\n    input  wire rst_pad_i,\n    input  wire new_cmd,\n    input  wire data_write,\n    input  wire data_read,\n    input  wire [31:0] arg_reg,\n    input  wire [13:0] cmd_set_reg,\n    input  wire [15:0] timeout_reg,\n    output wire [15:0] status_reg,\n    output wire [31:0] resp_1_reg,\n    output wire [4:0] err_int_reg,\n    output wire [15:0] normal_int_reg,\n    input  wire err_int_rst,\n    input  wire normal_int_rst,\n    output wire [15:0] settings,\n    output wire go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire req_out,\n    output wire ack_out,\n    input  wire req_in,\n    input  wire ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0] serial_status,\n    input  wire card_detect\n);\n\n    // Debounce Logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            debounce <= 0;\n            card_present <= 0;\n        end\n        else begin\n            if (!card_detect) begin\n                if (debounce < 4'b1111) debounce <= debounce + 1;\n                else card_present <= 1;\n            end\n            else debounce <= 0;\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    reg req_q;\n    reg ack_q;\n    reg req_in_int;\n    reg ack_in_int;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            req_q <= 0;\n            ack_q <= 0;\n        end\n        else begin\n            req_q <= req_in;\n            ack_q <= ack_in;\n        end\n    end\n\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            req_in_int <= 0;\n            ack_in_int <= 0;\n        end\n        else begin\n            req_in_int <= req_q;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // Finite State Machine (FSM)\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) state <= 3'b001;\n        else state <= next_state;\n    end\n\n    always_comb begin\n        case (state)\n            3'b001: begin\n                if (new_cmd) next_state = 3'b010;\n                else next_state = 3'b001;\n            end\n            3'b010: begin\n                if (ack_in_int) next_state = 3'b100;\n                else next_state = 3'b010;\n            end\n            3'b100: begin\n                if (complete) next_state = 3'b001;\n                else next_state = 3'b100;\n            end\n            default: next_state = 3'b001;\n        endcase\n    end\n\n    // FSM State operation\n    reg [15:0] settings_reg;\n    reg [39:0] cmd_out_reg;\n    reg [7:0] response_size;\n    reg complete;\n    reg [15:0] watchdog_cnt;\n    reg [15:0] crc_check_enable;\n    reg [15:0] index_check_enable;\n    reg [15:0] crc_valid;\n    reg [15:0] dat_ava;\n    reg [15:0] resp_1_reg_reg;\n    reg [15:0] err_int_reg_reg;\n    reg [15:0] normal_int_reg_reg;\n    reg [15:0] status_reg_reg;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            settings_reg <= 0;\n            cmd_out_reg <= 0;\n            response_size <= 0;\n            complete <= 0;\n            watchdog_cnt <= 0;\n            crc_check_enable <= 0;\n            index_check_enable <= 0;\n            crc_valid <= 0;\n            dat_ava <= 0;\n            resp_1_reg_reg <= 0;\n            err_int_reg_reg <= 0;\n            normal_int_reg_reg <= 0;\n            status_reg_reg <= 0;\n        end\n        else begin\n            case (state)\n                3'b001: begin\n                    // IDLE State\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    CICMD <= 0;\n                    if (req_in_int) begin\n                        status_reg_reg <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                3'b010: begin\n                    // SETUP State\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    index_check_enable <= cmd_set_reg[4];\n                    crc_check_enable <= cmd_set_reg[3];\n                    cmd_out_reg[39:38] <= 2'b01;\n                    cmd_out_reg[37:32] <= cmd_set_reg[13:8];\n                    cmd_out_reg[31:0] <= arg_reg;\n                    response_size <= (cmd_set_reg[1:0] == 2'b10 || cmd_set_reg[1:0] == 2'b11) ? 7'b0101000 : (cmd_set_reg[1:0] == 2'b01) ? 7'b1111111 : 0;\n                    settings_reg[14:13] <= cmd_set_reg[7:6];\n                    settings_reg[12] <= data_read;\n                    settings_reg[11] <= data_write;\n                    settings_reg[10:8] <= 3'b111;\n                    settings_reg[7] <= cmd_set_reg[3];\n                    settings_reg[6:0] <= response_size;\n                    watchdog_cnt <= 0;\n                end\n                3'b100: begin\n                    // EXECUTE State\n                    if (watchdog_cnt > timeout_reg) begin\n                        CTE <= 1;\n                        EI <= 1;\n                        if (ack_in) complete <= 1;\n                        go_idle_o <= 1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                    end\n                    else if (req_in_int) begin\n                        status_reg_reg <= serial_status;\n                        ack_out <= 1;\n                        if (dat_ava) begin\n                            complete <= 1;\n                            EI <= 0;\n                            if (crc_check_enable && ~crc_valid) begin\n                                CCRCE <= 1;\n                                EI <= 1;\n                            end\n                            if (index_check_enable && (cmd_out_reg[37:32] != cmd_in[37:32])) begin\n                                CIE <= 1;\n                                EI <= 1;\n                            end\n                            CC <= 1;\n                            if (response_size != 0) begin\n                                resp_1_reg_reg <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                    watchdog_cnt <= watchdog_cnt + 1;\n                end\n                default: begin\n                    // Default to IDLE\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    CICMD <= 0;\n                end\n            endcase\n        end\n    end\n\n    // Output Logic\n    assign settings = settings_reg;\n    assign cmd_out = cmd_out_reg;\n    assign req_out = req_out;\n    assign ack_out = ack_out;\n    assign status_reg = status_reg_reg;\n    assign resp_1_reg = resp_1_reg_reg;\n    assign err_int_reg = err_int_reg_reg;\n    assign normal_int_reg = normal_int_reg_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 4, "code": "module sd_cmd_master(\n    input  wire  clk_pad_io,\n    input  wire  rst_pad_i,\n    input  wire  new_cmd,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire [31:0] arg_reg,\n    input  wire [13:0] cmd_set_reg,\n    input  wire [15:0] timeout_reg,\n    output wire [15:0] status_reg,\n    output wire [31:0] resp_1_reg,\n    output wire [4:0] err_int_reg,\n    output wire [15:0] normal_int_reg,\n    input  wire err_int_rst,\n    input  wire normal_int_rst,\n    output wire [15:0] settings,\n    output wire go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire req_out,\n    output wire ack_out,\n    input  wire req_in,\n    input  wire ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0] serial_status,\n    input  wire card_detect\n);\n\n// Debounce Logic\nreg [3:0] debounce;\nreg card_present;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        debounce <= 0;\n        card_present <= 0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce < 4'b1111) debounce <= debounce + 1;\n            else card_present <= 1;\n        end else begin\n            debounce <= 0;\n            card_present <= 0;\n        end\n    end\nend\n\n// Request and Acknowledge Synchronizers\nreg req_q;\nreg ack_q;\nreg req_in_int;\nreg ack_in_int;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        req_q <= 0;\n        ack_q <= 0;\n        req_in_int <= 0;\n        ack_in_int <= 0;\n    end else begin\n        req_q <= req_in;\n        ack_q <= ack_in;\n        req_in_int <= req_q;\n        ack_in_int <= ack_q;\n    end\nend\n\n// Finite State Machine (FSM)\nreg [2:0] state;\nreg [2:0] next_state;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        state <= 3'b001; // IDLE\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                if (new_cmd) next_state <= 3'b010; // SETUP\n                else next_state <= 3'b001;\n            3'b010: // SETUP\n                if (ack_in_int) next_state <= 3'b100; // EXECUTE\n                else next_state <= 3'b010;\n            3'b100: // EXECUTE\n                if (complete) next_state <= 3'b001; // IDLE\n                else next_state <= 3'b100;\n            default: next_state <= 3'b001; // IDLE\n        endcase\n        state <= next_state;\n    end\nend\n\n// FSM State operation\nreg [15:0] settings_reg;\nreg [39:0] cmd_out_reg;\nreg [7:0] response_size;\nreg [15:0] resp_1_reg_reg;\nreg [4:0] err_int_reg_reg;\nreg [15:0] normal_int_reg_reg;\nreg [15:0] status_reg_reg;\nreg [6:0] status_reg_reg_6;\nreg [5:0] status_reg_reg_5;\nreg complete;\nreg [3:0] watchdog_cnt;\nreg [3:0] crc_check_enable;\nreg [3:0] index_check_enable;\nreg [3:0] crce;\nreg [3:0] cie;\nreg [3:0] cte;\nreg [3:0] ei;\nreg [3:0] cc;\nreg [3:0] dat_ava;\nreg [3:0] crc_valid;\nreg [3:0] go_idle_o_reg;\nreg [3:0] req_out_reg;\nreg [3:0] ack_out_reg;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        settings_reg <= 0;\n        cmd_out_reg <= 0;\n        response_size <= 0;\n        resp_1_reg_reg <= 0;\n        err_int_reg_reg <= 0;\n        normal_int_reg_reg <= 0;\n        status_reg_reg <= 0;\n        status_reg_reg_6 <= 0;\n        status_reg_reg_5 <= 0;\n        complete <= 0;\n        watchdog_cnt <= 0;\n        crc_check_enable <= 0;\n        index_check_enable <= 0;\n        crce <= 0;\n        cie <= 0;\n        cte <= 0;\n        ei <= 0;\n        cc <= 0;\n        dat_ava <= 0;\n        crc_valid <= 0;\n        go_idle_o_reg <= 0;\n        req_out_reg <= 0;\n        ack_out_reg <= 0;\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                go_idle_o_reg <= 0;\n                req_out_reg <= 0;\n                ack_out_reg <= 0;\n                status_reg_reg <= 0;\n                status_reg_reg_6 <= 0;\n                status_reg_reg_5 <= 0;\n                if (req_in_int) begin\n                    status_reg_reg <= serial_status;\n                    ack_out_reg <= 1;\n                end\n            3'b010: // SETUP\n                settings_reg <= cmd_set_reg;\n                cmd_out_reg <= {2'b01, cmd_set_reg[13:8], arg_reg};\n                response_size <= 0;\n                if (cmd_set_reg[4]) response_size <= 7'b0101000;\n                else if (cmd_set_reg[3]) response_size <= 7'b1111111;\n                settings_reg[14:13] <= cmd_set_reg[7:6];\n                settings_reg[12] <= data_read;\n                settings_reg[11] <= data_write;\n                settings_reg[10:8] <= 3'b111;\n                settings_reg[7] <= cmd_set_reg[3];\n                settings_reg[6:0] <= response_size;\n                crc_check_enable <= cmd_set_reg[3];\n                index_check_enable <= cmd_set_reg[4];\n                watchdog_cnt <= 0;\n            3'b100: // EXECUTE\n                if (watchdog_cnt < timeout_reg) begin\n                    watchdog_cnt <= watchdog_cnt + 1;\n                    if (ack_in_int) begin\n                        complete <= 1;\n                        req_out_reg <= 1;\n                    end else if (req_in_int) begin\n                        status_reg_reg <= serial_status;\n                        ack_out_reg <= 1;\n                        if (status_reg_reg[6]) begin\n                            complete <= 1;\n                            ei <= 0;\n                        end\n                        if (crc_check_enable && ~status_reg_reg[5]) begin\n                            crce <= 1;\n                            ei <= 1;\n                        end\n                        if (index_check_enable && (cmd_out_reg[37:32] != cmd_in[37:32])) begin\n                            cie <= 1;\n                            ei <= 1;\n                        end\n                        cc <= 1;\n                        if (response_size != 0) begin\n                            resp_1_reg_reg <= cmd_in[31:0];\n                        end\n                    end\n                end else begin\n                    cte <= 1;\n                    ei <= 1;\n                    if (ack_in) complete <= 1;\n                    go_idle_o_reg <= 1;\n                end\n        endcase\n        settings <= settings_reg;\n        cmd_out <= cmd_out_reg;\n        resp_1_reg <= resp_1_reg_reg;\n        err_int_reg <= err_int_reg_reg;\n        normal_int_reg <= normal_int_reg_reg;\n        status_reg <= status_reg_reg;\n        status_reg_6 <= status_reg_reg_6;\n        status_reg_5 <= status_reg_reg_5;\n        complete <= complete;\n        watchdog_cnt <= watchdog_cnt;\n        crc_check_enable <= crc_check_enable;\n        index_check_enable <= index_check_enable;\n        crce <= crce;\n        cie <= cie;\n        cte <= cte;\n        ei <= ei;\n        cc <= cc;\n        dat_ava <= status_reg_reg[6];\n        crc_valid <= status_reg_reg[5];\n        go_idle_o <= go_idle_o_reg;\n        req_out <= req_out_reg;\n        ack_out <= ack_out_reg;\n    end\nend\n\n// Output Logic\nassign go_idle_o = go_idle_o_reg;\nassign req_out = req_out_reg;\nassign ack_out = ack_out_reg;\nassign settings = settings_reg;\nassign cmd_out = cmd_out_reg;\nassign resp_1_reg = resp_1_reg_reg;\nassign err_int_reg = err_int_reg_reg;\nassign normal_int_reg = normal_int_reg_reg;\nassign status_reg = status_reg_reg;\nassign status_reg_6 = status_reg_reg_6;\nassign status_reg_5 = status_reg_reg_5;\nassign complete = complete;\nassign watchdog_cnt = watchdog_cnt;\nassign crc_check_enable = crc_check_enable;\nassign index_check_enable = index_check_enable;\nassign crce = crce;\nassign cie = cie;\nassign cte = cte;\nassign ei = ei;\nassign cc = cc;\nassign dat_ava = status_reg_reg[6];\nassign crc_valid = status_reg_reg[5];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 5, "code": "module sd_cmd_master(\n    input  wire  clk_pad_io,\n    input  wire  rst_pad_i,\n    input  wire  new_cmd,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire [31:0] arg_reg,\n    input  wire [13:0] cmd_set_reg,\n    input  wire [15:0] timeout_reg,\n    output wire [15:0] status_reg,\n    output wire [31:0] resp_1_reg,\n    output wire [4:0] err_int_reg,\n    output wire [15:0] normal_int_reg,\n    input  wire err_int_rst,\n    input  wire normal_int_rst,\n    output wire [15:0] settings,\n    output wire go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire req_out,\n    output wire ack_out,\n    input  wire req_in,\n    input  wire ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0] serial_status,\n    input  wire card_detect\n);\n\n// Debounce Logic\nreg [3:0] debounce;\nreg card_present;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        debounce <= 0;\n        card_present <= 0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce < 4'b1111) debounce <= debounce + 1;\n            else card_present <= 1;\n        end else begin\n            debounce <= 0;\n            card_present <= 0;\n        end\n    end\nend\n\n// Request and Acknowledge Synchronizers\nreg req_q;\nreg ack_q;\nreg req_in_int;\nreg ack_in_int;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        req_q <= 0;\n        ack_q <= 0;\n        req_in_int <= 0;\n        ack_in_int <= 0;\n    end else begin\n        req_q <= req_in;\n        ack_q <= ack_in;\n        req_in_int <= req_q;\n        ack_in_int <= ack_q;\n    end\nend\n\n// Finite State Machine (FSM)\nreg [2:0] state;\nreg [2:0] next_state;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        state <= 3'b001; // IDLE\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                if (new_cmd) next_state <= 3'b010; // SETUP\n                else next_state <= 3'b001;\n            3'b010: // SETUP\n                if (ack_in_int) next_state <= 3'b100; // EXECUTE\n                else next_state <= 3'b010;\n            3'b100: // EXECUTE\n                if (complete) next_state <= 3'b001; // IDLE\n                else next_state <= 3'b100;\n            default: next_state <= 3'b001; // IDLE\n        endcase\n        state <= next_state;\n    end\nend\n\n// FSM State operation\nreg [15:0] settings_reg;\nreg [39:0] cmd_out_reg;\nreg [7:0] response_size;\nreg [15:0] resp_1_reg_reg;\nreg [4:0] err_int_reg_reg;\nreg [15:0] normal_int_reg_reg;\nreg [15:0] status_reg_reg;\nreg [6:0] status_reg_reg_6;\nreg [5:0] status_reg_reg_5;\nreg complete;\nreg [3:0] watchdog_cnt;\nreg [3:0] crc_check_enable;\nreg [3:0] index_check_enable;\nreg [3:0] crce;\nreg [3:0] cie;\nreg [3:0] cte;\nreg [3:0] ei;\nreg [3:0] cc;\nreg [3:0] dat_ava;\nreg [3:0] crc_valid;\nreg [3:0] go_idle_o_reg;\nreg [3:0] req_out_reg;\nreg [3:0] ack_out_reg;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        settings_reg <= 0;\n        cmd_out_reg <= 0;\n        response_size <= 0;\n        resp_1_reg_reg <= 0;\n        err_int_reg_reg <= 0;\n        normal_int_reg_reg <= 0;\n        status_reg_reg <= 0;\n        status_reg_reg_6 <= 0;\n        status_reg_reg_5 <= 0;\n        complete <= 0;\n        watchdog_cnt <= 0;\n        crc_check_enable <= 0;\n        index_check_enable <= 0;\n        crce <= 0;\n        cie <= 0;\n        cte <= 0;\n        ei <= 0;\n        cc <= 0;\n        dat_ava <= 0;\n        crc_valid <= 0;\n        go_idle_o_reg <= 0;\n        req_out_reg <= 0;\n        ack_out_reg <= 0;\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                go_idle_o_reg <= 0;\n                req_out_reg <= 0;\n                ack_out_reg <= 0;\n                status_reg_reg <= 0;\n                status_reg_reg_6 <= 0;\n                status_reg_reg_5 <= 0;\n                if (req_in_int) begin\n                    status_reg_reg <= serial_status;\n                    ack_out_reg <= 1;\n                end\n            3'b010: // SETUP\n                settings_reg <= cmd_set_reg;\n                cmd_out_reg <= {2'b01, cmd_set_reg[13:8], arg_reg};\n                response_size <= 0;\n                if (cmd_set_reg[4]) response_size <= 7'b0101000;\n                else if (cmd_set_reg[3]) response_size <= 7'b1111111;\n                settings_reg[14:13] <= cmd_set_reg[7:6];\n                settings_reg[12] <= data_read;\n                settings_reg[11] <= data_write;\n                settings_reg[10:8] <= 3'b111;\n                settings_reg[7] <= cmd_set_reg[3];\n                settings_reg[6:0] <= response_size;\n                crc_check_enable <= cmd_set_reg[3];\n                index_check_enable <= cmd_set_reg[4];\n                watchdog_cnt <= 0;\n            3'b100: // EXECUTE\n                if (watchdog_cnt < timeout_reg) begin\n                    watchdog_cnt <= watchdog_cnt + 1;\n                    if (ack_in_int) begin\n                        complete <= 1;\n                        req_out_reg <= 1;\n                    end else if (req_in_int) begin\n                        status_reg_reg <= serial_status;\n                        ack_out_reg <= 1;\n                        if (status_reg_reg[6]) begin\n                            complete <= 1;\n                            ei <= 0;\n                        end\n                        if (crc_check_enable && ~status_reg_reg[5]) begin\n                            crce <= 1;\n                            ei <= 1;\n                        end\n                        if (index_check_enable && (cmd_out_reg[37:32] != cmd_in[37:32])) begin\n                            cie <= 1;\n                            ei <= 1;\n                        end\n                        cc <= 1;\n                        if (response_size != 0) begin\n                            resp_1_reg_reg <= cmd_in[31:0];\n                        end\n                    end\n                end else begin\n                    cte <= 1;\n                    ei <= 1;\n                    if (ack_in) complete <= 1;\n                    go_idle_o_reg <= 1;\n                end\n        endcase\n        settings <= settings_reg;\n        cmd_out <= cmd_out_reg;\n        resp_1_reg <= resp_1_reg_reg;\n        err_int_reg <= err_int_reg_reg;\n        normal_int_reg <= normal_int_reg_reg;\n        status_reg <= status_reg_reg;\n        status_reg_6 <= status_reg_reg_6;\n        status_reg_5 <= status_reg_reg_5;\n        complete <= complete;\n        watchdog_cnt <= watchdog_cnt;\n        crc_check_enable <= crc_check_enable;\n        index_check_enable <= index_check_enable;\n        crce <= crce;\n        cie <= cie;\n        cte <= cte;\n        ei <= ei;\n        cc <= cc;\n        dat_ava <= status_reg_reg[6];\n        crc_valid <= status_reg_reg[5];\n        go_idle_o <= go_idle_o_reg;\n        req_out <= req_out_reg;\n        ack_out <= ack_out_reg;\n    end\nend\n\n// Output Logic\nassign go_idle_o = go_idle_o_reg;\nassign req_out = req_out_reg;\nassign ack_out = ack_out_reg;\nassign settings = settings_reg;\nassign cmd_out = cmd_out_reg;\nassign resp_1_reg = resp_1_reg_reg;\nassign err_int_reg = err_int_reg_reg;\nassign normal_int_reg = normal_int_reg_reg;\nassign status_reg = status_reg_reg;\nassign status_reg_6 = status_reg_reg_6;\nassign status_reg_5 = status_reg_reg_5;\nassign complete = complete;\nassign watchdog_cnt = watchdog_cnt;\nassign crc_check_enable = crc_check_enable;\nassign index_check_enable = index_check_enable;\nassign crce = crce;\nassign cie = cie;\nassign cte = cte;\nassign ei = ei;\nassign cc = cc;\nassign dat_ava = status_reg_reg[6];\nassign crc_valid = status_reg_reg[5];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 6, "code": "module sd_cmd_master(\n  input  wire  clk_pad_io,\n  input  wire  rst_pad_i,\n  input  wire  new_cmd,\n  input  wire  data_write,\n  input  wire  data_read,\n  input  wire [31:0] arg_reg,\n  input  wire [13:0] cmd_set_reg,\n  input  wire [15:0] timeout_reg,\n  output wire [15:0] status_reg,\n  output wire [31:0] resp_1_reg,\n  output wire [4:0] err_int_reg,\n  output wire [15:0] normal_int_reg,\n  input  wire err_int_rst,\n  input  wire normal_int_rst,\n  output wire [15:0] settings,\n  output wire go_idle_o,\n  output wire [39:0] cmd_out,\n  output wire req_out,\n  output wire ack_out,\n  input  wire req_in,\n  input  wire ack_in,\n  input  wire [39:0] cmd_in,\n  input  wire [7:0] serial_status,\n  input  wire card_detect\n);\n\n  // Debounce Logic\n  reg [3:0] debounce;\n  reg card_present;\n  always @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n      debounce <= 0;\n      card_present <= 0;\n    end\n    else begin\n      if (!card_detect) begin\n        if (debounce < 4'b1111) debounce <= debounce + 1;\n        else card_present <= 1;\n      end\n      else debounce <= 0;\n    end\n  end\n\n  // Request and Acknowledge Synchronizers\n  reg req_q;\n  reg ack_q;\n  reg req_in_int;\n  reg ack_in_int;\n  always @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n      req_q <= 0;\n      ack_q <= 0;\n    end\n    else begin\n      req_q <= req_in;\n      ack_q <= ack_in;\n    end\n  end\n  always @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n      req_in_int <= 0;\n      ack_in_int <= 0;\n    end\n    else begin\n      req_in_int <= req_q;\n      ack_in_int <= ack_q;\n    end\n  end\n\n  // Finite State Machine (FSM)\n  reg [2:0] state;\n  reg [2:0] next_state;\n  always @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) state <= 3'b001;\n    else state <= next_state;\n  end\n  always_comb begin\n    case (state)\n      3'b001: begin\n        if (new_cmd) next_state = 3'b010;\n        else next_state = 3'b001;\n      end\n      3'b010: begin\n        if (ack_in_int) next_state = 3'b100;\n        else next_state = 3'b010;\n      end\n      3'b100: begin\n        if (complete) next_state = 3'b001;\n        else next_state = 3'b100;\n      end\n      default: next_state = 3'b001;\n    endcase\n  end\n\n  // State Register Update\n  always @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n      status_reg <= 16'h0000;\n      resp_1_reg <= 32'h00000000;\n      err_int_reg <= 5'h00000;\n      normal_int_reg <= 16'h0000;\n      settings <= 16'h0000;\n      go_idle_o <= 0;\n      cmd_out <= 40'h0000000000000000;\n      req_out <= 0;\n      ack_out <= 0;\n      complete <= 0;\n      index_check_enable <= 0;\n      CRC_check_enable <= 0;\n      Watchdog_Cnt <= 0;\n      CCRCE <= 0;\n      EI <= 0;\n      CC <= 0;\n    end\n    else begin\n      case (state)\n        3'b001: begin\n          go_idle_o <= 0;\n          req_out <= 0;\n          ack_out <= 0;\n          CICMD <= 0;\n        end\n        3'b010: begin\n          NORMAL_INT_REG <= 0;\n          ERR_INT_REG <= 0;\n          index_check_enable <= CICE;\n          CRC_check_enable <= CRCE;\n          cmd_out <= {2'b01, CMDI, ARG_REG};\n          settings <= {WORD_SELECT, data_read, data_write, 3'b111, CRCE, response_size};\n          Watchdog_Cnt <= 0;\n        end\n        3'b100: begin\n          Watchdog_Cnt <= Watchdog_Cnt + 1;\n          if (Watchdog_Cnt > TIMEOUT_REG) begin\n            CTE <= 1;\n            EI <= 1;\n            if (ack_in) complete <= 1;\n            go_idle_o <= 1;\n          end\n          if (ack_in_int) begin\n            req_out <= 1;\n          end\n          else if (req_in_int) begin\n            status <= serial_status;\n            ack_out <= 1;\n            if (dat_ava) begin\n              complete <= 1;\n              EI <= 0;\n              if (CRC_check_enable && ~crc_valid) begin\n                CCRCE <= 1;\n                EI <= 1;\n              end\n              if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                CIE <= 1;\n                EI <= 1;\n              end\n              CC <= 1;\n              if (response_size != 0) RESP_1_REG <= cmd_in[31:0];\n            end\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 7, "code": "module sd_cmd_master(\n    input  wire clk_pad_io,\n    input  wire rst_pad_i,\n    input  wire new_cmd,\n    input  wire data_write,\n    input  wire data_read,\n    input  wire [31:0] arg_reg,\n    input  wire [13:0] cmd_set_reg,\n    input  wire [15:0] timeout_reg,\n    output wire [15:0] status_reg,\n    output wire [31:0] resp_1_reg,\n    output wire [4:0] err_int_reg,\n    output wire [15:0] normal_int_reg,\n    input  wire err_int_rst,\n    input  wire normal_int_rst,\n    output wire [15:0] settings,\n    output wire go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire req_out,\n    output wire ack_out,\n    input  wire req_in,\n    input  wire ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0] serial_status,\n    input  wire card_detect\n);\n\n    // Debounce Logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            debounce <= 0;\n            card_present <= 0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce < 4'b1111) debounce <= debounce + 1;\n                else card_present <= 1;\n            end else begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    reg req_q;\n    reg ack_q;\n    reg req_in_int;\n    reg ack_in_int;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            req_q <= 0;\n            ack_q <= 0;\n            req_in_int <= 0;\n            ack_in_int <= 0;\n        end else begin\n            req_q <= req_in;\n            ack_q <= ack_in;\n            req_in_int <= req_q;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // Finite State Machine (FSM)\n    reg [2:0] state;\n    reg [1:0] next_state;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) state <= 3'b001;\n        else begin\n            case (state)\n                3'b001: begin\n                    if (new_cmd) next_state <= 3'b010;\n                    else next_state <= 3'b001;\n                end\n                3'b010: begin\n                    if (ack_in_int) next_state <= 3'b100;\n                    else next_state <= 3'b010;\n                end\n                3'b100: begin\n                    if (complete) next_state <= 3'b001;\n                    else next_state <= 3'b100;\n                end\n                default: next_state <= 3'b001;\n            endcase\n            state <= next_state;\n        end\n    end\n\n    // FSM State operation\n    reg [15:0] settings_reg;\n    reg [39:0] cmd_out_reg;\n    reg [7:0] response_size;\n    reg complete;\n    reg [1:0] index_check_enable;\n    reg [1:0] crc_check_enable;\n    reg [1:0] crce;\n    reg [1:0] cie;\n    reg [1:0] ccrce;\n    reg [1:0] ei;\n    reg [1:0] cc;\n    reg [1:0] dat_ava;\n    reg [1:0] crc_valid;\n    reg [39:0] resp_1_reg_reg;\n    reg [15:0] watchdog_cnt;\n    reg [15:0] timeout_reg_reg;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            settings_reg <= 0;\n            cmd_out_reg <= 0;\n            response_size <= 0;\n            complete <= 0;\n            index_check_enable <= 0;\n            crc_check_enable <= 0;\n            crce <= 0;\n            cie <= 0;\n            ccrce <= 0;\n            ei <= 0;\n            cc <= 0;\n            dat_ava <= 0;\n            crc_valid <= 0;\n            resp_1_reg_reg <= 0;\n            watchdog_cnt <= 0;\n            timeout_reg_reg <= 0;\n        end else begin\n            case (state)\n                3'b001: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    CICMD <= 0;\n                    if (req_in_int) begin\n                        status_reg <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                3'b010: begin\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    index_check_enable <= cmd_set_reg[4];\n                    crc_check_enable <= cmd_set_reg[3];\n                    cmd_out_reg[39:38] <= 2'b01;\n                    cmd_out_reg[37:32] <= cmd_set_reg[13:8];\n                    cmd_out_reg[31:0] <= arg_reg;\n                    response_size <= (cmd_set_reg[1:0] == 2'b10 || cmd_set_reg[1:0] == 2'b11) ? 7'b0101000 : (cmd_set_reg[1:0] == 2'b01) ? 7'b1111111 : 0;\n                    settings_reg[14:13] <= cmd_set_reg[7:6];\n                    settings_reg[12] <= data_read;\n                    settings_reg[11] <= data_write;\n                    settings_reg[10:8] <= 3'b111;\n                    settings_reg[7] <= cmd_set_reg[3];\n                    settings_reg[6:0] <= response_size;\n                    watchdog_cnt <= 0;\n                    CICMD <= 1;\n                end\n                3'b100: begin\n                    if (watchdog_cnt > timeout_reg_reg) begin\n                        CTE <= 1;\n                        EI <= 1;\n                        if (ack_in) complete <= 1;\n                        go_idle_o <= 1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                    end else if (req_in_int) begin\n                        status_reg <= serial_status;\n                        ack_out <= 1;\n                        if (dat_ava) begin\n                            complete <= 1;\n                            EI <= 0;\n                            if (crc_check_enable && !crc_valid) begin\n                                CCRCE <= 1;\n                                EI <= 1;\n                            end\n                            if (index_check_enable && (cmd_out_reg[37:32] != cmd_in[37:32])) begin\n                                CIE <= 1;\n                                EI <= 1;\n                            end\n                            CC <= 1;\n                            if (response_size != 0) begin\n                                resp_1_reg_reg <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                    watchdog_cnt <= watchdog_cnt + 1;\n                end\n                default: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    CICMD <= 0;\n                end\n            endcase\n        end\n    end\n\n    // Output Logic\n    assign settings = settings_reg;\n    assign cmd_out = cmd_out_reg;\n    assign go_idle_o = go_idle_o;\n    assign req_out = req_out;\n    assign ack_out = ack_out;\n    assign resp_1_reg = resp_1_reg_reg;\n    assign err_int_reg = {CIE, CCRCE, CTE};\n    assign normal_int_reg = {EI, CC};\n    assign status_reg = status_reg;\n    assign watchdog_cnt = watchdog_cnt;\n    assign timeout_reg_reg = timeout_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 8, "code": "module sd_cmd_master(\n    input  wire  CLK_PAD_IO,\n    input  wire  RST_PAD_I,\n    input  wire  New_CMD,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire  [31:0] ARG_REG,\n    input  wire  [13:0] CMD_SET_REG,\n    input  wire  [15:0] TIMEOUT_REG,\n    output wire  [15:0] STATUS_REG,\n    output wire  [31:0] RESP_1_REG,\n    output wire  [4:0] ERR_INT_REG,\n    output wire  [15:0] NORMAL_INT_REG,\n    input  wire  ERR_INT_RST,\n    input  wire  NORMAL_INT_RST,\n    output wire  [15:0] settings,\n    output wire  go_idle_o,\n    output wire  [39:0] cmd_out,\n    output wire  req_out,\n    output wire  ack_out,\n    input  wire  req_in,\n    input  wire  ack_in,\n    input  wire  [39:0] cmd_in,\n    input  wire  [7:0] serial_status,\n    input  wire  card_detect\n);\n\n// Debounce Logic\nreg [3:0] debounce;\nreg card_present;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I)\nbegin\n    if (RST_PAD_I)\n    begin\n        debounce <= 0;\n        card_present <= 0;\n    end\n    else\n    begin\n        if (!card_detect)\n        begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1;\n            else\n                card_present <= 1;\n        end\n        else\n            debounce <= 0;\n    end\nend\n\n// Request and Acknowledge Synchronizers\nreg req_q;\nreg ack_q;\nreg req_in_int;\nreg ack_in_int;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I)\nbegin\n    if (RST_PAD_I)\n    begin\n        req_q <= 0;\n        ack_q <= 0;\n        req_in_int <= 0;\n        ack_in_int <= 0;\n    end\n    else\n    begin\n        req_q <= req_in;\n        ack_q <= ack_in;\n        req_in_int <= req_q;\n        ack_in_int <= ack_q;\n    end\nend\n\n// Finite State Machine (FSM)\nreg [2:0] state;\nreg [2:0] next_state;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I)\nbegin\n    if (RST_PAD_I)\n        state <= 3'b001; // IDLE\n    else\n        state <= next_state;\nend\n\nalways_comb\nbegin\n    case (state)\n        3'b001: // IDLE\n            if (New_CMD)\n                next_state = 3'b010; // SETUP\n            else\n                next_state = 3'b001; // IDLE\n        3'b010: // SETUP\n            if (ack_in_int)\n                next_state = 3'b100; // EXECUTE\n            else\n                next_state = 3'b010; // SETUP\n        3'b100: // EXECUTE\n            if (complete)\n                next_state = 3'b001; // IDLE\n            else\n                next_state = 3'b100; // EXECUTE\n        default: next_state = 3'b001; // IDLE\n    endcase\nend\n\n// FSM State operation\nreg [15:0] CRC_check_enable;\nreg complete;\nreg [31:0] RESP_1_REG;\nreg [4:0] ERR_INT_REG;\nreg [15:0] NORMAL_INT_REG;\nreg [15:0] STATUS_REG;\nreg [6:0] status;\nreg [39:0] cmd_out;\nreg [15:0] settings;\nreg [7:0] response_size;\nreg [3:0] Watchdog_Cnt;\nreg CCRCE;\nreg EI;\nreg CC;\nreg go_idle_o;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I)\nbegin\n    if (RST_PAD_I)\n    begin\n        CRC_check_enable <= 0;\n        complete <= 0;\n        RESP_1_REG <= 0;\n        ERR_INT_REG <= 0;\n        NORMAL_INT_REG <= 0;\n        STATUS_REG <= 0;\n        status <= 0;\n        cmd_out <= 0;\n        settings <= 0;\n        response_size <= 0;\n        Watchdog_Cnt <= 0;\n        CCRCE <= 0;\n        EI <= 0;\n        CC <= 0;\n        go_idle_o <= 0;\n    end\n    else\n    begin\n        case (state)\n            3'b001: // IDLE\n                begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    CICMD <= 0;\n                    if (req_in_int)\n                    begin\n                        status <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n            3'b010: // SETUP\n                begin\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n                    response_size <= (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) ? 7'b0101000 : (CMD_SET_REG[1:0] == 2'b01) ? 7'b1111111 : 0;\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CMD_SET_REG[3];\n                    settings[6:0] <= response_size;\n                    Watchdog_Cnt <= 0;\n                end\n            3'b100: // EXECUTE\n                begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG)\n                    begin\n                        CTE <= 1;\n                        EI <= 1;\n                        if (ack_in)\n                            complete <= 1;\n                        go_idle_o <= 1;\n                    end\n                    if (ack_in_int)\n                    begin\n                        req_out <= 1;\n                    end\n                    else if (req_in_int)\n                    begin\n                        status <= serial_status;\n                        ack_out <= 1;\n                        if (dat_ava)\n                        begin\n                            complete <= 1;\n                            EI <= 0;\n                            if (CRC_check_enable && ~crc_valid)\n                            begin\n                                CCRCE <= 1;\n                                EI <= 1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32]))\n                            begin\n                                CIE <= 1;\n                                EI <= 1;\n                            end\n                            CC <= 1;\n                            if (response_size != 0)\n                                RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            default: // IDLE\n                begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    CICMD <= 0;\n                    if (req_in_int)\n                    begin\n                        status <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 9, "code": "module sd_cmd_master(\n    input  wire  clk_pad_io,\n    input  wire  rst_pad_i,\n    input  wire  new_cmd,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire  [31:0] arg_reg,\n    input  wire  [13:0] cmd_set_reg,\n    input  wire  [15:0] timeout_reg,\n    output wire  [15:0] status_reg,\n    output wire  [31:0] resp_1_reg,\n    output wire  [4:0]  err_int_reg,\n    output wire  [15:0] normal_int_reg,\n    input  wire  err_int_rst,\n    input  wire  normal_int_rst,\n    output wire  [15:0] settings,\n    output wire  go_idle_o,\n    output wire  [39:0] cmd_out,\n    output wire  req_out,\n    output wire  ack_out,\n    input  wire  req_in,\n    input  wire  ack_in,\n    input  wire  [39:0] cmd_in,\n    input  wire  [7:0]  serial_status,\n    input  wire  card_detect\n);\n\n    // Debounce Logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n        begin\n            debounce <= 0;\n            card_present <= 0;\n        end\n        else\n        begin\n            if (!card_detect)\n            begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                else\n                    card_present <= 1;\n            end\n            else\n                debounce <= 0;\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    reg req_q;\n    reg ack_q;\n    reg req_in_int;\n    reg ack_in_int;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n        begin\n            req_q <= 0;\n            ack_q <= 0;\n        end\n        else\n        begin\n            req_q <= req_in;\n            ack_q <= ack_in;\n        end\n    end\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n        begin\n            req_in_int <= 0;\n            ack_in_int <= 0;\n        end\n        else\n        begin\n            req_in_int <= req_q;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // Finite State Machine (FSM)\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            state <= 3'b001;\n        else\n            state <= next_state;\n    end\n\n    always_comb\n    begin\n        case (state)\n            3'b001: next_state = (new_cmd) ? 3'b010 : 3'b001;\n            3'b010: next_state = (ack_in_int) ? 3'b100 : 3'b010;\n            3'b100: next_state = (complete) ? 3'b001 : 3'b100;\n            default: next_state = 3'b001;\n        endcase\n    end\n\n    // FSM State operation\n    reg [15:0] settings_reg;\n    reg [39:0] cmd_out_reg;\n    reg [7:0]  response_size;\n    reg [31:0] resp_1_reg_reg;\n    reg complete;\n    reg [3:0]  CIE;\n    reg [1:0]  CCRCE;\n    reg [1:0]  CTE;\n    reg [1:0]  EI;\n    reg [1:0]  CC;\n    reg [1:0]  dat_ava;\n    reg [1:0]  crc_valid;\n    reg [1:0]  RTS;\n    reg [1:0]  WORD_SELECT;\n    reg [1:0]  data_read;\n    reg [1:0]  data_write;\n    reg [1:0]  CRCE;\n    reg [1:0]  CICE;\n    reg [1:0]  index_check_enable;\n    reg [1:0]  CRC_check_enable;\n    reg [1:0]  Watchdog_Cnt;\n    reg [1:0]  go_idle_o_reg;\n    reg [1:0]  req_out_reg;\n    reg [1:0]  ack_out_reg;\n    reg [1:0]  req_in_int_reg;\n    reg [1:0]  ack_in_int_reg;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n        begin\n            settings_reg <= 0;\n            cmd_out_reg <= 0;\n            response_size <= 0;\n            resp_1_reg_reg <= 0;\n            complete <= 0;\n            CIE <= 0;\n            CCRCE <= 0;\n            CTE <= 0;\n            EI <= 0;\n            CC <= 0;\n            dat_ava <= 0;\n            crc_valid <= 0;\n            RTS <= 0;\n            WORD_SELECT <= 0;\n            data_read <= 0;\n            data_write <= 0;\n            CRCE <= 0;\n            CICE <= 0;\n            index_check_enable <= 0;\n            CRC_check_enable <= 0;\n            Watchdog_Cnt <= 0;\n            go_idle_o_reg <= 0;\n            req_out_reg <= 0;\n            ack_out_reg <= 0;\n            req_in_int_reg <= 0;\n            ack_in_int_reg <= 0;\n        end\n        else\n        begin\n            case (state)\n                3'b001: // IDLE\n                    begin\n                        go_idle_o_reg <= 0;\n                        req_out_reg <= 0;\n                        ack_out_reg <= 0;\n                        CICMD <= 0;\n                        if (req_in_int_reg)\n                        begin\n                            status_reg <= serial_status;\n                            ack_out_reg <= 1;\n                        end\n                    end\n                3'b010: // SETUP\n                    begin\n                        NORMAL_INT_REG <= 0;\n                        ERR_INT_REG <= 0;\n                        index_check_enable <= CICE;\n                        CRC_check_enable <= CRCE;\n                        response_size <= (RTS == 2'b10 || RTS == 2'b11) ? 7'b0101000 : (RTS == 2'b01) ? 7'b1111111 : 0;\n                        cmd_out_reg[39:38] <= 2'b01;\n                        cmd_out_reg[37:32] <= CMDI;\n                        cmd_out_reg[31:0] <= ARG_REG;\n                        settings_reg[14:13] <= WORD_SELECT;\n                        settings_reg[12] <= data_read;\n                        settings_reg[11] <= data_write;\n                        settings_reg[10:8] <= 3'b111;\n                        settings_reg[7] <= CRCE;\n                        settings_reg[6:0] <= response_size;\n                        Watchdog_Cnt <= 0;\n                    end\n                3'b100: // EXECUTE\n                    begin\n                        Watchdog_Cnt <= Watchdog_Cnt + 1;\n                        if (Watchdog_Cnt > TIMEOUT_REG)\n                        begin\n                            CTE <= 1;\n                            EI <= 1;\n                            if (ack_in_int_reg)\n                                complete <= 1;\n                            go_idle_o_reg <= 1;\n                        end\n                        if (ack_in_int_reg)\n                        begin\n                            req_out_reg <= 1;\n                        end\n                        else if (req_in_int_reg)\n                        begin\n                            status_reg <= serial_status;\n                            ack_out_reg <= 1;\n                            if (dat_ava)\n                            begin\n                                complete <= 1;\n                                EI <= 0;\n                                if (CRC_check_enable && ~crc_valid)\n                                begin\n                                    CCRCE <= 1;\n                                    EI <= 1;\n                                end\n                                if (index_check_enable && (cmd_out_reg[37:32] != cmd_in[37:32]))\n                                begin\n                                    CIE <= 1;\n                                    EI <= 1;\n                                end\n                                CC <= 1;\n                                if (response_size != 0)\n                                begin\n                                    resp_1_reg_reg <= cmd_in[31:0];\n                                end\n                            end\n                        end\n                    end\n            endcase\n        end\n    end\n\n    // Outputs\n    assign status_reg = status_reg;\n    assign resp_1_reg = resp_1_reg_reg;\n    assign err_int_reg = {CIE, CCRCE, CTE, EI};\n    assign normal_int_reg = {EI, CC};\n    assign settings = settings_reg;\n    assign go_idle_o = go_idle_o_reg;\n    assign cmd_out = cmd_out_reg;\n    assign req_out = req_out_reg;\n    assign ack_out = ack_out_reg;\n    assign req_in_int = req_in_int_reg;\n    assign ack_in_int = ack_in_int_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 10, "code": "module sd_cmd_master(\n    input  wire clk_pad_io,\n    input  wire rst_pad_i,\n    input  wire new_cmd,\n    input  wire data_write,\n    input  wire data_read,\n    input  wire [31:0] arg_reg,\n    input  wire [13:0] cmd_set_reg,\n    input  wire [15:0] timeout_reg,\n    output wire [15:0] status_reg,\n    output wire [31:0] resp_1_reg,\n    output wire [4:0]  err_int_reg,\n    output wire [15:0] normal_int_reg,\n    input  wire err_int_rst,\n    input  wire normal_int_rst,\n    output wire [15:0] settings,\n    output wire go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire req_out,\n    output wire ack_out,\n    input  wire req_in,\n    input  wire ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire card_detect\n);\n\n    // Debounce Logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        else\n            begin\n                if (!card_detect)\n                    begin\n                        if (debounce!= 4'b1111)\n                            debounce <= debounce + 1;\n                        else\n                            card_present <= 1;\n                    end\n                else\n                    debounce <= 0;\n            end\n    end\n\n    // Request and Acknowledge Synchronizers\n    reg req_in_int;\n    reg ack_in_int;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            begin\n                req_in_int <= 0;\n                ack_in_int <= 0;\n            end\n        else\n            begin\n                req_in_int <= req_in;\n                ack_in_int <= ack_in;\n            end\n    end\n\n    // Finite State Machine (FSM)\n    reg [2:0] state;\n    reg [15:0] settings_reg;\n    reg [39:0] cmd_out_reg;\n    reg [7:0]  response_size;\n    reg complete;\n    reg [15:0] status_reg_reg;\n    reg [31:0] resp_1_reg_reg;\n    reg [4:0]  err_int_reg_reg;\n    reg [15:0] normal_int_reg_reg;\n    reg [15:0] watchdog_cnt;\n    reg [15:0] crc_check_enable;\n    reg [15:0] index_check_enable;\n    reg [15:0] crc_valid;\n    reg [15:0] dat_ava;\n    reg [15:0] cie;\n    reg [15:0] ccrce;\n    reg [15:0] cte;\n    reg [15:0] ei;\n    reg [15:0] cc;\n    reg [15:0] go_idle_o_reg;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            begin\n                state <= 3'b001;\n                settings_reg <= 0;\n                cmd_out_reg <= 0;\n                response_size <= 0;\n                complete <= 0;\n                status_reg_reg <= 0;\n                resp_1_reg_reg <= 0;\n                err_int_reg_reg <= 0;\n                normal_int_reg_reg <= 0;\n                watchdog_cnt <= 0;\n                crc_check_enable <= 0;\n                index_check_enable <= 0;\n                crc_valid <= 0;\n                dat_ava <= 0;\n                cie <= 0;\n                ccrce <= 0;\n                cte <= 0;\n                ei <= 0;\n                cc <= 0;\n                go_idle_o_reg <= 0;\n            end\n        else\n            begin\n                case (state)\n                    3'b001: // IDLE\n                        begin\n                            if (new_cmd)\n                                state <= 3'b010;\n                            else\n                                state <= 3'b001;\n                            if (req_in_int)\n                                begin\n                                    status_reg_reg <= serial_status;\n                                    ack_out <= 1;\n                                end\n                        end\n                    3'b010: // SETUP\n                        begin\n                            settings_reg <= cmd_set_reg;\n                            cmd_out_reg <= {2'b01, cmd_set_reg[13:8], arg_reg};\n                            response_size <= response_size_reg;\n                            settings <= {settings_reg[14:13], data_read, data_write, 3'b111, crc_check_enable, index_check_enable, response_size};\n                            state <= 3'b100;\n                        end\n                    3'b100: // EXECUTE\n                        begin\n                            if (ack_in_int)\n                                state <= 3'b001;\n                            else\n                                state <= 3'b100;\n                            if (req_in_int)\n                                begin\n                                    status_reg_reg <= serial_status;\n                                    ack_out <= 1;\n                                end\n                            if (complete)\n                                begin\n                                    complete <= 0;\n                                    ei <= 0;\n                                    cte <= 0;\n                                    cc <= 1;\n                                    if (response_size!= 0)\n                                        resp_1_reg_reg <= cmd_in[31:0];\n                                end\n                            if (watchdog_cnt > timeout_reg)\n                                begin\n                                    cte <= 1;\n                                    ei <= 1;\n                                    go_idle_o_reg <= 1;\n                                end\n                            if (crc_valid)\n                                begin\n                                    ccrce <= 1;\n                                    ei <= 1;\n                                end\n                            if (cie)\n                                begin\n                                    cie <= 1;\n                                    ei <= 1;\n                                end\n                            watchdog_cnt <= watchdog_cnt + 1;\n                        end\n                    default: // IDLE\n                        begin\n                            state <= 3'b001;\n                            settings_reg <= 0;\n                            cmd_out_reg <= 0;\n                            response_size <= 0;\n                            complete <= 0;\n                            status_reg_reg <= 0;\n                            resp_1_reg_reg <= 0;\n                            err_int_reg_reg <= 0;\n                            normal_int_reg_reg <= 0;\n                            watchdog_cnt <= 0;\n                            crc_check_enable <= 0;\n                            index_check_enable <= 0;\n                            crc_valid <= 0;\n                            dat_ava <= 0;\n                            cie <= 0;\n                            ccrce <= 0;\n                            cte <= 0;\n                            ei <= 0;\n                            cc <= 0;\n                            go_idle_o_reg <= 0;\n                        end\n                endcase\n            end\n    end\n\n    // Output Logic\n    assign status_reg = status_reg_reg;\n    assign resp_1_reg = resp_1_reg_reg;\n    assign err_int_reg = err_int_reg_reg;\n    assign normal_int_reg = normal_int_reg_reg;\n    assign settings = settings_reg;\n    assign go_idle_o = go_idle_o_reg;\n    assign cmd_out = cmd_out_reg;\n    assign req_out = req_out_reg;\n    assign ack_out = ack_out_reg;\n\n    // FSM State Transitions\n    assign req_out_reg = (state == 3'b100)? 1 : 0;\n    assign ack_out_reg = (state == 3'b001)? 1 : 0;\n    assign go_idle_o_reg = (state == 3'b100 && (watchdog_cnt > timeout_reg))? 1 : 0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 11, "code": "module sd_cmd_master(\n    input  wire        clk_pad_io,\n    input  wire        rst_pad_i,\n    input  wire        new_cmd,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] arg_reg,\n    input  wire [13:0] cmd_set_reg,\n    input  wire [15:0] timeout_reg,\n    output reg [15:0] status_reg,\n    output reg [31:0] resp_1_reg,\n    output reg [5:0]  err_int_reg,\n    output reg [15:0] normal_int_reg,\n    input  wire        err_int_rst,\n    input  wire        normal_int_rst,\n    output reg [15:0] settings,\n    output reg        go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg        req_out,\n    output reg        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n    // Debounce Logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        else\n            begin\n                if (!card_detect)\n                    if (debounce < 4'b1111)\n                        debounce <= debounce + 1;\n                    else\n                        card_present <= 1;\n                else\n                    debounce <= 0;\n            end\n    end\n\n    // Request and Acknowledge Synchronizers\n    reg req_q;\n    reg ack_q;\n    reg req_in_int;\n    reg ack_in_int;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            begin\n                req_q <= 0;\n                ack_q <= 0;\n            end\n        else\n            begin\n                req_q <= req_in;\n                ack_q <= ack_in;\n            end\n    end\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            begin\n                req_in_int <= 0;\n                ack_in_int <= 0;\n            end\n        else\n            begin\n                req_in_int <= req_q;\n                ack_in_int <= ack_q;\n            end\n    end\n\n    // Finite State Machine (FSM)\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            state <= 3'b001;\n        else\n            state <= next_state;\n    end\n\n    always_comb\n    begin\n        case (state)\n            3'b001: // IDLE\n                if (new_cmd)\n                    next_state = 3'b010;\n                else\n                    next_state = 3'b001;\n            3'b010: // SETUP\n                if (ack_in_int)\n                    next_state = 3'b100;\n                else\n                    next_state = 3'b010;\n            3'b100: // EXECUTE\n                if (complete)\n                    next_state = 3'b001;\n                else\n                    next_state = 3'b100;\n            default: // Default to IDLE\n                next_state = 3'b001;\n        endcase\n    end\n\n    // FSM State operation\n    reg [6:0] status;\n    reg complete;\n    reg [3:0] Watchdog_Cnt;\n    reg [3:0] CCRCE;\n    reg [1:0] CIE;\n    reg [1:0] CTE;\n    reg [1:0] EI;\n    reg [1:0] CC;\n    reg [1:0] dat_ava;\n    reg [1:0] crc_valid;\n    reg [7:0] response_size;\n    reg [7:0] small_rsp;\n    reg [7:0] big_rsp;\n    reg [3:0] WORD_SELECT;\n    reg [1:0] RTS;\n    reg [1:0] CRCE;\n    reg [1:0] CICE;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            begin\n                status <= 0;\n                complete <= 0;\n                Watchdog_Cnt <= 0;\n                CCRCE <= 0;\n                CIE <= 0;\n                CTE <= 0;\n                EI <= 0;\n                CC <= 0;\n                dat_ava <= 0;\n                crc_valid <= 0;\n                response_size <= 0;\n                small_rsp <= 0;\n                big_rsp <= 0;\n                WORD_SELECT <= 0;\n                RTS <= 0;\n                CRCE <= 0;\n                CICE <= 0;\n            end\n        else\n            begin\n                case (state)\n                    3'b001: // IDLE\n                        begin\n                            if (req_in_int)\n                                status <= serial_status;\n                            ack_out <= 1;\n                        end\n                    3'b010: // SETUP\n                        begin\n                            NORMAL_INT_REG <= 0;\n                            ERR_INT_REG <= 0;\n                            index_check_enable <= CICE;\n                            CRC_check_enable <= CRCE;\n                            cmd_out <= {2'b01, CMDI, ARG_REG};\n                            response_size <= (RTS == 2'b10 || RTS == 2'b11) ? small_rsp : (RTS == 2'b01 ? big_rsp : 0);\n                            settings <= {WORD_SELECT, data_read, data_write, 3'b111, CRCE, response_size};\n                            Watchdog_Cnt <= 0;\n                        end\n                    3'b100: // EXECUTE\n                        begin\n                            Watchdog_Cnt <= Watchdog_Cnt + 1;\n                            if (Watchdog_Cnt > timeout_reg)\n                                begin\n                                    CTE <= 1;\n                                    EI <= 1;\n                                    if (ack_in)\n                                        complete <= 1;\n                                    go_idle_o <= 1;\n                                end\n                            else if (ack_in_int)\n                                begin\n                                    req_out <= 1;\n                                end\n                            else if (req_in_int)\n                                begin\n                                    status <= serial_status;\n                                    ack_out <= 1;\n                                    if (dat_ava)\n                                        begin\n                                            complete <= 1;\n                                            EI <= 0;\n                                            if (!crc_valid)\n                                                CCRCE <= 1;\n                                            if (CICE && (cmd_out[37:32] != cmd_in[37:32]))\n                                                CIE <= 1;\n                                            CC <= 1;\n                                            if (response_size != 0)\n                                                RESP_1_REG <= cmd_in[31:0];\n                                        end\n                                end\n                        end\n                    default: // Default to IDLE\n                        begin\n                            NORMAL_INT_REG <= 0;\n                            ERR_INT_REG <= 0;\n                            index_check_enable <= 0;\n                            CRC_check_enable <= 0;\n                            cmd_out <= 0;\n                            response_size <= 0;\n                            settings <= 0;\n                            Watchdog_Cnt <= 0;\n                        end\n                endcase\n            end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 1, "code": "module sd_cmd_serial_host(\n    input  wire  SD_CLK_IN,\n    input  wire  RST_IN,\n    input  wire  [15:0] SETTING_IN,\n    input  wire  [39:0] CMD_IN,\n    input  wire  REQ_IN,\n    input  wire  ACK_IN,\n    input  wire  cmd_dat_i,\n    output wire  [39:0] CMD_OUT,\n    output wire  ACK_OUT,\n    output wire  REQ_OUT,\n    output wire  [7:0] STATUS,\n    output wire  cmd_oe_o,\n    output wire  cmd_out_o,\n    output wire  st_dat_t\n);\n\n    // Internal signals\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg [2:0] Delay_Cnt;\n    reg [7:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg [1:0] Write_Read;\n    reg [1:0] Write_Only;\n    reg [1:0] word_select;\n    reg [1:0] FSM_ACK;\n    reg [1:0] DECODER_ACK;\n    reg [1:0] q;\n    reg [1:0] Req_internal_in;\n    reg [1:0] q1;\n    reg [1:0] Ack_internal_in;\n    reg [1:0] CRC_Enable;\n    reg [1:0] CRC_RST;\n    reg [7:0] CRC_VAL;\n    reg [7:0] CRC_IN;\n    reg [1:0] CRC_OUT;\n    reg [1:0] Crc_Buffering;\n    reg [1:0] CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [1:0] st_dat_t;\n\n    // FSM_COMBO\n    always_comb begin\n        case(state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY) next_state = IDLE;\n                else next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1) next_state = DLY_WR;\n                else next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1) next_state = DLY_WO;\n                else next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i) next_state = READ_WR;\n                else next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler) next_state = ACK_WO;\n                else next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= Response_Size + EIGHT_PAD) next_state = DLY_READ;\n                else next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in) next_state = ACK_WR;\n                else next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // REQ_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else begin\n            if (Req_internal_in) begin\n                Response_Size <= SETTING_IN[6:0];\n                CRC_Check_On <= SETTING_IN[7];\n                Delay_Cycler <= SETTING_IN[10:8];\n                block_write <= SETTING_IN[11];\n                block_read <= SETTING_IN[12];\n                word_select <= SETTING_IN[14:13];\n                In_Buff <= CMD_IN;\n                if (SETTING_IN[6:0] > 0) begin\n                    Write_Read <= 1;\n                    Write_Only <= 0;\n                end else begin\n                    Write_Read <= 0;\n                    Write_Only <= 1;\n                end\n                DECODER_ACK <= 0;\n            end else begin\n                DECODER_ACK <= 1;\n                Write_Read <= 0;\n                Write_Only <= 0;\n            end\n        end\n    end\n\n    // FSM_OUT\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case(state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    STATUS <= 0;\n                    CRC_Valid <= 0;\n                end\n                WRITE_WR: begin\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Bit_Nr > 8) begin\n                            CMD_OUT <= CMD_OUT[39:1] & {1'b0, cmd_dat_i};\n                            if (Bit_Nr > 9) begin\n                                CRC_OUT <= CRC_OUT[6:0] & {1'b0, cmd_dat_i};\n                            end\n                        end else if (Bit_Nr <= 8 && Bit_Nr >= 2) begin\n                            CRC_OUT <= CRC_OUT[6:0] & {1'b0, cmd_dat_i};\n                            st_dat_t <= {st_dat_t[1:0], cmd_dat_i};\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39:32];\n                    end\n                end\n                WRITE_WO: begin\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmdoe_o <= 1;\n                        if (Bit_Nr > 8) begin\n                            CMD_OUT <= CMD_OUT[39:1] & {1'b0, cmd_dat_i};\n                            if (Bit_Nr > 9) begin\n                                CRC_OUT <= CRC_OUT[6:0] & {1'b0, cmd_dat_i};\n                            end\n                        end else if (Bit_Nr <= 8 && Bit_Nr >= 2) begin\n                            CRC_OUT <= CRC_OUT[6:0] & {1'b0, cmd_dat_i};\n                            st_dat_t <= {st_dat_t[1:0], cmd_dat_i};\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39:32];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    STATUS <= 0;\n                    CRC_Valid <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    STATUS <= 0;\n                    CRC_Valid <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_Enable <= 0;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[Cmd_Cnt*8+7:Cmd_Cnt*8] <= cmd_dat_i;\n                        CRC_IN <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= {st_dat_t[1:0], block_read, block_write};\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    CMD_OUT <= Out_Buff;\n                    Crc_Buffering <= 0;\n                    STATUS <= 0;\n                    CRC_Valid <= 0;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n                default: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    STATUS <= 0;\n                    CRC_Valid <= 0;\n                end\n            endcase\n        end\n    end\n\n    // sd_crc_7\n    sd_crc_7 sd_crc_7_module(\n        .BITVAL(cmd_dat_i),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_OUT)\n    );\n\n    // Assign outputs\n    CMD_OUT <= Out_Buff;\n    ACK_OUT <= FSM_ACK;\n    REQ_OUT <= REQ_OUT;\n    STATUS <= STATUS;\n    cmd_oe_o <= cmd_oe_o;\n    cmd_out_o <= cmd_out_o;\n    st_dat_t <= st_dat_t;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 2, "code": "module sd_cmd_serial_host(\n    input  wire  SD_CLK_IN,\n    input  wire  RST_IN,\n    input  wire  [15:0] SETTING_IN,\n    input  wire  [39:0] CMD_IN,\n    input  wire  REQ_IN,\n    input  wire  ACK_IN,\n    input  wire  cmd_dat_i,\n    output wire  [39:0] CMD_OUT,\n    output wire  ACK_OUT,\n    output wire  REQ_OUT,\n    output wire  [7:0] STATUS,\n    output wire  cmd_oe_o,\n    output wire  cmd_out_o,\n    output wire  st_dat_t\n);\n\n    // Internal signals\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg [2:0] Delay_Cnt;\n    reg [7:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg [1:0] Write_Read;\n    reg [1:0] Write_Only;\n    reg [5:0] word_select_counter;\n    reg [1:0] block_write;\n    reg [1:0] block_read;\n    reg [1:0] word_select;\n    reg [1:0] FSM_ACK;\n    reg [1:0] DECODER_ACK;\n    reg [1:0] q;\n    reg [1:0] Req_internal_in;\n    reg [1:0] q1;\n    reg [1:0] Ack_internal_in;\n    reg [1:0] CRC_RST;\n    reg [7:0] CRC_VAL;\n    reg [7:0] CRC_IN;\n    reg [1:0] CRC_Enable;\n    reg [1:0] CRC_OUT;\n    reg [1:0] CRC_Check_On;\n    reg [1:0] Crc_Buffering;\n    reg [1:0] CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg [1:0] st_dat_t;\n\n    // FSM_COMBO\n    always_comb begin\n        case(state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY) next_state = IDLE;\n                else next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1) next_state = DLY_WR;\n                else next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1) next_state = DLY_WO;\n                else next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i) next_state = READ_WR;\n                else next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler) next_state = ACK_WO;\n                else next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= Response_Size + EIGHT_PAD) next_state = DLY_READ;\n                else next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in) next_state = ACK_WR;\n                else next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end\n        else state <= next_state;\n    end\n\n    // REQ_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n        end\n        else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end\n        else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end\n        else begin\n            if (Req_internal_in) begin\n                Response_Size <= SETTING_IN[6:0];\n                CRC_Check_On <= SETTING_IN[7];\n                Delay_Cycler <= SETTING_IN[10:8];\n                block_write <= SETTING_IN[11];\n                block_read <= SETTING_IN[12];\n                word_select <= SETTING_IN[14:13];\n                In_Buff <= CMD_IN;\n                if (SETTING_IN[6:0] > 0) begin\n                    Write_Read <= 1;\n                    Write_Only <= 0;\n                end\n                else begin\n                    Write_Read <= 0;\n                    Write_Only <= 1;\n                end\n                DECODER_ACK <= 0;\n            end\n            else begin\n                DECODER_ACK <= 1;\n                Write_Read <= 0;\n                Write_Only <= 0;\n            end\n        end\n    end\n\n    // FSM_OUT\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end\n        else begin\n            case(state)\n                INIT: begin\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    st_dat_t <= 0;\n                end\n                WRITE_WR: begin\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        CRC_RST <= 0;\n                        CRC_Enable <= 1;\n                    end\n                    if (Cmd_Cnt < SEND_SIZE) begin\n                        if (Crc_Buffering == 1) begin\n                            cmd_oe_o <= 1;\n                            cmd_out_o <= 1;\n                            if (Bit_Nr > 8) begin\n                                cmd_out_o <= cmd_dat_i;\n                                if (Bit_Nr > 9) begin\n                                    CRC_OUT <= CRC_OUT | (CRC_VAL << 1);\n                                end\n                            end\n                            else if (Bit_Nr <= 8 && Bit_Nr >= 2) begin\n                                CRC_OUT <= CRC_OUT | (cmd_dat_i << 1);\n                                st_dat_t <= st_dat_t | (cmd_dat_i << 1);\n                            end\n                            else begin\n                                cmd_out_o <= 1;\n                            end\n                            Bit_Nr <= Bit_Nr + 1;\n                        end\n                        else begin\n                            Crc_Buffering <= 1;\n                            CRC_OUT <= In_Buff[7];\n                        end\n                        In_Buff <= In_Buff << 1;\n                        In_Buff[39] <= 0;\n                    end\n                    else begin\n                        CRC_RST <= 1;\n                        CRC_Enable <= 0;\n                        cmd_oe_o <= 0;\n                        cmd_out_o <= 0;\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                WRITE_WO: begin\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0010;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        CRC_RST <= 0;\n                        CRC_Enable <= 1;\n                    end\n                    if (Cmd_Cnt < SEND_SIZE) begin\n                        if (Crc_Buffering == 1) begin\n                            cmd_oe_o <= 1;\n                            cmd_out_o <= 1;\n                            if (Bit_Nr > 8) begin\n                                cmd_out_o <= cmd_dat_i;\n                                if (Bit_Nr > 9) begin\n                                    CRC_OUT <= CRC_OUT | (CRC_VAL << 1);\n                                end\n                            end\n                            else if (Bit_Nr <= 8 && Bit_Nr >= 2) begin\n                                CRC_OUT <= CRC_OUT | (cmd_dat_i << 1);\n                                st_dat_t <= st_dat_t | (cmd_dat_i << 1);\n                            end\n                            else begin\n                                cmd_out_o <= 1;\n                            end\n                            Bit_Nr <= Bit_Nr + 1;\n                        end\n                        else begin\n                            Crc_Buffering <= 1;\n                            CRC_OUT <= In_Buff[7];\n                        end\n                        In_Buff <= In_Buff << 1;\n                        In_Buff[39] <= 0;\n                    end\n                    else begin\n                        CRC_RST <= 1;\n                        CRC_Enable <= 0;\n                        cmd_oe_o <= 0;\n                        cmd_out_o <= 0;\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0011;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                READ_WR: begin\n                    if (Cmd_Cnt == 1) begin\n                        STATUS <= 16'b0000_0000_0000_0101;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        CRC_RST <= 0;\n                        CRC_Enable <= 1;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        if (Crc_Buffering == 1) begin\n                            cmd_oe_o <= 1;\n                            cmd_out_o <= 1;\n                            cmd_out_o <= cmd_dat_i;\n                            CRC_IN <= cmd_dat_i;\n                        end\n                        else begin\n                            Crc_Buffering <= 1;\n                            CRC_IN <= In_Buff[7];\n                        end\n                        In_Buff <= In_Buff << 1;\n                        In_Buff[39] <= 0;\n                    end\n                    else begin\n                        if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end\n                        else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end\n                        else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n                default: begin\n                    FSM_ACK <= 1;\n                end\n            endcase\n        end\n    end\n\n    // sd_crc_7\n    sd_crc_7 sd_crc_7_inst(\n        .BITVAL(cmd_dat_i),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(RST_IN),\n        .CRC(CRC_OUT)\n    );\n\n    // Assign outputs\n    CMD_OUT <= Out_Buff;\n    ACK_OUT <= FSM_ACK;\n    REQ_OUT <= REQ_OUT;\n    STATUS <= STATUS;\n    cmd_oe_o <= cmd_oe_o;\n    cmd_out_o <= cmd_out_o;\n    st_dat_t <= st_dat_t;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 3, "code": "module sd_cmd_serial_host(\n    input  wire  SD_CLK_IN,\n    input  wire  RST_IN,\n    input  wire  [15:0] SETTING_IN,\n    input  wire  [39:0] CMD_IN,\n    input  wire  REQ_IN,\n    input  wire  ACK_IN,\n    input  wire  cmd_dat_i,\n    output wire  [39:0] CMD_OUT,\n    output wire  ACK_OUT,\n    output wire  REQ_OUT,\n    output wire  [7:0] STATUS,\n    output wire  cmd_oe_o,\n    output wire  cmd_out_o,\n    output wire  st_dat_t\n);\n\n    // FSM state machine\n    reg [9:0] state;\n    reg [9:0] next_state;\n\n    // FSM state transition table\n    always_comb begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY) next_state = IDLE;\n                else next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1) next_state = DLY_WR;\n                else next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1) next_state = DLY_WO;\n                else next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i) next_state = READ_WR;\n                else next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler) next_state = ACK_WO;\n                else next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= Response_Size + EIGHT_PAD) next_state = DLY_READ;\n                else next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in) next_state = ACK_WR;\n                else next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: next_state = INIT;\n        end\n    end\n\n    // FSM state machine\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // FSM output logic\n    always_comb begin\n        case (state)\n            INIT: begin\n                cmd_oe_o = 1;\n                cmd_out_o = 1;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 0;\n                st_dat_t = 0;\n            end\n            IDLE: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 0;\n                st_dat_t = 0;\n            end\n            WRITE_WR: begin\n                cmd_oe_o = 1;\n                cmd_out_o = 1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 0;\n                REQ_OUT = 1;\n                STATUS = 16'b0000_0000_0000_0001;\n                st_dat_t = 2'b11;\n            end\n            WRITE_WO: begin\n                cmd_oe_o = 1;\n                cmd_out_o = 1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 0;\n                REQ_OUT = 1;\n                STATUS = 16'b0000_0000_0000_0010;\n                st_dat_t = 2'b01;\n            end\n            DLY_WR: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_0011;\n                st_dat_t = 2'b11;\n            end\n            DLY_WO: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_0100;\n                st_dat_t = 2'b01;\n            end\n            READ_WR: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 1;\n                STATUS = 16'b0000_0000_0000_0101;\n                st_dat_t = 2'b11;\n            end\n            DLY_READ: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_0110;\n                st_dat_t = 2'b11;\n            end\n            ACK_WO: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_0111;\n                st_dat_t = 2'b11;\n            end\n            ACK_WR: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_1000;\n                st_dat_t = 2'b11;\n            end\n            default: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 0;\n                st_dat_t = 0;\n            end\n        end\n    end\n\n    // Command decoder\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler = 0;\n            Response_Size = 0;\n            DECODER_ACK = 0;\n            Write_Read = 0;\n            Write_Only = 0;\n            CRC_Check_On = 0;\n            In_Buff = 0;\n            block_write = 0;\n            block_read = 0;\n            word_select = 0;\n        end else begin\n            if (Req_internal_in) begin\n                Response_Size = SETTING_IN[6:0];\n                CRC_Check_On = SETTING_IN[7];\n                Delay_Cycler = SETTING_IN[10:8];\n                block_write = SETTING_IN[11];\n                block_read = SETTING_IN[12];\n                word_select = SETTING_IN[14:13];\n                In_Buff = CMD_IN;\n                if (SETTING_IN[6:0] > 0) begin\n                    Write_Read = 1;\n                    Write_Only = 0;\n                end else begin\n                    Write_Read = 0;\n                    Write_Only = 1;\n                end\n                DECODER_ACK = 0;\n            end else begin\n                if (DECODER_ACK) begin\n                    Write_Read = 0;\n                    Write_Only = 0;\n                    DECODER_ACK = 1;\n                end\n            end\n        end\n    end\n\n    // Synchronization of REQ_IN\n    reg q;\n    reg Req_internal_in;\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q = 0;\n            Req_internal_in = 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // Synchronization of ACK_IN\n    reg q1;\n    reg Ack_internal_in;\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 = 0;\n            Ack_internal_in = 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // FSM combo logic\n    always_comb begin\n        case (state)\n            INIT: begin\n                next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            end\n            IDLE: begin\n                next_state = (Write_Read) ? WRITE_WR : (Write_Only) ? WRITE_WO : IDLE;\n            end\n            WRITE_WR: begin\n                next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            end\n            WRITE_WO: begin\n                next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            end\n            DLY_WR: begin\n                next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            end\n            DLY_WO: begin\n                next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            end\n            READ_WR: begin\n                next_state = (Cmd_Cnt >= Response_Size + EIGHT_PAD) ? DLY_READ : READ_WR;\n            end\n            DLY_READ: begin\n                next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = INIT;\n            end\n        end\n    end\n\n    // FSM output logic\n    always_comb begin\n        case (state)\n            INIT: begin\n                cmd_oe_o = 1;\n                cmd_out_o = 1;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 0;\n                st_dat_t = 0;\n            end\n            IDLE: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 0;\n                st_dat_t = 0;\n            end\n            WRITE_WR: begin\n                cmd_oe_o = 1;\n                cmd_out_o = 1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 0;\n                REQ_OUT = 1;\n                STATUS = 16'b0000_0000_0000_0001;\n                st_dat_t = 2'b11;\n            end\n            WRITE_WO: begin\n                cmd_oe_o = 1;\n                cmd_out_o = 1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 0;\n                REQ_OUT = 1;\n                STATUS = 16'b0000_0000_0000_0010;\n                st_dat_t = 2'b01;\n            end\n            DLY_WR: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_0011;\n                st_dat_t = 2'b11;\n            end\n            DLY_WO: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_0100;\n                st_dat_t = 2'b01;\n            end\n            READ_WR: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 1;\n                STATUS = 16'b0000_0000_0000_0101;\n                st_dat_t = 2'b11;\n            end\n            DLY_READ: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_0110;\n                st_dat_t = 2'b11;\n            end\n            ACK_WO: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_0111;\n                st_dat_t = 2'b11;\n            end\n            ACK_WR: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_1000;\n                st_dat_t = 2'b11;\n            end\n            default: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 0;\n                st_dat_t = 0;\n            end\n        end\n    end\n\n    // FSM state machine\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // FSM output logic\n    always_comb begin\n        case (state)\n            INIT: begin\n                cmd_oe_o = 1;\n                cmd_out_o = 1;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 0;\n                st_dat_t = 0;\n            end\n            IDLE: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 0;\n                st_dat_t = 0;\n            end\n            WRITE_WR: begin\n                cmd_oe_o = 1;\n                cmd_out_o = 1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 0;\n                REQ_OUT = 1;\n                STATUS = 16'b0000_0000_0000_0001;\n                st_dat_t = 2'b11;\n            end\n            WRITE_WO: begin\n                cmd_oe_o = 1;\n                cmd_out_o = 1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 0;\n                REQ_OUT = 1;\n                STATUS = 16'b0000_0000_0000_0010;\n                st_dat_t = 2'b01;\n            end\n            DLY_WR: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_0011;\n                st_dat_t = 2'b11;\n            end\n            DLY_WO: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_0100;\n                st_dat_t = 2'b01;\n            end\n            READ_WR: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 1;\n                STATUS = 16'b0000_0000_0000_0101;\n                st_dat_t = 2'b11;\n            end\n            DLY_READ: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_0110;\n                st_dat_t = 2'b11;\n            end\n            ACK_WO: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_0111;\n                st_dat_t = 2'b11;\n            end\n            ACK_WR: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 16'b0000_0000_0000_1000;\n                st_dat_t = 2'b11;\n            end\n            default: begin\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                CMD_OUT = 0;\n                ACK_OUT = 0;\n                REQ_OUT = 0;\n                STATUS = 0;\n                st_dat_t = 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 4, "code": "module sd_cmd_serial_host(\n    input  wire sd_clk_i_pad,\n    input  wire rst_i_pad,\n    input  wire [15:0] setting_in,\n    input  wire [39:0] cmd_in,\n    input  wire req_in,\n    input  wire ack_in,\n    input  wire cmd_dat_i,\n    output reg [39:0] cmd_out,\n    output reg ack_out,\n    output reg req_out,\n    output reg [7:0] status,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal signals\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg [2:0] delay_cycler;\n    reg [6:0] response_size;\n    reg [2:0] delay_cnt;\n    reg [39:0] in_buff;\n    reg [39:0] out_buff;\n    reg [1:0] word_select;\n    reg [1:0] block_read;\n    reg [1:0] block_write;\n    reg [1:0] write_read;\n    reg [1:0] write_only;\n    reg [1:0] crc_check_on;\n    reg [1:0] crc_valid;\n    reg [1:0] crc_buffering;\n    reg [1:0] crc_out;\n    reg [1:0] crc_in;\n    reg [1:0] crc_val;\n    reg [1:0] crc_enable;\n    reg [1:0] fsm_ack;\n    reg [1:0] decoder_ack;\n    reg [1:0] req_internal_in;\n    reg [1:0] ack_internal_in;\n    reg [1:0] q;\n    reg [1:0] q1;\n\n    // FSM_COMBO\n    always_comb begin\n        case(state)\n            INIT: begin\n                if (cmd_cnt >= init_delay) next_state = IDLE;\n                else next_state = INIT;\n            end\n            IDLE: begin\n                if (write_read) next_state = WRITE_WR;\n                else if (write_only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (cmd_cnt >= send_size - 1) next_state = DLY_WR;\n                else next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (cmd_cnt >= send_size - 1) next_state = DLY_WO;\n                else next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (delay_cnt >= ncr &&!cmd_dat_i) next_state = READ_WR;\n                else next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (delay_cnt >= delay_cycler) next_state = ACK_WO;\n                else next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (cmd_cnt >= response_size + eight_pad) next_state = DLY_READ;\n                else next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (ack_internal_in) next_state = ACK_WR;\n                else next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = INIT;\n            end\n        endcase\n    end\n\n    // FSM_SEQ\n    always_ff @(posedge sd_clk_i_pad or posedge rst_i_pad) begin\n        if (rst_i_pad) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // REQ_SYNC\n    always_ff @(posedge sd_clk_i_pad or posedge rst_i_pad) begin\n        if (rst_i_pad) begin\n            req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= req_in;\n            req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC\n    always_ff @(posedge sd_clk_i_pad or posedge rst_i_pad) begin\n        if (rst_i_pad) begin\n            ack_internal_in <= 0;\n            q1 <= 0;\n        end else begin\n            q1 <= ack_in;\n            ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always_ff @(posedge sd_clk_i_pad or posedge rst_i_pad) begin\n        if (rst_i_pad) begin\n            delay_cycler <= 0;\n            response_size <= 0;\n            decoder_ack <= 0;\n            write_read <= 0;\n            write_only <= 0;\n            crc_check_on <= 0;\n            in_buff <= 0;\n            block_read <= 0;\n            block_write <= 0;\n            word_select <= 0;\n        end else begin\n            if (req_internal_in) begin\n                response_size <= setting_in[6:0];\n                crc_check_on <= setting_in[7];\n                delay_cycler <= setting_in[10:8];\n                block_write <= setting_in[11];\n                block_read <= setting_in[12];\n                word_select <= setting_in[14:13];\n                in_buff <= cmd_in;\n                if (response_size > 0) write_read <= 1;\n                else write_only <= 1;\n                decoder_ack <= 0;\n            end else if (decoder_ack) begin\n                write_read <= 0;\n                write_only <= 0;\n                decoder_ack <= 1;\n            end\n        end\n    end\n\n    // FSM_OUT\n    always_ff @(posedge sd_clk_i_pad or posedge rst_i_pad) begin\n        if (rst_i_pad) begin\n            crc_enable <= 0;\n            word_select_counter <= 0;\n            delay_cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            out_buff <= 0;\n            fsm_ack <= 1;\n            req_out <= 0;\n            crc_out <= 0;\n            crc_in <= 0;\n            crc_valid <= 0;\n            status <= 0;\n            cmd_cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case(state)\n                INIT: begin\n                    cmd_cnt <= cmd_cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    delay_cnt <= 0;\n                    cmd_cnt <= 0;\n                    out_buff <= 0;\n                    fsm_ack <= 1;\n                    req_out <= 0;\n                    crc_out <= 0;\n                    crc_in <= 0;\n                    crc_valid <= 0;\n                    status <= 0;\n                    st_dat_t <= 0;\n                end\n                WRITE_WR: begin\n                    if (cmd_cnt == 0) begin\n                        status <= 16'b0000_0000_0000_0001;\n                        req_out <= 1;\n                    end else if (ack_internal_in) begin\n                        req_out <= 0;\n                    end\n                    if (crc_buffering) begin\n                        cmd_oe_o <= 1;\n                        if (bit_nr > 8) begin\n                            transmit_cmd_bits();\n                        end else if (bit_nr > 9) begin\n                            manage_crc_output();\n                        end else if (bit_nr <= 8 && bit_nr >= 2) begin\n                            transmit_crc_bits();\n                            update_st_dat_t();\n                        end else begin\n                            maintain_cmd_line_high();\n                        end\n                        cmd_cnt <= cmd_cnt + 1;\n                    end else begin\n                        preload_crc();\n                        assign_crc_out();\n                    end\n                end\n                WRITE_WO: begin\n                    if (cmd_cnt == 0) begin\n                        status <= 4'b0010;\n                        req_out <= 1;\n                    end else if (ack_internal_in) begin\n                        req_out <= 0;\n                    end\n                    if (crc_buffering) begin\n                        cmd_oe_o <= 1;\n                        transmit_cmd_bits();\n                        set_st_dat_t();\n                        cmd_cnt <= cmd_cnt + 1;\n                    end else begin\n                        preload_crc();\n                        assign_crc_out();\n                    end\n                end\n                DLY_WR: begin\n                    if (delay_cnt == 0) begin\n                        status <= 4'b0011;\n                        req_out <= 1;\n                    end else if (ack_internal_in) begin\n                        req_out <= 0;\n                    end\n                    disable_crc();\n                    reset_cmd_cnt();\n                    cmd_oe_o <= 0;\n                    if (delay_cnt < 3'b111) begin\n                        delay_cnt <= delay_cnt + 1;\n                    end\n                    disable_crc_buffering();\n                end\n                DLY_WO: begin\n                    if (delay_cnt == 0) begin\n                        status <= 4'b0100;\n                        status <= status | (1 << 5);\n                        status <= status | (1 << 6);\n                        req_out <= 1;\n                    end else if (ack_internal_in) begin\n                        req_out <= 0;\n                    end\n                    disable_crc();\n                    reset_cmd_cnt();\n                    cmd_oe_o <= 0;\n                    delay_cnt <= delay_cnt + 1;\n                    disable_crc_buffering();\n                end\n                READ_WR: begin\n                    reset_delay_cnt();\n                    disable_crc_reset();\n                    enable_crc();\n                    deassert_cmd_oe_o();\n                    if (cmd_cnt == 1) begin\n                        status <= 4'b0101;\n                        req_out <= 1;\n                        out_buff <= out_buff | (1 << 39);\n                    end else if (ack_internal_in) begin\n                        req_out <= 0;\n                    end\n                    if (cmd_cnt < response_size) begin\n                        capture_incoming_data();\n                        assign_crc_out();\n                    end else if ((cmd_cnt - response_size) <= 6) begin\n                        assign_crc_in();\n                        disable_crc();\n                    end else begin\n                        validate_crc();\n                        update_st_dat_t();\n                        cmd_cnt <= cmd_cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (delay_cnt == 0) begin\n                        status <= 4'b0110;\n                        status <= status | (crc_valid << 5);\n                        status <= status | (1 << 6);\n                        req_out <= 1;\n                    end else if (ack_internal_in) begin\n                        req_out <= 0;\n                    end\n                    disable_crc();\n                    reset_cmd_cnt();\n                    cmd_oe_o <= 0;\n                    assign_cmd_out();\n                    delay_cnt <= delay_cnt + 1;\n                end\n                ACK_WO: begin\n                    fsm_ack <= 1;\n                end\n                ACK_WR: begin\n                    fsm_ack <= 1;\n                    deassert_req_out();\n                end\n                default: begin\n                    state <= INIT;\n                end\n            endcase\n        end\n    end\n\n    // sd_crc_7\n    sd_crc_7 sd_crc_7_instance(\n       .bitval(cmd_dat_i),\n       .enable(crc_enable),\n       .clk(sd_clk_i_pad),\n       .rst(rst_i_pad),\n       .crc(crc_out)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 5, "code": "module sd_cmd_serial_host(\n    input  wire  SD_CLK_IN,\n    input  wire  RST_IN,\n    input  wire  [15:0] SETTING_IN,\n    input  wire  [39:0] CMD_IN,\n    input  wire  REQ_IN,\n    input  wire  ACK_IN,\n    input  wire  cmd_dat_i,\n    output wire  [39:0] CMD_OUT,\n    output wire  ACK_OUT,\n    output wire  REQ_OUT,\n    output wire  [7:0]  STATUS,\n    output wire  cmd_oe_o,\n    output wire  cmd_out_o,\n    output wire  st_dat_t\n);\n\n    // FSM state machine\n    reg [9:0] state;\n    reg [9:0] next_state;\n\n    // FSM state transition logic\n    always_comb begin\n        case(state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= Response_Size + EIGHT_PAD)\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = INIT;\n            end\n        endcase\n    end\n\n    // FSM state transition\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // Synchronize REQ_IN and ACK_IN\n    reg req_sync;\n    reg ack_sync;\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            req_sync <= 0;\n        else\n            req_sync <= REQ_IN;\n    end\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            ack_sync <= 0;\n        else\n            ack_sync <= ACK_IN;\n    end\n\n    // Command decoder\n    reg [7:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg Write_Read;\n    reg Write_Only;\n    reg [1:0] word_select;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg block_write;\n    reg block_read;\n    reg Decoder_ACK;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] CRC_VAL;\n    reg [7:0] CRC_IN;\n    reg [7:0] CRC_OUT;\n    reg CRC_Enable;\n    reg CRC_RST;\n    reg [39:0] CMD_OUT;\n    reg [7:0] st_dat_t;\n\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            begin\n                Response_Size <= 0;\n                Delay_Cycler <= 0;\n                Write_Read <= 0;\n                Write_Only <= 0;\n                word_select <= 0;\n                In_Buff <= 0;\n                Out_Buff <= 0;\n                block_write <= 0;\n                block_read <= 0;\n                Decoder_ACK <= 0;\n                CRC_Check_On <= 0;\n                Crc_Buffering <= 0;\n                CRC_Valid <= 0;\n                CRC_VAL <= 0;\n                CRC_IN <= 0;\n                CRC_OUT <= 0;\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n            end\n        else if (Req_internal_in)\n            begin\n                Response_Size <= SETTING_IN[6:0];\n                CRC_Check_On <= SETTING_IN[7];\n                Delay_Cycler <= SETTING_IN[10:8];\n                block_write <= SETTING_IN[11];\n                block_read <= SETTING_IN[12];\n                word_select <= SETTING_IN[14:13];\n                In_Buff <= CMD_IN;\n                if (SETTING_IN[6:0] > 0)\n                    Write_Read <= 1;\n                else\n                    Write_Only <= 1;\n                Decoder_ACK <= 0;\n            end\n        else\n            begin\n                if (Decoding_Complete)\n                    begin\n                        Write_Read <= 0;\n                        Write_Only <= 0;\n                        Decoder_ACK <= 1;\n                    end\n            end\n    end\n\n    // FSM output logic\n    reg cmd_oe_o;\n    reg cmd_out_o;\n    reg FSM_ACK;\n    reg REQ_OUT;\n    reg CRC_OUT;\n    reg CRC_RST;\n    reg [39:0] CMD_OUT;\n    reg [7:0] st_dat_t;\n\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n                CRC_OUT <= 0;\n                CRC_RST <= 1;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n            end\n        else\n            begin\n                case(state)\n                    INIT: begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= 1;\n                        FSM_ACK <= 1;\n                        REQ_OUT <= 1;\n                        CRC_RST <= 1;\n                        CMD_OUT <= 0;\n                        st_dat_t <= 0;\n                        Cmd_Cnt <= 0;\n                    end\n                    IDLE: begin\n                        cmd_oe_o <= 0;\n                        cmd_out_o <= 0;\n                        FSM_ACK <= 1;\n                        REQ_OUT <= 0;\n                        CRC_RST <= 1;\n                        CMD_OUT <= 0;\n                        st_dat_t <= 0;\n                        Cmd_Cnt <= 0;\n                    end\n                    WRITE_WR: begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= 1;\n                        FSM_ACK <= 0;\n                        REQ_OUT <= 1;\n                        CRC_RST <= 0;\n                        CRC_Enable <= 1;\n                        if (Cmd_Cnt == 0)\n                            CMD_OUT <= 16'b0000_0000_0000_0001;\n                        else if (Ack_internal_in)\n                            REQ_OUT <= 0;\n                        else\n                            begin\n                                if (Crc_Buffering)\n                                    begin\n                                        cmd_oe_o <= 1;\n                                        if (Bit_Nr > 8)\n                                            CMD_OUT <= CMD_OUT[39:1] & {1'b0, CRC_OUT};\n                                        else if (Bit_Nr > 9)\n                                            CMD_OUT <= CMD_OUT[39:2] & {1'b0, CRC_OUT[6:1]};\n                                        else\n                                            CMD_OUT <= CMD_OUT[39:2] & {1'b0, CRC_OUT[6:1], 1'b0};\n                                        if (Bit_Nr > 8)\n                                            Bit_Nr <= Bit_Nr + 1;\n                                        else\n                                            Bit_Nr <= Bit_Nr + 2;\n                                    end\n                                else\n                                    begin\n                                        Crc_Buffering <= 1;\n                                        CRC_OUT <= In_Buff[39];\n                                    end\n                            end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                    WRITE_WO: begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= 1;\n                        FSM_ACK <= 0;\n                        REQ_OUT <= 1;\n                        CRC_RST <= 0;\n                        CRC_Enable <= 1;\n                        if (Cmd_Cnt == 0)\n                            CMD_OUT <= 4'b0010;\n                        else if (Ack_internal_in)\n                            REQ_OUT <= 0;\n                        else\n                            begin\n                                if (Crc_Buffering)\n                                    begin\n                                        cmd_oe_o <= 1;\n                                        if (Bit_Nr > 8)\n                                            CMD_OUT <= CMD_OUT[39:1] & {1'b0, CRC_OUT};\n                                        else if (Bit_Nr > 9)\n                                            CMD_OUT <= CMD_OUT[39:2] & {1'b0, CRC_OUT[6:1]};\n                                        else\n                                            CMD_OUT <= CMD_OUT[39:2] & {1'b0, CRC_OUT[6:1], 1'b0};\n                                        if (Bit_Nr > 8)\n                                            Bit_Nr <= Bit_Nr + 1;\n                                        else\n                                            Bit_Nr <= Bit_Nr + 2;\n                                    end\n                                else\n                                    begin\n                                        Crc_Buffering <= 1;\n                                        CRC_OUT <= In_Buff[39];\n                                    end\n                            end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                    DLY_WR: begin\n                        cmd_oe_o <= 0;\n                        cmd_out_o <= 0;\n                        FSM_ACK <= 0;\n                        REQ_OUT <= 0;\n                        CRC_RST <= 1;\n                        CRC_Enable <= 0;\n                        if (Delay_Cnt == 0)\n                            begin\n                                CMD_OUT <= 4'b0011;\n                                REQ_OUT <= 1;\n                            end\n                        else if (Ack_internal_in)\n                            REQ_OUT <= 0;\n                        else\n                            begin\n                                Delay_Cnt <= Delay_Cnt + 1;\n                                if (Delay_Cnt < 3'b111)\n                                    Delay_Cnt <= Delay_Cnt + 1;\n                            end\n                        Crc_Buffering <= 0;\n                    end\n                    DLY_WO: begin\n                        cmd_oe_o <= 0;\n                        cmd_out_o <= 0;\n                        FSM_ACK <= 0;\n                        REQ_OUT <= 0;\n                        CRC_RST <= 1;\n                        CRC_Enable <= 0;\n                        if (Delay_Cnt == 0)\n                            begin\n                                CMD_OUT <= 4'b0100;\n                                CMD_OUT[5] <= CRC_Valid;\n                                CMD_OUT[6] <= 1;\n                                REQ_OUT <= 1;\n                            end\n                        else if (Ack_internal_in)\n                            REQ_OUT <= 0;\n                        else\n                            begin\n                                Delay_Cnt <= Delay_Cnt + 1;\n                                if (Delay_Cnt < Delay_Cycler)\n                                    Delay_Cnt <= Delay_Cnt + 1;\n                            end\n                        Crc_Buffering <= 0;\n                    end\n                    READ_WR: begin\n                        cmd_oe_o <= 0;\n                        cmd_out_o <= 0;\n                        FSM_ACK <= 0;\n                        REQ_OUT <= 1;\n                        CRC_RST <= 0;\n                        CRC_Enable <= 1;\n                        if (Cmd_Cnt == 1)\n                            begin\n                                CMD_OUT <= 4'b0101;\n                                CMD_OUT[7] <= 0;\n                                REQ_OUT <= 1;\n                            end\n                        else if (Ack_internal_in)\n                            REQ_OUT <= 0;\n                        else\n                            begin\n                                if (Cmd_Cnt < Response_Size)\n                                    begin\n                                        Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                                        CRC_IN <= cmd_dat_i;\n                                    end\n                                else if ((Cmd_Cnt - Response_Size) <= 6)\n                                    begin\n                                        CRC_IN <= cmd_dat_i;\n                                        CRC_OUT <= CRC_IN;\n                                    end\n                                else\n                                    begin\n                                        if (CRC_IN != CRC_VAL && CRC_Check_On)\n                                            CRC_Valid <= 0;\n                                        else\n                                            CRC_Valid <= 1;\n                                        if (block_read && block_write)\n                                            st_dat_t <= 2'b11;\n                                        else if (block_write)\n                                            st_dat_t <= 2'b01;\n                                        Cmd_Cnt <= Cmd_Cnt + 1;\n                                    end\n                            end\n                    end\n                    DLY_READ: begin\n                        cmd_oe_o <= 0;\n                        cmd_out_o <= 0;\n                        FSM_ACK <= 0;\n                        REQ_OUT <= 0;\n                        CRC_RST <= 1;\n                        CRC_Enable <= 0;\n                        if (Delay_Cnt == 0)\n                            begin\n                                CMD_OUT <= 4'b0110;\n                                CMD_OUT[5] <= CRC_Valid;\n                                CMD_OUT[6] <= 1;\n                                REQ_OUT <= 1;\n                            end\n                        else if (Ack_internal_in)\n                            REQ_OUT <= 0;\n                        else\n                            begin\n                                Delay_Cnt <= Delay_Cnt + 1;\n                                if (Delay_Cnt < 3'b111)\n                                    Delay_Cnt <= Delay_Cnt + 1;\n                            end\n                        Crc_Buffering <= 0;\n                    end\n                    ACK_WO: begin\n                        FSM_ACK <= 1;\n                    end\n                    ACK_WR: begin\n                        FSM_ACK <= 1;\n                        REQ_OUT <= 0;\n                    end\n                    default: begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= 1;\n                        FSM_ACK <= 1;\n                        REQ_OUT <= 0;\n                        CRC_RST <= 1;\n                        CMD_OUT <= 0;\n                        st_dat_t <= 0;\n                        Cmd_Cnt <= 0;\n                    end\n                endcase\n            end\n    end\n\n    // CRC computation\n    reg [6:0] CRC_VAL;\n    reg [6:0] CRC_IN;\n    reg [6:0] CRC_OUT;\n    reg CRC_Enable;\n    reg CRC_RST;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            begin\n                CRC_VAL <= 0;\n                CRC_IN <= 0;\n                CRC_OUT <= 0;\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Crc_Buffering <= 0;\n                CRC_Valid <= 0;\n            end\n        else\n            begin\n                if (CRC_Enable)\n                    begin\n                        if (CRC_RST)\n                            CRC_VAL <= 0;\n                        else\n                            begin\n                                CRC_VAL <= (CRC_VAL << 1) ^ (CRC_VAL[6] ? 1'b1 : 1'b0);\n                                CRC_IN <= CRC_IN << 1;\n                                if (CRC_IN[6])\n                                    CRC_IN <= CRC_IN ^ 1'b1;\n                            end\n                        if (Crc_Buffering)\n                            CRC_OUT <= CRC_VAL;\n                    end\n            end\n    end\n\n    // Status register\n    reg [7:0] STATUS;\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            STATUS <= 0;\n        else\n            begin\n                case(state)\n                    INIT: begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                    end\n                    IDLE: begin\n                        STATUS <= 16'b0000_0000_0000_0000;\n                    end\n                    WRITE_WR: begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                    end\n                    WRITE_WO: begin\n                        STATUS <= 16'b0000_0000_0000_0010;\n                    end\n                    DLY_WR: begin\n                        STATUS <= 16'b0000_0000_0000_0011;\n                    end\n                    DLY_WO: begin\n                        STATUS <= 16'b0000_0000_0000_0100;\n                    end\n                    READ_WR: begin\n                        STATUS <= 16'b0000_0000_0000_0101;\n                    end\n                    DLY_READ: begin\n                        STATUS <= 16'b0000_0000_0000_0110;\n                    end\n                    ACK_WO: begin\n                        STATUS <= 16'b0000_0000_0000_0111;\n                    end\n                    ACK_WR: begin\n                        STATUS <= 16'b0000_0000_0000_1000;\n                    end\n                    default: begin\n                        STATUS <= 16'b0000_0000_0000_0000;\n                    end\n                endcase\n            end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 6, "code": "module sd_cmd_serial_host(\n    input  wire  SD_CLK_IN,\n    input  wire  RST_IN,\n    input  wire  [15:0] SETTING_IN,\n    input  wire  [39:0] CMD_IN,\n    input  wire  REQ_IN,\n    input  wire  ACK_IN,\n    input  wire  cmd_dat_i,\n    output reg  [39:0] CMD_OUT,\n    output reg  ACK_OUT,\n    output reg  REQ_OUT,\n    output reg  [7:0] STATUS,\n    output reg  cmd_oe_o,\n    output reg  cmd_out_o,\n    output reg  st_dat_t\n);\n\n    // Internal signals\n    reg  [9:0] state;\n    reg  [9:0] next_state;\n    reg  [2:0] Delay_Cnt;\n    reg  [7:0] Response_Size;\n    reg  [3:0] Delay_Cycler;\n    reg  [40:0] In_Buff;\n    reg  [40:0] Out_Buff;\n    reg  [1:0] Write_Read;\n    reg  [1:0] Write_Only;\n    reg  [5:0] word_select_counter;\n    reg  [1:0] CRC_RST;\n    reg  [6:0] CRC_IN;\n    reg  [6:0] CRC_VAL;\n    reg  [1:0] CRC_Enable;\n    reg  [1:0] CRC_OUT;\n    reg  [1:0] CRC_Check_On;\n    reg  [1:0] Crc_Buffering;\n    reg  [1:0] CRC_Valid;\n    reg  [7:0] Cmd_Cnt;\n    reg  [2:0] Delay_Cnt;\n    reg  [1:0] FSM_ACK;\n    reg  [1:0] DECODER_ACK;\n    reg  [1:0] q;\n    reg  [1:0] Req_internal_in;\n    reg  [1:0] q1;\n    reg  [1:0] Ack_internal_in;\n\n    // FSM_COMBO\n    always_comb begin\n        case(state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= Response_Size + EIGHT_PAD)\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = INIT;\n            end\n        endcase\n    end\n\n    // FSM_SEQ\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            q <= 0;\n        else\n            q <= REQ_IN;\n    end\n\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            Req_internal_in <= 0;\n        else\n            Req_internal_in <= q;\n    end\n\n    // ACK_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            q1 <= 0;\n        else\n            q1 <= ACK_IN;\n    end\n\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            Ack_internal_in <= 0;\n        else\n            Ack_internal_in <= q1;\n    end\n\n    // COMMAND_DECODER\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n        begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end\n        else\n        begin\n            if (Req_internal_in)\n            begin\n                Response_Size <= SETTING_IN[6:0];\n                CRC_Check_On <= SETTING_IN[7];\n                Delay_Cycler <= SETTING_IN[10:8];\n                block_write <= SETTING_IN[11];\n                block_read <= SETTING_IN[12];\n                word_select <= SETTING_IN[14:13];\n                In_Buff <= CMD_IN;\n                if (SETTING_IN[6:0] > 0)\n                begin\n                    Write_Read <= 1;\n                    Write_Only <= 0;\n                end\n                else\n                begin\n                    Write_Read <= 0;\n                    Write_Only <= 1;\n                end\n                DECODER_ACK <= 0;\n            end\n            else\n            begin\n                DECODER_ACK <= 1;\n                Write_Read <= 0;\n                Write_Only <= 0;\n            end\n        end\n    end\n\n    // FSM_OUT\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n        begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end\n        else\n        begin\n            case(state)\n                INIT: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    CRC_Valid <= 0;\n                    Cmd_Cnt <= 0;\n                    st_dat_t <= 0;\n                end\n                WRITE_WR: begin\n                    if (Cmd_Cnt == 0)\n                    begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering == 1)\n                    begin\n                        cmd_oe_o <= 1;\n                        if (Bit_Nr > 8)\n                        begin\n                            CMD_OUT <= CMD_OUT[39:1] & {1'b0, CMD_IN};\n                            if (Bit_Nr > 9)\n                            begin\n                                CRC_OUT <= CRC_OUT[6:0] & {1'b0, CRC_IN};\n                            end\n                        end\n                        else if (Bit_Nr <= 8 && Bit_Nr >= 2)\n                        begin\n                            CRC_OUT <= CRC_OUT[6:0] & {1'b0, CRC_IN};\n                            st_dat_t <= {word_select[1:0], st_dat_t[1:0]};\n                        end\n                        else\n                        begin\n                            cmd_out_o <= 1;\n                        end\n                        Bit_Nr <= Bit_Nr + 1;\n                    end\n                    else\n                    begin\n                        Pre_load_CRC <= 1;\n                        CRC_OUT <= In_Buff[39:32];\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                WRITE_WO: begin\n                    if (Cmd_Cnt == 0)\n                    begin\n                        STATUS <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering == 1)\n                    begin\n                        cmd_oe_o <= 1;\n                        if (Bit_Nr > 8)\n                        begin\n                            CMD_OUT <= CMD_OUT[39:1] & {1'b0, CMD_IN};\n                            if (Bit_Nr > 9)\n                            begin\n                                CRC_OUT <= CRC_OUT[6:0] & {1'b0, CRC_IN};\n                            end\n                        end\n                        else if (Bit_Nr <= 8 && Bit_Nr >= 2)\n                        begin\n                            CRC_OUT <= CRC_OUT[6:0] & {1'b0, CRC_IN};\n                            st_dat_t <= {word_select[1:0], st_dat_t[1:0]};\n                        end\n                        else\n                        begin\n                            cmd_out_o <= 1;\n                        end\n                        Bit_Nr <= Bit_Nr + 1;\n                    end\n                    else\n                    begin\n                        Pre_load_CRC <= 1;\n                        CRC_OUT <= In_Buff[39:32];\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0)\n                    begin\n                        STATUS <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Out_Buff <= 0;\n                    FSM_ACK <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0)\n                    begin\n                        STATUS <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Out_Buff <= 0;\n                    FSM_ACK <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Reset_Delay_Cnt <= 0;\n                    CRC_Enable <= 0;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Out_Buff <= 0;\n                    FSM_ACK <= 0;\n                    if (Cmd_Cnt == 1)\n                    begin\n                        STATUS <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end\n                    else if (Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size)\n                    begin\n                        cmd_dat_i <= CMD_IN;\n                        Out_Buff <= Out_Buff[39:1] & {1'b0, cmd_dat_i};\n                        CRC_IN <= cmd_dat_i;\n                    end\n                    else if ((Cmd_Cnt - Response_Size) <= 6)\n                    begin\n                        CRC_IN <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end\n                    else\n                    begin\n                        if (CRC_IN != CRC_VAL && CRC_Check_On)\n                        begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end\n                        else\n                        begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= {block_read, block_write};\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0)\n                    begin\n                        STATUS <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Out_Buff <= 0;\n                    FSM_ACK <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n                default: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    Cmd_Cnt <= 0;\n                    st_dat_t <= 0;\n                end\n            endcase\n        end\n    end\n\n    // sd_crc_7\n    sd_crc_7 sd_crc_7_inst(\n        .BITVAL(cmd_dat_i),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_OUT)\n    );\n\n    // Assign outputs\n    CMD_OUT <= Out_Buff;\n    ACK_OUT <= FSM_ACK;\n    REQ_OUT <= REQ_OUT;\n    STATUS <= STATUS;\n    cmd_oe_o <= cmd_oe_o;\n    cmd_out_o <= cmd_out_o;\n    st_dat_t <= st_dat_t;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 7, "code": "module sd_cmd_serial_host(\n    input  wire  SD_CLK_IN,\n    input  wire  RST_IN,\n    input  wire  [15:0] SETTING_IN,\n    input  wire  [39:0] CMD_IN,\n    input  wire  REQ_IN,\n    input  wire  ACK_IN,\n    input  wire  cmd_dat_i,\n    output wire  [39:0] CMD_OUT,\n    output wire  ACK_OUT,\n    output wire  REQ_OUT,\n    output wire  [7:0] STATUS,\n    output wire  cmd_oe_o,\n    output wire  cmd_out_o,\n    output wire  st_dat_t\n);\n\n    // FSM state machine\n    reg [9:0] state;\n    reg [9:0] next_state;\n\n    // FSM state transition table\n    always_comb begin\n        case(state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= Response_Size + EIGHT_PAD)\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM state machine update\n    always @(posedge SD_CLK_IN or posedge RST_IN)\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n\n    // FSM output logic\n    always_comb begin\n        case(state)\n            INIT: begin\n                cmd_oe_o = 1'b1;\n                cmd_out_o = 1'b1;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b0;\n                STATUS = 8'b0;\n                st_dat_t = 2'b0;\n            end\n            IDLE: begin\n                cmd_oe_o = 1'b0;\n                cmd_out_o = 1'b0;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b0;\n                STATUS = 8'b0;\n                st_dat_t = 2'b0;\n            end\n            WRITE_WR: begin\n                cmd_oe_o = 1'b1;\n                cmd_out_o = 1'b1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b1;\n                STATUS = 8'b0;\n                st_dat_t = 2'b00;\n            end\n            WRITE_WO: begin\n                cmd_oe_o = 1'b1;\n                cmd_out_o = 1'b1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b1;\n                STATUS = 8'b0;\n                st_dat_t = 2'b01;\n            end\n            DLY_WR: begin\n                cmd_oe_o = 1'b1;\n                cmd_out_o = 1'b1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b1;\n                STATUS = 8'b0;\n                st_dat_t = 2'b00;\n            end\n            DLY_WO: begin\n                cmd_oe_o = 1'b1;\n                cmd_out_o = 1'b1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b1;\n                STATUS = 8'b0;\n                st_dat_t = 2'b01;\n            end\n            READ_WR: begin\n                cmd_oe_o = 1'b0;\n                cmd_out_o = 1'b0;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b1;\n                STATUS = 8'b0;\n                st_dat_t = 2'b10;\n            end\n            DLY_READ: begin\n                cmd_oe_o = 1'b0;\n                cmd_out_o = 1'b0;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b1;\n                STATUS = 8'b0;\n                st_dat_t = 2'b10;\n            end\n            ACK_WO: begin\n                cmd_oe_o = 1'b0;\n                cmd_out_o = 1'b0;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b1;\n                REQ_OUT = 1'b0;\n                STATUS = 8'b0;\n                st_dat_t = 2'b00;\n            end\n            ACK_WR: begin\n                cmd_oe_o = 1'b0;\n                cmd_out_o = 1'b0;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b1;\n                REQ_OUT = 1'b0;\n                STATUS = 8'b0;\n                st_dat_t = 2'b10;\n            end\n            default: begin\n                cmd_oe_o = 1'b0;\n                cmd_out_o = 1'b0;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b0;\n                STATUS = 8'b0;\n                st_dat_t = 2'b0;\n            end\n        endcase\n    end\n\n    // Synchronize REQ_IN and ACK_IN signals\n    reg req_sync_q, req_sync_q1;\n    reg ack_sync_q, ack_sync_q1;\n\n    always @(posedge SD_CLK_IN or posedge RST_IN)\n        if (RST_IN)\n            begin\n                req_sync_q = 1'b0;\n                req_sync_q1 = 1'b0;\n                ack_sync_q = 1'b0;\n                ack_sync_q1 = 1'b0;\n            end\n        else\n            begin\n                req_sync_q <= req_sync_q1;\n                req_sync_q1 <= REQ_IN;\n                ack_sync_q <= ack_sync_q1;\n                ack_sync_q1 <= ACK_IN;\n            end\n\n    assign Req_internal_in = req_sync_q;\n    assign Ack_internal_in = ack_sync_q;\n\n    // Command decoder\n    reg [7:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg Write_Read, Write_Only, CRC_Check_On;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg [7:0] word_select_counter;\n    reg [7:0] CRC_RST;\n    reg [7:0] CRC_IN;\n    reg [7:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Valid;\n    reg Crc_Buffering;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg [7:0] block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg q1;\n\n    always @(posedge SD_CLK_IN or posedge RST_IN)\n        if (RST_IN)\n            begin\n                Response_Size <= 8'b0;\n                Delay_Cycler <= 3'b0;\n                Write_Read <= 1'b0;\n                Write_Only <= 1'b0;\n                CRC_Check_On <= 1'b0;\n                In_Buff <= 40'b0;\n                Out_Buff <= 40'b0;\n                word_select_counter <= 3'b0;\n                CRC_RST <= 8'b0;\n                CRC_IN <= 8'b0;\n                CRC_VAL <= 8'b0;\n                CRC_Enable <= 1'b0;\n                CRC_OUT <= 1'b0;\n                CRC_Valid <= 1'b0;\n                Crc_Buffering <= 1'b0;\n                Cmd_Cnt <= 8'b0;\n                Delay_Cnt <= 3'b0;\n                state <= 10'b0;\n                next_state <= 10'b0;\n                block_write <= 1'b0;\n                block_read <= 1'b0;\n                word_select <= 2'b0;\n                FSM_ACK <= 1'b0;\n                DECODER_ACK <= 1'b0;\n                q <= 1'b0;\n                q1 <= 1'b0;\n            end\n        else\n            begin\n                // Decode settings\n                if (Req_internal_in)\n                    begin\n                        Response_Size <= SETTING_IN[6:0];\n                        CRC_Check_On <= SETTING_IN[7];\n                        Delay_Cycler <= SETTING_IN[10:8];\n                        block_write <= SETTING_IN[11];\n                        block_read <= SETTING_IN[12];\n                        word_select <= SETTING_IN[14:13];\n                        Write_Read <= 1'b1;\n                        Write_Only <= 1'b0;\n                    end\n                else\n                    begin\n                        Write_Read <= 1'b0;\n                        Write_Only <= 1'b1;\n                    end\n\n                // Load command data\n                In_Buff <= CMD_IN;\n\n                // Set operation flags\n                if (Response_Size > 0)\n                    begin\n                        Write_Read <= 1'b1;\n                        Write_Only <= 1'b0;\n                    end\n                else\n                    begin\n                        Write_Read <= 1'b0;\n                        Write_Only <= 1'b1;\n                    end\n\n                // Manage acknowledgment\n                DECODER_ACK <= 1'b0;\n\n                // Update internal counters and flags\n                if (Req_internal_in)\n                    begin\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                else\n                    begin\n                        Cmd_Cnt <= Cmd_Cnt;\n                        Delay_Cnt <= Delay_Cnt;\n                    end\n            end\n\n    // FSM_OUT\n    always_comb begin\n        case(state)\n            INIT: begin\n                cmd_oe_o = 1'b1;\n                cmd_out_o = 1'b1;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b0;\n                STATUS = 8'b0;\n                st_dat_t = 2'b0;\n            end\n            IDLE: begin\n                cmd_oe_o = 1'b0;\n                cmd_out_o = 1'b0;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b0;\n                STATUS = 8'b0;\n                st_dat_t = 2'b0;\n            end\n            WRITE_WR: begin\n                cmd_oe_o = 1'b1;\n                cmd_out_o = 1'b1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b1;\n                STATUS = 8'b0;\n                st_dat_t = 2'b00;\n            end\n            WRITE_WO: begin\n                cmd_oe_o = 1'b1;\n                cmd_out_o = 1'b1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b1;\n                STATUS = 8'b0;\n                st_dat_t = 2'b01;\n            end\n            DLY_WR: begin\n                cmd_oe_o = 1'b1;\n                cmd_out_o = 1'b1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b1;\n                STATUS = 8'b0;\n                st_dat_t = 2'b00;\n            end\n            DLY_WO: begin\n                cmd_oe_o = 1'b1;\n                cmd_out_o = 1'b1;\n                CMD_OUT = In_Buff;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b1;\n                STATUS = 8'b0;\n                st_dat_t = 2'b01;\n            end\n            READ_WR: begin\n                cmd_oe_o = 1'b0;\n                cmd_out_o = 1'b0;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b1;\n                STATUS = 8'b0;\n                st_dat_t = 2'b10;\n            end\n            DLY_READ: begin\n                cmd_oe_o = 1'b0;\n                cmd_out_o = 1'b0;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b1;\n                STATUS = 8'b0;\n                st_dat_t = 2'b10;\n            end\n            ACK_WO: begin\n                cmd_oe_o = 1'b0;\n                cmd_out_o = 1'b0;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b1;\n                REQ_OUT = 1'b0;\n                STATUS = 8'b0;\n                st_dat_t = 2'b00;\n            end\n            ACK_WR: begin\n                cmd_oe_o = 1'b0;\n                cmd_out_o = 1'b0;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b1;\n                REQ_OUT = 1'b0;\n                STATUS = 8'b0;\n                st_dat_t = 2'b10;\n            end\n            default: begin\n                cmd_oe_o = 1'b0;\n                cmd_out_o = 1'b0;\n                CMD_OUT = 40'b0;\n                ACK_OUT = 1'b0;\n                REQ_OUT = 1'b0;\n                STATUS = 8'b0;\n                st_dat_t = 2'b0;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 8, "code": "module sd_cmd_serial_host(\n    input  wire sd_clk_i,\n    input  wire rst_i,\n    input  wire [15:0] setting_in,\n    input  wire [39:0] cmd_in,\n    input  wire req_in,\n    input  wire ack_in,\n    input  wire cmd_dat_i,\n    output wire [39:0] cmd_out,\n    output wire ack_out,\n    output wire req_out,\n    output wire [7:0] status,\n    output wire cmd_oe_o,\n    output wire cmd_out_o,\n    output wire [1:0] st_dat_t\n);\n\n    // Internal signals\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg [2:0] delay_cnt;\n    reg [7:0] response_size;\n    reg [2:0] delay_cycler;\n    reg [39:0] in_buff;\n    reg [39:0] out_buff;\n    reg [1:0] write_read;\n    reg [1:0] write_only;\n    reg [1:0] block_write;\n    reg [1:0] block_read;\n    reg [5:0] word_select_counter;\n    reg [1:0] crc_rst;\n    reg [6:0] crc_in;\n    reg [6:0] crc_val;\n    reg [1:0] crc_enable;\n    reg [1:0] crc_out;\n    reg [1:0] crc_check_on;\n    reg [1:0] crc_buffering;\n    reg [1:0] crc_valid;\n    reg [7:0] cmd_cnt;\n    reg [2:0] delay_cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg [1:0] fsm_ack;\n    reg [1:0] decoder_ack;\n    reg [1:0] q;\n    reg [1:0] req_internal_in;\n    reg [1:0] q1;\n    reg [1:0] ack_internal_in;\n\n    // FSM_COMBO\n    always_comb begin\n        case(state)\n            INIT: begin\n                if (cmd_cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (write_read)\n                    next_state = WRITE_WR;\n                else if (write_only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (cmd_cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (cmd_cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (delay_cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (delay_cnt >= delay_cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (cmd_cnt >= (response_size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = INIT;\n            end\n        endcase\n    end\n\n    // FSM_SEQ\n    always_ff @(posedge sd_clk_i or posedge rst_i) begin\n        if (rst_i)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC\n    always_ff @(posedge sd_clk_i or posedge_i) begin\n        if (rst_i)\n            q <= 0;\n        else\n            q <= req_in;\n    end\n    always_ff @(posedge sd_clk_i or posedge rst_i) begin\n        if (rst_i)\n            req_internal_in <= 0;\n        else\n            req_internal_in <= q;\n    end\n\n    // ACK_SYNC\n    always_ff @(posedge sd_clk_i or posedge rst_i) begin\n        if (rst_i)\n            q1 <= 0;\n        else\n            q1 <= ack_in;\n    end\n    always_ff @(posedge sd_clk_i or posedge rst_i) begin\n        if (rst_i)\n            ack_internal_in <= 0;\n        else\n            ack_internal_in <= q1;\n    end\n\n    // COMMAND_DECODER\n    always_ff @(posedge sd_clk_i or posedge rst_i) begin\n        if (rst_i) begin\n            delay_cycler <= 0;\n            response_size <= 0;\n            decoder_ack <= 0;\n            write_read <= 0;\n            write_only <= 0;\n            crc_check_on <= 0;\n            in_buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select_counter <= 0;\n        end else if (req_internal_in) begin\n            // Decode setting_in\n            response_size <= setting_in[6:0];\n            crc_check_on <= setting_in[7];\n            delay_cycler <= setting_in[10:8];\n            block_write <= setting_in[11];\n            block_read <= setting_in[12];\n            word_select_counter <= setting_in[14:13];\n\n            // Load command data\n            in_buff <= cmd_in;\n\n            // Set operation flags\n            if (response_size > 0) begin\n                write_read <= 1;\n                write_only <= 0;\n            end else begin\n                write_read <= 0;\n                write_only <= 1;\n            end\n\n            // Manage acknowledgment\n            decoder_ack <= 0;\n        end else if (!req_internal_in && decoder_ack) begin\n            // Reset operation flags\n            write_read <= 0;\n            write_only <= 0;\n            decoder_ack <= 1;\n        end\n    end\n\n    // FSM_OUT\n    always_ff @(posedge sd_clk_i or posedge rst_i) begin\n        if (rst_i) begin\n            crc_enable <= 0;\n            word_select_counter <= 0;\n            delay_cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            out_buff <= 0;\n            fsm_ack <= 1;\n            req_out <= 0;\n            crc_rst <= 1;\n            crc_out <= 0;\n            crc_buffering <= 0;\n            status <= 0;\n            crc_valid <= 0;\n            cmd_cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case(state)\n                INIT: begin\n                    cmd_cnt <= cmd_cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    delay_cnt <= 0;\n                    crc_rst <= 1;\n                    crc_enable <= 0;\n                    out_buff <= 0;\n                    fsm_ack <= 1;\n                    req_out <= 0;\n                    crc_buffering <= 0;\n                    status <= 0;\n                    crc_valid <= 0;\n                    cmd_cnt <= 0;\n                    st_dat_t <= 0;\n                end\n                WRITE_WR: begin\n                    if (cmd_cnt == 0) begin\n                        status <= 16'b0000_0000_0000_0001;\n                        req_out <= 1;\n                    end else if (ack_internal_in) begin\n                        req_out <= 0;\n                    end\n                    if (cmd_cnt < SEND_SIZE) begin\n                        cmd_oe_o <= 1;\n                        if (cmd_cnt == 0) begin\n                            cmd_out_o <= 1;\n                        end else if (cmd_cnt == 1) begin\n                            cmd_out_o <= 0;\n                        end\n                        if (cmd_cnt < 8) begin\n                            out_buff <= {out_buff[38:1], cmd_dat_i};\n                        end else if (cmd_cnt < 9) begin\n                            out_buff <= {out_buff[38:2], cmd_dat_i};\n                        end else begin\n                            out_buff <= {out_buff[38:3], cmd_dat_i};\n                        end\n                    end\n                    if (cmd_cnt < SEND_SIZE - 1) begin\n                        cmd_cnt <= cmd_cnt + 1;\n                    end\n                end\n                WRITE_WO: begin\n                    if (cmd_cnt == 0) begin\n                        status <= 4'b0010;\n                        req_out <= 1;\n                    end else if (ack_internal_in) begin\n                        req_out <= 0;\n                    end\n                    if (cmd_cnt < SEND_SIZE) begin\n                        cmd_oe_o <= 1;\n                        if (cmd_cnt == 0) begin\n                            cmd_out_o <= 1;\n                        end else if (cmd_cnt == 1) begin\n                            cmd_out_o <= 0;\n                        end\n                        if (cmd_cnt < 8) begin\n                            out_buff <= {out_buff[38:1], cmd_dat_i};\n                        end else if (cmd_cnt < 9) begin\n                            out_buff <= {out_buff[38:2], cmd_dat_i};\n                        end else begin\n                            out_buff <= {out_buff[38:3], cmd_dat_i};\n                        end\n                    end\n                    if (cmd_cnt < SEND_SIZE - 1) begin\n                        cmd_cnt <= cmd_cnt + 1;\n                    end\n                end\n                DLY_WR: begin\n                    if (delay_cnt == 0) begin\n                        status <= 4'b0011;\n                        req_out <= 1;\n                    end else if (ack_internal_in) begin\n                        req_out <= 0;\n                    end\n                    if (delay_cnt < 3'b111) begin\n                        delay_cnt <= delay_cnt + 1;\n                    end\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    crc_rst <= 1;\n                    crc_enable <= 0;\n                    out_buff <= 0;\n                    fsm_ack <= 1;\n                    req_out <= 0;\n                    crc_buffering <= 0;\n                    status <= 0;\n                    crc_valid <= 0;\n                    cmd_cnt <= 1;\n                end\n                DLY_WO: begin\n                    if (delay_cnt == 0) begin\n                        status <= 4'b0100;\n                        status[5] <= 0;\n                        status[6] <= 1;\n                        req_out <= 1;\n                    end else if (ack_internal_in) begin\n                        req_out <= 0;\n                    end\n                    if (delay_cnt < delay_cycler) begin\n                        delay_cnt <= delay_cnt + 1;\n                    end\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    crc_rst <= 1;\n                    crc_enable <= 0;\n                    out_buff <= 0;\n                    fsm_ack <= 1;\n                    req_out <= 0;\n                    crc_buffering <= 0;\n                    status <= 0;\n                    crc_valid <= 0;\n                    cmd_cnt <= 0;\n                end\n                READ_WR: begin\n                    delay_cnt <= 0;\n                    crc_rst <= 0;\n                    crc_enable <= 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    out_buff <= 0;\n                    fsm_ack <= 0;\n                    req_out <= 1;\n                    if (cmd_cnt == 1) begin\n                        status <= 4'b0101;\n                        req_out <= 1;\n                    end else if (ack_internal_in) begin\n                        req_out <= 0;\n                    end\n                    if (cmd_cnt < response_size) begin\n                        if (cmd_cnt < 8) begin\n                            out_buff <= {out_buff[38:1], cmd_dat_i};\n                        end else if (cmd_cnt < 9) begin\n                            out_buff <= {out_buff[38:2], cmd_dat_i};\n                        end else begin\n                            out_buff <= {out_buff[38:3], cmd_dat_i};\n                        end\n                    end\n                    if (cmd_cnt < response_size) begin\n                        cmd_cnt <= cmd_cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (delay_cnt == 0) begin\n                        status <= 4'b0110;\n                        status[5] <= crc_valid;\n                        status[6] <= 1;\n                        req_out <= 1;\n                    end else if (ack_internal_in) begin\n                        req_out <= 0;\n                    end\n                    if (delay_cnt < 3'b111) begin\n                        delay_cnt <= delay_cnt + 1;\n                    end\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    crc_rst <= 1;\n                    crc_enable <= 0;\n                    out_buff <= 0;\n                    fsm_ack <= 1;\n                    req_out <= 0;\n                    crc_buffering <= 0;\n                    status <= 0;\n                    crc_valid <= 0;\n                    cmd_cnt <= 0;\n                end\n                ACK_WO: begin\n                    fsm_ack <= 1;\n                end\n                ACK_WR: begin\n                    fsm_ack <= 1;\n                    req_out <= 0;\n                end\n                default: begin\n                    state <= INIT;\n                end\n            endcase\n        end\n    end\n\n    // sd_crc_7\n    sd_crc_7 crc_unit(\n        .bitval(cmd_dat_i),\n        .enable(crc_enable),\n        .clk(sd_clk_i),\n        .rst(crc_rst),\n        .crc(crc_val)\n    );\n\n    // Output logic\n    assign cmd_out = out_buff;\n    assign ack_out = fsm_ack;\n    assign req_out = req_out;\n    assign status = status;\n    assign cmd_oe_o = cmd_oe_o;\n    assign cmd_out_o = cmd_out_o;\n    assign st_dat_t = st_dat_t;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 1, "code": "module sd_controller_wb(\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire we_m_tx_bd,\n    output wire we_m_rx_bd,\n    output wire new_cmd,\n    output wire we_ack,\n    output wire int_ack,\n    output wire cmd_int_busy,\n    output wire int_busy,\n    input  wire write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0] clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0] Bd_isr_reg,\n    output wire [7:0] Bd_isr_enable_reg,\n    output wire Bd_isr_reset,\n    output wire normal_isr_reset,\n    output wire error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    reg [31:0] argument_reg;\n    reg [15:0] cmd_setting_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [7:0] software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0] clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [7:0] Bd_isr_reg;\n    reg [7:0] Bd_isr_enable_reg;\n    reg Bd_isr_reset;\n    reg normal_isr_reset;\n    reg error_isr_reset;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    reg [31:0] cmd_arg_s_reg;\n    reg [15:0] cmd_set_s_reg;\n    reg we_m_tx_bd_reg;\n    reg we_m_rx_bd_reg;\n    reg new_cmd_reg;\n    reg we_ack_reg;\n    reg int_ack_reg;\n    reg cmd_int_busy_reg;\n    reg int_busy_reg;\n    reg write_req_s_reg;\n    reg [15:0] status_reg_reg;\n    reg [31:0] cmd_resp_1_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            argument_reg <= 32'd0;\n            cmd_setting_reg <= 16'd0;\n            status_reg <= 16'd0;\n            cmd_resp_1 <= 32'd0;\n            software_reset_reg <= 8'd0;\n            time_out_reg <= 16'd0;\n            normal_int_status_reg <= 16'd0;\n            error_int_status_reg <= 16'd0;\n            normal_int_signal_enable_reg <= 16'd0;\n            error_int_signal_enable_reg <= 16'd0;\n            clock_divider <= 8'd0;\n            Bd_Status_reg <= 16'd0;\n            Bd_isr_reg <= 8'd0;\n            Bd_isr_enable_reg <= 8'd0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            cmd_arg_s_reg <= 32'd0;\n            cmd_set_s_reg <= 16'd0;\n            we_m_tx_bd_reg <= 1'b0;\n            we_m_rx_bd_reg <= 1'b0;\n            new_cmd_reg <= 1'b0;\n            we_ack_reg <= 1'b0;\n            int_ack_reg <= 1'b1;\n            cmd_int_busy_reg <= 1'b0;\n            int_busy_reg <= 1'b0;\n            write_req_s_reg <= 1'b0;\n            status_reg_reg <= 16'd0;\n            cmd_resp_1_reg <= 32'd0;\n        end\n        else begin\n            // Register Write\n            if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n                case (wb_adr_i)\n                    4'd0: argument_reg <= wb_dat_i;\n                    4'd4: cmd_setting_reg <= wb_dat_i[15:0];\n                    4'd8: status_reg <= wb_dat_i[15:0];\n                    4'd0c: cmd_resp_1 <= wb_dat_i;\n                    // ... other register writes ...\n                endcase\n            end\n\n            // Register Read\n            if (wb_stb_i && wb_cyc_i) begin\n                case (wb_adr_i)\n                    4'd0: wb_dat_o <= argument_reg;\n                    4'd4: wb_dat_o <= cmd_setting_reg;\n                    4'd8: wb_dat_o <= status_reg;\n                    4'd0c: wb_dat_o <= cmd_resp_1;\n                    // ... other register reads ...\n                endcase\n            end\n\n            // Control Logic\n            if (write_req_s) begin\n                we_ack_reg <= 1'b1;\n            end\n            else begin\n                we_ack_reg <= 1'b0;\n            end\n\n            if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack_reg) begin\n                wb_ack_o <= 1'b1;\n            end\n\n            if (int_ack_reg) begin\n                int_ack_reg <= 1'b0;\n            end\n\n            if (we_m_tx_bd_reg) begin\n                we_m_tx_bd_reg <= 1'b0;\n            end\n\n            if (we_m_rx_bd_reg) begin\n                we_m_rx_bd_reg <= 1'b0;\n            end\n\n            if (new_cmd_reg) begin\n                new_cmd_reg <= 1'b0;\n            end\n\n            if (cmd_int_busy_reg) begin\n                cmd_int_busy_reg <= 1'b0;\n            end\n\n            if (int_busy_reg) begin\n                int_busy_reg <= 1'b0;\n            end\n\n            if (write_req_s_reg) begin\n                write_req_s_reg <= 1'b0;\n            end\n\n            if (status_reg_reg) begin\n                status_reg_reg <= 16'd0;\n            end\n\n            if (cmd_resp_1_reg) begin\n                cmd_resp_1_reg <= 32'd0;\n            end\n        end\n    end\n\n    assign argument_reg = cmd_arg_s_reg;\n    assign cmd_setting_reg = cmd_set_s_reg;\n    assign status_reg = status_reg_reg;\n    assign cmd_resp_1 = cmd_resp_1_reg;\n    assign software_reset_reg = 8'd0;\n    assign time_out_reg = 16'd0;\n    assign normal_int_status_reg = 16'd0;\n    assign error_int_status_reg = 16'd0;\n    assign normal_int_signal_enable_reg = 16'd0;\n    assign error_int_signal_enable_reg = 16'd0;\n    assign clock_divider = 8'd0;\n    assign Bd_Status_reg = 16'd0;\n    assign Bd_isr_reg = 8'd0;\n    assign Bd_isr_enable_reg = 8'd0;\n    assign Bd_isr_reset = 1'b0;\n    assign normal_isr_reset = 1'b0;\n    assign error_isr_reset = 1'b0;\n    assign dat_in_m_tx_bd = {RAM_MEM_WIDTH{1'b0}};\n    assign dat_in_m_rx_bd = {RAM_MEM_WIDTH{1'b0}};\n    assign we_m_tx_bd = we_m_tx_bd_reg;\n    assign we_m_rx_bd = we_m_rx_bd_reg;\n    assign new_cmd = new_cmd_reg;\n    assign we_ack = we_ack_reg;\n    assign int_ack = int_ack_reg;\n    assign cmd_int_busy = cmd_int_busy_reg;\n    assign int_busy = int_busy_reg;\n    assign write_req_s = write_req_s_reg;\n    assign status_reg_reg = status_reg;\n    assign cmd_resp_1_reg = cmd_resp_1;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 2, "code": "module sd_controller_wb(\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire         wb_we_i,\n    input  wire         wb_cyc_i,\n    input  wire         wb_stb_i,\n    output wire         wb_ack_o,\n    output wire         we_m_tx_bd,\n    output wire         we_m_rx_bd,\n    output wire         new_cmd,\n    output wire         we_ack,\n    output wire         int_ack,\n    output wire         cmd_int_busy,\n    output wire         int_busy,\n    input  wire         write_req_s,\n    input  wire [15:0]  cmd_set_s,\n    input  wire [31:0]  cmd_arg_s,\n    output wire [31:0]  argument_reg,\n    output wire [15:0]  cmd_setting_reg,\n    input  wire [15:0]  status_reg,\n    input  wire [31:0]  cmd_resp_1,\n    output wire [7:0]   software_reset_reg,\n    output wire [15:0]  time_out_reg,\n    input  wire [15:0]  normal_int_status_reg,\n    input  wire [15:0]  error_int_status_reg,\n    output wire [15:0]  normal_int_signal_enable_reg,\n    output wire [15:0]  error_int_signal_enable_reg,\n    output wire [7:0]   clock_divider,\n    input  wire [15:0]  Bd_Status_reg,\n    input  wire [7:0]   Bd_isr_reg,\n    output wire [7:0]   Bd_isr_enable_reg,\n    output wire         Bd_isr_reset,\n    output wire         normal_isr_reset,\n    output wire         error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n// Define global variables\n`include \"sd_defines.v\"\n\n// Define registers\nreg [31:0] argument_reg;\nreg [15:0] cmd_setting_reg;\nreg [15:0] status_reg;\nreg [31:0] cmd_resp_1;\nreg [7:0]  software_reset_reg;\nreg [15:0] time_out_reg;\nreg [15:0] normal_int_status_reg;\nreg [15:0] error_int_status_reg;\nreg [15:0] normal_int_signal_enable_reg;\nreg [15:0] error_int_signal_enable_reg;\nreg [7:0]  clock_divider;\nreg [15:0] Bd_Status_reg;\nreg [7:0]  Bd_isr_reg;\nreg [7:0]  Bd_isr_enable_reg;\nreg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nreg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Define control logic\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        // Reset all variables to their reset value\n        argument_reg <= 32'd0;\n        cmd_setting_reg <= 16'd0;\n        status_reg <= 16'd0;\n        cmd_resp_1 <= 32'd0;\n        software_reset_reg <= 8'd0;\n        time_out_reg <= 16'd0;\n        normal_int_status_reg <= 16'd0;\n        error_int_status_reg <= 16'd0;\n        normal_int_signal_enable_reg <= 16'd0;\n        error_int_signal_enable_reg <= 16'd0;\n        clock_divider <= 8'd0;\n        Bd_Status_reg <= 16'd0;\n        Bd_isr_reg <= 8'd0;\n        Bd_isr_enable_reg <= 8'd0;\n        dat_in_m_tx_bd <= RAM_MEM_WIDTH'd0;\n        dat_in_m_rx_bd <= RAM_MEM_WIDTH'd0;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end else begin\n        // Update variables based on input signals\n        if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n            wb_ack_o <= 1'b1;\n        end\n        if (write_req_s) begin\n            we_ack <= 1'b1;\n        end\n        if (cmd_arg_s!= 32'd0) begin\n            new_cmd <= 1'b1;\n        end\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg <= wb_dat_i;\n                8'h08: status_reg <= wb_dat_i;\n                8'h0c: cmd_resp_1 <= wb_dat_i;\n                8'h1c: // Controller Setting\n                8'h20: // Block Size\n                8'h24: // Power Control\n                8'h28: software_reset_reg <= wb_dat_i;\n                8'h2c: time_out_reg <= wb_dat_i;\n                8'h30: normal_int_status_reg <= wb_dat_i;\n                8'h34: error_int_status_reg <= wb_dat_i;\n                8'h38: normal_int_signal_enable_reg <= wb_dat_i;\n                8'h3c: error_int_signal_enable_reg <= wb_dat_i;\n                8'h48: // Capability\n                8'h4c: clock_divider <= wb_dat_i;\n                8'h50: Bd_Status_reg <= wb_dat_i;\n                8'h54: // Data Interrupt Status\n                8'h58: Bd_isr_enable_reg <= wb_dat_i;\n                8'h60: // BD RX\n                8'h80: // BD TX\n                default: ;\n            endcase\n        end\n        if (wb_stb_i && wb_cyc_i && ~wb_ack_o) begin\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= argument_reg;\n                8'h04: wb_dat_o <= cmd_setting_reg;\n                8'h08: wb_dat_o <= status_reg;\n                8'h0c: wb_dat_o <= cmd_resp_1;\n                8'h1c: // Controller Setting\n                8'h20: // Block Size\n                8'h24: // Power Control\n                8'h28: wb_dat_o <= software_reset_reg;\n                8'h2c: wb_dat_o <= time_out_reg;\n                8'h30: wb_dat_o <= normal_int_status_reg;\n                8'h34: wb_dat_o <= error_int_status_reg;\n                8'h38: wb_dat_o <= normal_int_signal_enable_reg;\n                8'h3c: wb_dat_o <= error_int_signal_enable_reg;\n                8'h48: // Capability\n                8'h4c: wb_dat_o <= clock_divider;\n                8'h50: wb_dat_o <= Bd_Status_reg;\n                8'h54: // Data Interrupt Status\n                8'h58: wb_dat_o <= Bd_isr_enable_reg;\n                8'h60: // BD RX\n                8'h80: // BD TX\n                default: ;\n            endcase\n        end\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h60: begin\n                    we_m_tx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    dat_in_m_tx_bd <= wb_dat_i;\n                end\n                8'h80: begin\n                    we_m_rx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    dat_in_m_rx_bd <= wb_dat_i;\n                end\n                default: ;\n            endcase\n        end\n        if (wb_stb_i && wb_cyc_i && ~wb_ack_o) begin\n            case (wb_adr_i)\n                8'h60: begin\n                    wb_dat_o <= dat_in_m_tx_bd;\n                    int_ack <= 1'b1;\n                end\n                8'h80: begin\n                    wb_dat_o <= dat_in_m_rx_bd;\n                    int_ack <= 1'b1;\n                end\n                default: ;\n            endcase\n        end\n    end\nend\n\n// Define BD RX and TX logic\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        // Reset BD RX and TX logic\n        dat_in_m_tx_bd <= RAM_MEM_WIDTH'd0;\n        dat_in_m_rx_bd <= RAM_MEM_WIDTH'd0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n    end else begin\n        // Update BD RX and TX logic\n        if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h60) begin\n            we_m_tx_bd <= 1'b1;\n            int_ack <= 1'b0;\n            dat_in_m_tx_bd <= wb_dat_i;\n        end\n        if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h80) begin\n            we_m_rx_bd <= 1'b1;\n            int_ack <= 1'b0;\n            dat_in_m_rx_bd <= wb_dat_i;\n        end\n        if (wb_stb_i && wb_cyc_i && ~wb_ack_o && wb_adr_i == 8'h60) begin\n            wb_dat_o <= dat_in_m_tx_bd;\n            int_ack <= 1'b1;\n        end\n        if (wb_stb_i && wb_cyc_i && ~wb_ack_o && wb_adr_i == 8'h80) begin\n            wb_dat_o <= dat_in_m_rx_bd;\n            int_ack <= 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 3, "code": "module sd_controller_wb(\n    // Wishbone Slave Interface\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire        wb_dat_i [31:0],\n    output wire        wb_dat_o [31:0],\n    input  wire        wb_adr_i [7:0],\n    input  wire        wb_sel_i [3:0],\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n\n    // SD Controller Interface\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n\n    // Command Interface\n    input  wire        write_req_s,\n    input  wire        cmd_set_s [15:0],\n    input  wire        cmd_arg_s [31:0],\n\n    // Registers\n    output wire        argument_reg [31:0],\n    output wire        cmd_setting_reg [15:0],\n    input  wire        status_reg [15:0],\n    input  wire        cmd_resp_1 [31:0],\n    output wire        software_reset_reg [7:0],\n    output wire        time_out_reg [15:0],\n    input  wire        normal_int_status_reg [15:0],\n    input  wire        error_int_status_reg [15:0],\n    output wire        normal_int_signal_enable_reg [15:0],\n    output wire        error_int_signal_enable_reg [15:0],\n    output wire        clock_divider [7:0],\n    input  wire        Bd_Status_reg [15:0],\n    input  wire        Bd_isr_reg [7:0],\n    output wire        Bd_isr_enable_reg [7:0],\n\n    // BD Buffer Interface\n    output wire        dat_in_m_tx_bd [RAM_MEM_WIDTH-1:0],\n    output wire        dat_in_m_rx_bd [RAM_MEM_WIDTH-1:0]\n);\n\n    // Local Variables\n    reg [31:0]        argument_reg;\n    reg [15:0]        cmd_setting_reg;\n    reg [15:0]        status_reg;\n    reg [31:0]        cmd_resp_1;\n    reg [7:0]        software_reset_reg;\n    reg [15:0]        time_out_reg;\n    reg [15:0]        normal_int_status_reg;\n    reg [15:0]        error_int_status_reg;\n    reg [15:0]        normal_int_signal_enable_reg;\n    reg [15:0]        error_int_signal_enable_reg;\n    reg [7:0]        clock_divider;\n    reg [15:0]        Bd_Status_reg;\n    reg [7:0]        Bd_isr_reg;\n    reg [7:0]        Bd_isr_enable_reg;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    reg [31:0]        cmd_arg;\n    reg [15:0]        cmd_set;\n    reg [15:0]        cmd_int_busy;\n    reg [15:0]        int_busy;\n    reg [15:0]        new_cmd;\n    reg [15:0]        we_ack;\n    reg [15:0]        int_ack;\n    reg [15:0]        we_m_tx_bd;\n    reg [15:0]        we_m_rx_bd;\n    reg [15:0]        cmd_int_busy;\n    reg [15:0]        int_busy;\n    reg [15:0]        write_req_s;\n    reg [15:0]        cmd_set_s;\n    reg [31:0]        cmd_arg_s;\n    reg [15:0]        status_reg;\n    reg [31:0]        cmd_resp_1;\n    reg [7:0]        software_reset_reg;\n    reg [15:0]        time_out_reg;\n    reg [15:0]        normal_int_status_reg;\n    reg [15:0]        error_int_status_reg;\n    reg [15:0]        normal_int_signal_enable_reg;\n    reg [15:0]        error_int_signal_enable_reg;\n    reg [7:0]        clock_divider;\n    reg [15:0]        Bd_Status_reg;\n    reg [7:0]        Bd_isr_reg;\n    reg [7:0]        Bd_isr_enable_reg;\n\n    // Reset Logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            argument_reg <= 32'd0;\n            cmd_setting_reg <= 16'd0;\n            status_reg <= 16'd0;\n            cmd_resp_1 <= 32'd0;\n            software_reset_reg <= 8'd0;\n            time_out_reg <= 16'd0;\n            normal_int_status_reg <= 16'd0;\n            error_int_status_reg <= 16'd0;\n            normal_int_signal_enable_reg <= 16'd0;\n            error_int_signal_enable_reg <= 16'd0;\n            clock_divider <= 8'd0;\n            Bd_Status_reg <= 16'd0;\n            Bd_isr_reg <= 8'd0;\n            Bd_isr_enable_reg <= 8'd0;\n            cmd_int_busy <= 16'd0;\n            int_busy <= 16'd0;\n            new_cmd <= 16'd0;\n            we_ack <= 16'd0;\n            int_ack <= 1'b1;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            dat_in_m_tx_bd <= RAM_MEM_WIDTH'(0);\n            dat_in_m_rx_bd <= RAM_MEM_WIDTH'(0);\n            cmd_arg <= 32'd0;\n            cmd_set <= 16'd0;\n            write_req_s <= 16'd0;\n            cmd_set_s <= 16'd0;\n            cmd_arg_s <= 32'd0;\n            status_reg <= 16'd0;\n            cmd_resp_1 <= 32'd0;\n            software_reset_reg <= 8'd0;\n            time_out_reg <= 16'd0;\n            normal_int_status_reg <= 16'd0;\n            error_int_status_reg <= 16'd0;\n            normal_int_signal_enable_reg <= 16'd0;\n            error_int_signal_enable_reg <= 16'd0;\n            clock_divider <= 8'd0;\n            Bd_Status_reg <= 16'd0;\n            Bd_isr_reg <= 8'd0;\n            Bd_isr_enable_reg <= 8'd0;\n        end\n    end\n\n    // Control Logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset logic\n        end else begin\n            // Command Interface\n            if (write_req_s) begin\n                we_ack <= 1'b1;\n            end else begin\n                we_ack <= 1'b0;\n            end\n\n            // New Command\n            if (cmd_arg_s != 32'd0) begin\n                new_cmd <= 1'b1;\n            end else begin\n                new_cmd <= 1'b0;\n            end\n\n            // Command Busy\n            if (cmd_int_busy != 16'd0) begin\n                cmd_int_busy <= 16'd1;\n            end else begin\n                cmd_int_busy <= 16'd0;\n            end\n\n            // Internal Busy\n            if (int_busy != 16'd0) begin\n                int_busy <= 16'd1;\n            end else begin\n                int_busy <= 16'd0;\n            end\n\n            // Interrupt Acknowledge\n            if (int_ack != 1'b0) begin\n                int_ack <= 1'b1;\n            end else begin\n                int_ack <= 1'b0;\n            end\n\n            // Write Enable\n            if (we_m_tx_bd != 1'b0) begin\n                we_m_tx_bd <= 1'b1;\n            end else begin\n                we_m_tx_bd <= 1'b0;\n            end\n\n            if (we_m_rx_bd != 1'b0) begin\n                we_m_rx_bd <= 1'b1;\n            end else begin\n                we_m_rx_bd <= 1'b0;\n            end\n\n            // Data Interface\n            if (dat_in_m_tx_bd != RAM_MEM_WIDTH'(0)) begin\n                dat_in_m_tx_bd <= RAM_MEM_WIDTH'(0);\n            end else begin\n                dat_in_m_tx_bd <= RAM_MEM_WIDTH'(0);\n            end\n\n            if (dat_in_m_rx_bd != RAM_MEM_WIDTH'(0)) begin\n                dat_in_m_rx_bd <= RAM_MEM_WIDTH'(0);\n            end else begin\n                dat_in_m_rx_bd <= RAM_MEM_WIDTH'(0);\n            end\n        end\n    end\n\n    // Register Write\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset logic\n        end else begin\n            if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h08: status_reg <= wb_dat_i[15:0];\n                    8'h0c: cmd_resp_1 <= wb_dat_i;\n                    8'h1c: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h20: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h24: software_reset_reg <= wb_dat_i[7:0];\n                    8'h28: time_out_reg <= wb_dat_i;\n                    8'h30: normal_int_status_reg <= wb_dat_i;\n                    8'h34: error_int_status_reg <= wb_dat_i;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i;\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i;\n                    8'h48: clock_divider <= wb_dat_i[7:0];\n                    8'h50: Bd_Status_reg <= wb_dat_i;\n                    8'h54: Bd_isr_reg <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                    8'h80: dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                    default: wb_ack_o <= 1'b0;\n                endcase\n                wb_ack_o <= 1'b1;\n            end else begin\n                wb_ack_o <= 1'b0;\n            end\n        end\n    end\n\n    // Register Read\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset logic\n        end else begin\n            if (wb_stb_i && wb_cyc_i) begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= cmd_setting_reg;\n                    8'h08: wb_dat_o <= status_reg;\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= cmd_setting_reg;\n                    8'h20: wb_dat_o <= cmd_setting_reg;\n                    8'h24: wb_dat_o <= software_reset_reg;\n                    8'h28: wb_dat_o <= time_out_reg;\n                    8'h30: wb_dat_o <= normal_int_status_reg;\n                    8'h34: wb_dat_o <= error_int_status_reg;\n                    8'h38: wb_dat_o <= normal_int_signal_enable_reg;\n                    8'h3c: wb_dat_o <= error_int_signal_enable_reg;\n                    8'h48: wb_dat_o <= clock_divider;\n                    8'h50: wb_dat_o <= Bd_Status_reg;\n                    8'h54: wb_dat_o <= Bd_isr_reg;\n                    8'h58: wb_dat_o <= Bd_isr_enable_reg;\n                    8'h60: wb_dat_o <= dat_in_m_rx_bd;\n                    8'h80: wb_dat_o <= dat_in_m_tx_bd;\n                    default: wb_dat_o <= 32'd0;\n                endcase\n            end else begin\n                wb_dat_o <= 32'd0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 4, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [ 7:0] wb_adr_i,\n    input  wire [ 3:0] wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [ 7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [ 7:0] clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [ 7:0] Bd_isr_reg,\n    output wire [ 7:0] Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Define the reset values\n    localparam RESET_VALUE = 0;\n\n    // Define the register addresses\n    localparam ARGUMENT_REG_ADDR = 0x00;\n    localparam CMD_SETTING_REG_ADDR = 0x04;\n    localparam STATUS_REG_ADDR = 0x08;\n    localparam RESPONSE_REG_ADDR = 0x0c;\n    localparam CONTROLLER_SETTING_REG_ADDR = 0x1c;\n    localparam BLOCK_SIZE_REG_ADDR = 0x20;\n    localparam POWER_CONTROL_REG_ADDR = 0x24;\n    localparam SOFTWARE_RESET_REG_ADDR = 0x28;\n    localparam TIMEOUT_REG_ADDR = 0x2c;\n    localparam NORMAL_INT_STATUS_REG_ADDR = 0x30;\n    localparam ERROR_INT_STATUS_REG_ADDR = 0x34;\n    localparam NORMAL_INT_ENABLE_REG_ADDR = 0x38;\n    localparam ERROR_INT_ENABLE_REG_ADDR = 0x3c;\n    localparam CAPABILITY_REG_ADDR = 0x48;\n    localparam CLOCK_DIVIDER_REG_ADDR = 0x4c;\n    localparam BD_BUFFER_STATUS_REG_ADDR = 0x50;\n    localparam DAT_INT_STATUS_REG_ADDR = 0x54;\n    localparam DAT_INT_ENABLE_REG_ADDR = 0x58;\n    localparam BD_RX_ADDR = 0x60;\n    localparam BD_TX_ADDR = 0x80;\n\n    // Define the register widths\n    localparam ARGUMENT_REG_WIDTH = 32;\n    localparam CMD_SETTING_REG_WIDTH = 16;\n    localparam STATUS_REG_WIDTH = 16;\n    localparam RESPONSE_REG_WIDTH = 32;\n    localparam CONTROLLER_SETTING_REG_WIDTH = 16;\n    localparam BLOCK_SIZE_REG_WIDTH = 16;\n    localparam POWER_CONTROL_REG_WIDTH = 8;\n    localparam SOFTWARE_RESET_REG_WIDTH = 8;\n    localparam TIMEOUT_REG_WIDTH = 16;\n    localparam NORMAL_INT_STATUS_REG_WIDTH = 16;\n    localparam ERROR_INT_STATUS_REG_WIDTH = 16;\n    localparam NORMAL_INT_ENABLE_REG_WIDTH = 16;\n    localparam ERROR_INT_ENABLE_REG_WIDTH = 16;\n    localparam CAPABILITY_REG_WIDTH = 16;\n    localparam CLOCK_DIVIDER_REG_WIDTH = 8;\n    localparam BD_BUFFER_STATUS_REG_WIDTH = 16;\n    localparam DAT_INT_STATUS_REG_WIDTH = 8;\n    localparam DAT_INT_ENABLE_REG_WIDTH = 8;\n\n    // Define the register values\n    reg [ARGUMENT_REG_WIDTH-1:0] argument_reg;\n    reg [CMD_SETTING_REG_WIDTH-1:0] cmd_setting_reg;\n    reg [STATUS_REG_WIDTH-1:0] status_reg;\n    reg [RESPONSE_REG_WIDTH-1:0] cmd_resp_1;\n    reg [SOFTWARE_RESET_REG_WIDTH-1:0] software_reset_reg;\n    reg [TIMEOUT_REG_WIDTH-1:0] time_out_reg;\n    reg [NORMAL_INT_STATUS_REG_WIDTH-1:0] normal_int_status_reg;\n    reg [ERROR_INT_STATUS_REG_WIDTH-1:0] error_int_status_reg;\n    reg [NORMAL_INT_ENABLE_REG_WIDTH-1:0] normal_int_signal_enable_reg;\n    reg [ERROR_INT_ENABLE_REG_WIDTH-1:0] error_int_signal_enable_reg;\n    reg [CLOCK_DIVIDER_REG_WIDTH-1:0] clock_divider;\n    reg [BD_BUFFER_STATUS_REG_WIDTH-1:0] Bd_Status_reg;\n    reg [DAT_INT_STATUS_REG_WIDTH-1:0] Bd_isr_reg;\n    reg [DAT_INT_ENABLE_REG_WIDTH-1:0] Bd_isr_enable_reg;\n\n    // Define the signals\n    wire cmd_int_busy;\n    wire int_busy;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n\n    // Define the control logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset the registers to their default values\n            argument_reg <= RESET_VALUE;\n            cmd_setting_reg <= RESET_VALUE;\n            status_reg <= RESET_VALUE;\n            cmd_resp_1 <= RESET_VALUE;\n            software_reset_reg <= RESET_VALUE;\n            time_out_reg <= RESET_VALUE;\n            normal_int_status_reg <= RESET_VALUE;\n            error_int_status_reg <= RESET_VALUE;\n            normal_int_signal_enable_reg <= RESET_VALUE;\n            error_int_signal_enable_reg <= RESET_VALUE;\n            clock_divider <= RESET_VALUE;\n            Bd_Status_reg <= RESET_VALUE;\n            Bd_isr_reg <= RESET_VALUE;\n            Bd_isr_enable_reg <= RESET_VALUE;\n        end else begin\n            // Update the registers based on the write requests\n            if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n                case (wb_adr_i)\n                    ARGUMENT_REG_ADDR: argument_reg <= wb_dat_i;\n                    CMD_SETTING_REG_ADDR: cmd_setting_reg <= wb_dat_i;\n                    STATUS_REG_ADDR: status_reg <= wb_dat_i;\n                    RESPONSE_REG_ADDR: cmd_resp_1 <= wb_dat_i;\n                    SOFTWARE_RESET_REG_ADDR: software_reset_reg <= wb_dat_i;\n                    TIMEOUT_REG_ADDR: time_out_reg <= wb_dat_i;\n                    NORMAL_INT_STATUS_REG_ADDR: normal_int_status_reg <= wb_dat_i;\n                    ERROR_INT_STATUS_REG_ADDR: error_int_status_reg <= wb_dat_i;\n                    NORMAL_INT_ENABLE_REG_ADDR: normal_int_signal_enable_reg <= wb_dat_i;\n                    ERROR_INT_ENABLE_REG_ADDR: error_int_signal_enable_reg <= wb_dat_i;\n                    CLOCK_DIVIDER_REG_ADDR: clock_divider <= wb_dat_i;\n                    BD_BUFFER_STATUS_REG_ADDR: Bd_Status_reg <= wb_dat_i;\n                    DAT_INT_STATUS_REG_ADDR: Bd_isr_reg <= wb_dat_i;\n                    DAT_INT_ENABLE_REG_ADDR: Bd_isr_enable_reg <= wb_dat_i;\n                    BD_RX_ADDR: begin\n                        // Write to the BD RX register\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        // Write the data to the BD RX register\n                        for (int i = 0; i < RAM_MEM_WIDTH; i++) begin\n                            if (i < RAM_MEM_WIDTH/2) begin\n                                dat_in_m_rx_bd[i] <= wb_dat_i[RAM_MEM_WIDTH-1-i];\n                            end else begin\n                                dat_in_m_rx_bd[i] <= wb_dat_i[i-RAM_MEM_WIDTH/2];\n                            end\n                        end\n                        // Assert the int_ack signal\n                        int_ack <= 1;\n                    end\n                    BD_TX_ADDR: begin\n                        // Write to the BD TX register\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        // Write the data to the BD TX register\n                        for (int i = 0; i < RAM_MEM_WIDTH; i++) begin\n                            if (i < RAM_MEM_WIDTH/2) begin\n                                dat_in_m_tx_bd[i] <= wb_dat_i[RAM_MEM_WIDTH-1-i];\n                            end else begin\n                                dat_in_m_tx_bd[i] <= wb_dat_i[i-RAM_MEM_WIDTH/2];\n                            end\n                        end\n                        // Assert the int_ack signal\n                        int_ack <= 1;\n                    end\n                    default: // Do nothing\n                endcase\n            end\n        end\n    end\n\n    // Define the read logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset the wb_dat_o signal\n            wb_dat_o <= 0;\n        end else begin\n            // Update the wb_dat_o signal based on the read requests\n            if (wb_stb_i && wb_cyc_i) begin\n                case (wb_adr_i)\n                    ARGUMENT_REG_ADDR: wb_dat_o <= argument_reg;\n                    CMD_SETTING_REG_ADDR: wb_dat_o <= cmd_setting_reg;\n                    STATUS_REG_ADDR: wb_dat_o <= status_reg;\n                    RESPONSE_REG_ADDR: wb_dat_o <= cmd_resp_1;\n                    SOFTWARE_RESET_REG_ADDR: wb_dat_o <= software_reset_reg;\n                    TIMEOUT_REG_ADDR: wb_dat_o <= time_out_reg;\n                    NORMAL_INT_STATUS_REG_ADDR: wb_dat_o <= normal_int_status_reg;\n                    ERROR_INT_STATUS_REG_ADDR: wb_dat_o <= error_int_status_reg;\n                    NORMAL_INT_ENABLE_REG_ADDR: wb_dat_o <= normal_int_signal_enable_reg;\n                    ERROR_INT_ENABLE_REG_ADDR: wb_dat_o <= error_int_signal_enable_reg;\n                    CLOCK_DIVIDER_REG_ADDR: wb_dat_o <= clock_divider;\n                    BD_BUFFER_STATUS_REG_ADDR: wb_dat_o <= Bd_Status_reg;\n                    DAT_INT_STATUS_REG_ADDR: wb_dat_o <= Bd_isr_reg;\n                    DAT_INT_ENABLE_REG_ADDR: wb_dat_o <= Bd_isr_enable_reg;\n                    BD_RX_ADDR: wb_dat_o <= dat_in_m_rx_bd;\n                    BD_TX_ADDR: wb_dat_o <= dat_in_m_tx_bd;\n                    default: // Do nothing\n                endcase\n            end\n        end\n    end\n\n    // Define the control logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset the control signals\n            cmd_int_busy <= 0;\n            int_busy <= 0;\n            new_cmd <= 0;\n            we_ack <= 0;\n            int_ack <= 1;\n            we_m_tx_bd <= 0;\n            we_m_rx_bd <= 0;\n        end else begin\n            // Update the control signals based on the write requests\n            if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n                case (wb_adr_i)\n                    ARGUMENT_REG_ADDR: begin\n                        // Update the argument_reg signal\n                        argument_reg <= wb_dat_i;\n                        // Set the new_cmd signal\n                        new_cmd <= 1;\n                    end\n                    CMD_SETTING_REG_ADDR: begin\n                        // Update the cmd_setting_reg signal\n                        cmd_setting_reg <= wb_dat_i;\n                        // Set the cmd_int_busy signal\n                        cmd_int_busy <= 1;\n                    end\n                    SOFTWARE_RESET_REG_ADDR: begin\n                        // Update the software_reset_reg signal\n                        software_reset_reg <= wb_dat_i;\n                    end\n                    TIMEOUT_REG_ADDR: begin\n                        // Update the time_out_reg signal\n                        time_out_reg <= wb_dat_i;\n                    end\n                    NORMAL_INT_STATUS_REG_ADDR: begin\n                        // Update the normal_int_status_reg signal\n                        normal_int_status_reg <= wb_dat_i;\n                    end\n                    ERROR_INT_STATUS_REG_ADDR: begin\n                        // Update the error_int_status_reg signal\n                        error_int_status_reg <= wb_dat_i;\n                    end\n                    NORMAL_INT_ENABLE_REG_ADDR: begin\n                        // Update the normal_int_signal_enable_reg signal\n                        normal_int_signal_enable_reg <= wb_dat_i;\n                    end\n                    ERROR_INT_ENABLE_REG_ADDR: begin\n                        // Update the error_int_signal_enable_reg signal\n                        error_int_signal_enable_reg <= wb_dat_i;\n                    end\n                    CLOCK_DIVIDER_REG_ADDR: begin\n                        // Update the clock_divider signal\n                        clock_divider <= wb_dat_i;\n                    end\n                    BD_BUFFER_STATUS_REG_ADDR: begin\n                        // Update the Bd_Status_reg signal\n                        Bd_Status_reg <= wb_dat_i;\n                    end\n                    DAT_INT_STATUS_REG_ADDR: begin\n                        // Update the Bd_isr_reg signal\n                        Bd_isr_reg <= wb_dat_i;\n                    end\n                    DAT_INT_ENABLE_REG_ADDR: begin\n                        // Update the Bd_isr_enable_reg signal\n                        Bd_isr_enable_reg <= wb_dat_i;\n                    end\n                    BD_RX_ADDR: begin\n                        // Set the we_m_rx_bd signal\n                        we_m_rx_bd <= 1;\n                        // Set the int_ack signal\n                        int_ack <= 0;\n                    end\n                    BD_TX_ADDR: begin\n                        // Set the we_m_tx_bd signal\n                        we_m_tx_bd <= 1;\n                        // Set the int_ack signal\n                        int_ack <= 0;\n                    end\n                    default: // Do nothing\n                endcase\n            end\n        end\n    end\n\n    // Define the wb_ack_o signal\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset the wb_ack_o signal\n            wb_ack_o <= 0;\n        end else begin\n            // Update the wb_ack_o signal based on the wb_cyc_i and wb_stb_i signals\n            if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n                wb_ack_o <= 1;\n            end else begin\n                wb_ack_o <= 0;\n            end\n        end\n    end\n\n    // Define the we_ack signal\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset the we_ack signal\n            we_ack <= 0;\n        end else begin\n            // Update the we_ack signal based on the write_req_s signal\n            if (write_req_s) begin\n                we_ack <= 1;\n            end else begin\n                we_ack <= 0;\n            end\n        end\n    end\n\n    // Define the new_cmd signal\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset the new_cmd signal\n            new_cmd <= 0;\n        end else begin\n            // Update the new_cmd signal based on the cmd_arg_s signal\n            if (cmd_arg_s != RESET_VALUE) begin\n                new_cmd <= 1;\n            end else begin\n                new_cmd <= 0;\n            end\n        end\n    end\n\n    // Define the cmd_int_busy signal\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset the cmd_int_busy signal\n            cmd_int_busy <= 0;\n        end else begin\n            // Update the cmd_int_busy signal based on the cmd_setting_reg signal\n            if (cmd_setting_reg != RESET_VALUE) begin\n                cmd_int_busy <= 1;\n            end else begin\n                cmd_int_busy <= 0;\n            end\n        end\n    end\n\n    // Define the int_busy signal\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset the int_busy signal\n            int_busy <= 0;\n        end else begin\n            // Update the int_busy signal based on the wb_adr_i signal\n            if (wb_adr_i == CMD_SETTING_REG_ADDR) begin\n                int_busy <= 1;\n            end else begin\n                int_busy <= 0;\n            end\n        end\n    end\n\n    // Define the we_m_tx_bd signal\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset the we_m_tx_bd signal\n            we_m_tx_bd <= 0;\n        end else begin\n            // Update the we_m_tx_bd signal based on the BD_TX_ADDR signal\n            if (wb_adr_i == BD_TX_ADDR) begin\n                we_m_tx_bd <= 1;\n            end else begin\n                we_m_tx_bd <= 0;\n            end\n        end\n    end\n\n    // Define the we_m_rx_bd signal\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset the we_m_rx_bd signal\n            we_m_rx_bd <= 0;\n        end else begin\n            // Update the we_m_rx_bd signal based on the BD_RX_ADDR signal\n            if (wb_adr_i == BD_RX_ADDR) begin\n                we_m_rx_bd <= 1;\n            end else begin\n                we_m_rx_bd <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 5, "code": "module sd_controller_wb(\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire we_m_tx_bd,\n    output wire we_m_rx_bd,\n    output wire new_cmd,\n    output wire we_ack,\n    output wire int_ack,\n    output wire cmd_int_busy,\n    output wire int_busy,\n    input  wire write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0] clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0] Bd_isr_reg,\n    output wire [7:0] Bd_isr_enable_reg,\n    output wire Bd_isr_reset,\n    output wire normal_isr_reset,\n    output wire error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Define the reset values for the registers\n    localparam RESET_VALUE_ARGUMENT_REG = 32'h00000000;\n    localparam RESET_VALUE_CMD_SETTING_REG = 16'h0000;\n    localparam RESET_VALUE_STATUS_REG = 16'h0000;\n    localparam RESET_VALUE_CMD_RESP_1 = 32'h00000000;\n    localparam RESET_VALUE_SOFTWARE_RESET_REG = 8'h00;\n    localparam RESET_VALUE_TIME_OUT_REG = 16'h0000;\n    localparam RESET_VALUE_NORMAL_INT_STATUS_REG = 16'h0000;\n    localparam RESET_VALUE_ERROR_INT_STATUS_REG = 16'h0000;\n    localparam RESET_VALUE_NORMAL_INT_SIGNAL_ENABLE_REG = 16'h0000;\n    localparam RESET_VALUE_ERROR_INT_SIGNAL_ENABLE_REG = 16'h0000;\n    localparam RESET_VALUE_CLOCK_DIVIDER = 8'h00;\n    localparam RESET_VALUE_BD_STATUS_REG = 16'h0404;\n    localparam RESET_VALUE_BD_ISR_REG = 8'h00;\n    localparam RESET_VALUE_BD_ISR_ENABLE_REG = 8'h00;\n\n    // Define the register widths\n    localparam REG_WIDTH_ARGUMENT_REG = 32;\n    localparam REG_WIDTH_CMD_SETTING_REG = 16;\n    localparam REG_WIDTH_STATUS_REG = 16;\n    localparam REG_WIDTH_CMD_RESP_1 = 32;\n    localparam REG_WIDTH_SOFTWARE_RESET_REG = 8;\n    localparam REG_WIDTH_TIME_OUT_REG = 16;\n    localparam REG_WIDTH_NORMAL_INT_STATUS_REG = 16;\n    localparam REG_WIDTH_ERROR_INT_STATUS_REG = 16;\n    localparam REG_WIDTH_NORMAL_INT_SIGNAL_ENABLE_REG = 16;\n    localparam REG_WIDTH_ERROR_INT_SIGNAL_ENABLE_REG = 16;\n    localparam REG_WIDTH_CLOCK_DIVIDER = 8;\n    localparam REG_WIDTH_BD_STATUS_REG = 16;\n    localparam REG_WIDTH_BD_ISR_REG = 8;\n    localparam REG_WIDTH_BD_ISR_ENABLE_REG = 8;\n\n    // Define the addresses of the registers\n    localparam ADDRESS_ARGUMENT_REG = 32'h0000;\n    localparam ADDRESS_CMD_SETTING_REG = 32'h0004;\n    localparam ADDRESS_STATUS_REG = 32'h0008;\n    localparam ADDRESS_CMD_RESP_1 = 32'h000c;\n    localparam ADDRESS_SOFTWARE_RESET_REG = 32'h0028;\n    localparam ADDRESS_TIME_OUT_REG = 32'h002c;\n    localparam ADDRESS_NORMAL_INT_STATUS_REG = 32'h0030;\n    localparam ADDRESS_ERROR_INT_STATUS_REG = 32'h0034;\n    localparam ADDRESS_NORMAL_INT_SIGNAL_ENABLE_REG = 32'h0038;\n    localparam ADDRESS_ERROR_INT_SIGNAL_ENABLE_REG = 32'h003c;\n    localparam ADDRESS_CLOCK_DIVIDER = 32'h004c;\n    localparam ADDRESS_BD_STATUS_REG = 32'h0050;\n    localparam ADDRESS_BD_ISR_REG = 32'h0054;\n    localparam ADDRESS_BD_ISR_ENABLE_REG = 32'h0058;\n\n    // Define the signals\n    reg [REG_WIDTH_ARGUMENT_REG-1:0] argument_reg;\n    reg [REG_WIDTH_CMD_SETTING_REG-1:0] cmd_setting_reg;\n    reg [REG_WIDTH_STATUS_REG-1:0] status_reg;\n    reg [REG_WIDTH_CMD_RESP_1-1:0] cmd_resp_1;\n    reg [REG_WIDTH_SOFTWARE_RESET_REG-1:0] software_reset_reg;\n    reg [REG_WIDTH_TIME_OUT_REG-1:0] time_out_reg;\n    reg [REG_WIDTH_NORMAL_INT_STATUS_REG-1:0] normal_int_status_reg;\n    reg [REG_WIDTH_ERROR_INT_STATUS_REG-1:0] error_int_status_reg;\n    reg [REG_WIDTH_NORMAL_INT_SIGNAL_ENABLE_REG-1:0] normal_int_signal_enable_reg;\n    reg [REG_WIDTH_ERROR_INT_SIGNAL_ENABLE_REG-1:0] error_int_signal_enable_reg;\n    reg [REG_WIDTH_CLOCK_DIVIDER-1:0] clock_divider;\n    reg [REG_WIDTH_BD_STATUS_REG-1:0] Bd_Status_reg;\n    reg [REG_WIDTH_BD_ISR_REG-1:0] Bd_isr_reg;\n    reg [REG_WIDTH_BD_ISR_ENABLE_REG-1:0] Bd_isr_enable_reg;\n\n    // Define the clock and reset logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            argument_reg <= RESET_VALUE_ARGUMENT_REG;\n            cmd_setting_reg <= RESET_VALUE_CMD_SETTING_REG;\n            status_reg <= RESET_VALUE_STATUS_REG;\n            cmd_resp_1 <= RESET_VALUE_CMD_RESP_1;\n            software_reset_reg <= RESET_VALUE_SOFTWARE_RESET_REG;\n            time_out_reg <= RESET_VALUE_TIME_OUT_REG;\n            normal_int_status_reg <= RESET_VALUE_NORMAL_INT_STATUS_REG;\n            error_int_status_reg <= RESET_VALUE_ERROR_INT_STATUS_REG;\n            normal_int_signal_enable_reg <= RESET_VALUE_NORMAL_INT_SIGNAL_ENABLE_REG;\n            error_int_signal_enable_reg <= RESET_VALUE_ERROR_INT_SIGNAL_ENABLE_REG;\n            clock_divider <= RESET_VALUE_CLOCK_DIVIDER;\n            Bd_Status_reg <= RESET_VALUE_BD_STATUS_REG;\n            Bd_isr_reg <= RESET_VALUE_BD_ISR_REG;\n            Bd_isr_enable_reg <= RESET_VALUE_BD_ISR_ENABLE_REG;\n        end\n        else begin\n            // Update the registers based on the write requests\n            if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n                case (wb_adr_i)\n                    ADDRESS_ARGUMENT_REG: argument_reg <= wb_dat_i;\n                    ADDRESS_CMD_SETTING_REG: cmd_setting_reg <= wb_dat_i;\n                    ADDRESS_STATUS_REG: status_reg <= wb_dat_i;\n                    ADDRESS_CMD_RESP_1: cmd_resp_1 <= wb_dat_i;\n                    ADDRESS_SOFTWARE_RESET_REG: software_reset_reg <= wb_dat_i;\n                    ADDRESS_TIME_OUT_REG: time_out_reg <= wb_dat_i;\n                    ADDRESS_NORMAL_INT_STATUS_REG: normal_int_status_reg <= wb_dat_i;\n                    ADDRESS_ERROR_INT_STATUS_REG: error_int_status_reg <= wb_dat_i;\n                    ADDRESS_NORMAL_INT_SIGNAL_ENABLE_REG: normal_int_signal_enable_reg <= wb_dat_i;\n                    ADDRESS_ERROR_INT_SIGNAL_ENABLE_REG: error_int_signal_enable_reg <= wb_dat_i;\n                    ADDRESS_CLOCK_DIVIDER: clock_divider <= wb_dat_i;\n                    ADDRESS_BD_STATUS_REG: Bd_Status_reg <= wb_dat_i;\n                    ADDRESS_BD_ISR_REG: Bd_isr_reg <= wb_dat_i;\n                    ADDRESS_BD_ISR_ENABLE_REG: Bd_isr_enable_reg <= wb_dat_i;\n                endcase\n            end\n        end\n    end\n\n    // Define the output signals\n    assign wb_dat_o = {argument_reg, cmd_setting_reg, status_reg, cmd_resp_1, software_reset_reg, time_out_reg, normal_int_status_reg, error_int_status_reg, normal_int_signal_enable_reg, error_int_signal_enable_reg, clock_divider, Bd_Status_reg, Bd_isr_reg, Bd_isr_enable_reg};\n    assign new_cmd = (cmd_setting_reg[13:8] != 0);\n    assign we_ack = write_req_s;\n    assign int_ack = 1'b1;\n    assign cmd_int_busy = (cmd_setting_reg[13:8] != 0) || (cmd_setting_reg[7:6] != 0);\n    assign int_busy = (wb_adr_i == ADDRESS_CMD_SETTING_REG);\n    assign we_m_tx_bd = 1'b0;\n    assign we_m_rx_bd = 1'b0;\n\n    // Define the logic for the BD registers\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n        else begin\n            if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == ADDRESS_BD_TX || wb_adr_i == ADDRESS_BD_RX)) begin\n                if (RAM_MEM_WIDTH == 32) begin\n                    if (wb_adr_i == ADDRESS_BD_TX) begin\n                        we_m_tx_bd <= 1'b1;\n                        dat_in_m_tx_bd <= wb_dat_i;\n                    end\n                    else if (wb_adr_i == ADDRESS_BD_RX) begin\n                        we_m_rx_bd <= 1'b1;\n                        dat_in_m_rx_bd <= wb_dat_i;\n                    end\n                end\n                else if (RAM_MEM_WIDTH == 16) begin\n                    if (wb_adr_i == ADDRESS_BD_TX) begin\n                        we_m_tx_bd <= 1'b1;\n                        dat_in_m_tx_bd <= {wb_dat_i[15:0], 16'h0};\n                    end\n                    else if (wb_adr_i == ADDRESS_BD_RX) begin\n                        we_m_rx_bd <= 1'b1;\n                        dat_in_m_rx_bd <= {wb_dat_i[15:0], 16'h0};\n                    end\n                end\n                int_ack <= 1'b0;\n            end\n            else begin\n                we_m_tx_bd <= 1'b0;\n                we_m_rx_bd <= 1'b0;\n                int_ack <= 1'b1;\n            end\n        end\n    end\n\n    // Define the logic for the wb_ack_o signal\n    assign wb_ack_o = (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 6, "code": "Here is the Verilog code for the `sd_controller_wb` module:\n```\nmodule sd_controller_wb(\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire         wb_we_i,\n    input  wire         wb_cyc_i,\n    input  wire         wb_stb_i,\n    output wire         wb_ack_o,\n    output wire         we_m_tx_bd,\n    output wire         we_m_rx_bd,\n    output wire         new_cmd,\n    output wire         we_ack,\n    output wire         int_ack,\n    output wire         cmd_int_busy,\n    output wire         int_busy,\n    input  wire         write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire         Bd_isr_reset,\n    output wire         normal_isr_reset,\n    output wire         error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n// Define the reset values for the registers\nlocalparam RESET_VAL = 0;\n\n// Define the register addresses\nlocalparam ARGUMENT_REG_ADDR = 4'h0;\nlocalparam CMD_SETTING_REG_ADDR = 4'h4;\nlocalparam STATUS_REG_ADDR = 4'h8;\nlocalparam RESP_REG_ADDR = 4'h0c;\nlocalparam CONTROLLER_SETTING_REG_ADDR = 4'h1c;\nlocalparam BLOCK_SIZE_REG_ADDR = 4'h20;\nlocalparam POWER_CONTROL_REG_ADDR = 4'h24;\nlocalparam SOFTWARE_RESET_REG_ADDR = 4'h28;\nlocalparam TIMEOUT_REG_ADDR = 4'h2c;\nlocalparam NORMAL_INT_STATUS_REG_ADDR = 4'h30;\nlocalparam ERROR_INT_STATUS_REG_ADDR = 4'h34;\nlocalparam NORMAL_INT_ENABLE_REG_ADDR = 4'h38;\nlocalparam ERROR_INT_ENABLE_REG_ADDR = 4'h3c;\nlocalparam CAPABILITY_REG_ADDR = 4'h48;\nlocalparam CLOCK_DIVIDER_REG_ADDR = 4'h4c;\nlocalparam BD_BUFFER_STATUS_REG_ADDR = 4'h50;\nlocalparam DAT_INT_STATUS_REG_ADDR = 4'h54;\nlocalparam DAT_INT_ENABLE_REG_ADDR = 4'h58;\nlocalparam BD_RX_REG_ADDR = 4'h60;\nlocalparam BD_TX_REG_ADDR = 4'h80;\n\n// Define the register widths\nlocalparam ARGUMENT_REG_WIDTH = 32;\nlocalparam CMD_SETTING_REG_WIDTH = 16;\nlocalparam STATUS_REG_WIDTH = 16;\nlocalparam RESP_REG_WIDTH = 32;\nlocalparam CONTROLLER_SETTING_REG_WIDTH = 16;\nlocalparam BLOCK_SIZE_REG_WIDTH = 16;\nlocalparam POWER_CONTROL_REG_WIDTH = 8;\nlocalparam SOFTWARE_RESET_REG_WIDTH = 8;\nlocalparam TIMEOUT_REG_WIDTH = 16;\nlocalparam NORMAL_INT_STATUS_REG_WIDTH = 16;\nlocalparam ERROR_INT_STATUS_REG_WIDTH = 16;\nlocalparam NORMAL_INT_ENABLE_REG_WIDTH = 16;\nlocalparam ERROR_INT_ENABLE_REG_WIDTH = 16;\nlocalparam CAPABILITY_REG_WIDTH = 16;\nlocalparam CLOCK_DIVIDER_REG_WIDTH = 8;\nlocalparam BD_BUFFER_STATUS_REG_WIDTH = 16;\nlocalparam DAT_INT_STATUS_REG_WIDTH = 8;\nlocalparam DAT_INT_ENABLE_REG_WIDTH = 8;\nlocalparam BD_RX_REG_WIDTH = RAM_MEM_WIDTH;\nlocalparam BD_TX_REG_WIDTH = RAM_MEM_WIDTH;\n\n// Define the register bits\nlocalparam ARGUMENT_REG_BIT = {ARGUMENT_REG_WIDTH{1'b1}};\nlocalparam CMD_SETTING_REG_BIT = {CMD_SETTING_REG_WIDTH{1'b1}};\nlocalparam STATUS_REG_BIT = {STATUS_REG_WIDTH{1'b1}};\nlocalparam RESP_REG_BIT = {RESP_REG_WIDTH{1'b1}};\nlocalparam CONTROLLER_SETTING_REG_BIT = {CONTROLLER_SETTING_REG_WIDTH{1'b1}};\nlocalparam BLOCK_SIZE_REG_BIT = {BLOCK_SIZE_REG_WIDTH{1'b1}};\nlocalparam POWER_CONTROL_REG_BIT = {POWER_CONTROL_REG_WIDTH{1'b1}};\nlocalparam SOFTWARE_RESET_REG_BIT = {SOFTWARE_RESET_REG_WIDTH{1'b1}};\nlocalparam TIMEOUT_REG_BIT = {TIMEOUT_REG_WIDTH{1'b1}};\nlocalparam NORMAL_INT_STATUS_REG_BIT = {NORMAL_INT_STATUS_REG_WIDTH{1'b1}};\nlocalparam ERROR_INT_STATUS_REG_BIT = {ERROR_INT_STATUS_REG_WIDTH{1'b1}};\nlocalparam NORMAL_INT_ENABLE_REG_BIT = {NORMAL_INT_ENABLE_REG_WIDTH{1'b1}};\nlocalparam ERROR_INT_ENABLE_REG_BIT = {ERROR_INT_ENABLE_REG_WIDTH{1'b1}};\nlocalparam CAPABILITY_REG_BIT = {CAPABILITY_REG_WIDTH{1'b1}};\nlocalparam CLOCK_DIVIDER_REG_BIT = {CLOCK_DIVIDER_REG_WIDTH{1'b1}};\nlocalparam BD_BUFFER_STATUS_REG_BIT = {BD_BUFFER_STATUS_REG_WIDTH{1'b1}};\nlocalparam DAT_INT_STATUS_REG_BIT = {DAT_INT_STATUS_REG_WIDTH{1'b1}};\nlocalparam DAT_INT_ENABLE_REG_BIT = {DAT_INT_ENABLE_REG_WIDTH{1'b1}};\nlocalparam BD_RX_REG_BIT = {BD_RX_REG_WIDTH{1'b1}};\nlocalparam BD_TX_REG_BIT = {BD_TX_REG_WIDTH{1'b1}};\n\n// Define the register values\nreg [ARGUMENT_REG_WIDTH-1:0] argument_reg;\nreg [CMD_SETTING_REG_WIDTH-1:0] cmd_setting_reg;\nreg [STATUS_REG_WIDTH-1:0] status_reg;\nreg [RESP_REG_WIDTH-1:0] resp_reg;\nreg [CONTROLLER_SETTING_REG_WIDTH-1:0] controller_setting_reg;\nreg [BLOCK_SIZE_REG_WIDTH-1:0] block_size_reg;\nreg [POWER_CONTROL_REG_WIDTH-1:0] power_control_reg;\nreg [SOFTWARE_RESET_REG_WIDTH-1:0] software_reset_reg;\nreg [TIMEOUT_REG_WIDTH-1:0] time_out_reg;\nreg [NORMAL_INT_STATUS_REG_WIDTH-1:0] normal_int_status_reg;\nreg [ERROR_INT_STATUS_REG_WIDTH-1:0] error_int_status_reg;\nreg [NORMAL_INT_ENABLE_REG_WIDTH-1:0] normal_int_enable_reg;\nreg [ERROR_INT_ENABLE_REG_WIDTH-1:0] error_int_enable_reg;\nreg [CAPABILITY_REG_WIDTH-1:0] capability_reg;\nreg [CLOCK_DIVIDER_REG_WIDTH-1:0] clock_divider;\nreg [BD_BUFFER_STATUS_REG_WIDTH-1:0] bd_buffer_status_reg;\nreg [DAT_INT_STATUS_REG_WIDTH-1:0] dat_int_status_reg;\nreg [DAT_INT_ENABLE_REG_WIDTH-1:0] dat_int_enable_reg;\nreg [BD_RX_REG_WIDTH-1:0] bd_rx_reg;\nreg [BD_TX_REG_WIDTH-1:0] bd_tx_reg;\n\n// Define the signals\nwire int_ack;\nwire cmd_int_busy;\nwire int_busy;\nwire new_cmd;\nwire we_ack;\nwire we_m_tx_bd;\nwire we_m_rx_bd;\n\n// Define the control logic\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        argument_reg <= RESET_VAL;\n        cmd_setting_reg <= RESET_VAL;\n        status_reg <= RESET_VAL;\n        resp_reg <= RESET_VAL;\n        controller_setting_reg <= RESET_VAL;\n        block_size_reg <= RESET_VAL;\n        power_control_reg <= RESET_VAL;\n        software_reset_reg <= RESET_VAL;\n        time_out_reg <= RESET_VAL;\n        normal_int_status_reg <= RESET_VAL;\n        error_int_status_reg <= RESET_VAL;\n        normal_int_enable_reg <= RESET_VAL;\n        error_int_enable_reg <= RESET_VAL;\n        capability_reg <= RESET_VAL;\n        clock_divider <= RESET_VAL;\n        bd_buffer_status_reg <= RESET_VAL;\n        dat_int_status_reg <= RESET_VAL;\n        dat_int_enable_reg <= RESET_VAL;\n        bd_rx_reg <= RESET_VAL;\n        bd_tx_reg <= RESET_VAL;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n    end\n    else begin\n        // Register write logic\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                ARGUMENT_REG_ADDR: argument_reg <= wb_dat_i;\n                CMD_SETTING_REG_ADDR: cmd_setting_reg <= wb_dat_i;\n                STATUS_REG_ADDR: status_reg <= wb_dat_i;\n                RESP_REG_ADDR: resp_reg <= wb_dat_i;\n                CONTROLLER_SETTING_REG_ADDR: controller_setting_reg <= wb_dat_i;\n                BLOCK_SIZE_REG_ADDR: block_size_reg <= wb_dat_i;\n                POWER_CONTROL_REG_ADDR: power_control_reg <= wb_dat_i;\n                SOFTWARE_RESET_REG_ADDR: software_reset_reg <= wb_dat_i;\n                TIMEOUT_REG_ADDR: time_out_reg <= wb_dat_i;\n                NORMAL_INT_STATUS_REG_ADDR: normal_int_status_reg <= wb_dat_i;\n                ERROR_INT_STATUS_REG_ADDR: error_int_status_reg <= wb_dat_i;\n                NORMAL_INT_ENABLE_REG_ADDR: normal_int_enable_reg <= wb_dat_i;\n                ERROR_INT_ENABLE_REG_ADDR: error_int_enable_reg <= wb_dat_i;\n                CAPABILITY_REG_ADDR: capability_reg <= wb_dat_i;\n                CLOCK_DIVIDER_REG_ADDR: clock_divider <= wb_dat_i;\n                BD_BUFFER_STATUS_REG_ADDR: bd_buffer_status_reg <= wb_dat_i;\n                DAT_INT_STATUS_REG_ADDR: dat_int_status_reg <= wb_dat_i;\n                DAT_INT_ENABLE_REG_ADDR: dat_int_enable_reg <= wb_dat_i;\n                BD_RX_REG_ADDR: bd_rx_reg <= wb_dat_i;\n                BD_TX_REG_ADDR: bd_tx_reg <= wb_dat_i;\n                default: ;\n            endcase\n        end\n\n        // Register read logic\n        if (wb_stb_i && wb_cyc_i) begin\n            case (wb_adr_i)\n                ARGUMENT_REG_ADDR: wb_dat_o <= argument_reg;\n                CMD_SETTING_REG_ADDR: wb_dat_o <= cmd_setting_reg;\n                STATUS_REG_ADDR: wb_dat_o <= status_reg;\n                RESP_REG_ADDR: wb_dat_o <= resp_reg;\n                CONTROLLER_SETTING_REG_ADDR: wb_dat_o <= controller_setting_reg;\n                BLOCK_SIZE_REG_ADDR: wb_dat_o <= block_size_reg;\n                POWER_CONTROL_REG_ADDR: wb_dat_o <= power_control_reg;\n                SOFTWARE_RESET_REG_ADDR: wb_dat_o <= software_reset_reg;\n                TIMEOUT_REG_ADDR: wb_dat_o <= time_out_reg;\n                NORMAL_INT_STATUS_REG_ADDR: wb_dat_o <= normal_int_status_reg;\n                ERROR_INT_STATUS_REG_ADDR: wb_dat_o <= error_int_status_reg;\n                NORMAL_INT_ENABLE_REG_ADDR: wb_dat_o <= normal_int_enable_reg;\n                ERROR_INT_ENABLE_REG_ADDR: wb_dat_o <= error_int_enable_reg;\n                CAPABILITY_REG_ADDR: wb_dat_o <= capability_reg;\n                CLOCK_DIVIDER_REG_ADDR: wb_dat_o <= clock_divider;\n                BD_BUFFER_STATUS_REG_ADDR: wb_dat_o <= bd_buffer_status_reg;\n                DAT_INT_STATUS_REG_ADDR: wb_dat_o <= dat_int_status_reg;\n                DAT_INT_ENABLE_REG_ADDR: wb_dat_o <= dat_int_enable_reg;\n                BD_RX_REG_ADDR: wb_dat_o <= bd_rx_reg;\n                BD_TX_REG_ADDR: wb_dat_o <= bd_tx_reg;\n                default: wb_dat_o <= 0;\n            endcase\n        end\n\n        // Control logic\n        if (write_req_s) begin\n            we_ack <= 1'b1;\n        end\n        else begin\n            we_ack <= 1'b0;\n        end\n\n        if (cmd_arg_s != 0) begin\n            new_cmd <= 1'b1;\n        end\n        else begin\n            new_cmd <= 1'b0;\n        end\n\n        if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n            wb_ack_o <= 1'b1;\n        end\n        else begin\n            wb_ack_o <= 1'b0;\n        end\n\n        if (int_ack) begin\n            int_ack <= 1'b0;\n        end\n        else begin\n            int_ack <= 1'b1;\n        end\n\n        if (we_m_tx_bd) begin\n            we_m_tx_bd <= 1'b0;\n        end\n        else begin\n            we_m_tx_bd <= 1'b1;\n        end\n\n        if (we_m_rx_bd) begin\n            we_m_rx_bd <= 1'b0;\n        end\n        else begin\n            we_m_rx_bd <= 1'b1;\n        end\n    end\nend\n\n// Define the BD RX and TX logic\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        bd_rx_reg <= 0;\n        bd_tx_reg <= 0;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n    end\n    else begin\n        if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == BD_RX_REG_ADDR) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                bd_rx_reg <= wb_dat_i;\n            end\n            else begin\n                bd_rx_reg[15:0] <= wb_dat_i[15:0];\n                bd_rx_reg[31:16] <= wb_dat_i[31:16];\n            end\n            int_ack <= 1'b0;\n            we_m_rx_bd <= 1'b1;\n        end\n        else if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == BD_TX_REG_ADDR) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                bd_tx_reg <= wb_dat_i;\n            end\n            else begin\n                bd_tx_reg[15:0] <= wb_dat_i[15:0];\n                bd_tx_reg[31:16] <= wb_dat_i[31:16];\n            end\n            int_ack <= 1'b0;\n            we_m_tx_bd <= 1'b1;\n        end\n        else begin\n            int_ack <= 1'b1;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n    end\nend\n\nendmodule\n```\nNote that this is a complex module and the code is quite long. I have tried to follow the specification as closely as possible, but there may be some errors or omissions. Please review the code carefully and let me know if you have any questions or need further clarification.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 7, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [ 7:0] wb_adr_i,\n    input  wire [ 3:0] wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [ 7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [ 7:0] clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [ 7:0] Bd_isr_reg,\n    output wire [ 7:0] Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Define the registers\n    reg [31:0] argument_reg;\n    reg [15:0] cmd_setting_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [ 7:0] software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [ 7:0] clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [ 7:0] Bd_isr_reg;\n    reg [ 7:0] Bd_isr_enable_reg;\n\n    // Define the control signals\n    wire int_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire we_ack;\n    wire new_cmd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n\n    // Define the clock divider\n    reg [7:0] clock_divider_reg;\n\n    // Define the BD buffer status\n    reg [15:0] Bd_Status_reg_reg;\n\n    // Define the data interrupt status\n    reg [7:0] Bd_isr_reg_reg;\n\n    // Define the data interrupt enable\n    reg [7:0] Bd_isr_enable_reg_reg;\n\n    // Define the BD RX and TX registers\n    reg [63:0] bd_rx_reg;\n    reg [63:0] bd_tx_reg;\n\n    // Define the write enable signals\n    wire we_m_tx_bd_reg;\n    wire we_m_rx_bd_reg;\n\n    // Define the reset signals\n    wire Bd_isr_reset_reg;\n    wire normal_isr_reset_reg;\n    wire error_isr_reset_reg;\n\n    // Define the clock divider\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            clock_divider_reg <= 0;\n        end else begin\n            clock_divider_reg <= clock_divider_reg + 1;\n        end\n    end\n\n    // Define the BD buffer status\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            Bd_Status_reg_reg <= 0;\n        end else begin\n            Bd_Status_reg_reg <= Bd_Status_reg_reg;\n        end\n    end\n\n    // Define the data interrupt status\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            Bd_isr_reg_reg <= 0;\n        end else begin\n            Bd_isr_reg_reg <= Bd_isr_reg_reg;\n        end\n    end\n\n    // Define the data interrupt enable\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            Bd_isr_enable_reg_reg <= 0;\n        end else begin\n            Bd_isr_enable_reg_reg <= Bd_isr_enable_reg_reg;\n        end\n    end\n\n    // Define the BD RX and TX registers\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            bd_rx_reg <= 0;\n            bd_tx_reg <= 0;\n        end else begin\n            if (we_m_tx_bd_reg) begin\n                bd_tx_reg <= wb_dat_i;\n            end\n            if (we_m_rx_bd_reg) begin\n                wb_dat_o <= bd_rx_reg;\n            end\n        end\n    end\n\n    // Define the write enable signals\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            we_m_tx_bd_reg <= 0;\n            we_m_rx_bd_reg <= 0;\n        end else begin\n            if (write_req_s) begin\n                we_m_tx_bd_reg <= 1;\n                we_m_rx_bd_reg <= 1;\n            end else begin\n                we_m_tx_bd_reg <= 0;\n                we_m_rx_bd_reg <= 0;\n            end\n        end\n    end\n\n    // Define the reset signals\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            Bd_isr_reset_reg <= 1;\n            normal_isr_reset_reg <= 1;\n            error_isr_reset_reg <= 1;\n        end else begin\n            Bd_isr_reset_reg <= 0;\n            normal_isr_reset_reg <= 0;\n            error_isr_reset_reg <= 0;\n        end\n    end\n\n    // Define the control logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            int_ack <= 1;\n            cmd_int_busy <= 0;\n            int_busy <= 0;\n            we_ack <= 0;\n            new_cmd <= 0;\n        end else begin\n            if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n                wb_ack_o <= 1;\n            end\n            if (write_req_s) begin\n                we_ack <= 1;\n            end else begin\n                we_ack <= 0;\n            end\n            if (cmd_arg_s!= 0) begin\n                new_cmd <= 1;\n            end else begin\n                new_cmd <= 0;\n            end\n            if (cmd_int_busy) begin\n                cmd_int_busy <= 1;\n            end else begin\n                cmd_int_busy <= 0;\n            end\n            if (int_busy) begin\n                int_busy <= 1;\n            end else begin\n                int_busy <= 0;\n            end\n        end\n    end\n\n    // Define the register write logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            argument_reg <= 0;\n            cmd_setting_reg <= 0;\n            status_reg <= 0;\n            cmd_resp_1 <= 0;\n            software_reset_reg <= 0;\n            time_out_reg <= 0;\n            normal_int_status_reg <= 0;\n            error_int_status_reg <= 0;\n            normal_int_signal_enable_reg <= 0;\n            error_int_signal_enable_reg <= 0;\n            clock_divider <= 0;\n            Bd_Status_reg <= 0;\n            Bd_isr_reg <= 0;\n            Bd_isr_enable_reg <= 0;\n        end else begin\n            if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n                case (wb_adr_i)\n                    4'h0: argument_reg <= wb_dat_i;\n                    4'h4: cmd_setting_reg <= wb_dat_i;\n                    4'h8: status_reg <= wb_dat_i;\n                    4'hc: cmd_resp_1 <= wb_dat_i;\n                    4'h1c: software_reset_reg <= wb_dat_i;\n                    4'h28: time_out_reg <= wb_dat_i;\n                    4'h30: normal_int_status_reg <= wb_dat_i;\n                    4'h34: error_int_status_reg <= wb_dat_i;\n                    4'h38: normal_int_signal_enable_reg <= wb_dat_i;\n                    4'h3c: error_int_signal_enable_reg <= wb_dat_i;\n                    4'h48: clock_divider <= wb_dat_i;\n                    4'h50: Bd_Status_reg <= wb_dat_i;\n                    4'h54: Bd_isr_reg <= wb_dat_i;\n                    4'h58: Bd_isr_enable_reg <= wb_dat_i;\n                    default: ;\n                endcase\n            end\n        end\n    end\n\n    // Define the register read logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            argument_reg <= 0;\n            cmd_setting_reg <= 0;\n            status_reg <= 0;\n            cmd_resp_1 <= 0;\n            software_reset_reg <= 0;\n            time_out_reg <= 0;\n            normal_int_status_reg <= 0;\n            error_int_status_reg <= 0;\n            normal_int_signal_enable_reg <= 0;\n            error_int_signal_enable_reg <= 0;\n            clock_divider <= 0;\n            Bd_Status_reg <= 0;\n            Bd_isr_reg <= 0;\n            Bd_isr_enable_reg <= 0;\n        end else begin\n            if (wb_stb_i && wb_cyc_i) begin\n                case (wb_adr_i)\n                    4'h0: wb_dat_o <= argument_reg;\n                    4'h4: wb_dat_o <= cmd_setting_reg;\n                    4'h8: wb_dat_o <= status_reg;\n                    4'hc: wb_dat_o <= cmd_resp_1;\n                    4'h1c: wb_dat_o <= software_reset_reg;\n                    4'h28: wb_dat_o <= time_out_reg;\n                    4'h30: wb_dat_o <= normal_int_status_reg;\n                    4'h34: wb_dat_o <= error_int_status_reg;\n                    4'h38: wb_dat_o <= normal_int_signal_enable_reg;\n                    4'h3c: wb_dat_o <= error_int_signal_enable_reg;\n                    4'h48: wb_dat_o <= clock_divider;\n                    4'h50: wb_dat_o <= Bd_Status_reg;\n                    4'h54: wb_dat_o <= Bd_isr_reg;\n                    4'h58: wb_dat_o <= Bd_isr_enable_reg;\n                    default: wb_dat_o <= 0;\n                endcase\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 8, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [ 7:0] wb_adr_i,\n    input  wire [ 3:0] wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [ 7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [ 7:0] clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [ 7:0] Bd_isr_reg,\n    output wire [ 7:0] Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Define the reset values for the registers\n    localparam ARGUMENT_REG_RESET = 32'h00000000;\n    localparam CMD_SETTING_REG_RESET = 16'h0000;\n    localparam STATUS_REG_RESET = 16'h0000;\n    localparam CMD_RESP_1_RESET = 32'h00000000;\n    localparam SOFTWARE_RESET_REG_RESET = 8'h00;\n    localparam TIME_OUT_REG_RESET = 16'h0000;\n    localparam NORMAL_INT_STATUS_REG_RESET = 16'h0000;\n    localparam ERROR_INT_STATUS_REG_RESET = 16'h0000;\n    localparam NORMAL_INT_SIGNAL_ENABLE_REG_RESET = 16'h0000;\n    localparam ERROR_INT_SIGNAL_ENABLE_REG_RESET = 16'h0000;\n    localparam CLOCK_DIVIDER_RESET = 8'h00;\n    localparam BD_STATUS_REG_RESET = 16'h0000;\n    localparam BD_ISR_REG_RESET = 8'h00;\n    localparam BD_ISR_ENABLE_REG_RESET = 8'h00;\n\n    // Define the register addresses\n    localparam ARGUMENT_REG_ADDR = 32'h00000000;\n    localparam CMD_SETTING_REG_ADDR = 32'h00000004;\n    localparam STATUS_REG_ADDR = 32'h00000008;\n    localparam CMD_RESP_1_ADDR = 32'h0000000c;\n    localparam SOFTWARE_RESET_REG_ADDR = 32'h00000028;\n    localparam TIME_OUT_REG_ADDR = 32'h0000002c;\n    localparam NORMAL_INT_STATUS_REG_ADDR = 32'h00000030;\n    localparam ERROR_INT_STATUS_REG_ADDR = 32'h00000034;\n    localparam NORMAL_INT_SIGNAL_ENABLE_REG_ADDR = 32'h00000038;\n    localparam ERROR_INT_SIGNAL_ENABLE_REG_ADDR = 32'h0000003c;\n    localparam CLOCK_DIVIDER_ADDR = 32'h0000004c;\n    localparam BD_STATUS_REG_ADDR = 32'h00000050;\n    localparam BD_ISR_REG_ADDR = 32'h00000054;\n    localparam BD_ISR_ENABLE_REG_ADDR = 32'h00000058;\n    localparam BD_TX_ADDR = 32'h00000060;\n    localparam BD_RX_ADDR = 32'h00000080;\n\n    // Define the register widths\n    localparam ARGUMENT_REG_WIDTH = 32;\n    localparam CMD_SETTING_REG_WIDTH = 16;\n    localparam STATUS_REG_WIDTH = 16;\n    localparam CMD_RESP_1_WIDTH = 32;\n    localparam SOFTWARE_RESET_REG_WIDTH = 8;\n    localparam TIME_OUT_REG_WIDTH = 16;\n    localparam NORMAL_INT_STATUS_REG_WIDTH = 16;\n    localparam ERROR_INT_STATUS_REG_WIDTH = 16;\n    localparam NORMAL_INT_SIGNAL_ENABLE_REG_WIDTH = 16;\n    localparam ERROR_INT_SIGNAL_ENABLE_REG_WIDTH = 16;\n    localparam CLOCK_DIVIDER_WIDTH = 8;\n    localparam BD_STATUS_REG_WIDTH = 16;\n    localparam BD_ISR_REG_WIDTH = 8;\n    localparam BD_ISR_ENABLE_REG_WIDTH = 8;\n\n    // Define the register values\n    reg [ARGUMENT_REG_WIDTH-1:0] argument_reg;\n    reg [CMD_SETTING_REG_WIDTH-1:0] cmd_setting_reg;\n    reg [STATUS_REG_WIDTH-1:0] status_reg;\n    reg [CMD_RESP_1_WIDTH-1:0] cmd_resp_1;\n    reg [SOFTWARE_RESET_REG_WIDTH-1:0] software_reset_reg;\n    reg [TIME_OUT_REG_WIDTH-1:0] time_out_reg;\n    reg [NORMAL_INT_STATUS_REG_WIDTH-1:0] normal_int_status_reg;\n    reg [ERROR_INT_STATUS_REG_WIDTH-1:0] error_int_status_reg;\n    reg [NORMAL_INT_SIGNAL_ENABLE_REG_WIDTH-1:0] normal_int_signal_enable_reg;\n    reg [ERROR_INT_SIGNAL_ENABLE_REG_WIDTH-1:0] error_int_signal_enable_reg;\n    reg [CLOCK_DIVIDER_WIDTH-1:0] clock_divider;\n    reg [BD_STATUS_REG_WIDTH-1:0] Bd_Status_reg;\n    reg [BD_ISR_REG_WIDTH-1:0] Bd_isr_reg;\n    reg [BD_ISR_ENABLE_REG_WIDTH-1:0] Bd_isr_enable_reg;\n\n    // Define the signals\n    wire int_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire we_ack;\n    wire new_cmd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n\n    // Define the control logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            argument_reg <= ARGUMENT_REG_RESET;\n            cmd_setting_reg <= CMD_SETTING_REG_RESET;\n            status_reg <= STATUS_REG_RESET;\n            cmd_resp_1 <= CMD_RESP_1_RESET;\n            software_reset_reg <= SOFTWARE_RESET_REG_RESET;\n            time_out_reg <= TIME_OUT_REG_RESET;\n            normal_int_status_reg <= NORMAL_INT_STATUS_REG_RESET;\n            error_int_status_reg <= ERROR_INT_STATUS_REG_RESET;\n            normal_int_signal_enable_reg <= NORMAL_INT_SIGNAL_ENABLE_REG_RESET;\n            error_int_signal_enable_reg <= ERROR_INT_SIGNAL_ENABLE_REG_RESET;\n            clock_divider <= CLOCK_DIVIDER_RESET;\n            Bd_Status_reg <= BD_STATUS_REG_RESET;\n            Bd_isr_reg <= BD_ISR_REG_RESET;\n            Bd_isr_enable_reg <= BD_ISR_ENABLE_REG_RESET;\n            int_ack <= 1;\n            cmd_int_busy <= 0;\n            int_busy <= 0;\n            we_ack <= 0;\n            new_cmd <= 0;\n            we_m_tx_bd <= 0;\n            we_m_rx_bd <= 0;\n        end else begin\n            // Register write\n            if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n                case (wb_adr_i)\n                    ARGUMENT_REG_ADDR: argument_reg <= wb_dat_i;\n                    CMD_SETTING_REG_ADDR: cmd_setting_reg <= wb_dat_i;\n                    STATUS_REG_ADDR: status_reg <= wb_dat_i;\n                    CMD_RESP_1_ADDR: cmd_resp_1 <= wb_dat_i;\n                    SOFTWARE_RESET_REG_ADDR: software_reset_reg <= wb_dat_i;\n                    TIME_OUT_REG_ADDR: time_out_reg <= wb_dat_i;\n                    NORMAL_INT_STATUS_REG_ADDR: normal_int_status_reg <= wb_dat_i;\n                    ERROR_INT_STATUS_REG_ADDR: error_int_status_reg <= wb_dat_i;\n                    NORMAL_INT_SIGNAL_ENABLE_REG_ADDR: normal_int_signal_enable_reg <= wb_dat_i;\n                    ERROR_INT_SIGNAL_ENABLE_REG_ADDR: error_int_signal_enable_reg <= wb_dat_i;\n                    CLOCK_DIVIDER_ADDR: clock_divider <= wb_dat_i;\n                    BD_STATUS_REG_ADDR: Bd_Status_reg <= wb_dat_i;\n                    BD_ISR_REG_ADDR: Bd_isr_reg <= wb_dat_i;\n                    BD_ISR_ENABLE_REG_ADDR: Bd_isr_enable_reg <= wb_dat_i;\n                    BD_TX_ADDR: begin\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        for (int i = 0; i < RAM_MEM_WIDTH; i = i + 1) begin\n                            if (RAM_MEM_WIDTH == 32) begin\n                                dat_in_m_tx_bd[i] <= wb_dat_i[31:0];\n                            end else begin\n                                dat_in_m_tx_bd[i] <= wb_dat_i[15:0];\n                                wb_dat_i = wb_dat_i >> 16;\n                            end\n                        end\n                        #1;\n                        int_ack <= 1;\n                        we_m_tx_bd <= 0;\n                    end\n                    BD_RX_ADDR: begin\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        for (int i = 0; i < RAM_MEM_WIDTH; i = i + 1) begin\n                            if (RAM_MEM_WIDTH == 32) begin\n                                dat_in_m_rx_bd[i] <= wb_dat_i[31:0];\n                            end else begin\n                                dat_in_m_rx_bd[i] <= wb_dat_i[15:0];\n                                wb_dat_i = wb_dat_i >> 16;\n                            end\n                        end\n                        #1;\n                        int_ack <= 1;\n                        we_m_rx_bd <= 0;\n                    end\n                    default: ;\n                endcase\n            end\n\n            // Register read\n            if (wb_stb_i && wb_cyc_i) begin\n                case (wb_adr_i)\n                    ARGUMENT_REG_ADDR: wb_dat_o <= argument_reg;\n                    CMD_SETTING_REG_ADDR: wb_dat_o <= cmd_setting_reg;\n                    STATUS_REG_ADDR: wb_dat_o <= status_reg;\n                    CMD_RESP_1_ADDR: wb_dat_o <= cmd_resp_1;\n                    SOFTWARE_RESET_REG_ADDR: wb_dat_o <= software_reset_reg;\n                    TIME_OUT_REG_ADDR: wb_dat_o <= time_out_reg;\n                    NORMAL_INT_STATUS_REG_ADDR: wb_dat_o <= normal_int_status_reg;\n                    ERROR_INT_STATUS_REG_ADDR: wb_dat_o <= error_int_status_reg;\n                    NORMAL_INT_SIGNAL_ENABLE_REG_ADDR: wb_dat_o <= normal_int_signal_enable_reg;\n                    ERROR_INT_SIGNAL_ENABLE_REG_ADDR: wb_dat_o <= error_int_signal_enable_reg;\n                    CLOCK_DIVIDER_ADDR: wb_dat_o <= clock_divider;\n                    BD_STATUS_REG_ADDR: wb_dat_o <= Bd_Status_reg;\n                    BD_ISR_REG_ADDR: wb_dat_o <= Bd_isr_reg;\n                    BD_ISR_ENABLE_REG_ADDR: wb_dat_o <= Bd_isr_enable_reg;\n                    BD_TX_ADDR: wb_dat_o <= dat_in_m_tx_bd;\n                    BD_RX_ADDR: wb_dat_o <= dat_in_m_rx_bd;\n                    default: wb_dat_o <= 32'h00000000;\n                endcase\n            end\n\n            // Control logic\n            if (write_req_s) begin\n                we_ack <= 1;\n            end else begin\n                we_ack <= 0;\n            end\n\n            if (cmd_arg_s != 0) begin\n                new_cmd <= 1;\n            end else begin\n                new_cmd <= 0;\n            end\n\n            if (cmd_int_busy) begin\n                int_busy <= 1;\n            end else begin\n                int_busy <= 0;\n            end\n\n            if (int_busy) begin\n                cmd_int_busy <= 1;\n            end else begin\n                cmd_int_busy <= 0;\n            end\n\n            if (wb_cyc_i && wb_stb_i && ~wb_ack_o && int_ack) begin\n                wb_ack_o <= 1;\n            end else begin\n                wb_ack_o <= 0;\n            end\n\n            if (int_ack) begin\n                int_ack <= 1;\n            end else begin\n                int_ack <= 0;\n            end\n\n            if (we_m_tx_bd) begin\n                we_m_tx_bd <= 1;\n            end else begin\n                we_m_tx_bd <= 0;\n            end\n\n            if (we_m_rx_bd) begin\n                we_m_rx_bd <= 1;\n            end else begin\n                we_m_rx_bd <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 1, "code": "module sd_crc_16(\n  input  BITVAL,\n  input  Enable,\n  input  CLK,\n  input  RST,\n  output [15:0] CRC\n);\n\n  // Define the global variables\n  parameter BIG_ENDIAN = 0;\n  parameter LITTLE_ENDIAN = 0;\n  parameter SIM = 0;\n  parameter SYN = 0;\n  parameter SDC_IRQ_ENABLE = 0;\n  parameter ACTEL = 0;\n  parameter BD_WIDTH = 8;\n  parameter BD_SIZE = 255;\n  parameter RAM_MEM_WIDTH_16 = 16;\n  parameter RAM_MEM_WIDTH = 16;\n  parameter RESEND_MAX_CNT = 255;\n  parameter MEM_OFFSET = 0;\n  parameter RESET_CLK_DIV = 255;\n  parameter SD_CLK_BUS_CLK = 0;\n  parameter SD_CLK_SEP = 0;\n  parameter SD_CLK_STATIC = 0;\n  parameter SD_CLK_DYNAMIC = 0;\n  parameter BLOCK_SIZE = 512;\n  parameter SD_BUS_WIDTH_4 = 0;\n  parameter SD_BUS_W = 4;\n  parameter FIFO_RX_MEM_DEPTH = 0;\n  parameter FIFO_RX_MEM_ADR_SIZE = 0;\n  parameter FIFO_TX_MEM_DEPTH = 0;\n  parameter FIFO_TX_MEM_ADR_SIZE = 0;\n\n  // Define the CRC register\n  reg [15:0] crc_reg;\n\n  // Define the inv variable\n  wire inv;\n\n  // Combinational logic\n  assign inv = BITVAL ^ crc_reg[15];\n\n  // Sequential logic\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      crc_reg <= 16'b0;\n    end else if (Enable) begin\n      crc_reg <= {crc_reg[14:0], inv};\n      crc_reg[12] <= crc_reg[11] ^ inv;\n      crc_reg[5] <= crc_reg[4] ^ inv;\n      crc_reg[0] <= inv;\n    end\n  end\n\n  // Output the CRC value\n  assign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 2, "code": "Here is the Verilog code for the `sd_crc_16` module:\n```\nmodule sd_crc_16(\n  input wire BITVAL,\n  input wire Enable,\n  input wire CLK,\n  input wire RST,\n  output reg [15:0] CRC\n);\n\n  // Define the LFSR polynomial\n  localparam POLYNOMIAL = 16'h8005;\n\n  // Define the CRC initial value\n  reg [15:0] crc_init = 16'h0000;\n\n  // Define the current CRC value\n  reg [15:0] crc_current;\n\n  // Define the inverse of the current input bit\n  wire inv;\n\n  // Combinational logic\n  assign inv = BITVAL ^ (crc_current[15]);\n\n  // Sequential logic\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      crc_current <= 16'h0000;\n    end else if (Enable) begin\n      // Shift the CRC value to the left\n      crc_current <= {crc_current[14:0], crc_current[15]};\n\n      // Update the CRC value\n      crc_current[12] <= crc_current[11] ^ inv;\n      crc_current[5] <= crc_current[4] ^ inv;\n      crc_current[0] <= inv;\n    end\n  end\n\n  assign CRC = crc_current;\n\nendmodule\n```\nNote that I've assumed that the `sd_defines.v` file is not necessary to include in this code, as the necessary definitions are already included in the module. If you need to use the definitions from `sd_defines.v`, you can include it at the top of the file using the `include` directive.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 3, "code": "module sd_crc_16(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output reg [15:0]  CRC\n);\n\n    // Define the initial value of the CRC\n    reg [15:0] crc_init = 16'h0000;\n\n    // Define the LFSR polynomial coefficients\n    localparam POLY = 16'h8005;\n\n    // Define the CRC update logic\n    assign inv = BITVAL ^ (CRC[15]);\n\n    // Define the CRC update equations\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'h0000;\n        end else if (Enable) begin\n            CRC[15:1] <= {CRC[14:0], CRC[15]};\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 4, "code": "module sd_crc_16(\n    input  BITVAL,\n    input  Enable,\n    input  CLK,\n    input  RST,\n    output [15:0] CRC\n);\n\n// Define global variables from sd_defines.v\n`include \"sd_defines.v\"\n\n// Local variables\nreg [15:0] crc_value;\n\n// Combinational logic\nwire inv = BITVAL ^ crc_value[15];\n\n// Sequential logic\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        crc_value <= 16'b0;\n    end else if (Enable) begin\n        crc_value <= {crc_value[14:0], inv};\n        crc_value[12] <= crc_value[11] ^ inv;\n        crc_value[5] <= crc_value[4] ^ inv;\n        crc_value[0] <= inv;\n    end\nend\n\n// Output CRC value\nassign CRC = crc_value;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 5, "code": "module sd_crc_16(\n    input  wire BITVAL,\n    input  wire Enable,\n    input  wire CLK,\n    input  wire RST,\n    output reg [15:0] CRC\n);\n\n// Define global variables\n`include \"sd_defines.v\"\n\n// Combinational logic\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\n// Sequential logic\nalways @(posedge CLK or posedge RST)\nbegin\n    if (RST)\n        CRC <= 16'b0;\n    else if (Enable)\n    begin\n        CRC[15:12] <= {CRC[13], CRC[14], CRC[11], CRC[10]};\n        CRC[5] <= CRC[4] ^ inv;\n        CRC[4] <= CRC[3] ^ inv;\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[2] <= CRC[1] ^ inv;\n        CRC[1] <= CRC[0] ^ inv;\n        CRC[0] <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 6, "code": "module sd_crc_16(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output reg [15:0] CRC\n);\n\n// Define global variables\n`include \"sd_defines.v\"\n\n// Combinational Logic\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\n// Sequential Logic\nalways @(posedge CLK or posedge RST)\nbegin\n    if (RST)\n        CRC <= 16'b0;\n    else if (Enable)\n    begin\n        CRC[15:12] <= {CRC[13], CRC[14], CRC[15], CRC[11] ^ inv};\n        CRC[11:8] <= {CRC[9], CRC[10], CRC[11], CRC[7] ^ inv};\n        CRC[7:4] <= {CRC[5], CRC[6], CRC[7], CRC[3] ^ inv};\n        CRC[3:0] <= {inv, CRC[0], CRC[1], CRC[2]};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 7, "code": "Here is the Verilog code for the `sd_crc_16` module based on the provided specification:\n```\nmodule sd_crc_16(\n  input  BITVAL,\n  input  Enable,\n  input  CLK,\n  input  RST,\n  output [15:0] CRC\n);\n\n  // Define the CRC value as a 16-bit register\n  reg [15:0] crc_value;\n\n  // Define the `inv` value as a wire\n  wire inv;\n\n  // Define the clock and reset signals\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      crc_value <= 16'b0;\n    end else begin\n      // Update the CRC value on each rising edge of the clock\n      if (Enable) begin\n        // Shift the CRC value to the left\n        crc_value <= {crc_value[14:0], crc_value[15]};\n        \n        // Update the specific bits of the CRC\n        crc_value[12] <= crc_value[11] ^ inv;\n        crc_value[5] <= crc_value[4] ^ inv;\n        crc_value[0] <= inv;\n      end\n    end\n  end\n\n  // Calculate the `inv` value\n  assign inv = BITVAL ^ crc_value[15];\n\nendmodule\n```\nNote that I've assumed that the `sd_defines.v` file is included in the project and the necessary definitions are available. If not, you may need to modify the code to include the necessary definitions or use the values directly.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 8, "code": "module sd_crc_16(\n    input  BITVAL,\n    input  Enable,\n    input  CLK,\n    input  RST,\n    output [15:0] CRC\n);\n\n// Define global variables from sd_defines.v\n`include \"sd_defines.v\"\n\n// Local variables\nreg [15:0] crc_value;\nreg inv;\n\n// Combinational logic\nassign inv = BITVAL ^ crc_value[15];\n\n// Sequential logic\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        crc_value <= 16'b0;\n    end else if (Enable) begin\n        crc_value <= {crc_value[14:0], inv};\n        crc_value[12] <= crc_value[11] ^ inv;\n        crc_value[5] <= crc_value[4] ^ inv;\n        crc_value[0] <= inv;\n    end\nend\n\n// Output CRC value\nassign CRC = crc_value;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 9, "code": "module sd_crc_16(\n  input  BITVAL,\n  input  Enable,\n  input  CLK,\n  input  RST,\n  output [15:0] CRC\n);\n\n  // Define the CRC value as a 16-bit register\n  reg [15:0] crc_value;\n\n  // Define the inv value as a 1-bit register\n  reg inv;\n\n  // Define the clock and reset signals\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      crc_value <= 16'b0;\n    begin\n      // Update the CRC value on each rising edge of the clock\n      if (Enable) begin\n        // Shift the CRC value to the left\n        crc_value <= {crc_value[14:0], crc_value[15]};\n        \n        // Update the specific bits of the CRC\n        crc_value[12] <= crc_value[11] ^ inv;\n        crc_value[5]  <= crc_value[4]  ^ inv;\n        crc_value[0]  <= inv;\n      end\n    end\n  end\n\n  // Calculate the inv value\n  assign inv = BITVAL ^ crc_value[15];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 10, "code": "Here is the Verilog code for the `sd_crc_16` module based on the provided specification:\n```\nmodule sd_crc_16(\n  input  BITVAL,\n  input  Enable,\n  input  CLK,\n  input  RST,\n  output [15:0] CRC\n);\n\n  reg [15:0] crc_value;\n  reg inv;\n\n  // Combinational logic\n  assign inv = BITVAL ^ crc_value[15];\n\n  // Reset handling\n  always @(posedge RST)\n    crc_value <= 16'b0;\n\n  // Sequential logic\n  always @(posedge CLK or posedge RST)\n  begin\n    if (RST)\n      crc_value <= 16'b0;\n    else if (Enable)\n    begin\n      crc_value[14:0] <= {crc_value[13:0], crc_value[14]};\n      crc_value[12] <= crc_value[11] ^ inv;\n      crc_value[5] <= crc_value[4] ^ inv;\n      crc_value[0] <= inv;\n    end\n  end\n\n  assign CRC = crc_value;\n\nendmodule\n```\nNote that I've assumed that the `sd_defines.v` file is included in the design and its contents are available. If you need to use the macros defined in `sd_defines.v`, you'll need to include it in your design and modify the code accordingly.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 11, "code": "module sd_crc_16(\n  input  BITVAL,\n  input  Enable,\n  input  CLK,\n  input  RST,\n  output [15:0] CRC\n);\n\n// Include sd_defines.v file\n`include \"sd_defines.v\"\n\n// Define global variables\nreg [15:0] crc_value;\nreg [1:0] inv;\n\n// Combinational logic\nassign inv = BITVAL ^ crc_value[15];\n\n// Sequential logic\nalways @(posedge CLK or posedge RST) begin\n  if (RST) begin\n    crc_value <= 16'b0;\n  end else if (Enable) begin\n    crc_value <= {crc_value[14:0], inv};\n    crc_value[12] <= crc_value[11] ^ inv;\n    crc_value[5] <= crc_value[4] ^ inv;\n    crc_value[0] <= inv;\n  end\nend\n\n// Output CRC value\nassign CRC = crc_value;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 12, "code": "module sd_crc_16(\n  input  BITVAL,\n  input  Enable,\n  input  CLK,\n  input  RST,\n  output [15:0] CRC\n);\n\n// Define global variables\n`include \"sd_defines.v\"\n\n// Local variables\nreg [15:0] crc_value;\n\n// Combinational logic\nwire inv = BITVAL ^ crc_value[15];\n\n// Sequential logic\nalways @(posedge CLK or posedge RST) begin\n  if (RST) begin\n    crc_value <= 16'b0;\n  end else if (Enable) begin\n    crc_value <= {crc_value[14:0], inv};\n    crc_value[12] <= crc_value[11] ^ inv;\n    crc_value[5] <= crc_value[4] ^ inv;\n    crc_value[0] <= inv;\n  end\nend\n\n// Output CRC value\nassign CRC = crc_value;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 13, "code": "module sd_crc_16(\n  input  wire        BITVAL,\n  input  wire        Enable,\n  input  wire        CLK,\n  input  wire        RST,\n  output reg [15:0]  CRC\n);\n\n  // Define the initial value of CRC\n  reg [15:0] crc_init = 16'h0000;\n\n  // Define the inv variable\n  wire inv;\n\n  // Combinational logic to calculate inv\n  assign inv = BITVAL ^ (CRC[15]);\n\n  // Sequential logic to update CRC\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      CRC <= 16'h0000;\n    end else if (Enable) begin\n      // Shift CRC to the left\n      CRC <= {CRC[14:0], CRC[15]};\n      // Update CRC bits\n      CRC[12] <= CRC[11] ^ inv;\n      CRC[5] <= CRC[4] ^ inv;\n      CRC[0] <= inv;\n    end\n  end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 14, "code": "module sd_crc_16(\n    input  BITVAL,\n    input  Enable,\n    input  CLK,\n    input  RST,\n    output [15:0] CRC\n);\n\n    reg [15:0] crc_value;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            crc_value <= 16'b0;\n        end else begin\n            if (Enable) begin\n                crc_value[15:1] <= {crc_value[14:0], crc_value[15]};\n                crc_value[12] <= crc_value[11] ^ BITVAL;\n                crc_value[5]  <= crc_value[4]  ^ BITVAL;\n                crc_value[0]  <= BITVAL;\n            end\n        end\n    end\n\n    assign CRC = crc_value;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 15, "code": "module sd_crc_16(\n    input  wire BITVAL,\n    input  wire Enable,\n    input  wire CLK,\n    input  wire RST,\n    output reg [15:0] CRC\n);\n\n// Global variables\n`include \"sd_defines.v\"\n\n// Combinational logic\nwire inv;\nassign inv = BITVAL ^ (CRC[15]);\n\n// Sequential logic\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        CRC[15:1] <= CRC[14:0];\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[5] <= CRC[4] ^ inv;\n        CRC[0] <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 16, "code": "module sd_crc_16(\n  input  wire BITVAL,\n  input  wire Enable,\n  input  wire CLK,\n  input  wire RST,\n  output reg [15:0] CRC\n);\n\n  // Define the LFSR taps\n  parameter LFSR_TAPS = 16'd0;\n\n  // Define the CRC polynomial\n  parameter CRC_POLY = 16'h8005;\n\n  // Define the initial CRC value\n  reg [15:0] crc_init = 16'h0000;\n\n  // Define the current CRC value\n  reg [15:0] crc_current;\n\n  // Define the inverse of the current input bit\n  wire inv;\n\n  // Calculate the inverse of the current input bit\n  assign inv = BITVAL ^ (crc_current[15]);\n\n  // Update the CRC value on each rising edge of the clock or when the reset signal is high\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      crc_current <= 16'h0000;\n    end else if (Enable) begin\n      // Shift the CRC value to the left\n      crc_current <= {crc_current[14:0], crc_current[15]};\n\n      // Update the specific bits of the CRC\n      crc_current[12] <= crc_current[11] ^ inv;\n      crc_current[5]  <= crc_current[4]  ^ inv;\n      crc_current[0]  <= inv;\n    end\n  end\n\n  // Assign the current CRC value to the output\n  assign CRC = crc_current;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 17, "code": "Here is the Verilog code for the `sd_crc_16` module:\n```\nmodule sd_crc_16(\n  input  BITVAL,\n  input  Enable,\n  input  CLK,\n  input  RST,\n  output [15:0] CRC\n);\n\n// Define the LFSR taps\nparameter LFSR_TAPS = {16'b1000000000000000};\n\n// Define the initial CRC value\nreg [15:0] crc_value = 16'h0000;\n\n// Define the current bit value\nreg bit_value;\n\n// Define the inverse of the current bit value\nreg inv;\n\n// Define the clock and reset signals\nreg clk_en;\nreg rst_en;\n\nalways @(posedge CLK or posedge RST) begin\n  if (RST) begin\n    crc_value <= 16'h0000;\n  end else begin\n    clk_en <= CLK;\n    rst_en <= RST;\n  end\nend\n\n// Combinational logic\nassign inv = BITVAL ^ crc_value[15];\n\n// Sequential logic\nalways @(posedge clk_en or posedge rst_en) begin\n  if (rst_en) begin\n    crc_value <= 16'h0000;\n  end else if (Enable) begin\n    crc_value <= {crc_value[14:0], inv};\n    crc_value[12] <= crc_value[11] ^ inv;\n    crc_value[5] <= crc_value[4] ^ inv;\n    crc_value[0] <= inv;\n  end\nend\n\n// Output the CRC value\nassign CRC = crc_value;\n\nendmodule\n```\nNote that I've assumed that the `sd_defines.v` file is not necessary to include in this code, as the necessary definitions are already included in the module. If you need to use the definitions from `sd_defines.v`, you can include it at the top of the file using the `include` directive.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 18, "code": "module sd_crc_16(\n    input  BITVAL,\n    input  Enable,\n    input  CLK,\n    input  RST,\n    output [15:0] CRC\n);\n\n    // Define the CRC register\n    reg [15:0] crc_reg;\n\n    // Define the `inv` signal\n    wire inv;\n\n    // Combinational logic\n    assign inv = BITVAL ^ crc_reg[15];\n\n    // Sequential logic\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            crc_reg <= 16'b0;\n        end else if (Enable) begin\n            // Shift CRC to the left\n            crc_reg[14:0] <= crc_reg[13:0];\n\n            // Update CRC bits\n            crc_reg[12] <= crc_reg[11] ^ inv;\n            crc_reg[5]  <= crc_reg[4]  ^ inv;\n            crc_reg[0]  <= inv;\n        end\n    end\n\n    // Assign the CRC output\n    assign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 19, "code": "module sd_crc_16(\n  input  BITVAL,\n  input  Enable,\n  input  CLK,\n  input  RST,\n  output [15:0] CRC\n);\n\n  // Define the CRC value as a 16-bit register\n  reg [15:0] crc_value;\n\n  // Initialize the CRC value to zero on reset\n  always @(posedge RST or posedge CLK) begin\n    if (RST) begin\n      crc_value <= 16'b0;\n    end\n  end\n\n  // Update the CRC value on each rising edge of the clock or when the reset signal is high\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      crc_value <= 16'b0;\n    end else if (Enable) begin\n      // Shift the CRC value to the left\n      crc_value <= {crc_value[14:0], crc_value[15]};\n\n      // Update the specific bits of the CRC\n      crc_value[12] <= crc_value[11] ^ BITVAL;\n      crc_value[5]  <= crc_value[4]  ^ BITVAL;\n      crc_value[0]  <= BITVAL;\n    end\n  end\n\n  // Assign the CRC value to the output\n  assign CRC = crc_value;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 20, "code": "module sd_crc_16(\n  input  BITVAL,\n  input  Enable,\n  input  CLK,\n  input  RST,\n  output [15:0] CRC\n);\n\n// Define global variables from sd_defines.v\n`include \"sd_defines.v\"\n\n// Local variables\nreg [15:0] crc_value;\nreg inv;\n\n// Combinational logic\nassign inv = BITVAL ^ crc_value[15];\n\n// Sequential logic\nalways @(posedge CLK or posedge RST) begin\n  if (RST) begin\n    crc_value <= 16'b0;\n  end else if (Enable) begin\n    crc_value <= {crc_value[14:0], inv};\n    crc_value[12] <= crc_value[11] ^ inv;\n    crc_value[5] <= crc_value[4] ^ inv;\n    crc_value[0] <= inv;\n  end\nend\n\n// Output CRC value\nassign CRC = crc_value;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 1, "code": "module sd_crc_7(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output wire [6:0]  CRC\n);\n\n    reg [6:0] crc_reg;\n\n    always @(posedge CLK or posedge RST)\n    begin\n        if (RST)\n            crc_reg <= 7'b0;\n        else if (Enable)\n        begin\n            reg [6:0] inv;\n            inv = BITVAL ^ crc_reg[6];\n            crc_reg[0] <= inv;\n            crc_reg[3] <= crc_reg[2] ^ inv;\n            for (int i = 4; i < 7; i++)\n                crc_reg[i] <= crc_reg[i-1];\n        end\n    end\n\n    assign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 2, "code": "module sd_crc_7(\n    input  wire  BITVAL,\n    input  wire  Enable,\n    input  wire  CLK,\n    input  wire  RST,\n    output wire  [6:0] CRC\n);\n\n    reg [6:0] crc_reg;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            crc_reg <= 7'b0;\n        end else if (Enable) begin\n            crc_reg[0] <= BITVAL ^ crc_reg[6];\n            crc_reg[3] <= crc_reg[2] ^ crc_reg[0];\n            for (int i = 4; i < 7; i++) begin\n                crc_reg[i] <= crc_reg[i-1];\n            end\n        end\n    end\n\n    assign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 3, "code": "module sd_crc_7(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output wire [6:0]  CRC\n);\n\n    reg [6:0] crc_reg;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            crc_reg <= 7'b0;\n        end else if (Enable) begin\n            // Inverse calculation\n            wire inv = BITVAL ^ crc_reg[6];\n\n            // CRC update\n            crc_reg[0] <= inv;\n            crc_reg[3] <= crc_reg[2] ^ inv;\n            for (int i = 4; i < 7; i++) begin\n                crc_reg[i] <= crc_reg[i-1];\n            end\n        end\n    end\n\n    assign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 4, "code": "module sd_crc_7(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output wire [6:0]  CRC\n);\n\nreg [6:0] crc_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        crc_reg <= 7'b0;\n    end else if (Enable) begin\n        // Inverse calculation\n        reg inv;\n        inv = BITVAL ^ crc_reg[6];\n\n        // CRC update\n        crc_reg[0] <= inv;\n        crc_reg[3] <= crc_reg[2] ^ inv;\n        for (int i = 4; i < 7; i++) begin\n            crc_reg[i] <= crc_reg[i-1];\n        end\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 5, "code": "module sd_crc_7(\n    input  BITVAL,\n    input  Enable,\n    input  CLK,\n    input  RST,\n    output [6:0] CRC\n);\n\n    // Define the CRC register\n    reg [6:0] crc_reg;\n\n    // Define the inverse calculation result\n    wire inv;\n\n    // Define the CRC update logic\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            crc_reg <= 7'b0;\n        end else if (Enable) begin\n            inv <= BITVAL ^ crc_reg[6];\n            crc_reg[0] <= inv;\n            crc_reg[3] <= crc_reg[2] ^ inv;\n            for (int i = 4; i < 7; i++) begin\n                crc_reg[i] <= crc_reg[i-1];\n            end\n        end\n    end\n\n    // Assign the CRC value to the output\n    assign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 6, "code": "module sd_crc_7(\n    input  wire  BITVAL,\n    input  wire  Enable,\n    input  wire  CLK,\n    input  wire  RST,\n    output wire [6:0] CRC\n);\n\n// Define the CRC register\nreg [6:0] crc_reg;\n\n// Define the inverse calculation result\nwire inv;\n\n// Define the CRC update logic\nalways @(*) begin\n    inv = BITVAL ^ crc_reg[6];\nend\n\n// Define the CRC update process\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        crc_reg <= 7'b0;\n    end else if (Enable) begin\n        crc_reg[0] <= inv;\n        crc_reg[3] <= crc_reg[2] ^ inv;\n        for (int i = 4; i < 7; i++) begin\n            crc_reg[i] <= crc_reg[i-1];\n        end\n    end\nend\n\n// Assign the CRC value to the output\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 7, "code": "module sd_crc_7(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output wire [6:0]  CRC\n);\n\n// Define the CRC register\nreg [6:0] crc_reg;\n\n// Define the inverse calculation\nwire inv;\n\n// Define the CRC update logic\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        crc_reg <= 7'b0;\n    end else if (Enable) begin\n        inv <= BITVAL ^ crc_reg[6];\n        crc_reg[0] <= inv;\n        crc_reg[3] <= crc_reg[2] ^ inv;\n        for (int i = 4; i < 7; i++) begin\n            crc_reg[i] <= crc_reg[i-1];\n        end\n    end\nend\n\n// Assign the CRC value to the output\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 8, "code": "module sd_crc_7(\n    input  BITVAL,\n    input  Enable,\n    input  CLK,\n    input  RST,\n    output [6:0] CRC\n);\n\nreg [6:0] crc_reg;\nreg inv;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        crc_reg <= 7'b0;\n    end else if (Enable) begin\n        inv = BITVAL ^ crc_reg[6];\n        crc_reg[0] <= inv;\n        crc_reg[3] <= crc_reg[2] ^ inv;\n        for (int i = 4; i < 7; i++) begin\n            crc_reg[i] <= crc_reg[i-1];\n        end\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 9, "code": "module sd_crc_7(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output wire [6:0]  CRC\n);\n\nreg [6:0] crc_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        crc_reg <= 7'b0;\n    end else if (Enable) begin\n        crc_reg[6] <= BITVAL ^ crc_reg[6];\n        crc_reg[3] <= crc_reg[2] ^ crc_reg[6];\n        crc_reg[2:0] <= crc_reg[1:0];\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 10, "code": "module sd_crc_7(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output wire [6:0]  CRC\n);\n\n    reg [6:0] crc_reg;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            crc_reg <= 7'b0;\n        end else if (Enable) begin\n            crc_reg[0] <= BITVAL ^ crc_reg[6];\n            crc_reg[3] <= crc_reg[2] ^ crc_reg[0];\n            for (int i = 4; i < 7; i++) begin\n                crc_reg[i] <= crc_reg[i-1];\n            end\n        end\n    end\n\n    assign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 11, "code": "module sd_crc_7(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output wire [6:0]   CRC\n);\n\n    reg [6:0] crc_reg;\n\n    always @(posedge RST or posedge CLK)\n    begin\n        if (RST)\n            crc_reg <= 7'b0;\n        else if (Enable)\n            crc_reg <= crc_reg;\n    end\n\n    always @(posedge CLK or posedge RST)\n    begin\n        if (RST)\n            crc_reg <= 7'b0;\n        else if (Enable)\n        begin\n            reg [6:0] inv;\n            inv = BITVAL ^ crc_reg[6];\n            crc_reg[0] <= inv;\n            crc_reg[3] <= crc_reg[2] ^ inv;\n            for (int i = 4; i < 7; i++)\n                crc_reg[i] <= crc_reg[i-1];\n        end\n    end\n\n    assign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 12, "code": "module sd_crc_7(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output reg [6:0]   CRC\n);\n\n    // Define the initial CRC value as 0\n    initial CRC = 7'b0;\n\n    // Define the inverse calculation\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    // Define the CRC update logic\n    always @ (posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[3] <= CRC[2] ^ inv;\n            for (int i = 4; i < 7; i++) begin\n                CRC[i] <= CRC[i-1];\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 13, "code": "module sd_crc_7(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output wire [6:0]  CRC\n);\n\n    reg [6:0] crc_reg;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            crc_reg <= 7'b0;\n        end else if (Enable) begin\n            // Inverse calculation\n            reg inv;\n            inv = BITVAL ^ crc_reg[6];\n\n            // CRC update\n            crc_reg[0] <= inv;\n            crc_reg[3] <= crc_reg[2] ^ inv;\n            for (int i = 4; i < 7; i++) begin\n                crc_reg[i] <= crc_reg[i-1];\n            end\n        end\n    end\n\n    assign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 14, "code": "module sd_crc_7 (\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output wire [6:0]   CRC\n);\n\nreg [6:0]   crc_reg;\n\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin\n        crc_reg <= 7'b0;\n    end else if (Enable) begin\n        crc_reg[0] <= BITVAL ^ crc_reg[6];\n        crc_reg[3] <= crc_reg[2] ^ crc_reg[0];\n        for (int i = 4; i < 7; i++) begin\n            crc_reg[i] <= crc_reg[i-1];\n        end\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 15, "code": "module sd_crc_7(\n    input  BITVAL,\n    input  Enable,\n    input  CLK,\n    input  RST,\n    output [6:0] CRC\n);\n\n    reg [6:0] crc_reg;\n\n    always @ (posedge CLK or posedge RST) begin\n        if (RST) begin\n            crc_reg <= 7'b0;\n        end\n        else if (Enable) begin\n            crc_reg[0] <= BITVAL ^ crc_reg[6];\n            crc_reg[3] <= crc_reg[2] ^ crc_reg[0];\n            for (int i = 4; i < 7; i++) begin\n                crc_reg[i] <= crc_reg[i-1];\n            end\n        end\n    end\n\n    assign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 16, "code": "module sd_crc_7(\n    input  wire clk,\n    input  wire rst,\n    input  wire enable,\n    input  wire bitval,\n    output reg [6:0] crc\n);\n\n    reg [6:0] crc_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            crc_reg <= 7'b0;\n        end else if (enable) begin\n            crc_reg[0] <= bitval ^ crc_reg[6];\n            crc_reg[3] <= crc_reg[2] ^ crc_reg[0];\n            for (int i = 4; i < 7; i++) begin\n                crc_reg[i] <= crc_reg[i-1];\n            end\n        end\n    end\n\n    assign crc = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 17, "code": "module sd_crc_7(\n    input  BITVAL,\n    input  Enable,\n    input  CLK,\n    input  RST,\n    output [6:0] CRC\n);\n\n    reg [6:0] crc_reg;\n    reg inv;\n\n    always @ (posedge CLK or posedge RST) begin\n        if (RST) begin\n            crc_reg <= 7'b0;\n        end else if (Enable) begin\n            inv = BITVAL ^ crc_reg[6];\n            crc_reg[0] <= inv;\n            crc_reg[3] <= crc_reg[2] ^ inv;\n            for (int i = 4; i < 7; i++) begin\n                crc_reg[i] <= crc_reg[i-1];\n            end\n        end\n    end\n\n    assign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 18, "code": "module sd_crc_7(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output reg [6:0]  CRC\n);\n\n// Define the CRC polynomial\nlocalparam CRC_POLY = 7'b1101001;\n\n// Initialize the CRC value to zero\ninitial CRC = 7'b0;\n\nalways @(posedge CLK) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Inverse calculation\n        wire inv = BITVAL ^ CRC[6];\n\n        // CRC update\n        CRC[0] <= inv;\n        CRC[3] <= CRC[2] ^ inv;\n        for (int i = 4; i < 7; i++) begin\n            CRC[i] <= CRC[i-1];\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 19, "code": "module sd_crc_7(\n  input  wire  BITVAL,\n  input  wire  Enable,\n  input  wire  CLK,\n  input  wire  RST,\n  output wire  [6:0] CRC\n);\n\n  reg [6:0] crc_reg;\n\n  always @ (posedge CLK or posedge RST) begin\n    if (RST) begin\n      crc_reg <= 7'b0;\n    end else if (Enable) begin\n      crc_reg[0] <= BITVAL ^ crc_reg[6];\n      crc_reg[3] <= crc_reg[2] ^ crc_reg[0];\n      for (int i = 4; i < 7; i++) begin\n        crc_reg[i] <= crc_reg[i-1];\n      end\n    end\n  end\n\n  assign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 20, "code": "module sd_crc_7(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output wire [6:0]   CRC\n);\n\n    reg [6:0]   crc_reg;\n\n    always @(posedge RST or posedge CLK) begin\n        if (RST) begin\n            crc_reg <= 7'b0;\n        end\n        else if (Enable) begin\n            // Inverse Calculation\n            wire inv = BITVAL ^ crc_reg[6];\n\n            // CRC Update\n            crc_reg[0] <= inv;\n            crc_reg[3] <= crc_reg[2] ^ inv;\n            for (int i = 4; i < 7; i++) begin\n                crc_reg[i] <= crc_reg[i-1];\n            end\n        end\n    end\n\n    assign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 1, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status\n);\n\nreg [8:0] state;\nreg [8:0] next_state;\nreg [1:0] resend_try_cnt;\nreg [1:0] tx_cycle;\nreg [1:0] rx_cycle;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr;\nreg [31:0] cmd_arg;\nreg [15:0] cmd_set;\nreg [1:0] CIDAT;\nreg [7:0] Dat_Int_Status;\nreg [1:0] trans_done;\nreg [1:0] trans_failed;\nreg [1:0] internal_transm_complete;\nreg [1:0] transm_complete_q;\nreg [1:0] send_done;\nreg [1:0] rec_done;\nreg [1:0] rec_failed;\nreg [1:0] cmd_busy;\nreg [1:0] we_req;\nreg [1:0] d_write;\nreg [1:0] d_read;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n        resend_try_cnt <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        cmd_busy <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n    end else begin\n        state <= next_state;\n        resend_try_cnt <= resend_try_cnt + 1;\n        tx_cycle <= tx_cycle;\n        rx_cycle <= rx_cycle;\n        bd_cnt <= bd_cnt;\n        sys_adr <= sys_adr;\n        cmd_arg <= cmd_arg;\n        cmd_set <= cmd_set;\n        CIDAT <= CIDAT;\n        Dat_Int_Status <= Dat_Int_Status;\n        trans_done <= trans_done;\n        trans_failed <= trans_failed;\n        internal_transm_complete <= internal_transm_complete;\n        transm_complete_q <= transm_complete_q;\n        send_done <= send_done;\n        rec_done <= rec_done;\n        rec_failed <= rec_failed;\n        cmd_busy <= cmd_busy;\n        we_req <= we_req;\n        d_write <= d_write;\n        d_read <= d_read;\n    end\nend\n\nalways_comb begin\n    case (state)\n        IDLE: begin\n            next_state = IDLE;\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end\n            if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end\n        end\n        GET_TX_BD: begin\n            next_state = GET_TX_BD;\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        GET_RX_BD: begin\n            next_state = GET_RX_BD;\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        SEND_CMD: begin\n            next_state = SEND_CMD;\n            if (send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            next_state = RECIVE_CMD;\n            if (rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end\n            if (rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            next_state = DATA_TRANSFER;\n            if (trans_done == 1) begin\n                next_state = IDLE;\n            end\n            if (trans_failed == 1) begin\n                next_state = STOP;\n            end\n        end\n        STOP: begin\n            next_state = STOP;\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            next_state = STOP_SEND;\n            if (send_done == 1) begin\n                next_state = IDLE;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                a_cmp_tx <= 0;\n                if (ack_i_s_tx == 1) begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 1;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                a_cmp_rx <= 0;\n                if (ack_i_s_rx == 1) begin\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 1;\n                end\n            end\n            SEND_CMD: begin\n                we_req <= 1;\n                if (we_ack == 1) begin\n                    we_req <= 0;\n                end\n            end\n            RECIVE_CMD: begin\n                if (cmd_busy == 0) begin\n                    we_req <= 1;\n                    if (we_ack == 1) begin\n                        we_req <= 0;\n                    end\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete == 1) begin\n                    ack_transfer <= 1;\n                end\n            end\n            STOP: begin\n                cmd_set <= CMD12;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    cmd_set <= CMD12;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n            end\n            default: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n            end\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            SEND_CMD: begin\n                send_done <= 1;\n            end\n            RECIVE_CMD: begin\n                rec_done <= 1;\n                if (cmd_tsf_err == 1) begin\n                    rec_failed <= 1;\n                end\n                if (card_status[0] == 1) begin\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                end\n                if (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6) begin\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete == 1) begin\n                    trans_done <= 1;\n                end\n                if (crc_ok == 0) begin\n                    trans_failed <= 1;\n                end\n            end\n            STOP: begin\n                rec_done <= 0;\n                rec_failed <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n            end\n            default: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            GET_TX_BD: begin\n                if (tx_cycle == 0) begin\n                    sys_adr <= dat_in_tx;\n                end\n                if (tx_cycle == 1) begin\n                    cmd_arg <= dat_in_tx;\n                    start_tx_fifo <= 1;\n                end\n            end\n            GET_RX_BD: begin\n                if (rx_cycle == 0) begin\n                    sys_adr <= dat_in_rx;\n                end\n                if (rx_cycle == 1) begin\n                    cmd_arg <= dat_in_rx;\n                end\n            end\n            SEND_CMD: begin\n                if (d_write == 1) begin\n                    cmd_set <= CMD24;\n                end\n                if (d_read == 1) begin\n                    cmd_set <= CMD17;\n                end\n            end\n            RECIVE_CMD: begin\n                if (cmd_busy == 0) begin\n                    we_req <= 1;\n                    if (we_ack == 1) begin\n                        we_req <= 0;\n                    end\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete == 1) begin\n                    ack_transfer <= 1;\n                end\n            end\n            STOP: begin\n                cmd_set <= CMD12;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    cmd_set <= CMD12;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n            end\n            default: begin\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n            end\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            DATA_TRANSFER: begin\n                CIDAT <= crc_ok;\n                if (transm_complete == 1) begin\n                    Dat_Int_Status <= 0;\n                end\n            end\n            STOP: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            STOP_SEND: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            default: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 2, "code": "module sd_data_master(\n    input  wire clk,\n    input  wire rst,\n    input  wire dat_in_tx[`RAM_MEM_WIDTH-1:0],\n    input  wire free_tx_bd[`BD_WIDTH-1:0],\n    input  wire ack_i_s_tx,\n    input  wire dat_in_rx[`RAM_MEM_WIDTH-1:0],\n    input  wire free_rx_bd[`BD_WIDTH-1:0],\n    input  wire ack_i_s_rx,\n    input  wire cmd_busy,\n    input  wire we_ack,\n    input  wire cmd_tsf_err,\n    input  wire card_status[4:0],\n    input  wire tx_empt,\n    input  wire tx_full,\n    input  wire rx_full,\n    input  wire busy_n,\n    input  wire transm_complete,\n    input  wire crc_ok,\n    input  wire Dat_Int_Status_rst,\n    input  wire transfer_type[1:0],\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg cmd_arg[`CMD_WIDTH-1:0],\n    output reg cmd_set[`CMD_WIDTH-1:0],\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg sys_adr[`MEM_WIDTH-1:0],\n    output reg ack_transfer,\n    output reg Dat_Int_Status[`DAT_INT_STATUS_WIDTH-1:0]\n);\n\n    // Internal signals\n    reg [`SIZE-1:0] state;\n    reg [`SIZE-1:0] next_state;\n    reg [`SIZE-1:0] send_done;\n    reg [`SIZE-1:0] rec_done;\n    reg [`SIZE-1:0] rec_failed;\n    reg [`SIZE-1:0] tx_cycle;\n    reg [`SIZE-1:0] rx_cycle;\n    reg [`RESEND_MAX_CNT-1:0] resend_try_cnt;\n    reg [`SIZE-1:0] trans_done;\n    reg [`SIZE-1:0] trans_failed;\n    reg [`SIZE-1:0] internal_transm_complete;\n    reg [`SIZE-1:0] transm_complete_q;\n    reg [`BD_WIDTH-1:0] bd_cnt;\n    reg [`MEM_WIDTH-1:0] sys_adr;\n    reg [`CMD_WIDTH-1:0] cmd_arg;\n    reg [`CMD_WIDTH-1:0] cmd_set;\n    reg [`SIZE-1:0] CIDAT;\n    reg [`DAT_INT_STATUS_WIDTH-1:0] Dat_Int_Status;\n\n    // FSM state machine\n    always @(posedge clk) begin\n        if (rst) begin\n            state <= `IDLE;\n            next_state <= `IDLE;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM state machine logic\n    always_comb begin\n        case (state)\n            `IDLE: begin\n                if (free_tx_bd != `BD_EMPTY)\n                    next_state = `GET_TX_BD;\n                else if (free_rx_bd != `BD_EMPTY)\n                    next_state = `GET_RX_BD;\n                else\n                    next_state = `IDLE;\n            end\n            `GET_TX_BD: begin\n                if (bd_cnt > `READ_CYCLE - 1 && tx_full == 1)\n                    next_state = `SEND_CMD;\n                else\n                    next_state = `GET_TX_BD;\n            end\n            `GET_RX_BD: begin\n                if (bd_cnt >= `READ_CYCLE - 1)\n                    next_state = `SEND_CMD;\n                else\n                    next_state = `GET_RX_BD;\n            end\n            `SEND_CMD: begin\n                if (send_done == 1)\n                    next_state = `RECIVE_CMD;\n                else\n                    next_state = `SEND_CMD;\n            end\n            `RECIVE_CMD: begin\n                if (rec_done == 1)\n                    next_state = `DATA_TRANSFER;\n                else if (rec_failed == 1)\n                    next_state = `SEND_CMD;\n                else\n                    next_state = `RECIVE_CMD;\n            end\n            `DATA_TRANSFER: begin\n                if (trans_done == 1)\n                    next_state = `IDLE;\n                else if (trans_failed == 1)\n                    next_state = `STOP;\n                else\n                    next_state = `DATA_TRANSFER;\n            end\n            `STOP: begin\n                next_state = `STOP_SEND;\n            end\n            `STOP_SEND: begin\n                if (send_done == 1)\n                    next_state = `IDLE;\n                else\n                    next_state = `STOP_SEND;\n            end\n            default: next_state = `IDLE;\n        end\n    end\n\n    // FSM state machine control\n    always @(posedge clk) begin\n        if (rst) begin\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n            sys_adr <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            CIDAT <= 0;\n            Dat_Int_Status <= 0;\n        end\n        else begin\n            case (state)\n                `IDLE: begin\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                    sys_adr <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                `GET_TX_BD: begin\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 1;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                    sys_adr <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                `GET_RX_BD: begin\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 1;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                    sys_adr <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                `SEND_CMD: begin\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                    sys_adr <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                `RECIVE_CMD: begin\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                    sys_adr <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                `DATA_TRANSFER: begin\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                    sys_adr <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                `STOP: begin\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                    sys_adr <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                `STOP_SEND: begin\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                    sys_adr <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                default: begin\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                    sys_adr <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n            endcase\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n        end\n        else begin\n            case (state)\n                `IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                `GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                `GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    a_cmp_rx <= 0;\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                `SEND_CMD: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 1;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= cmd_arg;\n                    cmd_set <= cmd_set;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= sys_adr;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= Dat_Int_Status;\n                end\n                `RECIVE_CMD: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 1;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                `DATA_TRANSFER: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                `STOP: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                `STOP_SEND: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 1;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                default: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 3, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_tx,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input transfer_type,\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status\n);\n\nreg [8:0] state;\nreg [8:0] next_state;\nreg [1:0] resend_try_cnt;\nreg [1:0] bd_cnt;\nreg [31:0] sys_adr;\nreg [31:0] cmd_arg;\nreg [15:0] cmd_set;\nreg CIDAT;\nreg [7:0] Dat_Int_Status;\nreg [1:0] transfer_type;\nreg [1:0] tx_cycle;\nreg [1:0] rx_cycle;\nreg [1:0] send_done;\nreg [1:0] rec_done;\nreg [1:0] rec_failed;\nreg [1:0] trans_done;\nreg [1:0] trans_failed;\nreg [1:0] internal_transm_complete;\nreg [1:0] transm_complete_q;\nreg [1:0] cmd_busy;\nreg [1:0] we_ack;\nreg [1:0] cmd_tsf_err;\nreg [4:0] card_status;\nreg [1:0] tx_empt;\nreg [1:0] tx_full;\nreg [1:0] rx_full;\nreg [1:0] busy_n;\nreg [1:0] transm_complete;\nreg [1:0] crc_ok;\nreg [1:0] Dat_Int_Status_rst;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n        resend_try_cnt <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n        transfer_type <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        cmd_busy <= 0;\n        we_ack <= 0;\n        cmd_tsf_err <= 0;\n        card_status <= 0;\n        tx_empt <= 0;\n        tx_full <= 0;\n        rx_full <= 0;\n        busy_n <= 0;\n        transm_complete <= 0;\n        crc_ok <= 0;\n        Dat_Int_Status_rst <= 0;\n    end\n    else begin\n        state <= next_state;\n        resend_try_cnt <= resend_try_cnt + 1;\n        bd_cnt <= bd_cnt + 1;\n        sys_adr <= sys_adr + 1;\n        cmd_arg <= cmd_arg + 1;\n        cmd_set <= cmd_set + 1;\n        CIDAT <= CIDAT + 1;\n        Dat_Int_Status <= Dat_Int_Status + 1;\n        transfer_type <= transfer_type + 1;\n        tx_cycle <= tx_cycle + 1;\n        rx_cycle <= rx_cycle + 1;\n        send_done <= send_done + 1;\n        rec_done <= rec_done + 1;\n        rec_failed <= rec_failed + 1;\n        trans_done <= trans_done + 1;\n        trans_failed <= trans_failed + 1;\n        internal_transm_complete <= internal_transm_complete + 1;\n        transm_complete_q <= transm_complete_q + 1;\n        cmd_busy <= cmd_busy + 1;\n        we_ack <= we_ack + 1;\n        cmd_tsf_err <= cmd_tsf_err + 1;\n        card_status <= card_status + 1;\n        tx_empt <= tx_empt + 1;\n        tx_full <= tx_full + 1;\n        rx_full <= rx_full + 1;\n        busy_n <= busy_n + 1;\n        transm_complete <= transm_complete + 1;\n        crc_ok <= crc_ok + 1;\n        Dat_Int_Status_rst <= Dat_Int_Status_rst + 1;\n    end\nend\n\nalways_comb begin\n    case (state)\n        IDLE: begin\n            next_state = IDLE;\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n        end\n        GET_TX_BD: begin\n            next_state = SEND_CMD;\n            re_s_tx = 1;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n        end\n        GET_RX_BD: begin\n            next_state = SEND_CMD;\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 1;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n        end\n        SEND_CMD: begin\n            next_state = RECIVE_CMD;\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 1;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = cmd_arg;\n            cmd_set = cmd_set;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = sys_adr;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n        end\n        RECIVE_CMD: begin\n            next_state = DATA_TRANSFER;\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n        end\n        DATA_TRANSFER: begin\n            next_state = IDLE;\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n        end\n        STOP_SEND: begin\n            next_state = IDLE;\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        Dat_Int_Status <= 0;\n    end\n    else begin\n        Dat_Int_Status <= Dat_Int_Status_rst ? 0 : Dat_Int_Status + 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 4, "code": "module sd_data_master(\n    input  wire clk,\n    input  wire rst,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input  wire [BD_WIDTH-1:0] free_tx_bd,\n    input  wire ack_i_s_tx,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input  wire [BD_WIDTH-1:0] free_rx_bd,\n    input  wire ack_i_s_rx,\n    input  wire cmd_busy,\n    input  wire we_ack,\n    input  wire cmd_tsf_err,\n    input  wire [4:0] card_status,\n    input  wire tx_empt,\n    input  wire tx_full,\n    input  wire rx_full,\n    input  wire busy_n,\n    input  wire transm_complete,\n    input  wire crc_ok,\n    input  wire Dat_Int_Status_rst,\n    input  wire [1:0] transfer_type,\n    output wire re_s_tx,\n    output wire a_cmp_tx,\n    output wire re_s_rx,\n    output wire a_cmp_rx,\n    output wire we_req,\n    output wire d_write,\n    output wire d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire start_tx_fifo,\n    output wire start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire ack_transfer,\n    output wire [7:0] Dat_Int_Status\n);\n\n    // Define parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = 2;\n    parameter BD_EMPTY = BD_SIZE / 2;\n\n    // Define internal signals\n    reg [1:0] resend_try_cnt;\n    reg [8:0] state;\n    reg [8:0] next_state;\n    reg [1:0] trans_done;\n    reg [1:0] trans_failed;\n    reg [1:0] internal_transm_complete;\n    reg [1:0] transm_complete_q;\n    reg [2:0] bd_cnt;\n    reg [31:0] sys_adr;\n    reg [31:0] cmd_arg;\n    reg [15:0] cmd_set;\n    reg [1:0] CIDAT;\n    reg [7:0] Dat_Int_Status;\n\n    // Define FSM state machine\n    always @(posedge clk) begin\n        if (rst) begin\n            state <= IDLE;\n            next_state <= IDLE;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n            sys_adr <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            CIDAT <= 0;\n            Dat_Int_Status <= 0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    if (free_tx_bd != BD_EMPTY) begin\n                        next_state <= GET_TX_BD;\n                    end\n                    else if (free_rx_bd != BD_EMPTY) begin\n                        next_state <= GET_RX_BD;\n                    end\n                    else begin\n                        next_state <= IDLE;\n                    end\n                end\n                GET_TX_BD: begin\n                    if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                        next_state <= SEND_CMD;\n                    end\n                    else begin\n                        next_state <= GET_TX_BD;\n                    end\n                end\n                GET_RX_BD: begin\n                    if (bd_cnt >= READ_CYCLE - 1) begin\n                        next_state <= SEND_CMD;\n                    end\n                    else begin\n                        next_state <= GET_RX_BD;\n                    end\n                end\n                SEND_CMD: begin\n                    if (send_done == 1) begin\n                        next_state <= RECIVE_CMD;\n                    end\n                    else begin\n                        next_state <= SEND_CMD;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rec_done == 1) begin\n                        next_state <= DATA_TRANSFER;\n                    end\n                    else if (rec_failed == 1) begin\n                        next_state <= SEND_CMD;\n                    end\n                    else begin\n                        next_state <= RECIVE_CMD;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (trans_done == 1) begin\n                        next_state <= IDLE;\n                    end\n                    else if (trans_failed == 1) begin\n                        next_state <= STOP;\n                    end\n                    else begin\n                        next_state <= DATA_TRANSFER;\n                    end\n                end\n                STOP: begin\n                    next_state <= STOP_SEND;\n                end\n                STOP_SEND: begin\n                    if (send_done == 1) begin\n                        next_state <= IDLE;\n                    end\n                    else begin\n                        next_state <= STOP_SEND;\n                    end\n                end\n                default: begin\n                    next_state <= IDLE;\n                end\n            endcase\n        end\n    end\n\n    // Define output signals\n    assign re_s_tx = (state == GET_TX_BD) ? 1 : 0;\n    assign a_cmp_tx = (state == GET_TX_BD) ? 1 : 0;\n    assign re_s_rx = (state == GET_RX_BD) ? 1 : 0;\n    assign a_cmp_rx = (state == GET_RX_BD) ? 1 : 0;\n    assign we_req = (state == SEND_CMD) ? 1 : 0;\n    assign d_write = (state == SEND_CMD) ? 1 : 0;\n    assign d_read = (state == SEND_CMD) ? 1 : 0;\n    assign cmd_arg = (state == SEND_CMD) ? cmd_arg : 0;\n    assign cmd_set = (state == SEND_CMD) ? cmd_set : 0;\n    assign start_tx_fifo = (state == SEND_CMD) ? 1 : 0;\n    assign start_rx_fifo = (state == SEND_CMD) ? 1 : 0;\n    assign sys_adr = (state == SEND_CMD) ? sys_adr : 0;\n    assign ack_transfer = (state == DATA_TRANSFER) ? 1 : 0;\n    assign Dat_Int_Status = (state == DATA_TRANSFER) ? Dat_Int_Status : 0;\n\n    // Define internal signals\n    always @(posedge clk) begin\n        if (rst) begin\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            send_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            resend_try_cnt <= 0;\n        end\n        else begin\n            case (state)\n                SEND_CMD: begin\n                    send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    rec_done <= 1;\n                    rec_failed <= 0;\n                end\n                DATA_TRANSFER: begin\n                    trans_done <= 1;\n                    trans_failed <= 0;\n                end\n                STOP: begin\n                    send_done <= 1;\n                    rec_done <= 1;\n                    rec_failed <= 1;\n                    send_done <= 1;\n                    trans_failed <= 1;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt == RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                end\n                default: begin\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    resend_try_cnt <= 0;\n                end\n            endcase\n        end\n    end\n\n    // Define internal logic\n    always @(posedge clk) begin\n        if (rst) begin\n            CIDAT <= 0;\n        end\n        else begin\n            case (state)\n                SEND_CMD: begin\n                    CIDAT <= 1;\n                end\n                default: begin\n                    CIDAT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // Define internal logic\n    always @(posedge clk) begin\n        if (rst) begin\n            Dat_Int_Status <= 0;\n        end\n        else begin\n            case (state)\n                DATA_TRANSFER: begin\n                    Dat_Int_Status <= Dat_Int_Status | (trans_failed ? 1 : 0);\n                end\n                STOP: begin\n                    Dat_Int_Status <= Dat_Int_Status | (trans_failed ? 1 : 0);\n                end\n                STOP_SEND: begin\n                    Dat_Int_Status <= Dat_Int_Status | (trans_failed ? 1 : 0);\n                end\n                default: begin\n                    Dat_Int_Status <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 5, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_tx,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\n// Define parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\nparameter READ_CYCLE = 2;\nparameter BD_EMPTY = 1;\n\n// Define internal signals\nreg [1:0] send_done;\nreg [1:0] rec_done;\nreg [1:0] rec_failed;\nreg [1:0] tx_cycle;\nreg [1:0] rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg [1:0] trans_done;\nreg [1:0] trans_failed;\nreg [1:0] internal_transm_complete;\nreg [1:0] transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr;\nreg [31:0] cmd_arg;\nreg [15:0] cmd_set;\nreg CIDAT;\nreg [7:0] Dat_Int_Status;\n\n// Define FSM state machine\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state <= GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state <= GET_RX_BD;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_TX_BD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_RX_BD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state <= RECIVE_CMD;\n                end else begin\n                    next_state <= SEND_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state <= DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= RECIVE_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state <= IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state <= STOP;\n                end else begin\n                    next_state <= DATA_TRANSFER;\n                end\n            end\n            STOP: begin\n                next_state <= STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= STOP_SEND;\n                end\n            end\n            default: begin\n                next_state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// Define FSM state machine combinational logic\nalways_comb begin\n    // Define output signals\n    re_s_tx = 1'b0;\n    a_cmp_tx = 1'b0;\n    re_s_rx = 1'b0;\n    a_cmp_rx = 1'b0;\n    we_req = 1'b0;\n    d_write = 1'b0;\n    d_read = 1'b0;\n    cmd_arg = 32'b0;\n    cmd_set = 16'b0;\n    start_tx_fifo = 1'b0;\n    start_rx_fifo = 1'b0;\n    sys_adr = 32'b0;\n    ack_transfer = 1'b0;\n    Dat_Int_Status = 8'b0;\n    CIDAT = 1'b0;\n\n    // Define FSM state machine logic\n    case (state)\n        IDLE: begin\n            // Do nothing\n        end\n        GET_TX_BD: begin\n            // Assert re_s_tx to read a transmit buffer descriptor\n            re_s_tx = 1'b1;\n            // Process data based on memory width\n            if (RAM_MEM_WIDTH == 32) begin\n                // First read: Store data to sys_adr\n                sys_adr = dat_in_tx;\n                // Second read: Store data to cmd_arg and start TX FIFO\n                cmd_arg = dat_in_tx;\n                start_tx_fifo = 1'b1;\n            end else if (RAM_MEM_WIDTH == 16) begin\n                // Four reads to populate sys_adr and cmd_arg (16 bits at a time)\n                sys_adr = {dat_in_tx[15:0], dat_in_tx[15:0]};\n                cmd_arg = {dat_in_tx[15:0], dat_in_tx[15:0]};\n                start_tx_fifo = 1'b1;\n            end\n            // Set cmd_set to CMD24 (write single block command)\n            cmd_set = CMD24;\n            // Set tx_cycle to 1 to indicate transmit mode\n            tx_cycle = 1'b1;\n        end\n        GET_RX_BD: begin\n            // Assert re_s_rx to read a receive buffer descriptor\n            re_s_rx = 1'b1;\n            // Process data based on memory width\n            if (RAM_MEM_WIDTH == 32) begin\n                // First read: Store data to sys_adr\n                sys_adr = dat_in_rx;\n                // Second read: Store data to cmd_arg\n                cmd_arg = dat_in_rx;\n            end else if (RAM_MEM_WIDTH == 16) begin\n                // Four reads to populate sys_adr and cmd_arg (16 bits at a time)\n                sys_adr = {dat_in_rx[15:0], dat_in_rx[15:0]};\n                cmd_arg = {dat_in_rx[15:0], dat_in_rx[15:0]};\n            end\n            // Set command based on transfer_type\n            if (transfer_type == 2'b00) begin\n                // Set cmd_set to CMD17 (read single block)\n                cmd_set = CMD17;\n            end else if (transfer_type == 2'b01) begin\n                // Set cmd_set to ACMD13 (SD status)\n                cmd_set = ACMD13;\n            end else begin\n                // Set cmd_set to ACMD51 (SCR register)\n                cmd_set = ACMD51;\n            end\n            // Set rx_cycle to 1 to indicate receive mode\n            rx_cycle = 1'b1;\n        end\n        SEND_CMD: begin\n            // Check type of cycle rx or tx\n            if (tx_cycle) begin\n                // Set d_write to 1\n                d_write = 1'b1;\n            end else begin\n                // Set d_read to 1\n                d_read = 1'b1;\n            end\n            // Check if CMD is free, if so assert we_req\n            if (!cmd_busy) begin\n                we_req = 1'b1;\n            end\n            // Wait for we_ack\n            wait (we_ack);\n            // Set send_done to 1\n            send_done = 1'b1;\n        end\n        RECIVE_CMD: begin\n            // Start Rx_Fifo_Filer if Rx cycle\n            if (rx_cycle) begin\n                start_rx_fifo = 1'b1;\n            end\n            // Wait for command response (indicated by cmd_busy are low)\n            wait (!cmd_busy);\n            // Check so cmd_tsf_err is not asserted, if asserted set command_failed.\n            if (cmd_tsf_err) begin\n                rec_failed = 1'b1;\n            end\n            // Check the response data,\n            if (card_status[0] == 1) begin\n                // If card is ready for data card_status[0] == 1\n                // If card is in transmission state for data card_status[4:1] == 4,5 or 6\n            end\n        end\n        DATA_TRANSFER: begin\n            // If tx_cycle check so tx_fifo doenst get empty \n            if (tx_cycle) begin\n                // Check so tx_fifo doenst get empty \n                if (!tx_empt) begin\n                    // Do nothing\n                end else begin\n                    // Do nothing\n                end\n            end\n            // If rx_cycle check so rx_fifo doenst get full \n            if (rx_cycle) begin\n                // Check so rx_fifo doenst get full \n                if (!rx_full) begin\n                    // Do nothing\n                end else begin\n                    // Do nothing\n                end\n            end\n            // Wait for command complete\n            wait (transm_complete);\n            // Check so crc_ok == 1 \n            if (crc_ok) begin\n                // Do nothing\n            end else begin\n                // Do nothing\n            end\n            // Free the BD\n            a_cmp_tx = 1'b1;\n        end\n        STOP: begin\n            // Set cmd_set to CMD12\n            cmd_set = CMD12;\n            // Set rec_done, rec_failed, send_done, trans_failed, trans_done to 0\n            rec_done = 1'b0;\n            rec_failed = 1'b0;\n            send_done = 1'b0;\n            trans_failed = 1'b0;\n            trans_done = 1'b0;\n            // Set d_read, d_write to 1\n            d_read = 1'b1;\n            d_write = 1'b1;\n            // Set start_rx_fifo, start_tx_fifo to 0\n            start_rx_fifo = 1'b0;\n            start_tx_fifo = 1'b0;\n        end\n        STOP_SEND: begin\n            // Increment resend_try_cnt by 1\n            resend_try_cnt = resend_try_cnt + 1;\n            // If resend_try_cnt reachs RESEND_MAX_CNT, then set Dat_Int_Status[1] to 1\n            if (resend_try_cnt == RESEND_MAX_CNT) begin\n                Dat_Int_Status[1] = 1'b1;\n            end\n            // If CMD is not busy, then request access to CMD registers\n            if (!cmd_busy) begin\n                we_req = 1'b1;\n            end\n            // If sccess granted(we_ack == 1), then message has send done.\n            if (we_ack) begin\n                send_done = 1'b1;\n            end\n        end\n        default: begin\n            // Do nothing\n        end\n    endcase\nend\n\n// Define output signals\nassign re_s_tx = re_s_tx;\nassign a_cmp_tx = a_cmp_tx;\nassign re_s_rx = re_s_rx;\nassign a_cmp_rx = a_cmp_rx;\nassign we_req = we_req;\nassign d_write = d_write;\nassign d_read = d_read;\nassign cmd_arg = cmd_arg;\nassign cmd_set = cmd_set;\nassign start_tx_fifo = start_tx_fifo;\nassign start_rx_fifo = start_rx_fifo;\nassign sys_adr = sys_adr;\nassign ack_transfer = ack_transfer;\nassign Dat_Int_Status = Dat_Int_Status;\nassign CIDAT = CIDAT;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 6, "code": "module sd_data_master(\n    input  wire clk,\n    input  wire rst,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input  wire [BD_WIDTH-1:0] free_tx_bd,\n    input  wire ack_i_s_tx,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input  wire [BD_WIDTH-1:0] free_rx_bd,\n    input  wire ack_i_s_rx,\n    input  wire cmd_busy,\n    input  wire we_ack,\n    input  wire cmd_tsf_err,\n    input  wire [4:0] card_status,\n    input  wire tx_empt,\n    input  wire tx_full,\n    input  wire rx_full,\n    input  wire busy_n,\n    input  wire transm_complete,\n    input  wire crc_ok,\n    input  wire Dat_Int_Status_rst,\n    input  wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Define parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = 2;\n    parameter BD_EMPTY = BD_SIZE / 2;\n\n    // Define registers\n    reg [1:0] resend_try_cnt;\n    reg [SIZE-1:0] state;\n    reg [SIZE-1:0] next_state;\n    reg [1:0] trans_done;\n    reg [1:0] trans_failed;\n    reg [1:0] internal_transm_complete;\n    reg [1:0] transm_complete_q;\n    reg [1:0] bd_cnt;\n    reg [31:0] sys_adr;\n    reg [31:0] cmd_arg;\n    reg [15:0] cmd_set;\n    reg [1:0] CIDAT;\n    reg [7:0] Dat_Int_Status;\n\n    // Define initial values\n    initial begin\n        state = IDLE;\n        resend_try_cnt = 0;\n        trans_done = 0;\n        trans_failed = 0;\n        internal_transm_complete = 0;\n        transm_complete_q = 0;\n        bd_cnt = 0;\n        sys_adr = 0;\n        cmd_arg = 0;\n        cmd_set = 0;\n        CIDAT = 0;\n        Dat_Int_Status = 0;\n    end\n\n    // FSM logic\n    always @(posedge clk) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n            sys_adr <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            CIDAT <= 0;\n            Dat_Int_Status <= 0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    if (free_tx_bd != BD_EMPTY) begin\n                        next_state = GET_TX_BD;\n                    end\n                    else if (free_rx_bd != BD_EMPTY) begin\n                        next_state = GET_RX_BD;\n                    end\n                    else begin\n                        next_state = IDLE;\n                    end\n                end\n                GET_TX_BD: begin\n                    if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                        next_state = SEND_CMD;\n                    end\n                    else begin\n                        next_state = GET_TX_BD;\n                    end\n                end\n                GET_RX_BD: begin\n                    if (bd_cnt >= READ_CYCLE - 1) begin\n                        next_state = SEND_CMD;\n                    end\n                    else begin\n                        next_state = GET_RX_BD;\n                    end\n                end\n                SEND_CMD: begin\n                    if (send_done == 1) begin\n                        next_state = RECIVE_CMD;\n                    end\n                    else begin\n                        next_state = SEND_CMD;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rec_done == 1) begin\n                        next_state = DATA_TRANSFER;\n                    end\n                    else if (rec_failed == 1) begin\n                        next_state = SEND_CMD;\n                    end\n                    else begin\n                        next_state = RECIVE_CMD;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (trans_done == 1) begin\n                        next_state = IDLE;\n                    end\n                    else if (trans_failed == 1) begin\n                        next_state = STOP;\n                    end\n                    else begin\n                        next_state = DATA_TRANSFER;\n                    end\n                end\n                STOP: begin\n                    next_state = STOP_SEND;\n                end\n                STOP_SEND: begin\n                    if (send_done == 1) begin\n                        next_state = IDLE;\n                    end\n                    else begin\n                        next_state = STOP_SEND;\n                    end\n                end\n            endcase\n        end\n        state <= next_state;\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n        end\n        else begin\n            case (state)\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    a_cmp_tx <= 0;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    a_cmp_rx <= 0;\n                end\n                SEND_CMD: begin\n                    if (d_write) begin\n                        we_req <= 1;\n                    end\n                    else begin\n                        we_req <= 0;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (d_read) begin\n                        we_req <= 1;\n                    end\n                    else begin\n                        we_req <= 0;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (transm_complete_q == 1) begin\n                        ack_transfer <= 1;\n                    end\n                    else begin\n                        ack_transfer <= 0;\n                    end\n                end\n                STOP: begin\n                    we_req <= 0;\n                    d_write <= 1;\n                    d_read <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    if (resend_try_cnt < RESEND_MAX_CNT) begin\n                        we_req <= 1;\n                    end\n                    else begin\n                        we_req <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Internal logic\n    always @(posedge clk) begin\n        if (rst) begin\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            send_done <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            sys_adr <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            CIDAT <= 0;\n            Dat_Int_Status <= 0;\n        end\n        else begin\n            case (state)\n                SEND_CMD: begin\n                    if (we_ack == 1) begin\n                        send_done <= 1;\n                    end\n                    else begin\n                        send_done <= 0;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (cmd_tsf_err == 1) begin\n                        rec_failed <= 1;\n                    end\n                    else if (card_status[0] == 1) begin\n                        rec_done <= 1;\n                    end\n                    else begin\n                        rec_done <= 0;\n                        rec_failed <= 0;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (transm_complete == 1) begin\n                        trans_done <= 1;\n                    end\n                    else begin\n                        trans_done <= 0;\n                    end\n                end\n                STOP: begin\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    sys_adr <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                STOP_SEND: begin\n                    if (send_done == 1) begin\n                        resend_try_cnt <= resend_try_cnt + 1;\n                    end\n                    else begin\n                        resend_try_cnt <= resend_try_cnt;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            CIDAT <= 0;\n            Dat_Int_Status <= 0;\n        end\n        else begin\n            case (state)\n                DATA_TRANSFER: begin\n                    if (transm_complete_q == 1) begin\n                        CIDAT <= 1;\n                    end\n                    else begin\n                        CIDAT <= 0;\n                    end\n                end\n                STOP: begin\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                STOP_SEND: begin\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status <= 1;\n                    end\n                    else begin\n                        Dat_Int_Status <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 7, "code": "module sd_data_master(\n    input  clk,\n    input  rst,\n    input  dat_in_tx,\n    input  free_tx_bd,\n    input  ack_i_s_tx,\n    input  dat_in_rx,\n    input  free_rx_bd,\n    input  ack_i_s_rx,\n    input  cmd_busy,\n    input  we_ack,\n    input  cmd_tsf_err,\n    input  card_status,\n    input  tx_empt,\n    input  tx_full,\n    input  rx_full,\n    input  busy_n,\n    input  transm_complete,\n    input  crc_ok,\n    input  Dat_Int_Status_rst,\n    input  transfer_type,\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output cmd_arg,\n    output cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output sys_adr,\n    output ack_transfer,\n    output Dat_Int_Status,\n    output CIDAT\n);\n\n    // Internal signals\n    reg [8:0] state;\n    reg [8:0] next_state;\n    reg [1:0] resend_try_cnt;\n    reg [1:0] tx_cycle;\n    reg [1:0] rx_cycle;\n    reg [2:0] bd_cnt;\n    reg [31:0] sys_adr;\n    reg [31:0] cmd_arg;\n    reg [15:0] cmd_set;\n    reg [1:0] CIDAT;\n    reg [7:0] Dat_Int_Status;\n    reg [1:0] trans_done;\n    reg [1:0] trans_failed;\n    reg [1:0] internal_transm_complete;\n    reg [1:0] transm_complete_q;\n    reg [1:0] resend_done;\n\n    // FSM state definitions\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n\n    // FSM state transition table\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            bd_cnt <= 0;\n            sys_adr <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            CIDAT <= 0;\n            Dat_Int_Status <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            resend_done <= 0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    if (free_tx_bd != BD_EMPTY) begin\n                        next_state = GET_TX_BD;\n                    end\n                    else if (free_rx_bd != BD_EMPTY) begin\n                        next_state = GET_RX_BD;\n                    end\n                    else begin\n                        next_state = IDLE;\n                    end\n                end\n                GET_TX_BD: begin\n                    if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                        next_state = SEND_CMD;\n                    end\n                    else begin\n                        next_state = GET_TX_BD;\n                    end\n                end\n                GET_RX_BD: begin\n                    if (bd_cnt >= READ_CYCLE - 1) begin\n                        next_state = SEND_CMD;\n                    end\n                    else begin\n                        next_state = GET_RX_BD;\n                    end\n                end\n                SEND_CMD: begin\n                    if (send_done == 1) begin\n                        next_state = RECIVE_CMD;\n                    end\n                    else begin\n                        next_state = SEND_CMD;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rec_done == 1) begin\n                        next_state = DATA_TRANSFER;\n                    end\n                    else if (rec_failed == 1) begin\n                        next_state = SEND_CMD;\n                    end\n                    else begin\n                        next_state = RECIVE_CMD;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (trans_done == 1) begin\n                        next_state = IDLE;\n                    end\n                    else if (trans_failed == 1) begin\n                        next_state = STOP;\n                    end\n                    else begin\n                        next_state = DATA_TRANSFER;\n                    end\n                end\n                STOP: begin\n                    next_state = STOP_SEND;\n                end\n                STOP_SEND: begin\n                    if (send_done == 1) begin\n                        next_state = IDLE;\n                    end\n                    else begin\n                        next_state = STOP_SEND;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // FSM state machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                GET_RX_BD: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 1;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                SEND_CMD: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 1;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                RECIVE_CMD: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                DATA_TRANSFER: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                STOP: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                STOP_SEND: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // FSM internal logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            send_done <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            resend_done <= 0;\n        end\n        else begin\n            case (state)\n                SEND_CMD: begin\n                    send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    rec_done <= 1;\n                    rec_failed <= 0;\n                end\n                DATA_TRANSFER: begin\n                    trans_done <= 1;\n                    trans_failed <= 0;\n                end\n                STOP: begin\n                    send_done <= 1;\n                    rec_done <= 1;\n                    rec_failed <= 0;\n                    trans_done <= 1;\n                    trans_failed <= 0;\n                end\n                STOP_SEND: begin\n                    resend_done <= 1;\n                end\n            endcase\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            CIDAT <= 0;\n            Dat_Int_Status <= 0;\n        end\n        else begin\n            case (state)\n                SEND_CMD: begin\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                RECIVE_CMD: begin\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                DATA_TRANSFER: begin\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                STOP: begin\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n                STOP_SEND: begin\n                    CIDAT <= 0;\n                    Dat_Int_Status <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 8, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg [8:0] state;\nreg [8:0] next_state;\nreg [1:0] resend_try_cnt;\nreg [1:0] tx_cycle;\nreg [1:0] rx_cycle;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr;\nreg [31:0] cmd_arg;\nreg [15:0] cmd_set;\nreg [1:0] resend_try_cnt;\nreg [1:0] trans_done;\nreg [1:0] trans_failed;\nreg [1:0] internal_transm_complete;\nreg [1:0] transm_complete_q;\nreg [1:0] CIDAT;\nreg [7:0] Dat_Int_Status;\n\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\nparameter READ_CYCLE = 2;\nparameter BD_EMPTY = BD_SIZE / 2;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n        resend_try_cnt <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end\n    else begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY)\n                    next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY)\n                    next_state = GET_RX_BD;\n                else\n                    next_state = IDLE;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1)\n                    next_state = SEND_CMD;\n                else\n                    next_state = GET_TX_BD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1)\n                    next_state = SEND_CMD;\n                else\n                    next_state = GET_RX_BD;\n            end\n            SEND_CMD: begin\n                if (send_done == 1)\n                    next_state = RECIVE_CMD;\n                else\n                    next_state = SEND_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1)\n                    next_state = DATA_TRANSFER;\n                else if (rec_failed == 1)\n                    next_state = SEND_CMD;\n                else\n                    next_state = RECIVE_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1)\n                    next_state = IDLE;\n                else if (trans_failed == 1)\n                    next_state = STOP;\n                else\n                    next_state = DATA_TRANSFER;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1)\n                    next_state = IDLE;\n                else\n                    next_state = STOP_SEND;\n            end\n        endcase\n        state <= next_state;\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n    end\n    else begin\n        case (state)\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                a_cmp_tx <= 1;\n                sys_adr <= dat_in_tx;\n                cmd_arg <= dat_in_tx;\n                cmd_set <= CMD24;\n                tx_cycle <= 1;\n            end\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                a_cmp_rx <= 1;\n                sys_adr <= dat_in_rx;\n                cmd_arg <= dat_in_rx;\n                cmd_set <= CMD17;\n                rx_cycle <= 1;\n            end\n            SEND_CMD: begin\n                if (cmd_busy == 0)\n                    we_req <= 1;\n                else\n                    we_req <= 0;\n                if (we_ack == 1)\n                    send_done <= 1;\n            end\n            RECIVE_CMD: begin\n                if (cmd_busy == 0)\n                    we_req <= 1;\n                else\n                    we_req <= 0;\n                if (we_ack == 1)\n                    rec_done <= 1;\n            end\n            DATA_TRANSFER: begin\n                if (tx_cycle == 1)\n                    start_tx_fifo <= 1;\n                if (rx_cycle == 1)\n                    start_rx_fifo <= 1;\n                if (transm_complete == 1)\n                    ack_transfer <= 1;\n            end\n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT)\n                    Dat_Int_Status[1] <= 1;\n                if (cmd_busy == 0)\n                    we_req <= 1;\n                else\n                    we_req <= 0;\n                if (we_ack == 1)\n                    send_done <= 1;\n            end\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end\n    else begin\n        case (state)\n            RECIVE_CMD: begin\n                if (cmd_tsf_err == 1)\n                    rec_failed <= 1;\n                if (card_status[0] == 1)\n                    CIDAT <= 1;\n                if (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)\n                    CIDAT <= 1;\n            end\n            DATA_TRANSFER: begin\n                if (tx_cycle == 1)\n                    CIDAT <= 1;\n                if (rx_cycle == 1)\n                    CIDAT <= 1;\n                if (crc_ok == 1)\n                    CIDAT <= 1;\n            end\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n    end\n    else begin\n        case (state)\n            DATA_TRANSFER: begin\n                if (transm_complete == 1)\n                    internal_transm_complete <= 1;\n                if (transm_complete_q == 1)\n                    trans_done <= 1;\n            end\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        Dat_Int_Status <= 0;\n    end\n    else begin\n        if (Dat_Int_Status_rst == 1)\n            Dat_Int_Status <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 1, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC Generation Block\n    sd_crc_16 crc_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK Synchronization Block\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end\n        else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM Combo Block\n    always @* begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01) begin\n                    next_state = WRITE_DAT;\n                end\n                else if (start_dat == 2'b10) begin\n                    next_state = READ_WAIT;\n                end\n                else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = WRITE_CRC;\n                end\n                else begin\n                    next_state = WRITE_DAT;\n                end\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111) begin\n                    next_state = WRITE_BUSY;\n                end\n                else begin\n                    next_state = WRITE_CRC;\n                end\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0) begin\n                    next_state = IDLE;\n                end\n                else begin\n                    next_state = WRITE_BUSY;\n                end\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0) begin\n                    next_state = READ_DAT;\n                end\n                else begin\n                    next_state = READ_WAIT;\n                end\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = IDLE;\n                end\n                else begin\n                    next_state = READ_DAT;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        end\n    end\n\n    // FSM Seq Block\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            state <= IDLE;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Out Block\n    always @* begin\n        case (state)\n            IDLE: begin\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n            WRITE_DAT: begin\n                write_buf_0 <= data_in;\n                write_buf_1 <= 0;\n                DAT_oe_o <= 1;\n                crc_en <= 1;\n                crc_rst <= 0;\n                transf_cnt <= transf_cnt + 1;\n                rd <= 0;\n                last_din <= write_buf_0[31:28];\n                crc_c <= crc_c + 1;\n                crc_in <= write_buf_0[27:0];\n                DAT_dat_o <= write_buf_0[27:0];\n                crc_status <= crc_status + 1;\n                crc_s <= crc_s + 1;\n                transm_complete <= 0;\n                busy_n <= 0;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index + 1;\n                out_buff_ptr <= out_buff_ptr + 1;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            WRITE_CRC: begin\n                DAT_oe_o <= 1;\n                crc_en <= 1;\n                crc_rst <= 0;\n                transf_cnt <= transf_cnt;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= crc_c + 1;\n                crc_in <= DAR_dat_i[15:0];\n                DAT_dat_o <= DAR_dat_i[15:0];\n                crc_status <= crc_status + 1;\n                crc_s <= crc_s + 1;\n                transm_complete <= 0;\n                busy_n <= 0;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            WRITE_BUSY: begin\n                DAT_oe_o <= 1;\n                crc_en <= 1;\n                crc_rst <= 0;\n                transf_cnt <= transf_cnt;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= crc_c + 1;\n                crc_in <= DAR_dat_i[15:0];\n                DAT_dat_o <= DAR_dat_i[15:0];\n                crc_status <= crc_status + 1;\n                crc_s <= crc_s + 1;\n                transm_complete <= 0;\n                busy_n <= 0;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            READ_WAIT: begin\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                rd <= 1;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n            READ_DAT: begin\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt + 1;\n                rd <= 1;\n                last_din <= DAR_dat_i[3:0];\n                crc_c <= crc_c + 1;\n                crc_in <= DAR_dat_i[15:4];\n                DAT_dat_o <= DAR_dat_i[15:4];\n                crc_status <= crc_status + 1;\n                crc_s <= crc_s + 1;\n                transm_complete <= 0;\n                busy_n <= 0;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index + 1;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            default: begin\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n        end\n    end\n\n    // START SYNC Block\n    always @* begin\n        if (state == READ_WAIT) begin\n            if (DAT_dat_i[0] == 0) begin\n                q_start_bit <= 0;\n            end\n            else begin\n                q_start_bit <= 1;\n            end\n        end\n        else begin\n            q_start_bit <= 1;\n        end\n    end\n\n    // FSM Seq Block\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            state <= IDLE;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Output Logic\n    assign DAT_oe_o = (state == WRITE_DAT || state == WRITE_CRC || state == WRITE_BUSY || state == READ_WAIT || state == READ_DAT);\n    assign DAT_dat_o = (state == WRITE_DAT) ? write_buf_0[27:0] : (state == WRITE_CRC) ? DAR_dat_i[15:0] : (state == WRITE_BUSY) ? DAR_dat_i[15:0] : (state == READ_DAT) ? DAR_dat_i[15:4] : 0;\n    assign rd = (state == READ_WAIT || state == READ_DAT);\n    assign we = (state == WRITE_DAT);\n    assign transm_complete = (state == WRITE_BUSY);\n    assign crc_ok = (state == WRITE_BUSY) ? (crc_status == 3'b111) : 1'b0;\n    assign busy_n = (state == WRITE_BUSY) ? 1'b0 : 1'b1;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 2, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen\n    sd_crc_16 crc_16_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end\n        else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01) next_state = WRITE_DAT;\n                else if (start_dat == 2'b10) next_state = READ_WAIT;\n                else next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = WRITE_CRC;\n                else next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111) next_state = WRITE_BUSY;\n                else next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0) next_state = IDLE;\n                else next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0) next_state = READ_DAT;\n                else next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = IDLE;\n                else next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) state <= IDLE;\n        else state <= next_state;\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    // Reset CRC and counters\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= 0;\n                    crc_c <= 0;\n                    crc_in <= 0;\n                    crc_status <= 3'b111;\n                    crc_s <= 0;\n                    last_din <= 0;\n                    data_send_index <= 0;\n                    out_buff_ptr <= 0;\n                    in_buff_ptr <= 0;\n                end\n                WRITE_DAT: begin\n                    // Write data to FIFO\n                    write_buf_0 <= data_in;\n                    write_buf_1 <= data_in;\n                    // Send start bit\n                    DAT_dat_o <= 0;\n                    // Read 4 bits from FIFO and assign to last_din and crc_in\n                    last_din <= write_buf_0[3:0];\n                    crc_in <= write_buf_0[3:0];\n                    // Assign value of last_din to DAT_dat_o\n                    DAT_dat_o <= last_din;\n                    // Increment out_buff_ptr and read new value to sd_data_out from FIFO\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    sd_data_out <= write_buf_0;\n                    // Repeat until 512 bytes sent\n                    if (transf_cnt == SD_BUS_W) begin\n                        // Attach 16-bit CRC to each data line\n                        crc_en <= 1;\n                        crc_rst <= 0;\n                    end\n                    else transf_cnt <= transf_cnt + 1;\n                end\n                WRITE_CRC: begin\n                    // Read CRC response token, 7 cycles, ignore 3 first cycles, 2 delay, and 1 start bit\n                    crc_s <= {crc_s[2:0], DAT_dat_i[0]};\n                    // Read bit 7, stop bit\n                    crc_c <= {crc_c[4:0], DAT_dat_i[7]};\n                    // Check CRC response\n                    if (crc_c == 5'b10000) crc_status <= 3'b111;\n                    else crc_status <= 3'b000;\n                end\n                WRITE_BUSY: begin\n                    // Signal for transm_complete\n                    transm_complete <= 1;\n                    // Check CRC response\n                    if (crc_status == 3'b111) crc_ok <= 1;\n                    // Poll DAT_dat_i[0] to sense whenever the card is busy\n                    if (DAT_dat_i[0] == 0) busy_int <= 0;\n                    else busy_int <= 1;\n                end\n                READ_WAIT: begin\n                    // Prepare for data reception, enable CRC units, disable output enable\n                    DAT_oe_o <= 0;\n                    crc_en <= 1;\n                    crc_rst <= 0;\n                    // Set up internal control register\n                    in_buff_ptr <= 0;\n                end\n                READ_DAT: begin\n                    // Read DAT_dat_i and store to FIFO data_out and crc_in\n                    data_out <= DAR_dat_i;\n                    crc_in <= DAR_dat_i;\n                    // Increment transfer counter\n                    transf_cnt <= transf_cnt + 1;\n                    // Repeat until 512 bytes received\n                    if (transf_cnt == SD_BUS_W) begin\n                        // Compare received CRC bits with calculated crc_out values\n                        if (LITTLE_ENDIAN) begin\n                            if (crc_in[SD_BUS_W-1:SD_BUS_W-4] == crc_out[15:12]) crc_ok <= 1;\n                            else crc_ok <= 0;\n                        end\n                        else begin\n                            if (crc_in[3:0] == crc_out[11:8]) crc_ok <= 1;\n                            else crc_ok <= 0;\n                        end\n                        // Set transm_complete when 16 CRC bits have been read\n                        transm_complete <= 1;\n                        // Clear busy_n to indicate operation completion\n                        busy_n <= 0;\n                    end\n                end\n                default: begin\n                    // Default to idle to ensure safe operation\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= 0;\n                    crc_c <= 0;\n                    crc_in <= 0;\n                    crc_status <= 3'b111;\n                    crc_s <= 0;\n                    last_din <= 0;\n                    data_send_index <= 0;\n                    out_buff_ptr <= 0;\n                    in_buff_ptr <= 0;\n                end\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 3, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n    // Parameters\n    parameter SD_BUS_W = 4;\n    parameter BIT_BLOCK = 512;\n    parameter CRC_OFF = 16;\n    parameter BIT_BLOCK_REC = 512;\n    parameter BIT_CRC_CYCLE = 16;\n    parameter LITTLE_ENDIAN = 1;\n    parameter BIG_ENDIAN = 0;\n    parameter SD_BUS_WIDTH_1 = 1;\n    parameter SD_BUS_WIDTH_4 = 4;\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC Generation Block\n    sd_crc_16 crc_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK Synchronization Block\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end\n        else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM Combo Block\n    always_comb begin\n        case (state)\n            6'd0: // IDLE\n                if (start_dat == 2'b01) next_state = 6'd1;\n                else if (start_dat == 2'b10) next_state = 6'd2;\n                else next_state = 6'd0;\n            6'd1: // WRITE_DAT\n                if (transf_cnt == SD_BUS_W) next_state = 6'd2;\n                else next_state = 6'd1;\n            6'd2: // WRITE_CRC\n                if (crc_status == 3'b111) next_state = 6'd3;\n                else next_state = 6'd2;\n            6'd3: // WRITE_BUSY\n                if (busy_int == 0) next_state = 6'd0;\n                else next_state = 6'd3;\n            6'd4: // READ_WAIT\n                if (DAT_dat_i[0] == 0) next_state = 6'd5;\n                else next_state = 6'd4;\n            6'd5: // READ_DAT\n                if (transf_cnt == SD_BUS_W) next_state = 6'd0;\n                else next_state = 6'd5;\n            default: next_state = 6'd0;\n        endcase\n    end\n\n    // FSM Seq Block\n    always @(posedge sd_clk) begin\n        if (rst) state <= 6'd0;\n        else state <= next_state;\n    end\n\n    // FSM Out Block\n    always @(posedge sd_clk) begin\n        case (state)\n            6'd0: // IDLE\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            6'd1: // WRITE_DAT\n                write_buf_0 <= data_in;\n                write_buf_1 <= 0;\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt + 1;\n                rd <= 0;\n                last_din <= write_buf_0[3:0];\n                crc_c <= crc_c + 1;\n                crc_in <= write_buf_0[SD_BUS_W-1:SD_BUS_W-4];\n                DAT_dat_o <= write_buf_0[SD_BUS_W-1:SD_BUS_W-4];\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 0;\n                busy_n <= 0;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index + 1;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            6'd2: // WRITE_CRC\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt;\n                rd <= 0;\n                last_din <= write_buf_1[3:0];\n                crc_c <= crc_c + 1;\n                crc_in <= write_buf_1[SD_BUS_W-1:SD_BUS_W-4];\n                DAT_dat_o <= write_buf_1[SD_BUS_W-1:SD_BUS_W-4];\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 0;\n                busy_n <= 0;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            6'd3: // WRITE_BUSY\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= crc_c;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 1;\n                busy_n <= 0;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 1;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            6'd4: // READ_WAIT\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= crc_c;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 0;\n                busy_n <= 0;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            6'd5: // READ_DAT\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt + 1;\n                rd <= 1;\n                last_din <= DAR_dat_i[3:0];\n                crc_c <= crc_c + 1;\n                crc_in <= DAR_dat_i[SD_BUS_W-1:SD_BUS_W-4];\n                DAT_dat_o <= DAR_dat_i[SD_BUS_W-1:SD_BUS_W-4];\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 0;\n                busy_n <= 0;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index + 1;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            default:\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n        endcase\n    end\n\n    // START SYNC Block\n    always @(posedge sd_clk) begin\n        if (rst) q_start_bit <= 1;\n        else if (state == 6'd4 && DAT_dat_i[0] == 0) q_start_bit <= 0;\n        else q_start_bit <= 1;\n    end\n\n    // FSM_OUT Block\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end\n        else begin\n            case (state)\n                6'd0: // IDLE\n                    write_buf_0 <= 0;\n                    write_buf_1 <= 0;\n                    DAT_oe_o <= 0;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    last_din <= 0;\n                    crc_c <= 0;\n                    crc_in <= 0;\n                    DAT_dat_o <= 0;\n                    crc_status <= 3'b111;\n                    crc_s <= 0;\n                    transm_complete <= 0;\n                    busy_n <= 1;\n                    we <= 0;\n                    data_out <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= 0;\n                    out_buff_ptr <= 0;\n                    in_buff_ptr <= 0;\n                6'd1: // WRITE_DAT\n                    write_buf_0 <= data_in;\n                    write_buf_1 <= 0;\n                    DAT_oe_o <= 0;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= transf_cnt + 1;\n                    rd <= 0;\n                    last_din <= write_buf_0[3:0];\n                    crc_c <= crc_c + 1;\n                    crc_in <= write_buf_0[SD_BUS_W-1:SD_BUS_W-4];\n                    DAT_dat_o <= write_buf_0[SD_BUS_W-1:SD_BUS_W-4];\n                    crc_status <= crc_status;\n                    crc_s <= crc_s;\n                    transm_complete <= 0;\n                    busy_n <= 0;\n                    we <= 0;\n                    data_out <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= data_send_index + 1;\n                    out_buff_ptr <= out_buff_ptr;\n                    in_buff_ptr <= in_buff_ptr;\n                6'd2: // WRITE_CRC\n                    DAT_oe_o <= 0;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= transf_cnt;\n                    rd <= 0;\n                    last_din <= write_buf_1[3:0];\n                    crc_c <= crc_c + 1;\n                    crc_in <= write_buf_1[SD_BUS_W-1:SD_BUS_W-4];\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-1:SD_BUS_W-4];\n                    crc_status <= crc_status;\n                    crc_s <= crc_s;\n                    transm_complete <= 0;\n                    busy_n <= 0;\n                    we <= 0;\n                    data_out <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= data_send_index;\n                    out_buff_ptr <= out_buff_ptr;\n                    in_buff_ptr <= in_buff_ptr;\n                6'd3: // WRITE_BUSY\n                    DAT_oe_o <= 0;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= transf_cnt;\n                    rd <= 0;\n                    last_din <= 0;\n                    crc_c <= crc_c;\n                    crc_in <= 0;\n                    DAT_dat_o <= 0;\n                    crc_status <= crc_status;\n                    crc_s <= crc_s;\n                    transm_complete <= 1;\n                    busy_n <= 0;\n                    we <= 0;\n                    data_out <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 1;\n                    data_send_index <= data_send_index;\n                    out_buff_ptr <= out_buff_ptr;\n                    in_buff_ptr <= in_buff_ptr;\n                6'd4: // READ_WAIT\n                    DAT_oe_o <= 0;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= transf_cnt;\n                    rd <= 0;\n                    last_din <= 0;\n                    crc_c <= crc_c;\n                    crc_in <= 0;\n                    DAT_dat_o <= 0;\n                    crc_status <= crc_status;\n                    crc_s <= crc_s;\n                    transm_complete <= 0;\n                    busy_n <= 0;\n                    we <= 0;\n                    data_out <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= data_send_index;\n                    out_buff_ptr <= out_buff_ptr;\n                    in_buff_ptr <= in_buff_ptr;\n                6'd5: // READ_DAT\n                    DAT_oe_o <= 0;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= transf_cnt + 1;\n                    rd <= 1;\n                    last_din <= DAR_dat_i[3:0];\n                    crc_c <= crc_c + 1;\n                    crc_in <= DAR_dat_i[SD_BUS_W-1:SD_BUS_W-4];\n                    DAT_dat_o <= DAR_dat_i[SD_BUS_W-1:SD_BUS_W-4];\n                    crc_status <= crc_status;\n                    crc_s <= crc_s;\n                    transm_complete <= 0;\n                    busy_n <= 0;\n                    we <= 0;\n                    data_out <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= data_send_index + 1;\n                    out_buff_ptr <= out_buff_ptr;\n                    in_buff_ptr <= in_buff_ptr;\n                default:\n                    DAT_oe_o <= 0;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    last_din <= 0;\n                    crc_c <= 0;\n                    crc_in <= 0;\n                    DAT_dat_o <= 0;\n                    crc_status <= 3'b111;\n                    crc_s <= 0;\n                    transm_complete <= 0;\n                    busy_n <= 1;\n                    we <= 0;\n                    data_out <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= 0;\n                    out_buff_ptr <= 0;\n                    in_buff_ptr <= 0;\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 4, "code": "module sd_data_serial_host(\n    input  logic sd_clk,\n    input  logic rst,\n    input  logic [31:0] data_in,\n    input  logic [1:0] start_dat,\n    input  logic ack_transfer,\n    input  logic [SD_BUS_W-1:0] DAR_dat_i,\n    output logic rd,\n    output logic [SD_BUS_W-1:0] data_out,\n    output logic we,\n    output logic DAT_oe_o,\n    output logic [SD_BUS_W-1:0] DAT_dat_o,\n    output logic busy_n,\n    output logic transm_complete,\n    output logic crc_ok\n);\n\n    // Internal signals\n    logic [SD_BUS_W-1:0] crc_in;\n    logic crc_en;\n    logic crc_rst;\n    logic [15:0] crc_out;\n    logic [SD_BUS_W-1:0] temp_in;\n    logic [10:0] transf_cnt;\n    logic [5:0] state;\n    logic [5:0] next_state;\n    logic [2:0] crc_status;\n    logic busy_int;\n    logic ack_transfer_int;\n    logic ack_q;\n    logic q_start_bit;\n    logic [4:0] crc_c;\n    logic [3:0] last_din;\n    logic [2:0] crc_s;\n    logic [31:0] write_buf_0;\n    logic [31:0] write_buf_1;\n    logic [31:0] sd_data_out;\n    logic [1:0] out_buff_ptr;\n    logic [1:0] in_buff_ptr;\n    logic [2:0] data_send_index;\n\n    // CRC_16_gen submodule\n    sd_crc_16 crc_16_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK_SYNC submodule\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end\n        else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO submodule\n    always_comb begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01) next_state = WRITE_DAT;\n                else if (start_dat == 2'b10) next_state = READ_WAIT;\n                else next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = WRITE_CRC;\n                else next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111) next_state = WRITE_BUSY;\n                else next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0) next_state = IDLE;\n                else next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0) next_state = READ_DAT;\n                else next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = IDLE;\n                else next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        end\n    end\n\n    // FSM_SEQ submodule\n    always @(posedge sd_clk) begin\n        if (rst) state <= IDLE;\n        else state <= next_state;\n    end\n\n    // FSM_OUT submodule\n    always_comb begin\n        case (state)\n            IDLE: begin\n                DAT_oe_o = 1;\n                DAT_dat_o = 0;\n                rd = 0;\n                we = 0;\n                busy_n = 1;\n                transm_complete = 0;\n                crc_ok = 0;\n                busy_int = 0;\n                data_send_index = 0;\n                out_buff_ptr = 0;\n                in_buff_ptr = 0;\n            end\n            WRITE_DAT: begin\n                DAT_oe_o = 0;\n                DAT_dat_o = write_buf_0[data_send_index];\n                rd = 0;\n                we = 1;\n                busy_n = 0;\n                transm_complete = 0;\n                crc_ok = 0;\n                busy_int = 0;\n                data_send_index = data_send_index + 1;\n                if (data_send_index == SD_BUS_W) begin\n                    data_send_index = 0;\n                    out_buff_ptr = out_buff_ptr + 1;\n                end\n            end\n            WRITE_CRC: begin\n                DAT_oe_o = 0;\n                DAT_dat_o = crc_out[15:8];\n                rd = 0;\n                we = 1;\n                busy_n = 0;\n                transm_complete = 0;\n                crc_ok = 0;\n                busy_int = 0;\n                data_send_index = 0;\n                out_buff_ptr = out_buff_ptr + 1;\n            end\n            WRITE_BUSY: begin\n                DAT_oe_o = 0;\n                DAT_dat_o = 0;\n                rd = 0;\n                we = 0;\n                busy_n = 0;\n                transm_complete = 1;\n                crc_ok = 0;\n                busy_int = 1;\n                data_send_index = 0;\n                out_buff_ptr = out_buff_ptr + 1;\n            end\n            READ_WAIT: begin\n                DAT_oe_o = 0;\n                DAT_dat_o = 0;\n                rd = 1;\n                we = 0;\n                busy_n = 0;\n                transm_complete = 0;\n                crc_ok = 0;\n                busy_int = 0;\n                data_send_index = 0;\n                out_buff_ptr = out_buff_ptr + 1;\n            end\n            READ_DAT: begin\n                DAT_oe_o = 0;\n                DAT_dat_o = DAR_dat_i;\n                rd = 1;\n                we = 0;\n                busy_n = 0;\n                transm_complete = 0;\n                crc_ok = 0;\n                busy_int = 0;\n                data_send_index = 0;\n                out_buff_ptr = out_buff_ptr + 1;\n                if (transf_cnt == SD_BUS_W) begin\n                    crc_ok = 1;\n                    if (SD_BUS_W == 4) begin\n                        for (int i = 0; i < 4; i++) begin\n                            if (crc_out[i*16+15: i*16] != DAR_dat_i[i*8+7: i*8]) crc_ok = 0;\n                        end\n                    end\n                    else if (SD_BUS_W == 1) begin\n                        if (crc_out[15:8] != DAR_dat_i[7:0]) crc_ok = 0;\n                    end\n                    transm_complete = 1;\n                end\n                transf_cnt = transf_cnt + 1;\n            end\n            default: begin\n                DAT_oe_o = 1;\n                DAT_dat_o = 0;\n                rd = 0;\n                we = 0;\n                busy_n = 1;\n                transm_complete = 0;\n                crc_ok = 0;\n                busy_int = 0;\n                data_send_index = 0;\n                out_buff_ptr = 0;\n                in_buff_ptr = 0;\n            end\n        end\n    end\n\n    // Assign outputs\n    assign data_out = sd_data_out;\n    assign DAT_dat_o = DAT_dat_o;\n    assign busy_n = busy_n;\n    assign transm_complete = transm_complete;\n    assign crc_ok = crc_ok;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 5, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Sub-modules\n    sd_crc_16 crc_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end\n        else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @* begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01) begin\n                    next_state = WRITE_DAT;\n                end\n                else if (start_dat == 2'b10) begin\n                    next_state = READ_WAIT;\n                end\n                else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = WRITE_CRC;\n                end\n                else begin\n                    next_state = WRITE_DAT;\n                end\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111) begin\n                    next_state = WRITE_BUSY;\n                end\n                else begin\n                    next_state = WRITE_CRC;\n                end\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0) begin\n                    next_state = IDLE;\n                end\n                else begin\n                    next_state = WRITE_BUSY;\n                end\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0) begin\n                    next_state = READ_DAT;\n                end\n                else begin\n                    next_state = READ_WAIT;\n                end\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = IDLE;\n                end\n                else begin\n                    next_state = READ_DAT;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            state <= IDLE;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @* begin\n        case (state)\n            IDLE: begin\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 0;\n                we <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n            WRITE_DAT: begin\n                DAT_oe_o <= 1;\n                DAT_dat_o <= write_buf_0;\n                rd <= 0;\n                we <= 1;\n                crc_en <= 1;\n                crc_rst <= 0;\n                transf_cnt <= transf_cnt + 1;\n                last_din <= write_buf_0[3:0];\n                crc_c <= crc_c + 1;\n                crc_in <= write_buf_0[SD_BUS_W-1:SD_BUS_W-4];\n                crc_status <= crc_status + 1;\n                crc_s <= crc_s + 1;\n                transm_complete <= 0;\n                busy_n <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index + 1;\n                out_buff_ptr <= out_buff_ptr + 1;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            WRITE_CRC: begin\n                DAT_oe_o <= 1;\n                DAT_dat_o <= crc_out;\n                rd <= 0;\n                we <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            WRITE_BUSY: begin\n                DAT_oe_o <= 1;\n                DAT_dat_o <= 0;\n                rd <= 0;\n                we <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 1;\n                busy_n <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            READ_WAIT: begin\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 1;\n                we <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n            READ_DAT: begin\n                DAT_oe_o <= 0;\n                DAT_dat_o <= DAR_dat_i;\n                rd <= 1;\n                we <= 0;\n                crc_en <= 1;\n                crc_rst <= 0;\n                transf_cnt <= transf_cnt + 1;\n                last_din <= DAR_dat_i[3:0];\n                crc_c <= crc_c + 1;\n                crc_in <= DAR_dat_i[SD_BUS_W-1:SD_BUS_W-4];\n                crc_status <= crc_status + 1;\n                crc_s <= crc_s + 1;\n                transm_complete <= 0;\n                busy_n <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index + 1;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr + 1;\n            end\n            default: begin\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 0;\n                we <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n        end\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end\n        else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT) begin\n                q_start_bit <= 0;\n            end\n            else begin\n                q_start_bit <= 1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 6, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Sub-modules\n    sd_crc_16 crc_16_gen(\n       .BITVAL(crc_in),\n       .Enable(crc_en),\n       .CLK(sd_clk),\n       .RST(crc_rst),\n       .CRC(crc_out)\n    );\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always_comb begin\n        case (state)\n            6'd0: // IDLE\n                next_state = (start_dat == 2'b01)? 6'd1 : (start_dat == 2'b10)? 6'd2 : 6'd0;\n            6'd1: // WRITE_DAT\n                next_state = (transf_cnt == SD_BUS_W)? 6'd2 : 6'd1;\n            6'd2: // WRITE_CRC\n                next_state = (crc_status == 3'b111)? 6'd3 : 6'd2;\n            6'd3: // WRITE_BUSY\n                next_state = (busy_int == 1'b0)? 6'd0 : 6'd3;\n            6'd4: // READ_WAIT\n                next_state = (DAR_dat_i[0] == 1'b0)? 6'd5 : 6'd4;\n            6'd5: // READ_DAT\n                next_state = (transf_cnt == SD_BUS_W)? 6'd0 : 6'd5;\n            default: next_state = 6'd0;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            state <= 6'd0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always_comb begin\n        case (state)\n            6'd0: // IDLE\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b1;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b0;\n                crc_rst = 1'b1;\n                crc_in = 0;\n                crc_status = 3'b000;\n                busy_int = 1'b0;\n                data_send_index = 3'b000;\n                out_buff_ptr = 2'b00;\n                in_buff_ptr = 2'b00;\n                sd_data_out = 0;\n                write_buf_0 = 0;\n                write_buf_1 = 0;\n            6'd1: // WRITE_DAT\n                rd = 1'b0;\n                we = 1'b1;\n                DAT_oe_o = 1'b1;\n                DAT_dat_o = temp_in;\n                busy_n = 1'b0;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b1;\n                crc_rst = 1'b0;\n                crc_in = temp_in;\n                crc_status = 3'b000;\n                busy_int = 1'b0;\n                data_send_index = 3'b000;\n                out_buff_ptr = 2'b00;\n                in_buff_ptr = 2'b00;\n                sd_data_out = 0;\n                write_buf_0 = 0;\n                write_buf_1 = 0;\n            6'd2: // WRITE_CRC\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b0;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b1;\n                crc_rst = 1'b0;\n                crc_in = DAR_dat_i;\n                crc_status = 3'b111;\n                busy_int = 1'b0;\n                data_send_index = 3'b000;\n                out_buff_ptr = 2'b00;\n                in_buff_ptr = 2'b00;\n                sd_data_out = 0;\n                write_buf_0 = 0;\n                write_buf_1 = 0;\n            6'd3: // WRITE_BUSY\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b0;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b0;\n                crc_rst = 1'b1;\n                crc_in = 0;\n                crc_status = 3'b000;\n                busy_int = 1'b1;\n                data_send_index = 3'b000;\n                out_buff_ptr = 2'b00;\n                in_buff_ptr = 2'b00;\n                sd_data_out = 0;\n                write_buf_0 = 0;\n                write_buf_1 = 0;\n            6'd4: // READ_WAIT\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b1;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b0;\n                crc_rst = 1'b1;\n                crc_in = 0;\n                crc_status = 3'b000;\n                busy_int = 1'b0;\n                data_send_index = 3'b000;\n                out_buff_ptr = 2'b00;\n                in_buff_ptr = 2'b00;\n                sd_data_out = 0;\n                write_buf_0 = 0;\n                write_buf_1 = 0;\n            6'd5: // READ_DAT\n                rd = 1'b1;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b0;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b0;\n                crc_rst = 1'b1;\n                crc_in = DAR_dat_i;\n                crc_status = 3'b000;\n                busy_int = 1'b0;\n                data_send_index = 3'b000;\n                out_buff_ptr = 2'b00;\n                in_buff_ptr = 2'b00;\n                sd_data_out = 0;\n                write_buf_0 = 0;\n                write_buf_1 = 0;\n            default:\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b1;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b0;\n                crc_rst = 1'b1;\n                crc_in = 0;\n                crc_status = 3'b000;\n                busy_int = 1'b0;\n                data_send_index = 3'b000;\n                out_buff_ptr = 2'b00;\n                in_buff_ptr = 2'b00;\n                sd_data_out = 0;\n                write_buf_0 = 0;\n                write_buf_1 = 0;\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else begin\n            if (state == 6'd4 && DAR_dat_i[0] == 1'b0) begin\n                q_start_bit <= 1'b0;\n            end else begin\n                q_start_bit <= 1'b1;\n            end\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            state <= 6'd0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always_comb begin\n        //...\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 7, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Sub-modules\n    sd_crc_16 crc_16_gen(\n       .BITVAL(crc_in),\n       .Enable(crc_en),\n       .CLK(sd_clk),\n       .RST(crc_rst),\n       .CRC(crc_out)\n    );\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always_comb begin\n        case (state)\n            6'd0: // IDLE\n                next_state = (start_dat == 2'b01)? 6'd1 : (start_dat == 2'b10)? 6'd2 : 6'd0;\n            6'd1: // WRITE_DAT\n                next_state = (transf_cnt == SD_BUS_W)? 6'd2 : 6'd1;\n            6'd2: // WRITE_CRC\n                next_state = (crc_status == 3'b111)? 6'd3 : 6'd2;\n            6'd3: // WRITE_BUSY\n                next_state = (busy_int == 1'b0)? 6'd0 : 6'd3;\n            6'd4: // READ_WAIT\n                next_state = (DAT_dat_i[0] == 1'b0)? 6'd5 : 6'd4;\n            6'd5: // READ_DAT\n                next_state = (transf_cnt == SD_BUS_W)? 6'd0 : 6'd5;\n            default: next_state = 6'd0;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) state <= 6'd0;\n        else state <= next_state;\n    end\n\n    // FSM_OUT\n    always_comb begin\n        case (state)\n            6'd0: // IDLE\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b1;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b0;\n                crc_rst = 1'b1;\n                crc_in = 0;\n                temp_in = 0;\n                transf_cnt = 0;\n                crc_status = 3'b000;\n                busy_int = 1'b0;\n                data_send_index = 3'b000;\n                out_buff_ptr = 2'b00;\n                in_buff_ptr = 2'b00;\n                sd_data_out = 0;\n            6'd1: // WRITE_DAT\n                rd = 1'b0;\n                we = 1'b1;\n                DAT_oe_o = 1'b1;\n                DAT_dat_o = temp_in;\n                busy_n = 1'b0;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b1;\n                crc_rst = 1'b0;\n                crc_in = temp_in;\n                temp_in = 0;\n                transf_cnt = transf_cnt + 1;\n                crc_status = crc_status + 1;\n                busy_int = 1'b0;\n                data_send_index = data_send_index + 1;\n                out_buff_ptr = out_buff_ptr + 1;\n                in_buff_ptr = in_buff_ptr + 1;\n                sd_data_out = sd_data_out + 1;\n            6'd2: // WRITE_CRC\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b0;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b1;\n                crc_rst = 1'b0;\n                crc_in = crc_out;\n                temp_in = 0;\n                transf_cnt = transf_cnt + 1;\n                crc_status = crc_status + 1;\n                busy_int = 1'b0;\n                data_send_index = data_send_index + 1;\n                out_buff_ptr = out_buff_ptr + 1;\n                in_buff_ptr = in_buff_ptr + 1;\n                sd_data_out = sd_data_out + 1;\n            6'd3: // WRITE_BUSY\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b0;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b0;\n                crc_rst = 1'b1;\n                crc_in = 0;\n                temp_in = 0;\n                transf_cnt = transf_cnt + 1;\n                crc_status = crc_status + 1;\n                busy_int = 1'b1;\n                data_send_index = data_send_index + 1;\n                out_buff_ptr = out_buff_ptr + 1;\n                in_buff_ptr = in_buff_ptr + 1;\n                sd_data_out = sd_data_out + 1;\n            6'd4: // READ_WAIT\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b1;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b0;\n                crc_rst = 1'b1;\n                crc_in = 0;\n                temp_in = 0;\n                transf_cnt = 0;\n                crc_status = 3'b000;\n                busy_int = 1'b0;\n                data_send_index = 3'b000;\n                out_buff_ptr = 2'b00;\n                in_buff_ptr = 2'b00;\n                sd_data_out = 0;\n            6'd5: // READ_DAT\n                rd = 1'b1;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b0;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b1;\n                crc_rst = 1'b0;\n                crc_in = DAR_dat_i;\n                temp_in = DAR_dat_i;\n                transf_cnt = transf_cnt + 1;\n                crc_status = crc_status + 1;\n                busy_int = 1'b0;\n                data_send_index = data_send_index + 1;\n                out_buff_ptr = out_buff_ptr + 1;\n                in_buff_ptr = in_buff_ptr + 1;\n                sd_data_out = sd_data_out + 1;\n            default:\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b1;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                crc_en = 1'b0;\n                crc_rst = 1'b1;\n                crc_in = 0;\n                temp_in = 0;\n                transf_cnt = 0;\n                crc_status = 3'b000;\n                busy_int = 1'b0;\n                data_send_index = 3'b000;\n                out_buff_ptr = 2'b00;\n                in_buff_ptr = 2'b00;\n                sd_data_out = 0;\n        endcase\n    end\n\n    // CRC_16_GEN\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            crc_in <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            crc_out <= 0;\n        end else begin\n            if (crc_en) begin\n                crc_out <= {crc_out[15:8], crc_in};\n                crc_in <= crc_in << 1;\n                if (crc_in[SD_BUS_W-1]) begin\n                    crc_in <= crc_in ^ crc_out;\n                end\n            end\n        end\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) q_start_bit <= 1;\n        else if (state == 6'd4) begin\n            if (DAT_dat_i[0] == 1'b0) q_start_bit <= 1;\n            else q_start_bit <= 0;\n        end\n    end\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 8, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // External signals\n    parameter SD_BUS_W = 4;\n    parameter BIT_BLOCK = 512;\n    parameter CRC_OFF = 16;\n    parameter BIT_BLOCK_REC = 512;\n    parameter BIT_CRC_CYCLE = 16;\n    parameter LITLE_ENDIAN = 0;\n    parameter BIG_ENDIAN = 1;\n    parameter SD_BUS_WIDTH_1 = 1;\n    parameter SD_BUS_WIDTH_4 = 4;\n\n    // Sub-modules\n    sd_crc_16 crc_16_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end\n        else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always_comb begin\n        case (state)\n            6'd0: begin\n                if (start_dat == 2'b01) begin\n                    next_state = 6'd1;\n                end\n                else if (start_dat == 2'b10) begin\n                    next_state = 6'd2;\n                end\n                else if (start_dat == 2'b11) begin\n                    next_state = 6'd3;\n                end\n                else begin\n                    next_state = 6'd0;\n                end\n            end\n            6'd1: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = 6'd4;\n                end\n                else begin\n                    next_state = 6'd1;\n                end\n            end\n            6'd2: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = 6'd5;\n                end\n                else begin\n                    next_state = 6'd2;\n                end\n            end\n            6'd3: begin\n                next_state = 6'd0;\n            end\n            6'd4: begin\n                if (crc_status == 3'b111) begin\n                    next_state = 6'd6;\n                end\n                else begin\n                    next_state = 6'd4;\n                end\n            end\n            6'd5: begin\n                if (crc_status == 3'b111) begin\n                    next_state = 6'd7;\n                end\n                else begin\n                    next_state = 6'd5;\n                end\n            end\n            6'd6: begin\n                if (busy_int == 0) begin\n                    next_state = 6'd0;\n                end\n                else begin\n                    next_state = 6'd6;\n                end\n            end\n            6'd7: begin\n                if (busy_int == 0) begin\n                    next_state = 6'd0;\n                end\n                else begin\n                    next_state = 6'd7;\n                end\n            end\n            default: begin\n                next_state = 6'd0;\n            end\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            state <= 6'd0;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk) begin\n        case (state)\n            6'd0: begin\n                write_buf_0 <= 32'd0;\n                write_buf_1 <= 32'd0;\n                DAT_oe_o <= 1'b0;\n                crc_en <= 1'b0;\n                crc_rst <= 1'b1;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n            6'd1: begin\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                DAT_oe_o <= 1'b0;\n                crc_en <= 1'b0;\n                crc_rst <= 1'b1;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n            6'd2: begin\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                DAT_oe_o <= 1'b0;\n                crc_en <= 1'b0;\n                crc_rst <= 1'b1;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n            6'd3: begin\n                write_buf_0 <= 32'd0;\n                write_buf_1 <= 32'd0;\n                DAT_oe_o <= 1'b0;\n                crc_en <= 1'b0;\n                crc_rst <= 1'b1;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n            6'd4: begin\n                DAT_oe_o <= 1'b1;\n                crc_en <= 1'b1;\n                crc_rst <= 1'b0;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b0;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n            6'd5: begin\n                DAT_oe_o <= 1'b1;\n                crc_en <= 1'b1;\n                crc_rst <= 1'b0;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b0;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n            6'd6: begin\n                DAT_oe_o <= 1'b1;\n                crc_en <= 1'b1;\n                crc_rst <= 1'b0;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b0;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n            6'd7: begin\n                DAT_oe_o <= 1'b1;\n                crc_en <= 1'b1;\n                crc_rst <= 1'b0;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b0;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n            default: begin\n                DAT_oe_o <= 1'b0;\n                crc_en <= 1'b0;\n                crc_rst <= 1'b1;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk) begin\n        case (state)\n            6'd0: begin\n                if (start_dat == 2'b01) begin\n                    write_buf_0 <= data_in;\n                    write_buf_1 <= data_in;\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    write_buf_1 <= data_in;\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else if (start_dat == 2'b11) begin\n                    write_buf_0 <= 32'd0;\n                    write_buf_1 <= 32'd0;\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    write_buf_0 <= 32'd0;\n                    write_buf_1 <= 32'd0;\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            6'd1: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    DAT_oe_o <= 1'b1;\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b0;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            6'd2: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    DAT_oe_o <= 1'b1;\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b0;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            6'd3: begin\n                DAT_oe_o <= 1'b0;\n                crc_en <= 1'b0;\n                crc_rst <= 1'b1;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n            6'd4: begin\n                if (crc_status == 3'b111) begin\n                    DAT_oe_o <= 1'b1;\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b0;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            6'd5: begin\n                if (crc_status == 3'b111) begin\n                    DAT_oe_o <= 1'b1;\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b0;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            6'd6: begin\n                if (busy_int == 0) begin\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    DAT_oe_o <= 1'b1;\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b0;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            6'd7: begin\n                if (busy_int == 0) begin\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    DAT_oe_o <= 1'b1;\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b0;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            default: begin\n                DAT_oe_o <= 1'b0;\n                crc_en <= 1'b0;\n                crc_rst <= 1'b1;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end\n        else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT) begin\n                q_start_bit <= 1'b0;\n            end\n            else begin\n                q_start_bit <= 1'b1;\n            end\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk) begin\n        case (state)\n            6'd0: begin\n                if (start_dat == 2'b01) begin\n                    write_buf_0 <= data_in;\n                    write_buf_1 <= data_in;\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else if (start_dat == 2'b10) begin\n                    write_buf_0 <= data_in;\n                    write_buf_1 <= data_in;\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else if (start_dat == 2'b11) begin\n                    write_buf_0 <= 32'd0;\n                    write_buf_1 <= 32'd0;\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    write_buf_0 <= 32'd0;\n                    write_buf_1 <= 32'd0;\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            6'd1: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    DAT_oe_o <= 1'b1;\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b0;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            6'd2: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    DAT_oe_o <= 1'b1;\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b0;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            6'd3: begin\n                DAT_oe_o <= 1'b0;\n                crc_en <= 1'b0;\n                crc_rst <= 1'b1;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n            6'd4: begin\n                if (crc_status == 3'b111) begin\n                    DAT_oe_o <= 1'b1;\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b0;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            6'd5: begin\n                if (crc_status == 3'b111) begin\n                    DAT_oe_o <= 1'b1;\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b0;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            6'd6: begin\n                if (busy_int == 0) begin\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    DAT_oe_o <= 1'b1;\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b0;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            6'd7: begin\n                if (busy_int == 0) begin\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n                else begin\n                    DAT_oe_o <= 1'b1;\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'd0;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b0;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                end\n            end\n            default: begin\n                DAT_oe_o <= 1'b0;\n                crc_en <= 1'b0;\n                crc_rst <= 1'b1;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                busy_int <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n        endcase\n    end\n\n    // Assign output signals\n    assign rd = state == 6'd1 || state == 6'd2 || state == 6'd3 || state == 6'd4 || state == 6'd5 || state == 6'd6 || state == 6'd7;\n    assign data_out = state == 6'd1 || state == 6'd2 || state == 6'd3 || state == 6'd4 || state == 6'd5 || state == 6'd6 || state == 6'd7 ? sd_data_out : 32'd0;\n    assign we = state == 6'd1 || state == 6'd2 || state == 6'd3 || state == 6'd4 || state == 6'd5 || state == 6'd6 || state == 6'd7 ? 1'b0 : 1'b0;\n    assign DAT_oe_o = state == 6'd1 || state == 6'd2 || state == 6'd3 || state == 6'd4 || state == 6'd5 || state == 6'd6 || state == 6'd7 ? DAT_oe_o : 1'b0;\n    assign DAT_dat_o = state == 6'd1 || state == 6'd2 || state == 6'd3 || state == 6'd4 || state == 6'd5 || state == 6'd6 || state == 6'd7 ? DAT_dat_o : 32'd0;\n    assign busy_n = state == 6'd6 || state == 6'd7 ? 1'b0 : 1'b1;\n    assign transm_complete = state == 6'd6 || state == 6'd7 ? 1'b1 : 1'b0;\n    assign crc_ok = state == 6'd6 || state == 6'd7 ? crc_ok : 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 9, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Sub-modules\n    sd_crc_16 crc_16_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end\n        else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always_comb begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01) next_state = WRITE_DAT;\n                else if (start_dat == 2'b10) next_state = READ_WAIT;\n                else next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = WRITE_CRC;\n                else next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111) next_state = WRITE_BUSY;\n                else next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0) next_state = IDLE;\n                else next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0) next_state = READ_DAT;\n                else next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = IDLE;\n                else next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) state <= IDLE;\n        else state <= next_state;\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk) begin\n        case (state)\n            IDLE: begin\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n            WRITE_DAT: begin\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                DAT_oe_o <= 1;\n                crc_en <= 1;\n                crc_rst <= 0;\n                transf_cnt <= transf_cnt + 1;\n                rd <= 0;\n                last_din <= write_buf_0[3:0];\n                crc_c <= crc_c + 1;\n                crc_in <= write_buf_0[SD_BUS_W-1:SD_BUS_W-4];\n                DAT_dat_o <= write_buf_0[SD_BUS_W-1:SD_BUS_W-4];\n                if (transf_cnt == SD_BUS_W) begin\n                    crc_status <= crc_status - 1;\n                    crc_s <= crc_s + 1;\n                end\n                if (transf_cnt == SD_BUS_W-1) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-1:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-1:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-2) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-5:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-5:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-3) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-9:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-9:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-4) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-13:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-13:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-5) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-17:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-17:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-6) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-21:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-21:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-7) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-25:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-25:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-8) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-29:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-29:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-9) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-33:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-33:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-10) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-37:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-37:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-11) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-41:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-41:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-12) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-45:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-45:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-13) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-49:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-49:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-14) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-53:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-53:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-15) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-57:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-57:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-16) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-61:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-61:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-17) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-65:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-65:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-18) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-69:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-69:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-19) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-73:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-73:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-20) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-77:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-77:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-21) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-81:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-81:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-22) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-85:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-85:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-23) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-89:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-89:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-24) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-93:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-93:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-25) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-97:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-97:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-26) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-101:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-101:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-27) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-105:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-105:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-28) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-109:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-109:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-29) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-113:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-113:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-30) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-117:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-117:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-31) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-121:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-121:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-1:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-1:SD_BUS_W-4];\n                end\n            end\n            WRITE_CRC: begin\n                crc_status <= crc_out;\n                crc_s <= crc_s + 1;\n                if (crc_status == 3'b111) next_state = WRITE_BUSY;\n                else next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0) next_state = IDLE;\n                else next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0) next_state = READ_DAT;\n                else next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = IDLE;\n                else next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        end\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk) begin\n        if (!DAT_dat_i[0] & state == READ_WAIT) q_start_bit <= 0;\n        else q_start_bit <= 1;\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) state <= IDLE;\n        else state <= next_state;\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk) begin\n        case (state)\n            IDLE: begin\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n            WRITE_DAT: begin\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                DAT_oe_o <= 1;\n                crc_en <= 1;\n                crc_rst <= 0;\n                transf_cnt <= transf_cnt + 1;\n                rd <= 0;\n                last_din <= write_buf_0[3:0];\n                crc_c <= crc_c + 1;\n                crc_in <= write_buf_0[SD_BUS_W-1:SD_BUS_W-4];\n                DAT_dat_o <= write_buf_0[SD_BUS_W-1:SD_BUS_W-4];\n                if (transf_cnt == SD_BUS_W) begin\n                    crc_status <= crc_status - 1;\n                    crc_s <= crc_s + 1;\n                end\n                if (transf_cnt == SD_BUS_W-1) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-1:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-1:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-2) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-5:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-5:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-3) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-9:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-9:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-4) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-13:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-13:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-5) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-17:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-17:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-6) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-21:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-21:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-7) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-25:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-25:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-8) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-29:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-29:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-9) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-33:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-33:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-10) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-37:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-37:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-11) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-41:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-41:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-12) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-45:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-45:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-13) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-49:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-49:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-14) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-53:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-53:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-15) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-57:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-57:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-16) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-61:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-61:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-17) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-65:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-65:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-18) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-69:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-69:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-19) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-73:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-73:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-20) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-77:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-77:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-21) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-81:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-81:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-22) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-85:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-85:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-23) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-89:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-89:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-24) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-93:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-93:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-25) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-97:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-97:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-26) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-101:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-101:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-27) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-105:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-105:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-28) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-109:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-109:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-29) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-113:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-113:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-30) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-117:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-117:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W-31) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-121:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-121:SD_BUS_W-4];\n                end\n                if (transf_cnt == SD_BUS_W) begin\n                    DAT_dat_o <= write_buf_1[SD_BUS_W-1:SD_BUS_W-4];\n                    crc_in <= write_buf_1[SD_BUS_W-1:SD_BUS_W-4];\n                end\n            end\n            WRITE_CRC: begin\n                crc_status <= crc_out;\n                crc_s <= crc_s + 1;\n                if (crc_status == 3'b111) next_state = WRITE_BUSY;\n                else next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0) next_state = IDLE;\n                else next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0) next_state = READ_DAT;\n                else next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = IDLE;\n                else next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        end\n    end\n\n    // Assign outputs\n    DAT_dat_o <= DAT_dat_o;\n    DAT_oe_o <= DAT_oe_o;\n    rd <= rd;\n    we <= we;\n    data_out <= data_out;\n    busy_n <= busy_n;\n    transm_complete <= transm_complete;\n    crc_ok <= crc_ok;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 10, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Define parameters\n    parameter SD_BUS_W = 4;\n    parameter BIT_BLOCK = 512;\n    parameter CRC_OFF = 16;\n    parameter BIT_BLOCK_REC = 512;\n    parameter BIT_CRC_CYCLE = 16;\n    parameter LITTLE_ENDIAN = 1;\n    parameter BIG_ENDIAN = 0;\n    parameter SD_BUS_WIDTH_1 = 1;\n    parameter SD_BUS_WIDTH_4 = 4;\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC generation block\n    sd_crc_16 crc_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK synchronization block\n    always @(posedge sd_clk)\n    begin\n        if (rst)\n            ack_transfer_int <= 0;\n        else\n            ack_transfer_int <= ack_transfer;\n    end\n\n    // FSM combo block\n    always @(posedge sd_clk)\n    begin\n        if (rst)\n            state <= 6'b000000;\n        else\n            state <= next_state;\n    end\n\n    // FSM seq block\n    always @(posedge sd_clk)\n    begin\n        if (rst)\n            next_state <= 6'b000000;\n        else\n            next_state <= FSM_COMBO(state, start_dat, transf_cnt, crc_status, busy_int, ack_transfer_int, q_start_bit, last_din, crc_s, data_send_index);\n    end\n\n    // FSM out block\n    always @(posedge sd_clk)\n    begin\n        if (rst)\n        begin\n            write_buf_0 <= 32'b0;\n            write_buf_1 <= 32'b0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 11'b0;\n            rd <= 0;\n            last_din <= 4'b0;\n            crc_c <= 5'b0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b000;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 3'b0;\n            out_buff_ptr <= 2'b00;\n            in_buff_ptr <= 2'b00;\n        end\n        else\n        begin\n            case (state)\n                6'b000000: // IDLE\n                    if (start_dat == 2'b01)\n                        next_state = 6'b000001; // WRITE_DAT\n                    else if (start_dat == 2'b10)\n                        next_state = 6'b000010; // READ_WAIT\n                    else\n                        next_state = 6'b000000;\n                6'b000001: // WRITE_DAT\n                    begin\n                        if (transf_cnt == SD_BUS_W)\n                            next_state = 6'b000010; // WRITE_CRC\n                        else\n                            next_state = 6'b000001;\n                    end\n                6'b000010: // WRITE_CRC\n                    begin\n                        if (crc_status == 3'b100)\n                            next_state = 6'b000011; // WRITE_BUSY\n                        else\n                            next_state = 6'b000010;\n                    end\n                6'b000011: // WRITE_BUSY\n                    begin\n                        if (busy_int == 0)\n                            next_state = 6'b000000; // IDLE\n                        else\n                            next_state = 6'b000011;\n                    end\n                6'b000100: // READ_WAIT\n                    begin\n                        if (DAT_dat_i[0] == 0)\n                            next_state = 6'b000101; // READ_DAT\n                        else\n                            next_state = 6'b000100;\n                    end\n                6'b000101: // READ_DAT\n                    begin\n                        if (transf_cnt == SD_BUS_W)\n                            next_state = 6'b000000; // IDLE\n                        else\n                            next_state = 6'b000101;\n                    end\n                default: // Default to IDLE\n                    next_state = 6'b000000;\n            end\n        end\n    end\n\n    // FSM out logic\n    always @(posedge sd_clk)\n    begin\n        case (state)\n            6'b000000: // IDLE\n                begin\n                    DAT_oe_o <= 0;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= 11'b0;\n                    rd <= 0;\n                    last_din <= 4'b0;\n                    crc_c <= 5'b0;\n                    crc_in <= 0;\n                    DAT_dat_o <= 0;\n                    crc_status <= 3'b000;\n                    busy_n <= 1;\n                    we <= 0;\n                    data_out <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= 3'b0;\n                    out_buff_ptr <= 2'b00;\n                    in_buff_ptr <= 2'b00;\n                end\n            6'b000001: // WRITE_DAT\n                begin\n                    DAT_oe_o <= 1;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= transf_cnt + 1;\n                    rd <= 0;\n                    last_din <= data_in[31:28];\n                    crc_c <= crc_c + 1;\n                    crc_in <= data_in[31:16];\n                    DAT_dat_o <= data_in[31:0];\n                    crc_status <= crc_status + 1;\n                    busy_n <= 0;\n                    we <= 1;\n                    data_out <= write_buf_0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= data_send_index + 1;\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    in_buff_ptr <= in_buff_ptr + 1;\n                end\n            6'b000010: // WRITE_CRC\n                begin\n                    DAT_oe_o <= 1;\n                    crc_en <= 1;\n                    crc_rst <= 0;\n                    transf_cnt <= transf_cnt + 1;\n                    rd <= 0;\n                    last_din <= data_in[31:28];\n                    crc_c <= crc_c + 1;\n                    crc_in <= data_in[31:16];\n                    DAT_dat_o <= data_in[31:0];\n                    crc_status <= crc_status + 1;\n                    busy_n <= 0;\n                    we <= 1;\n                    data_out <= write_buf_0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= data_send_index + 1;\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    in_buff_ptr <= in_buff_ptr + 1;\n                end\n            6'b000011: // WRITE_BUSY\n                begin\n                    DAT_oe_o <= 1;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= transf_cnt + 1;\n                    rd <= 0;\n                    last_din <= data_in[31:28];\n                    crc_c <= crc_c + 1;\n                    crc_in <= data_in[31:16];\n                    DAT_dat_o <= data_in[31:0];\n                    crc_status <= crc_status + 1;\n                    busy_n <= 0;\n                    we <= 1;\n                    data_out <= write_buf_0;\n                    crc_ok <= 0;\n                    busy_int <= 1;\n                    data_send_index <= data_send_index + 1;\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    in_buff_ptr <= in_buff_ptr + 1;\n                end\n            6'b000100: // READ_WAIT\n                begin\n                    DAT_oe_o <= 0;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= transf_cnt + 1;\n                    rd <= 1;\n                    last_din <= DAR_dat_i[31:28];\n                    crc_c <= crc_c + 1;\n                    crc_in <= DAR_dat_i[31:16];\n                    DAT_dat_o <= DAR_dat_i[31:0];\n                    crc_status <= crc_status + 1;\n                    busy_n <= 1;\n                    we <= 0;\n                    data_out <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= data_send_index + 1;\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    in_buff_ptr <= in_buff_ptr + 1;\n                end\n            6'b000101: // READ_DAT\n                begin\n                    DAT_oe_o <= 1;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= transf_cnt + 1;\n                    rd <= 1;\n                    last_din <= DAR_dat_i[31:28];\n                    crc_c <= crc_c + 1;\n                    crc_in <= DAR_dat_i[31:16];\n                    DAT_dat_o <= DAR_dat_i[31:0];\n                    crc_status <= crc_status + 1;\n                    busy_n <= 0;\n                    we <= 1;\n                    data_out <= DAR_dat_i;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= data_send_index + 1;\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    in_buff_ptr <= in_buff_ptr + 1;\n                end\n            default: // Default to IDLE\n                begin\n                    DAT_oe_o <= 0;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    transf_cnt <= 11'b0;\n                    rd <= 0;\n                    last_din <= 4'b0;\n                    crc_c <= 5'b0;\n                    crc_in <= 0;\n                    DAT_dat_o <= 0;\n                    crc_status <= 3'b000;\n                    busy_n <= 1;\n                    we <= 0;\n                    data_out <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= 3'b0;\n                    out_buff_ptr <= 2'b00;\n                    in_buff_ptr <= 2'b00;\n                end\n        end\n    end\n\n    // START_SYNC block\n    always @(posedge sd_clk)\n    begin\n        if (rst)\n            q_start_bit <= 1;\n        else\n            if (state == 6'b000100 && DAT_dat_i[0] == 0)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n    end\n\n    // FSM out signals\n    assign DAT_dat_o = (state == 6'b000001 || state == 6'b000010 || state == 6'b000011) ? write_buf_0 : DAR_dat_i;\n    assign we = (state == 6'b000001 || state == 6'b000010 || state == 6'b000011) ? 1 : 0;\n    assign rd = (state == 6'b000100 || state == 6'b000101) ? 1 : 0;\n    assign busy_n = (state == 6'b000011) ? 0 : 1;\n    assign transm_complete = (state == 6'b000011) ? 1 : 0;\n    assign crc_ok = (state == 6'b000011) ? (crc_status == 3'b100) : 0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 11, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Sub-modules\n    sd_crc_16 crc_16_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end\n        else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always_comb begin\n        case (state)\n            6'd0: // IDLE\n                if (start_dat == 2'b01) next_state = 6'd1;\n                else if (start_dat == 2'b10) next_state = 6'd2;\n                else next_state = 6'd0;\n            6'd1: // WRITE_DAT\n                if (transf_cnt == SD_BUS_W) next_state = 6'd3;\n                else next_state = 6'd1;\n            6'd2: // READ_WAIT\n                if (DAT_dat_i[0] == 0) next_state = 6'd4;\n                else next_state = 6'd2;\n            6'd3: // WRITE_CRC\n                if (crc_status == 3'b111) next_state = 6'd5;\n                else next_state = 6'd3;\n            6'd4: // READ_DAT\n                if (transf_cnt == SD_BUS_W) next_state = 6'd0;\n                else next_state = 6'd4;\n            6'd5: // WRITE_BUSY\n                if (busy_int == 0) next_state = 6'd0;\n                else next_state = 6'd5;\n            default: next_state = 6'd0;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) state <= 6'd0;\n        else state <= next_state;\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk) begin\n        case (state)\n            6'd0: // IDLE\n                crc_en <= 0;\n                crc_rst <= 1;\n                write_buf_0 <= 32'd0;\n                write_buf_1 <= 32'd0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 0;\n                we <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            6'd1: // WRITE_DAT\n                crc_en <= 1;\n                crc_rst <= 0;\n                write_buf_0 <= data_in;\n                write_buf_1 <= 32'd0;\n                DAT_oe_o <= 1;\n                DAT_dat_o <= write_buf_0[SD_BUS_W-1:SD_BUS_W-SD_BUS_W];\n                rd <= 0;\n                we <= 1;\n                last_din <= write_buf_0[SD_BUS_W-1:SD_BUS_W-SD_BUS_W];\n                crc_c <= 0;\n                crc_in <= last_din;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            6'd2: // READ_WAIT\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 1;\n                we <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            6'd3: // WRITE_CRC\n                DAT_oe_o <= 1;\n                DAT_dat_o <= crc_out;\n                rd <= 0;\n                we <= 1;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            6'd4: // READ_DAT\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 1;\n                we <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            6'd5: // WRITE_BUSY\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 0;\n                we <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 1;\n                busy_n <= 0;\n                crc_ok <= 0;\n                busy_int <= 1;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            default: // IDLE\n                crc_en <= 0;\n                crc_rst <= 1;\n                write_buf_0 <= 32'd0;\n                write_buf_1 <= 32'd0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 0;\n                we <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) q_start_bit <= 1;\n        else if (state == 6'd2) begin\n            if (!DAT_dat_i[0]) q_start_bit <= 0;\n            else q_start_bit <= 1;\n        end\n        else q_start_bit <= 1;\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk) begin\n        case (state)\n            6'd0: // IDLE\n                if (start_dat == 2'b01) begin\n                    write_buf_0 <= data_in;\n                    write_buf_1 <= 32'd0;\n                    DAT_oe_o <= 1;\n                    DAT_dat_o <= write_buf_0[SD_BUS_W-1:SD_BUS_W-SD_BUS_W];\n                    rd <= 0;\n                    we <= 1;\n                    last_din <= write_buf_0[SD_BUS_W-1:SD_BUS_W-SD_BUS_W];\n                    crc_c <= 0;\n                    crc_in <= last_din;\n                    crc_status <= 3'b111;\n                    crc_s <= 0;\n                    transm_complete <= 0;\n                    busy_n <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= 0;\n                    out_buff_ptr <= 0;\n                    in_buff_ptr <= 0;\n                end\n            6'd1: // WRITE_DAT\n                if (transf_cnt == SD_BUS_W) begin\n                    crc_en <= 1;\n                    crc_rst <= 0;\n                    write_buf_0 <= 32'd0;\n                    write_buf_1 <= 32'd0;\n                    DAT_oe_o <= 1;\n                    DAT_dat_o <= write_buf_0[SD_BUS_W-1:SD_BUS_W-SD_BUS_W];\n                    rd <= 0;\n                    we <= 1;\n                    last_din <= write_buf_0[SD_BUS_W-1:SD_BUS_W-SD_BUS_W];\n                    crc_c <= 0;\n                    crc_in <= last_din;\n                    crc_status <= 3'b111;\n                    crc_s <= 0;\n                    transm_complete <= 0;\n                    busy_n <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= 0;\n                    out_buff_ptr <= 0;\n                    in_buff_ptr <= 0;\n                end\n            6'd2: // READ_WAIT\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 1;\n                we <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            6'd3: // WRITE_CRC\n                DAT_oe_o <= 1;\n                DAT_dat_o <= crc_out;\n                rd <= 0;\n                we <= 1;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            6'd4: // READ_DAT\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 1;\n                we <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            6'd5: // WRITE_BUSY\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 0;\n                we <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 1;\n                busy_n <= 0;\n                crc_ok <= 0;\n                busy_int <= 1;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            default: // IDLE\n                crc_en <= 0;\n                crc_rst <= 1;\n                write_buf_0 <= 32'd0;\n                write_buf_1 <= 32'd0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 0;\n                we <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 12, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Sub-modules\n    sd_crc_16 crc_16_gen(\n       .BITVAL(crc_in),\n       .Enable(crc_en),\n       .CLK(sd_clk),\n       .RST(crc_rst),\n       .CRC(crc_out)\n    );\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always_comb begin\n        case (state)\n            6'd0: // IDLE\n                next_state = (start_dat == 2'b01)? 6'd1 : (start_dat == 2'b10)? 6'd2 : 6'd0;\n            6'd1: // WRITE_DAT\n                next_state = (transf_cnt == SD_BUS_W)? 6'd2 : 6'd1;\n            6'd2: // WRITE_CRC\n                next_state = (crc_status == 3'b111)? 6'd3 : 6'd2;\n            6'd3: // WRITE_BUSY\n                next_state = (busy_int == 1'b0)? 6'd0 : 6'd3;\n            6'd4: // READ_WAIT\n                next_state = (DAT_dat_i[0] == 1'b0)? 6'd5 : 6'd4;\n            6'd5: // READ_DAT\n                next_state = (transf_cnt == SD_BUS_W)? 6'd0 : 6'd5;\n            default: next_state = 6'd0;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) state <= 6'd0;\n        else state <= next_state;\n    end\n\n    // FSM_OUT\n    always_comb begin\n        case (state)\n            6'd0: // IDLE\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b1;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                write_buf_0 = 0;\n                write_buf_1 = 0;\n                sd_data_out = 0;\n                out_buff_ptr = 0;\n                in_buff_ptr = 0;\n                data_send_index = 0;\n                crc_en = 1'b0;\n                crc_rst = 1'b1;\n                crc_c = 0;\n                last_din = 0;\n                crc_s = 0;\n            6'd1: // WRITE_DAT\n                rd = 1'b0;\n                we = 1'b1;\n                DAT_oe_o = 1'b1;\n                DAT_dat_o = temp_in;\n                busy_n = 1'b0;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                write_buf_0 = data_in;\n                write_buf_1 = 0;\n                sd_data_out = 0;\n                out_buff_ptr = 0;\n                in_buff_ptr = 0;\n                data_send_index = 0;\n                crc_en = 1'b1;\n                crc_rst = 1'b0;\n                crc_c = 0;\n                last_din = 0;\n                crc_s = 0;\n            6'd2: // WRITE_CRC\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b0;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                write_buf_0 = 0;\n                write_buf_1 = 0;\n                sd_data_out = 0;\n                out_buff_ptr = 0;\n                in_buff_ptr = 0;\n                data_send_index = 0;\n                crc_en = 1'b1;\n                crc_rst = 1'b0;\n                crc_c = 0;\n                last_din = 0;\n                crc_s = 0;\n            6'd3: // WRITE_BUSY\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b0;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                write_buf_0 = 0;\n                write_buf_1 = 0;\n                sd_data_out = 0;\n                out_buff_ptr = 0;\n                in_buff_ptr = 0;\n                data_send_index = 0;\n                crc_en = 1'b0;\n                crc_rst = 1'b1;\n                crc_c = 0;\n                last_din = 0;\n                crc_s = 0;\n            6'd4: // READ_WAIT\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b1;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                write_buf_0 = 0;\n                write_buf_1 = 0;\n                sd_data_out = 0;\n                out_buff_ptr = 0;\n                in_buff_ptr = 0;\n                data_send_index = 0;\n                crc_en = 1'b0;\n                crc_rst = 1'b1;\n                crc_c = 0;\n                last_din = 0;\n                crc_s = 0;\n            6'd5: // READ_DAT\n                rd = 1'b1;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b0;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                write_buf_0 = 0;\n                write_buf_1 = 0;\n                sd_data_out = 0;\n                out_buff_ptr = 0;\n                in_buff_ptr = 0;\n                data_send_index = 0;\n                crc_en = 1'b1;\n                crc_rst = 1'b0;\n                crc_c = 0;\n                last_din = 0;\n                crc_s = 0;\n            default:\n                rd = 1'b0;\n                we = 1'b0;\n                DAT_oe_o = 1'b0;\n                DAT_dat_o = 0;\n                busy_n = 1'b1;\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n                write_buf_0 = 0;\n                write_buf_1 = 0;\n                sd_data_out = 0;\n                out_buff_ptr = 0;\n                in_buff_ptr = 0;\n                data_send_index = 0;\n                crc_en = 1'b0;\n                crc_rst = 1'b1;\n                crc_c = 0;\n                last_din = 0;\n                crc_s = 0;\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) q_start_bit <= 1'b1;\n        else if (state == 6'd4) q_start_bit <=!DAT_dat_i[0];\n        else q_start_bit <= 1'b1;\n    end\n\n    // FSM_OUT\n    always_comb begin\n        case (state)\n            6'd0: // IDLE\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n            6'd1: // WRITE_DAT\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n            6'd2: // WRITE_CRC\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n            6'd3: // WRITE_BUSY\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n            6'd4: // READ_WAIT\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n            6'd5: // READ_DAT\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n            default:\n                transm_complete = 1'b0;\n                crc_ok = 1'b0;\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 13, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter SD_BUS_W = 4;\n    parameter BIT_BLOCK = 512;\n    parameter CRC_OFF = 16;\n    parameter BIT_BLOCK_REC = 512;\n    parameter BIT_CRC_CYCLE = 16;\n    parameter LITTLE_ENDIAN = 1;\n    parameter BIG_ENDIAN = 0;\n    parameter SD_BUS_WIDTH_1 = 1;\n    parameter SD_BUS_WIDTH_4 = 4;\n\n    // CRC_16_gen submodule\n    sd_crc_16 crc_16_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK_SYNC submodule\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO submodule\n    always @* begin\n        case (state)\n            6'd0: // IDLE\n                if (start_dat == 2'b01) next_state = 6'd1;\n                else if (start_dat == 2'b10) next_state = 6'd2;\n                else next_state = 6'd0;\n            6'd1: // WRITE_DAT\n                if (transf_cnt == SD_BUS_W) next_state = 6'd3;\n                else next_state = 6'd1;\n            6'd2: // READ_WAIT\n                if (DAT_dat_i[0] == 0) next_state = 6'd4;\n                else next_state = 6'd2;\n            6'd3: // WRITE_CRC\n                if (crc_status == 3'b111) next_state = 6'd5;\n                else next_state = 6'd3;\n            6'd4: // READ_DAT\n                if (transf_cnt == BIT_BLOCK) next_state = 6'd0;\n                else next_state = 6'd4;\n            6'd5: // WRITE_BUSY\n                if (busy_int == 0) next_state = 6'd0;\n                else next_state = 6'd5;\n            default: next_state = 6'd0;\n        endcase\n    end\n\n    // FSM_SEQ submodule\n    always @(posedge sd_clk) begin\n        if (rst) state <= 6'd0;\n        else state <= next_state;\n    end\n\n    // FSM_OUT submodule\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            write_buf_0 <= 32'd0;\n            write_buf_1 <= 32'd0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'd0;\n            rd <= 1'b0;\n            last_din <= 4'd0;\n            crc_c <= 5'd0;\n            crc_in <= 32'd0;\n            DAT_dat_o <= 32'd0;\n            crc_status <= 3'b111;\n            busy_int <= 1'b0;\n            ack_transfer_int <= 1'b0;\n            q_start_bit <= 1'b1;\n            crc_s <= 3'd0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            data_out <= 32'd0;\n            crc_ok <= 1'b0;\n            data_send_index <= 3'd0;\n            out_buff_ptr <= 2'd0;\n            in_buff_ptr <= 2'd0;\n        end else begin\n            case (state)\n                6'd0: // IDLE\n                    write_buf_0 <= 32'd0;\n                    write_buf_1 <= 32'd0;\n                    DAT_oe_o <= 1'b0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_c <= 5'd0;\n                    crc_in <= 32'd0;\n                    DAT_dat_o <= 32'd0;\n                    crc_status <= 3'b111;\n                    busy_int <= 1'b0;\n                    ack_transfer_int <= 1'b0;\n                    q_start_bit <= 1'b1;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                6'd1: // WRITE_DAT\n                    if (transf_cnt == SD_BUS_W) begin\n                        crc_en <= 1'b1;\n                        crc_rst <= 1'b0;\n                        crc_c <= 5'd0;\n                        crc_in <= write_buf_0;\n                        DAT_dat_o <= write_buf_0;\n                        write_buf_0 <= 32'd0;\n                        write_buf_1 <= 32'd0;\n                        out_buff_ptr <= 2'd0;\n                        in_buff_ptr <= 2'd0;\n                        data_send_index <= 3'd0;\n                    end else begin\n                        write_buf_1 <= write_buf_0;\n                        write_buf_0 <= {data_in, write_buf_1[31:8]};\n                        out_buff_ptr <= out_buff_ptr + 1;\n                        in_buff_ptr <= in_buff_ptr + 1;\n                        data_send_index <= data_send_index + 1;\n                    end\n                    DAT_oe_o <= 1'b1;\n                    rd <= 1'b0;\n                    last_din <= 4'd0;\n                    crc_status <= 3'b111;\n                    busy_int <= 1'b0;\n                    ack_transfer_int <= 1'b0;\n                    q_start_bit <= 1'b1;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b0;\n                    we <= 1'b1;\n                    data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                6'd2: // READ_WAIT\n                    if (DAT_dat_i[0] == 0) begin\n                        crc_en <= 1'b1;\n                        crc_rst <= 1'b0;\n                        crc_c <= 5'd0;\n                        crc_in <= DAR_dat_i;\n                        DAT_dat_o <= DAR_dat_i;\n                        q_start_bit <= 1'b0;\n                        crc_status <= 3'b111;\n                        busy_int <= 1'b0;\n                        ack_transfer_int <= 1'b0;\n                        transm_complete <= 1'b0;\n                        busy_n <= 1'b0;\n                        we <= 1'b0;\n                        data_out <= 32'd0;\n                        crc_ok <= 1'b0;\n                    end\n                6'd3: // WRITE_CRC\n                    if (crc_status == 3'b111) begin\n                        crc_en <= 1'b0;\n                        crc_rst <= 1'b1;\n                        crc_c <= 5'd0;\n                        crc_in <= 32'd0;\n                        DAT_dat_o <= 32'd0;\n                        crc_status <= 3'b000;\n                        busy_int <= 1'b0;\n                        ack_transfer_int <= 1'b0;\n                        transm_complete <= 1'b0;\n                        busy_n <= 1'b1;\n                        we <= 1'b0;\n                        data_out <= 32'd0;\n                        crc_ok <= 1'b0;\n                    end else begin\n                        crc_c <= crc_c + 1;\n                        crc_in <= {crc_in[SD_BUS_W-1], crc_in[SD_BUS_W-2], crc_in[SD_BUS_W-3], crc_in[SD_BUS_W-4], crc_c};\n                        DAT_dat_o <= {DAT_dat_o[SD_BUS_W-1], DAT_dat_o[SD_BUS_W-2], DAT_dat_o[SD_BUS_W-3], DAT_dat_o[SD_BUS_W-4], crc_c};\n                        crc_status <= {crc_status[2], crc_status[1], crc_status[0], crc_c};\n                    end\n                6'd4: // READ_DAT\n                    if (transf_cnt == BIT_BLOCK) begin\n                        crc_en <= 1'b0;\n                        crc_rst <= 1'b1;\n                        crc_c <= 5'd0;\n                        crc_in <= 32'd0;\n                        DAT_dat_o <= 32'd0;\n                        crc_status <= 3'b111;\n                        busy_int <= 1'b0;\n                        ack_transfer_int <= 1'b0;\n                        transm_complete <= 1'b0;\n                        busy_n <= 1'b1;\n                        we <= 1'b0;\n                        data_out <= 32'd0;\n                        crc_ok <= 1'b0;\n                    end else begin\n                        crc_in <= DAR_dat_i;\n                        DAT_dat_o <= DAR_dat_i;\n                        crc_c <= crc_c + 1;\n                        crc_status <= {crc_status[2], crc_status[1], crc_status[0], crc_c};\n                        data_out <= {data_out[SD_BUS_W-1], data_out[SD_BUS_W-2], data_out[SD_BUS_W-3], data_out[SD_BUS_W-4], DAR_dat_i};\n                        transf_cnt <= transf_cnt + 1;\n                    end\n                6'd5: // WRITE_BUSY\n                    if (busy_int == 0) begin\n                        crc_en <= 1'b0;\n                        crc_rst <= 1'b1;\n                        crc_c <= 5'd0;\n                        crc_in <= 32'd0;\n                        DAT_dat_o <= 32'd0;\n                        crc_status <= 3'b111;\n                        busy_int <= 1'b0;\n                        ack_transfer_int <= 1'b0;\n                        transm_complete <= 1'b0;\n                        busy_n <= 1'b1;\n                        we <= 1'b0;\n                        data_out <= 32'd0;\n                        crc_ok <= 1'b0;\n                    end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign DAT_oe_o = (state == 6'd1) ? 1'b1 : 1'b0;\n    assign DAT_dat_o = (state == 6'd1) ? write_buf_0 : DAR_dat_i;\n    assign rd = (state == 6'd4) ? 1'b1 : 1'b0;\n    assign we = (state == 6'd1) ? 1'b1 : 1'b0;\n    assign busy_n = (state == 6'd5) ? 1'b0 : 1'b1;\n    assign transm_complete = (state == 6'd5) ? 1'b1 : 1'b0;\n    assign crc_ok = (state == 6'd5) ? crc_status[2] : 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 14, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // External signals\n    parameter SD_BUS_W = 4;\n    parameter BIT_BLOCK = 512;\n    parameter CRC_OFF = 16;\n    parameter BIT_BLOCK_REC = 512;\n    parameter BIT_CRC_CYCLE = 16;\n    parameter LITTLE_ENDIAN = 1;\n    parameter BIG_ENDIAN = 0;\n    parameter SD_BUS_WIDTH_1 = 1;\n    parameter SD_BUS_WIDTH_4 = 4;\n\n    // CRC generation block\n    sd_crc_16 crc_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK synchronization block\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end\n        else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM combination logic\n    always_comb begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01) begin\n                    next_state = WRITE_DAT;\n                end\n                else if (start_dat == 2'b10) begin\n                    next_state = READ_WAIT;\n                end\n                else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = WRITE_CRC;\n                end\n                else begin\n                    next_state = WRITE_DAT;\n                end\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111) begin\n                    next_state = WRITE_BUSY;\n                end\n                else begin\n                    next_state = WRITE_CRC;\n                end\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0) begin\n                    next_state = IDLE;\n                end\n                else begin\n                    next_state = WRITE_BUSY;\n                end\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0) begin\n                    next_state = READ_DAT;\n                end\n                else begin\n                    next_state = READ_WAIT;\n                end\n            end\n            READ_DAT: begin\n                if (transf_cnt == BIT_BLOCK) begin\n                    next_state = IDLE;\n                end\n                else begin\n                    next_state = READ_DAT;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        end\n    end\n\n    // FSM sequential logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            state <= IDLE;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM output logic\n    always_comb begin\n        case (state)\n            IDLE: begin\n                rd <= 0;\n                we <= 0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                busy_n <= 1;\n                transm_complete <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                sd_data_out <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                crc_c <= 0;\n                last_din <= 0;\n                crc_s <= 0;\n            end\n            WRITE_DAT: begin\n                rd <= 0;\n                we <= 1;\n                DAT_oe_o <= 1;\n                DAT_dat_o <= temp_in;\n                busy_n <= 0;\n                transm_complete <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index + 1;\n                out_buff_ptr <= out_buff_ptr + 1;\n                sd_data_out <= sd_data_out;\n                crc_en <= 1;\n                crc_rst <= 0;\n                crc_c <= crc_c + 1;\n                last_din <= last_din;\n                crc_s <= crc_s;\n            end\n            WRITE_CRC: begin\n                rd <= 0;\n                we <= 0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                busy_n <= 0;\n                transm_complete <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                sd_data_out <= sd_data_out;\n                crc_en <= 0;\n                crc_rst <= 1;\n                crc_c <= crc_c;\n                last_din <= last_din;\n                crc_s <= crc_s;\n            end\n            WRITE_BUSY: begin\n                rd <= 0;\n                we <= 0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                busy_n <= 0;\n                transm_complete <= 1;\n                crc_ok <= crc_ok;\n                busy_int <= busy_int;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                sd_data_out <= sd_data_out;\n                crc_en <= 0;\n                crc_rst <= 1;\n                crc_c <= crc_c;\n                last_din <= last_din;\n                crc_s <= crc_s;\n            end\n            READ_WAIT: begin\n                rd <= 0;\n                we <= 0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                busy_n <= 1;\n                transm_complete <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                sd_data_out <= sd_data_out;\n                crc_en <= 0;\n                crc_rst <= 1;\n                crc_c <= crc_c;\n                last_din <= last_din;\n                crc_s <= crc_s;\n            end\n            READ_DAT: begin\n                rd <= 1;\n                we <= 0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                busy_n <= 0;\n                transm_complete <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                sd_data_out <= sd_data_out;\n                crc_en <= 0;\n                crc_rst <= 1;\n                crc_c <= crc_c;\n                last_din <= last_din;\n                crc_s <= crc_s;\n            end\n            default: begin\n                rd <= 0;\n                we <= 0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                busy_n <= 1;\n                transm_complete <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                sd_data_out <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                crc_c <= 0;\n                last_din <= 0;\n                crc_s <= 0;\n            end\n        end\n    end\n\n    // Start bit synchronization\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end\n        else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT) begin\n                q_start_bit <= 0;\n            end\n            else begin\n                q_start_bit <= 1;\n            end\n        end\n    end\n\n    // CRC generation\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            crc_in <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            crc_c <= 0;\n            last_din <= 0;\n            crc_s <= 0;\n        end\n        else begin\n            if (state == WRITE_DAT) begin\n                crc_in <= temp_in;\n                crc_en <= 1;\n                crc_rst <= 0;\n                crc_c <= crc_c + 1;\n                last_din <= last_din;\n                crc_s <= crc_s;\n            end\n            else if (state == WRITE_CRC) begin\n                crc_in <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                crc_c <= crc_c;\n                last_din <= last_din;\n                crc_s <= crc_s;\n            end\n            else begin\n                crc_in <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                crc_c <= 0;\n                last_din <= 0;\n                crc_s <= 0;\n            end\n        end\n    end\n\n    // Data transmission\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            sd_data_out <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end\n        else begin\n            if (state == WRITE_DAT) begin\n                write_buf_0 <= write_buf_0;\n                write_buf_1 <= write_buf_1;\n                sd_data_out <= sd_data_out;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            else if (state == WRITE_CRC) begin\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                sd_data_out <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n            else begin\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                sd_data_out <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n        end\n    end\n\n    // Busy signal\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            busy_int <= 0;\n        end\n        else begin\n            if (state == WRITE_BUSY) begin\n                busy_int <= 0;\n            end\n            else begin\n                busy_int <= 1;\n            end\n        end\n    end\n\n    // Transmission complete\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            transm_complete <= 0;\n        end\n        else begin\n            if (state == WRITE_BUSY) begin\n                transm_complete <= 1;\n            end\n            else begin\n                transm_complete <= 0;\n            end\n        end\n    end\n\n    // CRC OK\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            crc_ok <= 0;\n        end\n        else begin\n            if (state == WRITE_CRC) begin\n                crc_ok <= crc_status == 3'b111;\n            end\n            else begin\n                crc_ok <= 0;\n            end\n        end\n    end\n\n    // Data output\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            data_out <= 0;\n        end\n        else begin\n            if (state == READ_DAT) begin\n                data_out <= DAR_dat_i;\n            end\n            else begin\n                data_out <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 15, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Sub-modules\n    sd_crc_16 crc_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end\n        else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always_comb begin\n        case(state)\n            IDLE: begin\n                if (start_dat == 2'b01) next_state = WRITE_DAT;\n                else if (start_dat == 2'b10) next_state = READ_WAIT;\n                else next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = WRITE_CRC;\n                else next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111) next_state = WRITE_BUSY;\n                else next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0) next_state = IDLE;\n                else next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0) next_state = READ_DAT;\n                else next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = IDLE;\n                else next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) state <= IDLE;\n        else state <= next_state;\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end\n        else begin\n            case(state)\n                IDLE: begin\n                    if (start_dat == 2'b01) begin\n                        write_buf_0 <= data_in;\n                        write_buf_1 <= 0;\n                        DAT_oe_o <= 0;\n                        crc_en <= 0;\n                        crc_rst <= 1;\n                        transf_cnt <= 0;\n                        rd <= 0;\n                        last_din <= 0;\n                        crc_c <= 0;\n                        crc_in <= 0;\n                        DAT_dat_o <= 0;\n                        crc_status <= 3'b111;\n                        crc_s <= 0;\n                        transm_complete <= 0;\n                        busy_n <= 1;\n                        we <= 0;\n                        data_out <= 0;\n                        crc_ok <= 0;\n                        busy_int <= 0;\n                        data_send_index <= 0;\n                        out_buff_ptr <= 0;\n                        in_buff_ptr <= 0;\n                    end\n                end\n                WRITE_DAT: begin\n                    if (transf_cnt == SD_BUS_W) begin\n                        crc_en <= 1;\n                        crc_rst <= 0;\n                        crc_in <= write_buf_0;\n                        DAT_dat_o <= write_buf_0;\n                        DAT_oe_o <= 1;\n                        write_buf_0 <= 0;\n                        write_buf_1 <= 0;\n                        rd <= 0;\n                        last_din <= 0;\n                        crc_c <= 0;\n                        crc_status <= 3'b111;\n                        crc_s <= 0;\n                        transm_complete <= 0;\n                        busy_n <= 1;\n                        we <= 0;\n                        data_out <= 0;\n                        crc_ok <= 0;\n                        busy_int <= 0;\n                        data_send_index <= 0;\n                        out_buff_ptr <= 0;\n                        in_buff_ptr <= 0;\n                    end\n                    else begin\n                        DAT_dat_o <= write_buf_0;\n                        write_buf_0 <= write_buf_0 >> 1;\n                        write_buf_1 <= write_buf_1 << 1;\n                        transf_cnt <= transf_cnt + 1;\n                        rd <= 0;\n                        last_din <= 0;\n                        crc_c <= 0;\n                        crc_status <= 3'b111;\n                        crc_s <= 0;\n                        transm_complete <= 0;\n                        busy_n <= 1;\n                        we <= 0;\n                        data_out <= 0;\n                        crc_ok <= 0;\n                        busy_int <= 0;\n                        data_send_index <= 0;\n                        out_buff_ptr <= 0;\n                        in_buff_ptr <= 0;\n                    end\n                end\n                WRITE_CRC: begin\n                    crc_c <= crc_c + 1;\n                    if (crc_c == BIT_CRC_CYCLE) begin\n                        crc_status <= crc_s;\n                        crc_s <= crc_s + 1;\n                        crc_c <= 0;\n                    end\n                    if (crc_status == 3'b111) begin\n                        DAT_dat_o <= crc_out;\n                        DAT_oe_o <= 1;\n                        crc_en <= 0;\n                        crc_rst <= 1;\n                        crc_in <= 0;\n                        crc_status <= 3'b111;\n                        crc_s <= 0;\n                        transm_complete <= 0;\n                        busy_n <= 1;\n                        we <= 0;\n                        data_out <= 0;\n                        crc_ok <= 0;\n                        busy_int <= 0;\n                        data_send_index <= 0;\n                        out_buff_ptr <= 0;\n                        in_buff_ptr <= 0;\n                    end\n                end\n                WRITE_BUSY: begin\n                    if (busy_int == 0) begin\n                        DAT_oe_o <= 0;\n                        crc_en <= 0;\n                        crc_rst <= 1;\n                        crc_in <= 0;\n                        crc_status <= 3'b111;\n                        crc_s <= 0;\n                        transm_complete <= 1;\n                        busy_n <= 0;\n                        we <= 0;\n                        data_out <= 0;\n                        crc_ok <= 0;\n                        busy_int <= 0;\n                        data_send_index <= 0;\n                        out_buff_ptr <= 0;\n                        in_buff_ptr <= 0;\n                    end\n                end\n                READ_WAIT: begin\n                    if (DAT_dat_i[0] == 0) begin\n                        DAT_dat_o <= DAT_dat_i;\n                        DAT_oe_o <= 1;\n                        crc_en <= 1;\n                        crc_rst <= 0;\n                        crc_in <= DAT_dat_i;\n                        crc_status <= 3'b111;\n                        crc_s <= 0;\n                        transm_complete <= 0;\n                        busy_n <= 1;\n                        we <= 0;\n                        data_out <= 0;\n                        crc_ok <= 0;\n                        busy_int <= 0;\n                        data_send_index <= 0;\n                        out_buff_ptr <= 0;\n                        in_buff_ptr <= 0;\n                    end\n                end\n                READ_DAT: begin\n                    if (transf_cnt == SD_BUS_W) begin\n                        DAT_oe_o <= 0;\n                        crc_en <= 0;\n                        crc_rst <= 1;\n                        crc_in <= 0;\n                        crc_status <= 3'b111;\n                        crc_s <= 0;\n                        transm_complete <= 1;\n                        busy_n <= 0;\n                        we <= 0;\n                        data_out <= 0;\n                        crc_ok <= 0;\n                        busy_int <= 0;\n                        data_send_index <= 0;\n                        out_buff_ptr <= 0;\n                        in_buff_ptr <= 0;\n                    end\n                    else begin\n                        DAT_dat_o <= DAT_dat_i;\n                        DAT_oe_o <= 1;\n                        crc_in <= DAT_dat_i;\n                        crc_status <= 3'b111;\n                        crc_s <= 0;\n                        transm_complete <= 0;\n                        busy_n <= 1;\n                        we <= 0;\n                        data_out <= 0;\n                        crc_ok <= 0;\n                        busy_int <= 0;\n                        data_send_index <= 0;\n                        out_buff_ptr <= 0;\n                        in_buff_ptr <= 0;\n                    end\n                end\n                default: begin\n                    DAT_oe_o <= 0;\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    crc_in <= 0;\n                    crc_status <= 3'b111;\n                    crc_s <= 0;\n                    transm_complete <= 0;\n                    busy_n <= 1;\n                    we <= 0;\n                    data_out <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= 0;\n                    out_buff_ptr <= 0;\n                    in_buff_ptr <= 0;\n                end\n            endcase\n        end\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) q_start_bit <= 1;\n        else if (state == READ_WAIT && !DAT_dat_i[0] && !busy_int) q_start_bit <= 0;\n        else q_start_bit <= 1;\n    end\n\n    // FSM_OUT\n    assign rd = (state == READ_DAT) ? 1 : 0;\n    assign data_out = (state == READ_DAT) ? DAR_dat_i : 0;\n    assign we = (state == WRITE_DAT) ? 1 : 0;\n    assign DAT_dat_o = (state == WRITE_DAT) ? write_buf_0 : 0;\n    assign DAT_oe_o = (state == WRITE_DAT || state == READ_DAT) ? 1 : 0;\n    assign busy_n = (state == WRITE_BUSY) ? 0 : 1;\n    assign transm_complete = (state == WRITE_BUSY) ? 1 : 0;\n    assign crc_ok = (state == WRITE_CRC) ? (crc_status == 3'b111) : 0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 16, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter SD_BUS_W = 4;\n    parameter BIT_BLOCK = 512;\n    parameter CRC_OFF = 16;\n    parameter BIT_BLOCK_REC = 512;\n    parameter BIT_CRC_CYCLE = 16;\n    parameter LITTLE_ENDIAN = 1;\n    parameter BIG_ENDIAN = 0;\n    parameter SD_BUS_WIDTH_1 = 1;\n    parameter SD_BUS_WIDTH_4 = 4;\n\n    // CRC generation block\n    sd_crc_16 crc_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK synchronization block\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end\n        else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM combo block\n    always @* begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01) begin\n                    next_state = WRITE_DAT;\n                end\n                else if (start_dat == 2'b10) begin\n                    next_state = READ_WAIT;\n                end\n                else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = WRITE_CRC;\n                end\n                else begin\n                    next_state = WRITE_DAT;\n                end\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111) begin\n                    next_state = WRITE_BUSY;\n                end\n                else begin\n                    next_state = WRITE_CRC;\n                end\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0) begin\n                    next_state = IDLE;\n                end\n                else begin\n                    next_state = WRITE_BUSY;\n                end\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0) begin\n                    next_state = READ_DAT;\n                end\n                else begin\n                    next_state = READ_WAIT;\n                end\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = IDLE;\n                end\n                else begin\n                    next_state = READ_DAT;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        end\n    end\n\n    // FSM sequence block\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            state <= IDLE;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM output block\n    always @* begin\n        case (state)\n            IDLE: begin\n                rd <= 0;\n                we <= 0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                busy_n <= 1;\n                transm_complete <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                sd_data_out <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                crc_c <= 0;\n                last_din <= 0;\n                crc_s <= 0;\n            end\n            WRITE_DAT: begin\n                rd <= 0;\n                we <= 1;\n                DAT_oe_o <= 1;\n                DAT_dat_o <= write_buf_0;\n                busy_n <= 0;\n                transm_complete <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                write_buf_0 <= data_in;\n                write_buf_1 <= 0;\n                sd_data_out <= 0;\n                crc_en <= 1;\n                crc_rst <= 0;\n                crc_c <= 0;\n                last_din <= 0;\n                crc_s <= 0;\n            end\n            WRITE_CRC: begin\n                rd <= 0;\n                we <= 0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                busy_n <= 0;\n                transm_complete <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                sd_data_out <= 0;\n                crc_en <= 1;\n                crc_rst <= 0;\n                crc_c <= 0;\n                last_din <= 0;\n                crc_s <= 0;\n            end\n            WRITE_BUSY: begin\n                rd <= 0;\n                we <= 0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                busy_n <= 0;\n                transm_complete <= 1;\n                crc_ok <= 0;\n                busy_int <= 1;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                sd_data_out <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                crc_c <= 0;\n                last_din <= 0;\n                crc_s <= 0;\n            end\n            READ_WAIT: begin\n                rd <= 0;\n                we <= 0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                busy_n <= 1;\n                transm_complete <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                sd_data_out <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                crc_c <= 0;\n                last_din <= 0;\n                crc_s <= 0;\n            end\n            READ_DAT: begin\n                rd <= 1;\n                we <= 0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                busy_n <= 0;\n                transm_complete <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                sd_data_out <= 0;\n                crc_en <= 1;\n                crc_rst <= 0;\n                crc_c <= 0;\n                last_din <= 0;\n                crc_s <= 0;\n            end\n            default: begin\n                rd <= 0;\n                we <= 0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                busy_n <= 1;\n                transm_complete <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                sd_data_out <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                crc_c <= 0;\n                last_din <= 0;\n                crc_s <= 0;\n            end\n        end\n    end\n\n    // Start synchronization block\n    always @* begin\n        if (state == READ_WAIT) begin\n            if (DAT_dat_i[0] == 0) begin\n                q_start_bit <= 0;\n            end\n            else begin\n                q_start_bit <= 1;\n            end\n        end\n        else begin\n            q_start_bit <= 1;\n        end\n    end\n\n    // FSM output logic\n    always @* begin\n        case (state)\n            IDLE: begin\n                data_out <= 0;\n                crc_ok <= 0;\n                transm_complete <= 0;\n            end\n            WRITE_DAT: begin\n                data_out <= write_buf_0;\n                crc_ok <= 0;\n                transm_complete <= 0;\n            end\n            WRITE_CRC: begin\n                data_out <= 0;\n                crc_ok <= 0;\n                transm_complete <= 0;\n            end\n            WRITE_BUSY: begin\n                data_out <= 0;\n                crc_ok <= 0;\n                transm_complete <= 1;\n            end\n            READ_WAIT: begin\n                data_out <= 0;\n                crc_ok <= 0;\n                transm_complete <= 0;\n            end\n            READ_DAT: begin\n                data_out <= DAR_dat_i;\n                crc_ok <= 0;\n                transm_complete <= 0;\n            end\n            default: begin\n                data_out <= 0;\n                crc_ok <= 0;\n                transm_complete <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty,\n    output wire [FIFO_RX_MEM_ADR_SIZE-1:0] mem_empt\n);\n\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] offset;\n    reg [1:0] wb_free;\n    reg [1:0] reset_rx_fifo;\n    reg [1:0] rd;\n\n    sd_rx_fifo sd_rx_fifo(\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt)\n    );\n\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= '0;\n            wb_free <= '0;\n            reset_rx_fifo <= '0;\n            rd <= '0;\n        end\n        else if (en) begin\n            if (rd) begin\n                if (!empty) begin\n                    m_wb_adr_o <= offset;\n                    m_wb_we_o <= 1'b1;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_cti_o <= 3'b001;\n                    m_wb_bte_o <= 2'b01;\n                    wb_free <= 1'b0;\n                end\n                else begin\n                    rd <= 1'b0;\n                end\n            end\n            else begin\n                if (wb_free) begin\n                    rd <= 1'b1;\n                end\n            end\n        end\n        else begin\n            rd <= 1'b0;\n            offset <= '0;\n            wb_free <= '0;\n            reset_rx_fifo <= '1;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= '0;\n            m_wb_we_o <= '0;\n            m_wb_cyc_o <= '0;\n            m_wb_stb_o <= '0;\n            m_wb_cti_o <= '0;\n            m_wb_bte_o <= '0;\n        end\n        else if (en) begin\n            if (m_wb_ack_i) begin\n                m_wb_adr_o <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 2, "code": "module sd_fifo_rx_filler(\n    input  clk,\n    input  rst,\n    input  sd_clk,\n    input  [31:0] m_wb_adr_o,\n    output [31:0] m_wb_dat_o,\n    output [1:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    input         m_wb_cti_i,\n    input         m_wb_bte_i,\n    input         en,\n    input  [31:0] adr,\n    input  sd_clk,\n    input  [SD_BUS_W-1:0] dat_i,\n    input  wr,\n    output        full,\n    output        empty,\n    output [FIFO_RX_MEM_ADR_SIZE-1:0] offset,\n    output        wb_free,\n    output        reset_rx_fifo,\n    output        rd\n);\n\n    // Define the FIFO module\n    sd_rx_fifo sd_fifo(\n        .clk(clk),\n        .rst(rst),\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt)\n    );\n\n    // Define the Wishbone interface\n    reg [31:0] wb_dat_o;\n    reg [1:0]  wb_cti_o;\n    reg [1:0]  wb_bte_o;\n    reg        wb_cyc_o;\n    reg        wb_stb_o;\n    reg        wb_ack_i;\n    reg        wb_cti_i;\n    reg        wb_bte_i;\n    reg        wb_free;\n\n    // Define the control logic\n    reg [8:0] offset_reg;\n    reg        reset_rx_fifo_reg;\n    reg        rd_reg;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            offset_reg <= 0;\n            reset_rx_fifo_reg <= 1;\n            rd_reg <= 0;\n            wb_free <= 1;\n        end else begin\n            if (en) begin\n                if (rd_reg) begin\n                    // Read from FIFO and initiate Wishbone write transaction\n                    if (empty) begin\n                        rd_reg <= 0;\n                        wb_free <= 1;\n                    end else begin\n                        wb_dat_o <= sd_fifo.q;\n                        wb_cti_o <= m_wb_cti_i;\n                        wb_bte_o <= m_wb_bte_i;\n                        wb_cyc_o <= 1;\n                        wb_stb_o <= 1;\n                        wb_free <= 0;\n                    end\n                end else begin\n                    // Wait for FIFO to be not empty and Wishbone bus to be free\n                    if (empty && wb_free) begin\n                        rd_reg <= 1;\n                        wb_free <= 0;\n                    end\n                end\n            end else begin\n                // Disabled state handling\n                rd_reg <= 0;\n                reset_rx_fifo_reg <= 1;\n                offset_reg <= 0;\n                wb_free <= 1;\n            end\n        end\n    end\n\n    // Update address offset\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n        end else begin\n            if (wb_ack_i) begin\n                offset <= offset_reg + MEM_OFFSET;\n            end\n        end\n    end\n\n    // Update FIFO reset control\n    always @(posedge clk) begin\n        if (rst) begin\n            reset_rx_fifo <= 1;\n        end else begin\n            if (en) begin\n                reset_rx_fifo <= reset_rx_fifo_reg;\n            end\n        end\n    end\n\n    // Update FIFO read enable\n    always @(posedge clk) begin\n        if (rst) begin\n            rd <= 0;\n        end else begin\n            if (en) begin\n                rd <= rd_reg;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 3, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o\n);\n\n    // Define FIFO parameters\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n    localparam FIFO_TX_MEM_DEPTH = 256;\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1;\n\n    // Define Wishbone parameters\n    localparam MEM_OFFSET = 2;\n\n    // FIFO instance\n    sd_rx_fifo sd_rx_fifo_i(\n       .clk(clk),\n       .rst(rst),\n       .d(dat_i),\n       .wr(wr),\n       .wclk(sd_clk),\n       .q(m_wb_dat_o),\n       .rd(1'b0),\n       .full(full),\n       .empty(empty),\n       .mem_empt({FIFO_RX_MEM_DEPTH[FIFO_RX_MEM_ADR_SIZE-1:0], FIFO_TX_MEM_DEPTH[FIFO_TX_MEM_ADR_SIZE-1:0]}),\n       .rclk(clk),\n       .rst(rst)\n    );\n\n    // Wishbone control logic\n    reg [31:0] m_wb_adr_o_reg;\n    reg m_wb_we_o_reg;\n    reg m_wb_cyc_o_reg;\n    reg m_wb_stb_o_reg;\n    reg [2:0] m_wb_cti_o_reg;\n    reg [1:0] m_wb_bte_o_reg;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o_reg <= 32'h00000000;\n            m_wb_we_o_reg <= 1'b0;\n            m_wb_cyc_o_reg <= 1'b0;\n            m_wb_stb_o_reg <= 1'b0;\n            m_wb_cti_o_reg <= 3'b000;\n            m_wb_bte_o_reg <= 2'b00;\n        end else begin\n            if (en &&!full &&!empty) begin\n                m_wb_adr_o_reg <= m_wb_adr_o_reg + MEM_OFFSET;\n                m_wb_we_o_reg <= 1'b1;\n                m_wb_cyc_o_reg <= 1'b1;\n                m_wb_stb_o_reg <= 1'b1;\n                m_wb_cti_o_reg <= 3'b000;\n                m_wb_bte_o_reg <= 2'b00;\n            end else begin\n                m_wb_adr_o_reg <= m_wb_adr_o_reg;\n                m_wb_we_o_reg <= m_wb_we_o_reg;\n                m_wb_cyc_o_reg <= m_wb_cyc_o_reg;\n                m_wb_stb_o_reg <= m_wb_stb_o_reg;\n                m_wb_cti_o_reg <= m_wb_cti_o_reg;\n                m_wb_bte_o_reg <= m_wb_bte_o_reg;\n            end\n        end\n    end\n\n    assign m_wb_adr_o = m_wb_adr_o_reg;\n    assign m_wb_we_o = m_wb_we_o_reg;\n    assign m_wb_cyc_o = m_wb_cyc_o_reg;\n    assign m_wb_stb_o = m_wb_stb_o_reg;\n    assign m_wb_cti_o = m_wb_cti_o_reg;\n    assign m_wb_bte_o = m_wb_bte_o_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 4, "code": "module sd_fifo_rx_filler(\n    input  clk,\n    input  rst,\n    output [31:0] m_wb_adr_o,\n    output  m_wb_we_o,\n    output  [31:0] m_wb_dat_o,\n    output  m_wb_cyc_o,\n    output  m_wb_stb_o,\n    input   m_wb_ack_i,\n    output  [2:0] m_wb_cti_o,\n    output  [1:0] m_wb_bte_o,\n    input   en,\n    input  [31:0] adr,\n    input   sd_clk,\n    input  [SD_BUS_W-1:0] dat_i,\n    input   wr,\n    output  full,\n    output  empty,\n    output  [FIFO_RX_MEM_ADR_SIZE-1:0] mem_empt,\n    input   rclk,\n    input   rst\n);\n\n    // Define the FIFO module\n    sd_rx_fifo sd_rx_fifo(\n        .clk(clk),\n        .rst(rst),\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(),\n        .rd(),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(rclk)\n    );\n\n    // Define the Wishbone interface\n    reg [31:0] wb_dat_o;\n    reg m_wb_we_o;\n    reg m_wb_cyc_o;\n    reg m_wb_stb_o;\n    reg [2:0] m_wb_cti_o;\n    reg [1:0] m_wb_bte_o;\n    reg m_wb_ack_i;\n    reg [31:0] m_wb_adr_o;\n    reg [31:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // Initialize the Wishbone interface\n    initial begin\n        m_wb_adr_o = 32'd0;\n        m_wb_we_o = 1'b0;\n        m_wb_dat_o = 32'd0;\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n        m_wb_cti_o = 3'b0;\n        m_wb_bte_o = 2'b0;\n        wb_free = 1'b1;\n        reset_rx_fifo = 1'b1;\n        rd = 1'b0;\n    end\n\n    // Clock and reset logic\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end\n        else begin\n            if (en) begin\n                if (wb_free && !empty) begin\n                    m_wb_adr_o <= offset;\n                    m_wb_we_o <= 1'b1;\n                    m_wb_dat_o <= wb_dat_o;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_cti_o <= 3'b0;\n                    m_wb_bte_o <= 2'b0;\n                    wb_free <= 1'b0;\n                    rd <= 1'b1;\n                end\n                else begin\n                    m_wb_adr_o <= 32'd0;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_dat_o <= 32'd0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    m_wb_cti_o <= 3'b0;\n                    m_wb_bte_o <= 2'b0;\n                    wb_free <= 1'b1;\n                    rd <= 1'b0;\n                end\n            end\n            else begin\n                m_wb_adr_o <= 32'd0;\n                m_wb_we_o <= 1'b0;\n                m_wb_dat_o <= 32'd0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_cti_o <= 3'b0;\n                m_wb_bte_o <= 2'b0;\n                wb_free <= 1'b1;\n                reset_rx_fifo <= 1'b1;\n                rd <= 1'b0;\n            end\n        end\n    end\n\n    // Wishbone write transaction completion\n    always @(posedge clk) begin\n        if (rst) begin\n            wb_free <= 1'b1;\n        end\n        else begin\n            if (m_wb_ack_i) begin\n                wb_free <= 1'b1;\n                offset <= offset + MEM_OFFSET;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 5, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o\n);\n\n    // Sub-modules\n    sd_rx_fifo sd_rx_fifo_module(\n       .clk(clk),\n       .rst(rst),\n       .d(dat_i),\n       .wr(wr),\n       .wclk(sd_clk),\n       .q(m_wb_dat_o),\n       .rd(1'b0),\n       .full(full),\n       .empty(empty),\n       .mem_empt({2'b0, FIFO_RX_MEM_ADR_SIZE{1'b0}}),\n       .rclk(clk),\n       .rst(rst)\n    );\n\n    // Registers\n    reg [8:0] offset = 9'd0;\n    reg wb_free = 1'b1;\n    reg reset_rx_fifo = 1'b0;\n    reg rd = 1'b0;\n\n    // Wishbone interface\n    assign m_wb_adr_o = adr + offset;\n    assign m_wb_we_o = 1'b1;\n    assign m_wb_cyc_o = 1'b1;\n    assign m_wb_stb_o = 1'b1;\n    assign m_wb_cti_o = 3'b001;\n    assign m_wb_bte_o = 2'b00;\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b0;\n            rd <= 1'b0;\n        end else begin\n            if (en) begin\n                if (!wb_free) begin\n                    wb_free <= 1'b1;\n                    offset <= offset + MEM_OFFSET;\n                end\n                if (!reset_rx_fifo) begin\n                    reset_rx_fifo <= 1'b1;\n                    rd <= 1'b1;\n                end\n                if (rd &&!empty) begin\n                    rd <= 1'b0;\n                    wb_free <= 1'b0;\n                end\n            end else begin\n                reset_rx_fifo <= 1'b1;\n                rd <= 1'b0;\n                wb_free <= 1'b1;\n                offset <= 9'd0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 6, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o\n);\n\n    // Define FIFO parameters\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n    localparam FIFO_TX_MEM_DEPTH = 256;\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1;\n\n    // Define Wishbone parameters\n    localparam MEM_OFFSET = 4;\n\n    // Define control signals\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // Define FIFO signals\n    reg [31:0] q;\n    reg full;\n    reg empty;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] mem_empt;\n\n    // Define sd_rx_fifo module\n    sd_rx_fifo sd_rx_fifo(\n       .d(dat_i),\n       .wr(wr),\n       .wclk(sd_clk),\n       .q(q),\n       .rd(rd),\n       .full(full),\n       .empty(empty),\n       .mem_empt(mem_empt),\n       .rst(reset_rx_fifo)\n    );\n\n    // Define Wishbone interface\n    assign m_wb_adr_o = adr + offset;\n    assign m_wb_we_o = wr;\n    assign m_wb_dat_o = q;\n    assign m_wb_cyc_o = m_wb_stb_o;\n    assign m_wb_cti_o = 3'b001;\n    assign m_wb_bte_o = 2'b00;\n\n    // Define state machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else if (en) begin\n            if (full) begin\n                wb_free <= 0;\n            end else if (wb_free) begin\n                wb_free <= 0;\n                offset <= offset + MEM_OFFSET;\n                rd <= 1;\n            end else if (rd) begin\n                rd <= 0;\n                wb_free <= 1;\n            end\n        end\n    end\n\n    // Define FIFO read and write operations\n    always @(posedge sd_clk) begin\n        if (wr) begin\n            sd_rx_fifo.wr <= 1;\n        end else begin\n            sd_rx_fifo.wr <= 0;\n        end\n    end\n\n    // Define FIFO read operation\n    always @(posedge clk) begin\n        if (rd) begin\n            q <= sd_rx_fifo.q;\n        end\n    end\n\n    // Define FIFO full and empty flags\n    assign full = sd_rx_fifo.full;\n    assign empty = sd_rx_fifo.empty;\n    assign mem_empt = sd_rx_fifo.mem_empt;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 7, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty\n);\n\n    // Local parameters\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n    localparam MEM_OFFSET = 2;\n\n    // Registers\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] offset;\n    reg [1:0] wb_free;\n    reg [1:0] reset_rx_fifo;\n    reg [1:0] rd;\n\n    // FIFO\n    wire [31:0] dat_o;\n    wire [31:0] q;\n    wire full;\n    wire empty;\n    sd_rx_fifo sd_rx_fifo(\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(q),\n        .rd(rd),\n        .full(full),\n        .empty(empty)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = offset + adr;\n    assign m_wb_we_o = rd;\n    assign m_wb_dat_o = q;\n    assign m_wb_cyc_o = rd;\n    assign m_wb_stb_o = rd;\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else if (en) begin\n            if (empty) begin\n                rd <= 1;\n                reset_rx_fifo <= 0;\n            end else if (wb_free) begin\n                rd <= 1;\n                wb_free <= 0;\n            end else if (m_wb_ack_i) begin\n                rd <= 0;\n                wb_free <= 1;\n                offset <= offset + MEM_OFFSET;\n            end\n        end else begin\n            rd <= 0;\n            reset_rx_fifo <= 1;\n            offset <= 0;\n            wb_free <= 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 8, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o\n);\n\n    // Define the FIFO depth and address size\n    localparam FIFO_RX_MEM_DEPTH = `FIFO_RX_MEM_DEPTH;\n    localparam FIFO_RX_MEM_ADR_SIZE = `FIFO_RX_MEM_ADR_SIZE;\n\n    // Define the Wishbone bus width\n    localparam WB_WIDTH = 32;\n\n    // Define the SD bus width\n    localparam SD_BUS_W = `SD_BUS_W;\n\n    // Define the memory offset\n    localparam MEM_OFFSET = `MEM_OFFSET;\n\n    // Define the reset clock divider\n    localparam RESET_CLK_DIV = `RESET_CLK_DIV;\n\n    // Define the SD clock bus clock\n    localparam SD_CLK_BUS_CLK = `SD_CLK_BUS_CLK;\n\n    // Define the SD clock static\n    localparam SD_CLK_STATIC = `SD_CLK_STATIC;\n\n    // Define the SD clock dynamic\n    localparam SD_CLK_DYNAMIC = `SD_CLK_DYNAMIC;\n\n    // Define the block size\n    localparam BLOCK_SIZE = `BLOCK_SIZE;\n\n    // Define the FIFO read and write enable signals\n    reg rd;\n    reg wr;\n\n    // Define the FIFO full and empty flags\n    reg full;\n    reg empty;\n\n    // Define the Wishbone bus signals\n    reg [WB_WIDTH-1:0] m_wb_dat_o;\n    reg m_wb_we_o;\n    reg m_wb_cyc_o;\n    reg m_wb_stb_o;\n    reg [2:0] m_wb_cti_o;\n    reg [1:0] m_wb_bte_o;\n\n    // Define the address offset\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] offset;\n\n    // Define the Wishbone bus availability flag\n    reg wb_free;\n\n    // Define the RX FIFO reset control\n    reg reset_rx_fifo;\n\n    // Define the sd_rx_fifo module\n    sd_rx_fifo sd_rx_fifo(\n       .d(dat_i),\n       .wr(wr),\n       .wclk(sd_clk),\n       .q(m_wb_dat_o),\n       .rd(rd),\n       .full(full),\n       .empty(empty),\n       .mem_empt({FIFO_RX_MEM_DEPTH[FIFO_RX_MEM_ADR_SIZE-1:0], FIFO_RX_MEM_DEPTH[FIFO_RX_MEM_ADR_SIZE-2:0]}),\n       .rclk(clk),\n       .rst(rst)\n    );\n\n    // Define the Wishbone bus interface\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_dat_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else begin\n            if (en) begin\n                if (wb_free &&!full) begin\n                    rd <= 1;\n                    m_wb_dat_o <= m_wb_dat_o;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 0;\n                    m_wb_bte_o <= 0;\n                    wb_free <= 0;\n                end else begin\n                    rd <= 0;\n                    m_wb_dat_o <= 0;\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    m_wb_cti_o <= 0;\n                    m_wb_bte_o <= 0;\n                    wb_free <= 1;\n                end\n            end else begin\n                rd <= 0;\n                m_wb_dat_o <= 0;\n                m_wb_we_o <= 0;\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                m_wb_cti_o <= 0;\n                m_wb_bte_o <= 0;\n                wb_free <= 1;\n                reset_rx_fifo <= 1;\n                offset <= 0;\n            end\n        end\n    end\n\n    // Define the Wishbone bus interface\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n        end else begin\n            if (en) begin\n                if (wb_free &&!full) begin\n                    m_wb_adr_o <= offset + MEM_OFFSET;\n                end else begin\n                    m_wb_adr_o <= 0;\n                end\n            end else begin\n                m_wb_adr_o <= 0;\n            end\n        end\n    end\n\n    // Define the Wishbone bus interface\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_ack_i <= 0;\n        end else begin\n            if (en) begin\n                if (wb_free &&!full) begin\n                    m_wb_ack_i <= 1;\n                end else begin\n                    m_wb_ack_i <= 0;\n                end\n            end else begin\n                m_wb_ack_i <= 0;\n            end\n        end\n    end\n\n    // Define the FIFO read and write enable signals\n    always @(posedge clk) begin\n        if (rst) begin\n            wr <= 0;\n            rd <= 0;\n        end else begin\n            if (en) begin\n                if (wb_free &&!full) begin\n                    wr <= 1;\n                    rd <= 1;\n                end else begin\n                    wr <= 0;\n                    rd <= 0;\n                end\n            end else begin\n                wr <= 0;\n                rd <= 0;\n            end\n        end\n    end\n\n    // Define the FIFO full and empty flags\n    always @(posedge clk) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 0;\n        end else begin\n            if (en) begin\n                if (wb_free &&!full) begin\n                    full <= sd_rx_fifo.full;\n                    empty <= sd_rx_fifo.empty;\n                end else begin\n                    full <= 0;\n                    empty <= 0;\n                end\n            end else begin\n                full <= 0;\n                empty <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 9, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty,\n    output wire [FIFO_RX_MEM_ADR_SIZE-1:0] mem_empt\n);\n\n    // Define the FIFO module\n    sd_rx_fifo sd_rx_fifo(\n        .clk(clk),\n        .rst(rst),\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(1'b0),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt)\n    );\n\n    // Define the Wishbone interface\n    reg [31:0] wb_adr;\n    reg wb_we;\n    reg [31:0] wb_dat;\n    reg wb_cyc;\n    reg wb_stb;\n    reg [2:0] wb_cti;\n    reg [1:0] wb_bte;\n    reg wb_ack;\n\n    // Define the state machine\n    enum logic [2:0] {IDLE, READ, WRITE} state;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            state <= IDLE;\n            wb_adr <= 32'd0;\n            wb_we <= 1'b0;\n            wb_dat <= 32'd0;\n            wb_cyc <= 1'b0;\n            wb_stb <= 1'b0;\n            wb_cti <= 3'b0;\n            wb_bte <= 2'b0;\n            wb_ack <= 1'b0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    if (en && !full) begin\n                        state <= READ;\n                    end\n                end\n                READ: begin\n                    if (m_wb_ack_i) begin\n                        wb_adr <= wb_adr + MEM_OFFSET;\n                        wb_we <= 1'b0;\n                        wb_dat <= sd_rx_fifo.q;\n                        wb_cyc <= 1'b1;\n                        wb_stb <= 1'b1;\n                        wb_cti <= 3'b010;\n                        wb_bte <= 2'b00;\n                        wb_ack <= 1'b0;\n                        state <= WRITE;\n                    end\n                end\n                WRITE: begin\n                    if (m_wb_ack_i) begin\n                        wb_adr <= wb_adr + MEM_OFFSET;\n                        wb_we <= 1'b0;\n                        wb_dat <= 32'd0;\n                        wb_cyc <= 1'b0;\n                        wb_stb <= 1'b0;\n                        wb_cti <= 3'b000;\n                        wb_bte <= 2'b00;\n                        wb_ack <= 1'b1;\n                        state <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Assign outputs\n    m_wb_adr_o <= wb_adr;\n    m_wb_we_o <= wb_we;\n    m_wb_dat_o <= wb_dat;\n    m_wb_cyc_o <= wb_cyc;\n    m_wb_stb_o <= wb_stb;\n    m_wb_cti_o <= wb_cti;\n    m_wb_bte_o <= wb_bte;\n    m_wb_ack_i <= wb_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 10, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // sd_rx_fifo module\n    sd_rx_fifo sd_rx_fifo_i(\n       .clk(clk),\n       .rst(rst),\n       .d(dat_i),\n       .wr(wr),\n       .wclk(sd_clk),\n       .q(m_wb_dat_o),\n       .rd(rd),\n       .full(full),\n       .empty(empty),\n       .mem_empt(),\n       .rclk(),\n       .rst(reset_rx_fifo)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = adr + offset;\n    assign m_wb_we_o = wr;\n    assign m_wb_cyc_o = en;\n    assign m_wb_stb_o = en;\n    assign m_wb_cti_o = 3'b001;\n    assign m_wb_bte_o = 2'b00;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else if (en) begin\n            if (wb_free &&!empty) begin\n                rd <= 1;\n                wb_free <= 0;\n            end else if (m_wb_ack_i) begin\n                wb_free <= 1;\n                offset <= offset + MEM_OFFSET;\n            end\n        end else begin\n            reset_rx_fifo <= 1;\n            rd <= 0;\n            wb_free <= 1;\n            offset <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 11, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty\n);\n\n    // Define the FIFO depth and address size\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    // Define the Wishbone bus parameters\n    localparam WB_DATA_WIDTH = 32;\n    localparam WB_ADDR_WIDTH = 32;\n    localparam WB_BURST_TYPE = 3;\n    localparam WB_BURST_EXTENSION = 2;\n\n    // Define the memory offset\n    localparam MEM_OFFSET = 4;\n\n    // Define the reset control signals\n    reg reset_rx_fifo = 1'b1;\n    reg wb_free = 1'b1;\n\n    // Define the FIFO read and write pointers\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] rx_fifo_wr_ptr = 0;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] rx_fifo_rd_ptr = 0;\n\n    // Define the FIFO data\n    reg [SD_BUS_W-1:0] fifo_data [FIFO_RX_MEM_DEPTH-1:0];\n\n    // Define the Wishbone master signals\n    reg [WB_DATA_WIDTH-1:0] m_wb_dat_o_reg;\n    reg m_wb_we_o_reg;\n    reg m_wb_cyc_o_reg;\n    reg m_wb_stb_o_reg;\n    reg [WB_BURST_TYPE-1:0] m_wb_cti_o_reg;\n    reg [WB_BURST_EXTENSION-1:0] m_wb_bte_o_reg;\n\n    // Define the address offset\n    reg [WB_ADDR_WIDTH-1:0] offset = 0;\n\n    // Define the FIFO full and empty flags\n    reg full_reg = 1'b0;\n    reg empty_reg = 1'b1;\n\n    // Define the read enable signal\n    reg rd = 1'b0;\n\n    // Define the FIFO read and write enable signals\n    reg wr_fifo = 1'b0;\n    reg rd_fifo = 1'b0;\n\n    // Define the clock and reset signals for the FIFO\n    reg sd_clk_reg;\n    reg rst_fifo = 1'b1;\n\n    // Define the state machine states\n    enum logic [2:0] {IDLE, FIFO_READ, WB_WRITE} state = IDLE;\n\n    // Define the state machine next state logic\n    always @(posedge clk) begin\n        case (state)\n            IDLE: begin\n                if (en && !full_reg) begin\n                    state = FIFO_READ;\n                end\n            end\n            FIFO_READ: begin\n                if (wr_fifo && !empty_reg) begin\n                    state = WB_WRITE;\n                end\n                else if (!wr_fifo || empty_reg) begin\n                    state = IDLE;\n                end\n            end\n            WB_WRITE: begin\n                if (m_wb_ack_i) begin\n                    state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // Define the state machine output logic\n    always @(posedge clk) begin\n        case (state)\n            IDLE: begin\n                m_wb_dat_o_reg <= 0;\n                m_wb_we_o_reg <= 0;\n                m_wb_cyc_o_reg <= 0;\n                m_wb_stb_o_reg <= 0;\n                m_wb_cti_o_reg <= 0;\n                m_wb_bte_o_reg <= 0;\n                offset <= 0;\n                full_reg <= 1'b0;\n                empty_reg <= 1'b1;\n                rd <= 1'b0;\n                wr_fifo <= 1'b0;\n                rd_fifo <= 1'b0;\n                rst_fifo <= 1'b1;\n            end\n            FIFO_READ: begin\n                m_wb_dat_o_reg <= fifo_data[rx_fifo_rd_ptr];\n                m_wb_we_o_reg <= 1'b1;\n                m_wb_cyc_o_reg <= 1'b1;\n                m_wb_stb_o_reg <= 1'b1;\n                m_wb_cti_o_reg <= 3'b000;\n                m_wb_bte_o_reg <= 2'b00;\n                offset <= offset + MEM_OFFSET;\n                full_reg <= 1'b0;\n                empty_reg <= 1'b0;\n                rd <= 1'b1;\n                wr_fifo <= 1'b1;\n                rd_fifo <= 1'b1;\n                rst_fifo <= 1'b0;\n            end\n            WB_WRITE: begin\n                m_wb_dat_o_reg <= 0;\n                m_wb_we_o_reg <= 0;\n                m_wb_cyc_o_reg <= 0;\n                m_wb_stb_o_reg <= 0;\n                m_wb_cti_o_reg <= 0;\n                m_wb_bte_o_reg <= 0;\n                offset <= offset + MEM_OFFSET;\n                full_reg <= 1'b0;\n                empty_reg <= 1'b1;\n                rd <= 1'b0;\n                wr_fifo <= 1'b0;\n                rd_fifo <= 1'b0;\n                rst_fifo <= 1'b1;\n            end\n        endcase\n    end\n\n    // Define the FIFO read and write logic\n    always @(posedge sd_clk) begin\n        if (rst_fifo) begin\n            fifo_data[rx_fifo_wr_ptr] <= 0;\n            rx_fifo_wr_ptr <= 0;\n            rx_fifo_rd_ptr <= 0;\n        end\n        else if (wr) begin\n            fifo_data[rx_fifo_wr_ptr] <= dat_i;\n            rx_fifo_wr_ptr <= rx_fifo_wr_ptr + 1;\n            if (rx_fifo_wr_ptr == FIFO_RX_MEM_DEPTH - 1) begin\n                rx_fifo_wr_ptr <= 0;\n            end\n        end\n        if (rd_fifo) begin\n            m_wb_dat_o <= fifo_data[rx_fifo_rd_ptr];\n            rx_fifo_rd_ptr <= rx_fifo_rd_ptr + 1;\n            if (rx_fifo_rd_ptr == FIFO_RX_MEM_DEPTH - 1) begin\n                rx_fifo_rd_ptr <= 0;\n            end\n        end\n    end\n\n    // Define the FIFO full and empty flags\n    assign full = full_reg;\n    assign empty = empty_reg;\n\n    // Define the Wishbone master output signals\n    assign m_wb_adr_o = offset;\n    assign m_wb_dat_o = m_wb_dat_o_reg;\n    assign m_wb_we_o = m_wb_we_o_reg;\n    assign m_wb_cyc_o = m_wb_cyc_o_reg;\n    assign m_wb_stb_o = m_wb_stb_o_reg;\n    assign m_wb_cti_o = m_wb_cti_o_reg;\n    assign m_wb_bte_o = m_wb_bte_o_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 12, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty,\n    output wire [FIFO_RX_MEM_ADR_SIZE-1:0] mem_empt\n);\n\n    // Define the FIFO module\n    sd_rx_fifo sd_rx_fifo(\n        .clk(clk),\n        .rst(rst),\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(1'b0),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt)\n    );\n\n    // Define the Wishbone master interface\n    assign m_wb_adr_o = adr;\n    assign m_wb_we_o = wr;\n    assign m_wb_cyc_o = 1'b1;\n    assign m_wb_stb_o = 1'b1;\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n\n    // Define the control logic\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] offset = 0;\n    reg [1:0] wb_free = 2'b11;\n    reg reset_rx_fifo = 1'b0;\n    reg rd = 1'b0;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            wb_free <= 2'b11;\n            reset_rx_fifo <= 1'b0;\n            rd <= 1'b0;\n        end else if (en) begin\n            if (reset_rx_fifo) begin\n                sd_rx_fifo.rst <= 1'b1;\n                rd <= 1'b0;\n            end else if (wb_free && !empty) begin\n                sd_rx_fifo.rd <= 1'b1;\n                wb_free <= 2'b00;\n            end else if (m_wb_ack_i) begin\n                sd_rx_fifo.rd <= 1'b0;\n                wb_free <= 2'b11;\n                offset <= offset + MEM_OFFSET;\n            end\n        end else begin\n            sd_rx_fifo.rst <= 1'b1;\n            rd <= 1'b0;\n            wb_free <= 2'b11;\n            offset <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 13, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty\n);\n\n    // Define the FIFO depth and address size\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\n    // Define the Wishbone bus parameters\n    localparam WB_DATA_WIDTH = 32;\n    localparam WB_ADDR_WIDTH = 32;\n    localparam WB_BURST_TYPE = 3;\n\n    // Define the memory offset\n    localparam MEM_OFFSET = 4;\n\n    // Define the FIFO module\n    sd_rx_fifo sd_rx_fifo(\n        .clk(clk),\n        .rst(rst),\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(1'b0),\n        .full(full),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(1'b0)\n    );\n\n    // Define the Wishbone master interface\n    wire [WB_DATA_WIDTH-1:0] wb_dat_o;\n    wire wb_we_o;\n    wire wb_cyc_o;\n    wire wb_stb_o;\n    wire wb_cti_o;\n    wire wb_bte_o;\n    wire wb_ack_i;\n\n    // Define the state machine\n    enum logic [2:0] {IDLE, READ_FIFO, WRITE_WB} state;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            state <= IDLE;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            wb_free <= 1'b1;\n            offset <= 32'd0;\n        end\n        else if (en) begin\n            case (state)\n                IDLE: begin\n                    if (wr && !full) begin\n                        state <= READ_FIFO;\n                    end\n                end\n                READ_FIFO: begin\n                    if (empty) begin\n                        state <= IDLE;\n                    end\n                    else begin\n                        m_wb_adr_o <= offset;\n                        m_wb_we_o <= 1'b1;\n                        m_wb_dat_o <= sd_rx_fifo.q;\n                        m_wb_cyc_o <= 1'b1;\n                        m_wb_stb_o <= 1'b1;\n                        m_wb_cti_o <= 3'b000;\n                        m_wb_bte_o <= 2'b00;\n                        wb_free <= 1'b0;\n                        offset <= offset + MEM_OFFSET;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Define the Wishbone bus interface\n    assign m_wb_ack_i = wb_ack_i;\n    assign wb_dat_o = m_wb_dat_o;\n    assign wb_we_o = m_wb_we_o;\n    assign wb_cyc_o = m_wb_cyc_o;\n    assign wb_stb_o = m_wb_stb_o;\n    assign wb_cti_o = m_wb_cti_o;\n    assign wb_bte_o = m_wb_bte_o;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 14, "code": "module sd_fifo_rx_filler(\n    input  clk,\n    input  rst,\n    output [31:0] m_wb_adr_o,\n    output  m_wb_we_o,\n    output  [31:0] m_wb_dat_o,\n    output  m_wb_cyc_o,\n    output  m_wb_stb_o,\n    input   m_wb_ack_i,\n    output  [2:0] m_wb_cti_o,\n    output  [1:0] m_wb_bte_o,\n    input   en,\n    input  [31:0] adr,\n    input   sd_clk,\n    input  [SD_BUS_W-1:0] dat_i,\n    input   wr,\n    output  full,\n    output  empty,\n    output  [FIFO_RX_MEM_ADR_SIZE-1:0] mem_empt\n);\n\n    // Define the FIFO module\n    sd_rx_fifo sd_rx_fifo(\n        .clk(clk),\n        .rst(rst),\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(1'b0), // rd is not used in this module\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt)\n    );\n\n    // Define the Wishbone master interface\n    reg [31:0] wb_adr;\n    reg wb_we;\n    reg [31:0] wb_dat;\n    reg wb_cyc;\n    reg wb_stb;\n    reg [2:0] wb_cti;\n    reg [1:0] wb_bte;\n    reg wb_ack;\n    reg wb_free;\n\n    // Initialize the Wishbone master interface\n    initial begin\n        wb_adr = 32'd0;\n        wb_we = 1'b0;\n        wb_dat = 32'd0;\n        wb_cyc = 1'b0;\n        wb_stb = 1'b0;\n        wb_cti = 3'b0;\n        wb_bte = 2'b0;\n        wb_ack = 1'b0;\n        wb_free = 1'b1;\n    end\n\n    // Clock domain crossing for sd_clk\n    reg [31:0] sd_dat;\n    always @(posedge sd_clk) begin\n        sd_dat <= dat_i;\n    end\n\n    // Wishbone master interface logic\n    always @(posedge clk) begin\n        if (rst) begin\n            wb_adr <= 32'd0;\n            wb_we <= 1'b0;\n            wb_dat <= 32'd0;\n            wb_cyc <= 1'b0;\n            wb_stb <= 1'b0;\n            wb_cti <= 3'b0;\n            wb_bte <= 2'b0;\n            wb_ack <= 1'b0;\n            wb_free <= 1'b1;\n        end else if (en && !wb_free) begin\n            wb_adr <= wb_adr + MEM_OFFSET;\n            wb_we <= 1'b1;\n            wb_dat <= sd_dat;\n            wb_cyc <= 1'b1;\n            wb_stb <= 1'b1;\n            wb_cti <= 3'b010;\n            wb_bte <= 2'b01;\n        end else if (m_wb_ack_i) begin\n            wb_adr <= wb_adr + MEM_OFFSET;\n            wb_we <= 1'b0;\n            wb_dat <= 32'd0;\n            wb_cyc <= 1'b0;\n            wb_stb <= 1'b0;\n            wb_cti <= 3'b0;\n            wb_bte <= 2'b0;\n            wb_ack <= 1'b1;\n            wb_free <= 1'b1;\n        end\n    end\n\n    // Output the Wishbone master interface signals\n    assign m_wb_adr_o = wb_adr;\n    assign m_wb_we_o = wb_we;\n    assign m_wb_dat_o = wb_dat;\n    assign m_wb_cyc_o = wb_cyc;\n    assign m_wb_stb_o = wb_stb;\n    assign m_wb_cti_o = wb_cti;\n    assign m_wb_bte_o = wb_bte;\n    assign wb_ack = wb_ack_i;\n\n    // Output the FIFO full and empty flags\n    assign full = sd_rx_fifo.full;\n    assign empty = sd_rx_fifo.empty;\n    assign mem_empt = sd_rx_fifo.mem_empt;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 15, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // FIFO\n    sd_rx_fifo sd_rx_fifo_i(\n       .clk(clk),\n       .rst(rst),\n       .d(dat_i),\n       .wr(wr),\n       .wclk(sd_clk),\n       .q(m_wb_dat_o),\n       .rd(rd),\n       .full(full),\n       .empty(empty),\n       .mem_empt(),\n       .rclk(),\n       .rst(reset_rx_fifo)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = adr + offset;\n    assign m_wb_we_o = wr;\n    assign m_wb_cyc_o = en;\n    assign m_wb_stb_o = en;\n    assign m_wb_cti_o = 3'b001;\n    assign m_wb_bte_o = 2'b00;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else if (en) begin\n            if (wb_free &&!empty) begin\n                rd <= 1;\n                wb_free <= 0;\n            end else if (m_wb_ack_i) begin\n                wb_free <= 1;\n                offset <= offset + MEM_OFFSET;\n            end\n        end else begin\n            reset_rx_fifo <= 1;\n            rd <= 0;\n            wb_free <= 1;\n            offset <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 1, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o\n);\n\n    // Wishbone master signals\n    reg [31:0] m_wb_adr;\n    reg m_wb_we;\n    reg [31:0] m_wb_dat;\n    reg m_wb_cyc;\n    reg m_wb_stb;\n    reg m_wb_ack;\n    reg [2:0] m_wb_cti;\n    reg [1:0] m_wb_bte;\n\n    // FIFO control signals\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // FIFO data and control signals\n    reg [31:0] din;\n    reg [31:0] q;\n    reg full;\n    reg empty;\n    reg [5:0] mem_empt;\n\n    // sd_tx_fifo module\n    sd_tx_fifo sd_tx_fifo(\n       .d(din),\n       .wr(wr_tx),\n       .wclk(clk),\n       .q(q),\n       .rd(rd),\n       .full(full),\n       .empty(empty),\n       .mem_empt(mem_empt),\n       .rclk(clk),\n       .rst(rst)\n    );\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr <= 0;\n            m_wb_we <= 0;\n            m_wb_dat <= 0;\n            m_wb_cyc <= 0;\n            m_wb_stb <= 0;\n            m_wb_ack <= 0;\n            m_wb_cti <= 0;\n            m_wb_bte <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n            din <= 0;\n            q <= 0;\n            full <= 0;\n            empty <= 0;\n            mem_empt <= 0;\n        end else begin\n            // Check if FIFO is not full and no ongoing Wishbone transaction\n            if (!full &&!m_wb_ack_i && first) begin\n                // Start Wishbone read transaction\n                m_wb_adr <= adr;\n                m_wb_we <= 1;\n                m_wb_dat <= m_wb_dat_i;\n                m_wb_cyc <= 1;\n                m_wb_stb <= 1;\n                m_wb_ack <= 0;\n                m_wb_cti <= 0;\n                m_wb_bte <= 0;\n                wr_tx <= 1;\n                reset_tx_fifo <= 0;\n                first <= 0;\n                ackd <= 0;\n                delay <= 0;\n                din <= m_wb_dat_i;\n            end\n\n            // Check if Wishbone acknowledges\n            if (m_wb_ack_i) begin\n                // Write data to FIFO\n                wr_tx <= 1;\n                din <= m_wb_dat_i;\n                // Deassert Wishbone signals\n                m_wb_cyc <= 0;\n                m_wb_stb <= 0;\n                m_wb_ack <= 0;\n                m_wb_cti <= 0;\n                m_wb_bte <= 0;\n                // Set delay flag for timing purposes\n                delay <= 1;\n            end\n\n            // Check if delay flag is set\n            if (delay) begin\n                // Increment memory address offset\n                m_wb_adr <= m_wb_adr + 1;\n                // Toggle acknowledge flag\n                ackd <= ~ackd;\n                // Stop writing to FIFO\n                wr_tx <= 0;\n                // Reset delay flag\n                delay <= 0;\n            end\n\n            // Check if disabled\n            if (!en) begin\n                // Reset TX FIFO\n                reset_tx_fifo <= 1;\n                // Reset address offset to 0\n                m_wb_adr <= 0;\n                // Set Wishbone control signals to inactive state\n                m_wb_cyc <= 0;\n                m_wb_stb <= 0;\n                m_wb_we <= 0;\n            end\n        end\n    end\n\n    // Assign outputs\n    assign dat_o = q;\n    assign empty = sd_tx_fifo.empty;\n    assign fe = sd_tx_fifo.full;\n    assign m_wb_adr_o = m_wb_adr;\n    assign m_wb_we_o = m_wb_we;\n    assign m_wb_dat_i = m_wb_dat;\n    assign m_wb_cyc_o = m_wb_cyc;\n    assign m_wb_stb_o = m_wb_stb;\n    assign m_wb_ack_i = m_wb_ack;\n    assign m_wb_cti_o = m_wb_cti;\n    assign m_wb_bte_o = m_wb_bte;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 2, "code": "module sd_fifo_tx_filler(\n    input  clk,\n    input  rst,\n    input  en,\n    input  [31:0] adr,\n    input  sd_clk,\n    input  [31:0] m_wb_dat_i,\n    output [31:0] m_wb_adr_o,\n    output        m_wb_we_o,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input  m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    output        dat_o,\n    input  rd,\n    output        empty,\n    output        fe,\n    output        wr_tx,\n    output        reset_tx_fifo,\n    output        first,\n    output        ackd,\n    output        delay\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // sd_tx_fifo module\n    sd_tx_fifo sd_tx_fifo(\n       .d(din),\n       .wr(wr_tx),\n       .wclk(clk),\n       .q(dat_o),\n       .rd(rd),\n       .full(fe),\n       .empty(empty),\n       .mem_empt(),\n       .rclk(clk),\n       .rst(reset_tx_fifo)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = offset;\n    assign m_wb_we_o = wr_tx;\n    assign m_wb_cyc_o = 1;\n    assign m_wb_stb_o = 1;\n    assign m_wb_cti_o = 3'b001;\n    assign m_wb_bte_o = 2'b01;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (!fe &&!m_wb_ack_i && ackd) begin\n                m_wb_dat_i <= din;\n                wr_tx <= 1;\n                din <= 0;\n                ackd <= 1;\n                delay <= 1;\n            end else if (m_wb_ack_i) begin\n                wr_tx <= 0;\n                ackd <= 0;\n                delay <= 0;\n                offset <= offset + 1;\n            end else if (delay) begin\n                delay <= 0;\n                ackd <= 1;\n            end\n        end else begin\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 3, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire m_wb_adr_o,\n    output wire m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe,\n    output wire wr_tx,\n    output wire reset_tx_fifo,\n    output wire first,\n    output wire ackd,\n    output wire delay\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // sd_tx_fifo instance\n    sd_tx_fifo sd_tx_fifo(\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = offset;\n    assign m_wb_we_o = we;\n    assign m_wb_cyc_o = 1;\n    assign m_wb_stb_o = 1;\n    assign m_wb_cti_o = 3'b001;\n    assign m_wb_bte_o = 2'b00;\n\n    // Control logic\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (!fe && !m_wb_ack_i && ackd) begin\n                // Start Wishbone read transaction\n                we <= 1;\n                offset <= offset + 1;\n                din <= m_wb_dat_i;\n                wr_tx <= 1;\n                ackd <= 1;\n            end else if (m_wb_ack_i) begin\n                // Write data to FIFO\n                sd_tx_fifo.wr <= 1;\n                sd_tx_fifo.d <= din;\n                wr_tx <= 0;\n                ackd <= 0;\n            end else if (delay) begin\n                // Increment address offset and toggle acknowledge flag\n                offset <= offset + 1;\n                ackd <= !ackd;\n                delay <= 0;\n            end\n        end else begin\n            // Disabled state handling\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end\n    end\n\n    // Delay flag\n    always @(posedge clk) begin\n        if (rst) begin\n            delay <= 0;\n        end else if (en) begin\n            if (wr_tx) begin\n                delay <= 1;\n            end else begin\n                delay <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 4, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire m_wb_adr_o,\n    output wire m_wb_we_o,\n    input  wire m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe,\n    output wire fe\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // sd_tx_fifo instance\n    sd_tx_fifo #(\n        .FIFO_RX_MEM_DEPTH(16),\n        .FIFO_RX_MEM_ADR_SIZE(5),\n        .FIFO_TX_MEM_DEPTH(16),\n        .FIFO_TX_MEM_ADR_SIZE(5)\n    ) sd_tx_fifo(\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = offset;\n    assign m_wb_we_o = wr_tx;\n    assign m_wb_dat_i = din;\n    assign m_wb_cyc_o = wr_tx;\n    assign m_wb_stb_o = wr_tx;\n    assign m_wb_ack_i = sd_tx_fifo.full;\n    assign m_wb_cti_o = 3'b001;\n    assign m_wb_bte_o = 2'b00;\n\n    // Control logic\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (sd_tx_fifo.full) begin\n                fe <= 1;\n            end else if (!m_wb_ack_i) begin\n                if (ackd) begin\n                    we <= we + 1;\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1;\n                    first <= 1;\n                    ackd <= 0;\n                end\n            end else if (m_wb_ack_i) begin\n                if (delay) begin\n                    offset <= offset + 1;\n                    wr_tx <= 0;\n                    ackd <= 1;\n                    delay <= 0;\n                end\n            end else begin\n                wr_tx <= 0;\n                ackd <= 0;\n            end\n        end else begin\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 5, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire m_wb_adr_o,\n    output wire m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe,\n    output wire wr_tx,\n    output wire reset_tx_fifo,\n    output wire first,\n    output wire ackd,\n    output wire delay\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // sd_tx_fifo module\n    sd_tx_fifo #(\n        .FIFO_RX_MEM_DEPTH(16),\n        .FIFO_RX_MEM_ADR_SIZE(5),\n        .FIFO_TX_MEM_DEPTH(16),\n        .FIFO_TX_MEM_ADR_SIZE(5)\n    ) sd_tx_fifo_i(\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Wishbone master interface\n    assign m_wb_adr_o = adr + offset;\n    assign m_wb_we_o = we;\n    assign m_wb_dat_i = din;\n    assign m_wb_cyc_o = 1;\n    assign m_wb_stb_o = 1;\n    assign m_wb_cti_o = 3'b001;\n    assign m_wb_bte_o = 2'b00;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (!fe && !m_wb_ack_i && ackd) begin\n                we <= 1;\n                din <= m_wb_dat_i;\n                wr_tx <= 1;\n                reset_tx_fifo <= 0;\n                first <= 1;\n                ackd <= 0;\n            end else if (m_wb_ack_i) begin\n                wr_tx <= 0;\n                ackd <= 1;\n                delay <= 1;\n            end else if (delay) begin\n                offset <= offset + 1;\n                ackd <= 0;\n                delay <= 0;\n            end\n        end else begin\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 6, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire m_wb_adr_o,\n    output wire m_wb_we_o,\n    input  wire m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // sd_tx_fifo module\n    sd_tx_fifo sd_tx_fifo_inst(\n       .d(din),\n       .wr(wr_tx),\n       .wclk(clk),\n       .q(dat_o),\n       .rd(rd),\n       .full(fe),\n       .empty(empty),\n       .mem_empt(mem_empt),\n       .rclk(clk),\n       .rst(rst)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = offset;\n    assign m_wb_we_o = wr_tx;\n    assign m_wb_dat_i = din;\n    assign m_wb_cyc_o = wr_tx;\n    assign m_wb_stb_o = wr_tx;\n    assign m_wb_ack_i = 1'b1;\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            if (en) begin\n                if (!fe &&!m_wb_ack_i && ackd) begin\n                    we <= we + 1;\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1;\n                    reset_tx_fifo <= 0;\n                    first <= 1;\n                    ackd <= 0;\n                end else if (m_wb_ack_i) begin\n                    wr_tx <= 0;\n                    delay <= 1;\n                    ackd <= 1;\n                end else if (delay) begin\n                    offset <= offset + 1;\n                    delay <= 0;\n                    ackd <= 0;\n                end\n            end else begin\n                reset_tx_fifo <= 1;\n                offset <= 0;\n                we <= 0;\n                din <= 0;\n                wr_tx <= 0;\n                first <= 0;\n                ackd <= 0;\n                delay <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 7, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [31:0] m_wb_dat_i,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // sd_tx_fifo module\n    sd_tx_fifo sd_tx_fifo_i(\n       .d(din),\n       .wr(wr_tx),\n       .wclk(clk),\n       .q(dat_o),\n       .rd(rd),\n       .full(fe),\n       .empty(empty),\n       .mem_empt(),\n       .rclk(clk),\n       .rst(rst)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = offset;\n    assign m_wb_we_o = wr_tx;\n    assign m_wb_cyc_o = 1;\n    assign m_wb_stb_o = 1;\n    assign m_wb_cti_o = 3'b010;\n    assign m_wb_bte_o = 2'b01;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (m_wb_ack_i &&!ackd) begin\n                wr_tx <= 1;\n                din <= m_wb_dat_i;\n                ackd <= 1;\n            end else if (ackd &&!delay) begin\n                offset <= offset + 1;\n                ackd <= 0;\n                delay <= 1;\n            end else if (delay) begin\n                delay <= 0;\n            end\n        end else begin\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 8, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire m_wb_adr_o,\n    output wire m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe,\n    output wire fe\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // sd_tx_fifo module\n    sd_tx_fifo #(\n        .FIFO_TX_MEM_DEPTH(256) // Assuming a 256-word FIFO\n    ) sd_tx_fifo(\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = offset;\n    assign m_wb_we_o = wr_tx;\n    assign m_wb_dat_i = din;\n    assign m_wb_cyc_o = 1;\n    assign m_wb_stb_o = 1;\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (m_wb_ack_i && ackd) begin\n                wr_tx <= 1;\n                din <= m_wb_dat_i;\n                we <= we + 1;\n                first <= 0;\n                ackd <= 0;\n            end else if (delay) begin\n                delay <= 0;\n                we <= we + 1;\n                first <= 1;\n            end else if (first) begin\n                first <= 0;\n                ackd <= 1;\n            end else if (we >= 9) begin\n                wr_tx <= 0;\n                we <= 0;\n                ackd <= 0;\n            end\n        end else begin\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 9, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [31:0] m_wb_dat_i,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // sd_tx_fifo instance\n    sd_tx_fifo sd_tx_fifo_i(\n       .d(m_wb_dat_i),\n       .wr(wr_tx),\n       .wclk(clk),\n       .q(dat_o),\n       .rd(rd),\n       .full(fe),\n       .empty(empty),\n       .mem_empt(),\n       .rclk(clk),\n       .rst(rst)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = offset;\n    assign m_wb_we_o = wr_tx;\n    assign m_wb_cyc_o = 1;\n    assign m_wb_stb_o = 1;\n    assign m_wb_cti_o = 3'b010;\n    assign m_wb_bte_o = 2'b01;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (!fe &&!m_wb_ack_i && ackd) begin\n                wr_tx <= 1;\n                din <= m_wb_dat_i;\n            end\n            if (m_wb_ack_i) begin\n                wr_tx <= 0;\n                ackd <= 1;\n            end\n            if (delay) begin\n                ackd <= 0;\n                delay <= 0;\n                offset <= offset + 1;\n            end\n        end else begin\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 10, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [31:0] m_wb_dat_i,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // sd_tx_fifo instance\n    sd_tx_fifo sd_tx_fifo_inst(\n       .d(din),\n       .wr(wr_tx),\n       .wclk(clk),\n       .q(dat_o),\n       .rd(rd),\n       .full(fe),\n       .empty(empty),\n       .mem_empt(),\n       .rclk(clk),\n       .rst(reset_tx_fifo)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = offset;\n    assign m_wb_we_o = wr_tx;\n    assign m_wb_cyc_o = 1;\n    assign m_wb_stb_o = 1;\n    assign m_wb_cti_o = 3'b001;\n    assign m_wb_bte_o = 2'b00;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (!fe &&!m_wb_ack_i && ackd) begin\n                // Start Wishbone read transaction\n                m_wb_dat_i <= din;\n                wr_tx <= 1;\n                din <= 0;\n                ackd <= 1;\n            end else if (m_wb_ack_i) begin\n                // Write data to FIFO\n                din <= m_wb_dat_i;\n                wr_tx <= 0;\n                ackd <= 0;\n            end else if (delay) begin\n                // Increment memory address offset\n                offset <= offset + 1;\n                delay <= 0;\n            end\n        end else begin\n            // Reset TX FIFO\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 11, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire m_wb_adr_o,\n    output wire m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe,\n    output wire fe,\n    output wire fe\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // sd_tx_fifo module\n    sd_tx_fifo #(\n        .FIFO_RX_MEM_DEPTH(16),\n        .FIFO_RX_MEM_ADR_SIZE(5),\n        .FIFO_TX_MEM_DEPTH(16),\n        .FIFO_TX_MEM_ADR_SIZE(5)\n    ) sd_tx_fifo(\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = offset;\n    assign m_wb_we_o = wr_tx;\n    assign m_wb_dat_i = din;\n    assign m_wb_cyc_o = wr_tx;\n    assign m_wb_stb_o = wr_tx;\n    assign m_wb_ack_i = m_wb_ack_i;\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n\n    // Control logic\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (!fe && !m_wb_ack_i && ackd) begin\n                m_wb_cyc_o <= 1;\n                m_wb_stb_o <= 1;\n                m_wb_we_o <= 1;\n                din <= m_wb_dat_i;\n                wr_tx <= 1;\n                ackd <= 1;\n            end else if (m_wb_ack_i) begin\n                wr_tx <= 0;\n                ackd <= 0;\n                delay <= 1;\n            end else if (delay) begin\n                offset <= offset + 1;\n                delay <= 0;\n            end\n        end else begin\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 12, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] m_wb_adr_i,\n    input  wire m_wb_we_i,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input  wire sd_clk,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe,\n    output wire [31:0] offset,\n    output wire [8:0] we,\n    output wire wr_tx,\n    output wire reset_tx_fifo,\n    output wire first,\n    output wire ackd,\n    output wire delay\n);\n\n    // Registers\n    reg [8:0] offset_reg;\n    reg [8:0] we_reg;\n    reg [31:0] din;\n    reg wr_tx_reg;\n    reg reset_tx_fifo_reg;\n    reg first_reg;\n    reg ackd_reg;\n    reg delay_reg;\n\n    // FIFO\n    sd_tx_fifo #(\n        .FIFO_RX_MEM_DEPTH(256),\n        .FIFO_RX_MEM_ADR_SIZE(9),\n        .FIFO_TX_MEM_DEPTH(256),\n        .FIFO_TX_MEM_ADR_SIZE(9)\n    ) sd_tx_fifo_i(\n        .d(m_wb_dat_i),\n        .wr(m_wb_we_i),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset_reg <= 0;\n            we_reg <= 0;\n            din <= 0;\n            wr_tx_reg <= 0;\n            reset_tx_fifo_reg <= 0;\n            first_reg <= 0;\n            ackd_reg <= 0;\n            delay_reg <= 0;\n        end else if (en) begin\n            if (!fe && !m_wb_ack_i && ackd_reg) begin\n                m_wb_cyc_o <= 1;\n                m_wb_stb_o <= 1;\n                m_wb_we_o <= m_wb_we_i;\n                m_wb_dat_o <= din;\n                m_wb_cti_o <= 3'b001;\n                m_wb_bte_o <= 2'b00;\n                we_reg <= we_reg + 1;\n                din <= m_wb_dat_i;\n                wr_tx_reg <= 1;\n                ackd_reg <= 1;\n                delay_reg <= 1;\n            end else if (m_wb_ack_i) begin\n                wr_tx_reg <= 0;\n                ackd_reg <= 0;\n                delay_reg <= 0;\n                offset_reg <= offset_reg + 1;\n            end\n        end else begin\n            reset_tx_fifo_reg <= 1;\n            offset_reg <= 0;\n            we_reg <= 0;\n            din <= 0;\n            wr_tx_reg <= 0;\n            first_reg <= 0;\n            ackd_reg <= 0;\n            delay_reg <= 0;\n        end\n    end\n\n    // Output signals\n    assign m_wb_adr_o = offset_reg;\n    assign m_wb_dat_o = din;\n    assign dat_o = sd_tx_fifo_i.q;\n    assign empty = sd_tx_fifo_i.empty;\n    assign fe = sd_tx_fifo_i.full;\n    assign first = first_reg;\n    assign ackd = ackd_reg;\n    assign delay = delay_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 13, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire m_wb_ack_i,\n    output wire m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    output wire [31:0] dat_o,\n    output wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // sd_tx_fifo module\n    sd_tx_fifo #(\n        .BD_WIDTH(BD_WIDTH),\n        .BD_SIZE(BD_SIZE),\n        .RAM_MEM_WIDTH(RAM_MEM_WIDTH),\n        .RESEND_MAX_CNT(RESEND_MAX_CNT),\n        .MEM_OFFSET(MEM_OFFSET),\n        .RESET_CLK_DIV(RESET_CLK_DIV),\n        .SD_CLK_BUS_CLK(SD_CLK_BUS_CLK),\n        .SD_CLK_SEP(SD_CLK_SEP),\n        .SD_CLK_STATIC(SD_CLK_STATIC),\n        .SD_CLK_DYNAMIC(SD_CLK_DYNAMIC),\n        .BLOCK_SIZE(BLOCK_SIZE),\n        .SD_BUS_WIDTH_4(SD_BUS_WIDTH_4),\n        .SD_BUS_W(SD_BUS_W),\n        .FIFO_RX_MEM_DEPTH(FIFO_RX_MEM_DEPTH),\n        .FIFO_RX_MEM_ADR_SIZE(FIFO_RX_MEM_ADR_SIZE),\n        .FIFO_TX_MEM_DEPTH(FIFO_TX_MEM_DEPTH),\n        .FIFO_TX_MEM_ADR_SIZE(FIFO_TX_MEM_ADR_SIZE)\n    ) sd_tx_fifo_i(\n        .clk(clk),\n        .rst(rst),\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = offset;\n    assign m_wb_we_o = wr_tx;\n    assign m_wb_cyc_o = 1;\n    assign m_wb_stb_o = 1;\n    assign m_wb_cti_o = 3'b001;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_dat_i = din;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (m_wb_ack_i && !ackd) begin\n                wr_tx <= 1;\n                din <= m_wb_dat_i;\n                ackd <= 1;\n            end else if (delay) begin\n                offset <= offset + 1;\n                ackd <= 0;\n                delay <= 0;\n            end else if (wr_tx) begin\n                wr_tx <= 0;\n                delay <= 1;\n            end\n        end else begin\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 14, "code": "module sd_fifo_tx_filler(\n    input  clk,\n    input  rst,\n    input  en,\n    input  [31:0] adr,\n    input  sd_clk,\n    input  [31:0] m_wb_dat_i,\n    output [31:0] m_wb_adr_o,\n    output [0:0]  m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    output [0:0]  m_wb_cyc_o,\n    output [0:0]  m_wb_stb_o,\n    input  m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    output [31:0] dat_o,\n    input  rd,\n    output [0:0]  empty,\n    output [0:0]  fe,\n    output [31:0] din,\n    output [0:0]  wr_tx,\n    output [0:0]  reset_tx_fifo,\n    output [0:0]  first,\n    output [0:0]  ackd,\n    output [0:0]  delay\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg [0:0] wr_tx;\n    reg [0:0] reset_tx_fifo;\n    reg [0:0] first;\n    reg [0:0] ackd;\n    reg [0:0] delay;\n\n    // FIFO\n    sd_tx_fifo #(\n        .FIFO_RX_MEM_DEPTH(32),\n        .FIFO_RX_MEM_ADR_SIZE(5),\n        .FIFO_TX_MEM_DEPTH(32),\n        .FIFO_TX_MEM_ADR_SIZE(5)\n    ) sd_tx_fifo_i(\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = {adr, offset};\n    assign m_wb_we_o = wr_tx;\n    assign m_wb_dat_o = din;\n    assign m_wb_cyc_o = (en && !m_wb_ack_i && !first);\n    assign m_wb_stb_o = m_wb_cyc_o;\n    assign m_wb_cti_o = 3'b001;\n    assign m_wb_bte_o = 2'b00;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (m_wb_ack_i) begin\n                wr_tx <= 0;\n                din <= m_wb_dat_i;\n                first <= 1;\n                ackd <= 1;\n                delay <= 1;\n            end else if (delay) begin\n                offset <= offset + 1;\n                ackd <= 0;\n                delay <= 0;\n            end\n        end\n    end\n\n    // Control signals\n    assign wr_tx = (en && !m_wb_ack_i && !first);\n    assign reset_tx_fifo = (en && !m_wb_ack_i && first);\n    assign first = (m_wb_ack_i && !delay);\n    assign ackd = (m_wb_ack_i && !delay);\n    assign delay = (m_wb_ack_i && !first);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 15, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire m_wb_adr_o,\n    output wire m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe,\n    output wire [5:0] mem_empt,\n    output wire wr_tx,\n    output wire reset_tx_fifo,\n    output wire first,\n    output wire ackd,\n    output wire delay\n);\n\n    // Define the FIFO module\n    sd_tx_fifo #(\n        .FIFO_TX_MEM_DEPTH(256) // Assuming a 256-word FIFO\n    ) sd_tx_fifo(\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Define the Wishbone master interface\n    wire [31:0] wb_dat_o;\n    wire wb_we_o;\n    wire wb_cyc_o;\n    wire wb_stb_o;\n    wire wb_cti_o;\n    wire wb_bte_o;\n\n    assign m_wb_adr_o = adr;\n    assign m_wb_we_o = wb_we_o;\n    assign m_wb_dat_o = wb_dat_o;\n    assign m_wb_cyc_o = wb_cyc_o;\n    assign m_wb_stb_o = wb_stb_o;\n    assign m_wb_cti_o = wb_cti_o;\n    assign m_wb_bte_o = wb_bte_o;\n\n    // Define the control logic\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx_reg;\n    reg reset_tx_fifo_reg;\n    reg first_reg;\n    reg ackd_reg;\n    reg delay_reg;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx_reg <= 0;\n            reset_tx_fifo_reg <= 0;\n            first_reg <= 0;\n            ackd_reg <= 0;\n            delay_reg <= 0;\n        end else begin\n            if (en) begin\n                if (m_wb_ack_i && !ackd_reg) begin\n                    din <= m_wb_dat_i;\n                    wr_tx_reg <= 1;\n                    ackd_reg <= 1;\n                end\n                if (wr_tx_reg) begin\n                    sd_tx_fifo.wr <= 1;\n                    sd_tx_fifo.d <= din;\n                    wr_tx_reg <= 0;\n                    ackd_reg <= 0;\n                    delay_reg <= 1;\n                end\n                if (delay_reg) begin\n                    offset <= offset + 1;\n                    delay_reg <= 0;\n                end\n            end else begin\n                sd_tx_fifo.wr <= 0;\n                reset_tx_fifo_reg <= 1;\n                first_reg <= 0;\n                ackd_reg <= 0;\n                delay_reg <= 0;\n            end\n        end\n    end\n\n    // Define the output signals\n    assign empty = sd_tx_fifo.empty;\n    assign fe = sd_tx_fifo.full;\n    assign mem_empt = sd_tx_fifo.mem_empt;\n    assign wr_tx = wr_tx_reg;\n    assign reset_tx_fifo = reset_tx_fifo_reg;\n    assign first = first_reg;\n    assign ackd = ackd_reg;\n    assign delay = delay_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 16, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] m_wb_adr_i,\n    input  wire m_wb_we_i,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input  wire sd_clk,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe,\n    output wire [31:0] din,\n    output wire wr_tx,\n    output wire reset_tx_fifo,\n    output wire first,\n    output wire ackd,\n    output wire delay\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // FIFO\n    sd_tx_fifo fifo(\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Wishbone Master Interface\n    assign m_wb_adr_o = m_wb_adr_i;\n    assign m_wb_we_o = m_wb_we_i;\n    assign m_wb_dat_o = din;\n    assign m_wb_stb_o = wr_tx;\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n\n    // State Machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (!fe && !m_wb_ack_i && ackd) begin\n                m_wb_cyc_o <= 1;\n                m_wb_stb_o <= 1;\n                wr_tx <= 1;\n                din <= m_wb_dat_i;\n                ackd <= 1;\n            end else if (m_wb_ack_i) begin\n                wr_tx <= 0;\n                ackd <= 0;\n                delay <= 1;\n            end else if (delay) begin\n                offset <= offset + 1;\n                delay <= 0;\n            end\n        end else begin\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 17, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [31:0] m_wb_dat_i,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe,\n    output wire [31:0] din,\n    output wire wr_tx,\n    output wire reset_tx_fifo,\n    output wire first,\n    output wire ackd,\n    output wire delay\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // sd_tx_fifo module\n    sd_tx_fifo sd_tx_fifo(\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = adr + offset;\n    assign m_wb_we_o = wr_tx;\n    assign m_wb_cyc_o = 1;\n    assign m_wb_stb_o = 1;\n    assign m_wb_cti_o = 3'b001;\n    assign m_wb_bte_o = 2'b01;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (m_wb_ack_i && !ackd) begin\n                wr_tx <= 1;\n                din <= m_wb_dat_i;\n                ackd <= 1;\n                delay <= 1;\n            end else if (delay) begin\n                offset <= offset + 1;\n                ackd <= 0;\n                delay <= 0;\n            end\n        end else begin\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 18, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] m_wb_adr_i,\n    input  wire m_wb_we_i,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    output wire [31:0] dat_o,\n    input  wire sd_clk,\n    input  wire rd,\n    output wire empty,\n    output wire fe,\n    output wire [31:0] din,\n    output wire wr_tx,\n    output wire reset_tx_fifo,\n    output wire first,\n    output wire ackd,\n    output wire delay\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // FIFO\n    sd_tx_fifo #(\n        .FIFO_RX_MEM_DEPTH(16),\n        .FIFO_TX_MEM_DEPTH(16)\n    ) sd_tx_fifo_i(\n        .d(m_wb_dat_i),\n        .wr(m_wb_we_i),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Wishbone interface\n    assign m_wb_cyc_o = 1'b1;\n    assign m_wb_stb_o = 1'b1;\n    assign m_wb_we_o = wr_tx;\n    assign m_wb_dat_o = din;\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (!fe && !m_wb_ack_i && ackd) begin\n                // Start new Wishbone transaction\n                m_wb_adr_o <= offset;\n                we <= 1;\n                din <= m_wb_dat_i;\n                wr_tx <= 1;\n                ackd <= 1;\n                delay <= 1;\n            end else if (m_wb_ack_i) begin\n                // Write data to FIFO\n                sd_tx_fifo_i.wr <= 1;\n                sd_tx_fifo_i.d <= din;\n                wr_tx <= 0;\n                ackd <= 0;\n                delay <= 0;\n            end else if (delay) begin\n                // Increment address offset and toggle acknowledge flag\n                offset <= offset + 1;\n                ackd <= ~ackd;\n                delay <= 0;\n            end\n        end else begin\n            // Disable state\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 19, "code": "module sd_fifo_tx_filler(\n    input  clk,\n    input  rst,\n    output [31:0] m_wb_adr_o,\n    output  m_wb_we_o,\n    input  [31:0] m_wb_dat_i,\n    output  m_wb_cyc_o,\n    output  m_wb_stb_o,\n    input  m_wb_ack_i,\n    output  m_wb_cti_o,\n    output  m_wb_bte_o,\n    input  en,\n    input  [31:0] adr,\n    input  sd_clk,\n    output  [31:0] dat_o,\n    input  rd,\n    output  empty,\n    output  fe,\n    output  wr_tx,\n    output  reset_tx_fifo,\n    output  first,\n    output  ackd,\n    output  delay\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // FIFO interface\n    wire [31:0] d;\n    wire wr;\n    wire wclk;\n    wire [31:0] q;\n    wire rd;\n    wire full;\n    wire empty;\n    wire [5:0] mem_empt;\n    wire rclk;\n    wire rst_fifo;\n\n    // sd_tx_fifo instance\n    sd_tx_fifo #(\n        .BD_WIDTH(BD_WIDTH),\n        .BD_SIZE(BD_SIZE),\n        .RAM_MEM_WIDTH(RAM_MEM_WIDTH),\n        .RESEND_MAX_CNT(RESEND_MAX_CNT),\n        .MEM_OFFSET(MEM_OFFSET),\n        .RESET_CLK_DIV(RESET_CLK_DIV),\n        .SD_CLK_BUS_CLK(SD_CLK_BUS_CLK),\n        .SD_CLK_SEP(SD_CLK_SEP),\n        .SD_CLK_STATIC(SD_CLK_STATIC),\n        .SD_CLK_DYNAMIC(SD_CLK_DYNAMIC),\n        .BLOCK_SIZE(BLOCK_SIZE),\n        .SD_BUS_WIDTH_4(SD_BUS_WIDTH_4),\n        .SD_BUS_W(SD_BUS_W),\n        .FIFO_RX_MEM_DEPTH(FIFO_RX_MEM_DEPTH),\n        .FIFO_RX_MEM_ADR_SIZE(FIFO_RX_MEM_ADR_SIZE),\n        .FIFO_TX_MEM_DEPTH(FIFO_TX_MEM_DEPTH),\n        .FIFO_TX_MEM_ADR_SIZE(FIFO_TX_MEM_ADR_SIZE)\n    ) sd_tx_fifo_i(\n        .d(d),\n        .wr(wr),\n        .wclk(wclk),\n        .q(q),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(rclk),\n        .rst(rst_fifo)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = adr + offset;\n    assign m_wb_we_o = wr_tx;\n    assign m_wb_dat_i = din;\n    assign m_wb_cyc_o = wr_tx;\n    assign m_wb_stb_o = wr_tx;\n    assign m_wb_cti_o = 3'b001;\n    assign m_wb_bte_o = 2'b00;\n\n    // Control logic\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 0;\n            first <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else if (en) begin\n            if (m_wb_ack_i && !full) begin\n                wr_tx <= 1;\n                din <= m_wb_dat_i;\n                offset <= offset + 1;\n                ackd <= 1;\n            end else if (wr_tx && !delay) begin\n                wr_tx <= 0;\n                ackd <= 0;\n            end\n        end\n    end\n\n    // FIFO control\n    assign wr = wr_tx;\n    assign wclk = sd_clk;\n    assign d = din;\n    assign rd = rd;\n    assign dat_o = q;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            fe <= 0;\n        end else if (en) begin\n            if (empty) begin\n                fe <= 1;\n            end else if (full) begin\n                fe <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 20, "code": "module sd_fifo_tx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [31:0] m_wb_dat_i,\n    output wire [31:0] dat_o,\n    output wire rd,\n    output wire empty,\n    output wire fe,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    output wire m_wb_we_o,\n    input  wire m_wb_ack_i,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_dat_o\n);\n\n    // Define the FIFO depth\n    localparam FIFO_TX_MEM_DEPTH = 16'd1024;\n\n    // Define the FIFO address size\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1;\n\n    // Define the Wishbone address offset\n    localparam OFFSET = 9'd0;\n\n    // Define the write enable counter\n    localparam WE = 9'd0;\n\n    // Define the data to be written to the FIFO\n    localparam DIN = 32'd0;\n\n    // Define the write control for the FIFO\n    localparam WR_TX = 1'd0;\n\n    // Define the TX FIFO reset control\n    localparam RESET_TX_FIFO = 1'd0;\n\n    // Define the first operation flag\n    localparam FIRST = 1'd0;\n\n    // Define the acknowledge delay flag\n    localparam ACKD = 1'd0;\n\n    // Define the delay flag for synchronization\n    localparam DELAY = 1'd0;\n\n    // Define the FIFO full flag\n    reg fe;\n\n    // Define the FIFO empty flag\n    reg empty;\n\n    // Define the FIFO occupancy\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] mem_empt;\n\n    // Define the TX FIFO\n    sd_tx_fifo sd_tx_fifo(\n       .d(m_wb_dat_i),\n       .wr(WR_TX),\n       .wclk(clk),\n       .q(dat_o),\n       .rd(rd),\n       .full(fe),\n       .empty(empty),\n       .mem_empt(mem_empt),\n       .rclk(clk),\n       .rst(RESET_TX_FIFO)\n    );\n\n    // Define the control logic\n    always @(posedge clk) begin\n        if (rst) begin\n            // Reset all control signals and counters\n            OFFSET <= 9'd0;\n            WE <= 9'd0;\n            DIN <= 32'd0;\n            WR_TX <= 1'd0;\n            RESET_TX_FIFO <= 1'd0;\n            FIRST <= 1'd0;\n            ACKD <= 1'd0;\n            DELAY <= 1'd0;\n            fe <= 1'd0;\n            empty <= 1'd0;\n            mem_empt <= 0;\n        end else if (en) begin\n            // Start a Wishbone read transaction if:\n            // - FIFO is not full (fe = 0)\n            // - No ongoing Wishbone transaction (m_wb_ack_i = 0)\n            // - Previous transaction is acknowledged (ackd = 1)\n            if (!fe &&!m_wb_ack_i && ACKD) begin\n                // Write data to FIFO (wr_tx = 1, din = m_wb_dat_i)\n                WR_TX <= 1'd1;\n                DIN <= m_wb_dat_i;\n                // Deassert Wishbone signals\n                m_wb_cyc_o <= 1'd0;\n                m_wb_stb_o <= 1'd0;\n                m_wb_we_o <= 1'd0;\n                // Set delay flag for timing purposes\n                DELAY <= 1'd1;\n            end else if (DELAY) begin\n                // Increment memory address offset\n                OFFSET <= OFFSET + 1;\n                // Toggle acknowledge flag (ackd)\n                ACKD <=!ACKD;\n                // Stop writing to FIFO (wr_tx = 0)\n                WR_TX <= 1'd0;\n                DELAY <= 1'd0;\n            end\n        end else begin\n            // Reset TX FIFO (reset_tx_fifo = 1)\n            RESET_TX_FIFO <= 1'd1;\n            // Reset address offset to 0\n            OFFSET <= 9'd0;\n            // Set Wishbone control signals to inactive state\n            m_wb_cyc_o <= 1'd0;\n            m_wb_stb_o <= 1'd0;\n            m_wb_we_o <= 1'd0;\n        end\n    end\n\n    // Define the Wishbone interface\n    assign m_wb_adr_o = {OFFSET, 23'b0};\n    assign m_wb_dat_o = DIN;\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_cyc_o = 1'd1;\n    assign m_wb_stb_o = 1'd1;\n    assign m_wb_we_o = 1'd1;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 1, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  rclk,\n    input  wire  rst,\n    input  wire  wr,\n    input  wire  [3:0] d,\n    output wire  [31:0] q,\n    input  wire  rd,\n    output wire  full,\n    output wire  empty,\n    output wire  [1:0] mem_empt,\n    output wire  ft\n);\n\n    parameter FIFO_RX_MEM_DEPTH = 256;\n    parameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n    reg ft;\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n        end\n        else if (wr) begin\n            tmp <= {tmp, d};\n            if (tmp[31:24] == 0) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n        end\n        else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_o == adr_i);\n    assign mem_empt = {adr_i[1], adr_i[0]};\n    assign ft = ft;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 2, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  rclk,\n    input  wire  rst,\n    input  wire  [3:0] d,\n    input  wire  wr,\n    output wire  [31:0] q,\n    input  wire  rd,\n    output wire  full,\n    output wire  empty,\n    output wire  [1:0] mem_empt,\n    output wire  ft\n);\n\n    parameter FIFO_RX_MEM_DEPTH = 256;\n    parameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n    reg ft;\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n        end\n        else if (wr) begin\n            tmp <= {tmp, d};\n            if (ft == 0) begin\n                ram[adr_i] <= tmp;\n                ft <= 1;\n            end\n            if (adr_i == FIFO_RX_MEM_DEPTH-1) begin\n                adr_i <= 0;\n                ft <= 0;\n            end\n            else begin\n                adr_i <= adr_i + 1;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end\n        else if (rd && !empty) begin\n            q <= ram[adr_o];\n            if (adr_o == FIFO_RX_MEM_DEPTH-1) begin\n                adr_o <= 0;\n            end\n            else begin\n                adr_o <= adr_o + 1;\n            end\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_o == adr_i);\n    assign mem_empt = {adr_o[FIFO_RX_MEM_ADR_SIZE-2:0], adr_i[FIFO_RX_MEM_ADR_SIZE-1]};\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 3, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  wr,\n    input  wire  d [3:0],\n    input  wire  rclk,\n    input  wire  rd,\n    output wire  q [31:0],\n    output wire  full,\n    output wire  empty,\n    output wire  mem_empt [1:0],\n    input  wire  rst\n);\n\n    // Registers\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // State machine\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n        end else if (wr) begin\n            tmp <= {tmp[27:0], d};\n            if (tmp[31:28] == 4'b0000) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                we <= 8'h1;\n                ft <= 0;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n        end else if (rd &&!empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\n    // Flags\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_o == adr_i);\n    assign mem_empt = {adr_i[1], adr_o[1]};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 4, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  rclk,\n    input  wire  rst,\n    input  wire  [3:0] d,\n    input  wire  wr,\n    output wire  [31:0] q,\n    input  wire  rd,\n    output wire  full,\n    output wire  empty,\n    output wire  [1:0] mem_empt,\n    output wire  ft\n);\n\n    parameter FIFO_RX_MEM_DEPTH = 256;\n    parameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n    reg ft;\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n        end\n        else if (wr) begin\n            tmp <= {tmp, d};\n            if (tmp[31:24] == 0) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n        end\n        else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_o == adr_i);\n    assign mem_empt = {adr_i[1:0], adr_o[1:0]};\n    assign ft = ft;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 5, "code": "module sd_rx_fifo(\n    input  wire        wclk,\n    input  wire        rclk,\n    input  wire        rst,\n    input  wire        wr,\n    input  wire [3:0]  d,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [1:0]  mem_empt,\n    output wire        ft\n);\n\n    parameter FIFO_RX_MEM_DEPTH = 256;\n    parameter FIFO_RX_MEM_ADR_SIZE = 8;\n\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n    reg ft;\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n        end\n        else if (wr) begin\n            tmp <= {tmp, d};\n            if (ft == 0) begin\n                ram[adr_i] <= tmp;\n                ft <= 1;\n                adr_i <= adr_i + 1;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end\n        else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_o == adr_i);\n    assign mem_empt = {adr_o[FIFO_RX_MEM_ADR_SIZE-2:1], adr_i[FIFO_RX_MEM_ADR_SIZE-1]};\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 6, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  rclk,\n    input  wire  rst,\n    input  wire  [3:0] d,\n    input  wire  wr,\n    input  wire  rd,\n    output wire  [31:0] q,\n    output wire  full,\n    output wire  empty,\n    output wire  [1:0] mem_empt,\n    output wire  ft\n);\n\n    // Define FIFO parameters\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    // Define RAM\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n    // Define write address\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n\n    // Define read address\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n\n    // Define write enable\n    reg [7:0] we;\n\n    // Define temporary storage\n    reg [31:0] tmp;\n\n    // Define data written flag\n    reg ft;\n\n    // Initialize RAM and addresses\n    initial begin\n        for (int i = 0; i < FIFO_RX_MEM_DEPTH; i++) begin\n            ram[i] = 32'd0;\n        end\n        adr_i = 0;\n        adr_o = 0;\n        we = 8'h1;\n        tmp = 32'd0;\n        ft = 0;\n    end\n\n    // Write operation\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 32'd0;\n            ft <= 0;\n        end else if (wr) begin\n            tmp <= {tmp[31:8], d};\n            if (tmp[31:24] == 32'd0) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                we <= 8'h1;\n                ft <= 1;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\n    // Full and empty flags\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == adr_o + 1);\n    assign mem_empt = {adr_i[1:0], ~adr_i[0]};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 7, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  wr,\n    input  wire  [3:0] d,\n    input  wire  rclk,\n    input  wire  rd,\n    output wire  q,\n    output wire  full,\n    output wire  empty,\n    output wire  [1:0] mem_empt,\n    input  wire  rst\n);\n\n    // Define the FIFO parameters\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    // Define the RAM\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n    // Define the write address\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n\n    // Define the read address\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n\n    // Define the write enable\n    reg [7:0] we;\n\n    // Define the temporary storage\n    reg [31:0] tmp;\n\n    // Define the data written flag\n    reg ft;\n\n    // Initialize the RAM\n    initial begin\n        for (int i = 0; i < FIFO_RX_MEM_DEPTH; i++) begin\n            ram[i] = 32'h00000000;\n        end\n    end\n\n    // Initialize the write address\n    initial begin\n        adr_i = 0;\n    end\n\n    // Initialize the read address\n    initial begin\n        adr_o = 0;\n    end\n\n    // Initialize the write enable\n    initial begin\n        we = 8'h1;\n    end\n\n    // Initialize the temporary storage\n    initial begin\n        tmp = 32'h00000000;\n    end\n\n    // Initialize the data written flag\n    initial begin\n        ft = 0;\n    end\n\n    // Write operation\n    always @(posedge wclk) begin\n        if (wr) begin\n            tmp[3:0] = d;\n            if (ft == 0) begin\n                ram[adr_i] = tmp;\n                ft = 1;\n            end else begin\n                tmp[31:24] = tmp[23:16];\n                tmp[23:16] = tmp[15:8];\n                tmp[15:8] = tmp[7:0];\n                tmp[7:0] = d;\n                ram[adr_i] = tmp;\n            end\n            adr_i = adr_i + 1;\n            if (adr_i == FIFO_RX_MEM_DEPTH) begin\n                adr_i = 0;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk) begin\n        if (rd &&!empty) begin\n            q = ram[adr_o];\n            adr_o = adr_o + 1;\n            if (adr_o == FIFO_RX_MEM_DEPTH) begin\n                adr_o = 0;\n            end\n        end\n    end\n\n    // Full flag\n    assign full = (adr_i == adr_o);\n\n    // Empty flag\n    assign empty = (adr_o == adr_i);\n\n    // Memory empty space\n    assign mem_empt = {adr_o, adr_i};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 8, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  rclk,\n    input  wire  rst,\n    input  wire  [3:0] d,\n    input  wire  wr,\n    input  wire  rd,\n    output wire  [31:0] q,\n    output wire  full,\n    output wire  empty,\n    output wire  [1:0] mem_empt\n);\n\n    parameter FIFO_RX_MEM_DEPTH = 256;\n    parameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n    parameter FIFO_TX_MEM_DEPTH = 256;\n    parameter FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH);\n\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n        end else if (wr) begin\n            tmp <= {tmp[31:8], d};\n            if (ft) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 0;\n            end else begin\n                ft <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end else if (rd &&!empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_o == adr_i);\n    assign mem_empt = {adr_o[1], adr_o[0]};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 9, "code": "module sd_rx_fifo(\n    input  wire        wclk,\n    input  wire        rclk,\n    input  wire        rst,\n    input  wire        wr,\n    input  wire [3:0]  d,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [1:0]  mem_empt,\n    output wire        ft\n);\n\n    parameter FIFO_RX_MEM_DEPTH = 256;\n    parameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n    reg ft;\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n            we <= 8'h1;\n        end\n        else if (wr) begin\n            tmp <= {tmp[27:0], d};\n            if (tmp[31] == 1'b1) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1'b1;\n                tmp <= 0;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n        end\n        else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_o == adr_i);\n    assign mem_empt = {adr_i[1:0], ~adr_i[0]};\n    assign ft = ft;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 10, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  wr,\n    input  wire  [3:0] d,\n    input  wire  rclk,\n    input  wire  rd,\n    output wire  [31:0] q,\n    output wire  full,\n    output wire  empty,\n    output wire  [1:0] mem_empt,\n    input  wire  rst\n);\n\n// Registers\nreg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\n// State machine\nreg [1:0] state;\n\n// State transition diagram\nalways @(posedge wclk) begin\n    if (rst) begin\n        state <= 2'b00;\n    end else if (wr) begin\n        case (state)\n            2'b00: begin\n                tmp <= d;\n                we <= 8'h1;\n                ft <= 0;\n                state <= 2'b01;\n            end\n            2'b01: begin\n                tmp <= {tmp, d};\n                if (tmp[31:24] == 8'h0) begin\n                    ram[adr_i] <= tmp;\n                    tmp <= 32'h0;\n                    ft <= 0;\n                    state <= 2'b00;\n                end\n            end\n        endcase\n    end\nend\n\nalways @(posedge rclk) begin\n    if (rst) begin\n        state <= 2'b00;\n    end else if (rd) begin\n        case (state)\n            2'b00: begin\n                q <= ram[adr_o];\n                state <= 2'b01;\n            end\n            2'b01: begin\n                adr_o <= adr_o + 1;\n                state <= 2'b00;\n            end\n        endcase\n    end\nend\n\n// Flags\nassign full = (adr_i == adr_o);\nassign empty = (adr_i == adr_o + FIFO_RX_MEM_DEPTH);\nassign mem_empt = {adr_i[1], adr_i[0]};\n\n// Output data\nassign q = ram[adr_o];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 11, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  rclk,\n    input  wire  rst,\n    input  wire  [3:0] d,\n    input  wire  wr,\n    output wire  [31:0] q,\n    input  wire  rd,\n    output wire  full,\n    output wire  empty,\n    output wire  [1:0] mem_empt,\n    output wire  ft\n);\n\n    // Define the FIFO size and address width\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    // Define the RAM\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n    // Define the write address\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n\n    // Define the read address\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n\n    // Define the write enable register\n    reg [7:0] we;\n\n    // Define the temporary storage register\n    reg [31:0] tmp;\n\n    // Define the data written flag\n    reg ft;\n\n    // Define the full and empty flags\n    wire full = (adr_i == adr_o);\n    wire empty = (adr_i == (adr_o + FIFO_RX_MEM_DEPTH));\n\n    // Define the memory empty space\n    wire [1:0] mem_empt = {FIFO_RX_MEM_DEPTH - adr_o, FIFO_RX_MEM_DEPTH - adr_i};\n\n    // Reset logic\n    always @(posedge rst)\n    begin\n        adr_i <= 0;\n        adr_o <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end\n\n    // Write logic\n    always @(posedge wclk)\n    begin\n        if (wr)\n        begin\n            tmp <= {tmp[27:0], d};\n            if (tmp[31:28] == 4'b0000)\n            begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n                tmp <= 0;\n            end\n        end\n    end\n\n    // Read logic\n    always @(posedge rclk)\n    begin\n        if (rd && !empty)\n        begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 12, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  wr,\n    input  wire  [3:0] d,\n    input  wire  rd,\n    output wire  [31:0] q,\n    output wire  full,\n    output wire  empty,\n    output wire  [1:0] mem_empt,\n    input  wire  rclk,\n    input  wire  rst\n);\n\n    // Define FIFO parameters\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    // Define registers\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // Define RAM\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n    // Define flags\n    wire full_flag;\n    wire empty_flag;\n\n    // Define memory empty space\n    wire [1:0] mem_empt_space;\n\n    // Define state machine\n    enum {IDLE, WRITE, READ} state;\n\n    // State machine logic\n    always @(posedge wclk) begin\n        case (state)\n            IDLE: begin\n                if (wr) begin\n                    state = WRITE;\n                end\n            end\n            WRITE: begin\n                if (we[0]) begin\n                    tmp = {tmp[31:24], d, 8'b0};\n                    if (tmp[31:0] == 32'b0) begin\n                        ft = 0;\n                    end\n                    if (tmp[31:0] == 32'hffff_ffff) begin\n                        ft = 1;\n                    end\n                    if (ft) begin\n                        ram[adr_i] = tmp;\n                        adr_i = adr_i + 1;\n                        we = 8'b0;\n                        state = IDLE;\n                    end\n                end\n            end\n            READ: begin\n                if (rd &&!empty_flag) begin\n                    q = ram[adr_o];\n                    adr_o = adr_o + 1;\n                    state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // Flag logic\n    assign full_flag = (adr_i == adr_o);\n    assign empty_flag = (adr_o == adr_i);\n    assign mem_empt_space = {adr_o[1:0], adr_i[1:0]};\n    assign full = full_flag;\n    assign empty = empty_flag;\n    assign mem_empt = mem_empt_space;\n\n    // Reset logic\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_i = 0;\n            adr_o = 0;\n            we = 8'h1;\n            tmp = 32'b0;\n            ft = 0;\n            for (int i = 0; i < FIFO_RX_MEM_DEPTH; i++) begin\n                ram[i] = 32'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 13, "code": "module sd_rx_fifo(\n    input  wire        wclk,\n    input  wire        rclk,\n    input  wire        rst,\n    input  wire        wr,\n    input  wire [3:0]  d,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [1:0]  mem_empt,\n    output wire        ft\n);\n\n    // Define FIFO parameters\n    localparam FIFO_RX_MEM_DEPTH = 16;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    // Define RAM\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n    // Define write address\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n\n    // Define read address\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n\n    // Define write enable\n    reg [7:0] we;\n\n    // Define temporary storage\n    reg [31:0] tmp;\n\n    // Define data written flag\n    reg ft;\n\n    // Initialize RAM and addresses\n    initial begin\n        for (int i = 0; i < FIFO_RX_MEM_DEPTH; i++) begin\n            ram[i] = 32'd0;\n        end\n        adr_i = 0;\n        adr_o = 0;\n        we = 8'h1;\n        tmp = 32'd0;\n        ft = 0;\n    end\n\n    // Write operation\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 32'd0;\n            ft <= 0;\n        end\n        else if (wr) begin\n            tmp <= {tmp[31:24], d, tmp[23:0]};\n            if (tmp[31:24] == 4'd0) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 32'd0;\n        end\n        else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\n    // Full and empty flags\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == adr_o + FIFO_RX_MEM_DEPTH);\n    assign mem_empt = {adr_i[1:0], ~adr_o[1:0]};\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 14, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  rclk,\n    input  wire  rst,\n    input  wire  [3:0] d,\n    input  wire  wr,\n    output wire  [31:0] q,\n    input  wire  rd,\n    output wire  full,\n    output wire  empty,\n    output wire  [1:0] mem_empt,\n    output wire  ft\n);\n\n    parameter FIFO_RX_MEM_DEPTH = 256;\n    parameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n    reg ft;\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n        end\n        else if (wr) begin\n            tmp <= {tmp[27:0], d};\n            if (ft == 0) begin\n                ram[adr_i] <= tmp;\n                ft <= 1;\n            end\n            if (ft == 1) begin\n                if (adr_i == FIFO_RX_MEM_DEPTH-1) begin\n                    adr_i <= 0;\n                    ft <= 0;\n                end\n                else begin\n                    adr_i <= adr_i + 1;\n                end\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end\n        else if (rd && !empty) begin\n            q <= ram[adr_o];\n            if (adr_o == FIFO_RX_MEM_DEPTH-1) begin\n                adr_o <= 0;\n            end\n            else begin\n                adr_o <= adr_o + 1;\n            end\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == adr_o && !ft);\n    assign mem_empt = {adr_i[1:0], adr_o[1:0]};\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 15, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  rclk,\n    input  wire  rst,\n    input  wire  wr,\n    input  wire  [3:0] d,\n    output wire  [31:0] q,\n    input  wire  rd,\n    output wire  full,\n    output wire  empty,\n    output wire  [1:0] mem_empt,\n    output wire  ft\n);\n\n    // Define the FIFO parameters\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    // Define the RAM\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n    // Define the write address\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n\n    // Define the read address\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n\n    // Define the write enable register\n    reg [7:0] we;\n\n    // Define the temporary storage register\n    reg [31:0] tmp;\n\n    // Define the data written flag\n    reg ft;\n\n    // Define the full flag\n    wire full = (adr_i == adr_o);\n\n    // Define the empty flag\n    wire empty = (adr_o == 0);\n\n    // Define the memory empty space\n    wire [1:0] mem_empt = {adr_o, adr_i};\n\n    // Write operation\n    always @(posedge wclk)\n    begin\n        if (wr)\n        begin\n            // Accumulate data in tmp\n            tmp[3:0] <= d;\n            tmp[7:4] <= tmp[3:0];\n            tmp[11:8] <= tmp[7:4];\n            tmp[15:12] <= tmp[11:8];\n            tmp[19:16] <= tmp[15:12];\n            tmp[23:20] <= tmp[19:16];\n            tmp[27:24] <= tmp[23:20];\n            tmp[31:28] <= tmp[27:24];\n\n            // Write to RAM\n            if (tmp[31:28] == 0)\n            begin\n                ram[adr_i] <= tmp;\n                ft <= 1;\n                adr_i <= adr_i + 1;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk)\n    begin\n        if (rd && !empty)\n        begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\n    // Reset\n    always @(posedge rst)\n    begin\n        adr_i <= 0;\n        adr_o <= 0;\n        tmp <= 0;\n        ft <= 0;\n        we <= 8'h1;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 16, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  wr,\n    input  wire  d [3:0],\n    input  wire  rst,\n    input  wire  rd,\n    output wire  q [31:0],\n    output wire  full,\n    output wire  empty,\n    output wire  mem_empt [1:0],\n    input  wire  rclk\n);\n\n    parameter FIFO_RX_MEM_DEPTH = 256;\n    parameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n    assign q = ram[adr_o];\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n            we <= 8'h1;\n        end else if (wr) begin\n            tmp <= {tmp[27:0], d};\n            if (ft) begin\n                ram[adr_i] <= tmp;\n                tmp <= 0;\n                ft <= 0;\n                we <= 8'h1;\n                adr_i <= adr_i + 1;\n            end else begin\n                we <= we + 1;\n                if (we == 8'h10) begin\n                    tmp <= 0;\n                    ft <= 1;\n                end\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end else if (rd &&!empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_o == adr_i + FIFO_RX_MEM_DEPTH);\n    assign mem_empt = {adr_o[FIFO_RX_MEM_ADR_SIZE-1], adr_i[FIFO_RX_MEM_ADR_SIZE-1]};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 17, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  wr,\n    input  wire  [3:0] d,\n    input  wire  rst,\n    input  wire  rclk,\n    input  wire  rd,\n    output wire  [31:0] q,\n    output wire  full,\n    output wire  empty,\n    output wire  [1:0] mem_empt\n);\n\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_ADR_SIZE = 8;\n\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n    assign q = ram[adr_o];\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == (adr_o + FIFO_RX_MEM_DEPTH - 1));\n    assign mem_empt = {1'b0, adr_i[1:0]};\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n            we <= 0;\n        end else if (wr) begin\n            tmp <= tmp | (d << ft);\n            if (tmp[31]) begin\n                ram[adr_i] <= tmp;\n                tmp <= 0;\n                ft <= 0;\n                we <= 0;\n                adr_i <= adr_i + 1;\n            end else begin\n                we <= we | (1 << ft);\n                ft <= ft + 1;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end else if (rd &&!full) begin\n            ram[adr_o] <= 0;\n            adr_o <= adr_o + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 18, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  wr,\n    input  wire  [3:0] d,\n    output wire  q,\n    input  wire  rd,\n    output wire  full,\n    output wire  empty,\n    output wire  [1:0] mem_empt,\n    input  wire  rclk,\n    input  wire  rst\n);\n\n    // Define the FIFO depth and address size\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    // Define the RAM\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n    // Define the write address\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n\n    // Define the read address\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n\n    // Define the write enable\n    reg [7:0] we;\n\n    // Define the temporary storage\n    reg [31:0] tmp;\n\n    // Define the data written flag\n    reg ft;\n\n    // Define the full flag\n    wire full = (adr_i == adr_o);\n\n    // Define the empty flag\n    wire empty = (adr_o == adr_i);\n\n    // Define the memory empty space\n    wire [1:0] mem_empt = {adr_o[1], adr_o[0]};\n\n    // Reset the FIFO\n    always @(posedge rst)\n    begin\n        adr_i <= 0;\n        adr_o <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end\n\n    // Write operation\n    always @(posedge wclk)\n    begin\n        if (wr)\n        begin\n            tmp <= {tmp[27:0], d};\n            if (tmp[31:28] == 4'b1000)\n            begin\n                ram[adr_i] <= tmp;\n                ft <= 1;\n                adr_i <= adr_i + 1;\n                we <= 8'h0;\n                tmp <= 0;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk)\n    begin\n        if (rd && !empty)\n        begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 1, "code": "module sd_tx_fifo(\n    input  wire  wclk,\n    input  wire  rst,\n    input  wire  wr,\n    input  wire  [31:0] d,\n    output wire  q,\n    input  wire  rd,\n    output wire  full,\n    output wire  empty,\n    output wire  [5:0] mem_empt,\n    input  wire  rclk\n);\n\n    parameter FIFO_TX_MEM_DEPTH = 256;\n    parameter FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH);\n\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n    reg [31:0] q_reg;\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n                adr_i <= 0;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end else if (rd && !empty) begin\n            q_reg <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n                adr_o <= 0;\n            end\n        end\n    end\n\n    assign q = q_reg;\n\n    always @(*) begin\n        full = (adr_i == adr_o);\n        empty = (adr_i == adr_o + 1);\n        mem_empt = $signed'(adr_i - adr_o);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 2, "code": "module sd_tx_fifo(\n    input  wire        wclk,\n    input  wire        rclk,\n    input  wire        rst,\n    input  wire        wr,\n    input  wire [31:0] d,\n    output wire [31:0] q,\n    output wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt,\n    output wire        adr_o,\n    input  wire [5:0]  adr_i\n);\n\n    // Define FIFO parameters\n    localparam FIFO_TX_MEM_DEPTH = 1024;\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH);\n\n    // Define RAM\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n    // Define write and read pointers\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] wr_ptr;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] rd_ptr;\n\n    // Define FIFO full and empty flags\n    reg full;\n    reg empty;\n\n    // Define FIFO occupancy\n    reg [5:0] mem_empt;\n\n    // Define read and write enable signals\n    reg wr_en;\n    reg rd_en;\n\n    // Define write and read addresses\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] wr_addr;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] rd_addr;\n\n    // Define data output\n    reg [31:0] data_out;\n\n    // Write operation\n    always @(posedge wclk) begin\n        if (rst) begin\n            wr_ptr <= 0;\n            wr_addr <= 0;\n        end\n        else if (wr && !full) begin\n            ram[wr_addr] <= d;\n            wr_ptr <= wr_ptr + 1;\n            if (wr_ptr == FIFO_TX_MEM_DEPTH-1) begin\n                wr_ptr <= 0;\n            end\n            wr_addr <= wr_addr + 1;\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk) begin\n        if (rst) begin\n            rd_ptr <= 0;\n            rd_addr <= 0;\n        end\n        else if (rd && !empty) begin\n            data_out <= ram[rd_addr];\n            rd_ptr <= rd_ptr + 1;\n            if (rd_ptr == FIFO_TX_MEM_DEPTH-1) begin\n                rd_ptr <= 0;\n            end\n            rd_addr <= rd_addr + 1;\n        end\n    end\n\n    // FIFO full and empty flags\n    always @(posedge wclk) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end\n        else if (wr && !full) begin\n            full <= 0;\n        end\n        else if (wr && full) begin\n            full <= 1;\n        end\n        if (rd && !empty) begin\n            empty <= 0;\n        end\n        else if (rd && empty) begin\n            empty <= 1;\n        end\n    end\n\n    // FIFO occupancy\n    always @(posedge wclk) begin\n        if (rst) begin\n            mem_empt <= 0;\n        end\n        else begin\n            mem_empt <= wr_ptr - rd_ptr;\n            if (mem_empt < 0) begin\n                mem_empt <= mem_empt + FIFO_TX_MEM_DEPTH;\n            end\n        end\n    end\n\n    // Data output\n    assign q = data_out;\n\n    // Read enable\n    assign rd = rd_en;\n\n    // Full and empty flags\n    assign full = full;\n    assign empty = empty;\n\n    // FIFO occupancy\n    assign mem_empt = mem_empt;\n\n    // Write and read addresses\n    assign adr_o = rd_addr;\n    assign adr_i = wr_addr;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 3, "code": "module sd_tx_fifo(\n    input  wire        wclk,\n    input  wire        rclk,\n    input  wire        rst,\n    input  wire        wr,\n    input  wire [31:0] d,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt,\n    output wire        adr_o,\n    output wire [5:0]  adr_i\n);\n\n    // Define FIFO parameters\n    localparam FIFO_TX_MEM_DEPTH = 256;\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH);\n\n    // Define RAM\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n    // Define write and read pointers\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] wr_ptr;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] rd_ptr;\n\n    // Define FIFO full and empty flags\n    reg full;\n    reg empty;\n\n    // Define FIFO occupancy\n    reg [5:0] mem_empt;\n\n    // Define address outputs\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n\n    // Write operation\n    always @(posedge wclk) begin\n        if (rst) begin\n            wr_ptr <= 0;\n        end else if (wr) begin\n            ram[wr_ptr] <= d;\n            wr_ptr <= wr_ptr + 1;\n            if (wr_ptr == FIFO_TX_MEM_DEPTH-1) begin\n                wr_ptr <= 0;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk) begin\n        if (rst) begin\n            rd_ptr <= 0;\n        end else if (rd) begin\n            q <= ram[rd_ptr];\n            rd_ptr <= rd_ptr + 1;\n            if (rd_ptr == FIFO_TX_MEM_DEPTH-1) begin\n                rd_ptr <= 0;\n            end\n        end\n    end\n\n    // Update full and empty flags\n    always @(posedge wclk) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else if (wr) begin\n            if (wr_ptr == rd_ptr) begin\n                full <= 1;\n                empty <= 0;\n            end else begin\n                full <= 0;\n                empty <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else if (rd) begin\n            if (wr_ptr == rd_ptr) begin\n                full <= 0;\n                empty <= 1;\n            end else begin\n                full <= 1;\n                empty <= 0;\n            end\n        end\n    end\n\n    // Update FIFO occupancy\n    always @(posedge wclk) begin\n        if (rst) begin\n            mem_empt <= 0;\n        end else if (wr) begin\n            mem_empt <= wr_ptr - rd_ptr;\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            mem_empt <= 0;\n        end else if (rd) begin\n            mem_empt <= wr_ptr - rd_ptr;\n        end\n    end\n\n    // Update address outputs\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n        end else if (wr) begin\n            adr_i <= wr_ptr;\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end else if (rd) begin\n            adr_o <= rd_ptr;\n        end\n    end\n\n    // Output signals\n    assign full = full;\n    assign empty = empty;\n    assign mem_empt = mem_empt;\n    assign q = q;\n    assign adr_o = adr_o;\n    assign adr_i = adr_i;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 4, "code": "module sd_tx_fifo(\n    input  wire        wclk,\n    input  wire        rclk,\n    input  wire        rst,\n    input  wire        wr,\n    input  wire [31:0] d,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt,\n    output wire        rst_n\n);\n\n    localparam FIFO_TX_MEM_DEPTH = 256;\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH);\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n        end else if (wr) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n                adr_i <= 0;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end else if (rd) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == FIFO_RX_MEM_DEPTH-1) begin\n                adr_o <= 0;\n            end\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == adr_o);\n    assign mem_empt = adr_i - adr_o;\n    assign rst_n = ~rst;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 5, "code": "// Import necessary modules\n`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire  wclk,\n    input  wire  rclk,\n    input  wire  rst,\n    input  wire  wr,\n    input  wire  [31:0] d,\n    output wire  q,\n    input  wire  rd,\n    output wire  full,\n    output wire  empty,\n    output wire  [5:0] mem_empt,\n    output wire  [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o,\n    input  wire  [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i\n);\n\n// Define FIFO parameters\nparameter FIFO_TX_MEM_DEPTH = 256;\nparameter FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1;\n\n// Define RAM\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Define pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] wr_ptr, rd_ptr;\n\n// Define status signals\nreg full, empty;\n\n// Define occupancy signal\nreg [5:0] mem_empt;\n\n// Write enable check\nalways @(posedge wclk) begin\n    if (rst) begin\n        wr_ptr <= 0;\n        full <= 0;\n    end else if (wr && !full) begin\n        ram[wr_ptr] <= d;\n        wr_ptr <= wr_ptr + 1;\n        if (wr_ptr == FIFO_TX_MEM_DEPTH - 1) begin\n            wr_ptr <= 0;\n        end\n    end\nend\n\n// Read enable check\nalways @(posedge rclk) begin\n    if (rst) begin\n        rd_ptr <= 0;\n        empty <= 1;\n    end else if (rd && !empty) begin\n        q <= ram[rd_ptr];\n        rd_ptr <= rd_ptr + 1;\n        if (rd_ptr == FIFO_TX_MEM_DEPTH - 1) begin\n            rd_ptr <= 0;\n        end\n    end\nend\n\n// Full status update\nalways @(posedge wclk) begin\n    if (rst) begin\n        full <= 0;\n    end else if (wr && !empty) begin\n        if (wr_ptr == rd_ptr) begin\n            full <= 1;\n        end else begin\n            full <= 0;\n        end\n    end\nend\n\n// Empty status update\nalways @(posedge rclk) begin\n    if (rst) begin\n        empty <= 1;\n    end else if (rd && !full) begin\n        if (rd_ptr == wr_ptr) begin\n            empty <= 1;\n        end else begin\n            empty <= 0;\n        end\n    end\nend\n\n// Occupancy update\nalways @(posedge wclk) begin\n    if (rst) begin\n        mem_empt <= 0;\n    end else if (wr) begin\n        mem_empt <= mem_empt + 1;\n    end\nend\n\n// Output signals\nassign full = full;\nassign empty = empty;\nassign mem_empt = mem_empt;\nassign adr_o = rd_ptr;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 6, "code": "module sd_tx_fifo(\n    input  wire       wclk,\n    input  wire       rclk,\n    input  wire       rst,\n    input  wire       wr,\n    input  wire [31:0] d,\n    output wire [31:0] q,\n    input  wire       rd,\n    output wire       full,\n    output wire       empty,\n    output wire [5:0] mem_empt,\n    output wire       adr_o,\n    output wire [5:0] adr_i\n);\n\n    parameter FIFO_TX_MEM_DEPTH = 256;\n    parameter FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH + 1);\n\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_reg, adr_o_reg;\n\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] wr_ptr, rd_ptr;\n\n    reg [5:0] mem_empt_reg;\n\n    assign q = ram[adr_o_reg];\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i_reg <= 0;\n            wr_ptr <= 0;\n        end\n        else if (wr) begin\n            ram[adr_i_reg] <= d;\n            adr_i_reg <= adr_i_reg + 1;\n            if (adr_i_reg == FIFO_TX_MEM_DEPTH) begin\n                adr_i_reg <= 0;\n            end\n            wr_ptr <= wr_ptr + 1;\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o_reg <= 0;\n            rd_ptr <= 0;\n        end\n        else if (rd) begin\n            adr_o_reg <= adr_o_reg + 1;\n            if (adr_o_reg == FIFO_TX_MEM_DEPTH) begin\n                adr_o_reg <= 0;\n            end\n            rd_ptr <= rd_ptr + 1;\n        end\n    end\n\n    always @(*) begin\n        full = (adr_i_reg == adr_o_reg);\n        empty = (adr_i_reg == rd_ptr);\n        mem_empt = (adr_i_reg - adr_o_reg);\n    end\n\n    assign adr_i = adr_i_reg;\n    assign adr_o = adr_o_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 7, "code": "module sd_tx_fifo(\n    input  wire  wclk,\n    input  wire  rst,\n    input  wire  wr,\n    input  wire  [31:0] d,\n    output wire  q,\n    input  wire  rd,\n    output wire  full,\n    output wire  empty,\n    output wire  [5:0] mem_empt,\n    input  wire  rclk\n);\n\n    parameter FIFO_TX_MEM_DEPTH = 256;\n    parameter FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH);\n\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n                adr_i <= 0;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n                adr_o <= 0;\n            end\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == adr_o && !wr);\n    assign mem_empt = adr_i - adr_o;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 8, "code": "module sd_tx_fifo(\n    input  wire  d[31:0],\n    input  wire  wr,\n    input  wire  wclk,\n    output wire  q[31:0],\n    input  wire  rd,\n    output wire  full,\n    output wire  empty,\n    output wire [5:0] mem_empt,\n    input  wire  rclk,\n    input  wire  rst\n);\n\n    localparam FIFO_TX_MEM_DEPTH = 256;\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH);\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n    assign q = ram[adr_o];\n\n    always @(posedge wclk) begin\n        if (wr) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH - 1) adr_i <= 0;\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rd) begin\n            adr_o <= adr_o + 1;\n            if (adr_o == FIFO_TX_MEM_DEPTH - 1) adr_o <= 0;\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == adr_o + 1);\n    assign mem_empt = $signed(adr_i) - $signed(adr_o);\n\n    always @(posedge rst) begin\n        adr_i <= 0;\n        adr_o <= 0;\n        for (int i = 0; i < FIFO_TX_MEM_DEPTH; i++) begin\n            ram[i] <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire        wclk,\n    input  wire        rclk,\n    input  wire        rst,\n    input  wire        wr,\n    input  wire [31:0] d,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt,\n    output wire        adr_o,\n    output wire [5:0]  adr_i\n);\n\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_reg;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_reg;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] wr_ptr;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] rd_ptr;\n    reg [5:0] mem_empt_reg;\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i_reg <= 0;\n            wr_ptr <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i_reg] <= d;\n            adr_i_reg <= adr_i_reg + 1;\n            if (adr_i_reg == FIFO_TX_MEM_DEPTH-1) begin\n                adr_i_reg <= 0;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o_reg <= 0;\n            rd_ptr <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o_reg];\n            adr_o_reg <= adr_o_reg + 1;\n            if (adr_o_reg == FIFO_TX_MEM_DEPTH-1) begin\n                adr_o_reg <= 0;\n            end\n        end\n    end\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            full <= 0;\n        end else if (wr_ptr == rd_ptr) begin\n            full <= 1;\n        end else begin\n            full <= 0;\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            empty <= 1;\n        end else if (wr_ptr == rd_ptr) begin\n            empty <= 1;\n        end else begin\n            empty <= 0;\n        end\n    end\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            mem_empt_reg <= 0;\n        end else begin\n            mem_empt_reg <= adr_i_reg - adr_o_reg;\n        end\n    end\n\n    assign full = full;\n    assign empty = empty;\n    assign mem_empt = mem_empt_reg;\n    assign adr_o = adr_o_reg;\n    assign adr_i = adr_i_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 10, "code": "module sd_tx_fifo(\n    input  wire  wclk,\n    input  wire  wr,\n    input  wire  [31:0] d,\n    output wire  [31:0] q,\n    input  wire  rclk,\n    input  wire  rd,\n    output wire  full,\n    output wire  empty,\n    output wire  [5:0] mem_empt,\n    input  wire  rst\n);\n\n    // Define FIFO parameters\n    localparam FIFO_TX_MEM_DEPTH = 256;\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH);\n\n    // Define RAM and address registers\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n\n    // Initialize RAM and address registers on reset\n    always @(posedge rst) begin\n        for (int i = 0; i < FIFO_TX_MEM_DEPTH; i++) begin\n            ram[i] <= 32'h00000000;\n        end\n        adr_i <= 0;\n        adr_o <= 0;\n    end\n\n    // Write operation\n    always @(posedge wclk) begin\n        if (wr) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH) begin\n                adr_i <= 0;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk) begin\n        if (rd) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == FIFO_TX_MEM_DEPTH) begin\n                adr_o <= 0;\n            end\n        end\n    end\n\n    // Status update\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == adr_o) && (adr_i == 0);\n    assign mem_empt = $signed(adr_i) - $signed(adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 11, "code": "module sd_tx_fifo(\n    input  logic wclk,\n    input  logic rclk,\n    input  logic rst,\n    input  logic [31:0] d,\n    input  logic wr,\n    output logic [31:0] q,\n    input  logic rd,\n    output logic full,\n    output logic empty,\n    output logic [5:0] mem_empt,\n    output logic [31:0] adr_o,\n    output logic [31:0] adr_i\n);\n\n    parameter FIFO_TX_MEM_DEPTH = 1024;\n    parameter FIFO_RX_MEM_ADR_SIZE = 10;\n    parameter FIFO_TX_MEM_ADR_SIZE = 10;\n\n    logic [FIFO_TX_MEM_ADR_SIZE-1:0] wr_ptr;\n    logic [FIFO_TX_MEM_ADR_SIZE-1:0] rd_ptr;\n    logic [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n    always_ff @(posedge wclk) begin\n        if (rst) begin\n            wr_ptr <= 0;\n        end else if (wr && !full) begin\n            ram[wr_ptr] <= d;\n            wr_ptr <= wr_ptr + 1;\n            if (wr_ptr == FIFO_TX_MEM_DEPTH-1) begin\n                wr_ptr <= 0;\n            end\n        end\n    end\n\n    always_ff @(posedge rclk) begin\n        if (rst) begin\n            rd_ptr <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[rd_ptr];\n            rd_ptr <= rd_ptr + 1;\n            if (rd_ptr == FIFO_TX_MEM_DEPTH-1) begin\n                rd_ptr <= 0;\n            end\n        end\n    end\n\n    assign full = (wr_ptr == rd_ptr);\n    assign empty = (wr_ptr == rd_ptr + 1);\n    assign mem_empt = wr_ptr - rd_ptr;\n\n    assign adr_o = rd_ptr;\n    assign adr_i = wr_ptr;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 12, "code": "module sd_tx_fifo(\n    input  wire        wclk,\n    input  wire        rclk,\n    input  wire        rst,\n    input  wire        wr,\n    input  wire [31:0]  d,\n    output wire [31:0]  q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt,\n    output wire        adr_o,\n    output wire [5:0]  adr_i\n);\n\n    // FIFO parameters\n    localparam FIFO_TX_MEM_DEPTH = 256;\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1;\n\n    // Registers\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_reg;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_reg;\n\n    // Status signals\n    reg full_reg;\n    reg empty_reg;\n    reg [5:0] mem_empt_reg;\n\n    // Write operation\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i_reg <= 0;\n        end else if (wr) begin\n            if (adr_i_reg == FIFO_TX_MEM_DEPTH-1) begin\n                adr_i_reg <= 0;\n            end else begin\n                adr_i_reg <= adr_i_reg + 1;\n            end\n            ram[adr_i_reg] <= d;\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o_reg <= 0;\n        end else if (rd) begin\n            if (adr_o_reg == FIFO_TX_MEM_DEPTH-1) begin\n                adr_o_reg <= 0;\n            end else begin\n                adr_o_reg <= adr_o_reg + 1;\n            end\n            q <= ram[adr_o_reg];\n        end\n    end\n\n    // Status update\n    always @(posedge wclk) begin\n        if (rst) begin\n            full_reg <= 0;\n            empty_reg <= 1;\n            mem_empt_reg <= 0;\n        end else begin\n            if (adr_i_reg == adr_o_reg) begin\n                empty_reg <= 1;\n            end else begin\n                empty_reg <= 0;\n            end\n            if (adr_i_reg == FIFO_TX_MEM_DEPTH-1) begin\n                full_reg <= 1;\n            end else begin\n                full_reg <= 0;\n            end\n            mem_empt_reg <= adr_i_reg - adr_o_reg;\n        end\n    end\n\n    // Output signals\n    assign full = full_reg;\n    assign empty = empty_reg;\n    assign mem_empt = mem_empt_reg;\n    assign adr_o = adr_o_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 13, "code": "module sd_tx_fifo(\n    input  logic wclk,\n    input  logic rclk,\n    input  logic rst,\n    input  logic [31:0] d,\n    input  logic wr,\n    output logic [31:0] q,\n    input  logic rd,\n    output logic full,\n    output logic empty,\n    output logic [5:0] mem_empt,\n    output logic [31:0] adr_i,\n    output logic [31:0] adr_o\n);\n\n    // Define FIFO parameters\n    localparam FIFO_TX_MEM_DEPTH = 256;\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH);\n\n    // Define RAM\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n    // Define write address\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_reg;\n\n    // Define read address\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_reg;\n\n    // Define write pointer\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] wptr;\n\n    // Define read pointer\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] rptr;\n\n    // Define FIFO full status\n    reg full_reg;\n\n    // Define FIFO empty status\n    reg empty_reg;\n\n    // Define FIFO occupancy\n    reg [5:0] mem_empt_reg;\n\n    // Define data output\n    reg [31:0] q_reg;\n\n    // Define write enable\n    reg wr_reg;\n\n    // Define read enable\n    reg rd_reg;\n\n    // Define write clock enable\n    reg wclk_en;\n\n    // Define read clock enable\n    reg rclk_en;\n\n    // Define reset\n    reg rst_reg;\n\n    // Define reset value\n    initial begin\n        rst_reg = 1'b1;\n        wptr = 0;\n        rptr = 0;\n        full_reg = 1'b0;\n        empty_reg = 1'b1;\n        mem_empt_reg = 0;\n        q_reg = 0;\n        wr_reg = 0;\n        rd_reg = 0;\n        wclk_en = 0;\n        rclk_en = 0;\n    end\n\n    // Clock domain crossing\n    always @(posedge wclk) begin\n        wclk_en = 1'b1;\n        if (rst_reg) begin\n            wclk_en = 1'b0;\n        end\n    end\n\n    always @(posedge rclk) begin\n        rclk_en = 1'b1;\n        if (rst_reg) begin\n            rclk_en = 1'b0;\n        end\n    end\n\n    // Write operation\n    always @(posedge wclk) begin\n        if (rst_reg) begin\n            wptr <= 0;\n            full_reg <= 1'b0;\n            mem_empt_reg <= 0;\n            q_reg <= 0;\n            wr_reg <= 0;\n        end else if (wr_reg) begin\n            ram[wptr] <= d;\n            wptr <= wptr + 1;\n            if (wptr == FIFO_TX_MEM_DEPTH-1) begin\n                wptr <= 0;\n            end\n            if (wptr == rptr) begin\n                full_reg <= 1'b1;\n            end else begin\n                full_reg <= 1'b0;\n            end\n            if (mem_empt_reg == 0) begin\n                mem_empt_reg <= wptr - rptr;\n            end else begin\n                mem_empt_reg <= mem_empt_reg - 1;\n            end\n            if (mem_empt_reg == 0) begin\n                full_reg <= 1'b1;\n            end\n            if (mem_empt_reg == FIFO_TX_MEM_DEPTH-1) begin\n                mem_empt_reg <= 0;\n            end\n            q_reg <= ram[wptr];\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk) begin\n        if (rst_reg) begin\n            rptr <= 0;\n            empty_reg <= 1'b1;\n            mem_empt_reg <= 0;\n            q_reg <= 0;\n            rd_reg <= 0;\n        end else if (rd_reg) begin\n            q_reg <= ram[rptr];\n            rptr <= rptr + 1;\n            if (rptr == FIFO_TX_MEM_DEPTH-1) begin\n                rptr <= 0;\n            end\n            if (rptr == wptr) begin\n                empty_reg <= 1'b0;\n            end else begin\n                empty_reg <= 1'b1;\n            end\n            if (mem_empt_reg == 0) begin\n                mem_empt_reg <= rptr - wptr;\n            end else begin\n                mem_empt_reg <= mem_empt_reg - 1;\n            end\n            if (mem_empt_reg == 0) begin\n                empty_reg <= 1'b1;\n            end\n            if (mem_empt_reg == FIFO_TX_MEM_DEPTH-1) begin\n                mem_empt_reg <= 0;\n            end\n        end\n    end\n\n    // Status update\n    assign full = full_reg;\n    assign empty = empty_reg;\n    assign mem_empt = mem_empt_reg;\n    assign adr_i = wptr;\n    assign adr_o = rptr;\n\n    // Write enable\n    always @(posedge wclk) begin\n        if (rst_reg) begin\n            wr_reg <= 0;\n        end else if (wr) begin\n            wr_reg <= 1'b1;\n        end else begin\n            wr_reg <= 0;\n        end\n    end\n\n    // Read enable\n    always @(posedge rclk) begin\n        if (rst_reg) begin\n            rd_reg <= 0;\n        end else if (rd) begin\n            rd_reg <= 1'b1;\n        end else begin\n            rd_reg <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 14, "code": "module sd_tx_fifo(\n    input  wire  wclk,\n    input  wire  wren,\n    input  wire  [31:0] d,\n    output wire  [31:0] q,\n    input  wire  rclk,\n    input  wire  ren,\n    output wire  full,\n    output wire  empty,\n    output wire  [5:0] mem_empt,\n    input  wire  rst\n);\n\n    parameter FIFO_TX_MEM_DEPTH = 256;\n    parameter FIFO_TX_MEM_ADR_SIZE = 8;\n\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n        end else if (wren) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH-1) adr_i <= 0;\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end else if (ren) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == FIFO_TX_MEM_DEPTH-1) adr_o <= 0;\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == adr_o + 1);\n    assign mem_empt = adr_i - adr_o;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 15, "code": "module sd_tx_fifo(\n    input  wire  wclk,  // Write clock\n    input  wire  rclk,  // Read clock\n    input  wire  rst,   // Asynchronous reset\n    input  wire  wr,    // Write enable\n    input  wire  [31:0] d,  // Data input\n    output wire  [31:0] q,  // Data output\n    output wire  full,  // FIFO full flag\n    output wire  empty, // FIFO empty flag\n    output wire  [5:0] mem_empt, // FIFO occupancy\n    input  wire  rd  // Read enable\n);\n\n    // Define FIFO parameters\n    localparam FIFO_TX_MEM_DEPTH = 256;\n    localparam FIFO_RX_MEM_DEPTH = 256;\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH);\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    // Define RAM and address registers\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i; // Write address\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o; // Read address\n\n    // Initialize FIFO and address registers on reset\n    always @(posedge rst) begin\n        adr_i <= 0;\n        adr_o <= 0;\n        for (int i = 0; i < FIFO_TX_MEM_DEPTH; i++) begin\n            ram[i] <= 0;\n        end\n    end\n\n    // Write operation\n    always @(posedge wclk) begin\n        if (wr) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n                adr_i <= 0;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk) begin\n        if (rd) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n                adr_o <= 0;\n            end\n        end\n    end\n\n    // FIFO full and empty status\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == adr_o && (adr_i == 0));\n\n    // FIFO occupancy\n    assign mem_empt = {adr_i,adr_o};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire        wclk,\n    input  wire        rst,\n    input  wire        wr,\n    input  wire [31:0]  d,\n    output wire [31:0]  q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt,\n    input  wire        rclk\n);\n\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH-1) adr_i <= 0;\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == FIFO_TX_MEM_DEPTH-1) adr_o <= 0;\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == adr_o + 1);\n    assign mem_empt = (adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 17, "code": "module sd_tx_fifo(\n    input  wire        wclk,\n    input  wire        rclk,\n    input  wire        rst,\n    input  wire        wr,\n    input  wire [31:0] d,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt,\n    output wire        rclk_en\n);\n\n    parameter FIFO_TX_MEM_DEPTH = 256;\n    parameter FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH);\n\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n    reg [31:0] data_out;\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n                adr_i <= 0;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end else if (rd && !empty) begin\n            data_out <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n                adr_o <= 0;\n            end\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == adr_o && !wr);\n    assign mem_empt = {adr_i,adr_o};\n    assign q = data_out;\n    assign rclk_en = rd;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 18, "code": "module sd_tx_fifo(\n    input  wire        d[31:0],\n    input  wire        wr,\n    input  wire        wclk,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt,\n    input  wire        rclk,\n    input  wire        rst\n);\n\n    // Define FIFO parameters\n    localparam FIFO_TX_MEM_DEPTH = 256;\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH);\n\n    // Define RAM\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n    // Define write address\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n\n    // Define read address\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n\n    // Define write pointer\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] wptr;\n\n    // Define read pointer\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] rptr;\n\n    // Define FIFO full status\n    reg full_status;\n\n    // Define FIFO empty status\n    reg empty_status;\n\n    // Define FIFO occupancy\n    reg [5:0] mem_empt_status;\n\n    // Write clock domain crossing\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n        end else if (wr) begin\n            ram[wptr] <= d;\n            adr_i <= wptr;\n            wptr <= wptr + 1;\n            if (wptr == FIFO_TX_MEM_DEPTH - 1) begin\n                wptr <= 0;\n            end\n        end\n    end\n\n    // Read clock domain crossing\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n        end else if (rd) begin\n            q <= ram[rptr];\n            adr_o <= rptr;\n            rptr <= rptr + 1;\n            if (rptr == FIFO_TX_MEM_DEPTH - 1) begin\n                rptr <= 0;\n            end\n        end\n    end\n\n    // Calculate FIFO full status\n    always @(posedge wclk) begin\n        if (rst) begin\n            full_status <= 0;\n        end else if (adr_i == adr_o) begin\n            full_status <= 1;\n        end else begin\n            full_status <= 0;\n        end\n    end\n\n    // Calculate FIFO empty status\n    always @(posedge rclk) begin\n        if (rst) begin\n            empty_status <= 1;\n        end else if (adr_i == adr_o) begin\n            empty_status <= 1;\n        end else begin\n            empty_status <= 0;\n        end\n    end\n\n    // Calculate FIFO occupancy\n    always @(posedge rclk) begin\n        if (rst) begin\n            mem_empt_status <= 0;\n        end else begin\n            mem_empt_status <= adr_i - adr_o;\n        end\n    end\n\n    // Assign signals\n    assign full = full_status;\n    assign empty = empty_status;\n    assign mem_empt = mem_empt_status;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 19, "code": "module sd_tx_fifo(\n    input  wire  wclk,\n    input  wire  rst,\n    input  wire  wr,\n    input  wire [31:0] d,\n    output wire [31:0] q,\n    input  wire  rd,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input  wire  rclk\n);\n\n    parameter FIFO_TX_MEM_DEPTH = 256;\n    parameter FIFO_TX_MEM_ADR_SIZE = 8;\n\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n        end else if (wr) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n                adr_i <= 0;\n            end\n        end\n    end\n\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o <= 0;\n        end else if (rd) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n                adr_o <= 0;\n            end\n        end\n    end\n\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == adr_o && adr_i == 0);\n    assign mem_empt = adr_i - adr_o;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 20, "code": "module sd_tx_fifo(\n    input  wire        wclk,\n    input  wire        rclk,\n    input  wire        rst,\n    input  wire        wr,\n    input  wire [31:0] d,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt,\n    output wire        adr_o,\n    output wire [5:0]  adr_i\n);\n\n    // Define FIFO parameters\n    localparam FIFO_TX_MEM_DEPTH = 256;\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1;\n\n    // Define RAM\n    reg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n    // Define write address\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i_reg;\n\n    // Define read address\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o_reg;\n\n    // Define write pointer\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] wr_ptr;\n\n    // Define read pointer\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] rd_ptr;\n\n    // Define FIFO full flag\n    reg full_reg;\n\n    // Define FIFO empty flag\n    reg empty_reg;\n\n    // Define FIFO occupancy\n    reg [5:0] mem_empt_reg;\n\n    // Define write enable flag\n    reg wr_en;\n\n    // Define read enable flag\n    reg rd_en;\n\n    // Define write clock enable\n    reg wclk_en;\n\n    // Define read clock enable\n    reg rclk_en;\n\n    // Define reset\n    reg rst_reg;\n\n    // Define reset value for write pointer\n    initial begin\n        wr_ptr = 0;\n    end\n\n    // Define reset value for read pointer\n    initial begin\n        rd_ptr = 0;\n    end\n\n    // Define reset value for FIFO full flag\n    initial begin\n        full_reg = 0;\n    end\n\n    // Define reset value for FIFO empty flag\n    initial begin\n        empty_reg = 1;\n    end\n\n    // Define reset value for FIFO occupancy\n    initial begin\n        mem_empt_reg = 0;\n    end\n\n    // Define reset value for write enable flag\n    initial begin\n        wr_en = 0;\n    end\n\n    // Define reset value for read enable flag\n    initial begin\n        rd_en = 0;\n    end\n\n    // Define reset value for write clock enable\n    initial begin\n        wclk_en = 0;\n    end\n\n    // Define reset value for read clock enable\n    initial begin\n        rclk_en = 0;\n    end\n\n    // Define reset value for reset\n    initial begin\n        rst_reg = 1;\n    end\n\n    // Define reset process\n    always @(posedge rst) begin\n        rst_reg <= 1;\n        wr_ptr <= 0;\n        rd_ptr <= 0;\n        full_reg <= 0;\n        empty_reg <= 1;\n        mem_empt_reg <= 0;\n        wr_en <= 0;\n        rd_en <= 0;\n        wclk_en <= 0;\n        rclk_en <= 0;\n    end\n\n    // Define write clock process\n    always @(posedge wclk) begin\n        if (rst_reg == 0) begin\n            wclk_en <= 1;\n        end\n        else begin\n            wclk_en <= 1;\n        end\n    end\n\n    // Define read clock process\n    always @(posedge rclk) begin\n        if (rst_reg == 0) begin\n            rclk_en <= 1;\n        end\n        else begin\n            rclk_en <= 1;\n        end\n    end\n\n    // Define write enable process\n    always @(posedge wclk) begin\n        if (rst_reg == 0) begin\n            wr_en <= 0;\n        end\n        else begin\n            if (wr) begin\n                wr_en <= 1;\n            end\n            else begin\n                wr_en <= 0;\n            end\n        end\n    end\n\n    // Define read enable process\n    always @(posedge rclk) begin\n        if (rst_reg == 0) begin\n            rd_en <= 0;\n        end\n        else begin\n            if (rd) begin\n                rd_en <= 1;\n            end\n            else begin\n                rd_en <= 0;\n            end\n        end\n    end\n\n    // Define write process\n    always @(posedge wclk) begin\n        if (rst_reg == 0) begin\n            ram[wr_ptr] <= 0;\n        end\n        else begin\n            if (wr_en == 1) begin\n                ram[wr_ptr] <= d;\n                if (wr_ptr == FIFO_TX_MEM_DEPTH-1) begin\n                    wr_ptr <= 0;\n                end\n                else begin\n                    wr_ptr <= wr_ptr + 1;\n                end\n            end\n        end\n    end\n\n    // Define read process\n    always @(posedge rclk) begin\n        if (rst_reg == 0) begin\n            q <= 0;\n        end\n        else begin\n            if (rd_en == 1) begin\n                if (rd_ptr == FIFO_TX_MEM_DEPTH-1) begin\n                    rd_ptr <= 0;\n                end\n                else begin\n                    rd_ptr <= rd_ptr + 1;\n                end\n                q <= ram[rd_ptr];\n            end\n        end\n    end\n\n    // Define FIFO full flag process\n    always @(posedge wclk) begin\n        if (rst_reg == 0) begin\n            full_reg <= 0;\n        end\n        else begin\n            if (wr_en == 1) begin\n                if (wr_ptr == rd_ptr) begin\n                    full_reg <= 1;\n                end\n                else begin\n                    full_reg <= 0;\n                end\n            end\n        end\n    end\n\n    // Define FIFO empty flag process\n    always @(posedge rclk) begin\n        if (rst_reg == 0) begin\n            empty_reg <= 1;\n        end\n        else begin\n            if (rd_en == 1) begin\n                if (rd_ptr == wr_ptr) begin\n                    empty_reg <= 1;\n                end\n                else begin\n                    empty_reg <= 0;\n                end\n            end\n        end\n    end\n\n    // Define FIFO occupancy process\n    always @(posedge wclk) begin\n        if (rst_reg == 0) begin\n            mem_empt_reg <= 0;\n        end\n        else begin\n            if (wr_en == 1) begin\n                if (wr_ptr == rd_ptr) begin\n                    mem_empt_reg <= 0;\n                end\n                else begin\n                    mem_empt_reg <= wr_ptr - rd_ptr;\n                end\n            end\n        end\n    end\n\n    // Define output signals\n    assign full = full_reg;\n    assign empty = empty_reg;\n    assign mem_empt = mem_empt_reg;\n    assign adr_o = rd_ptr;\n    assign adr_i = wr_ptr;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 1, "code": "Here is the Verilog code for the sdc_controller module:\n```\nmodule sdc_controller(\n    input  wb_clk_i,\n    input  wb_rst_i,\n    input  [3:0] wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input  [1:0]  wb_we_i,\n    input  [1:0]  wb_cyc_i,\n    input  [1:0]  wb_stb_i,\n    output [1:0]  wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output [1:0]  m_wb_sel_o,\n    output [1:0]  m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output [1:0]  m_wb_cyc_o,\n    output [1:0]  m_wb_stb_o,\n    input  [1:0]  m_wb_ack_i,\n    output [1:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n    input  card_detect,\n    output int_a,\n    output int_b,\n    output int_c\n);\n\n    // Wishbone Slave Interface\n    wire [31:0] wb_dat;\n    wire [7:0]  wb_adr;\n    wire [1:0]  wb_we;\n    wire [1:0]  wb_cyc;\n    wire [1:0]  wb_stb;\n    wire [1:0]  wb_ack;\n    wire [31:0] m_wb_dat;\n    wire [1:0]  m_wb_cyc;\n    wire [1:0]  m_wb_stb;\n    wire [1:0]  m_wb_ack;\n    wire [1:0]  m_wb_cti;\n    wire [1:0]  m_wb_bte;\n\n    // Wishbone Master Interface\n    wire [31:0] m_wb_adr_o;\n    wire [1:0]  m_wb_sel_o;\n    wire [1:0]  m_wb_we_o;\n    wire [31:0] m_wb_dat_o;\n\n    // SDC/MMC Interface\n    wire [3:0]  sd_dat_dat_i;\n    wire [3:0]  sd_dat_out_o;\n    wire [1:0]  sd_dat_oe_o;\n    wire [1:0]  sd_clk_o_pad;\n    wire [1:0]  sd_clk_i_pad;\n    wire [1:0]  sd_cmd_dat_i;\n    wire [1:0]  sd_cmd_out_o;\n    wire [1:0]  sd_cmd_oe_o;\n\n    // Interrupts\n    wire int_a;\n    wire int_b;\n    wire int_c;\n\n    // Sub-modules\n    sd_controller_wb wb_if(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack),\n        .wb_dat_o(wb_dat_o),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_sel_o(m_wb_sel_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .cmd_busy(cmd_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider clock_divider(\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master cmd_master(\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(cmd_arg_s),\n        .CMD_SET_REG(cmd_set_s),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(err_int_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(err_int_reset),\n        .NORMAL_INT_RST(normal_int_reset),\n        .settings(settings),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host cmd_serial_host(\n        .SD_CLK_IN(sd_clk_i_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_set_s),\n        .CMD_IN(cmd_in),\n        .REQ_IN(req_in),\n        .ACK_IN(ack_in),\n        .cmd_dat_i(cmd_dat_i),\n        .CMD_OUT(cmd_out),\n        .ACK_OUT(ack_out),\n        .REQ_OUT(req_out),\n        .STATUS(status_reg),\n        .cmd_oe_o(cmd_oe_o),\n        .cmd_out_o(cmd_out_o)\n    );\n\n    sd_data_master data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(cmd_tsf_err),\n        .card_status(card_status),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(Dat_Int_Status_rst),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(cidat)\n    );\n\n    sd_data_serial_host data_serial_host(\n        .sd_clk(sd_clk_i_pad),\n        .rst(wb_rst_i),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(rd),\n        .data_out(sd_dat_out_o),\n        .we(we),\n        .DAT_oe_o(DAT_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n\n    rx_bd rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_o_s),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s)\n    );\n\n    tx_bd tx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(free_tx_bd),\n        .re_s(re_s_tx),\n        .ack_o_s(ack_o_s),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s(dat_out_s)\n    );\n\n    sd_fifo_tx_filler tx_fifo(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_o(dat_o),\n        .rd(rd),\n        .empty(empty),\n        .fe(fe)\n    );\n\n    sd_fifo_rx_filler rx_fifo(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_i(dat_i),\n        .wr(wr),\n        .full(full)\n    );\n\n    // Interrupts\n    assign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) != 0;\n    assign int_b = (error_int_status_reg & error_int_signal_enable_reg) != 0;\n    assign int_c = (Bd_isr_reg & Bd_isr_enable_reg) != 0;\n\nendmodule\n```\nNote that this is a very large module and it's not possible to include all the details in this answer. The above code is a simplified version of the module and it's missing some details. You should consult the original specification for more information.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 2, "code": "module sd_controller(\n    // Wishbone Slave Interface\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire [31:0]  wb_dat_i,\n    output wire [31:0]  wb_dat_o,\n    input  wire [7:0]   wb_adr_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire        m_wb_adr_o,\n    output wire        m_wb_sel_o,\n    output wire        m_wb_we_o,\n    output wire [31:0]  m_wb_dat_o,\n    input  wire [31:0]  m_wb_dat_i,\n    output wire        m_wb_cyc_o,\n    output wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    output wire        m_wb_cti_o,\n    output wire        m_wb_bte_o,\n\n    // SDC/MMC Interface\n    input  wire        sd_cmd_dat_i,\n    output wire        sd_cmd_out_o,\n    output wire        sd_cmd_oe_o,\n    input  wire [3:0]  sd_dat_dat_i,\n    output wire [3:0]  sd_dat_out_o,\n    output wire        sd_dat_oe_o,\n    output wire        sd_clk_o_pad,\n\n    // Interrupts\n    output wire        int_a,\n    output wire        int_b,\n    output wire        int_c\n);\n\n    // Internal Registers\n    reg [15:0]  status_reg;\n    reg [15:0]  normal_int_status_reg;\n    reg [15:0]  error_int_status_reg;\n    reg [7:0]   Bd_isr_reg;\n    reg [7:0]   Bd_isr_enable_reg;\n    reg [15:0]  Bd_status_reg;\n    reg [7:0]   dat_int_status_reg;\n    reg [7:0]   dat_int_status_reg_rst;\n    reg [15:0]  cmd_setting_reg;\n    reg [31:0]  argument_reg;\n    reg [31:0]  cmd_resp_1;\n    reg [7:0]   software_reset_reg;\n    reg [15:0]  time_out_reg;\n    reg [15:0]  normal_int_signal_enable_reg;\n    reg [15:0]  error_int_signal_enable_reg;\n    reg [7:0]   clock_divider;\n    reg [15:0]  Bd_isr_enable_reg;\n    reg [7:0]   Bd_isr_reg_rst;\n    reg [7:0]   normal_isr_reset;\n    reg [7:0]   error_isr_reset;\n    reg [7:0]   bd_isr_reset;\n\n    // Internal Signals\n    wire        we_m_tx_bd;\n    wire        we_m_rx_bd;\n    wire        new_cmd;\n    wire        we_ack;\n    wire        int_ack;\n    wire        cmd_int_busy;\n    wire        int_busy;\n    wire        write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [31:0] argument_reg_out;\n    wire [15:0] cmd_setting_reg_out;\n    wire [15:0] status_reg_out;\n    wire [31:0] cmd_resp_1_out;\n    wire [7:0]  software_reset_reg_out;\n    wire [15:0] time_out_reg_out;\n    wire [15:0] normal_int_signal_enable_reg_out;\n    wire [15:0] error_int_signal_enable_reg_out;\n    wire [7:0]  clock_divider_out;\n    wire [15:0] Bd_status_reg_out;\n    wire [7:0]  Bd_isr_reg_out;\n    wire [7:0]  Bd_isr_enable_reg_out;\n    wire [7:0]  Bd_isr_reg_rst_out;\n    wire [7:0]  normal_isr_reset_out;\n    wire [7:0]  error_isr_reset_out;\n    wire [7:0]  bd_isr_reset_out;\n\n    // sd_controller_wb\n    sd_controller_wb sd_controller_wb(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg_out(argument_reg_out),\n        .cmd_setting_reg_out(cmd_setting_reg_out),\n        .status_reg_out(status_reg_out),\n        .cmd_resp_1_out(cmd_resp_1_out),\n        .software_reset_reg_out(software_reset_reg_out),\n        .time_out_reg_out(time_out_reg_out),\n        .normal_int_signal_enable_reg_out(normal_int_signal_enable_reg_out),\n        .error_int_signal_enable_reg_out(error_int_signal_enable_reg_out),\n        .clock_divider_out(clock_divider_out),\n        .Bd_status_reg_out(Bd_status_reg_out),\n        .Bd_isr_reg_out(Bd_isr_reg_out),\n        .Bd_isr_enable_reg_out(Bd_isr_enable_reg_out),\n        .Bd_isr_reg_rst_out(Bd_isr_reg_rst_out),\n        .normal_isr_reset_out(normal_isr_reset_out),\n        .error_isr_reset_out(error_isr_reset_out),\n        .bd_isr_reset_out(bd_isr_reset_out)\n    );\n\n    // sd_clock_divider\n    sd_clock_divider sd_clock_divider(\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // sd_cmd_master\n    sd_cmd_master sd_cmd_master(\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(we_m_tx_bd),\n        .data_read(we_m_rx_bd),\n        .ARG_REG(argument_reg_out),\n        .CMD_SET_REG(cmd_setting_reg_out),\n        .TIMEOUT_REG(time_out_reg_out),\n        .STATUS_REG(status_reg_out),\n        .RESP_1_REG(cmd_resp_1_out),\n        .ERR_INT_REG(error_int_status_reg_out),\n        .NORMAL_INT_REG(normal_int_status_reg_out),\n        .ERR_INT_RST(error_isr_reset_out),\n        .NORMAL_INT_RST(normal_isr_reset_out),\n        .settings(cmd_setting_reg_out),\n        .go_idle_o(1'b0),\n        .cmd_out(cmd_out),\n        .req_out(1'b0),\n        .ack_out(1'b0),\n        .req_in(1'b0),\n        .ack_in(1'b0),\n        .cmd_in(cmd_in),\n        .serial_status(8'b0),\n        .card_detect(1'b0)\n    );\n\n    // sd_cmd_serial_host\n    sd_cmd_serial_host sd_cmd_serial_host(\n        .SD_CLK_IN(wb_clk_i),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_setting_reg_out),\n        .CMD_IN(cmd_in),\n        .REQ_IN(1'b0),\n        .ACK_IN(1'b0),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(cmd_out),\n        .ACK_OUT(1'b0),\n        .REQ_OUT(1'b0),\n        .STATUS(8'b0),\n        .cmd_oe_o(1'b0),\n        .cmd_out_o(1'b0),\n        .st_dat_t(2'b0)\n    );\n\n    // sd_data_master\n    sd_data_master sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(we_m_tx_bd),\n        .ack_i_s_tx(we_ack),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(we_m_rx_bd),\n        .ack_i_s_rx(we_ack),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(1'b0),\n        .card_status(5'b0),\n        .tx_empt(1'b0),\n        .tx_full(1'b0),\n        .rx_full(1'b0),\n        .busy_n(1'b0),\n        .transm_complete(1'b0),\n        .crc_ok(1'b0),\n        .Dat_Int_Status_rst(1'b0),\n        .transfer_type(2'b0),\n        .re_s_tx(1'b0),\n        .a_cmp_tx(1'b0),\n        .re_s_rx(1'b0),\n        .a_cmp_rx(1'b0),\n        .we_req(1'b0),\n        .d_write(1'b0),\n        .d_read(1'b0),\n        .cmd_arg(cmd_arg_s),\n        .cmd_set(cmd_set_s),\n        .start_tx_fifo(1'b0),\n        .start_rx_fifo(1'b0),\n        .sys_adr(32'b0),\n        .ack_transfer(1'b0),\n        .Dat_Int_Status(dat_int_status_reg_out),\n        .CIDAT(1'b0)\n    );\n\n    // sd_data_serial_host\n    sd_data_serial_host sd_data_serial_host(\n        .sd_clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .data_in(dat_in_m_tx_bd),\n        .start_dat(2'b0),\n        .ack_transfer(1'b0),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(1'b0),\n        .data_out(sd_dat_out_o),\n        .we(1'b0),\n        .DAT_oe_o(1'b0),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(1'b0),\n        .transm_complete(1'b0),\n        .crc_ok(1'b0)\n    );\n\n    // rx_bd/tx_bd\n    rx_bd rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(we_m_rx_bd),\n        .re_s(1'b0),\n        .ack_o(1'b0),\n        .a_cmp(1'b0),\n        .dat_out_s(dat_out_s)\n    );\n\n    // sd_fifo_tx_filler\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(1'b0),\n        .adr(32'b0),\n        .sd_clk(sd_clk_o_pad),\n        .dat_o(dat_out_s),\n        .rd(1'b0),\n        .empty(1'b0),\n        .fe(1'b0)\n    );\n\n    // sd_fifo_rx_filler\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(1'b0),\n        .adr(32'b0),\n        .sd_clk(sd_clk_o_pad),\n        .dat_i(sd_dat_dat_i),\n        .wr(1'b0),\n        .full(1'b0)\n    );\n\n    // Register Update\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            status_reg <= 16'b0;\n            normal_int_status_reg <= 16'b0;\n            error_int_status_reg <= 16'b0;\n            Bd_isr_reg <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_status_reg <= 16'b0;\n            dat_int_status_reg <= 8'b0;\n            dat_int_status_reg_rst <= 8'b0;\n            cmd_setting_reg <= 16'b0;\n            argument_reg <= 32'b0;\n            cmd_resp_1 <= 32'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reg_rst <= 8'b0;\n            normal_isr_reset <= 8'b0;\n            error_isr_reset <= 8'b0;\n            bd_isr_reset <= 8'b0;\n        end else begin\n            if (cmd_int_busy) begin\n                status_reg <= status_reg_out;\n                normal_int_status_reg <= normal_int_status_reg_out;\n                error_int_status_reg <= error_int_status_reg_out;\n                Bd_isr_reg <= Bd_isr_reg_out;\n                Bd_isr_enable_reg <= Bd_isr_enable_reg_out;\n                Bd_status_reg <= Bd_status_reg_out;\n                dat_int_status_reg <= dat_int_status_reg_out;\n                dat_int_status_reg_rst <= dat_int_status_reg_rst_out;\n                cmd_setting_reg <= cmd_setting_reg_out;\n                argument_reg <= argument_reg_out;\n                cmd_resp_1 <= cmd_resp_1_out;\n                software_reset_reg <= software_reset_reg_out;\n                time_out_reg <= time_out_reg_out;\n                normal_int_signal_enable_reg <= normal_int_signal_enable_reg_out;\n                error_int_signal_enable_reg <= error_int_signal_enable_reg_out;\n                clock_divider <= clock_divider_out;\n                Bd_isr_enable_reg <= Bd_isr_enable_reg_out;\n                Bd_isr_reg_rst <= Bd_isr_reg_rst_out;\n                normal_isr_reset <= normal_isr_reset_out;\n                error_isr_reset <= error_isr_reset_out;\n                bd_isr_reset <= bd_isr_reset_out;\n            end\n        end\n    end\n\n    // Interrupts\n    assign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) ? 1'b1 : 1'b0;\n    assign int_b = (error_int_status_reg & error_int_signal_enable_reg) ? 1'b1 : 1'b0;\n    assign int_c = (Bd_isr_reg & Bd_isr_enable_reg) ? 1'b1 : 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 3, "code": "Here is the Verilog code for the sdc_controller module:\n```\nmodule sdc_controller(\n    input  wb_clk_i,\n    input  wb_rst_i,\n    input  [3:0] wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0] wb_adr_i,\n    input  wb_we_i,\n    input  wb_cyc_i,\n    input  wb_stb_i,\n    output wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output [3:0] m_wb_sel_o,\n    output wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output wb_cyc_o,\n    output wb_stb_o,\n    input  wb_ack_i,\n    output wb_cti_o,\n    output wb_bte_o,\n    input  card_detect,\n    output int_a,\n    output int_b,\n    output int_c,\n    output sd_clk_o_pad,\n    output sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input  sd_dat_dat_i,\n    input  sd_cmd_dat_i,\n    input  sd_clk_i_pad,\n    input  sd_clk_i,\n    input  sd_dat_i,\n    input  sd_cmd_i,\n    input  sd_dat_o,\n    input  sd_cmd_o,\n    input  sd_dat_oe_i,\n    input  sd_cmd_oe_i,\n    input  sd_clk_o,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_o_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd_cmd_o_pad,\n    input  sd_dat_oe_pad,\n    input  sd_cmd_oe_pad,\n    input  sd_clk_i_pad,\n    input  sd_dat_i_pad,\n    input  sd_cmd_i_pad,\n    input  sd_dat_o_pad,\n    input  sd", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 4, "code": "Here is the Verilog code for the sdc_controller module:\n```\nmodule sdc_controller(\n    input  wb_clk_i,\n    input  wb_rst_i,\n    input  [3:0] wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0] wb_adr_i,\n    input  wb_we_i,\n    input  wb_cyc_i,\n    input  wb_stb_i,\n    output wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output [3:0] m_wb_sel_o,\n    output wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [30:0] m_wb_dat_i,\n    output wb_cyc_o,\n    output wb_stb_o,\n    input  wb_ack_i,\n    output wb_cti_o,\n    output wb_bte_o,\n    input  card_detect\n);\n\n    // Wishbone Slave Interface\n    wire wb_ack;\n    wire wb_cti;\n    wire wb_bte;\n    wire wb_we;\n    wire wb_cyc;\n    wire wb_stb;\n    wire wb_dat_o_valid;\n    wire wb_dat_o_ready;\n\n    // Wishbone Master Interface\n    wire m_wb_ack;\n    wire m_wb_cti;\n    wire m_wb_bte;\n    wire m_wb_we;\n    wire m_wb_cyc;\n    wire m_wb_stb;\n    wire m_wb_dat_o_valid;\n    wire m_wb_dat_o_ready;\n\n    // SDC/MMC Interface\n    wire sd_clk_i;\n    wire sd_dat_i;\n    wire sd_dat_o;\n    wire sd_dat_oe_o;\n    wire sd_cmd_dat_i;\n    wire sd_cmd_out_o;\n    wire sd_cmd_oe_o;\n\n    // Interrupts\n    wire int_a;\n    wire int_b;\n    wire int_c;\n\n    // Sub-modules\n    sd_controller_wb sd_controller_wb_i(\n       .wb_clk_i(wb_clk_i),\n       .wb_rst_i(wb_rst_i),\n       .wb_dat_i(wb_dat_i),\n       .wb_dat_o(wb_dat_o),\n       .wb_adr_i(wb_adr_i),\n       .wb_we_i(wb_we_i),\n       .wb_cyc_i(wb_cyc_i),\n       .wb_stb_i(wb_stb_i),\n       .wb_ack_o(wb_ack_o),\n       .m_wb_adr_o(m_wb_adr_o),\n       .m_wb_sel_o(m_wb_sel_o),\n       .m_wb_we_o(wb_we_o),\n       .m_wb_dat_o(m_wb_dat_o),\n       .m_wb_dat_i(m_wb_dat_i),\n       .m_wb_cyc_o(wb_cyc_o),\n       .m_wb_stb_o(wb_stb_o),\n       .m_wb_ack_i(wb_ack_i),\n       .m_wb_cti_o(wb_cti_o),\n       .m_wb_bte_o(wb_bte_o),\n       .int_a(int_a),\n       .int_b(int_b),\n       .int_c(int_c)\n    );\n\n    sd_clock_divider sd_clock_divider_i(\n       .clk(wb_clk_i),\n       .rst(wb_rst_i),\n       .divider(8'd4),\n       .sd_clk(sd_clk_i)\n    );\n\n    sd_cmd_master sd_cmd_master_i(\n       .clk(wb_clk_i),\n       .rst(wb_rst_i),\n       .new_cmd(wb_stb_i),\n       .data_write(wb_we_i),\n       .data_read(wb_we_i),\n       .arg_reg(wb_dat_i[31:0]),\n       .cmd_set_reg(wb_dat_i[15:0]),\n       .timeout_reg(wb_dat_i[15:0]),\n       .status_reg(wb_dat_o[15:0]),\n       .resp_1_reg(wb_dat_o[31:16]),\n       .err_int_reg(wb_dat_o[5:0]),\n       .normal_int_reg(wb_dat_o[15:0]),\n       .err_int_reset(wb_dat_i[0]),\n       .normal_int_reset(wb_dat_i[0]),\n       .settings(wb_dat_o[15:0]),\n       .go_idle_o(wb_dat_o[0]),\n       .cmd_out(wb_dat_o[39:0]),\n       .req_out(wb_dat_o[0]),\n       .ack_out(wb_dat_o[0]),\n       .req_in(wb_dat_i[0]),\n       .ack_in(wb_dat_i[0]),\n       .cmd_in(wb_dat_i[39:0]),\n       .serial_status(wb_dat_i[7:0]),\n       .card_detect(card_detect)\n    );\n\n   ", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 5, "code": "Here is the Verilog code for the sdc_controller module:\n```\nmodule sdc_controller(\n    // Wishbone interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Master Wishbone interface\n    output wire m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC/MMC interface\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input  wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input  wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Clock divider\n    sd_clock_divider sd_clock_divider(\n        .CLK(wb_clk_i),\n        .DIVIDER(8'd4),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // SD CMD Master\n    sd_cmd_master sd_cmd_master(\n        .CLK(wb_clk_i),\n        .RST(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(cmd_arg_s),\n        .CMD_SET_REG(cmd_set_s),\n        .TIMEOUT_REG(timeout_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(resp_1_reg),\n        .ERR_INT_REG(err_int_reg),\n        .NORMAL_INT_REG(normal_int_reg),\n        .ERR_INT_RST(err_int_rst),\n        .NORMAL_INT_RST(normal_int_rst),\n        .settings(settings),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n\n    // SD CMD Serial Host\n    sd_cmd_serial_host sd_cmd_serial_host(\n        .SD_CLK_IN(sd_clk_i_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_set_s),\n        .CMD_IN(cmd_in),\n        .REQ_IN(req_in),\n        .ACK_IN(ack_in),\n        .cmd_dat_i(cmd_dat_i),\n        .CMD_OUT(cmd_out),\n        .ACK_OUT(ack_out),\n        .REQ_OUT(req_out),\n        .STATUS(status),\n        .cmd_oe_o(cmd_oe_o),\n        .cmd_out_o(cmd_out_o),\n        .st_dat_t(st_dat_t)\n    );\n\n    // SD Data Master\n    sd_data_master sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_o_s),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_o_s),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(cmd_tsf_err),\n        .card_status(card_status),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(Dat_Int_Status_rst),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status)\n    );\n\n    // SD Data Serial Host\n    sd_data_serial_host sd_data_serial_host(\n        .sd_clk(sd_clk_i_pad),\n        .rst(wb_rst_i),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(DAT_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(DAT_oe_o),\n        .DAT_dat_o(DAT_dat_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n\n    // RX BD\n    rx_bd rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_o_s),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s)\n    );\n\n    // TX BD\n    tx_bd tx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(free_tx_bd),\n        .re_s(re_s_tx),\n        .ack_o_s(ack_o_s),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s(dat_out_s)\n    );\n\n    // SD FIFO TX Filler\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_o(dat_o),\n        .rd(rd),\n        .empty(empty),\n        .fe(fe)\n    );\n\n    // SD FIFO RX Filler\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_i(dat_i),\n        .wr(wr),\n        .full(full),\n        .fe(fe)\n    );\n\n    // Register update\n    assign cmd_int_busy = (status_reg[0] == 1'b1);\n    assign status_reg = (cmd_int_busy) ? 1'b1 : STATUS_REG[15:1];\n    assign normal_int_status_reg = NORMAL_INT_REG;\n    assign error_int_status_reg = ERR_INT_REG;\n    assign Bd_isr_reg = Dat_Int_Status;\n    assign Bd_isr_enable_reg = Dat_Int_Status;\n\nendmodule\n```\nNote that this is a simplified version of the code, and some details may be missing. The original code may have additional features and complexities that are not included in this simplified version.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 6, "code": "module sd_controller(\n    // Wishbone Slave Interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    input  wire m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC/MMC Interface\n    input  wire sd_clk_i_pad,\n    output wire sd_clk_o_pad,\n    input  wire sd_dat_dat_i,\n    output wire sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input  wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // sd_controller_wb\n    sd_controller_wb sd_controller_wb(\n       .wb_clk_i(wb_clk_i),\n       .wb_rst_i(wb_rst_i),\n       .wb_dat_i(wb_dat_i),\n       .wb_dat_o(wb_dat_o),\n       .wb_adr_i(wb_adr_i),\n       .wb_we_i(wb_we_i),\n       .wb_cyc_i(wb_cyc_i),\n       .wb_stb_i(wb_stb_i),\n       .wb_ack_o(wb_ack_o),\n       .we_m_tx_bd(we_m_tx_bd),\n       .we_m_rx_bd(we_m_rx_bd),\n       .new_cmd(new_cmd),\n       .we_ack(we_ack),\n       .int_ack(int_ack),\n       .cmd_int_busy(cmd_int_busy),\n       .int_busy(int_busy),\n       .write_req_s(write_req_s),\n       .cmd_set_s(cmd_set_s),\n       .cmd_arg_s(cmd_arg_s),\n       .argument_reg(argument_reg),\n       .cmd_setting_reg(cmd_setting_reg),\n       .status_reg(status_reg),\n       .cmd_resp_1(cmd_resp_1),\n       .software_reset_reg(software_reset_reg),\n       .time_out_reg(time_out_reg),\n       .normal_int_status_reg(normal_int_status_reg),\n       .error_int_status_reg(error_int_status_reg),\n       .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n       .error_int_signal_enable_reg(error_int_signal_enable_reg),\n       .clock_divider(clock_divider),\n       .Bd_Status_reg(Bd_Status_reg),\n       .Bd_isr_reg(Bd_isr_reg),\n       .Bd_isr_enable_reg(Bd_isr_enable_reg),\n       .bd_isr_reset(bd_isr_reset),\n       .normal_isr_reset(normal_isr_reset),\n       .error_isr_reset(error_isr_reset),\n       .dat_in_m_tx_bd(dat_in_m_tx_bd),\n       .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // sd_clock_divider\n    sd_clock_divider sd_clock_divider(\n       .CLK(wb_clk_i),\n       .DIVIDER(clock_divider),\n       .RST(wb_rst_i),\n       .SD_CLK(sd_clk_o_pad)\n    );\n\n    // sd_cmd_master\n    sd_cmd_master sd_cmd_master(\n       .CLK_PAD_IO(wb_clk_i),\n       .RST_PAD_I(wb_rst_i),\n       .New_CMD(new_cmd),\n       .data_write(data_write),\n       .data_read(data_read),\n       .ARG_REG(argument_reg),\n       .CMD_SET_REG(cmd_setting_reg),\n       .TIMEOUT_REG(time_out_reg),\n       .STATUS_REG(status_reg),\n       .RESP_1_REG(cmd_resp_1),\n       .ERR_INT_REG(error_int_status_reg),\n       .NORMAL_INT_REG(normal_int_status_reg),\n       .ERR_INT_RST(error_isr_reset),\n       .NORMAL_INT_RST(normal_isr_reset),\n       .settings(cmd_setting_reg),\n       .go_idle_o(go_idle_o),\n       .cmd_out(cmd_out),\n       .req_out(req_out),\n       .ack_out(ack_out),\n       .req_in(req_in),\n       .ack_in(ack_in),\n       .cmd_in(cmd_in),\n       .serial_status(serial_status),\n       .card_detect(card_detect)\n    );\n\n    // sd_cmd_serial_host\n    sd_cmd_serial_host sd_cmd_serial_host(\n       .SD_CLK_IN(sd_clk_i_pad),\n       .RST_IN(wb_rst_i),\n       .SETTING_IN(cmd_setting_reg),\n       .CMD_IN(cmd_in),\n       .REQ_IN(req_in),\n       .ACK_IN(ack_in),\n       .cmd_dat_i(cmd_dat_i),\n       .CMD_OUT(cmd_out),\n       .ACK_OUT(ack_out),\n       .REQ_OUT(req_out),\n       .STATUS(serial_status),\n       .cmd_oe_o(cmd_oe_o),\n       .cmd_out_o(cmd_out_o),\n       .st_dat_t(st_dat_t)\n    );\n\n    // sd_data_master\n    sd_data_master sd_data_master(\n       .clk(wb_clk_i),\n       .rst(wb_rst_i),\n       .dat_in_tx(dat_in_m_tx_bd),\n       .free_tx_bd(free_tx_bd),\n       .ack_i_s_tx(ack_i_s_tx),\n       .dat_in_rx(dat_in_m_rx_bd),\n       .free_rx_bd(free_rx_bd),\n       .ack_i_s_rx(ack_i_s_rx),\n       .cmd_busy(cmd_int_busy),\n       .we_ack(we_ack),\n       .cmd_tsf_err(cmd_tsf_err),\n       .card_status(card_status),\n       .tx_empt(tx_empt),\n       .tx_full(tx_full),\n       .rx_full(rx_full),\n       .busy_n(busy_n),\n       .transm_complete(transm_complete),\n       .crc_ok(crc_ok),\n       .Dat_Int_Status_rst(Dat_Int_Status_rst),\n       .transfer_type(transfer_type),\n       .re_s_tx(re_s_tx),\n       .a_cmp_tx(a_cmp_tx),\n       .re_s_rx(re_s_rx),\n       .a_cmp_rx(a_cmp_rx),\n       .we_req(we_req),\n       .d_write(d_write),\n       .d_read(d_read),\n       .cmd_arg(cmd_arg),\n       .cmd_set(cmd_set),\n       .start_tx_fifo(start_tx_fifo),\n       .start_rx_fifo(start_rx_fifo),\n       .sys_adr(sys_adr),\n       .ack_transfer(ack_transfer),\n       .Dat_Int_Status(Dat_Int_Status),\n       .CIDAT(cidat_w)\n    );\n\n    // sd_data_serial_host\n    sd_data_serial_host sd_data_serial_host(\n       .sd_clk(sd_clk_i_pad),\n       .rst(wb_rst_i),\n       .data_in(dat_in_m_tx_bd),\n       .start_dat(start_dat),\n       .ack_transfer(ack_transfer),\n       .DAT_dat_i(sd_dat_dat_i),\n       .rd(rd),\n       .data_out(sd_dat_out_o),\n       .we(we),\n       .DAT_oe_o(DAT_oe_o),\n       .DAT_dat_o(sd_dat_out_o),\n       .busy_n(busy_n),\n       .transm_complete(transm_complete),\n       .crc_ok(crc_ok)\n    );\n\n    // rx_bd/tx_bd\n    rx_bd rx_bd(\n       .clk(wb_clk_i),\n       .rst(wb_rst_i),\n       .we_m(we_m_rx_bd),\n       .dat_in_m(dat_in_m_rx_bd),\n       .free_bd(free_rx_bd),\n       .re_s(re_s_rx),\n       .ack_o_s(ack_o_s_rx),\n       .a_cmp(a_cmp_rx),\n       .dat_out_s(dat_out_s_rx)\n    );\n\n    // sd_fifo_tx_filler\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n       .clk(wb_clk_i),\n       .rst(wb_rst_i),\n       .m_wb_adr_o(m_wb_adr_o),\n       .m_wb_we_o(m_wb_we_o),\n       .m_wb_dat_o(m_wb_dat_o),\n       .m_wb_cyc_o(m_wb_cyc_o),\n       .m_wb_stb_o(m_wb_stb_o),\n       .m_wb_ack_i(m_wb_ack_i),\n       .m_wb_cti_o(m_wb_cti_o),\n       .m_wb_bte_o(m_wb_bte_o),\n       .en(en),\n       .adr(adr),\n       .sd_clk(sd_clk_i_pad),\n       .dat_o(dat_o),\n       .rd(rd),\n       .empty(empty),\n       .fe(fe)\n    );\n\n    // sd_fifo_rx_filler\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n       .clk(wb_clk_i),\n       .rst(wb_rst_i),\n       .m_wb_adr_o(m_wb_adr_o),\n       .m_wb_we_o(m_wb_we_o),\n       .m_wb_dat_o(m_wb_dat_o),\n       .m_wb_cyc_o(m_wb_cyc_o),\n       .m_wb_stb_o(m_wb_stb_o),\n       .m_wb_ack_i(m_wb_ack_i),\n       .m_wb_cti_o(m_wb_cti_o),\n       .m_wb_bte_o(m_wb_bte_o),\n       .en(en),\n       .adr(adr),\n       .sd_clk(sd_clk_i_pad),\n       .dat_i(dat_i),\n       .wr(wr),\n       .full(full)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 7, "code": "module sd_controller(\n    // Wishbone Slave Interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire         wb_we_i,\n    input  wire         wb_cyc_i,\n    input  wire         wb_stb_i,\n    output wire         wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire         m_wb_clk_o,\n    output wire         m_wb_rst_o,\n    output wire [3:0]   m_wb_sel_o,\n    output wire [31:0]   m_wb_dat_o,\n    input  wire [31:0]   m_wb_dat_i,\n    output wire         m_wb_cyc_o,\n    output wire         m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire [2:0]   m_wb_cti_o,\n    output wire [1:0]   m_wb_bte_o,\n    output wire         m_wb_we_o,\n    output wire         m_wb_adr_o,\n\n    // SDC/MMC Interface\n    output wire         sd_cmd_out_o,\n    output wire         sd_cmd_oe_o,\n    input  wire [3:0]   sd_dat_dat_i,\n    output wire [3:0]   sd_dat_out_o,\n    output wire         sd_dat_oe_o,\n    output wire         sd_clk_o_pad,\n\n    // Interrupts\n    output wire         int_a,\n    output wire         int_b,\n    output wire         int_c\n);\n\n    // Clock Divider\n    sd_clock_divider sd_clock_divider(\n        .CLK(wb_clk_i),\n        .RST(wb_rst_i),\n        .DIVIDER(8'd4),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // SD CMD Master\n    sd_cmd_master sd_cmd_master(\n        .CLK(wb_clk_i),\n        .RST(wb_rst_i),\n        .New_CMD(wb_stb_i),\n        .data_write(wb_we_i),\n        .data_read(wb_we_i),\n        .ARG_REG(wb_dat_i[31:0]),\n        .CMD_SET_REG(wb_dat_i[15:0]),\n        .TIMEOUT_REG(wb_dat_i[15:0]),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(err_int_rst),\n        .NORMAL_INT_RST(normal_int_rst),\n        .settings(cmd_setting_reg),\n        .go_idle_o(go_idle),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n\n    // SD CMD Serial Host\n    sd_cmd_serial_host sd_cmd_serial_host(\n        .SD_CLK_IN(sd_clk_i),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(cmd_in),\n        .REQ_IN(req_in),\n        .ACK_IN(ack_in),\n        .cmd_dat_i(cmd_dat_i),\n        .CMD_OUT(cmd_out),\n        .ACK_OUT(ack_out),\n        .REQ_OUT(req_out),\n        .STATUS(status),\n        .cmd_oe_o(cmd_oe_o),\n        .cmd_out_o(cmd_out_o),\n        .st_dat_t(st_dat_t)\n    );\n\n    // SD Data Master\n    sd_data_master sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(cmd_tsf_err),\n        .card_status(card_status),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(Dat_Int_Status_rst),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n\n    // SD Data Serial Host\n    sd_data_serial_host sd_data_serial_host(\n        .sd_clk(sd_clk_i),\n        .rst(wb_rst_i),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(DAT_dat_i),\n        .rd(rd),\n        .data_out(DAT_dat_o),\n        .we(we),\n        .DAT_oe_o(DAT_oe_o),\n        .DAT_dat_o(DAT_dat_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n\n    // RX BD\n    rx_bd rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_o_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s)\n    );\n\n    // TX BD\n    tx_bd tx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(free_tx_bd),\n        .re_s(re_s_tx),\n        .ack_o_s(ack_o_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s(dat_out_s)\n    );\n\n    // SD FIFO TX Filler\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i),\n        .dat_o(dat_o),\n        .rd(rd),\n        .empty(empty),\n        .fe(fe)\n    );\n\n    // SD FIFO RX Filler\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i),\n        .dat_i(dat_i),\n        .wr(wr),\n        .full(full)\n    );\n\n    // Register Update\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            status_reg <= 0;\n            cmd_int_busy <= 0;\n        end else begin\n            if (cmd_int_busy) begin\n                status_reg <= {cmd_int_busy, status_reg[15:1]};\n            end\n        end\n    end\n\n    // Interrupts\n    assign int_a = (normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = (error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = (Bd_isr_reg & Bd_isr_enable_reg);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 8, "code": "Here is the Verilog code for the sdc_controller module:\n```\nmodule sdc_controller(\n    // Wishbone Interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Master Wishbone Interface\n    output wire m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    input  wire m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC/MMC Interface\n    input  wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input  wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // sd_controller_wb module\n    sd_controller_wb sd_controller_wb(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // sd_clock_divider module\n    sd_clock_divider sd_clock_divider(\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // sd_cmd_master module\n    sd_cmd_master sd_cmd_master(\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(cmd_arg_s),\n        .CMD_SET_REG(cmd_set_s),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(cmd_setting_reg),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n\n    // sd_cmd_serial_host module\n    sd_cmd_serial_host sd_cmd_serial_host(\n        .SD_CLK_IN(sd_clk_o_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_out),\n        .cmd_dat_i(cmd_dat_i),\n        .CMD_OUT(cmd_out),\n        .ACK_OUT(ack_out),\n        .REQ_OUT(req_out),\n        .STATUS(serial_status),\n        .cmd_oe_o(cmd_oe_o),\n        .cmd_out_o(cmd_out),\n        .st_dat_t(st_dat_t)\n    );\n\n    // sd_data_master module\n    sd_data_master sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(cmd_tsf_err),\n        .card_status(card_status),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(Dat_Int_Status_rst),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n\n    // sd_data_serial_host module\n    sd_data_serial_host sd_data_serial_host(\n        .sd_clk(sd_clk_o_pad),\n        .rst(wb_rst_i),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(DAT_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(DAT_oe_o),\n        .DAT_dat_o(DAT_dat_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n\n    // rx_bd/tx_bd module\n    rx_bd rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_o_s_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s_rx)\n    );\n\n    // sd_fifo_tx_filler module\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_o_pad),\n        .dat_o(dat_o),\n        .rd(rd),\n        .empty(empty),\n        .fe(fe)\n    );\n\n    // sd_fifo_rx_filler module\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_o_pad),\n        .dat_i(DAT_dat_i),\n        .wr(wr),\n        .full(full)\n    );\n\n    // Master Wishbone Interface Control\n    assign m_wb_cyc_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_cyc_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_cyc_o : 1'b0);\n    assign m_wb_stb_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_stb_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_stb_o : 1'b0);\n    assign m_wb_cti_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_cti_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_cti_o : 3'b0);\n    assign m_wb_bte_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_bte_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_bte_o : 2'b0);\n    assign m_wb_we_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_we_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_we_o : 1'b0);\n    assign m_wb_adr_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_adr_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_adr_o : 32'b0);\n\n    // Register Update\n    assign status_reg[0] = cmd_int_busy ? 1'b1 : STATUS_REG[0];\n    assign status_reg[15:1] = STATUS_REG[15:1];\n    assign normal_int_status_reg = NORMAL_INT_REG;\n    assign error_int_status_reg = ERR_INT_REG;\n    assign Bd_Status_reg = free_rx_bd;\n    assign Bd_isr_reg = Dat_Int_Status;\n    assign Bd_isr_enable_reg = Dat_Int_Status;\n    assign bd_isr_reset = Dat_Int_Status_rst;\n    assign normal_isr_reset = normal_isr_reset;\n    assign error_isr_reset = error_isr_reset;\n\nendmodule\n```\nNote that this is a very long and complex module, and it's not possible to include all the details in this response. The above code is a simplified version of the module, and you may need to add or modify some signals or modules to match your specific requirements.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 9, "code": "module sd_controller(\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input  wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input  wire card_detect,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Wishbone Slave Interface\n    wire [31:0] wb_dat_o_reg;\n    wire wb_ack_o_reg;\n    wire wb_we_o_reg;\n    wire wb_cyc_o_reg;\n    wire wb_stb_o_reg;\n    wire wb_cti_o_reg;\n    wire wb_bte_o_reg;\n\n    sd_controller_wb wb_slave(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o_reg),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o_reg),\n        .wb_cti_o(wb_cti_o_reg),\n        .wb_bte_o(wb_bte_o_reg)\n    );\n\n    // Master Wishbone Interface\n    wire m_wb_dat_o_reg;\n    wire m_wb_we_o_reg;\n    wire m_wb_cyc_o_reg;\n    wire m_wb_stb_o_reg;\n    wire m_wb_cti_o_reg;\n    wire m_wb_bte_o_reg;\n\n    sd_data_master sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_m_tx_bd(wb_dat_o_reg),\n        .free_tx_bd(wb_we_o_reg),\n        .we_ack(wb_ack_o_reg),\n        .cmd_busy(wb_stb_o_reg),\n        .cmd_tsf_err(wb_cti_o_reg),\n        .card_status(wb_adr_i),\n        .tx_empt(wb_we_i),\n        .tx_full(wb_cyc_i),\n        .rx_full(wb_stb_i),\n        .busy_n(wb_ack_o_reg),\n        .transm_complete(wb_cti_o_reg),\n        .crc_ok(wb_bte_o_reg),\n        .Dat_Int_Status_rst(wb_dat_i),\n        .transfer_type(wb_adr_i),\n        .re_s_tx(wb_we_o_reg),\n        .a_cmp_tx(wb_ack_o_reg),\n        .re_s_rx(wb_stb_o_reg),\n        .a_cmp_rx(wb_cti_o_reg),\n        .we_req(wb_we_i),\n        .d_write(wb_cyc_i),\n        .d_read(wb_stb_i),\n        .cmd_arg(wb_dat_o_reg),\n        .cmd_set(wb_adr_i),\n        .start_tx_fifo(wb_we_o_reg),\n        .start_rx_fifo(wb_stb_i),\n        .sys_adr(wb_adr_i),\n        .ack_transfer(wb_ack_o_reg),\n        .Dat_Int_Status(wb_dat_i),\n        .CIDAT(wb_cti_o_reg)\n    );\n\n    // SDC/MMC Interface\n    wire sd_clk_i;\n    wire sd_dat_i;\n    wire sd_dat_o;\n    wire sd_dat_oe_o;\n    wire sd_cmd_dat_i;\n    wire sd_cmd_out_o;\n    wire sd_cmd_oe_o;\n\n    sd_clock_divider sd_clock_divider(\n        .CLK(wb_clk_i),\n        .DIVIDER(8'd4),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_i)\n    );\n\n    sd_cmd_master sd_cmd_master(\n        .CLK(sd_clk_i),\n        .RST(wb_rst_i),\n        .New_CMD(wb_stb_i),\n        .data_write(wb_we_i),\n        .data_read(wb_cyc_i),\n        .ARG_REG(wb_dat_o_reg),\n        .CMD_SET_REG(wb_adr_i),\n        .TIMEOUT_REG(wb_dat_i),\n        .STATUS_REG(wb_dat_o_reg),\n        .RESP_1_REG(wb_dat_i),\n        .ERR_INT_REG(wb_dat_o_reg),\n        .NORMAL_INT_REG(wb_dat_i),\n        .ERR_INT_RST(wb_dat_i),\n        .NORMAL_INT_RST(wb_dat_o_reg),\n        .settings(wb_dat_o_reg),\n        .go_idle_o(wb_stb_i),\n        .cmd_out(wb_dat_o_reg),\n        .req_out(wb_we_i),\n        .ack_out(wb_ack_o_reg),\n        .req_in(wb_dat_i),\n        .ack_in(wb_dat_o_reg),\n        .cmd_in(wb_dat_i),\n        .serial_status(wb_dat_o_reg),\n        .card_detect(wb_dat_i)\n    );\n\n    sd_cmd_serial_host sd_cmd_serial_host(\n        .SD_CLK_IN(sd_clk_i),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(wb_dat_o_reg),\n        .CMD_IN(wb_dat_i),\n        .REQ_IN(wb_we_i),\n        .ACK_IN(wb_ack_o_reg),\n        .cmd_dat_i(wb_dat_i),\n        .CMD_OUT(wb_dat_o_reg),\n        .ACK_OUT(wb_ack_o_reg),\n        .REQ_OUT(wb_we_i),\n        .STATUS(wb_dat_o_reg),\n        .cmd_oe_o(wb_dat_o_reg),\n        .cmd_out_o(wb_dat_o_reg),\n        .st_dat_t(wb_dat_i)\n    );\n\n    sd_data_serial_host sd_data_serial_host(\n        .sd_clk(sd_clk_i),\n        .rst(wb_rst_i),\n        .data_in(wb_dat_o_reg),\n        .start_dat(wb_dat_i),\n        .ack_transfer(wb_ack_o_reg),\n        .DAT_dat_i(wb_dat_i),\n        .rd(wb_we_i),\n        .data_out(wb_dat_o_reg),\n        .we(wb_ack_o_reg),\n        .DAT_oe_o(wb_dat_o_reg),\n        .DAT_dat_o(wb_dat_o_reg),\n        .busy_n(wb_dat_i),\n        .transm_complete(wb_ack_o_reg),\n        .crc_ok(wb_dat_o_reg)\n    );\n\n    rx_bd rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(wb_we_o_reg),\n        .dat_in_m(wb_dat_o_reg),\n        .free_bd(wb_dat_i),\n        .re_s(wb_stb_i),\n        .ack_o_s(wb_ack_o_reg),\n        .a_cmp(wb_dat_i),\n        .dat_out_s(wb_dat_o_reg)\n    );\n\n    tx_bd tx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(wb_we_o_reg),\n        .dat_in_m(wb_dat_o_reg),\n        .free_bd(wb_dat_i),\n        .re_s(wb_stb_i),\n        .ack_o_s(wb_ack_o_reg),\n        .a_cmp(wb_dat_i),\n        .dat_out_s(wb_dat_o_reg)\n    );\n\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(wb_adr_i),\n        .m_wb_we_o(wb_we_o_reg),\n        .m_wb_dat_i(wb_dat_i),\n        .m_wb_cyc_o(wb_cyc_i),\n        .m_wb_stb_o(wb_stb_i),\n        .m_wb_ack_i(wb_ack_o_reg),\n        .m_wb_cti_o(wb_cti_o_reg),\n        .m_wb_bte_o(wb_bte_o_reg),\n        .en(wb_we_i),\n        .adr(wb_adr_i),\n        .sd_clk(sd_clk_i),\n        .dat_o(wb_dat_o_reg),\n        .rd(wb_we_i),\n        .empty(wb_dat_i),\n        .fe(wb_dat_o_reg)\n    );\n\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(wb_adr_i),\n        .m_wb_we_o(wb_we_o_reg),\n        .m_wb_dat_o(wb_dat_o_reg),\n        .m_wb_cyc_o(wb_cyc_i),\n        .m_wb_stb_o(wb_stb_i),\n        .m_wb_ack_i(wb_ack_o_reg),\n        .m_wb_cti_o(wb_cti_o_reg),\n        .m_wb_bte_o(wb_bte_o_reg),\n        .en(wb_we_i),\n        .adr(wb_adr_i),\n        .sd_clk(sd_clk_i),\n        .dat_i(wb_dat_i),\n        .wr(wb_we_i),\n        .full(wb_dat_o_reg)\n    );\n\n    // Register Update\n    assign wb_dat_o = wb_dat_o_reg;\n    assign wb_ack_o = wb_ack_o_reg;\n    assign m_wb_adr_o = wb_adr_i;\n    assign m_wb_sel_o = 4'b1111;\n    assign m_wb_we_o = wb_we_o_reg;\n    assign m_wb_dat_o = wb_dat_o_reg;\n    assign m_wb_cyc_o = wb_cyc_i;\n    assign m_wb_stb_o = wb_stb_i;\n    assign m_wb_cti_o = wb_cti_o_reg;\n    assign m_wb_bte_o = wb_bte_o_reg;\n\n    // Interrupt Generation\n    assign int_a = (normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = (error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = (Bd_isr_reg & Bd_isr_enable_reg);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 10, "code": "Here is the Verilog code for the sdc_controller module:\n```\nmodule sdc_controller(\n    // Wishbone interface\n    input  wb_clk_i,\n    input  wb_rst_i,\n    input  [3:0] wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0] wb_adr_i,\n    input  wb_we_i,\n    input  wb_cyc_i,\n    input  wb_stb_i,\n    output wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output [3:0] m_wb_sel_o,\n    output wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output wb_cyc_o,\n    output wb_stb_o,\n    input  wb_ack_i,\n    output wb_cti_o,\n    output wb_bte_o,\n\n    // SDC/MMC interface\n    input  sd_cmd_dat_i,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input  [3:0] sd_dat_dat_i,\n    output [3:0] sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_clk_o_pad,\n    input  sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c,\n\n    // Optional IO\n    input  sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c\n);\n\n    // sd_controller_wb module\n    sd_controller_wb sd_controller_wb(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_sel_o(m_wb_sel_o),\n        .m_wb_we_o(wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(wb_cyc_o),\n        .m_wb_stb_o(wb_stb_o),\n        .m_wb_ack_i(wb_ack_i),\n        .m_wb_cti_o(wb_cti_o),\n        .m_wb_bte_o(wb_bte_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .cmd_busy(cmd_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // sd_clock_divider module\n    sd_clock_divider sd_clock_divider(\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // sd_cmd_master module\n    sd_cmd_master sd_cmd_master(\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(ERR_INT_RST),\n        .NORMAL_INT_RST(NORMAL_INT_RST),\n        .settings(settings),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n\n    // sd_cmd_serial_host module\n    sd_cmd_serial_host sd_cmd_serial_host(\n        .SD_CLK_IN(sd_clk_i_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(settings),\n        .CMD_IN(cmd_in),\n        .REQ_IN(req_in),\n        .ACK_IN(ack_in),\n        .cmd_dat_i(cmd_dat_i),\n        .CMD_OUT(cmd_out),\n        .ACK_OUT(ack_out),\n        .REQ_OUT(req_out),\n        .STATUS(serial_status),\n        .cmd_oe_o(cmd_oe_o),\n        .cmd_out_o(cmd_out_o),\n        .st_dat_t(st_dat_t)\n    );\n\n    // sd_data_master module\n    sd_data_master sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(cmd_tsf_err),\n        .card_status(card_status),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(Dat_Int_Status_rst),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n\n    // sd_data_serial_host module\n    sd_data_serial_host sd_data_serial_host(\n        .sd_clk(sd_clk_i_pad),\n        .rst(wb_rst_i),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(DAT_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(DAT_oe_o),\n        .DAT_dat_o(DAT_dat_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n\n    // rx_bd/tx_bd module\n    rx_bd rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_o_s_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s_rx)\n    );\n\n    // sd_fifo_tx_filler module\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(wb_cyc_o),\n        .m_wb_stb_o(wb_stb_o),\n        .m_wb_ack_i(wb_ack_i),\n        .m_wb_cti_o(wb_cti_o),\n        .m_wb_bte_o(wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_o(dat_o),\n        .rd(rd),\n        .empty(empty),\n        .fe(fe)\n    );\n\n    // sd_fifo_rx_filler module\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(wb_cyc_o),\n        .m_wb_stb_o(wb_stb_o),\n        .m_wb_ack_i(wb_ack_i),\n        .m_wb_cti_o(wb_cti_o),\n        .m_wb_bte_o(wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_i(DAT_dat_i),\n        .wr(wr),\n        .full(full)\n    );\n\nendmodule\n```\nNote that this is a very long and complex module, and it's not possible to include all the details in this response. The above code is a simplified version of the module, and you may need to add or modify some signals and modules to match your specific requirements.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 19, "code": "module sd_rx_fifo(\n    input  logic clk_w,\n    input  logic clk_r,\n    input  logic rst,\n    input  logic [3:0] d,\n    input  logic wr,\n    output logic [31:0] q,\n    input  logic rd,\n    output logic full,\n    output logic empty,\n    output logic [1:0] mem_empt,\n    output logic ft\n);\n\n    // Define FIFO parameters\n    localparam FIFO_RX_MEM_DEPTH = 1 << FIFO_RX_MEM_ADR_SIZE;\n    localparam FIFO_RX_MEM_ADR_SIZE = 8;\n\n    // Define registers\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // Initialize registers\n    initial begin\n        adr_i = 0;\n        adr_o = 0;\n        tmp = 0;\n        ft = 0;\n        for (int i = 0; i < FIFO_RX_MEM_DEPTH; i++) begin\n            ram[i] = 0;\n        end\n    end\n\n    // Write operation\n    always @(posedge clk_w) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n        end else if (wr) begin\n            tmp <= tmp | (d << (adr_i));\n            if (adr_i == FIFO_RX_MEM_ADR_SIZE-1) begin\n                ram[adr_i] <= tmp;\n                adr_i <= 0;\n                tmp <= 0;\n                ft <= 1;\n            end else begin\n                adr_i <= adr_i + 1;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge clk_r) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n        end else if (rd) begin\n            if (adr_o == adr_o) begin\n                q <= ram[adr_o];\n                adr_o <= adr_o + 1;\n            end\n        end\n    end\n\n    // Full and Empty Flags\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_i == adr_o == 0);\n    assign mem_empt = {adr_i[1:0], adr_o[1:0]};\n    assign ft = ft;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 16, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire sd_clk,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output reg full,\n    output reg empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // sd_rx_fifo module\n    sd_rx_fifo sd_rx_fifo_i(\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(1'b0),\n        .full(full),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Wishbone interface\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            if (sd_rx_fifo_i.full) begin\n                m_wb_adr_o <= sd_rx_fifo_i.q;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_cti_o <= 3'b100;\n                m_wb_bte_o <= 2'b00;\n            end else if (sd_rx_fifo_i.empty) begin\n                m_wb_adr_o <= sd_rx_fifo_i.q;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_cti_o <= 3'b100;\n                m_wb_bte_o <= 2'b00;\n            end else begin\n                m_wb_adr_o <= sd_rx_fifo_i.q;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_cti_o <= 3'b100;\n                m_wb_bte_o <= 2'b00;\n            end\n        end\n    end\n\n    // sd_rx_fifo module\n    sd_rx_fifo sd_rx_fifo_i(\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(1'b0),\n        .full(full),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 17, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    sd_rx_fifo sd_rx_fifo_i(\n       .d(dat_i),\n       .wr(wr),\n       .wclk(clk),\n       .q(m_wb_dat_o),\n       .rd(rd),\n       .full(full),\n       .empty(empty),\n       .mem_empt(m_wb_cti_o[1:0]),\n       .rclk(clk),\n       .rst(rst)\n    );\n\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else if (en) begin\n            if (!empty && wb_free) begin\n                rd <= 1;\n                m_wb_we_o <= 1;\n                m_wb_adr_o <= adr + offset;\n                m_wb_stb_o <= 1;\n                m_wb_cyc_o <= 1;\n                wb_free <= 0;\n            end else if (m_wb_ack_i &&!wb_free) begin\n                wb_free <= 1;\n                offset <= offset + MEM_OFFSET;\n            end\n        end else begin\n            reset_rx_fifo <= 1;\n            rd <= 0;\n            offset <= 0;\n            wb_free <= 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 18, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    output wire m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire empty\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // sd_rx_fifo module\n    sd_rx_fifo sd_rx_fifo(\n       .d(dat_i),\n       .wr(wr),\n       .wclk(sd_clk),\n       .q(m_wb_dat_o),\n       .rd(rd),\n       .full(full),\n       .empty(empty),\n       .mem_empt(m_wb_cti_o),\n       .rclk(clk),\n       .rst(rst)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = adr + offset;\n    assign m_wb_we_o = rd;\n    assign m_wb_cyc_o = en;\n    assign m_wb_stb_o = rd;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_ack_i = m_wb_ack_i;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else if (en) begin\n            if (reset_rx_fifo) begin\n                reset_rx_fifo <= 0;\n                rd <= 0;\n            end else if (wb_free &&!empty) begin\n                rd <= 1;\n                wb_free <= 0;\n            end else if (m_wb_ack_i) begin\n                wb_free <= 1;\n                offset <= offset + MEM_OFFSET;\n            end else begin\n                rd <= 0;\n            end\n        end else begin\n            reset_rx_fifo <= 1;\n            rd <= 0;\n            offset <= 0;\n            wb_free <= 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 19, "code": "module sd_fifo_rx_filler(\n    input  wire clk,\n    input  wire rst,\n    input  wire sd_clk,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output reg [31:0] m_wb_adr_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [3:0] m_wb_cti_o,\n    output reg [1:0] m_wb_stb_o,\n    output reg [1:0] m_wb_cyc_o,\n    input  wire m_wb_ack_i,\n    output reg [1:0] m_wb_we_o,\n    output reg [1:0] m_wb_stb_o,\n    output reg [1:0] m_wb_cyc_o,\n    output reg full,\n    output reg empty\n);\n\n    // Registers\n    reg [8:0] offset;\n    reg [1:0] wb_free;\n    reg [1:0] reset_rx_fifo;\n    reg [1:0] rd;\n\n    // FIFO\n    wire [31:0] dat_o;\n    wire [1:0] full;\n    wire [1:0] empty;\n\n    sd_rx_fifo sd_rx_fifo_instance(\n       .d(dat_i),\n       .wr(wr),\n       .wclk(sd_clk),\n       .q(dat_o),\n       .rd(rd),\n       .full(full),\n       .empty(empty),\n       .rst(reset_rx_fifo)\n    );\n\n    // Wishbone interface\n    assign m_wb_adr_o = adr + offset;\n    assign m_wb_dat_o = dat_o;\n    assign m_wb_bte_o = 2'b00;\n    assign m_wb_cti_o = 4'b0000;\n    assign m_wb_stb_o = 1'b0;\n    assign m_wb_cyc_o = 1'b0;\n    assign m_wb_we_o = 1'b0;\n\n    // State machine\n    always @(posedge clk) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 2'b00;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end else if (en) begin\n            if (empty && wb_free) begin\n                rd <= 1'b1;\n                wb_free <= 2'b00;\n            end else if (m_wb_ack_i) begin\n                wb_free <= 2'b01;\n                offset <= offset + MEM_OFFSET;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            wb_free <= 2'b00;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 18, "code": "module sd_bd(\n    input  clk,\n    input  rst,\n    input  we_m,\n    input  [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output [BD_WIDTH-1:0] free_bd,\n    input  re_s,\n    output ack_o_s,\n    input  a_cmp,\n    output [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Import sd_defines.v\n    `include \"sd_defines.v\"\n\n    // Define BD_WIDTH and BD_SIZE\n    localparam BD_WIDTH = `BD_WIDTH;\n    localparam BD_SIZE = `BD_SIZE;\n\n    // Define RAM_MEM_WIDTH\n    localparam RAM_MEM_WIDTH = `RAM_MEM_WIDTH;\n\n    // Define counters and pointers\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] free_bd_count;\n    reg [BD_WIDTH-1:0] write_count;\n    reg [BD_WIDTH-1:0] read_count;\n\n    // Define new_bd and last_a_cmp\n    reg new_bd;\n    reg last_a_cmp;\n\n    // Define BD buffer\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n\n    // Initialize BD buffer\n    initial begin\n        for (int i = 0; i < BD_SIZE; i++) begin\n            bd_mem[i] = 0;\n        end\n    end\n\n    // Initialize counters and pointers\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            free_bd_count <= BD_SIZE / 2;\n            write_count <= 0;\n            read_count <= 0;\n            new_bd <= 0;\n            last_a_cmp <= 0;\n        end\n    end\n\n    // Write operation\n    always @(posedge clk) begin\n        if (we_m) begin\n            if (free_bd_count > 0) begin\n                if (`BD_WIDTH == 32) begin\n                    if (write_count == 1) begin\n                        bd_mem[m_wr_pnt] <= dat_in_m;\n                        m_wr_pnt <= m_wr_pnt + 1;\n                        write_count <= 0;\n                        new_bd <= 1;\n                        free_bd_count <= free_bd_count - 1;\n                    end\n                    else begin\n                        write_count <= write_count + 1;\n                    end\n                end\n                else if (`BD_WIDTH == 16) begin\n                    if (write_count == 3) begin\n                        bd_mem[m_wr_pnt] <= dat_in_m;\n                        m_wr_pnt <= m_wr_pnt + 1;\n                        write_count <= 0;\n                        new_bd <= 1;\n                        free_bd_count <= free_bd_count - 1;\n                    end\n                    else begin\n                        write_count <= write_count + 1;\n                    end\n                end\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge clk) begin\n        if (re_s) begin\n            if (`BD_WIDTH == 32) begin\n                if (read_count == 1) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_count <= 0;\n                    ack_o_s <= 1;\n                end\n                else begin\n                    read_count <= read_count + 1;\n                end\n            end\n            else if (`BD_WIDTH == 16) begin\n                if (read_count == 3) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_count <= 0;\n                    ack_o_s <= 1;\n                end\n                else begin\n                    read_count <= read_count + 1;\n                end\n            end\n        end\n    end\n\n    // Release BD\n    always @(posedge clk) begin\n        if (a_cmp) begin\n            if (`BD_WIDTH == 16) begin\n                if (last_a_cmp) begin\n                    free_bd_count <= free_bd_count + 1;\n                end\n            end\n        end\n    end\n\n    // Update free_bd\n    assign free_bd = free_bd_count;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 19, "code": "module sd_bd(\n    input  clk,\n    input  rst,\n    input  we_m,\n    input  [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output [BD_WIDTH-1:0] free_bd,\n    input  re_s,\n    output ack_o_s,\n    input  a_cmp,\n    output [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Import sd_defines.v\n`include \"sd_defines.v\"\n\n// Define BD_WIDTH and BD_SIZE\nlocalparam BD_WIDTH = `BD_WIDTH;\nlocalparam BD_SIZE = `BD_SIZE;\n\n// Define RAM_MEM_WIDTH\nlocalparam RAM_MEM_WIDTH = `RAM_MEM_WIDTH;\n\n// Define counters and pointers\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [BD_WIDTH-1:0] new_bw;\nreg [BD_WIDTH-1:0] write_cnt;\nreg [BD_WIDTH-1:0] read_cnt;\n\n// Define state machine states\nenum {INIT, WRITE, READ, RELEASE} state;\n\n// Initialize state machine\ninitial state = INIT;\n\n// Clock and reset logic\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= INIT;\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        new_bw <= 0;\n        write_cnt <= 0;\n        read_cnt <= 0;\n        free_bd <= BD_SIZE / 2;\n    end else begin\n        case (state)\n            INIT: begin\n                if (rst) begin\n                    state <= INIT;\n                    m_wr_pnt <= 0;\n                    s_rd_pnt <= 0;\n                    new_bw <= 0;\n                    write_cnt <= 0;\n                    read_cnt <= 0;\n                    free_bd <= BD_SIZE / 2;\n                end else begin\n                    state <= WRITE;\n                end\n            end\n            WRITE: begin\n                if (we_m) begin\n                    if (free_bd > 0) begin\n                        if (BD_WIDTH == 32) begin\n                            write_cnt <= write_cnt + 1;\n                            if (write_cnt == 2) begin\n                                new_bw <= 1;\n                                free_bd <= free_bd - 1;\n                                write_cnt <= 0;\n                            end\n                        end else if (BD_WIDTH == 16) begin\n                            write_cnt <= write_cnt + 1;\n                            if (write_cnt == 4) begin\n                                new_bw <= 1;\n                                free_bd <= free_bd - 1;\n                                write_cnt <= 0;\n                            end\n                        end\n                        m_wr_pnt <= m_wr_pnt + 1;\n                    end\n                end\n                state <= WRITE;\n            end\n            READ: begin\n                if (re_s) begin\n                    if (BD_WIDTH == 32) begin\n                        read_cnt <= read_cnt + 1;\n                        if (read_cnt == 2) begin\n                            ack_o_s <= 1;\n                            read_cnt <= 0;\n                        end\n                    end else if (BD_WIDTH == 16) begin\n                        read_cnt <= read_cnt + 1;\n                        if (read_cnt == 4) begin\n                            ack_o_s <= 1;\n                            read_cnt <= 0;\n                        end\n                    end\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end\n                state <= READ;\n            end\n            RELEASE: begin\n                if (a_cmp) begin\n                    free_bd <= free_bd + 1;\n                end\n                state <= RELEASE;\n            end\n        endcase\n    end\nend\n\n// Assign outputs\nassign free_bd = free_bd;\n\n// Assign ack_o_s\nassign ack_o_s = ack_o_s;\n\n// Assign dat_out_s\nassign dat_out_s = dat_out_s;\n\n// Assign bd_mem\nreg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n\n// Initialize bd_mem\ninitial begin\n    for (int i = 0; i < BD_SIZE; i++) begin\n        bd_mem[i] <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 20, "code": "// Import necessary modules\n`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input  clk,\n    input  rst,\n    output [31:0] m_wb_adr_o,\n    output  m_wb_we_o,\n    output  [31:0] m_wb_dat_o,\n    output  m_wb_cyc_o,\n    output  m_wb_stb_o,\n    input   m_wb_ack_i,\n    output  [2:0] m_wb_cti_o,\n    output  [1:0] m_wb_bte_o,\n    input   en,\n    input  [31:0] adr,\n    input   sd_clk,\n    input  [SD_BUS_W-1:0] dat_i,\n    input   wr,\n    output  full,\n    output  empty,\n    output  [FIFO_RX_MEM_ADR_SIZE-1:0] mem_empt\n);\n\n// Registers\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// sd_rx_fifo module\nsd_rx_fifo sd_rx_fifo(\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(m_wb_dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt)\n);\n\n// Wishbone interface\nalways @(posedge clk) begin\n    if (rst) begin\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_dat_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n        wb_free <= 1;\n        offset <= 0;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n    end else begin\n        if (en) begin\n            if (wb_free && !empty) begin\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1;\n                m_wb_dat_o <= sd_rx_fifo.q;\n                m_wb_cyc_o <= 1;\n                m_wb_stb_o <= 1;\n                m_wb_cti_o <= 3'b001;\n                m_wb_bte_o <= 2'b00;\n                wb_free <= 0;\n                rd <= 1;\n            end else if (m_wb_ack_i) begin\n                m_wb_adr_o <= 0;\n                m_wb_we_o <= 0;\n                m_wb_dat_o <= 0;\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                m_wb_cti_o <= 0;\n                m_wb_bte_o <= 0;\n                wb_free <= 1;\n                offset <= offset + MEM_OFFSET;\n            end\n        end else begin\n            sd_rx_fifo.wr <= 0;\n            sd_rx_fifo.rd <= 0;\n            reset_rx_fifo <= 1;\n            offset <= 0;\n            wb_free <= 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 20, "code": "module sd_rx_fifo(\n    input  wire  wclk,\n    input  wire  rclk,\n    input  wire  rst,\n    input  wire  [3:0] d,\n    input  wire  wr,\n    input  wire  rd,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    // Define the FIFO memory depth and address size\n    localparam FIFO_RX_MEM_DEPTH = 1024;\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH);\n\n    // Define the FIFO registers\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // Define the FIFO memory\n    reg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n    // Initialize the FIFO registers\n    initial begin\n        adr_i = 0;\n        adr_o = 0;\n        we = 8'h1;\n        tmp = 0;\n        ft = 0;\n    end\n\n    // Write operation\n    always @(posedge wclk) begin\n        if (rst) begin\n            adr_i = 0;\n            tmp = 0;\n            ft = 0;\n        end else if (wr) begin\n            tmp = {tmp[27:0], d};\n            if (tmp[31:28] == 4'b1111) begin\n                ram[adr_i] = tmp;\n                tmp = 0;\n                ft = 0;\n                adr_i = adr_i + 1;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk) begin\n        if (rst) begin\n            adr_o = 0;\n        end else if (rd) begin\n            if (adr_o < adr_i) begin\n                q = ram[adr_o];\n                adr_o = adr_o + 1;\n            end\n        end\n    end\n\n    // Full and empty flags\n    assign full = (adr_i == adr_o);\n    assign empty = (adr_o == adr_i);\n    assign mem_empt = {adr_i[1], adr_i[0]};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 12, "code": "module sd_cmd_master(\n    input  wire        CLK_PAD_IO,\n    input  wire        RST_PAD_I,\n    input  wire        New_CMD,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:0] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [4:0]  ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire        ERR_INT_RST,\n    input  wire        NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire        go_idle_o,\n    output wire        req_out,\n    output wire        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n// Debounce Logic\nreg [3:0] debounce;\nreg card_present;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I)\nbegin\n    if (RST_PAD_I)\n    begin\n        debounce <= 0;\n        card_present <= 0;\n    end\n    else\n    begin\n        if (!card_detect)\n        begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1;\n            else\n                card_present <= 1;\n        end\n        else\n            debounce <= 0;\n    end\nend\n\n// Request and Acknowledge Synchronizers\nreg req_q;\nreg ack_q;\nreg req_in_int;\nreg ack_in_int;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I)\nbegin\n    if (RST_PAD_I)\n    begin\n        req_q <= 0;\n        ack_q <= 0;\n    end\n    else\n    begin\n        req_q <= req_in;\n        ack_q <= ack_in;\n        req_in_int <= req_q;\n        ack_in_int <= ack_q;\n    end\nend\n\n// Finite State Machine (FSM)\nreg [2:0] state;\nreg [2:0] next_state;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I)\nbegin\n    if (RST_PAD_I)\n        state <= 3'b001;\n    else\n        state <= next_state;\nend\n\n// FSM State Transitions\nalways_comb\nbegin\n    case (state)\n        3'b001: // IDLE\n            if (New_CMD)\n                next_state = 3'b010;\n            else\n                next_state = 3'b001;\n        3'b010: // SETUP\n            if (ack_in_int)\n                next_state = 3'b100;\n            else\n                next_state = 3'b010;\n        3'b100: // EXECUTE\n            if (complete)\n                next_state = 3'b001;\n            else\n                next_state = 3'b100;\n        default: // Default to IDLE\n            next_state = 3'b001;\n    endcase\nend\n\n// FSM State Operations\nreg [15:0] CRC_check_enable;\nreg [15:0] index_check_enable;\nreg [15:0] complete;\nreg [31:0] RESP_1_REG;\nreg [4:0]  ERR_INT_REG;\nreg [15:0] NORMAL_INT_REG;\nreg [15:0] STATUS_REG;\nreg [15:0] settings;\nreg [7:0]  response_size;\nreg [15:0] Watchdog_Cnt;\nreg [15:0] CCRCE;\nreg [15:0] EI;\nreg [15:0] CC;\nreg [15:0] go_idle_o;\nreg [15:0] req_out;\nreg [15:0] ack_out;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I)\nbegin\n    if (RST_PAD_I)\n    begin\n        CRC_check_enable <= 0;\n        index_check_enable <= 0;\n        complete <= 0;\n        RESP_1_REG <= 0;\n        ERR_INT_REG <= 0;\n        NORMAL_INT_REG <= 0;\n        STATUS_REG <= 0;\n        settings <= 0;\n        response_size <= 0;\n        Watchdog_Cnt <= 0;\n        CCRCE <= 0;\n        EI <= 0;\n        CC <= 0;\n        go_idle_o <= 0;\n        req_out <= 0;\n        ack_out <= 0;\n    end\n    else\n    begin\n        case (state)\n            3'b001: // IDLE\n                begin\n                    if (req_in_int)\n                    begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                    end\n                    else\n                    begin\n                        go_idle_o <= 0;\n                        req_out <= 0;\n                        ack_out <= 0;\n                        CICMD <= 0;\n                    end\n                end\n            3'b010: // SETUP\n                begin\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    response_size <= (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) ? 7'b0101000 : (CMD_SET_REG[1:0] == 2'b01) ? 7'b1111111 : 0;\n                    settings <= {WORD_SELECT, data_read, data_write, 3'b111, CRC_check_enable, response_size};\n                    Watchdog_Cnt <= 0;\n                    CICMD <= 1;\n                end\n            3'b100: // EXECUTE\n                begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG)\n                    begin\n                        CTE <= 1;\n                        EI <= 1;\n                        if (ack_in)\n                            complete <= 1;\n                        go_idle_o <= 1;\n                    end\n                    else\n                    begin\n                        if (ack_in_int)\n                        begin\n                            req_out <= 1;\n                        end\n                        else if (req_in_int)\n                        begin\n                            STATUS_REG <= serial_status;\n                            ack_out <= 1;\n                            if (dat_ava)\n                            begin\n                                complete <= 1;\n                                EI <= 0;\n                                if (CRC_check_enable && ~crc_valid)\n                                begin\n                                    CCRCE <= 1;\n                                    EI <= 1;\n                                end\n                                if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32]))\n                                begin\n                                    CIE <= 1;\n                                    EI <= 1;\n                                end\n                                CC <= 1;\n                                if (response_size != 0)\n                                begin\n                                    RESP_1_REG <= cmd_in[31:0];\n                                end\n                            end\n                        end\n                    end\n                end\n            default: // Default to IDLE\n                begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    CICMD <= 0;\n                end\n        endcase\n    end\nend\n\n// Output Logic\nassign settings = settings;\nassign go_idle_o = go_idle_o;\nassign req_out = req_out;\nassign ack_out = ack_out;\nassign RESP_1_REG = RESP_1_REG;\nassign ERR_INT_REG = ERR_INT_REG;\nassign NORMAL_INT_REG = NORMAL_INT_REG;\nassign STATUS_REG = STATUS_REG;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 11, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC/MMC Interface\n    input  wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input  wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input  wire sd_clk_i_pad,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Wishbone Slave Interface\n    wire wb_ack;\n    wire wb_dat;\n    wire wb_adr;\n    wire wb_we;\n    wire wb_cyc;\n    wire wb_stb;\n\n    // Wishbone Master Interface\n    wire m_wb_ack;\n    wire m_wb_dat;\n    wire m_wb_adr;\n    wire m_wb_we;\n    wire m_wb_cyc;\n    wire m_wb_stb;\n\n    // SDC/MMC Interface\n    wire sd_cmd_dat;\n    wire sd_dat_dat;\n    wire sd_dat_out;\n    wire sd_dat_oe;\n    wire sd_clk;\n    wire sd_clk_pad;\n\n    // Interrupts\n    wire int_a_o;\n    wire int_b_o;\n    wire int_c_o;\n\n    // Wishbone Slave Interface\n    assign wb_ack = wb_ack_o;\n    assign wb_dat = wb_dat_o;\n    assign wb_adr = wb_adr_i;\n    assign wb_we = wb_we_i;\n    assign wb_cyc = wb_cyc_i;\n    assign wb_stb = wb_stb_i;\n\n    // Wishbone Master Interface\n    assign m_wb_ack = m_wb_ack_i;\n    assign m_wb_dat = m_wb_dat_o;\n    assign m_wb_adr = m_wb_adr_o;\n    assign m_wb_we = m_wb_we_o;\n    assign m_wb_cyc = m_wb_cyc_o;\n    assign m_wb_stb = m_wb_stb_o;\n\n    // SDC/MMC Interface\n    assign sd_cmd_dat = sd_cmd_dat_i;\n    assign sd_dat_dat = sd_dat_dat_i;\n    assign sd_dat_out = sd_dat_out_o;\n    assign sd_dat_oe = sd_dat_oe_o;\n    assign sd_clk = sd_clk_i_pad;\n    assign sd_clk_pad = sd_clk_o_pad;\n\n    // Interrupts\n    assign int_a = int_a_o;\n    assign int_b = int_b_o;\n    assign int_c = int_c_o;\n\n    // Wishbone Slave Interface\n    sd_controller_wb wb_slave (\n       .wb_clk_i(wb_clk_i),\n       .wb_rst_i(wb_rst_i),\n       .wb_dat_i(wb_dat_i),\n       .wb_dat_o(wb_dat_o),\n       .wb_adr_i(wb_adr_i),\n       .wb_we_i(wb_we_i),\n       .wb_cyc_i(wb_cyc_i),\n       .wb_stb_i(wb_stb_i),\n       .wb_ack_o(wb_ack_o)\n    );\n\n    // Wishbone Master Interface\n    sd_data_master wb_master (\n       .wb_clk_i(wb_clk_i),\n       .wb_rst_i(wb_rst_i),\n       .wb_dat_i(m_wb_dat_i),\n       .wb_dat_o(m_wb_dat_o),\n       .wb_adr_i(m_wb_adr_i),\n       .wb_we_i(m_wb_we_i),\n       .wb_cyc_i(m_wb_cyc_i),\n       .wb_stb_i(m_wb_stb_i),\n       .wb_ack_o(m_wb_ack_o)\n    );\n\n    // SDC/MMC Interface\n    sd_cmd_serial_host sd_cmd_host (\n       .sd_clk_i(sd_clk),\n       .rst_i(wb_rst_i),\n       .setting_i(wb_adr_i[15:0]),\n       .cmd_i(wb_adr_i[31:0]),\n       .req_i(wb_stb_i),\n       .ack_i(wb_ack_i),\n       .cmd_dat_i(sd_cmd_dat),\n       .cmd_out_o(sd_cmd_out_o),\n       .cmd_oe_o(sd_cmd_oe_o),\n       .cmd_dat_o(sd_dat_out_o),\n       .cmd_oe_i(sd_dat_oe_o),\n       .cmd_dat_i(sd_dat_dat),\n       .cmd_out_o(sd_dat_out_o),\n       .cmd_oe_o(sd_dat_oe_o)\n    );\n\n    // Interrupts\n    assign int_a_o = int_a;\n    assign int_b_o = int_b;\n    assign int_c_o = int_c;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 12, "code": "module sdc_controller(\n    // Wishbone interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Master Wishbone interface\n    output wire m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC/MMC interface\n    input  wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input  wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input  wire sd_clk_i_pad,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input  wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // sd_clock_divider\n    sd_clock_divider sd_clock_divider(\n        .CLK(wb_clk_i),\n        .RST(wb_rst_i),\n        .DIVIDER(8'd4),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // sd_cmd_master\n    sd_cmd_master sd_cmd_master(\n        .CLK(wb_clk_i),\n        .RST(wb_rst_i),\n        .New_CMD(wb_stb_i),\n        .data_write(wb_we_i),\n        .data_read(wb_we_i),\n        .ARG_REG(wb_dat_i[31:0]),\n        .CMD_SET_REG(wb_dat_i[15:0]),\n        .TIMEOUT_REG(wb_dat_i[15:0]),\n        .STATUS_REG(wb_dat_o[15:0]),\n        .RESP_1_REG(wb_dat_o[31:16]),\n        .ERR_INT_REG(wb_dat_o[5:0]),\n        .NORMAL_INT_REG(wb_dat_o[15:0]),\n        .ERR_INT_RST(wb_dat_i[0]),\n        .NORMAL_INT_RST(wb_dat_i[0]),\n        .settings(wb_dat_o[15:0]),\n        .go_idle_o(wb_dat_o[0]),\n        .cmd_out(wb_dat_o[39:0]),\n        .req_out(wb_dat_o[0]),\n        .ack_out(wb_dat_o[0]),\n        .req_in(wb_dat_i[0]),\n        .ack_in(wb_dat_i[0]),\n        .cmd_in(wb_dat_i[39:0]),\n        .serial_status(wb_dat_i[7:0]),\n        .card_detect(wb_dat_i[0])\n    );\n\n    // sd_cmd_serial_host\n    sd_cmd_serial_host sd_cmd_serial_host(\n        .SD_CLK_IN(sd_clk_i_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(wb_dat_i[15:0]),\n        .CMD_IN(wb_dat_i[39:0]),\n        .REQ_IN(wb_dat_i[0]),\n        .ACK_IN(wb_dat_i[0]),\n        .cmd_dat_i(wb_dat_i[0]),\n        .CMD_OUT(wb_dat_o[39:0]),\n        .ACK_OUT(wb_dat_o[0]),\n        .REQ_OUT(wb_dat_o[0]),\n        .STATUS(wb_dat_o[7:0]),\n        .cmd_oe_o(wb_dat_o[0]),\n        .cmd_out_o(wb_dat_o[0]),\n        .st_dat_t(wb_dat_o[1:0])\n    );\n\n    // sd_data_master\n    sd_data_master sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(wb_dat_i[31:0]),\n        .free_tx_bd(wb_dat_i[7:0]),\n        .ack_i_s_tx(wb_dat_i[0]),\n        .dat_in_rx(wb_dat_i[31:0]),\n        .free_rx_bd(wb_dat_i[7:0]),\n        .ack_i_s_rx(wb_dat_i[0]),\n        .cmd_busy(wb_dat_i[0]),\n        .we_ack(wb_dat_i[0]),\n        .cmd_tsf_err(wb_dat_i[0]),\n        .card_status(wb_dat_i[4:0]),\n        .tx_empt(wb_dat_i[0]),\n        .tx_full(wb_dat_i[0]),\n        .rx_full(wb_dat_i[0]),\n        .busy_n(wb_dat_i[0]),\n        .transm_complete(wb_dat_i[0]),\n        .crc_ok(wb_dat_i[0]),\n        .Dat_Int_Status_rst(wb_dat_i[0]),\n        .transfer_type(wb_dat_i[1:0]),\n        .re_s_tx(wb_dat_o[0]),\n        .a_cmp_tx(wb_dat_o[0]),\n        .re_s_rx(wb_dat_o[0]),\n        .a_cmp_rx(wb_dat_o[0]),\n        .we_req(wb_dat_o[0]),\n        .d_write(wb_dat_o[0]),\n        .d_read(wb_dat_o[0]),\n        .cmd_arg(wb_dat_o[31:0]),\n        .cmd_set(wb_dat_o[15:0]),\n        .start_tx_fifo(wb_dat_o[0]),\n        .start_rx_fifo(wb_dat_o[0]),\n        .sys_adr(wb_dat_o[31:0]),\n        .ack_transfer(wb_dat_o[0]),\n        .Dat_Int_Status(wb_dat_o[7:0]),\n        .CIDAT(wb_dat_o[0])\n    );\n\n    // sd_data_serial_host\n    sd_data_serial_host sd_data_serial_host(\n        .sd_clk(sd_clk_i_pad),\n        .rst(wb_rst_i),\n        .data_in(wb_dat_i[31:0]),\n        .start_dat(wb_dat_i[1:0]),\n        .ack_transfer(wb_dat_i[0]),\n        .DAT_dat_i(wb_dat_i[3:0]),\n        .rd(wb_dat_o[0]),\n        .data_out(wb_dat_o[3:0]),\n        .we(wb_dat_o[0]),\n        .DAT_oe_o(wb_dat_o[0]),\n        .DAT_dat_o(wb_dat_o[3:0]),\n        .busy_n(wb_dat_o[0]),\n        .transm_complete(wb_dat_o[0]),\n        .crc_ok(wb_dat_o[0])\n    );\n\n    // rx_bd/tx_bd\n    rx_bd rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(wb_dat_i[0]),\n        .dat_in_m(wb_dat_i[31:0]),\n        .free_bd(wb_dat_i[7:0]),\n        .re_s(wb_dat_i[0]),\n        .ack_o_s(wb_dat_o[0]),\n        .a_cmp(wb_dat_o[0]),\n        .dat_out_s(wb_dat_o[31:0])\n    );\n\n    // sd_fifo_tx_filler\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(wb_dat_o[31:0]),\n        .m_wb_we_o(wb_dat_o[0]),\n        .m_wb_dat_i(wb_dat_i[31:0]),\n        .m_wb_cyc_o(wb_dat_o[0]),\n        .m_wb_stb_o(wb_dat_o[0]),\n        .m_wb_ack_i(wb_dat_i[0]),\n        .m_wb_cti_o(wb_dat_o[2:0]),\n        .m_wb_bte(wb_dat_o[1:0]),\n        .en(wb_dat_i[0]),\n        .adr(wb_dat_i[31:0]),\n        .sd_clk(sd_clk_i_pad),\n        .dat_o(wb_dat_o[31:0]),\n        .rd(wb_dat_i[0]),\n        .empty(wb_dat_o[0]),\n        .fe(wb_dat_o[0])\n    );\n\n    // sd_fifo_rx_filler\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(wb_dat_o[31:0]),\n        .m_wb_we_o(wb_dat_o[0]),\n        .m_wb_dat_o(wb_dat_o[31:0]),\n        .m_wb_cyc_o(wb_dat_o[0]),\n        .m_wb_stb_o(wb_dat_o[0]),\n        .m_wb_ack_i(wb_dat_i[0]),\n        .m_wb_cti_o(wb_dat_o[2:0]),\n        .m_wb_bte(wb_dat_o[1:0]),\n        .en(wb_dat_i[0]),\n        .adr(wb_dat_i[31:0]),\n        .sd_clk(sd_clk_i_pad),\n        .dat_i(wb_dat_i[3:0]),\n        .wr(wb_dat_i[0]),\n        .full(wb_dat_o[0])\n    );\n\n    // sd_controller_wb\n    sd_controller_wb sd_controller_wb(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(wb_dat_o[0]),\n        .we_m_rx_bd(wb_dat_o[0]),\n        .new_cmd(wb_dat_o[0]),\n        .we_ack(wb_dat_o[0]),\n        .int_ack(wb_dat_o[0]),\n        .cmd_int_busy(wb_dat_o[0]),\n        .int_busy(wb_dat_o[0]),\n        .write_req_s(wb_dat_i[0]),\n        .cmd_set_s(wb_dat_i[15:0]),\n        .cmd_arg_s(wb_dat_i[31:0]),\n        .argument_reg(wb_dat_o[31:0]),\n        .cmd_setting_reg(wb_dat_o[15:0]),\n        .status_reg(wb_dat_i[15:0]),\n        .cmd_resp_1(wb_dat_o[31:0]),\n        .software_reset_reg(wb_dat_o[7:0]),\n        .time_out_reg(wb_dat_o[15:0]),\n        .normal_int_status_reg(wb_dat_i[15:0]),\n        .error_int_status_reg(wb_dat_i[15:0]),\n        .normal_int_signal_enable_reg(wb_dat_o[15:0]),\n        .error_int_signal_enable_reg(wb_dat_o[15:0]),\n        .clock_divider(wb_dat_o[7:0]),\n        .Bd_status_reg(wb_dat_i[15:0]),\n        .Bd_isr_reg(wb_dat_i[7:0]),\n        .Bd_isr_enable_reg(wb_dat_o[7:0]),\n        .bd_isr_reset(wb_dat_o[0]),\n        .normal_isr_reset(wb_dat_o[0]),\n        .error_isr_reset(wb_dat_o[0]),\n        .dat_in_m_tx_bd(wb_dat_o[RAM_MEM_WIDTH-1:0]),\n        .dat_in_m_rx_bd(wb_dat_o[RAM_MEM_WIDTH-1:0])\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 9, "code": "module sd_controller_wb(\n    input wb_clk_i,\n    input wb_rst_i,\n    input [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input [7:0] wb_adr_i,\n    input [3:0] wb_sel_i,\n    input wb_we_i,\n    input wb_cyc_i,\n    input wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input write_req_s,\n    input [15:0] cmd_set_s,\n    input [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input [15:0] status_reg,\n    input [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input [15:0] normal_int_status_reg,\n    input [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input [15:0] Bd_Status_reg,\n    input [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n// Register definitions\nreg [31:0] argument_reg;\nreg [15:0] cmd_setting_reg;\nreg [15:0] status_reg;\nreg [31:0] cmd_resp_1;\nreg [7:0] software_reset_reg;\nreg [15:0] time_out_reg;\nreg [15:0] normal_int_status_reg;\nreg [15:0] error_int_status_reg;\nreg [15:0] normal_int_signal_enable_reg;\nreg [15:0] error_int_signal_enable_reg;\nreg [7:0] clock_divider;\nreg [15:0] Bd_Status_reg;\nreg [7:0] Bd_isr_reg;\nreg [7:0] Bd_isr_enable_reg;\n\n// Control logic\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n            wb_ack_o <= 1'b1;\n        end\n        if (write_req_s) begin\n            we_ack <= 1'b1;\n        end\n        if (int_ack) begin\n            int_ack <= 1'b1;\n        end\n        if (we_m_tx_bd || we_m_rx_bd) begin\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                4'h0: argument_reg <= wb_dat_i;\n                4'h4: cmd_setting_reg <= wb_dat_i;\n                4'h8: status_reg <= wb_dat_i;\n                4'hC: cmd_resp_1 <= wb_dat_i;\n                4'h1C: software_reset_reg <= wb_dat_i;\n                4'h28: time_out_reg <= wb_dat_i;\n                4'h30: normal_int_status_reg <= wb_dat_i;\n                4'h34: error_int_status_reg <= wb_dat_i;\n                4'h38: normal_int_signal_enable_reg <= wb_dat_i;\n                4'h3C: error_int_signal_enable_reg <= wb_dat_i;\n                4'h48: clock_divider <= wb_dat_i;\n                4'h50: Bd_Status_reg <= wb_dat_i;\n                4'h54: Bd_isr_reg <= wb_dat_i;\n                4'h58: Bd_isr_enable_reg <= wb_dat_i;\n                default: ;\n            endcase\n        end\n    end\nend\n\n// Register read\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i) begin\n        case (wb_adr_i)\n            4'h0: wb_dat_o <= argument_reg;\n            4'h4: wb_dat_o <= cmd_setting_reg;\n            4'h8: wb_dat_o <= status_reg;\n            4'hC: wb_dat_o <= cmd_resp_1;\n            4'h1C: wb_dat_o <= software_reset_reg;\n            4'h28: wb_dat_o <= time_out_reg;\n            4'h30: wb_dat_o <= normal_int_status_reg;\n            4'h34: wb_dat_o <= error_int_status_reg;\n            4'h38: wb_dat_o <= normal_int_signal_enable_reg;\n            4'h3C: wb_dat_o <= error_int_signal_enable_reg;\n            4'h48: wb_dat_o <= clock_divider;\n            4'h50: wb_dat_o <= Bd_Status_reg;\n            4'h54: wb_dat_o <= Bd_isr_reg;\n            4'h58: wb_dat_o <= Bd_isr_enable_reg;\n            default: wb_dat_o <= 32'h0;\n        endcase\n    end\nend\n\n// Register write\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n        case (wb_adr_i)\n            4'h0: argument_reg <= wb_dat_i;\n            4'h4: cmd_setting_reg <= wb_dat_i;\n            4'h8: status_reg <= wb_dat_i;\n            4'hC: cmd_resp_1 <= wb_dat_i;\n            4'h1C: software_reset_reg <= wb_dat_i;\n            4'h28: time_out_reg <= wb_dat_i;\n            4'h30: normal_int_status_reg <= wb_dat_i;\n            4'h34: error_int_status_reg <= wb_dat_i;\n            4'h38: normal_int_signal_enable_reg <= wb_dat_i;\n            4'h3C: error_int_signal_enable_reg <= wb_dat_i;\n            4'h48: clock_divider <= wb_dat_i;\n            4'h50: Bd_Status_reg <= wb_dat_i;\n            4'h54: Bd_isr_reg <= wb_dat_i;\n            4'h58: Bd_isr_enable_reg <= wb_dat_i;\n            default: ;\n        endcase\n    end\nend\n\n// BD RX and TX\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n        case (wb_adr_i)\n            4'h60: begin\n                if (RAM_MEM_WIDTH == 16) begin\n                    dat_in_m_tx_bd <= {wb_dat_i[15:0], wb_dat_i[31:16]};\n                end else begin\n                    dat_in_m_tx_bd <= wb_dat_i;\n                end\n            end\n            4'h80: begin\n                if (RAM_MEM_WIDTH == 16) begin\n                    dat_in_m_rx_bd <= {wb_dat_i[15:0], wb_dat_i[31:16]};\n                end else begin\n                    dat_in_m_rx_bd <= wb_dat_i;\n                end\n            end\n            default: ;\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 13, "code": "module sdc_controller(\n    // Wishbone Slave Interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire         wb_we_i,\n    input  wire         wb_cyc_i,\n    input  wire         wb_stb_i,\n    output wire         wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire         m_wb_adr_o,\n    output wire         m_wb_sel_o,\n    output wire         m_wb_we_o,\n    output wire         m_wb_dat_o,\n    input  wire         m_wb_dat_i,\n    output wire         m_wb_cyc_o,\n    output wire         m_wb_stb_o,\n    input  wire         m_wb_ack_i,\n    output wire         m_wb_cti_o,\n    output wire         m_wb_bte_o,\n\n    // SDC/MMC Interface\n    input  wire         sd_cmd_dat_i,\n    output wire         sd_cmd_out_o,\n    output wire         sd_cmd_oe_o,\n    input  wire [3:0]   sd_dat_dat_i,\n    output wire [3:0]   sd_dat_out_o,\n    output wire         sd_dat_oe_o,\n    output wire         sd_clk_o_pad,\n    input  wire         sd_clk_i_pad,\n    output wire         int_a,\n    output wire         int_b,\n    output wire         int_c,\n\n    // Optional IO\n    input  wire         sd_clk_i_pad,\n    output wire         int_a,\n    output wire         int_b,\n    output wire         int_c\n);\n\n    // sd_controller_wb module\n    sd_controller_wb sd_controller_wb(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // sd_clock_divider module\n    sd_clock_divider sd_clock_divider(\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // sd_cmd_master module\n    sd_cmd_master sd_cmd_master(\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(cmd_arg_s),\n        .CMD_SET_REG(cmd_set_s),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(err_int_reg),\n        .NORMAL_INT_REG(normal_int_reg),\n        .ERR_INT_RST(err_int_reset),\n        .NORMAL_INT_RST(normal_int_reset),\n        .settings(cmd_setting_reg),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n\n    // sd_cmd_serial_host module\n    sd_cmd_serial_host sd_cmd_serial_host(\n        .SD_CLK_IN(sd_clk_i_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(cmd_in),\n        .REQ_IN(req_in),\n        .ACK_IN(ack_in),\n        .cmd_dat_i(cmd_dat_i),\n        .CMD_OUT(cmd_out),\n        .ACK_OUT(ack_out),\n        .REQ_OUT(req_out),\n        .STATUS(serial_status),\n        .cmd_oe_o(cmd_oe_o),\n        .cmd_out_o(cmd_out_o),\n        .st_dat_t(st_dat_t)\n    );\n\n    // sd_data_master module\n    sd_data_master sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(cmd_tsf_err),\n        .card_status(card_status),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(Dat_Int_Status_rst),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n\n    // sd_data_serial_host module\n    sd_data_serial_host sd_data_serial_host(\n        .sd_clk(sd_clk_i_pad),\n        .rst(wb_rst_i),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(DAT_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(DAT_oe_o),\n        .DAT_dat_o(DAT_dat_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n\n    // rx_bd/tx_bd module\n    rx_bd rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_o_s_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s_rx)\n    );\n\n    // sd_fifo_tx_filler module\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_o(dat_o),\n        .rd(rd),\n        .empty(empty),\n        .fe(fe)\n    );\n\n    // sd_fifo_rx_filler module\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_i(dat_i),\n        .wr(wr),\n        .full(full)\n    );\n\n    // Register Update\n    assign status_reg = cmd_int_busy ? 1'b1 : STATUS_REG[0];\n    assign normal_int_status_reg = NORMAL_INT_REG;\n    assign error_int_status_reg = ERR_INT_REG;\n    assign Bd_isr_reg = Dat_Int_Status;\n    assign Bd_isr_enable_reg = Dat_Int_Status;\n    assign bd_isr_reset = Dat_Int_Status_rst;\n    assign normal_isr_reset = normal_int_reset;\n    assign error_isr_reset = err_int_reset;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 14, "code": "module sdc_controller(\n    // Wishbone Slave Interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC/MMC Interface\n    input  wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input  wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input  wire sd_clk_i_pad,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input  wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // sd_controller_wb\n    sd_controller_wb sd_controller_wb(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // sd_clock_divider\n    sd_clock_divider sd_clock_divider(\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // sd_cmd_master\n    sd_cmd_master sd_cmd_master(\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(cmd_arg_s),\n        .CMD_SET_REG(cmd_set_s),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(cmd_setting_reg),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n\n    // sd_cmd_serial_host\n    sd_cmd_serial_host sd_cmd_serial_host(\n        .SD_CLK_IN(sd_clk_i_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_set_s),\n        .CMD_IN(cmd_in),\n        .REQ_IN(req_in),\n        .ACK_IN(ack_in),\n        .cmd_dat_i(cmd_dat_i),\n        .CMD_OUT(cmd_out),\n        .ACK_OUT(ack_out),\n        .REQ_OUT(req_out),\n        .STATUS(serial_status),\n        .cmd_oe_o(cmd_oe_o),\n        .cmd_out_o(cmd_out_o),\n        .st_dat_t(st_dat_t)\n    );\n\n    // sd_data_master\n    sd_data_master sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(cmd_tsf_err),\n        .card_status(card_status),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(Dat_Int_Status_rst),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n\n    // sd_data_serial_host\n    sd_data_serial_host sd_data_serial_host(\n        .sd_clk(sd_clk_i_pad),\n        .rst(wb_rst_i),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(DAT_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(DAT_oe_o),\n        .DAT_dat_o(DAT_dat_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n\n    // rx_bd/tx_bd\n    rx_bd rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_o_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s)\n    );\n\n    // sd_fifo_tx_filler\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_o(dat_o),\n        .rd(rd),\n        .empty(empty),\n        .fe(fe)\n    );\n\n    // sd_fifo_rx_filler\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_i(dat_i),\n        .wr(wr),\n        .full(full)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 13, "code": "module sd_cmd_master(\n    input  wire  clk_pad_io,\n    input  wire  rst_pad_i,\n    input  wire  new_cmd,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire  arg_reg [31:0],\n    input  wire  cmd_set_reg [13:0],\n    input  wire  timeout_reg [15:0],\n    output wire  status_reg [15:0],\n    output wire  resp_1_reg [31:0],\n    output wire  err_int_reg [3:0],\n    output wire  normal_int_reg [15:0],\n    input  wire  err_int_rst,\n    input  wire  normal_int_rst,\n    output wire  settings [15:0],\n    output wire  go_idle_o,\n    output wire  cmd_out [39:0],\n    output wire  req_out,\n    output wire  ack_out,\n    input  wire  req_in,\n    input  wire  ack_in,\n    input  wire  cmd_in [39:0],\n    input  wire  serial_status [7:0],\n    input  wire  card_detect\n);\n\n// Debounce Logic\nreg [3:0] debounce;\nreg card_present;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i)\nbegin\n    if (rst_pad_i)\n        debounce <= 0;\n    else\n    begin\n        if (!card_detect)\n            debounce <= debounce + 1;\n        else\n            debounce <= 0;\n        if (debounce == 4'b1111)\n            card_present <= 1;\n        else\n            card_present <= 0;\n    end\nend\n\n// Request and Acknowledge Synchronizers\nreg req_in_int;\nreg ack_in_int;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i)\nbegin\n    if (rst_pad_i)\n        req_in_int <= 0;\n    else\n        req_in_int <= req_in;\n\n    if (req_in_int)\n        req_in_int <= 0;\n\n    if (ack_in)\n        ack_in_int <= 1;\n    else\n        ack_in_int <= 0;\nend\n\n// Finite State Machine (FSM)\nreg [2:0] state;\nreg [2:0] next_state;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i)\nbegin\n    if (rst_pad_i)\n        state <= 3'b001;\n    else\n        state <= next_state;\nend\n\nalways @(posedge clk_pad_io or posedge rst_pad_i)\nbegin\n    case (state)\n        3'b001: // IDLE\n            if (new_cmd)\n                next_state <= 3'b010;\n            else\n                next_state <= 3'b001;\n        3'b010: // SETUP\n            if (ack_in_int)\n                next_state <= 3'b100;\n            else\n                next_state <= 3'b010;\n        3'b100: // EXECUTE\n            if (complete)\n                next_state <= 3'b001;\n            else\n                next_state <= 3'b100;\n        default: // Default to IDLE\n            next_state <= 3'b001;\n    endcase\nend\n\n// FSM State operation\nreg [15:0] settings_reg;\nreg [39:0] cmd_out_reg;\nreg [31:0] resp_1_reg_reg;\nreg complete;\nreg [3:0] err_int_reg_reg;\nreg [15:0] normal_int_reg_reg;\nreg [15:0] status_reg_reg;\nreg [7:0] serial_status_reg;\nreg [3:0] watchdog_cnt;\nreg [3:0] crc_check_enable;\nreg [3:0] index_check_enable;\nreg [3:0] response_size;\nreg [3:0] crce;\nreg [3:0] cie;\nreg [3:0] cte;\nreg [3:0] ei;\nreg [3:0] cc;\nreg [3:0] crc_valid;\nreg [3:0] dat_ava;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i)\nbegin\n    if (rst_pad_i)\n    begin\n        settings_reg <= 0;\n        cmd_out_reg <= 0;\n        resp_1_reg_reg <= 0;\n        complete <= 0;\n        err_int_reg_reg <= 0;\n        normal_int_reg_reg <= 0;\n        status_reg_reg <= 0;\n        serial_status_reg <= 0;\n        watchdog_cnt <= 0;\n        crc_check_enable <= 0;\n        index_check_enable <= 0;\n        response_size <= 0;\n        crce <= 0;\n        cie <= 0;\n        cte <= 0;\n        ei <= 0;\n        cc <= 0;\n        crc_valid <= 0;\n        dat_ava <= 0;\n    end\n    else\n    begin\n        case (state)\n            3'b001: // IDLE\n                begin\n                    if (req_in_int)\n                    begin\n                        serial_status_reg <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n            3'b010: // SETUP\n                begin\n                    settings_reg <= {cmd_set_reg[13:8], cmd_set_reg[7:6], cmd_set_reg[4], cmd_set_reg[3], response_size, cmd_set_reg[1:0]};\n                    cmd_out_reg <= {2'b01, cmd_set_reg[13:8], arg_reg};\n                    crc_check_enable <= cmd_set_reg[3];\n                    index_check_enable <= cmd_set_reg[4];\n                    response_size <= (cmd_set_reg[1] == 2'b10 || cmd_set_reg[1] == 2'b11)? 7'b0101000 : (cmd_set_reg[1] == 2'b01)? 7'b1111111 : 0;\n                    watchdog_cnt <= 0;\n                end\n            3'b100: // EXECUTE\n                begin\n                    if (ack_in_int)\n                    begin\n                        req_out <= 1;\n                        complete <= 1;\n                    end\n                    else\n                    begin\n                        if (watchdog_cnt > timeout_reg)\n                        begin\n                            cte <= 1;\n                            ei <= 1;\n                        end\n                        else\n                        begin\n                            watchdog_cnt <= watchdog_cnt + 1;\n                        end\n                    end\n                    if (req_in_int)\n                    begin\n                        serial_status_reg <= serial_status;\n                        ack_out <= 1;\n                        if (dat_ava)\n                        begin\n                            complete <= 1;\n                            ei <= 0;\n                            if (crc_check_enable && ~crc_valid)\n                            begin\n                                crce <= 1;\n                                ei <= 1;\n                            end\n                            if (index_check_enable && (cmd_out_reg[37:32]!= cmd_in[37:32]))\n                            begin\n                                cie <= 1;\n                                ei <= 1;\n                            end\n                            cc <= 1;\n                            if (response_size!= 0)\n                            begin\n                                resp_1_reg_reg <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            default: // Default to IDLE\n                begin\n                    complete <= 0;\n                    err_int_reg_reg <= 0;\n                    normal_int_reg_reg <= 0;\n                    status_reg_reg <= 0;\n                    serial_status_reg <= 0;\n                    watchdog_cnt <= 0;\n                    crc_check_enable <= 0;\n                    index_check_enable <= 0;\n                    response_size <= 0;\n                    crce <= 0;\n                    cie <= 0;\n                    cte <= 0;\n                    ei <= 0;\n                    cc <= 0;\n                    crc_valid <= 0;\n                    dat_ava <= 0;\n                end\n        endcase\n    end\nend\n\n// Output Logic\nassign go_idle_o = (state == 3'b001)? 1'b0 : (complete && state == 3'b001)? 1'b1 : 1'b0;\nassign req_out = (state == 3'b100)? 1'b1 : 1'b0;\nassign ack_out = (state == 3'b100)? 1'b1 : 1'b0;\nassign cmd_out = cmd_out_reg;\nassign settings = settings_reg;\nassign status_reg = status_reg_reg;\nassign resp_1_reg = resp_1_reg_reg;\nassign err_int_reg = err_int_reg_reg;\nassign normal_int_reg = normal_int_reg_reg;\nassign normal_int_reg[1] = card_present;\nassign normal_int_reg[2] = ~card_present;\nassign complete = complete;\nassign crc_check_enable = crc_check_enable;\nassign index_check_enable = index_check_enable;\nassign response_size = response_size;\nassign crce = crce;\nassign cie = cie;\nassign cte = cte;\nassign ei = ei;\nassign cc = cc;\nassign crc_valid = crc_valid;\nassign dat_ava = dat_ava;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 20, "code": "module sd_bd(\n    input  clk,\n    input  rst,\n    input  we_m,\n    input  [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output [BD_WIDTH-1:0] free_bd,\n    input  re_s,\n    output ack_o_s,\n    input  a_cmp,\n    output [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Import sd_defines.v\n`include \"sd_defines.v\"\n\n// Define BD_WIDTH and BD_SIZE\n`define BD_WIDTH 8\n`define BD_SIZE 256\n\n// Define RAM_MEM_WIDTH\n`define RAM_MEM_WIDTH 16\n\n// Define RESEND_MAX_CNT\n`define RESEND_MAX_CNT 255\n\n// Define MEM_OFFSET\n`define MEM_OFFSET 0\n\n// Define RESET_CLK_DIV\n`define RESET_CLK_DIV 255\n\n// Define SD_CLK_BUS_CLK\n`define SD_CLK_BUS_CLK 1\n\n// Define SD_CLK_SEP\n`define SD_CLK_SEP 0\n\n// Define SD_CLK_STATIC\n`define SD_CLK_STATIC 1\n\n// Define SD_CLK_DYNAMIC\n`define SD_CLK_DYNAMIC 0\n\n// Define BLOCK_SIZE\n`define BLOCK_SIZE 512\n\n// Define SD_BUS_WIDTH_4\n`define SD_BUS_WIDTH_4 1\n\n// Define SD_BUS_W\n`define SD_BUS_W 4\n\n// Define FIFO_RX_MEM_DEPTH\n`define FIFO_RX_MEM_DEPTH 256\n\n// Define FIFO_RX_MEM_ADR_SIZE\n`define FIFO_RX_MEM_ADR_SIZE 9\n\n// Define FIFO_TX_MEM_DEPTH\n`define FIFO_TX_MEM_DEPTH 256\n\n// Define FIFO_TX_MEM_ADR_SIZE\n`define FIFO_TX_MEM_ADR_SIZE 9\n\n// Define BD_SIZE\n`define BD_SIZE 256\n\n// Define BD_WIDTH\n`define BD_WIDTH 8\n\n// Define RAM_MEM_WIDTH\n`define RAM_MEM_WIDTH 16\n\n// Define RESEND_MAX_CNT\n`define RESEND_MAX_CNT 255\n\n// Define MEM_OFFSET\n`define MEM_OFFSET 0\n\n// Define RESET_CLK_DIV\n`define RESET_CLK_DIV 255\n\n// Define SD_CLK_BUS_CLK\n`define SD_CLK_BUS_CLK 1\n\n// Define SD_CLK_SEP\n`define SD_CLK_SEP 0\n\n// Define SD_CLK_STATIC\n`define SD_CLK_STATIC 1\n\n// Define SD_CLK_DYNAMIC\n`define SD_CLK_DYNAMIC 0\n\n// Define BLOCK_SIZE\n`define BLOCK_SIZE 512\n\n// Define SD_BUS_WIDTH_4\n`define SD_BUS_WIDTH_4 1\n\n// Define SD_BUS_W\n`define SD_BUS_W 4\n\n// Define FIFO_RX_MEM_DEPTH\n`define FIFO_RX_MEM_DEPTH 256\n\n// Define FIFO_RX_MEM_ADR_SIZE\n`define FIFO_RX_MEM_ADR_SIZE 9\n\n// Define FIFO_TX_MEM_DEPTH\n`define FIFO_TX_MEM_DEPTH 256\n\n// Define FIFO_TX_MEM_ADR_SIZE\n`define FIFO_TX_MEM_ADR_SIZE 9\n\n// Define BD_SIZE\n`define BD_SIZE 256\n\n// Define BD_WIDTH\n`define BD_WIDTH 8\n\n// Define RAM_MEM_WIDTH\n`define RAM_MEM_WIDTH 16\n\n// Define RESEND_MAX_CNT\n`define RESEND_MAX_CNT 255\n\n// Define MEM_OFFSET\n`define MEM_OFFSET 0\n\n// Define RESET_CLK_DIV\n`define RESET_CLK_DIV 255\n\n// Define SD_CLK_BUS_CLK\n`define SD_CLK_BUS_CLK 1\n\n// Define SD_CLK_SEP\n`define SD_CLK_SEP 0\n\n// Define SD_CLK_STATIC\n`define SD_CLK_STATIC 1\n\n// Define SD_CLK_DYNAMIC\n`define SD_CLK_DYNAMIC 0\n\n// Define BLOCK_SIZE\n`define BLOCK_SIZE 512\n\n// Define SD_BUS_WIDTH_4\n`define SD_BUS_WIDTH_4 1\n\n// Define SD_BUS_W\n`define SD_BUS_W 4\n\n// Define FIFO_RX_MEM_DEPTH\n`define FIFO_RX_MEM_DEPTH 256\n\n// Define FIFO_RX_MEM_ADR_SIZE\n`define FIFO_RX_MEM_ADR_SIZE 9\n\n// Define FIFO_TX_MEM_DEPTH\n`define FIFO_TX_MEM_DEPTH 256\n\n// Define FIFO_TX_MEM_ADR_SIZE\n`define FIFO_TX_MEM_ADR_SIZE 9\n\n// Define BD_SIZE\n`define BD_SIZE 256\n\n// Define BD_WIDTH\n`define BD_WIDTH 8\n\n// Define RAM_MEM_WIDTH\n`define RAM_MEM_WIDTH 16\n\n// Define RESEND_MAX_CNT\n`define RESEND_MAX_CNT 255\n\n// Define MEM_OFFSET\n`define MEM_OFFSET 0\n\n// Define RESET_CLK_DIV\n`define RESET_CLK_DIV 255\n\n// Define SD_CLK_BUS_CLK\n`define SD_CLK_BUS_CLK 1\n\n// Define SD_CLK_SEP\n`define SD_CLK_SEP 0\n\n// Define SD_CLK_STATIC\n`define SD_CLK_STATIC 1\n\n// Define SD_CLK_DYNAMIC\n`define SD_CLK_DYNAMIC 0\n\n// Define BLOCK_SIZE\n`define BLOCK_SIZE 512\n\n// Define SD_BUS_WIDTH_4\n`define SD_BUS_WIDTH_4 1\n\n// Define SD_BUS_W\n`define SD_BUS_W 4\n\n// Define FIFO_RX_MEM_DEPTH\n`define FIFO_RX_MEM_DEPTH 256\n\n// Define FIFO_RX_MEM_ADR_SIZE\n`define FIFO_RX_MEM_ADR_SIZE 9\n\n// Define FIFO_TX_MEM_DEPTH\n`define FIFO_TX_MEM_DEPTH 256\n\n// Define FIFO_TX_MEM_ADR_SIZE\n`define FIFO_TX_MEM_ADR_SIZE 9\n\n// Define BD_SIZE\n`define BD_SIZE 256\n\n// Define BD_WIDTH\n`define BD_WIDTH 8\n\n// Define RAM_MEM_WIDTH\n`define RAM_MEM_WIDTH 16\n\n// Define RESEND_MAX_CNT\n`define RESEND_MAX_CNT 255\n\n// Define MEM_OFFSET\n`define MEM_OFFSET 0\n\n// Define RESET_CLK_DIV\n`define RESET_CLK_DIV 255\n\n// Define SD_CLK_BUS_CLK\n`define SD_CLK_BUS_CLK 1\n\n// Define SD_CLK_SEP\n`define SD_CLK_SEP 0\n\n// Define SD_CLK_STATIC\n`define SD_CLK_STATIC 1\n\n// Define SD_CLK_DYNAMIC\n`define SD_CLK_DYNAMIC 0\n\n// Define BLOCK_SIZE\n`define BLOCK_SIZE 512\n\n// Define SD_BUS_WIDTH_4\n`define SD_BUS_WIDTH_4 1\n\n// Define SD_BUS_W\n`define SD_BUS_W 4\n\n// Define FIFO_RX_MEM_DEPTH\n`define FIFO_RX_MEM_DEPTH 256\n\n// Define FIFO_RX_MEM_ADR_SIZE\n`define FIFO_RX_MEM_ADR_SIZE 9\n\n// Define FIFO_TX_MEM_DEPTH\n`define FIFO_TX_MEM_DEPTH 256\n\n// Define FIFO_TX_MEM_ADR_SIZE\n`define FIFO_TX_MEM_ADR_SIZE 9\n\n// Define BD_SIZE\n`define BD_SIZE 256\n\n// Define BD_WIDTH\n`define BD_WIDTH 8\n\n// Define RAM_MEM_WIDTH\n`define RAM_MEM_WIDTH 16\n\n// Define RESEND_MAX_CNT\n`define RESEND_MAX_CNT 255\n\n// Define MEM_OFFSET\n`define MEM_OFFSET 0\n\n// Define RESET_CLK_DIV\n`define RESET_CLK_DIV 255\n\n// Define SD_CLK_BUS_CLK\n`define SD_CLK_BUS_CLK 1\n\n// Define SD_CLK_SEP\n`define SD_CLK_SEP 0\n\n// Define SD_CLK_STATIC\n`define SD_CLK_STATIC 1\n\n// Define SD_CLK_DYNAMIC\n`define SD_CLK_DYNAMIC 0\n\n// Define BLOCK_SIZE\n`define BLOCK_SIZE 512\n\n// Define SD_BUS_WIDTH_4\n`define SD_BUS_WIDTH_4 1\n\n// Define SD_BUS_W\n`define SD_BUS_W 4\n\n// Define FIFO_RX_MEM_DEPTH\n`define FIFO_RX_MEM_DEPTH 256\n\n// Define FIFO_RX_MEM_ADR_SIZE\n`define FIFO_RX_MEM_ADR_SIZE 9\n\n// Define FIFO_TX_MEM_DEPTH\n`define FIFO_TX_MEM_DEPTH 256\n\n// Define FIFO_TX_MEM_ADR_SIZE\n`define FIFO_TX_MEM_ADR_SIZE 9\n\nreg [BD_WIDTH-1:0] free_bd;\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [BD_WIDTH-1:0] new_bw;\nreg [BD_WIDTH-1:0] last_a_cmp;\nreg [BD_WIDTH-1:0] write_cnt;\nreg [BD_WIDTH-1:0] read_cnt;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        free_bd <= BD_WIDTH;\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n        write_cnt <= 0;\n        read_cnt <= 0;\n    end else begin\n        if (we_m) begin\n            if (free_bd > 0) begin\n                if (`(BD_WIDTH == 8)) begin\n                    if (write_cnt == 1) begin\n                        m_wr_pnt <= m_wr_pnt + 1;\n                        new_bw <= 1;\n                        free_bd <= free_bd - 1;\n                    end\n                end else if (`(BD_WIDTH == 16)) begin\n                    if (write_cnt == 3) begin\n                        m_wr_pnt <= m_wr_pnt + 1;\n                        new_bw <= 1;\n                        free_bd <= free_bd - 1;\n                    end\n                end\n            end\n        end\n\n        if (re_s) begin\n            if (`(BD_WIDTH == 8)) begin\n                if (read_cnt == 1) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_cnt <= read_cnt + 1;\n                end\n            end else if (`(BD_WIDTH == 16)) begin\n                if (read_cnt == 3) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_cnt <= read_cnt + 1;\n                end\n            end\n        end\n\n        if (a_cmp) begin\n            if (`(BD_WIDTH == 16)) begin\n                if (last_a_cmp == 1) begin\n                    free_bd <= free_bd + 1;\n                end\n            end\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        write_cnt <= 0;\n        read_cnt <= 0;\n    end else begin\n        if (we_m) begin\n            if (`(BD_WIDTH == 8)) begin\n                if (write_cnt == 1) begin\n                    write_cnt <= 0;\n                end\n            end else if (`(BD_WIDTH == 16)) begin\n                if (write_cnt == 3) begin\n                    write_cnt <= 0;\n                end\n            end\n        end\n\n        if (re_s) begin\n            if (`(BD_WIDTH == 8)) begin\n                if (read_cnt == 1) begin\n                    read_cnt <= 0;\n                end\n            end else if (`(BD_WIDTH == 16)) begin\n                if (read_cnt == 3) begin\n                    read_cnt <= 0;\n                end\n            end\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        last_a_cmp <= 0;\n    end else begin\n        if (a_cmp) begin\n            if (`(BD_WIDTH == 16)) begin\n                last_a_cmp <= 1;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 14, "code": "module sd_cmd_master(\n    input  wire  clk_pad_io,\n    input  wire  rst_pad_i,\n    input  wire  new_cmd,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire  [31:0] arg_reg,\n    input  wire  [13:0]  cmd_set_reg,\n    input  wire  [15:0]  timeout_reg,\n    output wire  [15:0]  status_reg,\n    output wire  [31:0]  resp_1_reg,\n    output wire  [4:0]   err_int_reg,\n    output wire  [15:0]  normal_int_reg,\n    input  wire  err_int_rst,\n    input  wire  normal_int_rst,\n    output wire  [15:0]  settings,\n    output wire  go_idle_o,\n    output wire  [39:0]  cmd_out,\n    output wire  req_out,\n    output wire  ack_out,\n    input  wire  req_in,\n    input  wire  ack_in,\n    input  wire  [39:0]  cmd_in,\n    input  wire  [7:0]   serial_status,\n    input  wire  card_detect\n);\n\n    // Debounce Logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        else\n            begin\n                if (!card_detect)\n                    begin\n                        if (debounce != 4'b1111)\n                            debounce <= debounce + 1;\n                        else\n                            card_present <= 1;\n                    end\n                else\n                    debounce <= 0;\n            end\n    end\n\n    // Request and Acknowledge Synchronizers\n    reg req_q;\n    reg ack_q;\n    reg req_in_int;\n    reg ack_in_int;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            begin\n                req_q <= 0;\n                ack_q <= 0;\n                req_in_int <= 0;\n                ack_in_int <= 0;\n            end\n        else\n            begin\n                req_q <= req_in;\n                ack_q <= ack_in;\n                req_in_int <= req_q;\n                ack_in_int <= ack_q;\n            end\n    end\n\n    // Finite State Machine (FSM)\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            state <= 3'b001; // IDLE\n        else\n            state <= next_state;\n    end\n\n    always_comb\n    begin\n        case (state)\n            3'b001: // IDLE\n                next_state = (new_cmd) ? 3'b010 : 3'b001;\n            3'b010: // SETUP\n                next_state = (ack_in_int) ? 3'b100 : 3'b010;\n            3'b100: // EXECUTE\n                next_state = (complete) ? 3'b001 : 3'b100;\n            default: next_state = 3'b001; // Default to IDLE\n        endcase\n    end\n\n    // FSM State operation\n    reg [15:0] status;\n    reg complete;\n    reg [39:0] cmd_out;\n    reg [15:0] settings;\n    reg [7:0]  response_size;\n    reg req_out;\n    reg ack_out;\n    reg [3:0]  Watchdog_Cnt;\n    reg CCRCE;\n    reg EI;\n    reg CC;\n    reg go_idle_o;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i)\n    begin\n        if (rst_pad_i)\n            begin\n                status <= 0;\n                complete <= 0;\n                cmd_out <= 0;\n                settings <= 0;\n                response_size <= 0;\n                req_out <= 0;\n                ack_out <= 0;\n                Watchdog_Cnt <= 0;\n                CCRCE <= 0;\n                EI <= 0;\n                CC <= 0;\n                go_idle_o <= 0;\n            end\n        else\n            begin\n                case (state)\n                    3'b001: // IDLE\n                        begin\n                            go_idle_o <= 0;\n                            req_out <= 0;\n                            ack_out <= 0;\n                            CICMD <= 0;\n                            if (req_in_int)\n                                begin\n                                    status <= serial_status;\n                                    ack_out <= 1;\n                                end\n                        end\n                    3'b010: // SETUP\n                        begin\n                            NORMAL_INT_REG <= 0;\n                            ERR_INT_REG <= 0;\n                            index_check_enable <= CICE;\n                            CRC_check_enable <= CRCE;\n                            response_size <= (RTS == 2'b10 || RTS == 2'b11) ? small_rsp : (RTS == 2'b01 ? big_rsp : 0);\n                            cmd_out <= {2'b01, CMDI, ARG_REG};\n                            settings <= {WORD_SELECT, data_read, data_write, 3'b111, CRCE, response_size};\n                            Watchdog_Cnt <= 0;\n                            CICMD <= 1;\n                        end\n                    3'b100: // EXECUTE\n                        begin\n                            Watchdog_Cnt <= Watchdog_Cnt + 1;\n                            if (Watchdog_Cnt > TIMEOUT_REG)\n                                begin\n                                    CTE <= 1;\n                                    EI <= 1;\n                                    if (ack_in)\n                                        complete <= 1;\n                                    go_idle_o <= 1;\n                                end\n                            if (ack_in_int)\n                                begin\n                                    req_out <= 1;\n                                end\n                            else if (req_in_int)\n                                begin\n                                    status <= serial_status;\n                                    ack_out <= 1;\n                                    if (dat_ava)\n                                        begin\n                                            complete <= 1;\n                                            EI <= 0;\n                                            if (CRC_check_enable && ~crc_valid)\n                                                begin\n                                                    CCRCE <= 1;\n                                                    EI <= 1;\n                                                end\n                                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32]))\n                                                begin\n                                                    CIE <= 1;\n                                                    EI <= 1;\n                                                end\n                                            CC <= 1;\n                                            if (response_size != 0)\n                                                RESP_1_REG <= cmd_in[31:0];\n                                        end\n                                end\n                        end\n                endcase\n            end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 9, "code": "module sd_data_master(\n    input  wire clk,\n    input  wire rst,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input  wire [BD_WIDTH-1:0] free_tx_bd,\n    input  wire [BD_WIDTH-1:0] free_rx_bd,\n    input  wire ack_i_s_tx,\n    input  wire ack_i_s_rx,\n    input  wire cmd_busy,\n    input  wire we_ack,\n    input  wire cmd_tsf_err,\n    input  wire [4:0] card_status,\n    input  wire tx_empt,\n    input  wire tx_full,\n    input  wire rx_full,\n    input  wire busy_n,\n    input  wire transm_complete,\n    input  wire crc_ok,\n    input  wire Dat_Int_Status_rst,\n    input  wire [1:0] transfer_type,\n    output wire re_s_tx,\n    output wire a_cmp_tx,\n    output wire re_s_rx,\n    output wire a_cmp_rx,\n    output wire we_req,\n    output wire d_write,\n    output wire d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire start_tx_fifo,\n    output wire start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire ack_transfer,\n    output wire [7:0] Dat_Int_Status,\n    output wire CIDAT\n);\n\n// Define parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\nparameter READ_CYCLE = 2;\nparameter BD_EMPTY = 1;\n\n// Define internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [BD_WIDTH-1:0] bd_cnt;\nreg [31:0] sys_adr;\nreg [31:0] cmd_arg;\nreg [15:0] cmd_set;\nreg CIDAT;\nreg [7:0] Dat_Int_Status;\n\n// Define external signals\nwire RAM_MEM_WIDTH;\nwire BD_WIDTH;\nwire BD_SIZE;\n\n// Define FSM state machine\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd!= BD_EMPTY) begin\n                    next_state <= GET_TX_BD;\n                end else if (free_rx_bd!= BD_EMPTY) begin\n                    next_state <= GET_RX_BD;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_TX_BD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_RX_BD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state <= RECIVE_CMD;\n                end else begin\n                    next_state <= SEND_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state <= DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= RECIVE_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state <= IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state <= STOP;\n                end else begin\n                    next_state <= DATA_TRANSFER;\n                end\n            end\n            STOP: begin\n                next_state <= STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= STOP_SEND;\n                end\n            end\n        endcase\n    end\nend\n\n// Define output signals\nassign re_s_tx = (state == GET_TX_BD)? 1 : 0;\nassign a_cmp_tx = (state == GET_TX_BD)? 1 : 0;\nassign re_s_rx = (state == GET_RX_BD)? 1 : 0;\nassign a_cmp_rx = (state == GET_RX_BD)? 1 : 0;\nassign we_req = (state == SEND_CMD)? 1 : 0;\nassign d_write = (state == SEND_CMD)? 1 : 0;\nassign d_read = (state == SEND_CMD)? 1 : 0;\nassign cmd_arg = (state == SEND_CMD)? cmd_arg : 0;\nassign cmd_set = (state == SEND_CMD)? cmd_set : 0;\nassign start_tx_fifo = (state == SEND_CMD)? 1 : 0;\nassign start_rx_fifo = (state == SEND_CMD)? 1 : 0;\nassign sys_adr = (state == SEND_CMD)? sys_adr : 0;\nassign ack_transfer = (state == DATA_TRANSFER)? 1 : 0;\nassign Dat_Int_Status = (state == DATA_TRANSFER)? Dat_Int_Status : 0;\nassign CIDAT = (state == DATA_TRANSFER)? CIDAT : 0;\n\n// Define internal logic\nalways @(posedge clk) begin\n    if (rst) begin\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            SEND_CMD: begin\n                if (we_ack == 1) begin\n                    send_done <= 1;\n                end\n            end\n            RECIVE_CMD: begin\n                if (cmd_busy == 0) begin\n                    rec_done <= 1;\n                end else if (cmd_tsf_err == 1) begin\n                    rec_failed <= 1;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete == 1) begin\n                    trans_done <= 1;\n                end else if (crc_ok == 0) begin\n                    trans_failed <= 1;\n                end\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    resend_try_cnt <= 0;\n                end else begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                end\n            end\n        endcase\n    end\nend\n\n// Define output logic\nalways @(posedge clk) begin\n    if (rst) begin\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            DATA_TRANSFER: begin\n                CIDAT <= crc_ok;\n                Dat_Int_Status <= {trans_failed, trans_done, rec_failed, rec_done, cmd_tsf_err, card_status};\n            end\n            STOP_SEND: begin\n                CIDAT <= resend_try_cnt == RESEND_MAX_CNT;\n                Dat_Int_Status <= {resend_try_cnt, trans_failed, trans_done, rec_failed, rec_done, cmd_tsf_err, card_status};\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 15, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    input  wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n\n    // SDC/MMC Interface\n    input  wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input  wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input  wire sd_clk_i_pad,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal Registers\n    reg [15:0] status_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [7:0] Bd_isr_reg;\n    reg [7:0] Bd_isr_enable_reg;\n    reg [7:0] dat_int_status_reg;\n    reg [7:0] dat_int_status_reg_en;\n    reg [7:0] dat_int_status_reg_rst;\n    reg [7:0] dat_int_status_reg_en_rst;\n    reg [7:0] dat_int_status_reg_rst_rst;\n    reg [7:0] dat_int_status_reg_en_rst_rst;\n    reg [15:0] cmd_setting_reg;\n    reg [31:0] cmd_arg_reg;\n    reg [15:0] timeout_reg;\n    reg [15:0] software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] clock_divider;\n    reg [15:0] Bd_status_reg;\n    reg [7:0] Bd_isr_reg;\n    reg [7:0] Bd_isr_enable_reg;\n    reg [7:0] dat_int_status_reg;\n    reg [7:0] dat_int_status_reg_en;\n    reg [7:0] dat_int_status_reg_rst;\n    reg [7:0] dat_int_status_reg_en_rst;\n    reg [7:0] dat_int_status_reg_rst_rst;\n    reg [7:0] dat_int_status_reg_en_rst_rst;\n\n    // Wishbone Slave Interface\n    assign wb_dat_o = wb_dat_i;\n    assign wb_ack_o = 1'b1;\n\n    // Wishbone Master Interface\n    assign m_wb_adr_o = 32'b0;\n    assign m_wb_sel_o = 4'b1111;\n    assign m_wb_we_o = wb_we_i;\n    assign m_wb_dat_o = m_wb_dat_i;\n    assign m_wb_cyc_o = wb_cyc_i;\n    assign m_wb_stb_o = wb_stb_i;\n    assign m_wb_ack_i = 1'b0;\n\n    // SDC/MMC Interface\n    assign sd_cmd_out_o = sd_cmd_dat_i;\n    assign sd_cmd_oe_o = 1'b1;\n    assign sd_dat_out_o = sd_dat_dat_i;\n    assign sd_dat_oe_o = 1'b1;\n    assign sd_clk_o_pad = sd_clk_i_pad;\n\n    // Interrupts\n    assign int_a = 1'b1;\n    assign int_b = 1'b1;\n    assign int_c = 1'b1;\n\n    // Internal Logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            status_reg <= 16'b0;\n            normal_int_status_reg <= 16'b0;\n            error_int_status_reg <= 16'b0;\n            Bd_isr_reg <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            dat_int_status_reg <= 8'b0;\n            dat_int_status_reg_en <= 8'b0;\n            dat_int_status_reg_rst <= 8'b0;\n            dat_int_status_reg_en_rst <= 8'b0;\n            dat_int_status_reg_rst_rst <= 8'b0;\n            dat_int_status_reg_en_rst_rst <= 8'b0;\n            cmd_setting_reg <= 16'b0;\n            cmd_arg_reg <= 32'b0;\n            timeout_reg <= 16'b0;\n            software_reset_reg <= 16'b0;\n            time_out_reg <= 16'b0;\n            clock_divider <= 16'b0;\n            Bd_status_reg <= 16'b0;\n            Bd_isr_reg <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            dat_int_status_reg <= 8'b0;\n            dat_int_status_reg_en <= 8'b0;\n            dat_int_status_reg_rst <= 8'b0;\n            dat_int_status_reg_en_rst <= 8'b0;\n            dat_int_status_reg_rst_rst <= 8'b0;\n            dat_int_status_reg_en_rst_rst <= 8'b0;\n        end else begin\n            // Update status register\n            status_reg <= (cmd_int_busy)? 16'b1 : status_reg;\n\n            // Update normal interrupt status register\n            normal_int_status_reg <= (NORMAL_INT_REG)? 16'b1 : normal_int_status_reg;\n\n            // Update error interrupt status register\n            error_int_status_reg <= (ERR_INT_REG)? 16'b1 : error_int_status_reg;\n\n            // Update BD status register\n            Bd_status_reg <= (Bd_status_reg[15:8] == free_rx_bd)? 16'b1 : Bd_status_reg;\n\n            // Update BD ISR register\n            Bd_isr_reg <= (Bd_isr_reg[7:0] == Dat_Int_Status)? 8'b1 : Bd_isr_reg;\n\n            // Update BD ISR enable register\n            Bd_isr_enable_reg <= (Bd_isr_enable_reg[7:0] == Dat_Int_Status_en)? 8'b1 : Bd_isr_enable_reg;\n\n            // Update data interrupt status register\n            dat_int_status_reg <= (dat_int_status_reg[7:0] == Dat_Int_Status)? 8'b1 : dat_int_status_reg;\n\n            // Update data interrupt status register enable\n            dat_int_status_reg_en <= (dat_int_status_reg_en[7:0] == Dat_Int_Status_en)? 8'b1 : dat_int_status_reg_en;\n\n            // Update data interrupt status register reset\n            dat_int_status_reg_rst <= (dat_int_status_reg_rst[7:0] == Dat_Int_Status_rst)? 8'b1 : dat_int_status_reg_rst;\n\n            // Update data interrupt status register enable reset\n            dat_int_status_reg_en_rst <= (dat_int_status_reg_en_rst[7:0] == Dat_Int_Status_en_rst)? 8'b1 : dat_int_status_reg_en_rst;\n\n            // Update data interrupt status register reset reset\n            dat_int_status_reg_rst_rst <= (dat_int_status_reg_rst_rst[7:0] == Dat_Int_Status_rst_rst)? 8'b1 : dat_int_status_reg_rst_rst;\n\n            // Update data interrupt status register enable reset reset\n            dat_int_status_reg_en_rst_rst <= (dat_int_status_reg_en_rst_rst[7:0] == Dat_Int_Status_en_rst_rst)? 8'b1 : dat_int_status_reg_en_rst_rst;\n\n            // Update command setting register\n            cmd_setting_reg <= (cmd_setting_reg[15:0] == settings)? 16'b1 : cmd_setting_reg;\n\n            // Update command argument register\n            cmd_arg_reg <= (cmd_arg_reg[31:0] == cmd_arg)? 32'b1 : cmd_arg_reg;\n\n            // Update timeout register\n            timeout_reg <= (timeout_reg[15:0] == timeout)? 16'b1 : timeout_reg;\n\n            // Update software reset register\n            software_reset_reg <= (software_reset_reg[15:0] == software_reset)? 16'b1 : software_reset_reg;\n\n            // Update time out register\n            time_out_reg <= (time_out_reg[15:0] == time_out)? 16'b1 : time_out_reg;\n\n            // Update clock divider register\n            clock_divider <= (clock_divider[15:0] == clock_divider)? 16'b1 : clock_divider;\n\n            // Update BD status register\n            Bd_status_reg <= (Bd_status_reg[15:8] == free_tx_bd)? 16'b1 : Bd_status_reg;\n\n            // Update BD ISR register\n            Bd_isr_reg <= (Bd_isr_reg[7:0] == Dat_Int_Status)? 8'b1 : Bd_isr_reg;\n\n            // Update BD ISR enable register\n            Bd_isr_enable_reg <= (Bd_isr_enable_reg[7:0] == Dat_Int_Status_en)? 8'b1 : Bd_isr_enable_reg;\n\n            // Update data interrupt status register\n            dat_int_status_reg <= (dat_int_status_reg[7:0] == Dat_Int_Status)? 8'b1 : dat_int_status_reg;\n\n            // Update data interrupt status register enable\n            dat_int_status_reg_en <= (dat_int_status_reg_en[7:0] == Dat_Int_Status_en)? 8'b1 : dat_int_status_reg_en;\n\n            // Update data interrupt status register reset\n            dat_int_status_reg_rst <= (dat_int_status_reg_rst[7:0] == Dat_Int_Status_rst)? 8'b1 : dat_int_status_reg_rst;\n\n            // Update data interrupt status register enable reset\n            dat_int_status_reg_en_rst <= (dat_int_status_reg_en_rst[7:0] == Dat_Int_Status_en_rst)? 8'b1 : dat_int_status_reg_en_rst;\n\n            // Update data interrupt status register reset reset\n            dat_int_status_reg_rst_rst <= (dat_int_status_reg_rst_rst[7:0] == Dat_Int_Status_rst_rst)? 8'b1 : dat_int_status_reg_rst_rst;\n\n            // Update data interrupt status register enable reset reset\n            dat_int_status_reg_en_rst_rst <= (dat_int_status_reg_en_rst_rst[7:0] == Dat_Int_Status_en_rst_rst)? 8'b1 : dat_int_status_reg_en_rst_rst;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 15, "code": "module sd_cmd_master(\n    input  wire clk,\n    input  wire rst,\n    input  wire new_cmd,\n    input  wire data_write,\n    input  wire data_read,\n    input  wire [31:0] arg_reg,\n    input  wire [13:0] cmd_set_reg,\n    input  wire [15:0] timeout_reg,\n    output wire [15:0] status_reg,\n    output wire [31:0] resp_1_reg,\n    output wire [4:0] err_int_reg,\n    output wire [15:0] normal_int_reg,\n    input  wire err_int_rst,\n    input  wire normal_int_rst,\n    output wire [15:0] settings,\n    output wire go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire req_out,\n    output wire ack_out,\n    input  wire req_in,\n    input  wire ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0] serial_status,\n    input  wire card_detect\n);\n\n    // Debounce Logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            debounce <= 0;\n            card_present <= 0;\n        end\n        else begin\n            if (!card_detect) begin\n                if (debounce < 4'b1111) debounce <= debounce + 1;\n                else card_present <= 1;\n            end\n            else debounce <= 0;\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    reg req_q;\n    reg ack_q;\n    reg req_in_int;\n    reg ack_in_int;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            req_q <= 0;\n            ack_q <= 0;\n            req_in_int <= 0;\n            ack_in_int <= 0;\n        end\n        else begin\n            req_q <= req_in;\n            ack_q <= ack_in;\n            req_in_int <= req_q;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // Finite State Machine (FSM)\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) state <= 3'b001;\n        else state <= next_state;\n    end\n\n    always_comb begin\n        case (state)\n            3'b001: begin\n                if (new_cmd) next_state = 3'b010;\n                else next_state = 3'b001;\n            end\n            3'b010: begin\n                if (ack_in_int) next_state = 3'b100;\n                else next_state = 3'b010;\n            end\n            3'b100: begin\n                if (complete) next_state = 3'b001;\n                else next_state = 3'b100;\n            end\n            default: next_state = 3'b001;\n        end\n    end\n\n    // FSM State operation\n    reg [15:0] status;\n    reg [31:0] resp_1_reg;\n    reg [4:0] err_int_reg;\n    reg [15:0] normal_int_reg;\n    reg [15:0] settings;\n    reg complete;\n    reg [39:0] cmd_out;\n    reg req_out;\n    reg ack_out;\n    reg [15:0] watchdog_cnt;\n    reg [15:0] crc_check_enable;\n    reg [15:0] index_check_enable;\n    reg [15:0] response_size;\n    reg [15:0] resp_1_reg;\n    reg [15:0] CCRCE;\n    reg [15:0] EI;\n    reg [15:0] CC;\n    reg [15:0] go_idle_o;\n\n    always_comb begin\n        case (state)\n            3'b001: begin\n                go_idle_o = 0;\n                req_out = 0;\n                ack_out = 0;\n                CICMD = 0;\n                if (req_in_int) begin\n                    status = serial_status;\n                    ack_out = 1;\n                end\n            end\n            3'b010: begin\n                NORMAL_INT_REG = 0;\n                ERR_INT_REG = 0;\n                index_check_enable = CICE;\n                crc_check_enable = CRCE;\n                response_size = (RTS == 2'b10 || RTS == 2'b11) ? small_rsp : (RTS == 2'b01 ? big_rsp : 0);\n                cmd_out[39:38] = 2'b01;\n                cmd_out[37:32] = CMDI;\n                cmd_out[31:0] = ARG_REG;\n                settings[14:13] = WORD_SELECT;\n                settings[12] = data_read;\n                settings[11] = data_write;\n                settings[10:8] = 3'b111;\n                settings[7] = CRCE;\n                settings[6:0] = response_size;\n                watchdog_cnt = 0;\n                CICMD = 1;\n            end\n            3'b100: begin\n                watchdog_cnt = watchdog_cnt + 1;\n                if (watchdog_cnt > TIMEOUT_REG) begin\n                    CTE = 1;\n                    EI = 1;\n                    if (ack_in) complete = 1;\n                    go_idle_o = 1;\n                end\n                if (ack_in_int) begin\n                    req_out = 1;\n                end\n                else if (req_in_int) begin\n                    status = serial_status;\n                    ack_out = 1;\n                    if (dat_ava) begin\n                        complete = 1;\n                        EI = 0;\n                        if (crc_check_enable && ~crc_valid) begin\n                            CCRCE = 1;\n                            EI = 1;\n                        end\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            CIE = 1;\n                            EI = 1;\n                        end\n                        CC = 1;\n                        if (response_size != 0) begin\n                            resp_1_reg = cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n            default: begin\n                go_idle_o = 0;\n                req_out = 0;\n                ack_out = 0;\n                CICMD = 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 16, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n\n    // SDC/MMC Interface\n    input  wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input  wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input  wire sd_clk_i_pad,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // sd_controller_wb module\n    sd_controller_wb sd_controller_wb (\n       .wb_clk_i(wb_clk_i),\n       .wb_rst_i(wb_rst_i),\n       .wb_dat_i(wb_dat_i),\n       .wb_dat_o(wb_dat_o),\n       .wb_adr_i(wb_adr_i),\n       .wb_we_i(wb_we_i),\n       .wb_cyc_i(wb_cyc_i),\n       .wb_stb_i(wb_stb_i),\n       .wb_ack_o(wb_ack_o),\n       .m_wb_adr_o(m_wb_adr_o),\n       .m_wb_sel_o(m_wb_sel_o),\n       .m_wb_we_o(m_wb_we_o),\n       .m_wb_dat_o(m_wb_dat_o),\n       .m_wb_dat_i(m_wb_dat_i),\n       .m_wb_cyc_o(m_wb_cyc_o),\n       .m_wb_stb_o(m_wb_stb_o),\n       .m_wb_ack_i(m_wb_ack_i),\n       .we_m_tx_bd(we_m_tx_bd),\n       .we_m_rx_bd(we_m_rx_bd),\n       .new_cmd(new_cmd),\n       .we_ack(we_ack),\n       .int_ack(int_ack),\n       .cmd_int_busy(cmd_int_busy),\n       .int_busy(int_busy),\n       .write_req_s(write_req_s),\n       .cmd_set_s(cmd_set_s),\n       .cmd_arg_s(cmd_arg_s),\n       .argument_reg(argument_reg),\n       .cmd_setting_reg(cmd_setting_reg),\n       .status_reg(status_reg),\n       .cmd_resp_1(cmd_resp_1),\n       .software_reset_reg(software_reset_reg),\n       .time_out_reg(time_out_reg),\n       .normal_int_status_reg(normal_int_status_reg),\n       .error_int_status_reg(error_int_status_reg),\n       .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n       .error_int_signal_enable_reg(error_int_signal_enable_reg),\n       .clock_divider(clock_divider),\n       .Bd_Status_reg(Bd_Status_reg),\n       .Bd_isr_reg(Bd_isr_reg),\n       .Bd_isr_enable_reg(Bd_isr_enable_reg),\n       .bd_isr_reset(bd_isr_reset),\n       .normal_isr_reset(normal_isr_reset),\n       .error_isr_reset(error_isr_reset),\n       .dat_in_m_tx_bd(dat_in_m_tx_bd),\n       .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // sd_clock_divider module\n    sd_clock_divider sd_clock_divider (\n       .CLK(wb_clk_i),\n       .RST(wb_rst_i),\n       .DIVIDER(clock_divider),\n       .SD_CLK(sd_clk_o_pad)\n    );\n\n    // sd_cmd_master module\n    sd_cmd_master sd_cmd_master (\n       .CLK_PAD_IO(wb_clk_i),\n       .RST_PAD_I(wb_rst_i),\n       .New_CMD(new_cmd),\n       .data_write(data_write),\n       .data_read(data_read),\n       .ARG_REG(argument_reg),\n       .CMD_SET_REG(cmd_setting_reg),\n       .TIMEOUT_REG(time_out_reg),\n       .STATUS_REG(status_reg),\n       .RESP_1_REG(cmd_resp_1),\n       .ERR_INT_REG(error_int_status_reg),\n       .NORMAL_INT_REG(normal_int_status_reg),\n       .ERR_INT_RST(error_isr_reset),\n       .NORMAL_INT_RST(normal_isr_reset),\n       .settings(cmd_setting_reg),\n       .go_idle_o(go_idle_o),\n       .cmd_out(cmd_out),\n       .req_out(req_out),\n       .ack_out(ack_out),\n       .req_in(req_in),\n       .ack_in(ack_in),\n       .cmd_in(cmd_in),\n       .serial_status(serial_status),\n       .card_detect(card_detect)\n    );\n\n    // sd_cmd_serial_host module\n    sd_cmd_serial_host sd_cmd_serial_host (\n       .SD_CLK_IN(sd_clk_i_pad),\n       .RST_IN(wb_rst_i),\n       .SETTING_IN(cmd_setting_reg),\n       .CMD_IN(cmd_in),\n       .REQ_IN(req_in),\n       .ACK_IN(ack_in),\n       .cmd_dat_i(cmd_dat_i),\n       .CMD_OUT(cmd_out),\n       .ACK_OUT(ack_out),\n       .REQ_OUT(req_out),\n       .STATUS(serial_status),\n       .cmd_oe_o(cmd_oe_o),\n       .cmd_out_o(cmd_out_o),\n       .st_dat_t(st_dat_t)\n    );\n\n    // sd_data_master module\n    sd_data_master sd_data_master (\n       .clk(wb_clk_i),\n       .rst(wb_rst_i),\n       .dat_in_tx(dat_in_m_tx_bd),\n       .free_tx_bd(free_tx_bd),\n       .ack_i_s_tx(ack_i_s_tx),\n       .dat_in_rx(dat_in_m_rx_bd),\n       .free_rx_bd(free_rx_bd),\n       .ack_i_s_rx(ack_i_s_rx),\n       .cmd_busy(cmd_int_busy),\n       .we_ack(we_ack),\n       .cmd_tsf_err(cmd_tsf_err),\n       .card_status(card_status),\n       .tx_empt(tx_empt),\n       .tx_full(tx_full),\n       .rx_full(rx_full),\n       .busy_n(busy_n),\n       .transm_complete(transm_complete),\n       .crc_ok(crc_ok),\n       .Dat_Int_Status_rst(Dat_Int_Status_rst),\n       .transfer_type(transfer_type),\n       .re_s_tx(re_s_tx),\n       .a_cmp_tx(a_cmp_tx),\n       .re_s_rx(re_s_rx),\n       .a_cmp_rx(a_cmp_rx),\n       .we_req(we_req),\n       .d_write(d_write),\n       .d_read(d_read),\n       .cmd_arg(cmd_arg),\n       .cmd_set(cmd_set),\n       .start_tx_fifo(start_tx_fifo),\n       .start_rx_fifo(start_rx_fifo),\n       .sys_adr(sys_adr),\n       .ack_transfer(ack_transfer),\n       .Dat_Int_Status(Dat_Int_Status),\n       .CIDAT(CIDAT)\n    );\n\n    // sd_data_serial_host module\n    sd_data_serial_host sd_data_serial_host (\n       .sd_clk(sd_clk_i_pad),\n       .rst(wb_rst_i),\n       .data_in(data_in),\n       .start_dat(start_dat),\n       .ack_transfer(ack_transfer),\n       .DAT_dat_i(DAT_dat_i),\n       .rd(rd),\n       .data_out(DAT_dat_o),\n       .we(we),\n       .DAT_oe_o(DAT_oe_o),\n       .DAT_dat_o(DAT_dat_o),\n       .busy_n(busy_n),\n       .transm_complete(transm_complete),\n       .crc_ok(crc_ok)\n    );\n\n    // rx_bd/tx_bd module\n    rx_bd/tx_bd rx_bd/tx_bd (\n       .clk(wb_clk_i),\n       .rst(wb_rst_i),\n       .we_m(we_m),\n       .dat_in_m(dat_in_m),\n       .free_bd(free_bd),\n       .re_s(re_s),\n       .ack_o_s(ack_o_s),\n       .a_cmp(a_cmp),\n       .dat_out_s(dat_out_s)\n    );\n\n    // sd_fifo_tx_filler module\n    sd_fifo_tx_filler sd_fifo_tx_filler (\n       .clk(wb_clk_i),\n       .rst(wb_rst_i),\n       .m_wb_adr_o(m_wb_adr_o),\n       .m_wb_we_o(m_wb_we_o),\n       .m_wb_dat_o(m_wb_dat_o),\n       .m_wb_cyc_o(m_wb_cyc_o),\n       .m_wb_stb_o(m_wb_stb_o),\n       .m_wb_ack_i(m_wb_ack_i),\n       .m_wb_cti_o(m_wb_cti_o),\n       .m_wb_bte(m_wb_bte),\n       .en(en),\n       .adr(adr),\n       .sd_clk(sd_clk_i_pad),\n       .dat_o(dat_o),\n       .rd(rd),\n       .empty(empty),\n       .fe(fe)\n    );\n\n    // sd_fifo_rx_filler module\n    sd_fifo_rx_filler sd_fifo_rx_filler (\n       .clk(wb_clk_i),\n       .rst(wb_rst_i),\n       .m_wb_adr_o(m_wb_adr_o),\n       .m_wb_we_o(m_wb_we_o),\n       .m_wb_dat_o(m_wb_dat_o),\n       .m_wb_cyc_o(m_wb_cyc_o),\n       .m_wb_stb_o(m_wb_stb_o),\n       .m_wb_ack_i(m_wb_ack_i),\n       .m_wb_cti_o(m_wb_cti_o),\n       .m_wb_bte(m_wb_bte),\n       .en(en),\n       .adr(adr),\n       .sd_clk(sd_clk_i_pad),\n       .dat_i(dat_i),\n       .wr(wr),\n       .full(full)\n    );\n\n    // Interrupts\n    assign int_a = int_a;\n    assign int_b = int_b;\n    assign int_c = int_c;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 10, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input dat_in_tx,\n    input free_tx_bd,\n    input ack_i_s_tx,\n    input dat_in_rx,\n    input free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input transfer_type,\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output cmd_arg,\n    output cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output sys_adr,\n    output ack_transfer,\n    output Dat_Int_Status,\n    output CIDAT\n);\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg resend_try_cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [BD_WIDTH-1:0] bd_cnt;\nreg [31:0] sys_adr;\nreg [31:0] cmd_arg;\nreg [15:0] cmd_set;\nreg CIDAT;\nreg [7:0] Dat_Int_Status;\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\nparameter READ_CYCLE = 2;\nparameter BD_EMPTY = 1;\n\n// FSM state machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        // FSM state machine logic\n        case (state)\n            IDLE: begin\n                if (free_tx_bd!= BD_EMPTY) begin\n                    next_state <= GET_TX_BD;\n                end else if (free_rx_bd!= BD_EMPTY) begin\n                    next_state <= GET_RX_BD;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_TX_BD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_RX_BD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state <= RECIVE_CMD;\n                end else begin\n                    next_state <= SEND_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state <= DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= RECIVE_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state <= IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state <= STOP;\n                end else begin\n                    next_state <= DATA_TRANSFER;\n                end\n            end\n            STOP: begin\n                next_state <= STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= STOP_SEND;\n                end\n            end\n            default: begin\n                next_state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// Output logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            GET_RX_BD: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 1;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            SEND_CMD: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 1;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= cmd_arg;\n                cmd_set <= cmd_set;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= sys_adr;\n                ack_transfer <= 0;\n                Dat_Int_Status <= Dat_Int_Status;\n                CIDAT <= CIDAT;\n            end\n            RECIVE_CMD: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            DATA_TRANSFER: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            STOP: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            STOP_SEND: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            default: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 17, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:3] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Sub-modules\n    sd_crc_16 crc_16_gen(\n       .BITVAL(crc_in),\n       .Enable(crc_en),\n       .CLK(sd_clk),\n       .RST(crc_rst),\n       .CRC(crc_out)\n    );\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @* begin\n        case (state)\n            6'd0: begin // IDLE\n                if (start_dat == 2'b01) begin\n                    next_state = 6'd1; // WRITE_DAT\n                end else if (start_dat == 2'b10) begin\n                    next_state = 6'd2; // READ_WAIT\n                end else begin\n                    next_state = 6'd0; // IDLE\n                end\n            end\n            6'd1: begin // WRITE_DAT\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = 6'd3; // WRITE_CRC\n                end else begin\n                    next_state = 6'd1; // WRITE_DAT\n                end\n            end\n            6'd2: begin // READ_WAIT\n                if (DAT_dat_i[0] == 0) begin\n                    next_state = 6'd4; // READ_DAT\n                end else begin\n                    next_state = 6'd2; // READ_WAIT\n                end\n            end\n            6'd3: begin // WRITE_CRC\n                if (crc_status == 3'b111) begin\n                    next_state = 6'd5; // WRITE_BUSY\n                end else begin\n                    next_state = 6'd3; // WRITE_CRC\n                end\n            end\n            6'd4: begin // READ_DAT\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = 6'd0; // IDLE\n                end else begin\n                    next_state = 6'd4; // READ_DAT\n                end\n            end\n            6'd5: begin // WRITE_BUSY\n                if (busy_int == 0) begin\n                    next_state = 6'd0; // IDLE\n                end else begin\n                    next_state = 6'd5; // WRITE_BUSY\n                end\n            end\n            default: begin\n                next_state = 6'd0; // IDLE\n            end\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            state <= 6'd0; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk) begin\n        case (state)\n            6'd0: begin // IDLE\n                // Reset variables\n                write_buf_0 <= 32'd0;\n                write_buf_1 <= 32'd0;\n                DAT_oe_o <= 1'b0;\n                crc_en <= 1'b0;\n                crc_rst <= 1'b1;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                busy_int <= 1'b0;\n                ack_transfer_int <= 1'b0;\n                ack_q <= 1'b0;\n                q_start_bit <= 1'b1;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n            6'd1: begin // WRITE_DAT\n                // Write data to buffers\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                DAT_oe_o <= 1'b1;\n                crc_en <= 1'b1;\n                crc_rst <= 1'b0;\n                transf_cnt <= transf_cnt + 1;\n                rd <= 1'b0;\n                last_din <= last_din + 4'd1;\n                crc_c <= crc_c + 5'd1;\n                crc_in <= crc_in + crc_out;\n                DAT_dat_o <= DAT_dat_i;\n                crc_status <= crc_status + 3'd1;\n                busy_int <= busy_int + 1'b1;\n                ack_transfer_int <= ack_transfer_int + ack_q;\n                ack_q <= ack_q + ack_transfer;\n                q_start_bit <= q_start_bit + 1'b0;\n                crc_s <= crc_s + 3'd1;\n                transm_complete <= transm_complete + 1'b0;\n                busy_n <= busy_n + 1'b0;\n                we <= we + 1'b1;\n                data_out <= data_out + data_in;\n                crc_ok <= crc_ok + 1'b0;\n                data_send_index <= data_send_index + 3'd1;\n                out_buff_ptr <= out_buff_ptr + 2'd1;\n                in_buff_ptr <= in_buff_ptr + 2'd1;\n            end\n            6'd2: begin // READ_WAIT\n                // Wait for start bit\n                DAT_oe_o <= 1'b0;\n                crc_en <= 1'b0;\n                crc_rst <= 1'b1;\n                transf_cnt <= 11'd0;\n                rd <= 1'b1;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                busy_int <= 1'b0;\n                ack_transfer_int <= 1'b0;\n                ack_q <= 1'b0;\n                q_start_bit <= 1'b1;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n            6'd3: begin // WRITE_CRC\n                // Generate CRC\n                crc_in <= crc_in + crc_out;\n                DAT_dat_o <= DAT_dat_i;\n                crc_status <= crc_status + 3'd1;\n                busy_int <= busy_int + 1'b1;\n                ack_transfer_int <= ack_transfer_int + ack_q;\n                ack_q <= ack_q + ack_transfer;\n                q_start_bit <= q_start_bit + 1'b0;\n                crc_s <= crc_s + 3'd1;\n                transm_complete <= transm_complete + 1'b0;\n                busy_n <= busy_n + 1'b0;\n                we <= we + 1'b1;\n                data_out <= data_out + data_in;\n                crc_ok <= crc_ok + 1'b0;\n                data_send_index <= data_send_index + 3'd1;\n                out_buff_ptr <= out_buff_ptr + 2'd1;\n                in_buff_ptr <= in_buff_ptr + 2'd1;\n            end\n            6'd4: begin // READ_DAT\n                // Read data from SD bus\n                DAT_oe_o <= 1'b1;\n                crc_en <= 1'b1;\n                crc_rst <= 1'b0;\n                transf_cnt <= transf_cnt + 1;\n                rd <= 1'b1;\n                last_din <= last_din + 4'd1;\n                crc_c <= crc_c + 5'd1;\n                crc_in <= crc_in + crc_out;\n                DAT_dat_o <= DAT_dat_i;\n                crc_status <= crc_status + 3'd1;\n                busy_int <= busy_int + 1'b1;\n                ack_transfer_int <= ack_transfer_int + ack_q;\n                ack_q <= ack_q + ack_transfer;\n                q_start_bit <= q_start_bit + 1'b0;\n                crc_s <= crc_s + 3'd1;\n                transm_complete <= transm_complete + 1'b0;\n                busy_n <= busy_n + 1'b0;\n                we <= we + 1'b1;\n                data_out <= data_out + data_in;\n                crc_ok <= crc_ok + 1'b0;\n                data_send_index <= data_send_index + 3'd1;\n                out_buff_ptr <= out_buff_ptr + 2'd1;\n                in_buff_ptr <= in_buff_ptr + 2'd1;\n            end\n            6'd5: begin // WRITE_BUSY\n                // Wait for busy signal\n                DAT_oe_o <= 1'b0;\n                crc_en <= 1'b0;\n                crc_rst <= 1'b1;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                busy_int <= 1'b0;\n                ack_transfer_int <= 1'b0;\n                ack_q <= 1'b0;\n                q_start_bit <= 1'b1;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n            default: begin\n                // Reset variables\n                write_buf_0 <= 32'd0;\n                write_buf_1 <= 32'd0;\n                DAT_oe_o <= 1'b0;\n                crc_en <= 1'b0;\n                crc_rst <= 1'b1;\n                transf_cnt <= 11'd0;\n                rd <= 1'b0;\n                last_din <= 4'd0;\n                crc_c <= 5'd0;\n                crc_in <= 32'd0;\n                DAT_dat_o <= 32'd0;\n                crc_status <= 3'd0;\n                busy_int <= 1'b0;\n                ack_transfer_int <= 1'b0;\n                ack_q <= 1'b0;\n                q_start_bit <= 1'b1;\n                crc_s <= 3'd0;\n                transm_complete <= 1'b0;\n                busy_n <= 1'b1;\n                we <= 1'b0;\n                data_out <= 32'd0;\n                crc_ok <= 1'b0;\n                data_send_index <= 3'd0;\n                out_buff_ptr <= 2'd0;\n                in_buff_ptr <= 2'd0;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 16, "code": "module sd_cmd_master(\n    input  wire  CLK_PAD_IO,\n    input  wire  RST_PAD_I,\n    input  wire  New_CMD,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire  [31:0] ARG_REG,\n    input  wire  [13:0] CMD_SET_REG,\n    input  wire  [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input  wire  ERR_INT_RST,\n    input  wire  NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input  wire  req_in,\n    input  wire  ack_in,\n    input  wire  [39:0] cmd_in,\n    input  wire  [7:0] serial_status,\n    input  wire  card_detect\n);\n\n    // Debounce Logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I)\n    begin\n        if (RST_PAD_I)\n        begin\n            debounce <= 0;\n            card_present <= 0;\n        end\n        else\n        begin\n            if (!card_detect)\n            begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                else\n                    card_present <= 1;\n            end\n            else\n                debounce <= 0;\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    reg req_q;\n    reg ack_q;\n    reg req_in_int;\n    reg ack_in_int;\n\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I)\n    begin\n        if (RST_PAD_I)\n        begin\n            req_q <= 0;\n            ack_q <= 0;\n            req_in_int <= 0;\n            ack_in_int <= 0;\n        end\n        else\n        begin\n            req_q <= req_in;\n            ack_q <= ack_in;\n            req_in_int <= req_q;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // Finite State Machine (FSM)\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I)\n    begin\n        if (RST_PAD_I)\n            state <= 3'b001; // IDLE\n        else\n            state <= next_state;\n    end\n\n    always_comb\n    begin\n        case (state)\n            3'b001: // IDLE\n                if (New_CMD)\n                    next_state = 3'b010; // SETUP\n                else\n                    next_state = 3'b001; // IDLE\n            3'b010: // SETUP\n                if (ack_in_int)\n                    next_state = 3'b100; // EXECUTE\n                else\n                    next_state = 3'b010; // SETUP\n            3'b100: // EXECUTE\n                if (complete)\n                    next_state = 3'b001; // IDLE\n                else\n                    next_state = 3'b100; // EXECUTE\n            default: // Default to IDLE\n                next_state = 3'b001; // IDLE\n        endcase\n    end\n\n    // FSM State operation\n    reg [15:0] CRC_check_enable;\n    reg complete;\n    reg [31:0] RESP_1_REG;\n    reg [4:0] ERR_INT_REG;\n    reg [15:0] NORMAL_INT_REG;\n    reg [15:0] STATUS_REG;\n    reg [6:0] status;\n    reg [39:0] cmd_out;\n    reg [15:0] settings;\n    reg [7:0] response_size;\n    reg req_out;\n    reg ack_out;\n    reg Watchdog_Cnt;\n    reg CCRCE;\n    reg EI;\n    reg CC;\n    reg go_idle_o;\n\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I)\n    begin\n        if (RST_PAD_I)\n        begin\n            CRC_check_enable <= 0;\n            complete <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            STATUS_REG <= 0;\n            status <= 0;\n            cmd_out <= 0;\n            settings <= 0;\n            response_size <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            Watchdog_Cnt <= 0;\n            CCRCE <= 0;\n            EI <= 0;\n            CC <= 0;\n            go_idle_o <= 0;\n        end\n        else\n        begin\n            case (state)\n                3'b001: // IDLE\n                    begin\n                        go_idle_o <= 0;\n                        req_out <= 0;\n                        ack_out <= 0;\n                        CICMD <= 0;\n                        if (req_in_int)\n                        begin\n                            status <= serial_status;\n                            ack_out <= 1;\n                        end\n                    end\n                3'b010: // SETUP\n                    begin\n                        NORMAL_INT_REG <= 0;\n                        ERR_INT_REG <= 0;\n                        index_check_enable <= CMD_SET_REG[4];\n                        CRC_check_enable <= CMD_SET_REG[3];\n                        cmd_out[39:38] <= 2'b01;\n                        cmd_out[37:32] <= CMD_SET_REG[13:8];\n                        cmd_out[31:0] <= ARG_REG;\n                        response_size <= (RTS == 2'b10 || RTS == 2'b11) ? small_rsp : (RTS == 2'b01 ? big_rsp : 0);\n                        settings[14:13] <= WORD_SELECT;\n                        settings[12] <= data_read;\n                        settings[11] <= data_write;\n                        settings[10:8] <= 3'b111;\n                        settings[7] <= CRCE;\n                        settings[6:0] <= response_size;\n                        Watchdog_Cnt <= 0;\n                        CICMD <= 1;\n                    end\n                3'b100: // EXECUTE\n                    begin\n                        Watchdog_Cnt <= Watchdog_Cnt + 1;\n                        if (Watchdog_Cnt > TIMEOUT_REG)\n                        begin\n                            CTE <= 1;\n                            EI <= 1;\n                            if (ack_in)\n                                complete <= 1;\n                            go_idle_o <= 1;\n                        end\n                        if (ack_in_int)\n                        begin\n                            req_out <= 1;\n                        end\n                        else if (req_in_int)\n                        begin\n                            status <= serial_status;\n                            ack_out <= 1;\n                            if (dat_ava)\n                            begin\n                                complete <= 1;\n                                EI <= 0;\n                                if (CRC_check_enable && ~crc_valid)\n                                begin\n                                    CCRCE <= 1;\n                                    EI <= 1;\n                                end\n                                if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32]))\n                                begin\n                                    CIE <= 1;\n                                    EI <= 1;\n                                end\n                                CC <= 1;\n                                if (response_size != 0)\n                                    RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                default: // Default to IDLE\n                    begin\n                        go_idle_o <= 0;\n                        req_out <= 0;\n                        ack_out <= 0;\n                        CICMD <= 0;\n                        if (req_in_int)\n                        begin\n                            status <= serial_status;\n                            ack_out <= 1;\n                        end\n                    end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 11, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input dat_in_tx,\n    input free_tx_bd,\n    input ack_i_s_tx,\n    input dat_in_rx,\n    input free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input transfer_type,\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output cmd_arg,\n    output cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output sys_adr,\n    output ack_transfer,\n    output Dat_Int_Status,\n    output CIDAT\n);\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg resend_try_cnt;\nreg state;\nreg next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg bd_cnt;\nreg sys_adr;\nreg cmd_arg;\nreg cmd_set;\nreg CIDAT;\nreg Dat_Int_Status;\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\nparameter READ_CYCLE = 2;\nparameter BD_EMPTY = 1;\n\n// FSM state machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end\nend\n\n// FSM state transition logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        next_state <= IDLE;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd!= BD_EMPTY) begin\n                    next_state <= GET_TX_BD;\n                end else if (free_rx_bd!= BD_EMPTY) begin\n                    next_state <= GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_TX_BD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_RX_BD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state <= RECIVE_CMD;\n                end else begin\n                    next_state <= SEND_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state <= DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= RECIVE_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state <= IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state <= STOP;\n                end else begin\n                    next_state <= DATA_TRANSFER;\n                end\n            end\n            STOP: begin\n                next_state <= STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= STOP_SEND;\n                end\n            end\n            default: begin\n                next_state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// FSM state machine logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Do nothing\n            end\n            GET_TX_BD: begin\n                // Read Tx BD\n                re_s_tx <= 1;\n                // Process data\n                if (RAM_MEM_WIDTH == 32) begin\n                    sys_adr <= dat_in_tx;\n                    cmd_arg <= dat_in_tx;\n                    start_tx_fifo <= 1;\n                end else if (RAM_MEM_WIDTH == 16) begin\n                    for (int i = 0; i < 4; i++) begin\n                        sys_adr <= dat_in_tx;\n                        cmd_arg <= dat_in_tx;\n                    end\n                    start_tx_fifo <= 1;\n                end\n                // Set cmd_set\n                cmd_set <= CMD24;\n                // Set tx_cycle\n                tx_cycle <= 1;\n            end\n            GET_RX_BD: begin\n                // Read Rx BD\n                re_s_rx <= 1;\n                // Process data\n                if (RAM_MEM_WIDTH == 32) begin\n                    sys_adr <= dat_in_rx;\n                    cmd_arg <= dat_in_rx;\n                end else if (RAM_MEM_WIDTH == 16) begin\n                    for (int i = 0; i < 4; i++) begin\n                        sys_adr <= dat_in_rx;\n                        cmd_arg <= dat_in_rx;\n                    end\n                end\n                // Set cmd_set\n                case (transfer_type)\n                    2'b00: cmd_set <= CMD17;\n                    2'b01: cmd_set <= ACMD13;\n                    default: cmd_set <= ACMD51;\n                endcase\n                // Set rx_cycle\n                rx_cycle <= 1;\n            end\n            SEND_CMD: begin\n                // Check if CMD is free\n                if (cmd_busy == 0) begin\n                    // Assert we_req\n                    we_req <= 1;\n                    // Wait for we_ack\n                    wait (we_ack == 1);\n                    // Set send_done\n                    send_done <= 1;\n                end\n            end\n            RECIVE_CMD: begin\n                // Start Rx Fifo Filler\n                start_rx_fifo <= 1;\n                // Wait for command response\n                wait (cmd_busy == 0);\n                // Check if cmd_tsf_err is asserted\n                if (cmd_tsf_err == 1) begin\n                    // Set rec_failed\n                    rec_failed <= 1;\n                end\n                // Check response data\n                if (card_status[0] == 1) begin\n                    // Check card status\n                    if (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6) begin\n                        // Set rec_done\n                        rec_done <= 1;\n                    end\n                end\n            end\n            DATA_TRANSFER: begin\n                // Check if tx_fifo is not empty\n                if (tx_full == 0) begin\n                    // Check if rx_fifo is not full\n                    if (rx_full == 0) begin\n                        // Wait for command complete\n                        wait (cmd_busy == 0);\n                        // Check if crc_ok is asserted\n                        if (crc_ok == 1) begin\n                            // Set trans_done\n                            trans_done <= 1;\n                        end\n                    end\n                end\n            end\n            STOP: begin\n                // Set cmd_set to CMD12\n                cmd_set <= CMD12;\n                // Set rec_done, rec_failed, send_done, trans_failed, trans_done to 0\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                // Set d_read, d_write to 1\n                d_read <= 1;\n                d_write <= 1;\n                // Set start_rx_fifo, start_tx_fifo to 0\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            STOP_SEND: begin\n                // Increment resend_try_cnt by 1\n                resend_try_cnt <= resend_try_cnt + 1;\n                // Check if resend_try_cnt reaches RESEND_MAX_CNT\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    // Set Dat_Int_Status[1] to 1\n                    Dat_Int_Status <= Dat_Int_Status | 1'b1;\n                end\n                // Check if CMD is not busy\n                if (cmd_busy == 0) begin\n                    // Request access to CMD registers\n                    we_req <= 1;\n                    // Wait for we_ack\n                    wait (we_ack == 1);\n                    // Check if success granted\n                    if (we_ack == 1) begin\n                        // Message has send done\n                        send_done <= 1;\n                    end\n                end\n            end\n            default: begin\n                // Do nothing\n            end\n        endcase\n    end\nend\n\n// Output signals\nassign re_s_tx = (state == GET_TX_BD)? 1 : 0;\nassign a_cmp_tx = (state == GET_TX_BD)? 1 : 0;\nassign re_s_rx = (state == GET_RX_BD)? 1 : 0;\nassign a_cmp_rx = (state == GET_RX_BD)? 1 : 0;\nassign we_req = (state == SEND_CMD)? 1 : 0;\nassign d_write = (state == SEND_CMD)? 1 : 0;\nassign d_read = (state == SEND_CMD)? 1 : 0;\nassign cmd_arg = (state == SEND_CMD)? cmd_arg : 0;\nassign cmd_set = (state == SEND_CMD)? cmd_set : 0;\nassign start_tx_fifo = (state == SEND_CMD)? 1 : 0;\nassign start_rx_fifo = (state == SEND_CMD)? 1 : 0;\nassign sys_adr = (state == SEND_CMD)? sys_adr : 0;\nassign ack_transfer = (state == DATA_TRANSFER)? 1 : 0;\nassign Dat_Int_Status = (state == DATA_TRANSFER)? Dat_Int_Status : 0;\nassign CIDAT = (state == DATA_TRANSFER)? CIDAT : 0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 10, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [ 7:0] wb_adr_i,\n    input  wire [ 3:0] wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [ 7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [ 7:0] clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [ 7:0] Bd_isr_reg,\n    output wire [ 7:0] Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Define the reset values for the registers\n    localparam RESET_VALUE = 0;\n\n    // Define the width of the RAM\n    localparam RAM_MEM_WIDTH = (RAM_MEM_WIDTH_16) ? 16 : 32;\n\n    // Define the width of the BD buffer\n    localparam BD_WIDTH = (BD_WIDTH <= 8) ? BD_WIDTH : 8;\n\n    // Define the size of the BD buffer\n    localparam BD_SIZE = (BD_WIDTH <= 8) ? (1 << BD_WIDTH) : 255;\n\n    // Define the maximum number of retries for resend data\n    localparam RESEND_MAX_CNT = 255;\n\n    // Define the memory address offset between 2 words\n    localparam MEM_OFFSET = 0;\n\n    // Define the clock divider value\n    localparam RESET_CLK_DIV = 0;\n\n    // Define the SD clock bus clock\n    localparam SD_CLK_BUS_CLK = 0;\n\n    // Define the SD clock separate\n    localparam SD_CLK_SEP = 0;\n\n    // Define the SD clock static\n    localparam SD_CLK_STATIC = 0;\n\n    // Define the SD clock dynamic\n    localparam SD_CLK_DYNAMIC = 0;\n\n    // Define the block size\n    localparam BLOCK_SIZE = 512;\n\n    // Define the SD bus width\n    localparam SD_BUS_WIDTH_4 = 0;\n\n    // Define the SD bus width\n    localparam SD_BUS_W = 4;\n\n    // Define the FIFO RX memory depth\n    localparam FIFO_RX_MEM_DEPTH = 0;\n\n    // Define the FIFO RX memory address size\n    localparam FIFO_RX_MEM_ADR_SIZE = 0;\n\n    // Define the FIFO TX memory depth\n    localparam FIFO_TX_MEM_DEPTH = 0;\n\n    // Define the FIFO TX memory address size\n    localparam FIFO_TX_MEM_ADR_SIZE = 0;\n\n    // Define the registers\n    reg [31:0] argument_reg;\n    reg [15:0] cmd_setting_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [ 7:0] software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [ 7:0] clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [ 7:0] Bd_isr_reg;\n    reg [ 7:0] Bd_isr_enable_reg;\n\n    // Define the BD RX and TX registers\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Define the control logic\n    wire cmd_int_busy;\n    wire int_busy;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n\n    // Define the reset logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            argument_reg <= RESET_VALUE;\n            cmd_setting_reg <= RESET_VALUE;\n            status_reg <= RESET_VALUE;\n            cmd_resp_1 <= RESET_VALUE;\n            software_reset_reg <= RESET_VALUE;\n            time_out_reg <= RESET_VALUE;\n            normal_int_status_reg <= RESET_VALUE;\n            error_int_status_reg <= RESET_VALUE;\n            normal_int_signal_enable_reg <= RESET_VALUE;\n            error_int_signal_enable_reg <= RESET_VALUE;\n            clock_divider <= RESET_VALUE;\n            Bd_Status_reg <= RESET_VALUE;\n            Bd_isr_reg <= RESET_VALUE;\n            Bd_isr_enable_reg <= RESET_VALUE;\n            dat_in_m_tx_bd <= 0;\n            dat_in_m_rx_bd <= 0;\n            int_ack <= 1;\n            we_m_tx_bd <= 0;\n            we_m_rx_bd <= 0;\n            cmd_int_busy <= 0;\n            int_busy <= 0;\n            new_cmd <= 0;\n            we_ack <= 0;\n        end\n    end\n\n    // Define the register write logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset the registers\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                4'h0: argument_reg <= wb_dat_i;\n                4'h4: cmd_setting_reg <= wb_dat_i;\n                4'h8: status_reg <= wb_dat_i;\n                4'hc: cmd_resp_1 <= wb_dat_i;\n                4'h1c: software_reset_reg <= wb_dat_i;\n                4'h28: time_out_reg <= wb_dat_i;\n                4'h30: normal_int_status_reg <= wb_dat_i;\n                4'h34: error_int_status_reg <= wb_dat_i;\n                4'h38: normal_int_signal_enable_reg <= wb_dat_i;\n                4'h3c: error_int_signal_enable_reg <= wb_dat_i;\n                4'h48: clock_divider <= wb_dat_i;\n                4'h50: Bd_Status_reg <= wb_dat_i;\n                4'h54: Bd_isr_reg <= wb_dat_i;\n                4'h58: Bd_isr_enable_reg <= wb_dat_i;\n                4'h60: dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                4'h80: dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                default: ;\n            endcase\n        end\n    end\n\n    // Define the register read logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset the registers\n        end else if (wb_stb_i && wb_cyc_i) begin\n            case (wb_adr_i)\n                4'h0: wb_dat_o <= argument_reg;\n                4'h4: wb_dat_o <= cmd_setting_reg;\n                4'h8: wb_dat_o <= status_reg;\n                4'hc: wb_dat_o <= cmd_resp_1;\n                4'h1c: wb_dat_o <= software_reset_reg;\n                4'h28: wb_dat_o <= time_out_reg;\n                4'h30: wb_dat_o <= normal_int_status_reg;\n                4'h34: wb_dat_o <= error_int_status_reg;\n                4'h38: wb_dat_o <= normal_int_signal_enable_reg;\n                4'h3c: wb_dat_o <= error_int_signal_enable_reg;\n                4'h48: wb_dat_o <= clock_divider;\n                4'h50: wb_dat_o <= Bd_Status_reg;\n                4'h54: wb_dat_o <= Bd_isr_reg;\n                4'h58: wb_dat_o <= Bd_isr_enable_reg;\n                4'h60: wb_dat_o <= dat_in_m_rx_bd;\n                4'h80: wb_dat_o <= dat_in_m_tx_bd;\n                default: wb_dat_o <= 0;\n            endcase\n        end\n    end\n\n    // Define the control logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset the control logic\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            if (wb_adr_i == 4'h60) begin\n                we_m_rx_bd <= 1;\n                int_ack <= 0;\n            end else if (wb_adr_i == 4'h80) begin\n                we_m_tx_bd <= 1;\n                int_ack <= 0;\n            end else begin\n                we_m_rx_bd <= 0;\n                we_m_tx_bd <= 0;\n                int_ack <= 1;\n            end\n        end else if (wb_stb_i && wb_cyc_i) begin\n            if (wb_adr_i == 4'h60) begin\n                int_ack <= 1;\n            end else if (wb_adr_i == 4'h80) begin\n                int_ack <= 1;\n            end\n        end\n    end\n\n    // Define the new_cmd signal\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            new_cmd <= 0;\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 4'h4) begin\n            new_cmd <= 1;\n        end else begin\n            new_cmd <= 0;\n        end\n    end\n\n    // Define the we_ack signal\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            we_ack <= 0;\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            if (wb_adr_i == 4'h60 || wb_adr_i == 4'h80) begin\n                we_ack <= 1;\n            end else begin\n                we_ack <= 0;\n            end\n        end else begin\n            we_ack <= 0;\n        end\n    end\n\n    // Define the cmd_int_busy signal\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            cmd_int_busy <= 0;\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 4'h4) begin\n            cmd_int_busy <= 1;\n        end else begin\n            cmd_int_busy <= 0;\n        end\n    end\n\n    // Define the int_busy signal\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            int_busy <= 0;\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 4'h0) begin\n            int_busy <= 1;\n        end else begin\n            int_busy <= 0;\n        end\n    end\n\n    // Define the wb_ack_o signal\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            wb_ack_o <= 0;\n        end else if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 17, "code": "module sd_cmd_master(\n    input  wire  clk_pad_io,\n    input  wire  rst_pad_i,\n    input  wire  new_cmd,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire  [31:0] arg_reg,\n    input  wire  [13:0] cmd_set_reg,\n    input  wire  [15:0] timeout_reg,\n    output reg [15:0] status_reg,\n    output reg [31:0] resp_1_reg,\n    output reg [4:0] err_int_reg,\n    output reg [15:0] normal_int_reg,\n    input  wire  err_int_rst,\n    input  wire  normal_int_rst,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input  wire  req_in,\n    input  wire  ack_in,\n    input  wire  [39:0] cmd_in,\n    input  wire  [7:0] serial_status,\n    input  wire  card_detect\n);\n\n    // Debounce Logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            debounce <= 0;\n            card_present <= 0;\n        end\n        else begin\n            if (!card_detect) begin\n                if (debounce < 4'b1111) debounce <= debounce + 1;\n                else card_present <= 1;\n            end\n            else debounce <= 0;\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    reg req_q;\n    reg ack_q;\n    reg req_in_int;\n    reg ack_in_int;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            req_q <= 0;\n            ack_q <= 0;\n            req_in_int <= 0;\n            ack_in_int <= 0;\n        end\n        else begin\n            req_q <= req_in;\n            ack_q <= ack_in;\n            req_in_int <= req_q;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // Finite State Machine (FSM)\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) state <= 3'b001;\n        else state <= next_state;\n    end\n\n    always_comb begin\n        case (state)\n            3'b001: next_state = (new_cmd) ? 3'b010 : 3'b001;\n            3'b010: next_state = (ack_in_int) ? 3'b100 : 3'b010;\n            3'b100: next_state = (complete) ? 3'b001 : 3'b100;\n            default: next_state = 3'b001;\n        endcase\n    end\n\n    // FSM State operation\n    reg [15:0] status;\n    reg complete;\n    reg [39:0] cmd_out;\n    reg [15:0] settings;\n    reg [7:0] response_size;\n    reg req_out;\n    reg ack_out;\n    reg [3:0] watchdog_cnt;\n    reg CCRCE;\n    reg EI;\n    reg CC;\n    reg go_idle_o;\n\n    always @(posedge clk_pad_io or posedge rst_pad_i) begin\n        if (rst_pad_i) begin\n            status <= 0;\n            complete <= 0;\n            cmd_out <= 0;\n            settings <= 0;\n            response_size <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            watchdog_cnt <= 0;\n            CCRCE <= 0;\n            EI <= 0;\n            CC <= 0;\n            go_idle_o <= 0;\n        end\n        else begin\n            case (state)\n                3'b001: begin\n                    // IDLE State\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    CICMD <= 0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                3'b010: begin\n                    // SETUP State\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    index_check_enable <= CICE;\n                    CRC_check_enable <= CRCE;\n                    response_size <= (RTS == 2'b10 || RTS == 2'b11) ? small_rsp : (RTS == 2'b01 ? big_rsp : 0);\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMDI;\n                    cmd_out[31:0] <= ARG_REG;\n                    settings[14:13] <= WORD_SELECT;\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CRCE;\n                    settings[6:0] <= response_size;\n                    watchdog_cnt <= 0;\n                    CICMD <= 1;\n                end\n                3'b100: begin\n                    // EXECUTE State\n                    if (watchdog_cnt > TIMEOUT_REG) begin\n                        CTE <= 1;\n                        EI <= 1;\n                        if (ack_in) complete <= 1;\n                        go_idle_o <= 1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                    end\n                    else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1;\n                        if (dat_ava) begin\n                            complete <= 1;\n                            EI <= 0;\n                            if (CRC_check_enable && ~crc_valid) begin\n                                CCRCE <= 1;\n                                EI <= 1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                CIE <= 1;\n                                EI <= 1;\n                            end\n                            CC <= 1;\n                            if (response_size != 0) RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                    watchdog_cnt <= watchdog_cnt + 1;\n                end\n                default: begin\n                    // Default to IDLE to ensure safe recovery from undefined states\n                    go_idle_o <= 1;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    CICMD <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 11, "code": "module sd_controller_wb(\n    // Wishbone Slave Interface\n    input  wire  wb_clk_i,  // Slave WISHBONE Clock Input\n    input  wire  wb_rst_i,  // Slave WISHBONE Reset Input\n    input  wire  [31:0] wb_dat_i,  // Slave WISHBONE Data Inputs\n    output wire  [31:0] wb_dat_o,  // Slave WISHBONE Data Outputs\n    input  wire  [7:0] wb_adr_i,  // Slave WISHBONE Address Input\n    input  wire  [3:0] wb_sel_i,  // Slave WISHBONE Select Input\n    input  wire  wb_we_i,  // Slave WISHBONE Write Enable\n    input  wire  wb_cyc_i,  // Slave WISHBONE Cycle\n    input  wire  wb_stb_i,  // Slave WISHBONE Strobe\n    output wire  wb_ack_o,  // Slave WISHBONE Acknowledge\n\n    // Master Wishbone Interface\n    output wire  we_m_tx_bd,  // Write enable TIx BD\n    output wire  we_m_rx_bd,  // Write enable Rx BD\n    output wire  new_cmd,  // New command indication signal\n    output wire  we_ack,  // Ack on cmd access request\n    output wire  int_ack,  // Internal Delayed Acknowledge\n    output wire  cmd_int_busy,  // Cmd busy by data module\n    output wire  int_busy,  // Command Busy by data module\n    input  wire  write_req_s,  // Cmd access request\n    input  wire  [15:0] cmd_set_s,  // Command setting input from data master\n    input  wire  [31:0] cmd_arg_s,  // Command argument input from data master\n    output wire  [31:0] argument_reg,  // Command Argument Reg\n    output wire  [15:0] cmd_setting_reg,  // Command Setting Reg\n    input  wire  [15:0] status_reg,  // Card Status Reg\n    input  wire  [31:0] cmd_resp_1,  // Command Response\n    output wire  [7:0] software_reset_reg,  // Software reset Reg\n    output wire  [15:0] time_out_reg,  // Timeout Reg\n    input  wire  [15:0] normal_int_status_reg,  // Normal Interrupt Status Reg\n    input  wire  [15:0] error_int_status_reg,  // Error Interrupt Status Reg\n    output wire  [15:0] normal_int_signal_enable_reg,  // Normal Interrupt Enable Reg\n    output wire  [15:0] error_int_signal_enable_reg,  // Error Interrupt Enable Reg\n    output wire  [7:0] clock_divider,  // Clock Divider Reg\n    input  wire  [15:0] Bd_Status_reg,  // BD Status Reg\n    input  wire  [7:0] Bd_isr_reg,  // Data Interrupt Status Reg\n    output wire  [7:0] Bd_isr_enable_reg,  // Data Interrupt Enable Reg\n    output wire  Bd_isr_reset,  // Reset data interrupt status\n    output wire  normal_isr_reset,  // Reset normal interrupt status\n    output wire  error_isr_reset,  // Reset error interrupt status\n    output wire  [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,  // Data going to the Tx BD\n    output wire  [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd  // Data going to the RX BD\n);\n\n// Argument Register\nreg [31:0] argument_reg;\n\n// Command Setting Register\nreg [15:0] cmd_setting_reg;\n\n// Card Status Register\nreg [15:0] status_reg;\n\n// Response Register\nreg [31:0] cmd_resp_1;\n\n// Controller Settings Register\nreg [15:0] controller_setting_reg;\n\n// Block Size Register\nreg [15:0] block_size_reg;\n\n// Power Control Register\nreg [7:0] power_control_reg;\n\n// Software Reset Register\nreg [7:0] software_reset_reg;\n\n// Timeout Register\nreg [15:0] time_out_reg;\n\n// Normal Interrupt Status Register\nreg [15:0] normal_int_status_reg;\n\n// Error Interrupt Status Register\nreg [15:0] error_int_status_reg;\n\n// Normal Interrupt Enable Register\nreg [15:0] normal_int_signal_enable_reg;\n\n// Error Interrupt Enable Register\nreg [15:0] error_int_signal_enable_reg;\n\n// Clock Divider Register\nreg [7:0] clock_divider;\n\n// BD Buffer Status Register\nreg [15:0] Bd_Status_reg;\n\n// Data Interrupt Status Register\nreg [7:0] Bd_isr_reg;\n\n// Data Interrupt Enable Register\nreg [7:0] Bd_isr_enable_reg;\n\n// BD RX Register\nreg [63:0] bd_rx_reg;\n\n// BD TX Register\nreg [63:0] bd_tx_reg;\n\n// Write enable for the master side's TX buffer descriptor\nwire we_m_tx_bd;\n\n// Write enable for the master side's RX buffer descriptor\nwire we_m_rx_bd;\n\n// New command indication signal\nwire new_cmd;\n\n// Ack on cmd access request\nwire we_ack;\n\n// Internal Delayed Acknowledge\nwire int_ack;\n\n// Cmd busy by data module\nwire cmd_int_busy;\n\n// Command Busy by data module\nwire int_busy;\n\n// Cmd access request\nwire write_req_s;\n\n// Command setting input from data master\nwire [15:0] cmd_set_s;\n\n// Command argument input from data master\nwire [31:0] cmd_arg_s;\n\n// Command Argument Reg\nassign argument_reg = cmd_arg_s;\n\n// Command Setting Reg\nassign cmd_setting_reg = cmd_set_s;\n\n// Card Status Reg\nassign status_reg = 16'h0000;\n\n// Command Response\nassign cmd_resp_1 = 32'h00000000;\n\n// Software reset Reg\nassign software_reset_reg = 8'h00;\n\n// Timeout Reg\nassign time_out_reg = 16'h0000;\n\n// Normal Interrupt Status Reg\nassign normal_int_status_reg = 16'h0000;\n\n// Error Interrupt Status Reg\nassign error_int_status_reg = 16'h0000;\n\n// Normal Interrupt Enable Reg\nassign normal_int_signal_enable_reg = 16'h0000;\n\n// Error Interrupt Enable Reg\nassign error_int_signal_enable_reg = 16'h0000;\n\n// Clock Divider Reg\nassign clock_divider = 8'h00;\n\n// BD Status Reg\nassign Bd_Status_reg = 16'h0000;\n\n// Data Interrupt Status Reg\nassign Bd_isr_reg = 8'h00;\n\n// Data Interrupt Enable Reg\nassign Bd_isr_enable_reg = 8'h00;\n\n// BD RX Register\nassign bd_rx_reg = 64'h0000000000000000;\n\n// BD TX Register\nassign bd_tx_reg = 64'h0000000000000000;\n\n// Write enable for the master side's TX buffer descriptor\nassign we_m_tx_bd = 1'b0;\n\n// Write enable for the master side's RX buffer descriptor\nassign we_m_rx_bd = 1'b0;\n\n// New command indication signal\nassign new_cmd = 1'b0;\n\n// Ack on cmd access request\nassign we_ack = 1'b0;\n\n// Internal Delayed Acknowledge\nassign int_ack = 1'b1;\n\n// Cmd busy by data module\nassign cmd_int_busy = 1'b0;\n\n// Command Busy by data module\nassign int_busy = 1'b0;\n\n// Cmd access request\nassign write_req_s = 1'b0;\n\n// Command setting input from data master\nassign cmd_set_s = 16'h0000;\n\n// Command argument input from data master\nassign cmd_arg_s = 32'h00000000;\n\n// Wishbone Slave Interface\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        wb_dat_o <= 32'h00000000;\n    end else if (wb_stb_i & wb_cyc_i & ~wb_ack_o & int_ack) begin\n        wb_dat_o <= wb_dat_i;\n    end\nend\n\n// Master Wishbone Interface\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        write_req_s <= 1'b0;\n        cmd_set_s <= 16'h0000;\n        cmd_arg_s <= 32'h00000000;\n    end else if (wb_stb_i & wb_cyc_i & wb_we_i) begin\n        case (wb_adr_i)\n            4'h0: begin\n                argument_reg <= wb_dat_i;\n            end\n            4'h4: begin\n                cmd_setting_reg <= wb_dat_i;\n            end\n            4'h8: begin\n                status_reg <= wb_dat_i;\n            end\n            4'hc: begin\n                cmd_resp_1 <= wb_dat_i;\n            end\n            4'h1c: begin\n                controller_setting_reg <= wb_dat_i;\n            end\n            4'h20: begin\n                block_size_reg <= wb_dat_i;\n            end\n            4'h24: begin\n                power_control_reg <= wb_dat_i;\n            end\n            4'h28: begin\n                software_reset_reg <= wb_dat_i;\n            end\n            4'h2c: begin\n                time_out_reg <= wb_dat_i;\n            end\n            4'h30: begin\n                normal_int_status_reg <= wb_dat_i;\n            end\n            4'h34: begin\n                error_int_status_reg <= wb_dat_i;\n            end\n            4'h38: begin\n                normal_int_signal_enable_reg <= wb_dat_i;\n            end\n            4'h3c: begin\n                error_int_signal_enable_reg <= wb_dat_i;\n            end\n            4'h48: begin\n                clock_divider <= wb_dat_i;\n            end\n            4'h50: begin\n                Bd_Status_reg <= wb_dat_i;\n            end\n            4'h54: begin\n                Bd_isr_reg <= wb_dat_i;\n            end\n            4'h58: begin\n                Bd_isr_enable_reg <= wb_dat_i;\n            end\n            4'h60: begin\n                bd_rx_reg <= wb_dat_i;\n            end\n            4'h80: begin\n                bd_tx_reg <= wb_dat_i;\n            end\n            default: begin\n                wb_ack_o <= 1'b0;\n            end\n        endcase\n    end\nend\n\n// BD RX and TX Register Write\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        int_ack <= 1'b1;\n    end else if (wb_stb_i & wb_cyc_i & wb_we_i) begin\n        case (wb_adr_i)\n            4'h60: begin\n                if (RAM_MEM_WIDTH == 32) begin\n                    bd_rx_reg <= wb_dat_i;\n                end else begin\n                    bd_rx_reg[31:16] <= wb_dat_i;\n                    bd_rx_reg[15:0] <= wb_dat_i;\n                end\n                we_m_rx_bd <= 1'b1;\n                int_ack <= 1'b0;\n                wb_ack_o <= 1'b0;\n            end\n            4'h80: begin\n                if (RAM_MEM_WIDTH == 32) begin\n                    bd_tx_reg <= wb_dat_i;\n                end else begin\n                    bd_tx_reg[31:16] <= wb_dat_i;\n                    bd_tx_reg[15:0] <= wb_dat_i;\n                end\n                we_m_tx_bd <= 1'b1;\n                int_ack <= 1'b0;\n                wb_ack_o <= 1'b0;\n            end\n            default: begin\n                wb_ack_o <= 1'b0;\n            end\n        endcase\n    end else if (wb_stb_i & wb_cyc_i & ~wb_we_i) begin\n        case (wb_adr_i)\n            4'h60: begin\n                wb_dat_o <= bd_rx_reg;\n            end\n            4'h80: begin\n                wb_dat_o <= bd_tx_reg;\n            end\n            default: begin\n                wb_dat_o <= 32'h00000000;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 18, "code": "module sd_cmd_master(\n    input  wire clk_pad_io,\n    input  wire rst_pad_i,\n    input  wire new_cmd,\n    input  wire data_write,\n    input  wire data_read,\n    input  wire [31:0] arg_reg,\n    input  wire [13:0] cmd_set_reg,\n    input  wire [15:0] timeout_reg,\n    output wire [15:0] status_reg,\n    output wire [31:0] resp_1_reg,\n    output wire [4:0]  err_int_reg,\n    output wire [15:0] normal_int_reg,\n    input  wire err_int_rst,\n    input  wire normal_int_rst,\n    output wire [15:0] settings,\n    output wire go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire req_out,\n    output wire ack_out,\n    input  wire req_in,\n    input  wire ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire card_detect\n);\n\n// Debounce Logic\nreg [3:0] debounce;\nreg card_present;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i)\nbegin\n    if (rst_pad_i)\n    begin\n        debounce <= 0;\n        card_present <= 0;\n    end\n    else\n    begin\n        if (!card_detect)\n        begin\n            if (debounce!= 4'b1111)\n                debounce <= debounce + 1;\n            else\n                card_present <= 1;\n        end\n        else\n            debounce <= 0;\n    end\nend\n\n// Request and Acknowledge Synchronizers\nreg req_q;\nreg ack_q;\nreg req_in_int;\nreg ack_in_int;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i)\nbegin\n    if (rst_pad_i)\n    begin\n        req_q <= 0;\n        ack_q <= 0;\n    end\n    else\n    begin\n        req_q <= req_in;\n        ack_q <= ack_in;\n        req_in_int <= req_q;\n        ack_in_int <= ack_q;\n    end\nend\n\n// Finite State Machine (FSM)\nreg [2:0] state;\nreg [2:0] next_state;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i)\nbegin\n    if (rst_pad_i)\n        state <= 3'b001;\n    else\n        state <= next_state;\nend\n\n// FSM State transitions\nalways_comb\nbegin\n    case (state)\n        3'b001: // IDLE\n            if (new_cmd)\n                next_state = 3'b010;\n            else\n                next_state = 3'b001;\n        3'b010: // SETUP\n            if (ack_in_int)\n                next_state = 3'b100;\n            else\n                next_state = 3'b010;\n        3'b100: // EXECUTE\n            if (complete)\n                next_state = 3'b001;\n            else\n                next_state = 3'b100;\n        default: // Default to IDLE\n            next_state = 3'b001;\n    endcase\nend\n\n// FSM State operation\nreg [15:0] status;\nreg [31:0] resp_1;\nreg [4:0]  err_int;\nreg [15:0] normal_int;\nreg complete;\nreg [15:0] settings_out;\nreg [39:0] cmd_out_reg;\nreg req_out_reg;\nreg ack_out_reg;\nreg [7:0]  serial_status_reg;\nreg [39:0] cmd_in_reg;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i)\nbegin\n    if (rst_pad_i)\n    begin\n        status <= 0;\n        resp_1 <= 0;\n        err_int <= 0;\n        normal_int <= 0;\n        complete <= 0;\n        settings_out <= 0;\n        cmd_out_reg <= 0;\n        req_out_reg <= 0;\n        ack_out_reg <= 0;\n        serial_status_reg <= 0;\n        cmd_in_reg <= 0;\n    end\n    else\n    begin\n        case (state)\n            3'b001: // IDLE\n                begin\n                    if (req_in_int)\n                    begin\n                        status <= serial_status;\n                        ack_out_reg <= 1;\n                    end\n                    else\n                        ack_out_reg <= 0;\n                end\n            3'b010: // SETUP\n                begin\n                    settings_out <= cmd_set_reg;\n                    cmd_out_reg <= {2'b01, cmd_set_reg[13:8], arg_reg};\n                    settings_out[14:13] <= cmd_set_reg[7:6];\n                    settings_out[12] <= data_read;\n                    settings_out[11] <= data_write;\n                    settings_out[10:8] <= 3'b111;\n                    settings_out[7] <= cmd_set_reg[3];\n                    settings_out[6:0] <= response_size;\n                    complete <= 0;\n                    req_out_reg <= 0;\n                    ack_out_reg <= 0;\n                end\n            3'b100: // EXECUTE\n                begin\n                    if (Watchdog_Cnt > timeout_reg)\n                    begin\n                        err_int[3] <= 1;\n                        err_int[1] <= 1;\n                        go_idle_o <= 1;\n                        complete <= 1;\n                    end\n                    else\n                    begin\n                        if (ack_in_int)\n                        begin\n                            req_out_reg <= 1;\n                        end\n                        else if (req_in_int)\n                        begin\n                            status <= serial_status;\n                            ack_out_reg <= 1;\n                            if (dat_ava)\n                            begin\n                                complete <= 1;\n                                err_int[1] <= 0;\n                                if (CRC_check_enable && ~crc_valid)\n                                begin\n                                    err_int[0] <= 1;\n                                    err_int[1] <= 1;\n                                end\n                                if (index_check_enable && (cmd_out_reg[37:32]!= cmd_in_reg[37:32]))\n                                begin\n                                    err_int[2] <= 1;\n                                    err_int[1] <= 1;\n                                end\n                                normal_int[15] <= 1;\n                                if (response_size!= 0)\n                                begin\n                                    resp_1 <= cmd_in_reg[31:0];\n                                end\n                            end\n                        end\n                    end\n                end\n            default: // Default to IDLE\n                begin\n                    status <= 0;\n                    resp_1 <= 0;\n                    err_int <= 0;\n                    normal_int <= 0;\n                    complete <= 0;\n                    settings_out <= 0;\n                    cmd_out_reg <= 0;\n                    req_out_reg <= 0;\n                    ack_out_reg <= 0;\n                    serial_status_reg <= 0;\n                    cmd_in_reg <= 0;\n                end\n        endcase\n    end\nend\n\n// Output Logic\nassign status_reg = status;\nassign resp_1_reg = resp_1;\nassign err_int_reg = err_int;\nassign normal_int_reg = normal_int;\nassign settings = settings_out;\nassign cmd_out = cmd_out_reg;\nassign req_out = req_out_reg;\nassign ack_out = ack_out_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 18, "code": "// sd_data_serial_host.v\n\nmodule sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:3] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Sub-modules\n    sd_crc_16 crc_16_gen(\n       .BITVAL(crc_in),\n       .Enable(crc_en),\n       .CLK(sd_clk),\n       .RST(crc_rst),\n       .CRC(crc_out)\n    );\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always_comb begin\n        case (state)\n            6'd0: // IDLE\n                next_state = (start_dat == 2'b01)? 6'd1 : ((start_dat == 2'b10)? 6'd2 : 6'd0);\n            6'd1: // WRITE_DAT\n                next_state = (transf_cnt == SD_BUS_W)? 6'd3 : 6'd1;\n            6'd2: // WRITE_CRC\n                next_state = (crc_status == 3'b111)? 6'd4 : 6'd2;\n            6'd3: // WRITE_BUSY\n                next_state = (busy_int == 1'b0)? 6'd0 : 6'd3;\n            6'd4: // READ_WAIT\n                next_state = (DAT_dat_i[0] == 1'b0)? 6'd5 : 6'd4;\n            6'd5: // READ_DAT\n                next_state = (transf_cnt == SD_BUS_W)? 6'd0 : 6'd5;\n            default: next_state = 6'd0;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) state <= 6'd0;\n        else state <= next_state;\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            write_buf_0 <= 32'd0;\n            write_buf_1 <= 32'd0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'd0;\n            rd <= 1'b0;\n            last_din <= 4'd0;\n            crc_c <= 5'd0;\n            crc_in <= 32'd0;\n            DAT_dat_o <= 32'd0;\n            crc_status <= 3'd7;\n            crc_s <= 3'd0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            sd_data_out <= 32'd0;\n            crc_ok <= 1'b0;\n            busy_int <= 1'b0;\n            data_send_index <= 3'd0;\n            out_buff_ptr <= 1'd0;\n            in_buff_ptr <= 1'd0;\n        end else begin\n            case (state)\n                6'd0: // IDLE\n                    if (start_dat == 2'b01) begin\n                        write_buf_0 <= data_in;\n                        write_buf_1 <= data_in;\n                        DAT_oe_o <= 1'b1;\n                        crc_en <= 1'b1;\n                        crc_rst <= 1'b0;\n                        transf_cnt <= 11'd0;\n                        rd <= 1'b0;\n                        last_din <= 4'd0;\n                        crc_c <= 5'd0;\n                        crc_in <= 32'd0;\n                        DAT_dat_o <= 32'd0;\n                        crc_status <= 3'd7;\n                        crc_s <= 3'd0;\n                        transm_complete <= 1'b0;\n                        busy_n <= 1'b1;\n                        we <= 1'b0;\n                        sd_data_out <= 32'd0;\n                        crc_ok <= 1'b0;\n                        busy_int <= 1'b0;\n                        data_send_index <= 3'd0;\n                        out_buff_ptr <= 1'd0;\n                        in_buff_ptr <= 1'd0;\n                    end\n                6'd1: // WRITE_DAT\n                    if (transf_cnt == SD_BUS_W) begin\n                        crc_en <= 1'b0;\n                        crc_rst <= 1'b1;\n                        crc_status <= 3'd7;\n                        crc_s <= 3'd0;\n                        transm_complete <= 1'b0;\n                        busy_n <= 1'b1;\n                        we <= 1'b0;\n                        sd_data_out <= 32'd0;\n                        crc_ok <= 1'b0;\n                        busy_int <= 1'b0;\n                        data_send_index <= 3'd0;\n                        out_buff_ptr <= 1'd0;\n                        in_buff_ptr <= 1'd0;\n                    end else begin\n                        DAT_dat_o <= write_buf_0[SD_BUS_W-1:SD_BUS_W-SD_BUS_W];\n                        crc_in <= write_buf_0[SD_BUS_W-1:SD_BUS_W-SD_BUS_W];\n                        write_buf_0 <= write_buf_0 << 1;\n                        write_buf_1 <= write_buf_1 << 1;\n                        transf_cnt <= transf_cnt + 1;\n                    end\n                6'd2: // WRITE_CRC\n                    if (crc_status == 3'b111) begin\n                        crc_en <= 1'b0;\n                        crc_rst <= 1'b1;\n                        crc_status <= 3'd7;\n                        crc_s <= 3'd0;\n                        transm_complete <= 1'b0;\n                        busy_n <= 1'b1;\n                        we <= 1'b0;\n                        sd_data_out <= 32'd0;\n                        crc_ok <= 1'b0;\n                        busy_int <= 1'b0;\n                        data_send_index <= 3'd0;\n                        out_buff_ptr <= 1'd0;\n                        in_buff_ptr <= 1'd0;\n                    end else begin\n                        crc_in <= write_buf_0[SD_BUS_W-1:SD_BUS_W-SD_BUS_W];\n                        write_buf_0 <= write_buf_0 << 1;\n                        write_buf_1 <= write_buf_1 << 1;\n                        crc_c <= crc_c + 1;\n                        if (crc_c == 5'd16) begin\n                            crc_en <= 1'b0;\n                            crc_rst <= 1'b1;\n                            crc_status <= 3'd7;\n                            crc_s <= 3'd0;\n                            transm_complete <= 1'b0;\n                            busy_n <= 1'b1;\n                            we <= 1'b0;\n                            sd_data_out <= 32'd0;\n                            crc_ok <= 1'b0;\n                            busy_int <= 1'b0;\n                            data_send_index <= 3'd0;\n                            out_buff_ptr <= 1'd0;\n                            in_buff_ptr <= 1'd0;\n                        end\n                    end\n                6'd3: // WRITE_BUSY\n                    if (busy_int == 1'b0) begin\n                        crc_en <= 1'b0;\n                        crc_rst <= 1'b1;\n                        crc_status <= 3'd7;\n                        crc_s <= 3'd0;\n                        transm_complete <= 1'b0;\n                        busy_n <= 1'b1;\n                        we <= 1'b0;\n                        sd_data_out <= 32'd0;\n                        crc_ok <= 1'b0;\n                        busy_int <= 1'b0;\n                        data_send_index <= 3'd0;\n                        out_buff_ptr <= 1'd0;\n                        in_buff_ptr <= 1'd0;\n                    end\n                6'd4: // READ_WAIT\n                    if (DAT_dat_i[0] == 1'b0) begin\n                        q_start_bit <= 1'b0;\n                        in_buff_ptr <= 1'd1;\n                        data_send_index <= 3'd0;\n                        out_buff_ptr <= 1'd0;\n                        crc_in <= 32'd0;\n                        DAT_dat_o <= 32'd0;\n                        crc_status <= 3'd7;\n                        crc_s <= 3'd0;\n                        transm_complete <= 1'b0;\n                        busy_n <= 1'b1;\n                        we <= 1'b0;\n                        sd_data_out <= 32'd0;\n                        crc_ok <= 1'b0;\n                        busy_int <= 1'b0;\n                    end\n                6'd5: // READ_DAT\n                    if (transf_cnt == SD_BUS_W) begin\n                        crc_en <= 1'b0;\n                        crc_rst <= 1'b1;\n                        crc_status <= 3'd7;\n                        crc_s <= 3'd0;\n                        transm_complete <= 1'b0;\n                        busy_n <= 1'b1;\n                        we <= 1'b0;\n                        sd_data_out <= 32'd0;\n                        crc_ok <= 1'b0;\n                        busy_int <= 1'b0;\n                        data_send_index <= 3'd0;\n                        out_buff_ptr <= 1'd0;\n                        in_buff_ptr <= 1'd0;\n                    end else begin\n                        DAT_dat_o <= DAR_dat_i[SD_BUS_W-1:SD_BUS_W-SD_BUS_W];\n                        crc_in <= DAR_dat_i[SD_BUS_W-1:SD_BUS_W-SD_BUS_W];\n                        DAR_dat_i <= DAR_dat_i << 1;\n                        transf_cnt <= transf_cnt + 1;\n                    end\n                default: begin\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    crc_status <= 3'd7;\n                    crc_s <= 3'd0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    sd_data_out <= 32'd0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 1'd0;\n                    in_buff_ptr <= 1'd0;\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    assign DAT_oe_o = (state == 6'd1)? 1'b1 : 1'b0;\n    assign DAT_dat_o = (state == 6'd1)? write_buf_0[SD_BUS_W-1:SD_BUS_W-SD_BUS_W] : DAR_dat_i[SD_BUS_W-1:SD_BUS_W-SD_BUS_W];\n    assign rd = (state == 6'd5)? 1'b1 : 1'b0;\n    assign we = (state == 6'd1)? 1'b1 : 1'b0;\n    assign busy_n = (state == 6'd3)? 1'b0 : 1'b1;\n    assign transm_complete = (state == 6'd2)? 1'b1 : 1'b0;\n    assign crc_ok = (state == 6'd5)? (crc_status == 3'b111) : 1'b0;\n\nendmodule\n\n// sd_crc_16.v\nmodule sd_crc_16(\n    input  wire BITVAL,\n    input  wire Enable,\n    input  wire CLK,\n    input  wire RST,\n    output wire [15:0] CRC\n);\n\n    reg [15:0] crc;\n    reg [15:0] temp;\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            crc <= 16'd0;\n        end else if (Enable) begin\n            if (BITVAL) begin\n                temp <= crc ^ {16{BITVAL}};\n                crc <= temp;\n            end\n        end\n    end\n\n    assign CRC = crc;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 9, "code": "module sd_cmd_serial_host(\n    input  wire  SD_CLK_IN,\n    input  wire  RST_IN,\n    input  wire  [15:0] SETTING_IN,\n    input  wire  [39:0] CMD_IN,\n    input  wire  REQ_IN,\n    input  wire  ACK_IN,\n    input  wire  cmd_dat_i,\n    output reg  [39:0] CMD_OUT,\n    output reg  wire  ACK_OUT,\n    output reg  wire  REQ_OUT,\n    output reg  wire  STATUS,\n    output reg  wire  cmd_oe_o,\n    output reg  wire  cmd_out_o,\n    output reg  wire  st_dat_t\n);\n\n    // Internal signals\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg [2:0] Delay_Cnt;\n    reg [7:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg [1:0] Write_Read;\n    reg [1:0] Write_Only;\n    reg [5:0] word_select_counter;\n    reg [1:0] word_select;\n    reg [1:0] block_write;\n    reg [1:0] block_read;\n    reg [1:0] FSM_ACK;\n    reg [1:0] DECODER_ACK;\n    reg [1:0] q;\n    reg [1:0] Req_internal_in;\n    reg [1:0] q1;\n    reg [1:0] Ack_internal_in;\n    reg [1:0] CRC_RST;\n    reg [7:0] CRC_IN;\n    reg [7:0] CRC_VAL;\n    reg [1:0] CRC_Enable;\n    reg [1:0] CRC_OUT;\n    reg [1:0] CRC_Check_On;\n    reg [1:0] Crc_Buffering;\n    reg [1:0] CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg [1:0] st_dat_t;\n\n    // FSM_COMBO\n    always_comb begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY) next_state = IDLE;\n                else next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1) next_state = DLY_WR;\n                else next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1) next_state = DLY_WO;\n                else next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i) next_state = READ_WR;\n                else next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler) next_state = ACK_WO;\n                else next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= Response_Size + EIGHT_PAD) next_state = DLY_READ;\n                else next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in) next_state = ACK_WR;\n                else next_state = DLY_READ;\n            end\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n            Delay_Cnt <= 0;\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            In_Buff <= 0;\n            Out_Buff <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            word_select_counter <= 0;\n            word_select <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            FSM_ACK <= 0;\n            DECODER_ACK <= 0;\n            q <= 0;\n            Req_internal_in <= 0;\n            q1 <= 0;\n            Ack_internal_in <= 0;\n            CRC_RST <= 0;\n            CRC_IN <= 0;\n            CRC_VAL <= 0;\n            CRC_Enable <= 0;\n            CRC_OUT <= 0;\n            CRC_Check_On <= 0;\n            Crc_Buffering <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            state <= next_state;\n            Delay_Cnt <= Delay_Cnt + 1;\n            Response_Size <= Response_Size;\n            Delay_Cycler <= Delay_Cycler;\n            In_Buff <= In_Buff;\n            Out_Buff <= Out_Buff;\n            Write_Read <= Write_Read;\n            Write_Only <= Write_Only;\n            word_select_counter <= word_select_counter;\n            word_select <= word_select;\n            block_write <= block_write;\n            block_read <= block_read;\n            FSM_ACK <= FSM_ACK;\n            DECODER_ACK <= DECODER_ACK;\n            q <= q;\n            Req_internal_in <= Req_internal_in;\n            q1 <= q1;\n            Ack_internal_in <= Ack_internal_in;\n            CRC_RST <= CRC_RST;\n            CRC_IN <= CRC_IN;\n            CRC_VAL <= CRC_VAL;\n            CRC_Enable <= CRC_Enable;\n            CRC_OUT <= CRC_OUT;\n            CRC_Check_On <= CRC_Check_On;\n            Crc_Buffering <= Crc_Buffering;\n            CRC_Valid <= CRC_Valid;\n            Cmd_Cnt <= Cmd_Cnt + 1;\n            st_dat_t <= st_dat_t;\n        end\n    end\n\n    // REQ_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else begin\n            if (Req_internal_in) begin\n                Response_Size <= SETTING_IN[6:0];\n                CRC_Check_On <= SETTING_IN[7];\n                Delay_Cycler <= SETTING_IN[10:8];\n                block_write <= SETTING_IN[11];\n                block_read <= SETTING_IN[12];\n                word_select <= SETTING_IN[14:13];\n                In_Buff <= CMD_IN;\n                if (SETTING_IN[6:0] > 0) begin\n                    Write_Read <= 1;\n                    Write_Only <= 0;\n                end else begin\n                    Write_Read <= 0;\n                    Write_Only <= 1;\n                end\n                DECODER_ACK <= 0;\n            end else begin\n                DECODER_ACK <= 1;\n                Write_Read <= 0;\n                Write_Only <= 0;\n            end\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            CRC_Valid <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                end\n                WRITE_WR: begin\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Bit_Nr > 8) begin\n                            CMD_OUT <= CMD_OUT[39:1] << 1 | CMD_IN;\n                            if (Bit_Nr > 9) begin\n                                CRC_OUT <= CRC_OUT << 1 | CRC_IN;\n                            end\n                        end else if (Bit_Nr <= 8 && Bit_Nr >= 2) begin\n                            CRC_OUT <= CRC_OUT << 1 | CRC_IN;\n                            st_dat_t <= st_dat_t;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39:32] << 1 | In_Buff[31:24];\n                    end\n                end\n                WRITE_WO: begin\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Bit_Nr > 8) begin\n                            CMD_OUT <= CMD_OUT[39:1] << 1 | CMD_IN;\n                            if (Bit_Nr > 9) begin\n                                CRC_OUT <= CRC_OUT << 1 | CRC_IN;\n                            end\n                        end else if (Bit_Nr <= 8 && Bit_Nr >= 2) begin\n                            CRC_OUT <= CRC_OUT << 1 | CRC_IN;\n                            st_dat_t <= st_dat_t;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39:32] << 1 | In_Buff[31:24];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Cmd_Cnt <= 0;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[Cmd_Cnt + 1] <= cmd_dat_i;\n                        CRC_IN <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= st_dat_t;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Cmd_Cnt <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Crc_Buffering <= 0;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n                default: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n            endcase\n        end\n    end\n\n    // sd_crc_7\n    sd_crc_7 sd_crc_7_inst(\n        .BITVAL(cmd_dat_i),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_OUT)\n    );\n\n    // Assign outputs\n    CMD_OUT <= Out_Buff;\n    ACK_OUT <= FSM_ACK;\n    REQ_OUT <= REQ_OUT;\n    STATUS <= STATUS;\n    cmd_oe_o <= cmd_oe_o;\n    cmd_out_o <= cmd_out_o;\n    st_dat_t <= st_dat_t;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 12, "code": "module sd_data_master(\n    input  wire clk,\n    input  wire rst,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input  wire [BD_WIDTH-1:0] free_tx_bd,\n    input  wire ack_i_s_tx,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input  wire [BD_WIDTH-1:0] free_rx_bd,\n    input  wire ack_i_s_rx,\n    input  wire cmd_busy,\n    input  wire we_ack,\n    input  wire cmd_tsf_err,\n    input  wire [4:0] card_status,\n    input  wire tx_empt,\n    input  wire tx_full,\n    input  wire rx_full,\n    input  wire busy_n,\n    input  wire transm_complete,\n    input  wire crc_ok,\n    input  wire Dat_Int_Status_rst,\n    input  wire [1:0] transfer_type,\n    output wire re_s_tx,\n    output wire a_cmp_tx,\n    output wire re_s_rx,\n    output wire a_cmp_rx,\n    output wire we_req,\n    output wire d_write,\n    output wire d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire start_tx_fifo,\n    output wire start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire ack_transfer,\n    output wire [7:0] Dat_Int_Status\n);\n\n// Internal signals\nreg [8:0] state;\nreg [8:0] next_state;\nreg [1:0] resend_try_cnt;\nreg [1:0] tx_cycle;\nreg [1:0] rx_cycle;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr;\nreg [31:0] cmd_arg;\nreg [15:0] cmd_set;\nreg [1:0] CIDAT;\nreg [7:0] Dat_Int_Status;\nreg [1:0] trans_done;\nreg [1:0] trans_failed;\nreg [1:0] internal_transm_complete;\nreg [1:0] transm_complete_q;\nreg [1:0] send_done;\nreg [1:0] rec_done;\nreg [1:0] rec_failed;\nreg [1:0] cmd_busy;\nreg [1:0] we_req;\nreg [1:0] d_write;\nreg [1:0] d_read;\nreg [1:0] start_tx_fifo;\nreg [1:0] start_rx_fifo;\nreg [1:0] ack_transfer;\n\n// FSM state definitions\nlocalparam IDLE = 9'b000000001;\nlocalparam GET_TX_BD = 9'b000000010;\nlocalparam GET_RX_BD = 9'b000000100;\nlocalparam SEND_CMD = 9'b000001000;\nlocalparam RECIVE_CMD = 9'b000010000;\nlocalparam DATA_TRANSFER = 9'b000100000;\nlocalparam STOP = 9'b001000000;\nlocalparam STOP_SEND = 9'b010000000;\n\n// FSM state transition table\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n    end\n    else begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state <= GET_TX_BD;\n                end\n                else if (free_rx_bd != BD_EMPTY) begin\n                    next_state <= GET_RX_BD;\n                end\n                else begin\n                    next_state <= IDLE;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state <= SEND_CMD;\n                end\n                else begin\n                    next_state <= GET_TX_BD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state <= SEND_CMD;\n                end\n                else begin\n                    next_state <= GET_RX_BD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state <= RECIVE_CMD;\n                end\n                else begin\n                    next_state <= SEND_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state <= DATA_TRANSFER;\n                end\n                else if (rec_failed == 1) begin\n                    next_state <= SEND_CMD;\n                end\n                else begin\n                    next_state <= RECIVE_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state <= IDLE;\n                end\n                else if (trans_failed == 1) begin\n                    next_state <= STOP;\n                end\n                else begin\n                    next_state <= DATA_TRANSFER;\n                end\n            end\n            STOP: begin\n                next_state <= STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state <= IDLE;\n                end\n                else begin\n                    next_state <= STOP_SEND;\n                end\n            end\n            default: next_state <= IDLE;\n        endcase\n    end\nend\n\n// FSM state machine\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n    end\n    else begin\n        state <= next_state;\n    end\nend\n\n// FSM output logic\nalways @(posedge clk) begin\n    if (rst) begin\n        // Reset all control signals\n        re_s_tx <= 1'b0;\n        a_cmp_tx <= 1'b0;\n        re_s_rx <= 1'b0;\n        a_cmp_rx <= 1'b0;\n        we_req <= 1'b0;\n        d_write <= 1'b0;\n        d_read <= 1'b0;\n        cmd_arg <= 32'b0;\n        cmd_set <= 16'b0;\n        start_tx_fifo <= 1'b0;\n        start_rx_fifo <= 1'b0;\n        sys_adr <= 32'b0;\n        ack_transfer <= 1'b0;\n        Dat_Int_Status <= 8'b0;\n    end\n    else begin\n        case (state)\n            IDLE: begin\n                // Do nothing\n            end\n            GET_TX_BD: begin\n                // Assert re_s_tx to read a transmit buffer descriptor\n                re_s_tx <= 1'b1;\n                // Process data based on memory width\n                if (RAM_MEM_WIDTH == 32) begin\n                    // First read: Store data to sys_adr\n                    sys_adr <= dat_in_tx;\n                    // Second read: Store data to cmd_arg and start TX FIFO\n                    cmd_arg <= dat_in_tx;\n                    start_tx_fifo <= 1'b1;\n                end\n                else if (RAM_MEM_WIDTH == 16) begin\n                    // Four reads to populate sys_adr and cmd_arg (16 bits at a time)\n                    sys_adr <= {dat_in_tx, dat_in_tx};\n                    cmd_arg <= {dat_in_tx, dat_in_tx};\n                    start_tx_fifo <= 1'b1;\n                end\n                // Set cmd_set = CMD24 (write single block command)\n                cmd_set <= CMD24;\n                // Set tx_cycle = 1 to indicate transmit mode\n                tx_cycle <= 1'b1;\n            end\n            GET_RX_BD: begin\n                // Assert re_s_rx to read a receive buffer descriptor\n                re_s_rx <= 1'b1;\n                // Process data based on memory width\n                if (RAM_MEM_WIDTH == 32) begin\n                    // First read: Store data to sys_adr\n                    sys_adr <= dat_in_rx;\n                    // Second read: Store data to cmd_arg\n                    cmd_arg <= dat_in_rx;\n                end\n                else if (RAM_MEM_WIDTH == 16) begin\n                    // Four reads to populate sys_adr and cmd_arg (16 bits at a time)\n                    sys_adr <= {dat_in_rx, dat_in_rx};\n                    cmd_arg <= {dat_in_rx, dat_in_rx};\n                end\n                // Set command based on transfer_type\n                if (transfer_type == 2'b00) begin\n                    // Set cmd_set = CMD17 (read single block)\n                    cmd_set <= CMD17;\n                end\n                else if (transfer_type == 2'b01) begin\n                    // Set cmd_set = ACMD13 (SD status)\n                    cmd_set <= ACMD13;\n                end\n                else begin\n                    // Set cmd_set = ACMD51 (SCR register)\n                    cmd_set <= ACMD51;\n                end\n                // Set rx_cycle = 1 to indicate receive mode\n                rx_cycle <= 1'b1;\n            end\n            SEND_CMD: begin\n                // Check type of cycle rx or tx\n                if (tx_cycle == 1) begin\n                    // Set d_write = 1\n                    d_write <= 1'b1;\n                end\n                else begin\n                    // Set d_read = 1\n                    d_read <= 1'b1;\n                end\n                // Check if CMD is free, if so assert we_req\n                if (cmd_busy == 1'b0) begin\n                    we_req <= 1'b1;\n                end\n                // Wait for we_ack\n                if (we_ack == 1'b1) begin\n                    // Set send_done = 1\n                    send_done <= 1'b1;\n                end\n            end\n            RECIVE_CMD: begin\n                // Start Rx_Fifo_Filer if Rx cycle\n                if (rx_cycle == 1) begin\n                    start_rx_fifo <= 1'b1;\n                end\n                // Wait for command response (indicated by cmd_busy are low)\n                if (cmd_busy == 1'b0) begin\n                    // Check so cmd_tsf_err is not asserted, if asserted set command_failed.\n                    if (cmd_tsf_err == 1'b1) begin\n                        rec_failed <= 1'b1;\n                    end\n                    // Check the response data,\n                    if (card_status[0] == 1'b1) begin\n                        // If card is ready for data card_status[4:1] == 4,5 or 6\n                        if ((card_status[4:1] == 4) || (card_status[4:1] == 5) || (card_status[4:1] == 6)) begin\n                            // Set rec_done = 1\n                            rec_done <= 1'b1;\n                        end\n                    end\n                end\n            end\n            DATA_TRANSFER: begin\n                // If tx_cycle check so tx_fifo doenst get empty \n                if (tx_cycle == 1) begin\n                    if (tx_full == 1'b0) begin\n                        // Wait for command complete\n                        if (cmd_busy == 1'b0) begin\n                            // Check so crc_ok == 1 \n                            if (crc_ok == 1'b1) begin\n                                // Free the BD\n                                a_cmp_tx <= 1'b1;\n                            end\n                        end\n                    end\n                end\n                // If rx_cycle check so rx_fifo doenst get full \n                else if (rx_cycle == 1) begin\n                    if (rx_full == 1'b0) begin\n                        // Wait for command complete\n                        if (cmd_busy == 1'b0) begin\n                            // Check so crc_ok == 1 \n                            if (crc_ok == 1'b1) begin\n                                // Free the BD\n                                a_cmp_rx <= 1'b1;\n                            end\n                        end\n                    end\n                end\n            end\n            STOP: begin\n                // Set cmd_set = CMD12\n                cmd_set <= CMD12;\n                // Set rec_done, rec_failed, send_done, trans_failed, trans_done to 0\n                rec_done <= 1'b0;\n                rec_failed <= 1'b0;\n                send_done <= 1'b0;\n                trans_failed <= 1'b0;\n                trans_done <= 1'b0;\n                // Set d_read, d_write to 1\n                d_read <= 1'b1;\n                d_write <= 1'b1;\n                // Set start_rx_fifo, start_tx_fifo to 0\n                start_rx_fifo <= 1'b0;\n                start_tx_fifo <= 1'b0;\n            end\n            STOP_SEND: begin\n                // Increment resend_try_cnt by 1\n                resend_try_cnt <= resend_try_cnt + 1;\n                // If resend_try_cnt reachs RESEND_MAX_CNT, then set Dat_Int_Status[1] to 1\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1'b1;\n                end\n                // If CMD is not busy, then request access to CMD registers\n                if (cmd_busy == 1'b0) begin\n                    we_req <= 1'b1;\n                end\n                // If sccess granted(we_ack == 1), then message has send done.\n                if (we_ack == 1'b1) begin\n                    send_done <= 1'b1;\n                end\n            end\n            default: begin\n                // Do nothing\n            end\n        endcase\n    end\nend\n\n// Internal signal assignments\nassign re_s_tx = (state == GET_TX_BD) ? 1'b1 : 1'b0;\nassign a_cmp_tx = (state == GET_TX_BD) ? 1'b1 : 1'b0;\nassign re_s_rx = (state == GET_RX_BD) ? 1'b1 : 1'b0;\nassign a_cmp_rx = (state == GET_RX_BD) ? 1'b1 : 1'b0;\nassign we_req = (state == SEND_CMD) ? 1'b1 : 1'b0;\nassign d_write = (state == SEND_CMD) ? 1'b1 : 1'b0;\nassign d_read = (state == SEND_CMD) ? 1'b1 : 1'b0;\nassign cmd_arg = (state == SEND_CMD) ? cmd_arg : 32'b0;\nassign cmd_set = (state == SEND_CMD) ? cmd_set : 16'b0;\nassign start_tx_fifo = (state == SEND_CMD) ? 1'b1 : 1'b0;\nassign start_rx_fifo = (state == SEND_CMD) ? 1'b1 : 1'b0;\nassign sys_adr = (state == SEND_CMD) ? sys_adr : 32'b0;\nassign ack_transfer = (state == DATA_TRANSFER) ? 1'b1 : 1'b0;\nassign Dat_Int_Status = (state == DATA_TRANSFER) ? Dat_Int_Status : 8'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 12, "code": "module sd_controller_wb(\n    // WISHBONE Slave Interface\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire        wb_dat_i [31:0],\n    output wire        wb_dat_o [31:0],\n    input  wire        wb_adr_i [7:0],\n    input  wire        wb_sel_i [3:0],\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    // SD Controller Interface\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire        cmd_set_s [15:0],\n    input  wire        cmd_arg_s [31:0],\n    output wire        argument_reg [31:0],\n    output wire        cmd_setting_reg [15:0],\n    input  wire        status_reg [15:0],\n    input  wire        cmd_resp_1 [31:0],\n    output wire        software_reset_reg [7:0],\n    output wire        time_out_reg [15:0],\n    input  wire        normal_int_status_reg [15:0],\n    input  wire        error_int_status_reg [15:0],\n    output wire        normal_int_signal_enable_reg [15:0],\n    output wire        error_int_signal_enable_reg [15:0],\n    output wire        clock_divider [7:0],\n    input  wire        Bd_Status_reg [15:0],\n    input  wire        Bd_isr_reg [7:0],\n    output wire        Bd_isr_enable_reg [7:0],\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire        dat_in_m_tx_bd [RAM_MEM_WIDTH-1:0],\n    output wire        dat_in_m_rx_bd [RAM_MEM_WIDTH-1:0]\n);\n\n    // Register definitions\n    reg [31:0] argument_reg;\n    reg [15:0] cmd_setting_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [7:0] software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0] clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [7:0] Bd_isr_reg;\n    reg [7:0] Bd_isr_enable_reg;\n\n    // Internal signals\n    wire cmd_int_busy;\n    wire int_busy;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n\n    // Clock and Reset\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            argument_reg <= 32'd0;\n            cmd_setting_reg <= 16'd0;\n            status_reg <= 16'd0;\n            cmd_resp_1 <= 32'd0;\n            software_reset_reg <= 8'd0;\n            time_out_reg <= 16'd0;\n            normal_int_status_reg <= 16'd0;\n            error_int_status_reg <= 16'd0;\n            normal_int_signal_enable_reg <= 16'd0;\n            error_int_signal_enable_reg <= 16'd0;\n            clock_divider <= 8'd0;\n            Bd_Status_reg <= 16'd0;\n            Bd_isr_reg <= 8'd0;\n            Bd_isr_enable_reg <= 8'd0;\n            int_ack <= 1'b1;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n        else begin\n            // Register write\n            if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h08: status_reg <= wb_dat_i[15:0];\n                    8'h0c: cmd_resp_1 <= wb_dat_i;\n                    8'h1c: // Controller Setting\n                    8'h20: // Block Size\n                    8'h24: // Power Control\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i;\n                    8'h30: normal_int_status_reg <= wb_dat_i;\n                    8'h34: error_int_status_reg <= wb_dat_i;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i;\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i;\n                    8'h48: // Capability\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h50: Bd_Status_reg <= wb_dat_i;\n                    8'h54: // Data Interrupt Status\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: // BD RX\n                    8'h80: // BD TX\n                    default: ;\n                endcase\n            end\n            // Register read\n            if (wb_stb_i && wb_cyc_i) begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {cmd_setting_reg, 12'h0};\n                    8'h08: wb_dat_o <= status_reg;\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: // Controller Setting\n                    8'h20: // Block Size\n                    8'h24: // Power Control\n                    8'h28: wb_dat_o <= software_reset_reg;\n                    8'h2c: wb_dat_o <= time_out_reg;\n                    8'h30: wb_dat_o <= normal_int_status_reg;\n                    8'h34: wb_dat_o <= error_int_status_reg;\n                    8'h38: wb_dat_o <= normal_int_signal_enable_reg;\n                    8'h3c: wb_dat_o <= error_int_signal_enable_reg;\n                    8'h48: // Capability\n                    8'h4c: wb_dat_o <= {clock_divider, 8'h0};\n                    8'h50: wb_dat_o <= Bd_Status_reg;\n                    8'h54: // Data Interrupt Status\n                    8'h58: wb_dat_o <= Bd_isr_reg;\n                    8'h60: // BD RX\n                    8'h80: // BD TX\n                    default: wb_dat_o <= 32'h0;\n                endcase\n            end\n        end\n    end\n\n    // Control Logic\n    assign cmd_int_busy = (write_req_s && (cmd_set_s != 16'h0));\n    assign int_busy = (wb_adr_i == 8'h04);\n    assign new_cmd = (cmd_arg_s != 16'h0);\n    assign we_ack = write_req_s;\n    assign int_ack = (int_ack && (wb_adr_i != 8'h60 && wb_adr_i != 8'h80));\n    assign we_m_tx_bd = (wb_adr_i == 8'h80);\n    assign we_m_rx_bd = (wb_adr_i == 8'h60);\n    assign wb_ack_o = (wb_cyc_i && wb_stb_i && ~wb_ack_o && int_ack);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 10, "code": "module sd_cmd_serial_host(\n    input  wire  SD_CLK_IN,\n    input  wire  RST_IN,\n    input  wire  [15:0] SETTING_IN,\n    input  wire  [39:0] CMD_IN,\n    input  wire  REQ_IN,\n    input  wire  ACK_IN,\n    input  wire  cmd_dat_i,\n\n    output reg  [39:0] CMD_OUT,\n    output reg  wire  ACK_OUT,\n    output reg  wire  REQ_OUT,\n    output reg  [7:0] STATUS,\n    output reg  wire  cmd_oe_o,\n    output reg  wire  cmd_out_o,\n    output reg  wire  st_dat_t\n);\n\n    // Internal constants and parameters\n    localparam INIT_DELAY = 2;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n    localparam INIT = 8'b00000000;\n    localparam IDLE = 8'b00000001;\n    localparam WRITE_WR = 8'b00000010;\n    localparam DLY_WR = 8'b00000011;\n    localparam READ_WR = 8'b00000100;\n    localparam DLY_READ = 8'b00000101;\n    localparam ACK_WR = 8'b00000110;\n    localparam WRITE_WO = 8'b00000111;\n    localparam DLY_WO = 8'b00001000;\n    localparam ACK_WO = 8'b00001001;\n\n    // Internal signals\n    reg [7:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    reg [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO\n    always_comb begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= Response_Size + EIGHT_PAD)\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = INIT;\n            end\n        endcase\n    end\n\n    // FSM_SEQ\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            q <= 0;\n        else\n            q <= REQ_IN;\n    end\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            Req_internal_in <= 0;\n        else\n            Req_internal_in <= q;\n    end\n\n    // ACK_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            q1 <= 0;\n        else\n            q1 <= ACK_IN;\n    end\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            Ack_internal_in <= 0;\n        else\n            Ack_internal_in <= q1;\n    end\n\n    // COMMAND_DECODER\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else if (!DECODER_ACK) begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    STATUS <= 0;\n                    CRC_Valid <= 0;\n                    Cmd_Cnt <= 0;\n                    st_dat_t <= 0;\n                end\n                WRITE_WR: begin\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Bit_Nr > 8) begin\n                            CMD_OUT <= CMD_OUT[39:1] << 1 | CMD_IN;\n                            if (Bit_Nr > 9)\n                                CRC_OUT <= CRC_OUT << 1 | CRC_IN;\n                        end else if (Bit_Nr <= 8 && Bit_Nr >= 2) begin\n                            CRC_OUT <= CRC_OUT << 1 | CRC_IN;\n                            st_dat_t <= st_dat_t << 1 | word_select;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Pre_load_CRC <= 1;\n                        CRC_OUT <= In_Buff[39:32] << 1 | In_Buff[31:24];\n                    end\n                end\n                WRITE_WO: begin\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Bit_Nr > 8) begin\n                            CMD_OUT <= CMD_OUT[39:1] << 1 | CMD_IN;\n                            if (Bit_Nr > 9)\n                                CRC_OUT <= CRC_OUT << 1 | CRC_IN;\n                        end else if (Bit_Nr <= 8 && Bit_Nr >= 2) begin\n                            CRC_OUT <= CRC_OUT << 1 | CRC_IN;\n                            st_dat_t <= st_dat_t << 1 | word_select;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Pre_load_CRC <= 1;\n                        CRC_OUT <= In_Buff[39:32] << 1 | In_Buff[31:24];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    cmd_oe_o <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    STATUS <= 0;\n                    CRC_Valid <= 0;\n                    Cmd_Cnt <= 1;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    cmd_oe_o <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    STATUS <= 0;\n                    CRC_Valid <= 0;\n                    Cmd_Cnt <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[Cmd_Cnt + 1] <= cmd_dat_i;\n                        CRC_IN <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= st_dat_t << 1 | word_select;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    cmd_oe_o <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Cmd_Cnt <= 0;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n                default: begin\n                    FSM_ACK <= 1;\n                end\n            endcase\n        end\n    end\n\n    // sd_crc_7\n    sd_crc_7 sd_crc_7_module(\n        .BITVAL(cmd_dat_i),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_OUT)\n    );\n\n    // Assign outputs\n    CMD_OUT <= Out_Buff;\n    ACK_OUT <= FSM_ACK;\n    REQ_OUT <= FSM_ACK;\n    STATUS <= STATUS;\n    cmd_oe_o <= cmd_oe_o;\n    cmd_out_o <= cmd_out_o;\n    st_dat_t <= st_dat_t;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 11, "code": "module sd_cmd_serial_host(\n    input  wire  SD_CLK_IN,\n    input  wire  RST_IN,\n    input  wire  [15:0] SETTING_IN,\n    input  wire  [39:0] CMD_IN,\n    input  wire  REQ_IN,\n    input  wire  ACK_IN,\n    input  wire  cmd_dat_i,\n    output wire  [39:0] CMD_OUT,\n    output wire  ACK_OUT,\n    output wire  REQ_OUT,\n    output wire  [7:0] STATUS,\n    output wire  cmd_oe_o,\n    output wire  cmd_out_o,\n    output wire  st_dat_t\n);\n\n    // Internal Constants and Parameters\n    localparam INIT_DELAY = 2;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n    localparam INIT = 8'b00000000;\n    localparam IDLE = 8'b00000001;\n    localparam WRITE_WR = 8'b00000010;\n    localparam DLY_WR = 8'b00000100;\n    localparam READ_WR = 8'b00000110;\n    localparam DLY_READ = 8'b00001000;\n    localparam ACK_WR = 8'b00001010;\n    localparam WRITE_WO = 8'b00001100;\n    localparam DLY_WO = 8'b00010000;\n    localparam ACK_WO = 8'b00010010;\n\n    // Internal Signals\n    reg [7:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    reg [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO\n    always_comb begin\n        case(state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = INIT;\n            end\n        endcase\n    end\n\n    // FSM_SEQ\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            q <= 0;\n        else\n            q <= REQ_IN;\n    end\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            Req_internal_in <= 0;\n        else\n            Req_internal_in <= q;\n    end\n\n    // ACK_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            q1 <= 0;\n        else\n            q1 <= ACK_IN;\n    end\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            Ack_internal_in <= 0;\n        else\n            Ack_internal_in <= q1;\n    end\n\n    // COMMAND_DECODER\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else if (!DECODER_ACK) begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case(state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    STATUS <= 0;\n                    CRC_Valid <= 0;\n                    Cmd_Cnt <= 0;\n                    st_dat_t <= 0;\n                end\n                WRITE_WR: begin\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Bit_Nr > 8) begin\n                            CMD_OUT <= CMD_OUT << 1;\n                            if (Bit_Nr > 9)\n                                CRC_OUT <= CRC_OUT << 1;\n                        end else if (Bit_Nr <= 8 && Bit_Nr >= 2) begin\n                            CRC_OUT <= (CRC_OUT << 1) | cmd_dat_i;\n                            st_dat_t <= st_dat_t << 1;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Bit_Nr <= Bit_Nr + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[word_select_counter];\n                        word_select_counter <= word_select_counter + 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                WRITE_WO: begin\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Bit_Nr > 8) begin\n                            CMD_OUT <= CMD_OUT << 1;\n                            if (Bit_Nr > 9)\n                                CRC_OUT <= CRC_OUT << 1;\n                        end else if (Bit_Nr <= 8 && Bit_Nr >= 2) begin\n                            CRC_OUT <= (CRC_OUT << 1) | cmd_dat_i;\n                            st_dat_t <= st_dat_t << 1;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Bit_Nr <= Bit_Nr + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[word_select_counter];\n                        word_select_counter <= word_select_counter + 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                        CRC_IN <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n                default: begin\n                    FSM_ACK <= 1;\n                end\n            endcase\n        end\n    end\n\n    // sd_crc_7\n    sd_crc_7 sd_crc_7_module(\n        .BITVAL(cmd_dat_i),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_OUT)\n    );\n\n    // Assign outputs\n    CMD_OUT <= CMD_OUT;\n    ACK_OUT <= FSM_ACK;\n    REQ_OUT <= REQ_OUT;\n    STATUS <= STATUS;\n    cmd_oe_o <= cmd_oe_o;\n    cmd_out_o <= cmd_out_o;\n    st_dat_t <= st_dat_t;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 12, "code": "module sd_cmd_serial_host(\n    input  wire  SD_CLK_IN,\n    input  wire  RST_IN,\n    input  wire  [15:0] SETTING_IN,\n    input  wire  [39:0] CMD_IN,\n    input  wire  REQ_IN,\n    input  wire  ACK_IN,\n    input  wire  cmd_dat_i,\n    output reg   [39:0] CMD_OUT,\n    output reg   [7:0]  STATUS,\n    output reg   [1:0]  st_dat_t,\n    output reg   [1:0]  cmd_oe_o,\n    output reg   [1:0]  cmd_out_o\n);\n\n// Internal signals\nreg [9:0] state;\nreg [9:0] next_state;\nreg [2:0] Delay_Cnt;\nreg [7:0] Response_Size;\nreg [3:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg [1:0] Write_Read;\nreg [1:0] Write_Only;\nreg [5:0] word_select_counter;\nreg [1:0] CRC_RST;\nreg [6:0] CRC_IN;\nreg [6:0] CRC_VAL;\nreg [1:0] CRC_Enable;\nreg [1:0] CRC_OUT;\nreg [1:0] CRC_Check_On;\nreg [1:0] Crc_Buffering;\nreg [1:0] CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [1:0] FSM_ACK;\nreg [1:0] DECODER_ACK;\nreg [1:0] q;\nreg [1:0] Req_internal_in;\nreg [1:0] q1;\nreg [1:0] Ack_internal_in;\n\n// FSM_COMBO\nalways_comb begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY)\n                next_state = IDLE;\n            else\n                next_state = INIT;\n        end\n        IDLE: begin\n            if (Write_Read)\n                next_state = WRITE_WR;\n            else if (Write_Only)\n                next_state = WRITE_WO;\n            else\n                next_state = IDLE;\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1)\n                next_state = DLY_WR;\n            else\n                next_state = WRITE_WR;\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1)\n                next_state = DLY_WO;\n            else\n                next_state = WRITE_WO;\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i)\n                next_state = READ_WR;\n            else\n                next_state = DLY_WR;\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler)\n                next_state = ACK_WO;\n            else\n                next_state = DLY_WO;\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD)\n                next_state = DLY_READ;\n            else\n                next_state = READ_WR;\n        end\n        DLY_READ: begin\n            if (Ack_internal_in)\n                next_state = ACK_WR;\n            else\n                next_state = DLY_READ;\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN)\n        state <= INIT;\n    else\n        state <= next_state;\nend\n\n// REQ_SYNC\nreg [1:0] q;\nreg [1:0] Req_internal_in;\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN)\n        q <= 0;\n    else\n        q <= REQ_IN;\nend\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN)\n        Req_internal_in <= 0;\n    else\n        Req_internal_in <= q;\nend\n\n// ACK_SYNC\nreg [1:0] q1;\nreg [1:0] Ack_internal_in;\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN)\n        q1 <= 0;\n    else\n        q1 <= ACK_IN;\nend\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN)\n        Ack_internal_in <= 0;\n    else\n        Ack_internal_in <= q1;\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        CRC_Check_On <= SETTING_IN[7];\n        Delay_Cycler <= SETTING_IN[10:8];\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        In_Buff <= CMD_IN;\n        if (SETTING_IN[6:0] > 0) begin\n            Write_Read <= 1;\n            Write_Only <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 1;\n        end\n        DECODER_ACK <= 0;\n    end else begin\n        DECODER_ACK <= 1;\n        Write_Read <= 0;\n        Write_Only <= 0;\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                Crc_Buffering <= 0;\n                STATUS <= 0;\n                CRC_Valid <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Bit_Nr > 8) begin\n                        CMD_OUT <= CMD_OUT[39:1] << 1 | CMD_IN;\n                        if (Bit_Nr > 9)\n                            CRC_OUT <= CRC_OUT[6:1] << 1 | CRC_IN;\n                        else if (Bit_Nr <= 8 && Bit_Nr >= 2)\n                            st_dat_t <= st_dat_t[1] << 1 | (cmd_dat_i & 1);\n                        else\n                            cmd_out_o <= 1;\n                        Bit_Nr <= Bit_Nr + 1;\n                    end else begin\n                        Pre_load_CRC <= 1;\n                        CRC_OUT <= In_Buff[39:32] << 1 | In_Buff[31:24];\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Pre_load_CRC <= 1;\n                    CRC_OUT <= In_Buff[39:32] << 1 | In_Buff[31:24];\n                end\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Bit_Nr > 8) begin\n                        CMD_OUT <= CMD_OUT[39:1] << 1 | CMD_IN;\n                        if (Bit_Nr > 9)\n                            CRC_OUT <= CRC_OUT[6:1] << 1 | CRC_IN;\n                        else if (Bit_Nr <= 8 && Bit_Nr >= 2)\n                            st_dat_t <= st_dat_t[1] << 1 | (cmd_dat_i & 1);\n                        else\n                            cmd_out_o <= 1;\n                        Bit_Nr <= Bit_Nr + 1;\n                    end else begin\n                        Pre_load_CRC <= 1;\n                        CRC_OUT <= In_Buff[39:32] << 1 | In_Buff[31:24];\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Pre_load_CRC <= 1;\n                    CRC_OUT <= In_Buff[39:32] << 1 | In_Buff[31:24];\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                Delay_Cnt <= Delay_Cnt + 1;\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                CMD_OUT <= 0;\n                Crc_Buffering <= 0;\n                STATUS <= 0;\n                CRC_Valid <= 0;\n                st_dat_t <= 0;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                Delay_Cnt <= Delay_Cnt + 1;\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                CMD_OUT <= 0;\n                Crc_Buffering <= 0;\n                STATUS <= 0;\n                CRC_Valid <= 0;\n                st_dat_t <= 0;\n            end\n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[Cmd_Cnt + 39] <= cmd_dat_i;\n                    CRC_IN <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                Delay_Cnt <= Delay_Cnt + 1;\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                CMD_OUT <= 0;\n                Crc_Buffering <= 0;\n                STATUS <= 0;\n                CRC_Valid <= 0;\n                st_dat_t <= 0;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n            default: begin\n                FSM_ACK <= 1;\n            end\n        endcase\n    end\nend\n\n// sd_crc_7\nmodule sd_crc_7(\n    input  wire  BITVAL,\n    input  wire  Enable,\n    input  wire  CLK,\n    input  wire  RST,\n    output reg   [6:0] CRC\n);\nreg [6:0] CRC;\nreg [6:0] CRC_PREV;\nalways @(posedge CLK or posedge RST) begin\n    if (RST)\n        CRC <= 0;\n    else if (Enable)\n        CRC <= (CRC_PREV ^ BITVAL) ^ (CRC_PREV ^ (CRC_PREV ^ BITVAL));\n    CRC_PREV <= CRC;\nend\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 13, "code": "module sd_cmd_serial_host(\n    // Input Ports\n    input  logic SD_CLK_IN,\n    input  logic RST_IN,\n    input  logic [15:0] SETTING_IN,\n    input  logic [39:0] CMD_IN,\n    input  logic REQ_IN,\n    input  logic ACK_IN,\n    input  logic cmd_dat_i,\n\n    // Output Ports\n    output logic [39:0] CMD_OUT,\n    output logic ACK_OUT,\n    output logic REQ_OUT,\n    output logic [7:0] STATUS,\n    output logic cmd_oe_o,\n    output logic cmd_out_o,\n    output logic st_dat_t\n);\n\n    // Internal Constants and Parameters\n    localparam INIT_DELAY = 2;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n    localparam INIT = 8'b00000000;\n    localparam IDLE = 8'b00000001;\n    localparam WRITE_WR = 8'b00000010;\n    localparam DLY_WR = 8'b00000011;\n    localparam READ_WR = 8'b00000100;\n    localparam DLY_READ = 8'b00000101;\n    localparam ACK_WR = 8'b00000110;\n    localparam WRITE_WO = 8'b00000111;\n    localparam DLY_WO = 8'b00001000;\n    localparam ACK_WO = 8'b00001001;\n\n    // Internal Signals\n    reg [7:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    reg [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO\n    always_comb begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR &&!cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= Response_Size + EIGHT_PAD)\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = INIT;\n            end\n        endcase\n    end\n\n    // FSM_SEQ\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            q <= 0;\n        else\n            q <= REQ_IN;\n    end\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            Req_internal_in <= 0;\n        else\n            Req_internal_in <= q;\n    end\n\n    // ACK_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            q1 <= 0;\n        else\n            q1 <= ACK_IN;\n    end\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            Ack_internal_in <= 0;\n        else\n            Ack_internal_in <= q1;\n    end\n\n    // COMMAND_DECODER\n    always_comb begin\n        case (Req_internal_in)\n            1: begin\n                Response_Size <= SETTING_IN[6:0];\n                CRC_Check_On <= SETTING_IN[7];\n                Delay_Cycler <= SETTING_IN[10:8];\n                block_write <= SETTING_IN[11];\n                block_read <= SETTING_IN[12];\n                word_select <= SETTING_IN[14:13];\n                In_Buff <= CMD_IN;\n                if (SETTING_IN[6:0] > 0) begin\n                    Write_Read <= 1;\n                    Write_Only <= 0;\n                end else begin\n                    Write_Read <= 0;\n                    Write_Only <= 1;\n                end\n                DECODER_ACK <= 0;\n            end\n            default: begin\n                Response_Size <= 0;\n                CRC_Check_On <= 0;\n                Delay_Cycler <= 0;\n                block_write <= 0;\n                block_read <= 0;\n                word_select <= 0;\n                In_Buff <= 0;\n                Write_Read <= 0;\n                Write_Only <= 0;\n                DECODER_ACK <= 1;\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always_comb begin\n        case (state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                CMD_OUT <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS <= 0;\n                st_dat_t <= 0;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                CMD_OUT <= In_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n                STATUS <= 16'b0000_0000_0000_0001;\n                if (Cmd_Cnt == 0) begin\n                    CMD_OUT <= 0;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                end else if (Ack_internal_in) begin\n                    CMD_OUT <= 0;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                end\n                if (Cmd_Cnt < Response_Size) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_OUT <= CRC_IN;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_OUT <= CRC_IN;\n                end else begin\n                    if (CRC_IN!= CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    st_dat_t <= 2'b11;\n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n            end\n            WRITE_WO: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                CMD_OUT <= In_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n                STATUS <= 16'b0000_0000_0000_0001;\n                if (Cmd_Cnt == 0) begin\n                    CMD_OUT <= 0;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                end else if (Ack_internal_in) begin\n                    CMD_OUT <= 0;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                end\n                if (Cmd_Cnt < Response_Size) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_OUT <= CRC_IN;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_OUT <= CRC_IN;\n                end else begin\n                    if (CRC_IN!= CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    st_dat_t <= 2'b11;\n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n            end\n            DLY_WR: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS <= 16'b0000_0000_0000_0001;\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    CMD_OUT <= 0;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                end\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            DLY_WO: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS <= 16'b0000_0000_0000_0001;\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    CMD_OUT <= 0;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                end\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            READ_WR: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS <= 16'b0000_0000_0000_0001;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    CMD_OUT <= 0;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                end\n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff <= Out_Buff | (cmd_dat_i << (Cmd_Cnt * 8));\n                    CRC_IN <= cmd_dat_i;\n                    CRC_OUT <= CRC_IN;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_OUT <= CRC_IN;\n                end else begin\n                    if (CRC_IN!= CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    st_dat_t <= 2'b11;\n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n            end\n            DLY_READ: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS <= 16'b0000_0000_0000_0001;\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    CMD_OUT <= 0;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                end\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            ACK_WO: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS <= 16'b0000_0000_0000_0001;\n                ACK_OUT <= 1;\n            end\n            ACK_WR: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS <= 16'b0000_0000_0000_0001;\n                ACK_OUT <= 1;\n            end\n            default: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS <= 0;\n                st_dat_t <= 0;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 14, "code": "module sd_cmd_serial_host(\n    input  wire  SD_CLK_IN,\n    input  wire  RST_IN,\n    input  wire  [15:0] SETTING_IN,\n    input  wire  [39:0] CMD_IN,\n    input  wire  REQ_IN,\n    input  wire  ACK_IN,\n    input  wire  cmd_dat_i,\n    output reg  [39:0] CMD_OUT,\n    output reg  ACK_OUT,\n    output reg  REQ_OUT,\n    output reg  [7:0] STATUS,\n    output reg  cmd_oe_o,\n    output reg  cmd_out_o,\n    output reg  st_dat_t\n);\n\n// Internal constants and parameters\nparameter INIT_DELAY = 2; // SIM: 2, Other: 64\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\nparameter INIT = 8'b00000000;\nparameter IDLE = 8'b00000001;\nparameter WRITE_WR = 8'b00000010;\nparameter DLY_WR = 8'b00000100;\nparameter READ_WR = 8'b00000110;\nparameter DLY_READ = 8'b00001000;\nparameter ACK_WR = 8'b00001010;\nparameter WRITE_WO = 8'b00001100;\nparameter DLY_WO = 8'b00010000;\nparameter ACK_WO = 8'b00010010;\n\n// Internal signals\nreg [7:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nreg [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// FSM_COMBO\nalways_comb begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) next_state = IDLE;\n            else next_state = INIT;\n        end\n        IDLE: begin\n            if (Write_Read) next_state = WRITE_WR;\n            else if (Write_Only) next_state = WRITE_WO;\n            else next_state = IDLE;\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) next_state = DLY_WR;\n            else next_state = WRITE_WR;\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) next_state = DLY_WO;\n            else next_state = WRITE_WO;\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR &&!cmd_dat_i) next_state = READ_WR;\n            else next_state = DLY_WR;\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) next_state = ACK_WO;\n            else next_state = DLY_WO;\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) next_state = DLY_READ;\n            else next_state = READ_WR;\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) next_state = ACK_WR;\n            else next_state = DLY_READ;\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ\nalways_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) state <= INIT;\n    else state <= next_state;\nend\n\n// REQ_SYNC\nalways_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Req_internal_in <= 0;\n        q <= 0;\n    end\n    else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC\nalways_ff @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Ack_internal_in <= 0;\n        q1 <= 0;\n    end\n    else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways_comb begin\n    case (SETTING_IN[15])\n        1'b0: begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end\n            else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end\n        default: begin\n            Response_Size <= 0;\n            CRC_Check_On <= 0;\n            Delay_Cycler <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n            In_Buff <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 0;\n        end\n    endcase\nend\n\n// FSM_OUT\nalways_comb begin\n    case (state)\n        INIT: begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            st_dat_t <= 0;\n        end\n        IDLE: begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 0;\n            cmd_out_o <= 0;\n            st_dat_t <= 0;\n        end\n        WRITE_WR: begin\n            CMD_OUT <= In_Buff;\n            ACK_OUT <= 0;\n            REQ_OUT <= 1;\n            STATUS <= 16'b0000_0000_0000_0001;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            st_dat_t <= 0;\n            if (Cmd_Cnt == 0) begin\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                CRC_OUT <= 0;\n                CRC_Valid <= 0;\n                Crc_Buffering <= 1;\n                word_select_counter <= 0;\n                if (Bit_Nr > 8) begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    if (Bit_Nr > 9) begin\n                        CRC_OUT <= CRC_OUT;\n                        CRC_Valid <= 1;\n                    end\n                    else begin\n                        CRC_OUT <= CRC_OUT;\n                        CRC_Valid <= 0;\n                    end\n                end\n                else if (Bit_Nr <= 8 && Bit_Nr >= 2) begin\n                    CRC_OUT <= CRC_OUT;\n                    CRC_Valid <= 1;\n                    st_dat_t <= 0;\n                end\n                else begin\n                    cmd_out_o <= 1;\n                    cmd_oe_o <= 1;\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            else if (Ack_internal_in) begin\n                REQ_OUT <= 0;\n            end\n            CRC_IN <= 0;\n            CRC_VAL <= 0;\n            CRC_Enable <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_Valid <= 0;\n            Crc_Buffering <= 0;\n            word_select_counter <= 0;\n        end\n        WRITE_WO: begin\n            CMD_OUT <= In_Buff;\n            ACK_OUT <= 0;\n            REQ_OUT <= 1;\n            STATUS <= 16'b0000_0000_0000_0010;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            st_dat_t <= 0;\n            if (Cmd_Cnt == 0) begin\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                CRC_OUT <= 0;\n                CRC_Valid <= 0;\n                Crc_Buffering <= 1;\n                word_select_counter <= 0;\n                if (Bit_Nr > 8) begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    if (Bit_Nr > 9) begin\n                        CRC_OUT <= CRC_OUT;\n                        CRC_Valid <= 1;\n                    end\n                    else begin\n                        CRC_OUT <= CRC_OUT;\n                        CRC_Valid <= 0;\n                    end\n                end\n                else if (Bit_Nr <= 8 && Bit_Nr >= 2) begin\n                    CRC_OUT <= CRC_OUT;\n                    CRC_Valid <= 1;\n                    st_dat_t <= 0;\n                end\n                else begin\n                    cmd_out_o <= 1;\n                    cmd_oe_o <= 1;\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            else if (Ack_internal_in) begin\n                REQ_OUT <= 0;\n            end\n            CRC_IN <= 0;\n            CRC_VAL <= 0;\n            CRC_Enable <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_Valid <= 0;\n            Crc_Buffering <= 0;\n            word_select_counter <= 0;\n        end\n        DLY_WR: begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 0;\n            cmd_out_o <= 0;\n            st_dat_t <= 0;\n            if (Delay_Cnt == 0) begin\n                STATUS <= 8'b0000_0001;\n                REQ_OUT <= 1;\n            end\n            else if (Ack_internal_in) begin\n                REQ_OUT <= 0;\n            end\n            Delay_Cnt <= Delay_Cnt + 1;\n        end\n        DLY_WO: begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 0;\n            cmd_out_o <= 0;\n            st_dat_t <= 0;\n            if (Delay_Cnt == 0) begin\n                STATUS <= 8'b0001_0000;\n                STATUS[5] <= CRC_Valid;\n                STATUS[6] <= 1;\n                REQ_OUT <= 1;\n            end\n            else if (Ack_internal_in) begin\n                REQ_OUT <= 0;\n            end\n            Delay_Cnt <= Delay_Cnt + 1;\n        end\n        READ_WR: begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 0;\n            cmd_out_o <= 0;\n            st_dat_t <= 0;\n            if (Cmd_Cnt == 1) begin\n                STATUS <= 8'b0001_0010;\n                REQ_OUT <= 1;\n                Out_Buff[39] <= 0;\n            end\n            else if (Ack_internal_in) begin\n                REQ_OUT <= 0;\n            end\n            if (Cmd_Cnt < Response_Size) begin\n                Out_Buff <= Out_Buff;\n                CRC_IN <= cmd_dat_i;\n                CRC_VAL <= CRC_VAL;\n                CRC_Enable <= 1;\n                CRC_RST <= 0;\n                CRC_OUT <= CRC_OUT;\n                CRC_Valid <= CRC_Valid;\n                Crc_Buffering <= Crc_Buffering;\n                word_select_counter <= word_select_counter;\n            end\n            else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                CRC_IN <= cmd_dat_i;\n                CRC_VAL <= CRC_VAL;\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                CRC_OUT <= CRC_OUT;\n                CRC_Valid <= CRC_Valid;\n                Crc_Buffering <= Crc_Buffering;\n                word_select_counter <= word_select_counter;\n            end\n            else begin\n                if ((CRC_IN!= CRC_VAL) && CRC_Check_On) begin\n                    CRC_Valid <= 0;\n                    CRC_Enable <= 0;\n                end\n                else begin\n                    CRC_Valid <= 1;\n                    CRC_Enable <= 0;\n                end\n                Out_Buff <= Out_Buff;\n                st_dat_t <= 0;\n                if (block_read && block_write) begin\n                    st_dat_t <= 2'b11;\n                end\n                else if (block_write) begin\n                    st_dat_t <= 2'b01;\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n        end\n        DLY_READ: begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 0;\n            cmd_out_o <= 0;\n            st_dat_t <= 0;\n            if (Delay_Cnt == 0) begin\n                STATUS <= 8'b0001_0110;\n                STATUS[5] <= CRC_Valid;\n                STATUS[6] <= 1;\n                REQ_OUT <= 1;\n            end\n            else if (Ack_internal_in) begin\n                REQ_OUT <= 0;\n            end\n            Delay_Cnt <= Delay_Cnt + 1;\n        end\n        ACK_WO: begin\n            FSM_ACK <= 1;\n        end\n        ACK_WR: begin\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n        end\n        default: begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 0;\n            cmd_out_o <= 0;\n            st_dat_t <= 0;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 13, "code": "module sd_data_master(\n    input  wire clk,\n    input  wire rst,\n    input  wire dat_in_tx,\n    input  wire free_tx_bd,\n    input  wire ack_i_s_tx,\n    input  wire dat_in_rx,\n    input  wire free_rx_bd,\n    input  wire ack_i_s_rx,\n    input  wire cmd_busy,\n    input  wire we_ack,\n    input  wire cmd_tsf_err,\n    input  wire card_status,\n    input  wire tx_empt,\n    input  wire tx_full,\n    input  wire rx_full,\n    input  wire busy_n,\n    input  wire transm_complete,\n    input  wire crc_ok,\n    input  wire Dat_Int_Status_rst,\n    input  wire transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg cmd_arg,\n    output reg cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg sys_adr,\n    output reg ack_transfer,\n    output reg Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Define the state register\nreg [8:0] state;\nreg [8:0] next_state;\n\n// Define the internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg resend_try_cnt;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [1:0] bd_cnt;\nreg [31:0] sys_adr;\nreg [31:0] cmd_arg;\nreg [15:0] cmd_set;\nreg CIDAT;\nreg [7:0] Dat_Int_Status;\n\n// Define the parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\nparameter READ_CYCLE = 2;\nparameter BD_EMPTY = 1;\n\n// Define the state transition table\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end else begin\n                    next_state = GET_TX_BD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end else begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state = RECIVE_CMD;\n                end else begin\n                    next_state = SEND_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state = SEND_CMD;\n                end else begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state = IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state = STOP;\n                end else begin\n                    next_state = DATA_TRANSFER;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = STOP_SEND;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\nend\n\n// Define the output signals\nassign re_s_tx = (state == GET_TX_BD) ? 1 : 0;\nassign a_cmp_tx = (state == GET_TX_BD) ? 1 : 0;\nassign re_s_rx = (state == GET_RX_BD) ? 1 : 0;\nassign a_cmp_rx = (state == GET_RX_BD) ? 1 : 0;\nassign we_req = (state == SEND_CMD) ? 1 : 0;\nassign d_write = (state == SEND_CMD) ? 1 : 0;\nassign d_read = (state == SEND_CMD) ? 1 : 0;\nassign cmd_arg = cmd_arg;\nassign cmd_set = cmd_set;\nassign start_tx_fifo = (state == SEND_CMD) ? 1 : 0;\nassign start_rx_fifo = (state == SEND_CMD) ? 1 : 0;\nassign sys_adr = sys_adr;\nassign ack_transfer = (state == DATA_TRANSFER) ? 1 : 0;\nassign CIDAT = CIDAT;\nassign Dat_Int_Status = Dat_Int_Status;\n\n// Define the internal signals\nalways @(posedge clk) begin\n    if (rst) begin\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            GET_TX_BD: begin\n                if (ack_i_s_tx == 1) begin\n                    re_s_tx <= 1;\n                    dat_in_tx <= dat_in_tx;\n                    bd_cnt <= bd_cnt + 1;\n                end\n            end\n            GET_RX_BD: begin\n                if (ack_i_s_rx == 1) begin\n                    re_s_rx <= 1;\n                    dat_in_rx <= dat_in_rx;\n                    bd_cnt <= bd_cnt + 1;\n                end\n            end\n            SEND_CMD: begin\n                if (we_ack == 1) begin\n                    send_done <= 1;\n                end\n            end\n            RECIVE_CMD: begin\n                if (cmd_busy == 0) begin\n                    rec_done <= 1;\n                end else if (cmd_tsf_err == 1) begin\n                    rec_failed <= 1;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete == 1) begin\n                    trans_done <= 1;\n                end else if (crc_ok == 0) begin\n                    trans_failed <= 1;\n                end\n            end\n            STOP: begin\n                cmd_set <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n            end\n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status <= Dat_Int_Status | 1'b1;\n                end else if (we_ack == 1) begin\n                    send_done <= 1;\n                end\n            end\n            default: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n        endcase\n    end\nend\n\n// Define the output signals\nassign CIDAT = (state == DATA_TRANSFER) ? 1 : 0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 19, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // External signals\n    parameter SD_BUS_W = 4;\n    parameter BIT_BLOCK = 512;\n    parameter CRC_OFF = 16;\n    parameter BIT_BLOCK_REC = 512;\n    parameter BIT_CRC_CYCLE = 16;\n    parameter LITLE_ENDIAN = 0;\n    parameter BIG_ENDIAN = 1;\n    parameter SD_BUS_WIDTH_1 = 1;\n    parameter SD_BUS_WIDTH_4 = 4;\n\n    // Sub-modules\n    sd_crc_16 crc_16_gen(\n       .BITVAL(crc_in),\n       .Enable(crc_en),\n       .CLK(sd_clk),\n       .RST(crc_rst),\n       .CRC(crc_out)\n    );\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always_comb begin\n        case (state)\n            6'd0: // IDLE\n                next_state = (start_dat == 2'b01)? 6'd1 : (start_dat == 2'b10)? 6'd2 : 6'd0;\n            6'd1: // WRITE_DAT\n                next_state = (transf_cnt == SD_BUS_W)? 6'd2 : 6'd1;\n            6'd2: // WRITE_CRC\n                next_state = (crc_status == 3'b111)? 6'd3 : 6'd2;\n            6'd3: // WRITE_BUSY\n                next_state = (busy_int == 1'b0)? 6'd0 : 6'd3;\n            6'd4: // READ_WAIT\n                next_state = (DAT_dat_i[0] == 1'b0)? 6'd5 : 6'd4;\n            6'd5: // READ_DAT\n                next_state = (transf_cnt == SD_BUS_W)? 6'd0 : 6'd5;\n            default: // Default\n                next_state = 6'd0;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            state <= 6'd0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always_comb begin\n        case (state)\n            6'd0: // IDLE\n                begin\n                    DAT_oe_o <= 1'b0;\n                    DAT_dat_o <= 0;\n                    rd <= 1'b0;\n                    we <= 1'b0;\n                    transm_complete <= 1'b0;\n                    crc_ok <= 1'b0;\n                    busy_n <= 1'b1;\n                    write_buf_0 <= 0;\n                    write_buf_1 <= 0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    crc_status <= 3'b000;\n                    crc_s <= 3'b000;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                    sd_data_out <= 0;\n                end\n            6'd1: // WRITE_DAT\n                begin\n                    DAT_oe_o <= 1'b1;\n                    DAT_dat_o <= temp_in;\n                    rd <= 1'b0;\n                    we <= 1'b1;\n                    transm_complete <= 1'b0;\n                    crc_ok <= 1'b0;\n                    busy_n <= 1'b0;\n                    write_buf_0 <= data_in;\n                    write_buf_1 <= 0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    crc_status <= 3'b000;\n                    crc_s <= 3'b000;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                    sd_data_out <= 0;\n                end\n            6'd2: // WRITE_CRC\n                begin\n                    DAT_oe_o <= 1'b1;\n                    DAT_dat_o <= crc_out;\n                    rd <= 1'b0;\n                    we <= 1'b1;\n                    transm_complete <= 1'b0;\n                    crc_ok <= 1'b0;\n                    busy_n <= 1'b0;\n                    write_buf_0 <= 0;\n                    write_buf_1 <= 0;\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    transf_cnt <= 11'd0;\n                    crc_status <= 3'b000;\n                    crc_s <= 3'b000;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                    sd_data_out <= 0;\n                end\n            6'd3: // WRITE_BUSY\n                begin\n                    DAT_oe_o <= 1'b1;\n                    DAT_dat_o <= 0;\n                    rd <= 1'b0;\n                    we <= 1'b1;\n                    transm_complete <= 1'b0;\n                    crc_ok <= 1'b0;\n                    busy_n <= 1'b0;\n                    write_buf_0 <= 0;\n                    write_buf_1 <= 0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    crc_status <= 3'b000;\n                    crc_s <= 3'b000;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                    sd_data_out <= 0;\n                end\n            6'd4: // READ_WAIT\n                begin\n                    DAT_oe_o <= 1'b0;\n                    DAT_dat_o <= 0;\n                    rd <= 1'b1;\n                    we <= 1'b0;\n                    transm_complete <= 1'b0;\n                    crc_ok <= 1'b0;\n                    busy_n <= 1'b1;\n                    write_buf_0 <= 0;\n                    write_buf_1 <= 0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    crc_status <= 3'b000;\n                    crc_s <= 3'b000;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                    sd_data_out <= 0;\n                end\n            6'd5: // READ_DAT\n                begin\n                    DAT_oe_o <= 1'b0;\n                    DAT_dat_o <= DAR_dat_i;\n                    rd <= 1'b1;\n                    we <= 1'b0;\n                    transm_complete <= 1'b0;\n                    crc_ok <= 1'b0;\n                    busy_n <= 1'b0;\n                    write_buf_0 <= 0;\n                    write_buf_1 <= 0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    crc_status <= 3'b000;\n                    crc_s <= 3'b000;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                    sd_data_out <= 0;\n                end\n            default: // Default\n                begin\n                    DAT_oe_o <= 1'b0;\n                    DAT_dat_o <= 0;\n                    rd <= 1'b0;\n                    we <= 1'b0;\n                    transm_complete <= 1'b0;\n                    crc_ok <= 1'b0;\n                    busy_n <= 1'b1;\n                    write_buf_0 <= 0;\n                    write_buf_1 <= 0;\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b1;\n                    transf_cnt <= 11'd0;\n                    crc_status <= 3'b000;\n                    crc_s <= 3'b000;\n                    data_send_index <= 3'd0;\n                    out_buff_ptr <= 2'd0;\n                    in_buff_ptr <= 2'd0;\n                    sd_data_out <= 0;\n                end\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else begin\n            if (state == 6'd4 && DAT_dat_i[0] == 1'b0) begin\n                q_start_bit <= 1'b0;\n            end else begin\n                q_start_bit <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 17, "code": "module sdc_controller(\n    // Wishbone Slave Interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC/MMC Interface\n    input  wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input  wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input  wire sd_clk_i_pad,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input  wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal Registers\n    reg [15:0] status_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [7:0]  Bd_isr_reg;\n    reg [7:0]  Bd_isr_enable_reg;\n    reg [15:0] Bd_status_reg;\n    reg [31:0] argument_reg;\n    reg [15:0] cmd_setting_reg;\n    reg [31:0] cmd_resp_1;\n    reg [7:0]  software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0]  clock_divider;\n\n    // sd_controller_wb\n    sd_controller_wb sd_controller_wb(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // sd_clock_divider\n    sd_clock_divider sd_clock_divider(\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // sd_cmd_master\n    sd_cmd_master sd_cmd_master(\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(cmd_setting_reg),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n\n    // sd_cmd_serial_host\n    sd_cmd_serial_host sd_cmd_serial_host(\n        .SD_CLK_IN(sd_clk_i_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(cmd_in),\n        .REQ_IN(req_in),\n        .ACK_IN(ack_in),\n        .cmd_dat_i(cmd_dat_i),\n        .CMD_OUT(cmd_out),\n        .ACK_OUT(ack_out),\n        .REQ_OUT(req_out),\n        .STATUS(serial_status),\n        .cmd_oe_o(cmd_oe_o),\n        .cmd_out_o(cmd_out_o),\n        .st_dat_t(st_dat_t)\n    );\n\n    // sd_data_master\n    sd_data_master sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(cmd_tsf_err),\n        .card_status(card_status),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(Dat_Int_Status_rst),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n\n    // sd_data_serial_host\n    sd_data_serial_host sd_data_serial_host(\n        .sd_clk(sd_clk_i_pad),\n        .rst(wb_rst_i),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(DAT_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(DAT_oe_o),\n        .DAT_dat_o(DAT_dat_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n\n    // rx_bd/tx_bd\n    rx_bd rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_o_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s)\n    );\n\n    // sd_fifo_tx_filler\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_o(dat_o),\n        .rd(rd),\n        .empty(empty),\n        .fe(fe)\n    );\n\n    // sd_fifo_rx_filler\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_i(dat_i),\n        .wr(wr),\n        .full(full)\n    );\n\n    // Master Wishbone Interface Control\n    always_comb begin\n        if (start_tx_fifo) begin\n            m_wb_cyc_o = 1'b1;\n            m_wb_stb_o = 1'b1;\n            m_wb_cti_o = 3'b010;\n            m_wb_bte_o = 2'b10;\n            m_wb_we_o = 1'b1;\n            m_wb_adr_o = m_wb_adr_o;\n        end\n        else if (start_rx_fifo) begin\n            m_wb_cyc_o = 1'b1;\n            m_wb_stb_o = 1'b1;\n            m_wb_cti_o = 3'b010;\n            m_wb_bte_o = 2'b10;\n            m_wb_we_o = 1'b0;\n            m_wb_adr_o = m_wb_adr_o;\n        end\n        else begin\n            m_wb_cyc_o = 1'b0;\n            m_wb_stb_o = 1'b0;\n            m_wb_cti_o = 3'b000;\n            m_wb_bte_o = 2'b00;\n            m_wb_we_o = 1'b0;\n            m_wb_adr_o = m_wb_adr_o;\n        end\n    end\n\n    // Register Update\n    always_comb begin\n        if (cmd_int_busy) begin\n            status_reg[0] = 1'b1;\n        end\n        else begin\n            status_reg[0] = STATUS_REG[0];\n        end\n        status_reg[15:1] = STATUS_REG[15:1];\n        status_reg[1] = cidat_w;\n        normal_int_status_reg = NORMAL_INT_REG;\n        error_int_status_reg = ERR_INT_REG;\n        Bd_isr_reg = Dat_Int_Status;\n        Bd_isr_enable_reg = Dat_Int_Status;\n        bd_isr_reset = 1'b1;\n        normal_isr_reset = 1'b1;\n        error_isr_reset = 1'b1;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 19, "code": "module sd_cmd_master(\n    input  wire   clk_pad_io,\n    input  wire   rst_pad_i,\n    input  wire   new_cmd,\n    input  wire   data_write,\n    input  wire   data_read,\n    input  wire   arg_reg [31:0],\n    input  wire   cmd_set_reg [13:0],\n    input  wire   timeout_reg [15:0],\n    output wire   status_reg [15:0],\n    output wire   resp_1_reg [31:0],\n    output wire   err_int_reg [3:0],\n    output wire   normal_int_reg [15:0],\n    input  wire   err_int_rst,\n    input  wire   normal_int_rst,\n    output wire   settings [15:0],\n    output wire   go_idle_o,\n    output wire   cmd_out [39:0],\n    output wire   req_out,\n    output wire   ack_out,\n    input  wire   req_in,\n    input  wire   ack_in,\n    input  wire   cmd_in [39:0],\n    input  wire   serial_status [7:0],\n    input  wire   card_detect\n);\n\n// Debounce Logic\nreg [3:0] debounce;\nreg card_present;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        debounce <= 0;\n        card_present <= 0;\n    end\n    else begin\n        if (!card_detect) begin\n            if (debounce < 4'b1111) debounce <= debounce + 1;\n            else card_present <= 1;\n        end\n        else debounce <= 0;\n    end\nend\n\n// Request and Acknowledge Synchronizers\nreg req_q;\nreg ack_q;\nreg req_in_int;\nreg ack_in_int;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        req_q <= 0;\n        ack_q <= 0;\n    end\n    else begin\n        req_q <= req_in;\n        ack_q <= ack_in;\n    end\nend\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        req_in_int <= 0;\n        ack_in_int <= 0;\n    end\n    else begin\n        req_in_int <= req_q;\n        ack_in_int <= ack_q;\n    end\nend\n\n// Finite State Machine (FSM)\nreg [2:0] state;\nreg [2:0] next_state;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) state <= 3'b001;\n    else state <= next_state;\nend\n\nalways_comb begin\n    case (state)\n        3'b001: begin\n            if (new_cmd) next_state = 3'b010;\n            else next_state = 3'b001;\n        end\n        3'b010: begin\n            if (ack_in_int) next_state = 3'b100;\n            else next_state = 3'b010;\n        end\n        3'b100: begin\n            if (complete) next_state = 3'b001;\n            else next_state = 3'b100;\n        end\n        default: next_state = 3'b001;\n    endcase\nend\n\n// FSM State operation\nreg [15:0] status;\nreg [15:0] settings;\nreg [39:0] cmd_out;\nreg [7:0] response_size;\nreg [15:0] resp_1_reg;\nreg [3:0] err_int_reg;\nreg [15:0] normal_int_reg;\nreg [15:0] watchdog_cnt;\nreg [3:0] crc_check_enable;\nreg [3:0] index_check_enable;\nreg [3:0] complete;\nreg [3:0] crc_valid;\nreg [3:0] dat_ava;\nreg [3:0] EI;\nreg [3:0] CC;\nreg [3:0] CCRCE;\nreg [3:0] CIE;\nreg [3:0] CTE;\nreg [3:0] RTS;\nreg [3:0] WORD_SELECT;\nreg [3:0] data_read;\nreg [3:0] data_write;\nreg [3:0] CRCE;\nreg [3:0] CICE;\nreg [3:0] cmd_out_int;\nreg [3:0] settings_int;\nreg [7:0] serial_status_int;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        status <= 0;\n        settings <= 0;\n        cmd_out <= 0;\n        response_size <= 0;\n        resp_1_reg <= 0;\n        err_int_reg <= 0;\n        normal_int_reg <= 0;\n        watchdog_cnt <= 0;\n        crc_check_enable <= 0;\n        index_check_enable <= 0;\n        complete <= 0;\n        crc_valid <= 0;\n        dat_ava <= 0;\n        EI <= 0;\n        CC <= 0;\n        CCRCE <= 0;\n        CIE <= 0;\n        CTE <= 0;\n        RTS <= 0;\n        WORD_SELECT <= 0;\n        data_read <= 0;\n        data_write <= 0;\n        CRCE <= 0;\n        CICE <= 0;\n        cmd_out_int <= 0;\n        settings_int <= 0;\n        serial_status_int <= 0;\n    end\n    else begin\n        case (state)\n            3'b001: begin\n                // IDLE State\n                go_idle_o <= 0;\n                req_out <= 0;\n                ack_out <= 0;\n                CICMD <= 0;\n                if (req_in_int) begin\n                    status <= serial_status_int;\n                    ack_out <= 1;\n                end\n            end\n            3'b010: begin\n                // SETUP State\n                NORMAL_INT_REG <= 0;\n                ERR_INT_REG <= 0;\n                index_check_enable <= CICE;\n                crc_check_enable <= CRCE;\n                response_size <= 0;\n                if (RTS == 2'b10 || RTS == 2'b11) response_size <= 7'b0101000;\n                else if (RTS == 2'b01) response_size <= 7'b1111111;\n                else response_size <= 0;\n                cmd_out <= {2'b01, CMDI, ARG_REG};\n                settings <= {WORD_SELECT, data_read, data_write, 3'b111, CRCE, response_size};\n                watchdog_cnt <= 0;\n                CICMD <= 1;\n            end\n            3'b100: begin\n                // EXECUTE State\n                if (watchdog_cnt > timeout_reg) begin\n                    CTE <= 1;\n                    EI <= 1;\n                    if (ack_in) complete <= 1;\n                    go_idle_o <= 1;\n                end\n                if (ack_in_int) begin\n                    req_out <= 1;\n                end\n                else if (req_in_int) begin\n                    status <= serial_status_int;\n                    ack_out <= 1;\n                    if (dat_ava) begin\n                        complete <= 1;\n                        EI <= 0;\n                        if (crc_check_enable && ~crc_valid) begin\n                            CCRCE <= 1;\n                            EI <= 1;\n                        end\n                        if (index_check_enable && (cmd_out_int != cmd_in[37:32])) begin\n                            CIE <= 1;\n                            EI <= 1;\n                        end\n                        CC <= 1;\n                        if (response_size != 0) resp_1_reg <= cmd_in[31:0];\n                    end\n                end\n                watchdog_cnt <= watchdog_cnt + 1;\n            end\n        endcase\n    end\nend\n\n// Output Logic\nassign settings = settings_int;\nassign cmd_out = cmd_out_int;\nassign resp_1_reg = resp_1_reg;\nassign err_int_reg = {EI, CCRCE, CIE, CTE};\nassign normal_int_reg = {EI, CC};\nassign status_reg = status;\nassign go_idle_o = go_idle_o;\nassign req_out = req_out;\nassign ack_out = ack_out;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 13, "code": "module sd_controller_wb(\n    // Wishbone Slave Interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire         wb_we_i,\n    input  wire         wb_cyc_i,\n    input  wire         wb_stb_i,\n    output wire         wb_ack_o,\n\n    // Master Interface\n    output wire         we_m_tx_bd,\n    output wire         we_m_rx_bd,\n    output wire         new_cmd,\n    output wire         we_ack,\n    output wire         int_ack,\n    output wire         cmd_int_busy,\n    output wire         int_busy,\n\n    // Data Master Interface\n    input  wire         write_req_s,\n    input  wire [15:0]  cmd_set_s,\n    input  wire [31:0]  cmd_arg_s,\n    output wire [31:0]  argument_reg,\n    output wire [15:0]  cmd_setting_reg,\n    input  wire [15:0]  status_reg,\n    input  wire [31:0]  cmd_resp_1,\n    output wire [7:0]   software_reset_reg,\n    output wire [15:0]  time_out_reg,\n    input  wire [15:0]  normal_int_status_reg,\n    input  wire [15:0]  error_int_status_reg,\n    output wire [15:0]  normal_int_signal_enable_reg,\n    output wire [15:0]  error_int_signal_enable_reg,\n    output wire [7:0]   clock_divider,\n    input  wire [15:0]  Bd_Status_reg,\n    input  wire [7:0]   Bd_isr_reg,\n    output wire [7:0]   Bd_isr_enable_reg,\n    output wire         Bd_isr_reset,\n    output wire         normal_isr_reset,\n    output wire         error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Configuration Registers\n    reg [31:0] argument_reg;\n    reg [15:0] cmd_setting_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [7:0]  software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0]  clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [7:0]  Bd_isr_reg;\n    reg [7:0]  Bd_isr_enable_reg;\n    reg        Bd_isr_reset;\n    reg        normal_isr_reset;\n    reg        error_isr_reset;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Control Logic\n    wire cmd_int_busy;\n    wire int_busy;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n\n    // Register Write\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            argument_reg <= 32'd0;\n            cmd_setting_reg <= 16'd0;\n            status_reg <= 16'd0;\n            cmd_resp_1 <= 32'd0;\n            software_reset_reg <= 8'd0;\n            time_out_reg <= 16'd0;\n            normal_int_status_reg <= 16'd0;\n            error_int_status_reg <= 16'd0;\n            normal_int_signal_enable_reg <= 16'd0;\n            error_int_signal_enable_reg <= 16'd0;\n            clock_divider <= 8'd0;\n            Bd_Status_reg <= 16'd0;\n            Bd_isr_reg <= 8'd0;\n            Bd_isr_enable_reg <= 8'd0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= RAM_MEM_WIDTH'd0;\n            dat_in_m_rx_bd <= RAM_MEM_WIDTH'd0;\n        end else begin\n            if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n                case (wb_adr_i)\n                    4'h0: argument_reg <= wb_dat_i;\n                    4'h4: cmd_setting_reg <= wb_dat_i;\n                    4'h8: status_reg <= wb_dat_i;\n                    4'hc: cmd_resp_1 <= wb_dat_i;\n                    4'h1c: software_reset_reg <= wb_dat_i;\n                    4'h28: time_out_reg <= wb_dat_i;\n                    4'h30: normal_int_status_reg <= wb_dat_i;\n                    4'h34: error_int_status_reg <= wb_dat_i;\n                    4'h38: normal_int_signal_enable_reg <= wb_dat_i;\n                    4'h3c: error_int_signal_enable_reg <= wb_dat_i;\n                    4'h48: clock_divider <= wb_dat_i;\n                    4'h50: Bd_Status_reg <= wb_dat_i;\n                    4'h54: Bd_isr_reg <= wb_dat_i;\n                    4'h58: Bd_isr_enable_reg <= wb_dat_i;\n                    4'h60: dat_in_m_tx_bd <= wb_dat_i;\n                    4'h80: dat_in_m_rx_bd <= wb_dat_i;\n                    default: ;\n                endcase\n            end\n        end\n    end\n\n    // Register Read\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            wb_dat_o <= 32'd0;\n        end else begin\n            if (wb_stb_i && wb_cyc_i) begin\n                case (wb_adr_i)\n                    4'h0: wb_dat_o <= argument_reg;\n                    4'h4: wb_dat_o <= cmd_setting_reg;\n                    4'h8: wb_dat_o <= status_reg;\n                    4'hc: wb_dat_o <= cmd_resp_1;\n                    4'h1c: wb_dat_o <= software_reset_reg;\n                    4'h28: wb_dat_o <= time_out_reg;\n                    4'h30: wb_dat_o <= normal_int_status_reg;\n                    4'h34: wb_dat_o <= error_int_status_reg;\n                    4'h38: wb_dat_o <= normal_int_signal_enable_reg;\n                    4'h3c: wb_dat_o <= error_int_signal_enable_reg;\n                    4'h48: wb_dat_o <= clock_divider;\n                    4'h50: wb_dat_o <= Bd_Status_reg;\n                    4'h54: wb_dat_o <= Bd_isr_reg;\n                    4'h58: wb_dat_o <= Bd_isr_enable_reg;\n                    4'h60: wb_dat_o <= dat_in_m_tx_bd;\n                    4'h80: wb_dat_o <= dat_in_m_rx_bd;\n                    default: wb_dat_o <= 32'd0;\n                endcase\n            end\n        end\n    end\n\n    // Control Logic\n    assign cmd_int_busy = (write_req_s && (cmd_arg_s!= 16'd0 || cmd_set_s!= 16'd0));\n    assign int_busy = (wb_adr_i == 4'h4);\n    assign new_cmd = (cmd_arg_s!= 16'd0);\n    assign we_ack = write_req_s;\n    assign int_ack = (int_ack_default && (wb_adr_i == 4'h60 || wb_adr_i == 4'h80));\n    assign we_m_tx_bd = (wb_adr_i == 4'h60);\n    assign we_m_rx_bd = (wb_adr_i == 4'h80);\n\n    // Default values\n    reg int_ack_default;\n    initial begin\n        int_ack_default = 1'b1;\n    end\n\n    // Clock Divider\n    reg [7:0] clk_divider;\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            clk_divider <= 8'd0;\n        end else begin\n            clk_divider <= clk_divider + 1;\n        end\n    end\n\n    // BD Buffer Status\n    reg [15:0] Bd_Status_reg;\n    reg [7:0]  Bd_isr_reg;\n    reg [7:0]  Bd_isr_enable_reg;\n    reg        Bd_isr_reset;\n    reg        normal_isr_reset;\n    reg        error_isr_reset;\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            Bd_Status_reg <= 16'd0;\n            Bd_isr_reg <= 8'd0;\n            Bd_isr_enable_reg <= 8'd0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n        end else begin\n            if (wb_adr_i == 4'h50) begin\n                Bd_Status_reg <= wb_dat_i;\n            end else if (wb_adr_i == 4'h54) begin\n                Bd_isr_reg <= wb_dat_i;\n            end else if (wb_adr_i == 4'h58) begin\n                Bd_isr_enable_reg <= wb_dat_i;\n            end else if (wb_adr_i == 4'h5c) begin\n                Bd_isr_reset <= wb_dat_i[0];\n                normal_isr_reset <= wb_dat_i[1];\n                error_isr_reset <= wb_dat_i[2];\n            end\n        end\n    end\n\n    // Data Interrupt Status\n    reg [7:0] dat_int_status;\n    reg [7:0] dat_int_enable;\n    reg        dat_int_reset;\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            dat_int_status <= 8'd0;\n            dat_int_enable <= 8'd0;\n            dat_int_reset <= 1'b0;\n        end else begin\n            if (wb_adr_i == 4'h54) begin\n                dat_int_status <= wb_dat_i;\n            end else if (wb_adr_i == 4'h58) begin\n                dat_int_enable <= wb_dat_i;\n            end else if (wb_adr_i == 4'h5c) begin\n                dat_int_reset <= wb_dat_i[0];\n            end\n        end\n    end\n\n    // Data Interrupt Enable\n    assign dat_int_enable = (dat_int_enable & ~dat_int_status);\n\n    // BD RX and TX\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            dat_in_m_tx_bd <= RAM_MEM_WIDTH'd0;\n            dat_in_m_rx_bd <= RAM_MEM_WIDTH'd0;\n        end else begin\n            if (wb_adr_i == 4'h60) begin\n                dat_in_m_tx_bd <= wb_dat_i;\n            end else if (wb_adr_i == 4'h80) begin\n                dat_in_m_rx_bd <= wb_dat_i;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 14, "code": "module sd_controller_wb(\n    // WISHBONE Slave Interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n    // Master Interface\n    output wire we_m_tx_bd,\n    output wire we_m_rx_bd,\n    output wire new_cmd,\n    output wire we_ack,\n    output wire int_ack,\n    output wire cmd_int_busy,\n    output wire int_busy,\n    input  wire write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0] clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0] Bd_isr_reg,\n    output wire [7:0] Bd_isr_enable_reg,\n    output wire Bd_isr_reset,\n    output wire normal_isr_reset,\n    output wire error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Define the width of the RAM\n    localparam RAM_MEM_WIDTH = 32;\n\n    // Define the width of the BD buffer\n    localparam BD_WIDTH = 8;\n\n    // Define the size of the BD buffer\n    localparam BD_SIZE = 255;\n\n    // Define the width of the block RAM\n    localparam RAM_MEM_WIDTH_16 = 16;\n\n    // Define the maximum number of resend attempts\n    localparam RESEND_MAX_CNT = 255;\n\n    // Define the memory address offset between 2 words\n    localparam MEM_OFFSET = 0;\n\n    // Define the reset clock divider\n    localparam RESET_CLK_DIV = 255;\n\n    // Define the clock divider\n    localparam CLK_DIV = 0;\n\n    // Define the SD clock bus clock\n    localparam SD_CLK_BUS_CLK = 0;\n\n    // Define the SD clock separate\n    localparam SD_CLK_SEP = 0;\n\n    // Define the SD clock static\n    localparam SD_CLK_STATIC = 0;\n\n    // Define the SD clock dynamic\n    localparam SD_CLK_DYNAMIC = 0;\n\n    // Define the block size\n    localparam BLOCK_SIZE = 512;\n\n    // Define the SD bus width\n    localparam SD_BUS_WIDTH_4 = 0;\n\n    // Define the SD bus width\n    localparam SD_BUS_W = 4;\n\n    // Define the FIFO RX memory depth\n    localparam FIFO_RX_MEM_DEPTH = 0;\n\n    // Define the FIFO RX memory address size\n    localparam FIFO_RX_MEM_ADR_SIZE = 0;\n\n    // Define the FIFO TX memory depth\n    localparam FIFO_TX_MEM_DEPTH = 0;\n\n    // Define the FIFO TX memory address size\n    localparam FIFO_TX_MEM_ADR_SIZE = 0;\n\n    // Define the BD buffer status register\n    reg [15:0] bd_status_reg;\n\n    // Define the BD interrupt status register\n    reg [7:0] bd_isr_reg;\n\n    // Define the BD interrupt enable register\n    reg [7:0] bd_isr_enable_reg;\n\n    // Define the BD interrupt reset register\n    reg bd_isr_reset;\n\n    // Define the normal interrupt status register\n    reg [15:0] normal_int_status_reg;\n\n    // Define the error interrupt status register\n    reg [15:0] error_int_status_reg;\n\n    // Define the normal interrupt enable register\n    reg [15:0] normal_int_signal_enable_reg;\n\n    // Define the error interrupt enable register\n    reg [15:0] error_int_signal_enable_reg;\n\n    // Define the clock divider register\n    reg [7:0] clock_divider;\n\n    // Define the argument register\n    reg [31:0] argument_reg;\n\n    // Define the command setting register\n    reg [15:0] cmd_setting_reg;\n\n    // Define the status register\n    reg [15:0] status_reg;\n\n    // Define the command response register\n    reg [31:0] cmd_resp_1;\n\n    // Define the software reset register\n    reg [7:0] software_reset_reg;\n\n    // Define the timeout register\n    reg [15:0] time_out_reg;\n\n    // Define the new command signal\n    wire new_cmd;\n\n    // Define the write enable signal for the master TX buffer descriptor\n    wire we_m_tx_bd;\n\n    // Define the write enable signal for the master RX buffer descriptor\n    wire we_m_rx_bd;\n\n    // Define the acknowledge signal\n    wire wb_ack_o;\n\n    // Define the write enable signal\n    wire we_ack;\n\n    // Define the internal acknowledge signal\n    wire int_ack;\n\n    // Define the command interrupt busy signal\n    wire cmd_int_busy;\n\n    // Define the internal busy signal\n    wire int_busy;\n\n    // Define the write request signal\n    wire write_req_s;\n\n    // Define the command set signal\n    wire [15:0] cmd_set_s;\n\n    // Define the command argument signal\n    wire [31:0] cmd_arg_s;\n\n    // Define the BD RX register\n    reg [RAM_MEM_WIDTH-1:0] bd_rx;\n\n    // Define the BD TX register\n    reg [RAM_MEM_WIDTH-1:0] bd_tx;\n\n    // Define the data going to the TX BD register\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n\n    // Define the data going to the RX BD register\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Define the BD buffer status register\n    assign bd_status_reg = Bd_Status_reg;\n\n    // Define the BD interrupt status register\n    assign bd_isr_reg = Bd_isr_reg;\n\n    // Define the BD interrupt enable register\n    assign bd_isr_enable_reg = Bd_isr_enable_reg;\n\n    // Define the BD interrupt reset register\n    assign bd_isr_reset = Bd_isr_reset;\n\n    // Define the normal interrupt status register\n    assign normal_int_status_reg = normal_int_status_reg;\n\n    // Define the error interrupt status register\n    assign error_int_status_reg = error_int_status_reg;\n\n    // Define the normal interrupt enable register\n    assign normal_int_signal_enable_reg = normal_int_signal_enable_reg;\n\n    // Define the error interrupt enable register\n    assign error_int_signal_enable_reg = error_int_signal_enable_reg;\n\n    // Define the clock divider register\n    assign clock_divider = clock_divider;\n\n    // Define the argument register\n    assign argument_reg = argument_reg;\n\n    // Define the command setting register\n    assign cmd_setting_reg = cmd_setting_reg;\n\n    // Define the status register\n    assign status_reg = status_reg;\n\n    // Define the command response register\n    assign cmd_resp_1 = cmd_resp_1;\n\n    // Define the software reset register\n    assign software_reset_reg = software_reset_reg;\n\n    // Define the timeout register\n    assign time_out_reg = time_out_reg;\n\n    // Define the new command signal\n    assign new_cmd = (cmd_arg_s != 0);\n\n    // Define the write enable signal for the master TX buffer descriptor\n    assign we_m_tx_bd = (write_req_s && (wb_adr_i == 0x80));\n\n    // Define the write enable signal for the master RX buffer descriptor\n    assign we_m_rx_bd = (write_req_s && (wb_adr_i == 0x60));\n\n    // Define the acknowledge signal\n    assign wb_ack_o = (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack);\n\n    // Define the write enable signal\n    assign we_ack = write_req_s;\n\n    // Define the internal acknowledge signal\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            int_ack <= 1;\n        end else begin\n            if (write_req_s) begin\n                int_ack <= 0;\n            end else begin\n                int_ack <= 1;\n            end\n        end\n    end\n\n    // Define the command interrupt busy signal\n    assign cmd_int_busy = (cmd_arg_s != 0);\n\n    // Define the internal busy signal\n    assign int_busy = (wb_adr_i == 0x04);\n\n    // Define the BD RX register\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            bd_rx <= 0;\n        end else begin\n            if (write_req_s && (wb_adr_i == 0x60)) begin\n                bd_rx <= dat_in_m_rx_bd;\n            end\n        end\n    end\n\n    // Define the BD TX register\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            bd_tx <= 0;\n        end else begin\n            if (write_req_s && (wb_adr_i == 0x80)) begin\n                bd_tx <= dat_in_m_tx_bd;\n            end\n        end\n    end\n\n    // Define the data going to the TX BD register\n    assign dat_in_m_tx_bd = bd_tx;\n\n    // Define the data going to the RX BD register\n    assign dat_in_m_rx_bd = bd_rx;\n\n    // Define the BD buffer status register\n    assign Bd_Status_reg = bd_status_reg;\n\n    // Define the BD interrupt status register\n    assign Bd_isr_reg = bd_isr_reg;\n\n    // Define the BD interrupt enable register\n    assign Bd_isr_enable_reg = bd_isr_enable_reg;\n\n    // Define the BD interrupt reset register\n    assign Bd_isr_reset = bd_isr_reset;\n\n    // Define the normal interrupt status register\n    assign normal_int_status_reg = normal_int_status_reg;\n\n    // Define the error interrupt status register\n    assign error_int_status_reg = error_int_status_reg;\n\n    // Define the normal interrupt enable register\n    assign normal_int_signal_enable_reg = normal_int_signal_enable_reg;\n\n    // Define the error interrupt enable register\n    assign error_int_signal_enable_reg = error_int_signal_enable_reg;\n\n    // Define the clock divider register\n    assign clock_divider = clock_divider;\n\n    // Define the argument register\n    assign argument_reg = argument_reg;\n\n    // Define the command setting register\n    assign cmd_setting_reg = cmd_setting_reg;\n\n    // Define the status register\n    assign status_reg = status_reg;\n\n    // Define the command response register\n    assign cmd_resp_1 = cmd_resp_1;\n\n    // Define the software reset register\n    assign software_reset_reg = software_reset_reg;\n\n    // Define the timeout register\n    assign time_out_reg = time_out_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 14, "code": "module sd_data_master(\n    input  wire clk,\n    input  wire rst,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input  wire [BD_WIDTH-1:0] free_tx_bd,\n    input  wire ack_i_s_tx,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input  wire [BD_WIDTH-1:0] free_rx_bd,\n    input  wire ack_i_s_rx,\n    input  wire cmd_busy,\n    input  wire we_ack,\n    input  wire cmd_tsf_err,\n    input  wire [4:0] card_status,\n    input  wire tx_empt,\n    input  wire tx_full,\n    input  wire rx_full,\n    input  wire busy_n,\n    input  wire transm_complete,\n    input  wire crc_ok,\n    input  wire Dat_Int_Status_rst,\n    input  wire [1:0] transfer_type,\n    output wire re_s_tx,\n    output wire a_cmp_tx,\n    output wire re_s_rx,\n    output wire a_cmp_rx,\n    output wire we_req,\n    output wire d_write,\n    output wire d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire start_tx_fifo,\n    output wire start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire ack_transfer,\n    output wire [7:0] Dat_Int_Status,\n    output wire CIDAT\n);\n\n    // Internal signals\n    reg [8:0] state;\n    reg [8:0] next_state;\n    reg [1:0] resend_try_cnt;\n    reg [1:0] tx_cycle;\n    reg [1:0] rx_cycle;\n    reg [2:0] bd_cnt;\n    reg [31:0] sys_adr;\n    reg [31:0] cmd_arg;\n    reg [15:0] cmd_set;\n    reg [1:0] CIDAT;\n    reg [7:0] Dat_Int_Status;\n    reg [1:0] trans_done;\n    reg [1:0] trans_failed;\n    reg [1:0] internal_transm_complete;\n    reg [1:0] transm_complete_q;\n    reg [1:0] send_done;\n    reg [1:0] rec_done;\n    reg [1:0] rec_failed;\n    reg [1:0] cmd_busy;\n    reg [1:0] we_req;\n    reg [1:0] d_write;\n    reg [1:0] d_read;\n    reg [1:0] start_tx_fifo;\n    reg [1:0] start_rx_fifo;\n    reg [1:0] ack_transfer;\n    reg [1:0] CIDAT;\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = 2;\n    parameter BD_EMPTY = BD_SIZE / 2;\n\n    // FSM state machine\n    always @(posedge clk) begin\n        if (rst) begin\n            state <= IDLE;\n            next_state <= IDLE;\n            resend_try_cnt <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            bd_cnt <= 0;\n            sys_adr <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            CIDAT <= 0;\n            Dat_Int_Status <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            cmd_busy <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            ack_transfer <= 0;\n            CIDAT <= 0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    if (free_tx_bd != BD_EMPTY) begin\n                        next_state <= GET_TX_BD;\n                    end\n                    else if (free_rx_bd != BD_EMPTY) begin\n                        next_state <= GET_RX_BD;\n                    end\n                    else begin\n                        next_state <= IDLE;\n                    end\n                end\n                GET_TX_BD: begin\n                    if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                        next_state <= SEND_CMD;\n                    end\n                    else begin\n                        next_state <= GET_TX_BD;\n                    end\n                end\n                GET_RX_BD: begin\n                    if (bd_cnt >= READ_CYCLE - 1) begin\n                        next_state <= SEND_CMD;\n                    end\n                    else begin\n                        next_state <= GET_RX_BD;\n                    end\n                end\n                SEND_CMD: begin\n                    if (send_done == 1) begin\n                        next_state <= RECIVE_CMD;\n                    end\n                    else begin\n                        next_state <= SEND_CMD;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rec_done == 1) begin\n                        next_state <= DATA_TRANSFER;\n                    end\n                    else if (rec_failed == 1) begin\n                        next_state <= SEND_CMD;\n                    end\n                    else begin\n                        next_state <= RECIVE_CMD;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (trans_done == 1) begin\n                        next_state <= IDLE;\n                    end\n                    else if (trans_failed == 1) begin\n                        next_state <= STOP;\n                    end\n                    else begin\n                        next_state <= DATA_TRANSFER;\n                    end\n                end\n                STOP: begin\n                    next_state <= STOP_SEND;\n                end\n                STOP_SEND: begin\n                    if (send_done == 1) begin\n                        next_state <= IDLE;\n                    end\n                    else begin\n                        next_state <= STOP_SEND;\n                    end\n                end\n                default: begin\n                    next_state <= IDLE;\n                end\n            endcase\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                GET_RX_BD: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 1;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                SEND_CMD: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 1;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                RECIVE_CMD: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                DATA_TRANSFER: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                STOP: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                STOP_SEND: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 1;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n                default: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // FSM state machine logic\n    always @(posedge clk) begin\n        if (rst) begin\n            state <= IDLE;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            CIDAT <= 0;\n        end\n        else begin\n            CIDAT <= state[0];\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            Dat_Int_Status <= 0;\n        end\n        else begin\n            Dat_Int_Status <= state[7:1];\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            ack_transfer <= 0;\n        end\n        else begin\n            ack_transfer <= transm_complete_q;\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            sys_adr <= 0;\n        end\n        else begin\n            sys_adr <= state[31:16];\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            cmd_arg <= 0;\n        end\n        else begin\n            cmd_arg <= state[31:16];\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            cmd_set <= 0;\n        end\n        else begin\n            cmd_set <= state[15:0];\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            start_tx_fifo <= 0;\n        end\n        else begin\n            start_tx_fifo <= state[1];\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            start_rx_fifo <= 0;\n        end\n        else begin\n            start_rx_fifo <= state[0];\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            d_write <= 0;\n        end\n        else begin\n            d_write <= state[2];\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            d_read <= 0;\n        end\n        else begin\n            d_read <= state[3];\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            we_req <= 0;\n        end\n        else begin\n            we_req <= state[4];\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            re_s_tx <= 0;\n        end\n        else begin\n            re_s_tx <= state[5];\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            a_cmp_tx <= 0;\n        end\n        else begin\n            a_cmp_tx <= state[6];\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            re_s_rx <= 0;\n        end\n        else begin\n            re_s_rx <= state[7];\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            a_cmp_rx <= 0;\n        end\n        else begin\n            a_cmp_rx <= state[8];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 15, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_tx,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\n// Define parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\nparameter READ_CYCLE = 2;\nparameter BD_EMPTY = BD_SIZE / 2;\n\n// Define registers\nreg [1:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg [1:0] trans_done;\nreg [1:0] trans_failed;\nreg [1:0] internal_transm_complete;\nreg [1:0] transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr;\nreg [31:0] cmd_arg;\nreg [15:0] cmd_set;\nreg [1:0] CIDAT;\nreg [7:0] Dat_Int_Status;\n\n// Define combinational logic\nalways_comb begin\n    // Determine next state based on current state and input conditions\n    case (state)\n        IDLE: begin\n            if (free_tx_bd!= BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd!= BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done == 1) begin\n                next_state = IDLE;\n            end else if (trans_failed == 1) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done == 1) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\n\n    // Update output signals based on current state and next state\n    case (state)\n        IDLE: begin\n            re_s_tx = 1;\n            a_cmp_tx = 1;\n            re_s_rx = 1;\n            a_cmp_rx = 1;\n            we_req = 1;\n            d_write = 1;\n            d_read = 1;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h0000;\n            start_tx_fifo = 1;\n            start_rx_fifo = 1;\n            sys_adr = 32'h00000000;\n            ack_transfer = 1;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 1;\n        end\n        GET_TX_BD: begin\n            re_s_tx = 1;\n            a_cmp_tx = 1;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h181A;\n            start_tx_fifo = 1;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        GET_RX_BD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 1;\n            a_cmp_rx = 1;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h111A;\n            start_tx_fifo = 0;\n            start_rx_fifo = 1;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        SEND_CMD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 1;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h181A;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        RECIVE_CMD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h0000;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        DATA_TRANSFER: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h0000;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        STOP: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'hC1A;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        STOP_SEND: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h0000;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        default: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h0000;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n    endcase\nend\n\n// Update internal signals based on current state and next state\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 32'h00000000;\n        cmd_arg <= 32'h00000000;\n        cmd_set <= 16'h0000;\n        CIDAT <= 0;\n        Dat_Int_Status <= 8'h00;\n    end else begin\n        state <= next_state;\n        resend_try_cnt <= resend_try_cnt + 1;\n        trans_done <= trans_done;\n        trans_failed <= trans_failed;\n        internal_transm_complete <= internal_transm_complete;\n        transm_complete_q <= transm_complete_q;\n        bd_cnt <= bd_cnt;\n        sys_adr <= sys_adr;\n        cmd_arg <= cmd_arg;\n        cmd_set <= cmd_set;\n        CIDAT <= CIDAT;\n        Dat_Int_Status <= Dat_Int_Status;\n    end\nend\n\n// Update output signals based on current state and next state\nalways_comb begin\n    // Determine output signals based on current state\n    case (state)\n        IDLE: begin\n            re_s_tx = 1;\n            a_cmp_tx = 1;\n            re_s_rx = 1;\n            a_cmp_rx = 1;\n            we_req = 1;\n            d_write = 1;\n            d_read = 1;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h0000;\n            start_tx_fifo = 1;\n            start_rx_fifo = 1;\n            sys_adr = 32'h00000000;\n            ack_transfer = 1;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 1;\n        end\n        GET_TX_BD: begin\n            re_s_tx = 1;\n            a_cmp_tx = 1;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h181A;\n            start_tx_fifo = 1;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        GET_RX_BD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 1;\n            a_cmp_rx = 1;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h111A;\n            start_tx_fifo = 0;\n            start_rx_fifo = 1;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        SEND_CMD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 1;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h181A;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        RECIVE_CMD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h0000;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        DATA_TRANSFER: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h0000;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        STOP: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'hC1A;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        STOP_SEND: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h0000;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n        default: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 32'h00000000;\n            cmd_set = 16'h0000;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 32'h00000000;\n            ack_transfer = 0;\n            Dat_Int_Status = 8'h00;\n            CIDAT = 0;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 18, "code": "module sdc_controller(\n    // Wishbone Slave Interface\n    input  wire  wb_clk_i,\n    input  wire  wb_rst_i,\n    input  wire  wb_dat_i [31:0],\n    output wire  wb_dat_o [31:0],\n    input  wire  wb_adr_i [7:0],\n    input  wire  wb_we_i,\n    input  wire  wb_cyc_i,\n    input  wire  wb_stb_i,\n    output wire  wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire  m_wb_adr_o [31:0],\n    output wire  m_wb_sel_o [3:0],\n    output wire  m_wb_we_o,\n    output wire  m_wb_dat_o [31:0],\n    input  wire  m_wb_dat_i [31:0],\n    output wire  m_wb_cyc_o,\n    output wire  m_wb_stb_o,\n    input  wire  m_wb_ack_i,\n\n    // SDC/MMC Interface\n    input  wire  sd_clk_i,\n    input  wire  sd_cmd_dat_i,\n    output wire  sd_cmd_out_o,\n    output wire  sd_cmd_oe_o,\n    input  wire  sd_dat_dat_i [3:0],\n    output wire  sd_dat_out_o [3:0],\n    output wire  sd_dat_oe_o,\n    output wire  sd_clk_o_pad,\n\n    // Interrupts\n    output wire  int_a,\n    output wire  int_b,\n    output wire  int_c\n);\n\n    // Define the width of the buffer descriptors\n    localparam BD_WIDTH = 64;\n\n    // Define the width of the RAM memory\n    localparam RAM_MEM_WIDTH = 32;\n\n    // Define the width of the SD bus\n    localparam SD_BUS_WIDTH = 4;\n\n    // Define the maximum number of retries for data resend\n    localparam RESEND_MAX_CNT = 255;\n\n    // Define the memory address offset between two words\n    localparam MEM_OFFSET = 0;\n\n    // Define the clock divider value\n    localparam RESET_CLK_DIV = 0;\n\n    // Define the clock source\n    localparam SD_CLK_BUS_CLK = 1;\n    localparam SD_CLK_SEP = 0;\n    localparam SD_CLK_STATIC = 0;\n    localparam SD_CLK_DYNAMIC = 0;\n\n    // Define the block size\n    localparam BLOCK_SIZE = 512;\n\n    // Define the width of the FIFO RX and TX\n    localparam FIFO_RX_MEM_DEPTH = 16;\n    localparam FIFO_TX_MEM_DEPTH = 16;\n\n    // Define the address size for the FIFO RX and TX\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1;\n\n    // Define the endianness of the system\n    localparam BIG_ENDIAN = 0;\n    localparam LITTLE_ENDIAN = 1;\n\n    // Define the simulation and synthesis options\n    localparam SIM = 0;\n    localparam SYN = 0;\n\n    // Define the SDC IRQ enable option\n    localparam SDC_IRQ_ENABLE = 0;\n\n    // Define the ACTEL option\n    localparam ACTEL = 0;\n\n    // Define the BD size\n    localparam BD_SIZE = 255;\n\n    // Define the RAM memory width\n    localparam RAM_MEM_WIDTH_16 = 16;\n\n    // Define the clock divider value\n    localparam SD_CLK_DIV = RESET_CLK_DIV;\n\n    // Define the clock source\n    localparam sd_clk_i_pad = (SD_CLK_SEP == 1) ? sd_clk_i : wb_clk_i;\n    localparam sd_clk_o = (SD_CLK_STATIC == 1) ? sd_clk_i_pad : sd_clk_i;\n    localparam sd_clk_o_pad = sd_clk_o;\n\n    // Define the clock divider\n    wire sd_clk_div = sd_clk_o / (SD_CLK_DIV + 1);\n\n    // Define the clock divider module\n    sd_clock_divider sd_clock_divider(\n        .CLK(sd_clk_i_pad),\n        .DIVIDER(SD_CLK_DIV),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o)\n    );\n\n    // Define the SDC/MMC controller module\n    sd_controller_wb sd_controller_wb(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n\n        // Wishbone Master Interface\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_sel_o(m_wb_sel_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n\n        // SDC/MMC Interface\n        .sd_clk_i(sd_clk_i_pad),\n        .sd_cmd_dat_i(sd_cmd_dat_i),\n        .sd_cmd_out_o(sd_cmd_out_o),\n        .sd_cmd_oe_o(sd_cmd_oe_o),\n        .sd_dat_dat_i(sd_dat_dat_i),\n        .sd_dat_out_o(sd_dat_out_o),\n        .sd_dat_oe_o(sd_dat_oe_o),\n        .sd_clk_o_pad(sd_clk_o_pad),\n\n        // Interrupts\n        .int_a(int_a),\n        .int_b(int_b),\n        .int_c(int_c)\n    );\n\n    // Define the SDC/MMC command master module\n    sd_cmd_master sd_cmd_master(\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(wb_stb_i),\n        .data_write(wb_we_i),\n        .data_read(wb_we_i),\n        .ARG_REG(wb_dat_i[31:0]),\n        .CMD_SET_REG(wb_dat_i[15:0]),\n        .TIMEOUT_REG(wb_dat_i[15:0]),\n        .STATUS_REG(wb_dat_o[15:0]),\n        .RESP_1_REG(wb_dat_o[31:16]),\n        .ERR_INT_REG(wb_dat_o[5:0]),\n        .NORMAL_INT_REG(wb_dat_o[15:0]),\n        .ERR_INT_RST(wb_dat_i[0]),\n        .NORMAL_INT_RST(wb_dat_i[0]),\n        .settings(wb_dat_o[15:0]),\n        .go_idle_o(wb_dat_o[0]),\n        .cmd_out(wb_dat_o[39:0]),\n        .req_out(wb_dat_o[0]),\n        .ack_out(wb_dat_o[0]),\n        .req_in(wb_dat_i[0]),\n        .ack_in(wb_dat_i[0]),\n        .cmd_in(wb_dat_i[39:0]),\n        .serial_status(wb_dat_i[7:0]),\n        .card_detect(wb_dat_i[0])\n    );\n\n    // Define the SDC/MMC command serial host module\n    sd_cmd_serial_host sd_cmd_serial_host(\n        .SD_CLK_IN(sd_clk_i_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(wb_dat_i[15:0]),\n        .CMD_IN(wb_dat_i[39:0]),\n        .REQ_IN(wb_dat_i[0]),\n        .ACK_IN(wb_dat_i[0]),\n        .cmd_dat_i(wb_dat_i[0]),\n        .CMD_OUT(wb_dat_o[39:0]),\n        .ACK_OUT(wb_dat_o[0]),\n        .REQ_OUT(wb_dat_o[0]),\n        .STATUS(wb_dat_o[7:0]),\n        .cmd_oe_o(wb_dat_o[0]),\n        .cmd_out_o(wb_dat_o[0]),\n        .st_dat_t(wb_dat_o[1:0])\n    );\n\n    // Define the SDC/MMC data master module\n    sd_data_master sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(wb_dat_i[31:0]),\n        .free_tx_bd(wb_dat_i[7:0]),\n        .ack_i_s_tx(wb_dat_i[0]),\n        .dat_in_rx(wb_dat_i[31:0]),\n        .free_rx_bd(wb_dat_i[7:0]),\n        .ack_i_s_rx(wb_dat_i[0]),\n        .cmd_busy(wb_dat_i[0]),\n        .we_ack(wb_dat_i[0]),\n        .cmd_tsf_err(wb_dat_i[0]),\n        .card_status(wb_dat_i[4:0]),\n        .tx_empt(wb_dat_i[0]),\n        .tx_full(wb_dat_i[0]),\n        .rx_full(wb_dat_i[0]),\n        .busy_n(wb_dat_i[0]),\n        .transm_complete(wb_dat_i[0]),\n        .crc_ok(wb_dat_i[0]),\n        .Dat_Int_Status_rst(wb_dat_i[0]),\n        .transfer_type(wb_dat_i[1:0]),\n        .re_s_tx(wb_dat_o[0]),\n        .a_cmp_tx(wb_dat_o[0]),\n        .re_s_rx(wb_dat_o[0]),\n        .a_cmp_rx(wb_dat_o[0]),\n        .we_req(wb_dat_o[0]),\n        .d_write(wb_dat_o[0]),\n        .d_read(wb_dat_o[0]),\n        .cmd_arg(wb_dat_o[31:0]),\n        .cmd_set(wb_dat_o[15:0]),\n        .start_tx_fifo(wb_dat_o[0]),\n        .start_rx_fifo(wb_dat_o[0]),\n        .sys_adr(wb_dat_o[31:0]),\n        .ack_transfer(wb_dat_o[0]),\n        .Dat_Int_Status(wb_dat_o[7:0]),\n        .CIDAT(wb_dat_o[0])\n    );\n\n    // Define the SDC/MMC data serial host module\n    sd_data_serial_host sd_data_serial_host(\n        .sd_clk(sd_clk_i_pad),\n        .rst(wb_rst_i),\n        .data_in(wb_dat_i[31:0]),\n        .start_dat(wb_dat_i[1:0]),\n        .ack_transfer(wb_dat_i[0]),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(wb_dat_o[0]),\n        .data_out(sd_dat_out_o),\n        .we(wb_dat_o[0]),\n        .DAT_oe_o(wb_dat_o[0]),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(wb_dat_o[0]),\n        .transm_complete(wb_dat_o[0]),\n        .crc_ok(wb_dat_o[0])\n    );\n\n    // Define the receive and transmit buffer descriptors\n    rx_bd rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(wb_dat_i[0]),\n        .dat_in_m(wb_dat_i[31:0]),\n        .free_bd(wb_dat_i[7:0]),\n        .re_s(wb_dat_i[0]),\n        .ack_o_s(wb_dat_o[0]),\n        .a_cmp(wb_dat_o[0]),\n        .dat_out_s(wb_dat_o[31:0])\n    );\n\n    tx_bd tx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(wb_dat_i[0]),\n        .dat_in_m(wb_dat_i[31:0]),\n        .free_bd(wb_dat_i[7:0]),\n        .re_s(wb_dat_i[0]),\n        .ack_o_s(wb_dat_o[0]),\n        .a_cmp(wb_dat_o[0]),\n        .dat_out_s(wb_dat_o[31:0])\n    );\n\n    // Define the SD TX FIFO filler module\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte(m_wb_bte),\n        .en(wb_dat_i[0]),\n        .adr(wb_dat_i[31:0]),\n        .sd_clk(sd_clk_i_pad),\n        .dat_o(wb_dat_o),\n        .rd(wb_dat_i[0]),\n        .empty(wb_dat_o[0]),\n        .fe(wb_dat_o[0])\n    );\n\n    // Define the SD RX FIFO filler module\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte(m_wb_bte),\n        .en(wb_dat_i[0]),\n        .adr(wb_dat_i[31:0]),\n        .sd_clk(sd_clk_i_pad),\n        .dat_i(sd_dat_dat_i),\n        .wr(wb_dat_i[0]),\n        .full(wb_dat_o[0])\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 16, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\n// Internal signals\nreg [1:0] send_done;\nreg [1:0] rec_done;\nreg [1:0] rec_failed;\nreg [1:0] tx_cycle;\nreg [1:0] rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg [1:0] trans_done;\nreg [1:0] trans_failed;\nreg [1:0] internal_transm_complete;\nreg [1:0] transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr;\nreg [31:0] cmd_arg;\nreg [15:0] cmd_set;\nreg [1:0] CIDAT;\nreg [7:0] Dat_Int_Status;\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\nparameter READ_CYCLE = 2;\nparameter BD_EMPTY = BD_SIZE / 2;\n\n// FSM state machine\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n    end\n    else begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY)\n                    next_state <= GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY)\n                    next_state <= GET_RX_BD;\n                else\n                    next_state <= IDLE;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1)\n                    next_state <= SEND_CMD;\n                else\n                    next_state <= GET_TX_BD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1)\n                    next_state <= SEND_CMD;\n                else\n                    next_state <= GET_RX_BD;\n            end\n            SEND_CMD: begin\n                if (send_done == 1)\n                    next_state <= RECIVE_CMD;\n                else\n                    next_state <= SEND_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1)\n                    next_state <= DATA_TRANSFER;\n                else if (rec_failed == 1)\n                    next_state <= SEND_CMD;\n                else\n                    next_state <= RECIVE_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1)\n                    next_state <= IDLE;\n                else if (trans_failed == 1)\n                    next_state <= STOP;\n                else\n                    next_state <= DATA_TRANSFER;\n            end\n            STOP: begin\n                next_state <= STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (resend_try_cnt == RESEND_MAX_CNT)\n                    next_state <= IDLE;\n                else if (send_done == 1)\n                    next_state <= IDLE;\n                else\n                    next_state <= STOP_SEND;\n            end\n        endcase\n    end\nend\n\n// FSM state machine logic\nalways @(posedge clk) begin\n    if (rst) begin\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end\n    else begin\n        case (state)\n            IDLE: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            GET_TX_BD: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 1;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= CMD24;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            GET_RX_BD: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 1;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            SEND_CMD: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 1;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            RECIVE_CMD: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            DATA_TRANSFER: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 1;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            STOP: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= CMD12;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            STOP_SEND: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= resend_try_cnt + 1;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n        endcase\n    end\nend\n\n// Output logic\nassign re_s_tx = (state == GET_TX_BD) ? 1 : 0;\nassign a_cmp_tx = (state == GET_TX_BD) ? 1 : 0;\nassign re_s_rx = (state == GET_RX_BD) ? 1 : 0;\nassign a_cmp_rx = (state == GET_RX_BD) ? 1 : 0;\nassign we_req = (state == SEND_CMD) ? 1 : 0;\nassign d_write = (state == SEND_CMD) ? 1 : 0;\nassign d_read = (state == SEND_CMD) ? 1 : 0;\nassign cmd_arg = (state == SEND_CMD) ? cmd_arg : 0;\nassign cmd_set = (state == SEND_CMD) ? cmd_set : 0;\nassign start_tx_fifo = (state == SEND_CMD) ? 1 : 0;\nassign start_rx_fifo = (state == SEND_CMD) ? 1 : 0;\nassign sys_adr = (state == SEND_CMD) ? sys_adr : 0;\nassign ack_transfer = (state == DATA_TRANSFER) ? 1 : 0;\nassign Dat_Int_Status = (state == STOP_SEND) ? Dat_Int_Status : 0;\nassign CIDAT = (state == SEND_CMD) ? CIDAT : 0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 19, "code": "module sdc_controller(\n    // Wishbone slave interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone master interface\n    output wire m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC/MMC interface\n    output wire sd_clk_o,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input  wire sd_dat_dat_i,\n    output wire sd_dat_out_o,\n    output wire sd_dat_oe_o,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal registers\n    reg [15:0] cmd_setting_reg;\n    reg [31:0] argument_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [7:0] software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0] clock_divider;\n    reg [15:0] Bd_status_reg;\n    reg [7:0] Bd_isr_reg;\n    reg [7:0] Bd_isr_enable_reg;\n\n    // sd_controller_wb module\n    sd_controller_wb sd_controller_wb_inst(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .cmd_busy(cmd_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_status_reg(Bd_status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg)\n    );\n\n    // sd_clock_divider module\n    sd_clock_divider sd_clock_divider_inst(\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o)\n    );\n\n    // sd_cmd_master module\n    sd_cmd_master sd_cmd_master_inst(\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(ERR_INT_RST),\n        .NORMAL_INT_RST(NORMAL_INT_RST),\n        .settings(settings),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n\n    // sd_cmd_serial_host module\n    sd_cmd_serial_host sd_cmd_serial_host_inst(\n        .SD_CLK_IN(sd_clk_i),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_out),\n        .cmd_dat_i(cmd_in),\n        .CMD_OUT(cmd_out),\n        .ACK_OUT(ack_out),\n        .REQ_OUT(req_out),\n        .STATUS(serial_status),\n        .cmd_oe_o(cmd_oe_o),\n        .cmd_out_o(cmd_out_o),\n        .st_dat_t(st_dat_t)\n    );\n\n    // sd_data_master module\n    sd_data_master sd_data_master_inst(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_tx),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_in_rx),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(cmd_tsf_err),\n        .card_status(card_status),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(Dat_Int_Status_rst),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n\n    // sd_data_serial_host module\n    sd_data_serial_host sd_data_serial_host_inst(\n        .sd_clk(sd_clk_i),\n        .rst(wb_rst_i),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(DAT_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(DAT_oe_o),\n        .DAT_dat_o(DAT_dat_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n\n    // rx_bd/tx_bd modules\n    rx_bd rx_bd_inst(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m),\n        .dat_in_m(dat_in_m),\n        .free_bd(free_bd),\n        .re_s(re_s),\n        .ack_o_s(ack_o_s),\n        .a_cmp(a_cmp),\n        .dat_out_s(dat_out_s)\n    );\n\n    // sd_fifo_tx_filler module\n    sd_fifo_tx_filler sd_fifo_tx_filler_inst(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i),\n        .dat_o(dat_o),\n        .rd(rd),\n        .empty(empty),\n        .fe(fe)\n    );\n\n    // sd_fifo_rx_filler module\n    sd_fifo_rx_filler sd_fifo_rx_filler_inst(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i),\n        .dat_i(dat_i),\n        .wr(wr),\n        .full(full)\n    );\n\n    // Register update logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            cmd_int_busy <= 0;\n            status_reg <= 0;\n            Bd_status_reg <= 0;\n            Bd_isr_reg <= 0;\n            Bd_isr_enable_reg <= 0;\n        end else begin\n            if (cmd_int_busy) begin\n                cmd_int_busy <= 0;\n                status_reg <= STATUS_REG;\n            end\n        end\n    end\n\n    // Master Wishbone Interface Control\n    always @(posedge wb_clk_i) begin\n        if (start_tx_fifo) begin\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            m_wb_cti_o <= 3'b001;\n            m_wb_bte_o <= 2'b00;\n            m_wb_we_o <= 1;\n            m_wb_adr_o <= sys_adr;\n        end else if (start_rx_fifo) begin\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            m_wb_cti_o <= 3'b001;\n            m_wb_bte_o <= 2'b00;\n            m_wb_we_o <= 0;\n            m_wb_adr_o <= sys_adr;\n        end else begin\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_adr_o <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 17, "code": "module sd_data_master(\n    input  wire clk,\n    input  wire rst,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input  wire [BD_WIDTH-1:0] free_tx_bd,\n    input  wire ack_i_s_tx,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input  wire [BD_WIDTH-1:0] free_rx_bd,\n    input  wire ack_i_s_rx,\n    input  wire cmd_busy,\n    input  wire we_ack,\n    input  wire cmd_tsf_err,\n    input  wire [4:0] card_status,\n    input  wire tx_empt,\n    input  wire tx_full,\n    input  wire rx_full,\n    input  wire busy_n,\n    input  wire transm_complete,\n    input  wire crc_ok,\n    input  wire Dat_Int_Status_rst,\n    input  wire [1:0] transfer_type,\n    output wire re_s_tx,\n    output wire a_cmp_tx,\n    output wire re_s_rx,\n    output wire a_cmp_rx,\n    output wire we_req,\n    output wire d_write,\n    output wire d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire start_tx_fifo,\n    output wire start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire ack_transfer,\n    output wire [7:0] Dat_Int_Status,\n    output wire CIDAT\n);\n\n    // Internal signals\n    reg [1:0] send_done;\n    reg [1:0] rec_done;\n    reg [1:0] rec_failed;\n    reg [1:0] tx_cycle;\n    reg [1:0] rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state;\n    reg [8:0] next_state;\n    reg [1:0] trans_done;\n    reg [1:0] trans_failed;\n    reg [1:0] internal_transm_complete;\n    reg [1:0] transm_complete_q;\n    reg [2:0] bd_cnt;\n    reg [31:0] sys_adr;\n    reg [31:0] cmd_arg;\n    reg [15:0] cmd_set;\n    reg [1:0] CIDAT;\n    reg [7:0] Dat_Int_Status;\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = 2;\n    parameter BD_EMPTY = BD_SIZE / 2;\n\n    // FSM state machine\n    always @(posedge clk) begin\n        if (rst) begin\n            state <= IDLE;\n            next_state <= IDLE;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    if (free_tx_bd != BD_EMPTY) begin\n                        next_state <= GET_TX_BD;\n                    end\n                    else if (free_rx_bd != BD_EMPTY) begin\n                        next_state <= GET_RX_BD;\n                    end\n                    else begin\n                        next_state <= IDLE;\n                    end\n                end\n                GET_TX_BD: begin\n                    if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                        next_state <= SEND_CMD;\n                    end\n                    else begin\n                        next_state <= GET_TX_BD;\n                    end\n                end\n                GET_RX_BD: begin\n                    if (bd_cnt >= READ_CYCLE - 1) begin\n                        next_state <= SEND_CMD;\n                    end\n                    else begin\n                        next_state <= GET_RX_BD;\n                    end\n                end\n                SEND_CMD: begin\n                    if (send_done == 1) begin\n                        next_state <= RECIVE_CMD;\n                    end\n                    else begin\n                        next_state <= SEND_CMD;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rec_done == 1) begin\n                        next_state <= DATA_TRANSFER;\n                    end\n                    else if (rec_failed == 1) begin\n                        next_state <= SEND_CMD;\n                    end\n                    else begin\n                        next_state <= RECIVE_CMD;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (trans_done == 1) begin\n                        next_state <= IDLE;\n                    end\n                    else if (trans_failed == 1) begin\n                        next_state <= STOP;\n                    end\n                    else begin\n                        next_state <= DATA_TRANSFER;\n                    end\n                end\n                STOP: begin\n                    next_state <= STOP_SEND;\n                end\n                STOP_SEND: begin\n                    if (send_done == 1) begin\n                        next_state <= IDLE;\n                    end\n                    else begin\n                        next_state <= STOP_SEND;\n                    end\n                end\n                default: begin\n                    next_state <= IDLE;\n                end\n            endcase\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            re_s_tx <= 1'b0;\n            a_cmp_tx <= 1'b0;\n            re_s_rx <= 1'b0;\n            a_cmp_rx <= 1'b0;\n            we_req <= 1'b0;\n            d_write <= 1'b0;\n            d_read <= 1'b0;\n            cmd_arg <= 32'b0;\n            cmd_set <= 16'b0;\n            start_tx_fifo <= 1'b0;\n            start_rx_fifo <= 1'b0;\n            sys_adr <= 32'b0;\n            ack_transfer <= 1'b0;\n            Dat_Int_Status <= 8'b0;\n            CIDAT <= 1'b0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1'b1;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                GET_RX_BD: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b1;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                SEND_CMD: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b1;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                RECIVE_CMD: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                DATA_TRANSFER: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                STOP: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                STOP_SEND: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                default: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n            endcase\n        end\n    end\n\n    // FSM state machine logic\n    always @(posedge clk) begin\n        if (rst) begin\n            send_done <= 1'b0;\n            rec_done <= 1'b0;\n            rec_failed <= 1'b0;\n            tx_cycle <= 1'b0;\n            rx_cycle <= 1'b0;\n            resend_try_cnt <= 3'b0;\n            state <= IDLE;\n            next_state <= IDLE;\n            trans_done <= 1'b0;\n            trans_failed <= 1'b0;\n            internal_transm_complete <= 1'b0;\n            transm_complete_q <= 1'b0;\n            bd_cnt <= 2'b0;\n            sys_adr <= 32'b0;\n            cmd_arg <= 32'b0;\n            cmd_set <= 16'b0;\n            CIDAT <= 1'b0;\n            Dat_Int_Status <= 8'b0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    send_done <= 1'b0;\n                    rec_done <= 1'b0;\n                    rec_failed <= 1'b0;\n                    tx_cycle <= 1'b0;\n                    rx_cycle <= 1'b0;\n                    resend_try_cnt <= 3'b0;\n                    trans_done <= 1'b0;\n                    trans_failed <= 1'b0;\n                    internal_transm_complete <= 1'b0;\n                    transm_complete_q <= 1'b0;\n                    bd_cnt <= 2'b0;\n                    sys_adr <= 32'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    CIDAT <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                end\n                GET_TX_BD: begin\n                    send_done <= 1'b0;\n                    rec_done <= 1'b0;\n                    rec_failed <= 1'b0;\n                    tx_cycle <= 1'b0;\n                    rx_cycle <= 1'b0;\n                    resend_try_cnt <= 3'b0;\n                    trans_done <= 1'b0;\n                    trans_failed <= 1'b0;\n                    internal_transm_complete <= 1'b0;\n                    transm_complete_q <= 1'b0;\n                    bd_cnt <= 2'b0;\n                    sys_adr <= 32'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    CIDAT <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                end\n                GET_RX_BD: begin\n                    send_done <= 1'b0;\n                    rec_done <= 1'b0;\n                    rec_failed <= 1'b0;\n                    tx_cycle <= 1'b0;\n                    rx_cycle <= 1'b0;\n                    resend_try_cnt <= 3'b0;\n                    trans_done <= 1'b0;\n                    trans_failed <= 1'b0;\n                    internal_transm_complete <= 1'b0;\n                    transm_complete_q <= 1'b0;\n                    bd_cnt <= 2'b0;\n                    sys_adr <= 32'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    CIDAT <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                end\n                SEND_CMD: begin\n                    send_done <= 1'b0;\n                    rec_done <= 1'b0;\n                    rec_failed <= 1'b0;\n                    tx_cycle <= 1'b0;\n                    rx_cycle <= 1'b0;\n                    resend_try_cnt <= 3'b0;\n                    trans_done <= 1'b0;\n                    trans_failed <= 1'b0;\n                    internal_transm_complete <= 1'b0;\n                    transm_complete_q <= 1'b0;\n                    bd_cnt <= 2'b0;\n                    sys_adr <= 32'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    CIDAT <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                end\n                RECIVE_CMD: begin\n                    send_done <= 1'b0;\n                    rec_done <= 1'b0;\n                    rec_failed <= 1'b0;\n                    tx_cycle <= 1'b0;\n                    rx_cycle <= 1'b0;\n                    resend_try_cnt <= 3'b0;\n                    trans_done <= 1'b0;\n                    trans_failed <= 1'b0;\n                    internal_transm_complete <= 1'b0;\n                    transm_complete_q <= 1'b0;\n                    bd_cnt <= 2'b0;\n                    sys_adr <= 32'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    CIDAT <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                end\n                DATA_TRANSFER: begin\n                    send_done <= 1'b0;\n                    rec_done <= 1'b0;\n                    rec_failed <= 1'b0;\n                    tx_cycle <= 1'b0;\n                    rx_cycle <= 1'b0;\n                    resend_try_cnt <= 3'b0;\n                    trans_done <= 1'b0;\n                    trans_failed <= 1'b0;\n                    internal_transm_complete <= 1'b0;\n                    transm_complete_q <= 1'b0;\n                    bd_cnt <= 2'b0;\n                    sys_adr <= 32'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    CIDAT <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                end\n                STOP: begin\n                    send_done <= 1'b0;\n                    rec_done <= 1'b0;\n                    rec_failed <= 1'b0;\n                    tx_cycle <= 1'b0;\n                    rx_cycle <= 1'b0;\n                    resend_try_cnt <= 3'b0;\n                    trans_done <= 1'b0;\n                    trans_failed <= 1'b0;\n                    internal_transm_complete <= 1'b0;\n                    transm_complete_q <= 1'b0;\n                    bd_cnt <= 2'b0;\n                    sys_adr <= 32'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    CIDAT <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                end\n                STOP_SEND: begin\n                    send_done <= 1'b0;\n                    rec_done <= 1'b0;\n                    rec_failed <= 1'b0;\n                    tx_cycle <= 1'b0;\n                    rx_cycle <= 1'b0;\n                    resend_try_cnt <= 3'b0;\n                    trans_done <= 1'b0;\n                    trans_failed <= 1'b0;\n                    internal_transm_complete <= 1'b0;\n                    transm_complete_q <= 1'b0;\n                    bd_cnt <= 2'b0;\n                    sys_adr <= 32'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    CIDAT <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                end\n                default: begin\n                    send_done <= 1'b0;\n                    rec_done <= 1'b0;\n                    rec_failed <= 1'b0;\n                    tx_cycle <= 1'b0;\n                    rx_cycle <= 1'b0;\n                    resend_try_cnt <= 3'b0;\n                    trans_done <= 1'b0;\n                    trans_failed <= 1'b0;\n                    internal_transm_complete <= 1'b0;\n                    transm_complete_q <= 1'b0;\n                    bd_cnt <= 2'b0;\n                    sys_adr <= 32'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    CIDAT <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                end\n            endcase\n        end\n    end\n\n    // FSM output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            re_s_tx <= 1'b0;\n            a_cmp_tx <= 1'b0;\n            re_s_rx <= 1'b0;\n            a_cmp_rx <= 1'b0;\n            we_req <= 1'b0;\n            d_write <= 1'b0;\n            d_read <= 1'b0;\n            cmd_arg <= 32'b0;\n            cmd_set <= 16'b0;\n            start_tx_fifo <= 1'b0;\n            start_rx_fifo <= 1'b0;\n            sys_adr <= 32'b0;\n            ack_transfer <= 1'b0;\n            Dat_Int_Status <= 8'b0;\n            CIDAT <= 1'b0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1'b1;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                GET_RX_BD: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b1;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                SEND_CMD: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b1;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                RECIVE_CMD: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                DATA_TRANSFER: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                STOP: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                STOP_SEND: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n                default: begin\n                    re_s_tx <= 1'b0;\n                    a_cmp_tx <= 1'b0;\n                    re_s_rx <= 1'b0;\n                    a_cmp_rx <= 1'b0;\n                    we_req <= 1'b0;\n                    d_write <= 1'b0;\n                    d_read <= 1'b0;\n                    cmd_arg <= 32'b0;\n                    cmd_set <= 16'b0;\n                    start_tx_fifo <= 1'b0;\n                    start_rx_fifo <= 1'b0;\n                    sys_adr <= 32'b0;\n                    ack_transfer <= 1'b0;\n                    Dat_Int_Status <= 8'b0;\n                    CIDAT <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 20, "code": "module sdc_controller(\n    // Wishbone Slave Interface\n    input  wire  wb_clk_i,\n    input  wire  wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire m_wb_dat_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC/MMC Interface\n    input  wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input  wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input  wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input  wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal Registers\n    reg [15:0] cmd_setting_reg;\n    reg [31:0] argument_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [7:0] software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0] clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [7:0] Bd_isr_reg;\n    reg [7:0] Bd_isr_enable_reg;\n    reg [7:0] dat_in_m_tx_bd;\n    reg [7:0] dat_in_m_rx_bd;\n\n    // sd_controller_wb Module\n    sd_controller_wb sd_controller_wb(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .cmd_busy(cmd_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // sd_clock_divider Module\n    sd_clock_divider sd_clock_divider(\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // sd_cmd_master Module\n    sd_cmd_master sd_cmd_master(\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_int_reset),\n        .NORMAL_INT_RST(normal_int_reset),\n        .settings(cmd_setting_reg),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n\n    // sd_cmd_serial_host Module\n    sd_cmd_serial_host sd_cmd_serial_host(\n        .SD_CLK_IN(sd_clk_i_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(cmd_in),\n        .REQ_IN(req_in),\n        .ACK_IN(ack_in),\n        .cmd_dat_i(cmd_dat_i),\n        .CMD_OUT(cmd_out),\n        .ACK_OUT(ack_out),\n        .REQ_OUT(req_out),\n        .STATUS(serial_status),\n        .cmd_oe_o(cmd_oe_o),\n        .cmd_out_o(cmd_out_o),\n        .st_dat_t(st_dat_t)\n    );\n\n    // sd_data_master Module\n    sd_data_master sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(cmd_tsf_err),\n        .card_status(card_status),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(Dat_Int_Status_rst),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n\n    // sd_data_serial_host Module\n    sd_data_serial_host sd_data_serial_host(\n        .sd_clk(sd_clk_i_pad),\n        .rst(wb_rst_i),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(DAT_dat_i),\n        .rd(rd),\n        .data_out(data_out),\n        .we(we),\n        .DAT_oe_o(DAT_oe_o),\n        .DAT_dat_o(DAT_dat_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n\n    // rx_bd/tx_bd Module\n    rx_bd rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_o_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s)\n    );\n\n    // sd_fifo_tx_filler Module\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_o(dat_o),\n        .rd(rd),\n        .empty(empty),\n        .fe(fe)\n    );\n\n    // sd_fifo_rx_filler Module\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte(m_wb_bte_o),\n        .en(en),\n        .adr(adr),\n        .sd_clk(sd_clk_i_pad),\n        .dat_i(dat_i),\n        .wr(wr),\n        .full(full),\n        .fe(fe)\n    );\n\n    // Register Update\n    assign cmd_int_busy = cmd_int_busy;\n    assign status_reg[0] = cmd_int_busy ? 1'b1 : status_reg[0];\n    assign status_reg[15:1] = STATUS_REG[15:1];\n    assign normal_int_status_reg = NORMAL_INT_REG;\n    assign error_int_status_reg = ERR_INT_REG;\n    assign Bd_isr_reg = Dat_Int_Status;\n    assign Bd_isr_enable_reg = Dat_Int_Status;\n    assign dat_in_m_tx_bd = dat_in_m_tx_bd;\n    assign dat_in_m_rx_bd = dat_in_m_rx_bd;\n\n    // Master Wishbone Interface Control\n    assign m_wb_cyc_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_cyc_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_cyc_o : 1'b0);\n    assign m_wb_stb_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_stb_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_stb_o : 1'b0);\n    assign m_wb_cti_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_cti_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_cti_o : 3'b000);\n    assign m_wb_bte = start_tx_fifo ? sd_fifo_tx_filler.m_wb_bte : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_bte : 2'b00);\n    assign m_wb_we_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_we_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_we_o : 1'b0);\n    assign m_wb_adr_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_adr_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_adr_o : 32'b0);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 20, "code": "module sd_data_serial_host(\n    input  wire sd_clk,\n    input  wire rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg [1:0] out_buff_ptr;\n    reg [1:0] in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Sub-modules\n    sd_crc_16 crc_16_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end\n        else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always_comb begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01) next_state = WRITE_DAT;\n                else if (start_dat == 2'b10) next_state = READ_WAIT;\n                else next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = WRITE_CRC;\n                else next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111) next_state = WRITE_BUSY;\n                else next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0) next_state = IDLE;\n                else next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0) next_state = READ_DAT;\n                else next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = IDLE;\n                else next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk) begin\n        if (rst) state <= IDLE;\n        else state <= next_state;\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk) begin\n        case (state)\n            IDLE: begin\n                write_buf_0 <= 0;\n                write_buf_1 <= 0;\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n            WRITE_DAT: begin\n                write_buf_0 <= data_in;\n                write_buf_1 <= 0;\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt + 1;\n                rd <= 0;\n                last_din <= write_buf_0[3:0];\n                crc_c <= crc_c + 1;\n                crc_in <= write_buf_0[SD_BUS_W-1:SD_BUS_W-4];\n                DAT_dat_o <= last_din;\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            WRITE_CRC: begin\n                DAT_oe_o <= 0;\n                crc_en <= 1;\n                crc_rst <= 0;\n                transf_cnt <= transf_cnt;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= crc_c;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            WRITE_BUSY: begin\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= crc_c;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 1;\n                busy_n <= 0;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            READ_WAIT: begin\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= crc_c;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            READ_DAT: begin\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt + 1;\n                rd <= 1;\n                last_din <= DAR_dat_i[3:0];\n                crc_c <= crc_c;\n                crc_in <= DAR_dat_i[SD_BUS_W-1:SD_BUS_W-4];\n                DAT_dat_o <= last_din;\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            default: begin\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk) begin\n        if (rst) q_start_bit <= 1;\n        else if (state == READ_WAIT && !DAT_dat_i[0] && !busy_n) q_start_bit <= 0;\n        else q_start_bit <= 1;\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk) begin\n        case (state)\n            IDLE: begin\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n            WRITE_DAT: begin\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt + 1;\n                rd <= 0;\n                last_din <= write_buf_0[3:0];\n                crc_c <= crc_c + 1;\n                crc_in <= write_buf_0[SD_BUS_W-1:SD_BUS_W-4];\n                DAT_dat_o <= last_din;\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            WRITE_CRC: begin\n                DAT_oe_o <= 0;\n                crc_en <= 1;\n                crc_rst <= 0;\n                transf_cnt <= transf_cnt;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= crc_c;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            WRITE_BUSY: begin\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= crc_c;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 1;\n                busy_n <= 0;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            READ_WAIT: begin\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= crc_c;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            READ_DAT: begin\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= transf_cnt + 1;\n                rd <= 1;\n                last_din <= DAR_dat_i[3:0];\n                crc_c <= crc_c;\n                crc_in <= DAR_dat_i[SD_BUS_W-1:SD_BUS_W-4];\n                DAT_dat_o <= last_din;\n                crc_status <= crc_status;\n                crc_s <= crc_s;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= data_send_index;\n                out_buff_ptr <= out_buff_ptr;\n                in_buff_ptr <= in_buff_ptr;\n            end\n            default: begin\n                DAT_oe_o <= 0;\n                crc_en <= 0;\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                rd <= 0;\n                last_din <= 0;\n                crc_c <= 0;\n                crc_in <= 0;\n                DAT_dat_o <= 0;\n                crc_status <= 3'b111;\n                crc_s <= 0;\n                transm_complete <= 0;\n                busy_n <= 1;\n                we <= 0;\n                data_out <= 0;\n                crc_ok <= 0;\n                busy_int <= 0;\n                data_send_index <= 0;\n                out_buff_ptr <= 0;\n                in_buff_ptr <= 0;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 18, "code": "module sd_data_master(\n    input  wire clk,\n    input  wire rst,\n    input  wire dat_in_tx,\n    input  wire free_tx_bd,\n    input  wire ack_i_s_tx,\n    input  wire dat_in_rx,\n    input  wire free_rx_bd,\n    input  wire ack_i_s_rx,\n    input  wire cmd_busy,\n    input  wire we_ack,\n    input  wire cmd_tsf_err,\n    input  wire card_status,\n    input  wire tx_empt,\n    input  wire tx_full,\n    input  wire rx_full,\n    input  wire busy_n,\n    input  wire transm_complete,\n    input  wire crc_ok,\n    input  wire Dat_Int_Status_rst,\n    input  wire transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg cmd_arg,\n    output reg cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg sys_adr,\n    output reg ack_transfer,\n    output reg Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Define parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\nparameter READ_CYCLE = 2;\nparameter BD_EMPTY = 1;\n\n// Define internal signals\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg resend_try_cnt;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr;\nreg [31:0] cmd_arg;\nreg [15:0] cmd_set;\nreg CIDAT;\nreg [7:0] Dat_Int_Status;\n\n// Define FSM state machine\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        state <= next_state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state <= GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state <= GET_RX_BD;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_TX_BD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_RX_BD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state <= RECIVE_CMD;\n                end else begin\n                    next_state <= SEND_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state <= DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= RECIVE_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state <= IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state <= STOP;\n                end else begin\n                    next_state <= DATA_TRANSFER;\n                end\n            end\n            STOP: begin\n                next_state <= STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= STOP_SEND;\n                end\n            end\n        endcase\n    end\nend\n\n// Define output signals\nassign re_s_tx = (state == GET_TX_BD) ? 1 : 0;\nassign a_cmp_tx = (state == GET_TX_BD) ? 1 : 0;\nassign re_s_rx = (state == GET_RX_BD) ? 1 : 0;\nassign a_cmp_rx = (state == GET_RX_BD) ? 1 : 0;\nassign we_req = (state == SEND_CMD) ? 1 : 0;\nassign d_write = (state == SEND_CMD) ? 1 : 0;\nassign d_read = (state == SEND_CMD) ? 1 : 0;\nassign cmd_arg = (state == SEND_CMD) ? cmd_arg : 0;\nassign cmd_set = (state == SEND_CMD) ? cmd_set : 0;\nassign start_tx_fifo = (state == SEND_CMD) ? 1 : 0;\nassign start_rx_fifo = (state == SEND_CMD) ? 1 : 0;\nassign sys_adr = (state == SEND_CMD) ? sys_adr : 0;\nassign ack_transfer = (state == DATA_TRANSFER) ? 1 : 0;\nassign Dat_Int_Status = (state == DATA_TRANSFER) ? Dat_Int_Status : 0;\nassign CIDAT = (state == DATA_TRANSFER) ? CIDAT : 0;\n\n// Define internal logic\nalways @(posedge clk) begin\n    if (rst) begin\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            GET_TX_BD: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 1;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            GET_RX_BD: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 1;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            SEND_CMD: begin\n                send_done <= 1;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            RECIVE_CMD: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            DATA_TRANSFER: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 1;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            STOP: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            STOP_SEND: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= resend_try_cnt + 1;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n        endcase\n    end\nend\n\n// Define output logic\nalways @(posedge clk) begin\n    if (rst) begin\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            GET_TX_BD: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            GET_RX_BD: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            SEND_CMD: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            RECIVE_CMD: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            DATA_TRANSFER: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            STOP: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            STOP_SEND: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 15, "code": "module sd_cmd_serial_host(\n    input  wire  SD_CLK_IN,\n    input  wire  RST_IN,\n    input  wire  [15:0] SETTING_IN,\n    input  wire  [39:0] CMD_IN,\n    input  wire  REQ_IN,\n    input  wire  ACK_IN,\n    input  wire  cmd_dat_i,\n    output wire  [39:0] CMD_OUT,\n    output wire  ACK_OUT,\n    output wire  REQ_OUT,\n    output wire  [7:0] STATUS,\n    output wire  cmd_oe_o,\n    output wire  cmd_out_o,\n    output wire  st_dat_t\n);\n\n    // Internal Constants and Parameters\n    localparam INIT_DELAY = 2;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n    localparam INIT = 8'b00000000;\n    localparam IDLE = 8'b00000001;\n    localparam WRITE_WR = 8'b00000010;\n    localparam DLY_WR = 8'b00000011;\n    localparam READ_WR = 8'b00000100;\n    localparam DLY_READ = 8'b00000101;\n    localparam ACK_WR = 8'b00000110;\n    localparam WRITE_WO = 8'b00000111;\n    localparam DLY_WO = 8'b00001000;\n    localparam ACK_WO = 8'b00001001;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    reg [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO\n    always_comb begin\n        case(state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= Response_Size + EIGHT_PAD)\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = INIT;\n            end\n        endcase\n    end\n\n    // FSM_SEQ\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            Req_internal_in <= 0;\n        else\n            Req_internal_in <= q;\n    end\n\n    always_ff @(posedge SD_CLK_IN)\n    begin\n        q <= REQ_IN;\n    end\n\n    // ACK_SYNC\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            Ack_internal_in <= 0;\n        else\n            Ack_internal_in <= q1;\n    end\n\n    always_ff @(posedge SD_CLK_IN)\n    begin\n        q1 <= ACK_IN;\n    end\n\n    // COMMAND_DECODER\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n        begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end\n        else\n        begin\n            if (Req_internal_in)\n            begin\n                Response_Size <= SETTING_IN[6:0];\n                CRC_Check_On <= SETTING_IN[7];\n                Delay_Cycler <= SETTING_IN[10:8];\n                block_write <= SETTING_IN[11];\n                block_read <= SETTING_IN[12];\n                word_select <= SETTING_IN[14:13];\n                In_Buff <= CMD_IN;\n                if (SETTING_IN[6:0] > 0)\n                begin\n                    Write_Read <= 1;\n                    Write_Only <= 0;\n                end\n                else\n                begin\n                    Write_Read <= 0;\n                    Write_Only <= 1;\n                end\n                DECODER_ACK <= 0;\n            end\n            else\n            begin\n                if (DECODER_ACK)\n                begin\n                    Write_Read <= 0;\n                    Write_Only <= 0;\n                    DECODER_ACK <= 1;\n                end\n            end\n        end\n    end\n\n    // FSM_OUT\n    always_ff @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n        begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end\n        else\n        begin\n            case(state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    CRC_Valid <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    if (Cmd_Cnt == 0)\n                    begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering)\n                    begin\n                        cmd_oe_o <= 1;\n                        if (Bit_Nr > 8)\n                        begin\n                            cmd_out_o <= 1;\n                            if (Bit_Nr > 9)\n                            begin\n                                CRC_OUT <= CRC_OUT;\n                            end\n                        end\n                        else if (Bit_Nr <= 8 && Bit_Nr >= 2)\n                        begin\n                            CRC_OUT <= CRC_OUT;\n                            st_dat_t <= st_dat_t;\n                        end\n                        else\n                        begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                    else\n                    begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff;\n                    end\n                end\n                WRITE_WO: begin\n                    if (Cmd_Cnt == 0)\n                    begin\n                        STATUS <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering)\n                    begin\n                        cmd_oe_o <= 1;\n                        if (Bit_Nr > 8)\n                        begin\n                            cmd_out_o <= 1;\n                            if (Bit_Nr > 9)\n                            begin\n                                CRC_OUT <= CRC_OUT;\n                            end\n                        end\n                        else if (Bit_Nr <= 8 && Bit_Nr >= 2)\n                        begin\n                            CRC_OUT <= CRC_OUT;\n                            st_dat_t <= st_dat_t;\n                        end\n                        else\n                        begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                    else\n                    begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff;\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0)\n                    begin\n                        STATUS <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    CRC_Valid <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0)\n                    begin\n                        STATUS <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    CRC_Valid <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_Enable <= 0;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    if (Cmd_Cnt == 1)\n                    begin\n                        STATUS <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end\n                    else if (Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size)\n                    begin\n                        cmd_dat_i <= cmd_dat_i;\n                        Out_Buff <= Out_Buff;\n                        CRC_IN <= cmd_dat_i;\n                        CRC_OUT <= CRC_OUT;\n                    end\n                    else if ((Cmd_Cnt - Response_Size) <= 6)\n                    begin\n                        CRC_IN <= cmd_dat_i;\n                        CRC_OUT <= CRC_OUT;\n                    end\n                    else\n                    begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On)\n                        begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end\n                        else\n                        begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= st_dat_t;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0)\n                    begin\n                        STATUS <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end\n                    else if (Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    CRC_Valid <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n                default: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    CRC_Valid <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n            endcase\n        end\n    end\n\n    // sd_crc_7\n    sd_crc_7 sd_crc_7_module(\n        .BITVAL(cmd_dat_i),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_OUT)\n    );\n\n    // Assign Outputs\n    CMD_OUT <= Out_Buff;\n    ACK_OUT <= FSM_ACK;\n    REQ_OUT <= FSM_ACK;\n    STATUS <= STATUS;\n    cmd_oe_o <= cmd_oe_o;\n    cmd_out_o <= cmd_out_o;\n    st_dat_t <= st_dat_t;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 16, "code": "module sd_cmd_serial_host(\n    input  wire clk,\n    input  wire rst,\n    input  wire [15:0] setting_in,\n    input  wire [39:0] cmd_in,\n    input  wire req_in,\n    input  wire ack_in,\n    input  wire cmd_dat_i,\n    output wire [39:0] cmd_out,\n    output wire ack_out,\n    output wire req_out,\n    output wire [7:0] status,\n    output wire cmd_oe_o,\n    output wire cmd_out_o,\n    output wire [1:0] st_dat_t\n);\n\n    // Internal signals\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg [2:0] delay_cnt;\n    reg [7:0] cmd_cnt;\n    reg [2:0] response_size;\n    reg [1:0] word_select;\n    reg [1:0] block_write;\n    reg [1:0] block_read;\n    reg [1:0] crc_check_on;\n    reg [1:0] crc_valid;\n    reg [1:0] crc_buffering;\n    reg [1:0] crc_enable;\n    reg [1:0] crc_out;\n    reg [1:0] crc_in;\n    reg [1:0] crc_rst;\n    reg [1:0] cmd_oe;\n    reg [1:0] cmd_out_o;\n    reg [1:0] fsm_ack;\n    reg [1:0] decoder_ack;\n    reg [1:0] req_internal_in;\n    reg [1:0] ack_internal_in;\n    reg [1:0] q;\n    reg [1:0] q1;\n\n    // FSM_COMBO\n    always_comb begin\n        case(state)\n            INIT: begin\n                if (cmd_cnt >= INIT_DELAY) next_state = IDLE;\n                else next_state = INIT;\n            end\n            IDLE: begin\n                if (write_read) next_state = WRITE_WR;\n                else if (write_only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (cmd_cnt >= SEND_SIZE - 1) next_state = DLY_WR;\n                else next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (cmd_cnt >= SEND_SIZE - 1) next_state = DLY_WO;\n                else next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (delay_cnt >= NCR && !cmd_dat_i) next_state = READ_WR;\n                else next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (delay_cnt >= Delay_Cycler) next_state = ACK_WO;\n                else next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (cmd_cnt >= Response_Size + EIGHT_PAD) next_state = DLY_READ;\n                else next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (ack_internal_in) next_state = ACK_WR;\n                else next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= INIT;\n            delay_cnt <= 0;\n            cmd_cnt <= 0;\n            response_size <= 0;\n            word_select <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            crc_check_on <= 0;\n            crc_valid <= 0;\n            crc_buffering <= 0;\n            crc_enable <= 0;\n            crc_out <= 0;\n            crc_in <= 0;\n            crc_rst <= 0;\n            cmd_oe <= 1;\n            cmd_out_o <= 1;\n            fsm_ack <= 1;\n            decoder_ack <= 0;\n            req_internal_in <= 0;\n            ack_internal_in <= 0;\n            q <= 0;\n            q1 <= 0;\n        end\n        else begin\n            state <= next_state;\n            delay_cnt <= delay_cnt + 1;\n            cmd_cnt <= cmd_cnt + 1;\n            response_size <= response_size;\n            word_select <= word_select;\n            block_write <= block_write;\n            block_read <= block_read;\n            crc_check_on <= crc_check_on;\n            crc_valid <= crc_valid;\n            crc_buffering <= crc_buffering;\n            crc_enable <= crc_enable;\n            crc_out <= crc_out;\n            crc_in <= crc_in;\n            crc_rst <= crc_rst;\n            cmd_oe <= cmd_oe;\n            cmd_out_o <= cmd_out_o;\n            fsm_ack <= fsm_ack;\n            decoder_ack <= decoder_ack;\n            req_internal_in <= req_internal_in;\n            ack_internal_in <= ack_internal_in;\n            q <= q;\n            q1 <= q1;\n        end\n    end\n\n    // REQ_SYNC\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            req_internal_in <= 0;\n            q <= 0;\n        end\n        else begin\n            q <= req_in;\n            req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            ack_internal_in <= 0;\n            q1 <= 0;\n        end\n        else begin\n            q1 <= ack_in;\n            ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            delay_cnt <= 0;\n            response_size <= 0;\n            decoder_ack <= 0;\n            write_read <= 0;\n            write_only <= 0;\n            crc_check_on <= 0;\n            crc_buffering <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end\n        else begin\n            if (req_internal_in) begin\n                response_size <= setting_in[6:0];\n                crc_check_on <= setting_in[7];\n                delay_cnt <= setting_in[10:8];\n                block_write <= setting_in[11];\n                block_read <= setting_in[12];\n                word_select <= setting_in[14:13];\n                write_read <= (response_size > 0);\n                write_only <= !write_read;\n                decoder_ack <= 0;\n            end\n            else if (!write_read && !write_only) begin\n                decoder_ack <= 1;\n            end\n        end\n    end\n\n    // FSM_OUT\n    always_comb begin\n        case(state)\n            INIT: begin\n                cmd_oe <= 1;\n                cmd_out_o <= 1;\n                fsm_ack <= 1;\n                req_out <= 0;\n                crc_rst <= 1;\n                crc_enable <= 0;\n                crc_out <= 0;\n                crc_in <= 0;\n                cmd_out <= 0;\n                st_dat_t <= 0;\n            end\n            IDLE: begin\n                cmd_oe <= 0;\n                cmd_out_o <= 0;\n                fsm_ack <= 0;\n                req_out <= 0;\n                crc_rst <= 0;\n                crc_enable <= 0;\n                crc_out <= 0;\n                crc_in <= 0;\n                cmd_out <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                cmd_oe <= 1;\n                cmd_out_o <= 1;\n                fsm_ack <= 0;\n                req_out <= 1;\n                crc_rst <= 0;\n                crc_enable <= 1;\n                crc_out <= 0;\n                crc_in <= 0;\n                cmd_out <= cmd_in;\n                st_dat_t <= 2'b00;\n            end\n            WRITE_WO: begin\n                cmd_oe <= 1;\n                cmd_out_o <= 1;\n                fsm_ack <= 0;\n                req_out <= 1;\n                crc_rst <= 0;\n                crc_enable <= 1;\n                crc_out <= 0;\n                crc_in <= 0;\n                cmd_out <= cmd_in;\n                st_dat_t <= 2'b01;\n            end\n            DLY_WR: begin\n                cmd_oe <= 0;\n                cmd_out_o <= 0;\n                fsm_ack <= 0;\n                req_out <= 0;\n                crc_rst <= 0;\n                crc_enable <= 0;\n                crc_out <= 0;\n                crc_in <= 0;\n                cmd_out <= 0;\n                st_dat_t <= 0;\n            end\n            DLY_WO: begin\n                cmd_oe <= 0;\n                cmd_out_o <= 0;\n                fsm_ack <= 0;\n                req_out <= 0;\n                crc_rst <= 0;\n                crc_enable <= 0;\n                crc_out <= 0;\n                crc_in <= 0;\n                cmd_out <= 0;\n                st_dat_t <= 0;\n            end\n            READ_WR: begin\n                cmd_oe <= 0;\n                cmd_out_o <= 0;\n                fsm_ack <= 0;\n                req_out <= 1;\n                crc_rst <= 0;\n                crc_enable <= 1;\n                crc_out <= 0;\n                crc_in <= 0;\n                cmd_out <= 0;\n                st_dat_t <= 2'b10;\n            end\n            DLY_READ: begin\n                cmd_oe <= 0;\n                cmd_out_o <= 0;\n                fsm_ack <= 0;\n                req_out <= 0;\n                crc_rst <= 0;\n                crc_enable <= 0;\n                crc_out <= 0;\n                crc_in <= 0;\n                cmd_out <= 0;\n                st_dat_t <= 0;\n            end\n            ACK_WO: begin\n                cmd_oe <= 0;\n                cmd_out_o <= 0;\n                fsm_ack <= 1;\n                req_out <= 0;\n                crc_rst <= 0;\n                crc_enable <= 0;\n                crc_out <= 0;\n                crc_in <= 0;\n                cmd_out <= 0;\n                st_dat_t <= 0;\n            end\n            ACK_WR: begin\n                cmd_oe <= 0;\n                cmd_out_o <= 0;\n                fsm_ack <= 1;\n                req_out <= 0;\n                crc_rst <= 0;\n                crc_enable <= 0;\n                crc_out <= 0;\n                crc_in <= 0;\n                cmd_out <= 0;\n                st_dat_t <= 0;\n            end\n            default: begin\n                cmd_oe <= 0;\n                cmd_out_o <= 0;\n                fsm_ack <= 0;\n                req_out <= 0;\n                crc_rst <= 0;\n                crc_enable <= 0;\n                crc_out <= 0;\n                crc_in <= 0;\n                cmd_out <= 0;\n                st_dat_t <= 0;\n            end\n        endcase\n    end\n\n    // sd_crc_7\n    sd_crc_7 sd_crc_7_inst(\n        .bitval(cmd_dat_i),\n        .enable(crc_enable),\n        .clk(clk),\n        .rst(crc_rst),\n        .crc(crc_out)\n    );\n\n    // Assign outputs\n    cmd_out <= cmd_out_o ? cmd_in : 0;\n    ack_out <= fsm_ack;\n    req_out <= req_out;\n    status <= {crc_valid, crc_check_on, block_read, block_write, cmd_cnt, response_size};\n    cmd_oe_o <= cmd_oe;\n    cmd_out_o <= cmd_out_o;\n    st_dat_t <= st_dat_t;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 19, "code": "module sd_data_master(\n    input  wire clk,\n    input  wire rst,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input  wire [BD_WIDTH-1:0] free_tx_bd,\n    input  wire [BD_WIDTH-1:0] free_rx_bd,\n    input  wire ack_i_s_tx,\n    input  wire ack_i_s_rx,\n    input  wire cmd_busy,\n    input  wire we_ack,\n    input  wire cmd_tsf_err,\n    input  wire [4:0] card_status,\n    input  wire tx_empt,\n    input  wire tx_full,\n    input  wire rx_full,\n    input  wire busy_n,\n    input  wire transm_complete,\n    input  wire crc_ok,\n    input  wire Dat_Int_Status_rst,\n    input  wire [1:0] transfer_type,\n    output wire re_s_tx,\n    output wire a_cmp_tx,\n    output wire re_s_rx,\n    output wire a_cmp_rx,\n    output wire we_req,\n    output wire d_write,\n    output wire d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire start_tx_fifo,\n    output wire start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire ack_transfer,\n    output wire [7:0] Dat_Int_Status,\n    output wire CIDAT\n);\n\n// Internal signals\nreg [1:0] send_done;\nreg [1:0] rec_done;\nreg [1:0] rec_failed;\nreg [1:0] tx_cycle;\nreg [1:0] rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg [1:0] trans_done;\nreg [1:0] trans_failed;\nreg [1:0] internal_transm_complete;\nreg [1:0] transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr;\nreg [31:0] cmd_arg;\nreg [15:0] cmd_set;\nreg [1:0] CIDAT;\nreg [7:0] Dat_Int_Status;\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\nparameter READ_CYCLE = 2;\nparameter BD_EMPTY = BD_SIZE / 2;\n\n// FSM state machine\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd!= BD_EMPTY) begin\n                    next_state <= GET_TX_BD;\n                end else if (free_rx_bd!= BD_EMPTY) begin\n                    next_state <= GET_RX_BD;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_TX_BD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_RX_BD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state <= RECIVE_CMD;\n                end else begin\n                    next_state <= SEND_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state <= DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= RECIVE_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state <= IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state <= STOP;\n                end else begin\n                    next_state <= DATA_TRANSFER;\n                end\n            end\n            STOP: begin\n                next_state <= STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= STOP_SEND;\n                end\n            end\n            default: begin\n                next_state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// FSM state machine logic\nalways @(posedge clk) begin\n    if (rst) begin\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= dat_in_tx;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            GET_RX_BD: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 1;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= dat_in_rx;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            SEND_CMD: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 1;\n                d_write <= 0;\n                d_read <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            RECIVE_CMD: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            DATA_TRANSFER: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            STOP: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            STOP_SEND: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            default: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n        endcase\n    end\nend\n\n// FSM output logic\nalways @(posedge clk) begin\n    if (rst) begin\n        CIDAT <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            GET_TX_BD: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            GET_RX_BD: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            SEND_CMD: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            RECIVE_CMD: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            DATA_TRANSFER: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            STOP: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            STOP_SEND: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n            default: begin\n                CIDAT <= 0;\n                Dat_Int_Status <= 0;\n            end\n        endcase\n    end\nend\n\n// FSM internal logic\nalways @(posedge clk) begin\n    if (rst) begin\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n            end\n            GET_TX_BD: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= bd_cnt + 1;\n                sys_adr <= dat_in_tx;\n                cmd_arg <= 0;\n                cmd_set <= CMD24;\n            end\n            GET_RX_BD: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= bd_cnt + 1;\n                sys_adr <= dat_in_rx;\n                cmd_arg <= 0;\n                cmd_set <= CMD17;\n            end\n            SEND_CMD: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 1;\n                rx_cycle <= 0;\n                resend_try_cnt <= resend_try_cnt + 1;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= bd_cnt + 1;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n            end\n            RECIVE_CMD: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 1;\n                resend_try_cnt <= resend_try_cnt + 1;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= bd_cnt + 1;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n            end\n            DATA_TRANSFER: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 1;\n                rx_cycle <= 1;\n                resend_try_cnt <= resend_try_cnt + 1;\n                trans_done <= 1;\n                trans_failed <= 0;\n                internal_transm_complete <= 1;\n                transm_complete_q <= 1;\n                bd_cnt <= bd_cnt + 1;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n            end\n            STOP: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= resend_try_cnt + 1;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= bd_cnt + 1;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= CMD12;\n            end\n            STOP_SEND: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= resend_try_cnt + 1;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= bd_cnt + 1;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n            end\n            default: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 15, "code": "module sd_controller_wb(\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire we_m_tx_bd,\n    output wire we_m_rx_bd,\n    output wire new_cmd,\n    output wire we_ack,\n    output wire int_ack,\n    output wire cmd_int_busy,\n    output wire int_busy,\n    input  wire write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0] clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0] Bd_isr_reg,\n    output wire [7:0] Bd_isr_enable_reg,\n    output wire Bd_isr_reset,\n    output wire normal_isr_reset,\n    output wire error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    reg [31:0] argument_reg;\n    reg [15:0] cmd_setting_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [7:0] software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0] clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [7:0] Bd_isr_reg;\n    reg [7:0] Bd_isr_enable_reg;\n    reg Bd_isr_reset;\n    reg normal_isr_reset;\n    reg error_isr_reset;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    reg we_m_tx_bd;\n    reg we_m_rx_bd;\n    reg new_cmd;\n    reg we_ack;\n    reg int_ack;\n    reg cmd_int_busy;\n    reg int_busy;\n    reg write_req_s;\n    reg [15:0] cmd_set_s;\n    reg [31:0] cmd_arg_s;\n\n    always @(posedge wb_clk_i) begin\n        if(wb_rst_i) begin\n            argument_reg <= 32'd0;\n            cmd_setting_reg <= 16'd0;\n            status_reg <= 16'd0;\n            cmd_resp_1 <= 32'd0;\n            software_reset_reg <= 8'd0;\n            time_out_reg <= 16'd0;\n            normal_int_status_reg <= 16'd0;\n            error_int_status_reg <= 16'd0;\n            normal_int_signal_enable_reg <= 16'd0;\n            error_int_signal_enable_reg <= 16'd0;\n            clock_divider <= 8'd0;\n            Bd_Status_reg <= 16'd0;\n            Bd_isr_reg <= 8'd0;\n            Bd_isr_enable_reg <= 8'd0;\n            dat_in_m_tx_bd <= (RAM_MEM_WIDTH-1 downto 0)'(0);\n            dat_in_m_rx_bd <= (RAM_MEM_WIDTH-1 downto 0)'(0);\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            write_req_s <= 1'b0;\n            cmd_set_s <= 16'd0;\n            cmd_arg_s <= 32'd0;\n        end else begin\n            if(wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n                wb_ack_o <= 1'b1;\n            end else begin\n                wb_ack_o <= 1'b0;\n            end\n\n            if(wb_stb_i && wb_cyc_i && wb_we_i) begin\n                case(wb_adr_i)\n                    8'h00: begin\n                        argument_reg <= wb_dat_i;\n                    end\n                    8'h04: begin\n                        cmd_setting_reg <= wb_dat_i;\n                    end\n                    8'h08: begin\n                        status_reg <= wb_dat_i;\n                    end\n                    8'h0c: begin\n                        cmd_resp_1 <= wb_dat_i;\n                    end\n                    8'h1c: begin\n                        //Controller Setting\n                    end\n                    8'h20: begin\n                        //Block Size\n                    end\n                    8'h24: begin\n                        //Power Control\n                    end\n                    8'h28: begin\n                        software_reset_reg <= wb_dat_i;\n                    end\n                    8'h2c: begin\n                        time_out_reg <= wb_dat_i;\n                    end\n                    8'h30: begin\n                        normal_int_status_reg <= wb_dat_i;\n                    end\n                    8'h34: begin\n                        error_int_status_reg <= wb_dat_i;\n                    end\n                    8'h38: begin\n                        normal_int_signal_enable_reg <= wb_dat_i;\n                    end\n                    8'h3c: begin\n                        error_int_signal_enable_reg <= wb_dat_i;\n                    end\n                    8'h48: begin\n                        //Capability\n                    end\n                    8'h4c: begin\n                        clock_divider <= wb_dat_i;\n                    end\n                    8'h50: begin\n                        Bd_Status_reg <= wb_dat_i;\n                    end\n                    8'h54: begin\n                        Bd_isr_reg <= wb_dat_i;\n                    end\n                    8'h58: begin\n                        Bd_isr_enable_reg <= wb_dat_i;\n                    end\n                    8'h60: begin\n                        //BD RX\n                        if(RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else if(RAM_MEM_WIDTH == 16) begin\n                            dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                    end\n                    8'h80: begin\n                        //BD TX\n                        if(RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                        end else if(RAM_MEM_WIDTH == 16) begin\n                            dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                        we_m_tx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                    end\n                    default: begin\n                        wb_ack_o <= 1'b0;\n                    end\n                endcase\n            end else if(wb_stb_i && wb_cyc_i) begin\n                case(wb_adr_i)\n                    8'h00: begin\n                        wb_dat_o <= argument_reg;\n                    end\n                    8'h04: begin\n                        wb_dat_o <= cmd_setting_reg;\n                    end\n                    8'h08: begin\n                        wb_dat_o <= status_reg;\n                    end\n                    8'h0c: begin\n                        wb_dat_o <= cmd_resp_1;\n                    end\n                    8'h1c: begin\n                        //Controller Setting\n                    end\n                    8'h20: begin\n                        //Block Size\n                    end\n                    8'h24: begin\n                        //Power Control\n                    end\n                    8'h28: begin\n                        wb_dat_o <= software_reset_reg;\n                    end\n                    8'h2c: begin\n                        wb_dat_o <= time_out_reg;\n                    end\n                    8'h30: begin\n                        wb_dat_o <= normal_int_status_reg;\n                    end\n                    8'h34: begin\n                        wb_dat_o <= error_int_status_reg;\n                    end\n                    8'h38: begin\n                        wb_dat_o <= normal_int_signal_enable_reg;\n                    end\n                    8'h3c: begin\n                        wb_dat_o <= error_int_signal_enable_reg;\n                    end\n                    8'h48: begin\n                        //Capability\n                    end\n                    8'h4c: begin\n                        wb_dat_o <= clock_divider;\n                    end\n                    8'h50: begin\n                        wb_dat_o <= Bd_Status_reg;\n                    end\n                    8'h54: begin\n                        wb_dat_o <= Bd_isr_reg;\n                    end\n                    8'h58: begin\n                        wb_dat_o <= Bd_isr_enable_reg;\n                    end\n                    8'h60: begin\n                        //BD RX\n                        if(RAM_MEM_WIDTH == 32) begin\n                            wb_dat_o <= dat_in_m_rx_bd;\n                        end else if(RAM_MEM_WIDTH == 16) begin\n                            wb_dat_o[15:0] <= dat_in_m_rx_bd[15:0];\n                            wb_dat_o[31:16] <= dat_in_m_rx_bd[31:16];\n                        end\n                    end\n                    8'h80: begin\n                        //BD TX\n                        if(RAM_MEM_WIDTH == 32) begin\n                            wb_dat_o <= dat_in_m_tx_bd;\n                        end else if(RAM_MEM_WIDTH == 16) begin\n                            wb_dat_o[15:0] <= dat_in_m_tx_bd[15:0];\n                            wb_dat_o[31:16] <= dat_in_m_tx_bd[31:16];\n                        end\n                    end\n                    default: begin\n                        wb_ack_o <= 1'b0;\n                    end\n                endcase\n            end else begin\n                wb_ack_o <= 1'b0;\n            end\n\n            if(write_req_s) begin\n                we_ack <= 1'b1;\n            end else begin\n                we_ack <= 1'b0;\n            end\n\n            if(cmd_arg_s != 32'd0) begin\n                new_cmd <= 1'b1;\n            end else begin\n                new_cmd <= 1'b0;\n            end\n\n            if(we_m_tx_bd || we_m_rx_bd) begin\n                int_ack <= 1'b0;\n            end else begin\n                int_ack <= 1'b1;\n            end\n\n            if(we_m_tx_bd) begin\n                we_m_tx_bd <= 1'b0;\n            end\n\n            if(we_m_rx_bd) begin\n                we_m_rx_bd <= 1'b0;\n            end\n\n            if(int_ack) begin\n                if(we_m_tx_bd) begin\n                    dat_in_m_tx_bd <= 32'd0;\n                end\n\n                if(we_m_rx_bd) begin\n                    dat_in_m_rx_bd <= 32'd0;\n                end\n            end\n\n            if(cmd_int_busy) begin\n                cmd_int_busy <= 1'b0;\n            end\n\n            if(int_busy) begin\n                int_busy <= 1'b0;\n            end\n\n            if(write_req_s) begin\n                write_req_s <= 1'b0;\n            end\n\n            if(cmd_arg_s != 32'd0) begin\n                cmd_arg_s <= 32'd0;\n            end\n\n            if(cmd_set_s != 16'd0) begin\n                cmd_set_s <= 16'd0;\n            end\n        end\n    end\n\n    assign we_m_tx_bd = we_m_tx_bd;\n    assign we_m_rx_bd = we_m_rx_bd;\n    assign new_cmd = new_cmd;\n    assign we_ack = we_ack;\n    assign int_ack = int_ack;\n    assign cmd_int_busy = cmd_int_busy;\n    assign int_busy = int_busy;\n    assign write_req_s = write_req_s;\n    assign cmd_set_s = cmd_set_s;\n    assign cmd_arg_s = cmd_arg_s;\n    assign argument_reg = argument_reg;\n    assign cmd_setting_reg = cmd_setting_reg;\n    assign status_reg = status_reg;\n    assign cmd_resp_1 = cmd_resp_1;\n    assign software_reset_reg = software_reset_reg;\n    assign time_out_reg = time_out_reg;\n    assign normal_int_status_reg = normal_int_status_reg;\n    assign error_int_status_reg = error_int_status_reg;\n    assign normal_int_signal_enable_reg = normal_int_signal_enable_reg;\n    assign error_int_signal_enable_reg = error_int_signal_enable_reg;\n    assign clock_divider = clock_divider;\n    assign Bd_Status_reg = Bd_Status_reg;\n    assign Bd_isr_reg = Bd_isr_reg;\n    assign Bd_isr_enable_reg = Bd_isr_enable_reg;\n    assign dat_in_m_tx_bd = dat_in_m_tx_bd;\n    assign dat_in_m_rx_bd = dat_in_m_rx_bd;\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 20, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input dat_in_tx,\n    input free_tx_bd,\n    input ack_i_s_tx,\n    input dat_in_rx,\n    input free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input transfer_type,\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output cmd_arg,\n    output cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output sys_adr,\n    output ack_transfer,\n    output Dat_Int_Status,\n    output CIDAT\n);\n\n    // FSM state machine\n    reg [8:0] state;\n    reg [8:0] next_state;\n\n    // ... (rest of the code remains the same)\n\n    always @(posedge clk) begin\n        if (rst) begin\n            state <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // ... (rest of the code remains the same)\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 17, "code": "module sd_cmd_serial_host(\n    input  wire sd_clk_i_pad,\n    input  wire rst_i_pad,\n    input  wire [15:0] setting_in,\n    input  wire [39:0] cmd_in,\n    input  wire req_in,\n    input  wire ack_in,\n    input  wire cmd_dat_i,\n\n    output wire [39:0] cmd_out,\n    output wire ack_out,\n    output wire req_out,\n    output wire [7:0] status,\n    output wire cmd_oe_o,\n    output wire cmd_out_o,\n    output wire st_dat_t\n);\n\n// Internal constants and parameters\nparameter INIT_DELAY = 2;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\nparameter INIT = 8'b0000_0000;\nparameter IDLE = 8'b0000_0001;\nparameter WRITE_WR = 8'b0000_0010;\nparameter DLY_WR = 8'b0000_0011;\nparameter READ_WR = 8'b0000_0100;\nparameter DLY_READ = 8'b0000_0101;\nparameter ACK_WR = 8'b0000_0110;\nparameter WRITE_WO = 8'b0000_0111;\nparameter DLY_WO = 8'b0000_1000;\nparameter ACK_WO = 8'b0000_1001;\n\n// Internal signals\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg [7:0] Delay_Cycler;\nreg [7:0] Response_Size;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [5:0] word_select_counter;\nreg CRC_RST;\nreg [7:0] CRC_IN;\nreg [7:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [8:0] Cmd_Cnt;\nreg [3:0] Delay_Cnt;\n\n// State machine\nalways @(posedge sd_clk_i_pad) begin\n    if (rst_i_pad) begin\n        state <= INIT;\n    end else begin\n        case (state)\n            INIT: begin\n                next_state <= IDLE;\n            end\n            IDLE: begin\n                if (req_in) begin\n                    next_state <= WRITE_WR;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n            WRITE_WR: begin\n                if (cmd_dat_i) begin\n                    next_state <= DLY_WR;\n                end else begin\n                    next_state <= WRITE_WR;\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cycler == Read_Delay) begin\n                    next_state <= READ_WR;\n                end else begin\n                    next_state <= DLY_WR;\n                end\n            end\n            READ_WR: begin\n                if (cmd_dat_i) begin\n                    next_state <= DLY_READ;\n                end else begin\n                    next_state <= READ_WR;\n                end\n            end\n            DLY_READ: begin\n                if (Delay_Cycler == Read_Delay) begin\n                    next_state <= ACK_WR;\n                end else begin\n                    next_state <= DLY_READ;\n                end\n            end\n            ACK_WR: begin\n                if (ack_in) begin\n                    next_state <= WRITE_WO;\n                end else begin\n                    next_state <= ACK_WR;\n                end\n            end\n            WRITE_WO: begin\n                if (cmd_dat_i) begin\n                    next_state <= DLY_WO;\n                end else begin\n                    next_state <= WRITE_WO;\n                end\n            end\n            DLY_WO: begin\n                if (Delay_Cycler == Read_Delay) begin\n                    next_state <= ACK_WO;\n                end else begin\n                    next_state <= DLY_WO;\n                end\n            end\n            ACK_WO: begin\n                if (ack_in) begin\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= ACK_WO;\n                end\n            end\n            default: begin\n                next_state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// Output logic\nassign cmd_out = Out_Buff;\nassign ack_out = CRC_Valid;\nassign req_out = Write_Read;\nassign status = Delay_Cycler;\nassign cmd_oe_o = Write_Only;\nassign cmd_out_o = cmd_dat_i;\nassign st_dat_t = CRC_OUT;\n\n// CRC logic\nalways @(posedge sd_clk_i_pad) begin\n    if (rst_i_pad) begin\n        CRC_RST <= 1;\n    end else begin\n        if (CRC_RST) begin\n            CRC_IN <= 0;\n            CRC_VAL <= 0;\n            CRC_OUT <= 0;\n            CRC_Valid <= 0;\n            CRC_Check_On <= 0;\n            Crc_Buffering <= 0;\n            CRC_Enable <= 0;\n        end else begin\n            if (CRC_Enable) begin\n                CRC_IN <= CRC_IN << 1;\n                CRC_VAL <= CRC_VAL << 1;\n                CRC_OUT <= CRC_OUT << 1;\n                if (CRC_IN[7]) begin\n                    CRC_VAL <= CRC_VAL ^ CRC_VAL;\n                end\n                if (CRC_VAL[7]) begin\n                    CRC_OUT <= CRC_OUT ^ CRC_OUT;\n                end\n                if (CRC_Check_On) begin\n                    CRC_Valid <= 1;\n                end\n            end else begin\n                if (CRC_RST) begin\n                    CRC_RST <= 1;\n                end else begin\n                    CRC_Enable <= 1;\n                end\n            end\n        end\n    end\nend\n\n// Delay logic\nalways @(posedge sd_clk_i_pad) begin\n    if (rst_i_pad) begin\n        Delay_Cycler <= 0;\n    end else begin\n        if (Delay_Cycler == Read_Delay) begin\n            Delay_Cycler <= 0;\n        end else begin\n            Delay_Cycler <= Delay_Cycler + 1;\n        end\n    end\nend\n\n// Word select counter\nalways @(posedge sd_clk_i_pad) begin\n    if (rst_i_pad) begin\n        word_select_counter <= 0;\n    end else begin\n        if (word_select_counter == SEND_SIZE - 1) begin\n            word_select_counter <= 0;\n        end else begin\n            word_select_counter <= word_select_counter + 1;\n        end\n    end\nend\n\n// In and Out Buffers\nalways @(posedge sd_clk_i_pad) begin\n    if (rst_i_pad) begin\n        In_Buff <= 0;\n        Out_Buff <= 0;\n    end else begin\n        if (Write_Read) begin\n            In_Buff <= cmd_in;\n        end else begin\n            Out_Buff <= In_Buff;\n        end\n    end\nend\n\n// Write and Read logic\nalways @(posedge sd_clk_i_pad) begin\n    if (rst_i_pad) begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n    end else begin\n        if (Write_Read) begin\n            Write_Only <= 1;\n        end else begin\n            Write_Read <= 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 16, "code": "module sd_controller_wb(\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire         wb_we_i,\n    input  wire         wb_cyc_i,\n    input  wire         wb_stb_i,\n    output wire         wb_ack_o,\n    output wire         we_m_tx_bd,\n    output wire         we_m_rx_bd,\n    output wire         new_cmd,\n    output wire         we_ack,\n    output wire         int_ack,\n    output wire         cmd_int_busy,\n    output wire         int_busy,\n    input  wire         write_req_s,\n    input  wire [15:0]  cmd_set_s,\n    input  wire [31:0]  cmd_arg_s,\n    output wire [31:0]  argument_reg,\n    output wire [15:0]  cmd_setting_reg,\n    input  wire [15:0]  status_reg,\n    input  wire [31:0]  cmd_resp_1,\n    output wire [7:0]   software_reset_reg,\n    output wire [15:0]  time_out_reg,\n    input  wire [15:0]  normal_int_status_reg,\n    input  wire [15:0]  error_int_status_reg,\n    output wire [15:0]  normal_int_signal_enable_reg,\n    output wire [15:0]  error_int_signal_enable_reg,\n    output wire [7:0]   clock_divider,\n    input  wire [15:0]  Bd_Status_reg,\n    input  wire [7:0]   Bd_isr_reg,\n    output wire [7:0]   Bd_isr_enable_reg,\n    output wire         Bd_isr_reset,\n    output wire         normal_isr_reset,\n    output wire         error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n// Define the width of the RAM memory\nparameter RAM_MEM_WIDTH = 32;\n\n// Define the width of the BD buffer\nparameter BD_WIDTH = 8;\n\n// Define the size of the BD buffer\nparameter BD_SIZE = 255;\n\n// Define the maximum number of resend attempts\nparameter RESEND_MAX_CNT = 255;\n\n// Define the memory address offset between 2 words\nparameter MEM_OFFSET = 0;\n\n// Define the reset clock divider value\nparameter RESET_CLK_DIV = 255;\n\n// Define the SD clock bus clock value\nparameter SD_CLK_BUS_CLK = 0;\n\n// Define the SD clock separate value\nparameter SD_CLK_SEP = 0;\n\n// Define the SD clock static value\nparameter SD_CLK_STATIC = 0;\n\n// Define the SD clock dynamic value\nparameter SD_CLK_DYNAMIC = 0;\n\n// Define the block size\nparameter BLOCK_SIZE = 512;\n\n// Define the SD bus width\nparameter SD_BUS_WIDTH_4 = 0;\n\n// Define the SD bus width\nparameter SD_BUS_W = 4;\n\n// Define the FIFO RX memory depth\nparameter FIFO_RX_MEM_DEPTH = 0;\n\n// Define the FIFO RX memory address size\nparameter FIFO_RX_MEM_ADR_SIZE = 0;\n\n// Define the FIFO TX memory depth\nparameter FIFO_TX_MEM_DEPTH = 0;\n\n// Define the FIFO TX memory address size\nparameter FIFO_TX_MEM_ADR_SIZE = 0;\n\n// Define the clock divider value\nparameter CLKD = 0;\n\n// Define the big endian system value\nparameter BIG_ENDIAN = 0;\n\n// Define the little endian system value\nparameter LITTLE_ENDIAN = 0;\n\n// Define the simulation value\nparameter SIM = 0;\n\n// Define the synthesis value\nparameter SYN = 0;\n\n// Define the SDC IRQ enable value\nparameter SDC_IRQ_ENABLE = 0;\n\n// Define the Actel value\nparameter ACTEL = 0;\n\n// Define the BD width value\nparameter BD_WIDTH = 8;\n\n// Define the BD size value\nparameter BD_SIZE = 255;\n\n// Define the RAM memory width value\nparameter RAM_MEM_WIDTH_16 = 16;\n\n// Define the RAM memory width value\nparameter RAM_MEM_WIDTH = 32;\n\n// Define the memory offset value\nparameter MEM_OFFSET = 0;\n\n// Define the reset clock divider value\nparameter RESET_CLK_DIV = 255;\n\n// Define the SD clock bus clock value\nparameter SD_CLK_BUS_CLK = 0;\n\n// Define the SD clock separate value\nparameter SD_CLK_SEP = 0;\n\n// Define the SD clock static value\nparameter SD_CLK_STATIC = 0;\n\n// Define the SD clock dynamic value\nparameter SD_CLK_DYNAMIC = 0;\n\n// Define the block size value\nparameter BLOCK_SIZE = 512;\n\n// Define the SD bus width value\nparameter SD_BUS_WIDTH_4 = 0;\n\n// Define the SD bus width value\nparameter SD_BUS_W = 4;\n\n// Define the FIFO RX memory depth value\nparameter FIFO_RX_MEM_DEPTH = 0;\n\n// Define the FIFO RX memory address size value\nparameter FIFO_RX_MEM_ADR_SIZE = 0;\n\n// Define the FIFO TX memory depth value\nparameter FIFO_TX_MEM_DEPTH = 0;\n\n// Define the FIFO TX memory address size value\nparameter FIFO_TX_MEM_ADR_SIZE = 0;\n\n// Define the clock divider value\nparameter CLKD = 0;\n\n// Define the big endian system value\nparameter BIG_ENDIAN = 0;\n\n// Define the little endian system value\nparameter LITTLE_ENDIAN = 0;\n\n// Define the simulation value\nparameter SIM = 0;\n\n// Define the synthesis value\nparameter SYN = 0;\n\n// Define the SDC IRQ enable value\nparameter SDC_IRQ_ENABLE = 0;\n\n// Define the Actel value\nparameter ACTEL = 0;\n\nreg [31:0] argument_reg;\nreg [15:0] cmd_setting_reg;\nreg [15:0] status_reg;\nreg [31:0] cmd_resp_1;\nreg [7:0]  software_reset_reg;\nreg [15:0] time_out_reg;\nreg [15:0] normal_int_status_reg;\nreg [15:0] error_int_status_reg;\nreg [15:0] normal_int_signal_enable_reg;\nreg [15:0] error_int_signal_enable_reg;\nreg [7:0]  clock_divider;\nreg [15:0] Bd_Status_reg;\nreg [7:0]  Bd_isr_reg;\nreg [7:0]  Bd_isr_enable_reg;\nreg Bd_isr_reset;\nreg normal_isr_reset;\nreg error_isr_reset;\nreg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nreg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        argument_reg <= 0;\n        cmd_setting_reg <= 0;\n        status_reg <= 0;\n        cmd_resp_1 <= 0;\n        software_reset_reg <= 0;\n        time_out_reg <= 0;\n        normal_int_status_reg <= 0;\n        error_int_status_reg <= 0;\n        normal_int_signal_enable_reg <= 0;\n        error_int_signal_enable_reg <= 0;\n        clock_divider <= 0;\n        Bd_Status_reg <= 0;\n        Bd_isr_reg <= 0;\n        Bd_isr_enable_reg <= 0;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n        dat_in_m_tx_bd <= 0;\n        dat_in_m_rx_bd <= 0;\n    end else begin\n        // Implement the logic for the SD controller here\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 17, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [ 7:0] wb_adr_i,\n    input  wire [ 3:0] wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [ 7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [ 7:0] clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [ 7:0] Bd_isr_reg,\n    output wire [ 7:0] Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Define the registers\n    reg [31:0] argument_reg;\n    reg [15:0] cmd_setting_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [ 7:0] software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [ 7:0] clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [ 7:0] Bd_isr_reg;\n    reg [ 7:0] Bd_isr_enable_reg;\n\n    // Define the BD RX and TX registers\n    reg [RAM_MEM_WIDTH-1:0] bd_rx;\n    reg [RAM_MEM_WIDTH-1:0] bd_tx;\n\n    // Define the control signals\n    wire cmd_int_busy;\n    wire int_busy;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n\n    // Define the interrupt enable signals\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n\n    // Define the interrupt reset signals\n    wire Bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n\n    // Define the BD RX and TX signals\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Define the clock divider\n    reg [7:0] clock_divider;\n\n    // Define the BD buffer status register\n    reg [15:8] FBRX;\n    reg [7:0] FBTX;\n\n    // Define the data interrupt status register\n    reg [7:0] TRE;\n    reg [7:0] CMDE;\n    reg [7:0] FIFOE;\n    reg [7:0] MRC;\n    reg [7:0] TRS;\n\n    // Define the data interrupt enable register\n    reg [7:0] ETRE;\n    reg [7:0] ECMDE;\n    reg [7:0] EFIFOE;\n    reg [7:0] EMRC;\n    reg [7:0] ETRS;\n\n    // Assign the default values to the registers\n    assign argument_reg = 32'd0;\n    assign cmd_setting_reg = 16'd0;\n    assign status_reg = 16'd0;\n    assign cmd_resp_1 = 32'd0;\n    assign software_reset_reg = 8'd0;\n    assign time_out_reg = 16'd0;\n    assign normal_int_status_reg = 16'd0;\n    assign error_int_status_reg = 16'd0;\n    assign normal_int_signal_enable_reg = 16'd0;\n    assign error_int_signal_enable_reg = 16'd0;\n    assign Bd_isr_reset = 1'b0;\n    assign normal_isr_reset = 1'b0;\n    assign error_isr_reset = 1'b0;\n    assign Bd_isr_reg = 8'd0;\n    assign Bd_isr_enable_reg = 8'd0;\n    assign clock_divider = 8'd0;\n    assign FBRX = 16'd0;\n    assign FBTX = 8'd0;\n    assign TRE = 8'd0;\n    assign CMDE = 8'd0;\n    assign FIFOE = 8'd0;\n    assign MRC = 8'd0;\n    assign TRS = 8'd0;\n    assign ETRE = 8'd0;\n    assign ECMDE = 8'd0;\n    assign EFIFOE = 8'd0;\n    assign EMRC = 8'd0;\n    assign ETRS = 8'd0;\n\n    // Assign the default values to the BD RX and TX registers\n    assign bd_rx = {RAM_MEM_WIDTH{1'b0}};\n    assign bd_tx = {RAM_MEM_WIDTH{1'b0}};\n\n    // Assign the control signals\n    assign cmd_int_busy = (cmd_arg_s != 16'd0);\n    assign int_busy = (wb_adr_i == 8'd4);\n    assign new_cmd = (cmd_arg_s != 16'd0);\n    assign we_ack = write_req_s;\n    assign int_ack = (wb_adr_i == 8'd4) ? 1'b0 : 1'b1;\n    assign we_m_tx_bd = (wb_adr_i == 8'd80);\n    assign we_m_rx_bd = (wb_adr_i == 8'd60);\n\n    // Assign the interrupt enable signals\n    assign normal_int_signal_enable_reg = 16'd0;\n    assign error_int_signal_enable_reg = 16'd0;\n\n    // Assign the interrupt reset signals\n    assign Bd_isr_reset = 1'b0;\n    assign normal_isr_reset = 1'b0;\n    assign error_isr_reset = 1'b0;\n\n    // Assign the BD RX and TX signals\n    assign dat_in_m_tx_bd = bd_tx;\n    assign dat_in_m_rx_bd = bd_rx;\n\n    // Assign the clock divider\n    assign clock_divider = 8'd0;\n\n    // Assign the BD buffer status register\n    assign FBRX = 16'd0;\n    assign FBTX = 8'd0;\n\n    // Assign the data interrupt status register\n    assign TRE = 8'd0;\n    assign CMDE = 8'd0;\n    assign FIFOE = 8'd0;\n    assign MRC = 8'd0;\n    assign TRS = 8'd0;\n\n    // Assign the data interrupt enable register\n    assign ETRE = 8'd0;\n    assign ECMDE = 8'd0;\n    assign EFIFOE = 8'd0;\n    assign EMRC = 8'd0;\n    assign ETRS = 8'd0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 18, "code": "module sd_controller_wb(\n    // WISHBONE Slave Interface\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [ 7:0] wb_adr_i,\n    input  wire [ 3:0] wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    // SD Controller Interface\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [ 7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [ 7:0] clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [ 7:0] Bd_isr_reg,\n    output wire [ 7:0] Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Define the width of the RAM\n    localparam RAM_MEM_WIDTH = 32;\n\n    // Define the width of the BD buffer\n    localparam BD_WIDTH = 8;\n\n    // Define the size of the BD buffer\n    localparam BD_SIZE = 255;\n\n    // Define the maximum number of resend attempts\n    localparam RESEND_MAX_CNT = 255;\n\n    // Define the memory address offset between two words\n    localparam MEM_OFFSET = 0;\n\n    // Define the reset clock divider value\n    localparam RESET_CLK_DIV = 255;\n\n    // Define the SD clock bus clock\n    localparam SD_CLK_BUS_CLK = 1;\n\n    // Define the SD clock separate\n    localparam SD_CLK_SEP = 0;\n\n    // Define the SD clock static\n    localparam SD_CLK_STATIC = 0;\n\n    // Define the SD clock dynamic\n    localparam SD_CLK_DYNAMIC = 0;\n\n    // Define the block size\n    localparam BLOCK_SIZE = 512;\n\n    // Define the SD bus width\n    localparam SD_BUS_WIDTH_4 = 0;\n\n    // Define the SD bus width\n    localparam SD_BUS_W = 4;\n\n    // Define the RX FIFO memory depth\n    localparam FIFO_RX_MEM_DEPTH = 16;\n\n    // Define the RX FIFO memory address size\n    localparam FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\n    // Define the TX FIFO memory depth\n    localparam FIFO_TX_MEM_DEPTH = 16;\n\n    // Define the TX FIFO memory address size\n    localparam FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1;\n\n    // Define the BD buffer status register\n    reg [15:0] Bd_Status_reg_reg;\n\n    // Define the BD interrupt status register\n    reg [ 7:0] Bd_isr_reg_reg;\n\n    // Define the BD interrupt enable register\n    reg [ 7:0] Bd_isr_enable_reg_reg;\n\n    // Define the BD interrupt reset register\n    reg Bd_isr_reset_reg;\n\n    // Define the normal interrupt status register\n    reg [15:0] normal_int_status_reg_reg;\n\n    // Define the error interrupt status register\n    reg [15:0] error_int_status_reg_reg;\n\n    // Define the normal interrupt enable register\n    reg [15:0] normal_int_signal_enable_reg_reg;\n\n    // Define the error interrupt enable register\n    reg [15:0] error_int_signal_enable_reg_reg;\n\n    // Define the clock divider register\n    reg [ 7:0] clock_divider_reg;\n\n    // Define the argument register\n    reg [31:0] argument_reg_reg;\n\n    // Define the command setting register\n    reg [15:0] cmd_setting_reg_reg;\n\n    // Define the status register\n    reg [15:0] status_reg_reg;\n\n    // Define the command response register\n    reg [31:0] cmd_resp_1_reg;\n\n    // Define the software reset register\n    reg [ 7:0] software_reset_reg_reg;\n\n    // Define the time out register\n    reg [15:0] time_out_reg_reg;\n\n    // Define the new command signal\n    wire new_cmd_signal;\n\n    // Define the write enable signal for TX BD\n    wire we_m_tx_bd_signal;\n\n    // Define the write enable signal for RX BD\n    wire we_m_rx_bd_signal;\n\n    // Define the write acknowledge signal\n    wire we_ack_signal;\n\n    // Define the internal acknowledge signal\n    wire int_ack_signal;\n\n    // Define the command interrupt busy signal\n    wire cmd_int_busy_signal;\n\n    // Define the internal busy signal\n    wire int_busy_signal;\n\n    // Define the write request signal\n    wire write_req_s_signal;\n\n    // Define the command set signal\n    wire [15:0] cmd_set_s_signal;\n\n    // Define the command argument signal\n    wire [31:0] cmd_arg_s_signal;\n\n    // Define the argument register output\n    assign argument_reg = argument_reg_reg;\n\n    // Define the command setting register output\n    assign cmd_setting_reg = cmd_setting_reg_reg;\n\n    // Define the status register output\n    assign status_reg = status_reg_reg;\n\n    // Define the command response register output\n    assign cmd_resp_1 = cmd_resp_1;\n\n    // Define the software reset register output\n    assign software_reset_reg = software_reset_reg;\n\n    // Define the time out register output\n    assign time_out_reg = time_out_reg;\n\n    // Define the new command signal\n    assign new_cmd = new_cmd_signal;\n\n    // Define the write enable signal for TX BD\n    assign we_m_tx_bd = we_m_tx_bd_signal;\n\n    // Define the write enable signal for RX BD\n    assign we_m_rx_bd = we_m_rx_bd_signal;\n\n    // Define the write acknowledge signal\n    assign we_ack = we_ack_signal;\n\n    // Define the internal acknowledge signal\n    assign int_ack = int_ack_signal;\n\n    // Define the command interrupt busy signal\n    assign cmd_int_busy = cmd_int_busy_signal;\n\n    // Define the internal busy signal\n    assign int_busy = int_busy_signal;\n\n    // Define the write request signal\n    assign write_req_s = write_req_s_signal;\n\n    // Define the command set signal\n    assign cmd_set_s = cmd_set_s_signal;\n\n    // Define the command argument signal\n    assign cmd_arg_s = cmd_arg_s_signal;\n\n    // Define the BD buffer status register\n    assign Bd_Status_reg = Bd_Status_reg_reg;\n\n    // Define the BD interrupt status register\n    assign Bd_isr_reg = Bd_isr_reg_reg;\n\n    // Define the BD interrupt enable register\n    assign Bd_isr_enable_reg = Bd_isr_enable_reg_reg;\n\n    // Define the BD interrupt reset register\n    assign Bd_isr_reset = Bd_isr_reset_reg;\n\n    // Define the normal interrupt status register\n    assign normal_int_status_reg = normal_int_status_reg_reg;\n\n    // Define the error interrupt status register\n    assign error_int_status_reg = error_int_status_reg_reg;\n\n    // Define the normal interrupt enable register\n    assign normal_int_signal_enable_reg = normal_int_signal_enable_reg_reg;\n\n    // Define the error interrupt enable register\n    assign error_int_signal_enable_reg = error_int_signal_enable_reg_reg;\n\n    // Define the clock divider register\n    assign clock_divider = clock_divider_reg;\n\n    // Define the argument register\n    assign argument_reg_reg = cmd_arg_s_signal;\n\n    // Define the command setting register\n    assign cmd_setting_reg_reg = cmd_set_s_signal;\n\n    // Define the status register\n    assign status_reg_reg = status_reg;\n\n    // Define the command response register\n    assign cmd_resp_1_reg = cmd_resp_1;\n\n    // Define the software reset register\n    assign software_reset_reg_reg = software_reset_reg;\n\n    // Define the time out register\n    assign time_out_reg_reg = time_out_reg;\n\n    // Define the new command signal\n    assign new_cmd_signal = (cmd_setting_reg_reg!= 0);\n\n    // Define the write enable signal for TX BD\n    assign we_m_tx_bd_signal = (write_req_s_signal && (wb_adr_i == 0x60));\n\n    // Define the write enable signal for RX BD\n    assign we_m_rx_bd_signal = (write_req_s_signal && (wb_adr_i == 0x80));\n\n    // Define the write acknowledge signal\n    assign we_ack_signal = (write_req_s_signal && (wb_ack_o == 1));\n\n    // Define the internal acknowledge signal\n    assign int_ack_signal = (write_req_s_signal && (wb_ack_o == 1));\n\n    // Define the command interrupt busy signal\n    assign cmd_int_busy_signal = (cmd_setting_reg_reg!= 0);\n\n    // Define the internal busy signal\n    assign int_busy_signal = (wb_adr_i == 0x04);\n\n    // Define the write request signal\n    assign write_req_s_signal = (wb_stb_i && wb_cyc_i && ~wb_ack_o);\n\n    // Define the command set signal\n    assign cmd_set_s_signal = cmd_set_s;\n\n    // Define the command argument signal\n    assign cmd_arg_s_signal = cmd_arg_s;\n\n    // Define the BD buffer status register\n    assign Bd_Status_reg_reg = Bd_Status_reg;\n\n    // Define the BD interrupt status register\n    assign Bd_isr_reg_reg = Bd_isr_reg;\n\n    // Define the BD interrupt enable register\n    assign Bd_isr_enable_reg_reg = Bd_isr_enable_reg;\n\n    // Define the BD interrupt reset register\n    assign Bd_isr_reset_reg = Bd_isr_reset;\n\n    // Define the normal interrupt status register\n    assign normal_int_status_reg_reg = normal_int_status_reg;\n\n    // Define the error interrupt status register\n    assign error_int_status_reg_reg = error_int_status_reg;\n\n    // Define the normal interrupt enable register\n    assign normal_int_signal_enable_reg_reg = normal_int_signal_enable_reg;\n\n    // Define the error interrupt enable register\n    assign error_int_signal_enable_reg_reg = error_int_signal_enable_reg;\n\n    // Define the clock divider register\n    assign clock_divider_reg = clock_divider;\n\n    // Define the argument register\n    assign argument_reg_reg = cmd_arg_s_signal;\n\n    // Define the command setting register\n    assign cmd_setting_reg_reg = cmd_set_s_signal;\n\n    // Define the status register\n    assign status_reg_reg = status_reg;\n\n    // Define the command response register\n    assign cmd_resp_1_reg = cmd_resp_1;\n\n    // Define the software reset register\n    assign software_reset_reg_reg = software_reset_reg;\n\n    // Define the time out register\n    assign time_out_reg_reg = time_out_reg;\n\n    // Define the BD RX output\n    assign dat_in_m_rx_bd = cmd_arg_s_signal;\n\n    // Define the BD TX output\n    assign dat_in_m_tx_bd = cmd_arg_s_signal;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 20, "code": "module sd_cmd_master(\n    input  wire  clk_pad_io,\n    input  wire  rst_pad_i,\n    input  wire  new_cmd,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire  arg_reg [31:0],\n    input  wire  cmd_set_reg [13:0],\n    input  wire  timeout_reg [15:0],\n    output reg  status_reg [15:0],\n    output reg  resp_1_reg [31:0],\n    output reg  err_int_reg [3:0],\n    output reg  normal_int_reg [15:0],\n    input  wire  err_int_rst,\n    input  wire  normal_int_rst,\n    output reg  settings [15:0],\n    output reg  go_idle_o,\n    output reg  cmd_out [39:0],\n    output reg  req_out,\n    output reg  ack_out,\n    input  wire  req_in,\n    input  wire  ack_in,\n    input  wire  cmd_in [39:0],\n    input  wire  serial_status [7:0],\n    input  wire  card_detect\n);\n\n// Debounce Logic\nreg [3:0] debounce;\nreg card_present;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        debounce <= 4'b0000;\n        card_present <= 0;\n    end\n    else begin\n        if (!card_detect) begin\n            if (debounce!= 4'b1111) begin\n                debounce <= debounce + 1;\n            end\n            else begin\n                card_present <= 1;\n            end\n        end\n        else begin\n            debounce <= 4'b0000;\n            card_present <= 0;\n        end\n    end\nend\n\n// Request and Acknowledge Synchronizers\nreg ack_q;\nreg ack_in_int;\nreg req_q;\nreg req_in_int;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        ack_q <= 0;\n        ack_in_int <= 0;\n        req_q <= 0;\n        req_in_int <= 0;\n    end\n    else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// Finite State Machine (FSM)\nreg [2:0] state;\nreg [2:0] next_state;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        state <= 3'b001;\n    end\n    else begin\n        case (state)\n            3'b001: begin\n                if (new_cmd) begin\n                    next_state <= 3'b010;\n                end\n                else begin\n                    next_state <= 3'b001;\n                end\n            end\n            3'b010: begin\n                if (ack_in_int) begin\n                    next_state <= 3'b100;\n                end\n                else begin\n                    next_state <= 3'b010;\n                end\n            end\n            3'b100: begin\n                if (complete) begin\n                    next_state <= 3'b001;\n                end\n                else begin\n                    next_state <= 3'b100;\n                end\n            end\n            default: begin\n                next_state <= 3'b001;\n            end\n        endcase\n        state <= next_state;\n    end\nend\n\n// FSM State operation\nreg [15:0] status;\nreg [15:0] settings;\nreg [39:0] cmd_out;\nreg [7:0] response_size;\nreg [15:0] resp_1_reg;\nreg [3:0] err_int_reg;\nreg [15:0] normal_int_reg;\nreg [15:0] status_reg;\nreg [7:0] serial_status;\nreg [39:0] cmd_in;\nreg [15:0] timeout_reg;\n\nalways @(posedge clk_pad_io or posedge rst_pad_i) begin\n    if (rst_pad_i) begin\n        status <= 0;\n        settings <= 0;\n        cmd_out <= 0;\n        response_size <= 0;\n        resp_1_reg <= 0;\n        err_int_reg <= 0;\n        normal_int_reg <= 0;\n        status_reg <= 0;\n        serial_status <= 0;\n        cmd_in <= 0;\n        timeout_reg <= 0;\n    end\n    else begin\n        // FSM state operation\n        case (state)\n            3'b001: begin\n                // FSM state operation\n                if (new_cmd) begin\n                    settings <= cmd_set_reg;\n                    cmd_out <= cmd_in;\n                    response_size <= 8'h00;\n                    status <= 0;\n                    resp_1_reg <= 0;\n                    err_int_reg <= 0;\n                    normal_int_reg <= 0;\n                    status_reg <= 0;\n                    serial_status <= 0;\n                    cmd_in <= 0;\n                    timeout_reg <= 0;\n                end\n            end\n            3'b010: begin\n                // FSM state operation\n                if (ack_in_int) begin\n                    status <= 0;\n                    resp_1_reg <= 0;\n                    err_int_reg <= 0;\n                    normal_int_reg <= 0;\n                    status_reg <= 0;\n                    serial_status <= 0;\n                    cmd_in <= 0;\n                    timeout_reg <= 0;\n                end\n            end\n            3'b100: begin\n                // FSM state operation\n                if (complete) begin\n                    status <= 0;\n                    resp_1_reg <= 0;\n                    err_int_reg <= 0;\n                    normal_int_reg <= 0;\n                    status_reg <= 0;\n                    serial_status <= 0;\n                    cmd_in <= 0;\n                    timeout_reg <= 0;\n                end\n            end\n            default: begin\n                // FSM state operation\n                status <= 0;\n                settings <= 0;\n                cmd_out <= 0;\n                response_size <= 0;\n                resp_1_reg <= 0;\n                err_int_reg <= 0;\n                normal_int_reg <= 0;\n                status_reg <= 0;\n                serial_status <= 0;\n                cmd_in <= 0;\n                timeout_reg <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 19, "code": "module sd_controller_wb(\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire         wb_we_i,\n    input  wire         wb_cyc_i,\n    input  wire         wb_stb_i,\n    output wire         wb_ack_o,\n    output wire         we_m_tx_bd,\n    output wire         we_m_rx_bd,\n    output wire         new_cmd,\n    output wire         we_ack,\n    output wire         int_ack,\n    output wire         cmd_int_busy,\n    output wire         int_busy,\n    input  wire         write_req_s,\n    input  wire [15:0]  cmd_set_s,\n    input  wire [31:0]  cmd_arg_s,\n    output wire [31:0]  argument_reg,\n    output wire [15:0]  cmd_setting_reg,\n    input  wire [15:0]  status_reg,\n    input  wire [31:0]  cmd_resp_1,\n    output wire [7:0]   software_reset_reg,\n    output wire [15:0]  time_out_reg,\n    input  wire [15:0]  normal_int_status_reg,\n    input  wire [15:0]  error_int_status_reg,\n    output wire [15:0]  normal_int_signal_enable_reg,\n    output wire [15:0]  error_int_signal_enable_reg,\n    output wire [7:0]   clock_divider,\n    input  wire [15:0]  Bd_Status_reg,\n    input  wire [7:0]   Bd_isr_reg,\n    output wire [7:0]   Bd_isr_enable_reg,\n    output wire         Bd_isr_reset,\n    output wire         normal_isr_reset,\n    output wire         error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n// Define the reset values for the registers\nlocalparam [31:0] ARGUMENT_REG_RESET = 32'd0;\nlocalparam [15:0] CMD_SETTING_REG_RESET = 16'd0;\nlocalparam [15:0] STATUS_REG_RESET = 16'd0;\nlocalparam [31:0] CMD_RESP_1_RESET = 32'd0;\nlocalparam [7:0] SOFTWARE_RESET_REG_RESET = 8'd0;\nlocalparam [15:0] TIME_OUT_REG_RESET = 16'd0;\nlocalparam [15:0] NORMAL_INT_STATUS_REG_RESET = 16'd0;\nlocalparam [15:0] ERROR_INT_STATUS_REG_RESET = 16'd0;\nlocalparam [15:0] NORMAL_INT_SIGNAL_ENABLE_REG_RESET = 16'd0;\nlocalparam [15:0] ERROR_INT_SIGNAL_ENABLE_REG_RESET = 16'd0;\nlocalparam [7:0] CLOCK_DIVIDER_RESET = 8'd0;\nlocalparam [15:0] BD_STATUS_REG_RESET = 16'd0;\nlocalparam [7:0] BD_ISR_REG_RESET = 8'd0;\nlocalparam [7:0] BD_ISR_ENABLE_REG_RESET = 8'd0;\n\n// Define the register widths\nlocalparam ARGUMENT_REG_WIDTH = 32;\nlocalparam CMD_SETTING_REG_WIDTH = 16;\nlocalparam STATUS_REG_WIDTH = 16;\nlocalparam CMD_RESP_1_WIDTH = 32;\nlocalparam SOFTWARE_RESET_REG_WIDTH = 8;\nlocalparam TIME_OUT_REG_WIDTH = 16;\nlocalparam NORMAL_INT_STATUS_REG_WIDTH = 16;\nlocalparam ERROR_INT_STATUS_REG_WIDTH = 16;\nlocalparam NORMAL_INT_SIGNAL_ENABLE_REG_WIDTH = 16;\nlocalparam ERROR_INT_SIGNAL_ENABLE_REG_WIDTH = 16;\nlocalparam CLOCK_DIVIDER_WIDTH = 8;\nlocalparam BD_STATUS_REG_WIDTH = 16;\nlocalparam BD_ISR_REG_WIDTH = 8;\nlocalparam BD_ISR_ENABLE_REG_WIDTH = 8;\n\n// Define the register addresses\nlocalparam ARGUMENT_REG_ADDR = 32'd0;\nlocalparam CMD_SETTING_REG_ADDR = 32'd4;\nlocalparam STATUS_REG_ADDR = 32'd8;\nlocalparam CMD_RESP_1_ADDR = 32'd0c;\nlocalparam SOFTWARE_RESET_REG_ADDR = 32'd28;\nlocalparam TIME_OUT_REG_ADDR = 32'd2c;\nlocalparam NORMAL_INT_STATUS_REG_ADDR = 32'd30;\nlocalparam ERROR_INT_STATUS_REG_ADDR = 32'd34;\nlocalparam NORMAL_INT_SIGNAL_ENABLE_REG_ADDR = 32'd38;\nlocalparam ERROR_INT_SIGNAL_ENABLE_REG_ADDR = 32'd3c;\nlocalparam CLOCK_DIVIDER_ADDR = 32'd4c;\nlocalparam BD_STATUS_REG_ADDR = 32'd50;\nlocalparam BD_ISR_REG_ADDR = 32'd54;\nlocalparam BD_ISR_ENABLE_REG_ADDR = 32'd58;\n\n// Define the BD RX and TX register addresses\nlocalparam BD_RX_ADDR = 32'd60;\nlocalparam BD_TX_ADDR = 32'd80;\n\n// Define the BD RX and TX register widths\nlocalparam BD_RX_WIDTH = 16;\nlocalparam BD_TX_WIDTH = 16;\n\n// Define the BD RX and TX register reset values\nlocalparam BD_RX_RESET = 16'd0;\nlocalparam BD_TX_RESET = 16'd0;", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 18, "code": "module sd_cmd_serial_host(\n    input  wire        SD_CLK_IN,\n    input  wire        RST_IN,\n    input  wire [15:0] SETTING_IN,\n    input  wire [39:0] CMD_IN,\n    input  wire        REQ_IN,\n    input  wire        ACK_IN,\n    input  wire        cmd_dat_i,\n    output wire [39:0] CMD_OUT,\n    output wire        ACK_OUT,\n    output wire        REQ_OUT,\n    output wire [7:0]  STATUS,\n    output wire        cmd_oe_o,\n    output wire        cmd_out_o,\n    output wire        st_dat_t\n);\n\n// Internal Constants and Parameters\nlocalparam INIT_DELAY = 2;\nlocalparam NCR = 2;\nlocalparam SEND_SIZE = 48;\nlocalparam SIZE = 10;\nlocalparam CONTENT_SIZE = 40;\nlocalparam Read_Delay = 7;\nlocalparam EIGHT_PAD = 8;\nlocalparam INIT = 8'b0000_0000;\nlocalparam IDLE = 8'b0000_0001;\nlocalparam WRITE_WR = 8'b0000_0010;\nlocalparam DLY_WR = 8'b0000_0011;\nlocalparam READ_WR = 8'b0000_0100;\nlocalparam DLY_READ = 8'b0000_0101;\nlocalparam ACK_WR = 8'b0000_0110;\nlocalparam WRITE_WO = 8'b0000_0111;\nlocalparam DLY_WO = 8'b0000_1000;\nlocalparam ACK_WO = 8'b0000_1001;\n\n// Internal Signals\nreg [7:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nreg [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_OUT;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// FSM_COMBO\nalways_comb\nbegin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY)? IDLE : INIT;\n        IDLE: next_state = (Write_Read)? WRITE_WR : ((Write_Only)? WRITE_WO : IDLE);\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1)? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1)? DLY_WO : WRITE_WO;\n        DLY_WR: next_state = (Delay_Cnt >= NCR &&!cmd_dat_i)? READ_WR : DLY_WR;\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler)? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD))? DLY_READ : READ_WR;\n        DLY_READ: next_state = (Ack_internal_in)? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ\nalways_ff @(posedge SD_CLK_IN or posedge RST_IN)\nbegin\n    if (RST_IN)\n        state <= INIT;\n    else\n        state <= next_state;\nend\n\n// REQ_SYNC\nreg req_sync_q;\nreg req_sync_q1;\nalways_ff @(posedge SD_CLK_IN or posedge RST_IN)\nbegin\n    if (RST_IN)\n    begin\n        req_sync_q <= 0;\n        req_sync_q1 <= 0;\n    end\n    else\n    begin\n        req_sync_q <= req_sync_q1;\n        req_sync_q1 <= REQ_IN;\n    end\nend\n\nassign Req_internal_in = req_sync_q1;\n\n// ACK_SYNC\nreg ack_sync_q;\nreg ack_sync_q1;\nalways_ff @(posedge SD_CLK_IN or posedge RST_IN)\nbegin\n    if (RST_IN)\n    begin\n        ack_sync_q <= 0;\n        ack_sync_q1 <= 0;\n    end\n    else\n    begin\n        ack_sync_q <= ack_sync_q1;\n        ack_sync_q1 <= ACK_IN;\n    end\nend\n\nassign Ack_internal_in = ack_sync_q1;\n\n// COMMAND_DECODER\nalways_comb\nbegin\n    case (SETTING_IN[6:0])\n        7'b0000000: Response_Size = 7'b0000000;\n        7'b0000001: Response_Size = 7'b0000001;\n        7'b0000010: Response_Size = 7'b0000010;\n        7'b0000011: Response_Size = 7'b0000011;\n        7'b0000100: Response_Size = 7'b0000100;\n        7'b0000101: Response_Size = 7'b0000101;\n        7'b0000110: Response_Size = 7'b0000110;\n        7'b0000111: Response_Size = 7'b0000111;\n        7'b0001000: Response_Size = 7'b0001000;\n        7'b0001001: Response_Size = 7'b0001001;\n        7'b0001010: Response_Size = 7'b0001010;\n        7'b0001011: Response_Size = 7'b0001011;\n        7'b0001100: Response_Size = 7'b0001100;\n        7'b0001101: Response_Size = 7'b0001101;\n        7'b0001110: Response_Size = 7'b0001110;\n        7'b0001111: Response_Size = 7'b0001111;\n        default: Response_Size = 7'b0000000;\n    endcase\n\n    case (SETTING_IN[7])\n        1'b0: CRC_Check_On = 1'b0;\n        1'b1: CRC_Check_On = 1'b1;\n        default: CRC_Check_On = 1'b0;\n    endcase\n\n    case (SETTING_IN[10:8])\n        3'b000: Delay_Cycler = 3'b000;\n        3'b001: Delay_Cycler = 3'b001;\n        3'b010: Delay_Cycler = 3'b010;\n        3'b011: Delay_Cycler = 3'b011;\n        3'b100: Delay_Cycler = 3'b100;\n        3'b101: Delay_Cycler = 3'b101;\n        3'b110: Delay_Cycler = 3'b110;\n        3'b111: Delay_Cycler = 3'b111;\n        default: Delay_Cycler = 3'b000;\n    endcase\n\n    case (SETTING_IN[11])\n        1'b0: block_write = 1'b0;\n        1'b1: block_write = 1'b1;\n        default: block_write = 1'b0;\n    endcase\n\n    case (SETTING_IN[12])\n        1'b0: block_read = 1'b0;\n        1'b1: block_read = 1'b1;\n        default: block_read = 1'b0;\n    endcase\n\n    case (SETTING_IN[14:13])\n        2'b00: word_select = 2'b00;\n        2'b01: word_select = 2'b01;\n        2'b10: word_select = 2'b10;\n        2'b11: word_select = 2'b11;\n        default: word_select = 2'b00;\n    endcase\nend\n\nalways_comb\nbegin\n    case (SETTING_IN[15])\n        1'b0: Write_Read = 1'b0;\n        1'b1: Write_Read = 1'b1;\n        default: Write_Read = 1'b0;\n    endcase\n\n    case (SETTING_IN[15])\n        1'b0: Write_Only = 1'b0;\n        1'b1: Write_Only = 1'b1;\n        default: Write_Only = 1'b0;\n    endcase\nend\n\nalways_comb\nbegin\n    case (SETTING_IN[15])\n        1'b0: DECODER_ACK = 1'b0;\n        1'b1: DECODER_ACK = 1'b1;\n        default: DECODER_ACK = 1'b0;\n    endcase\nend\n\nalways_comb\nbegin\n    case (SETTING_IN[15])\n        1'b0: FSM_ACK = 1'b0;\n        1'b1: FSM_ACK = 1'b1;\n        default: FSM_ACK = 1'b0;\n    endcase\nend\n\nalways_comb\nbegin\n    case (SETTING_IN[15])\n        1'b0: CRC_RST = 1'b0;\n        1'b1: CRC_RST = 1'b1;\n        default: CRC_RST = 1'b0;\n    endcase\nend\n\nalways_comb\nbegin\n    case (SETTING_IN[15])\n        1'b0: CRC_Enable = 1'b0;\n        1'b1: CRC_Enable = 1'b1;\n        default: CRC_Enable = 1'b0;\n    endcase\nend\n\nalways_comb\nbegin\n    case (SETTING_IN[15])\n        1'b0: CRC_Valid = 1'b0;\n        1'b1: CRC_Valid = 1'b1;\n        default: CRC_Valid = 1'b0;\n    endcase\nend\n\nalways_comb\nbegin\n    case (SETTING_IN[15])\n        1'b0: Crc_Buffering = 1'b0;\n        1'b1: Crc_Buffering = 1'b1;\n        default: Crc_Buffering = 1'b0;\n    endcase\nend\n\nalways_comb\nbegin\n    case (SETTING_IN[15])\n        1'b0: CRC_OUT = 1'b0;\n        1'b1: CRC_OUT = 1'b1;\n        default: CRC_OUT = 1'b0;\n    endcase\nend\n\nalways_comb\nbegin\n    case (SETTING_IN[15])\n        1'b0: CRC_IN = 1'b0;\n        1'b1: CRC_IN = 1'b1;\n        default: CRC_IN = 1'b0;\n    endcase\nend\n\nalways_comb\nbegin\n    case (SETTING_IN[15])\n        1'b0: cmd_oe_o = 1'b0;\n        1'b1: cmd_oe_o = 1'b1;\n        default: cmd_oe_o = 1'b0;\n    endcase\nend\n\nalways_comb\nbegin\n    case (SETTING_IN[15])\n        1'b0: cmd_out_o = 1'b0;\n        1'b1: cmd_out_o = 1'b1;\n        default: cmd_out_o = 1'b0;\n    endcase\nend\n\nalways_comb\nbegin\n    case (SETTING_IN[15])\n        1'b0: Out_Buff = 40'b0000_0000_0000_0000;\n        1'b1: Out_Buff = 40'b0000_0000_0000_0000;\n        default: Out_Buff = 40'b0000_0000_0000_0000;\n    endcase\nend\n\nalways_comb\nbegin\n    case (SETTING_IN[15])\n        1'b0: In_Buff = 40'b0000_0000_0000_0000;\n        1'b1: In_Buff = 40'b0000_0000_0000_0000;\n        default: In_Buff = 40'b0000_0000_0000_0000;\n    endcase\nend\n\n// ... (rest of the code remains the same)", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 20, "code": "module sd_controller_wb(\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire         Bd_isr_reset,\n    output wire         normal_isr_reset,\n    output wire         error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n// Define the registers\nreg [31:0] argument_reg;\nreg [15:0] cmd_setting_reg;\nreg [15:0] status_reg;\nreg [31:0] cmd_resp_1;\nreg [7:0]  software_reset_reg;\nreg [15:0] time_out_reg;\nreg [15:0] normal_int_status_reg;\nreg [15:0] error_int_status_reg;\nreg [15:0] normal_int_signal_enable_reg;\nreg [15:0] error_int_signal_enable_reg;\nreg [7:0]  clock_divider;\nreg [15:0] Bd_Status_reg;\nreg [7:0]  Bd_isr_reg;\nreg [7:0]  Bd_isr_enable_reg;\n\n// Define the control signals\nwire cmd_int_busy;\nwire int_busy;\nwire new_cmd;\nwire we_ack;\nwire int_ack;\nwire we_m_tx_bd;\nwire we_m_rx_bd;\n\n// Define the clock divider\nreg [7:0] clock_divider;\n\n// Define the BD buffer status register\nreg [15:8] FBRX;\nreg [7:0]  FBTX;\n\n// Define the data interrupt status register\nreg [7:6] Reserved;\nreg [5:0] TRE;\nreg [4:0] CMDE;\nreg [2:0] FIFOE;\nreg [1:0] MRC;\nreg [0:0] TRS;\n\n// Define the data interrupt enable register\nreg [7:6] Reserved;\nreg [5:0] ETRE;\nreg [4:0] ECMDE;\nreg [2:0] EFIFOE;\nreg [1:0] EMRC;\nreg [0:0] ETRS;\n\n// Define the BD RX and TX registers\nreg [63:32] BD_RX;\nreg [31:0]  BD_TX;\n\n// Define the reset and clock signals\nwire reset;\nwire clk;\n\n// Define the control logic\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        // Reset the registers\n        argument_reg <= 32'd0;\n        cmd_setting_reg <= 16'd0;\n        status_reg <= 16'd0;\n        cmd_resp_1 <= 32'd0;\n        software_reset_reg <= 8'd0;\n        time_out_reg <= 16'd0;\n        normal_int_status_reg <= 16'd0;\n        error_int_status_reg <= 16'd0;\n        normal_int_signal_enable_reg <= 16'd0;\n        error_int_signal_enable_reg <= 16'd0;\n        clock_divider <= 8'd0;\n        Bd_Status_reg <= 16'd0;\n        Bd_isr_reg <= 8'd0;\n        Bd_isr_enable_reg <= 8'd0;\n        // Reset the control signals\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        // Reset the BD buffer status register\n        FBRX <= 16'd0;\n        FBTX <= 8'd0;\n        // Reset the data interrupt status register\n        TRE <= 5'd0;\n        CMDE <= 5'd0;\n        FIFOE <= 3'd0;\n        MRC <= 2'd0;\n        TRS <= 1'd0;\n        // Reset the data interrupt enable register\n        ETRE <= 5'd0;\n        ECMDE <= 5'd0;\n        EFIFOE <= 3'd0;\n        EMRC <= 2'd0;\n        ETRS <= 1'd0;\n        // Reset the BD RX and TX registers\n        BD_RX <= 32'd0;\n        BD_TX <= 32'd0;\n    end else begin\n        // Update the registers\n        argument_reg <= wb_dat_i;\n        cmd_setting_reg <= wb_dat_i[15:0];\n        status_reg <= wb_dat_i[15:0];\n        cmd_resp_1 <= wb_dat_i;\n        software_reset_reg <= wb_dat_i[7:0];\n        time_out_reg <= wb_dat_i[15:0];\n        normal_int_status_reg <= wb_dat_i[15:0];\n        error_int_status_reg <= wb_dat_i[15:0];\n        normal_int_signal_enable_reg <= wb_dat_i[15:0];\n        error_int_signal_enable_reg <= wb_dat_i[15:0];\n        clock_divider <= wb_dat_i[7:0];\n        Bd_Status_reg <= wb_dat_i[15:0];\n        Bd_isr_reg <= wb_dat_i[7:0];\n        Bd_isr_enable_reg <= wb_dat_i[7:0];\n        // Update the control signals\n        cmd_int_busy <= (cmd_set_s!= 16'd0);\n        int_busy <= (wb_adr_i == 8'h04);\n        new_cmd <= (cmd_arg_s!= 32'd0);\n        we_ack <= write_req_s;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        // Update the BD buffer status register\n        FBRX <= Bd_Status_reg[15:8];\n        FBTX <= Bd_Status_reg[7:0];\n        // Update the data interrupt status register\n        TRE <= TRE | (cmd_arg_s[5] & ~cmd_arg_s[4]);\n        CMDE <= CMDE | (cmd_arg_s[4] & ~cmd_arg_s[3]);\n        FIFOE <= FIFOE | (cmd_arg_s[2] & ~cmd_arg_s[1]);\n        MRC <= MRC | (cmd_arg_s[1] & ~cmd_arg_s[0]);\n        TRS <= TRS | (cmd_arg_s[0] & ~cmd_arg_s[5]);\n        // Update the data interrupt enable register\n        ETRE <= ETRE | (cmd_arg_s[5] & ~cmd_arg_s[4]);\n        ECMDE <= ECMDE | (cmd_arg_s[4] & ~cmd_arg_s[3]);\n        EFIFOE <= EFIFOE | (cmd_arg_s[2] & ~cmd_arg_s[1]);\n        EMRC <= EMRC | (cmd_arg_s[1] & ~cmd_arg_s[0]);\n        ETRS <= ETRS | (cmd_arg_s[0] & ~cmd_arg_s[5]);\n        // Update the BD RX and TX registers\n        BD_RX <= BD_RX | cmd_arg_s[31:0];\n        BD_TX <= BD_TX | cmd_arg_s[31:0];\n    end\nend\n\n// Define the wishbone interface\nassign wb_dat_o = argument_reg;\nassign wb_ack_o = (wb_cyc_i & wb_stb_i & ~wb_ack_o & int_ack);\n\n// Define the control logic\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        // Reset the control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        int_ack <= 1'b1;\n    end else begin\n        // Update the control signals\n        if (wb_cyc_i & wb_stb_i & ~wb_ack_o & int_ack) begin\n            if (wb_adr_i == 8'h00) begin\n                // Write to the argument register\n                argument_reg <= wb_dat_i;\n            end else if (wb_adr_i == 8'h04) begin\n                // Write to the command setting register\n                cmd_setting_reg <= wb_dat_i[15:0];\n            end else if (wb_adr_i == 8'h08) begin\n                // Read from the status register\n                wb_dat_o <= status_reg;\n            end else if (wb_adr_i == 8'h0c) begin\n                // Read from the response register\n                wb_dat_o <= cmd_resp_1;\n            end else if (wb_adr_i == 8'h1c) begin\n                // Read from the controller setting register\n                wb_dat_o <= 16'd0;\n            end else if (wb_adr_i == 8'h20) begin\n                // Read from the block size register\n                wb_dat_o <= 16'd512;\n            end else if (wb_adr_i == 8'h24) begin\n                // Read from the power control register\n                wb_dat_o <= 8'd0;\n            end else if (wb_adr_i == 8'h28) begin\n                // Write to the software reset register\n                software_reset_reg <= wb_dat_i[7:0];\n            end else if (wb_adr_i == 8'h2c) begin\n                // Write to the timeout register\n                time_out_reg <= wb_dat_i[15:0];\n            end else if (wb_adr_i == 8'h30) begin\n                // Write to the normal interrupt status register\n                normal_int_status_reg <= wb_dat_i[15:0];\n            end else if (wb_adr_i == 8'h34) begin\n                // Write to the error interrupt status register\n                error_int_status_reg <= wb_dat_i[15:0];\n            end else if (wb_adr_i == 8'h38) begin\n                // Write to the normal interrupt enable register\n                normal_int_signal_enable_reg <= wb_dat_i[15:0];\n            end else if (wb_adr_i == 8'h3c) begin\n                // Write to the error interrupt enable register\n                error_int_signal_enable_reg <= wb_dat_i[15:0];\n            end else if (wb_adr_i == 8'h48) begin\n                // Read from the capability register\n                wb_dat_o <= 16'd0;\n            end else if (wb_adr_i == 8'h4c) begin\n                // Write to the clock divider register\n                clock_divider <= wb_dat_i[7:0];\n            end else if (wb_adr_i == 8'h50) begin\n                // Read from the BD buffer status register\n                wb_dat_o <= {FBRX, FBTX};\n            end else if (wb_adr_i == 8'h54) begin\n                // Read from the data interrupt status register\n                wb_dat_o <= {TRS, MRC, FIFOE, CMDE, TRE};\n            end else if (wb_adr_i == 8'h58) begin\n                // Write to the data interrupt enable register\n                Bd_isr_enable_reg <= wb_dat_i[7:0];\n            end else if (wb_adr_i == 8'h60) begin\n                // Write to the BD RX register\n                BD_RX <= wb_dat_i[63:32];\n            end else if (wb_adr_i == 8'h80) begin\n                // Write to the BD TX register\n                BD_TX <= wb_dat_i[63:32];\n            end\n        end\n    end\nend\n\n// Define the BD RX and TX registers\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        // Reset the BD RX and TX registers\n        BD_RX <= 32'd0;\n        BD_TX <= 32'd0;\n    end else begin\n        // Update the BD RX and TX registers\n        if (wb_adr_i == 8'h60) begin\n            BD_RX <= wb_dat_i[63:32];\n        end else if (wb_adr_i == 8'h80) begin\n            BD_TX <= wb_dat_i[63:32];\n        end\n    end\nend\n\n// Define the control logic\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        // Reset the control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        int_ack <= 1'b1;\n    end else begin\n        // Update the control signals\n        if (wb_cyc_i & wb_stb_i & ~wb_ack_o & int_ack) begin\n            if (wb_adr_i == 8'h60) begin\n                // Write to the BD RX register\n                we_m_rx_bd <= 1'b1;\n                int_ack <= 1'b0;\n                #1;\n                we_m_rx_bd <= 1'b0;\n                int_ack <= 1'b1;\n            end else if (wb_adr_i == 8'h80) begin\n                // Write to the BD TX register\n                we_m_tx_bd <= 1'b1;\n                int_ack <= 1'b0;\n                #1;\n                we_m_tx_bd <= 1'b0;\n                int_ack <= 1'b1;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 19, "code": "// sd_cmd_serial_host.v\n\nmodule sd_cmd_serial_host(\n    input  wire SD_CLK_IN,\n    input  wire RST_IN,\n    input  wire [15:0] SETTING_IN,\n    input  wire [39:0] CMD_IN,\n    input  wire REQ_IN,\n    input  wire ACK_IN,\n    input  wire cmd_dat_i,\n    output wire [39:0] CMD_OUT,\n    output wire ACK_OUT,\n    output wire REQ_OUT,\n    output wire [7:0] STATUS,\n    output wire cmd_oe_o,\n    output wire cmd_out_o,\n    output wire [1:0] st_dat_t\n);\n\n    // FSM_COMBO\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg [2:0] Delay_Cnt;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cycler;\n    reg [6:0] Response_Size;\n    reg [7:0] word_select_counter;\n    reg [1:0] word_select;\n    reg [1:0] block_read;\n    reg [1:0] block_write;\n    reg [1:0] st_dat_t;\n    reg [1:0] CRC_Valid;\n    reg [1:0] Crc_Buffering;\n    reg [1:0] CRC_Check_On;\n    reg [1:0] CRC_Enable;\n    reg [1:0] CRC_RST;\n    reg [1:0] CRC_OUT;\n    reg [1:0] CRC_IN;\n    reg [1:0] CRC_VAL;\n    reg [1:0] FSM_ACK;\n    reg [1:0] DECODER_ACK;\n    reg [1:0] q;\n    reg [1:0] Req_internal_in;\n    reg [1:0] q1;\n    reg [1:0] Ack_internal_in;\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            state <= 10'd0;\n        else\n            state <= next_state;\n    end\n\n    // FSM_COMBO\n    always_comb\n    begin\n        case(state)\n            INIT:\n                begin\n                    if (Cmd_Cnt >= INIT_DELAY)\n                        next_state = IDLE;\n                    else\n                        next_state = INIT;\n                end\n            IDLE:\n                begin\n                    if (Write_Read)\n                        next_state = WRITE_WR;\n                    else if (Write_Only)\n                        next_state = WRITE_WO;\n                    else\n                        next_state = IDLE;\n                end\n            WRITE_WR:\n                begin\n                    if (Cmd_Cnt >= SEND_SIZE - 1)\n                        next_state = DLY_WR;\n                    else\n                        next_state = WRITE_WR;\n                end\n            WRITE_WO:\n                begin\n                    if (Cmd_Cnt >= SEND_SIZE - 1)\n                        next_state = DLY_WO;\n                    else\n                        next_state = WRITE_WO;\n                end\n            DLY_WR:\n                begin\n                    if (Delay_Cnt >= NCR && !cmd_dat_i)\n                        next_state = READ_WR;\n                    else\n                        next_state = DLY_WR;\n                end\n            DLY_WO:\n                begin\n                    if (Delay_Cnt >= Delay_Cycler)\n                        next_state = ACK_WO;\n                    else\n                        next_state = DLY_WO;\n                end\n            READ_WR:\n                begin\n                    if (Cmd_Cnt >= Response_Size + EIGHT_PAD)\n                        next_state = DLY_READ;\n                    else\n                        next_state = READ_WR;\n                end\n            DLY_READ:\n                begin\n                    if (Ack_internal_in)\n                        next_state = ACK_WR;\n                    else\n                        next_state = DLY_READ;\n                end\n            ACK_WO:\n                begin\n                    next_state = IDLE;\n                end\n            ACK_WR:\n                begin\n                    next_state = IDLE;\n                end\n            default:\n                next_state = INIT;\n        end\n    end\n\n    // FSM_OUT\n    always_comb\n    begin\n        case(state)\n            INIT:\n                begin\n                    cmd_oe_o = 1;\n                    cmd_out_o = 1;\n                    FSM_ACK = 1;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 0;\n                    st_dat_t = 2'b00;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    CMD_OUT = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000000;\n                    CRC_Valid = 0;\n                end\n            IDLE:\n                begin\n                    cmd_oe_o = 0;\n                    cmd_out_o = 0;\n                    FSM_ACK = 1;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 0;\n                    st_dat_t = 2'b00;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    CMD_OUT = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000000;\n                    CRC_Valid = 0;\n                end\n            WRITE_WR:\n                begin\n                    cmd_oe_o = 1;\n                    cmd_out_o = 1;\n                    FSM_ACK = 0;\n                    REQ_OUT = 1;\n                    CRC_Enable = 1;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 1;\n                    st_dat_t = 2'b10;\n                    CRC_RST = 0;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    CMD_OUT = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000001;\n                    CRC_Valid = 0;\n                end\n            WRITE_WO:\n                begin\n                    cmd_oe_o = 1;\n                    cmd_out_o = 1;\n                    FSM_ACK = 0;\n                    REQ_OUT = 1;\n                    CRC_Enable = 1;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 1;\n                    st_dat_t = 2'b01;\n                    CRC_RST = 0;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    CMD_OUT = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000010;\n                    CRC_Valid = 0;\n                end\n            DLY_WR:\n                begin\n                    cmd_oe_o = 1;\n                    cmd_out_o = 1;\n                    FSM_ACK = 0;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = Delay_Cnt + 1;\n                    Cmd_Cnt = 1;\n                    st_dat_t = 2'b10;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    CMD_OUT = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000011;\n                    CRC_Valid = 0;\n                end\n            DLY_WO:\n                begin\n                    cmd_oe_o = 1;\n                    cmd_out_o = 1;\n                    FSM_ACK = 0;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = Delay_Cnt + 1;\n                    Cmd_Cnt = 0;\n                    st_dat_t = 2'b01;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    CMD_OUT = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000100;\n                    CRC_Valid = 0;\n                end\n            READ_WR:\n                begin\n                    cmd_oe_o = 0;\n                    cmd_out_o = 0;\n                    FSM_ACK = 0;\n                    REQ_OUT = 1;\n                    CRC_Enable = 1;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 1;\n                    st_dat_t = 2'b11;\n                    CRC_RST = 0;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    CMD_OUT = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000101;\n                    CRC_Valid = 0;\n                end\n            DLY_READ:\n                begin\n                    cmd_oe_o = 0;\n                    cmd_out_o = 0;\n                    FSM_ACK = 0;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = Delay_Cnt + 1;\n                    Cmd_Cnt = 1;\n                    st_dat_t = 2'b11;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    CMD_OUT = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000110;\n                    CRC_Valid = 0;\n                end\n            ACK_WO:\n                begin\n                    cmd_oe_o = 0;\n                    cmd_out_o = 0;\n                    FSM_ACK = 1;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 0;\n                    st_dat_t = 2'b00;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    CMD_OUT = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000111;\n                    CRC_Valid = 0;\n                end\n            ACK_WR:\n                begin\n                    cmd_oe_o = 0;\n                    cmd_out_o = 0;\n                    FSM_ACK = 1;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 0;\n                    st_dat_t = 2'b00;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    CMD_OUT = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00001000;\n                    CRC_Valid = 0;\n                end\n            default:\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                FSM_ACK = 1;\n                REQ_OUT = 0;\n                CRC_Enable = 0;\n                word_select_counter = 0;\n                Delay_Cnt = 0;\n                Cmd_Cnt = 0;\n                st_dat_t = 2'b00;\n                CRC_RST = 1;\n                CRC_OUT = 0;\n                CRC_IN = 0;\n                CMD_OUT = 0;\n                Crc_Buffering = 0;\n                STATUS = 8'b00000000;\n                CRC_Valid = 0;\n        end\n    end\n\n    // COMMAND_DECODER\n    always_comb\n    begin\n        if (Req_internal_in)\n        begin\n            Response_Size = SETTING_IN[6:0];\n            CRC_Check_On = SETTING_IN[7];\n            Delay_Cycler = SETTING_IN[10:8];\n            block_write = SETTING_IN[11];\n            block_read = SETTING_IN[12];\n            word_select = SETTING_IN[14:13];\n            In_Buff = CMD_IN;\n            Write_Read = (SETTING_IN[6:0] > 0);\n            Write_Only = (!Write_Read);\n            DECODER_ACK = 0;\n        end\n        else\n        begin\n            Write_Read = 0;\n            Write_Only = 0;\n            DECODER_ACK = 1;\n        end\n    end\n\n    // FSM_OUT\n    always_comb\n    begin\n        case(state)\n            INIT:\n                begin\n                    ACK_OUT = 0;\n                    CMD_OUT = 0;\n                    st_dat_t = 2'b00;\n                    cmd_oe_o = 1;\n                    cmd_out_o = 1;\n                    FSM_ACK = 1;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 0;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000000;\n                    CRC_Valid = 0;\n                end\n            IDLE:\n                begin\n                    ACK_OUT = 0;\n                    CMD_OUT = 0;\n                    st_dat_t = 2'b00;\n                    cmd_oe_o = 0;\n                    cmd_out_o = 0;\n                    FSM_ACK = 1;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 0;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000000;\n                    CRC_Valid = 0;\n                end\n            WRITE_WR:\n                begin\n                    ACK_OUT = 0;\n                    CMD_OUT = In_Buff;\n                    st_dat_t = 2'b10;\n                    cmd_oe_o = 1;\n                    cmd_out_o = 1;\n                    FSM_ACK = 0;\n                    REQ_OUT = 1;\n                    CRC_Enable = 1;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 1;\n                    CRC_RST = 0;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000001;\n                    CRC_Valid = 0;\n                end\n            WRITE_WO:\n                begin\n                    ACK_OUT = 0;\n                    CMD_OUT = In_Buff;\n                    st_dat_t = 2'b01;\n                    cmd_oe_o = 1;\n                    cmd_out_o = 1;\n                    FSM_ACK = 0;\n                    REQ_OUT = 1;\n                    CRC_Enable = 1;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 1;\n                    CRC_RST = 0;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000010;\n                    CRC_Valid = 0;\n                end\n            DLY_WR:\n                begin\n                    ACK_OUT = 0;\n                    CMD_OUT = 0;\n                    st_dat_t = 2'b10;\n                    cmd_oe_o = 1;\n                    cmd_out_o = 1;\n                    FSM_ACK = 0;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = Delay_Cnt + 1;\n                    Cmd_Cnt = 1;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000011;\n                    CRC_Valid = 0;\n                end\n            DLY_WO:\n                begin\n                    ACK_OUT = 0;\n                    CMD_OUT = 0;\n                    st_dat_t = 2'b01;\n                    cmd_oe_o = 1;\n                    cmd_out_o = 1;\n                    FSM_ACK = 0;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = Delay_Cnt + 1;\n                    Cmd_Cnt = 0;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000100;\n                    CRC_Valid = 0;\n                end\n            READ_WR:\n                begin\n                    ACK_OUT = 0;\n                    CMD_OUT = In_Buff;\n                    st_dat_t = 2'b11;\n                    cmd_oe_o = 0;\n                    cmd_out_o = 0;\n                    FSM_ACK = 0;\n                    REQ_OUT = 1;\n                    CRC_Enable = 1;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 1;\n                    CRC_RST = 0;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000101;\n                    CRC_Valid = 0;\n                end\n            DLY_READ:\n                begin\n                    ACK_OUT = 0;\n                    CMD_OUT = 0;\n                    st_dat_t = 2'b11;\n                    cmd_oe_o = 0;\n                    cmd_out_o = 0;\n                    FSM_ACK = 0;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = Delay_Cnt + 1;\n                    Cmd_Cnt = 1;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000110;\n                    CRC_Valid = 0;\n                end\n            ACK_WO:\n                begin\n                    ACK_OUT = 1;\n                    CMD_OUT = 0;\n                    st_dat_t = 2'b00;\n                    cmd_oe_o = 0;\n                    cmd_out_o = 0;\n                    FSM_ACK = 1;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 0;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00000111;\n                    CRC_Valid = 0;\n                end\n            ACK_WR:\n                begin\n                    ACK_OUT = 1;\n                    CMD_OUT = 0;\n                    st_dat_t = 2'b00;\n                    cmd_oe_o = 0;\n                    cmd_out_o = 0;\n                    FSM_ACK = 1;\n                    REQ_OUT = 0;\n                    CRC_Enable = 0;\n                    word_select_counter = 0;\n                    Delay_Cnt = 0;\n                    Cmd_Cnt = 0;\n                    CRC_RST = 1;\n                    CRC_OUT = 0;\n                    CRC_IN = 0;\n                    Crc_Buffering = 0;\n                    STATUS = 8'b00001000;\n                    CRC_Valid = 0;\n                end\n            default:\n                ACK_OUT = 0;\n                CMD_OUT = 0;\n                st_dat_t = 2'b00;\n                cmd_oe_o = 0;\n                cmd_out_o = 0;\n                FSM_ACK = 1;\n                REQ_OUT = 0;\n                CRC_Enable = 0;\n                word_select_counter = 0;\n                Delay_Cnt = 0;\n                Cmd_Cnt = 0;\n                CRC_RST = 1;\n                CRC_OUT = 0;\n                CRC_IN = 0;\n                Crc_Buffering = 0;\n                STATUS = 8'b00000000;\n                CRC_Valid = 0;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            state <= 10'd0;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            q <= 0;\n        else\n            q <= REQ_IN;\n    end\n\n    always @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            Req_internal_in <= 0;\n        else\n            Req_internal_in <= q;\n    end\n\n    // ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            q1 <= 0;\n        else\n            q1 <= ACK_IN;\n    end\n\n    always @(posedge SD_CLK_IN or posedge RST_IN)\n    begin\n        if (RST_IN)\n            Ack_internal_in <= 0;\n        else\n            Ack_internal_in <= q1;\n    end\n\n    // sd_crc_7\n    sd_crc_7 sd_crc_7_module(\n        .BITVAL(cmd_dat_i),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(RST_IN),\n        .CRC(CRC_OUT)\n    );\n\n    // FSM_COMBO\n    always_comb\n    begin\n        case(state)\n            INIT:\n                begin\n                    next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n                end\n            IDLE:\n                begin\n                    next_state = (Write_Read) ? WRITE_WR : ((Write_Only) ? WRITE_WO : IDLE);\n                end\n            WRITE_WR:\n                begin\n                    next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n                end\n            WRITE_WO:\n                begin\n                    next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n                end\n            DLY_WR:\n                begin\n                    next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n                end\n            DLY_WO:\n                begin\n                    next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n                end\n            READ_WR:\n                begin\n                    next_state = (Cmd_Cnt >= Response_Size + EIGHT_PAD) ? DLY_READ : READ_WR;\n                end\n            DLY_READ:\n                begin\n                    next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n                end\n            ACK_WO:\n                begin\n                    next_state = IDLE;\n                end\n            ACK_WR:\n                begin\n                    next_state = IDLE;\n                end\n            default:\n                next_state = INIT;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 20, "code": "module sd_cmd_serial_host(\n    input  wire sd_clk_in,\n    input  wire rst_in,\n    input  wire [15:0] setting_in,\n    input  wire [39:0] cmd_in,\n    input  wire req_in,\n    input  wire ack_in,\n    input  wire cmd_dat_i,\n    output wire [39:0] cmd_out,\n    output wire ack_out,\n    output wire req_out,\n    output wire [7:0] status,\n    output wire cmd_oe_o,\n    output wire cmd_out_o,\n    output wire [1:0] st_dat_t\n);\n\n// Internal signals\nreg [9:0] state;\nreg [9:0] next_state;\nreg [2:0] delay_cycler;\nreg [3:0] delay_cnt;\nreg [7:0] response_size;\nreg [3:0] cmd_cnt;\nreg [2:0] in_buff;\nreg [2:0] out_buff;\nreg [1:0] write_read;\nreg [1:0] write_only;\nreg [1:0] block_write;\nreg [1:0] block_read;\nreg [1:0] word_select;\nreg [1:0] fsm_ack;\nreg [1:0] decoder_ack;\nreg [1:0] crc_check_on;\nreg [1:0] crc_valid;\nreg [1:0] crc_buffering;\nreg [1:0] crc_out;\nreg [1:0] crc_in;\nreg [1:0] crc_enable;\nreg [1:0] crc_rst;\nreg [1:0] req_internal_in;\nreg [1:0] ack_internal_in;\nreg [1:0] req_out;\nreg [1:0] cmd_out_o;\nreg [1:0] cmd_oe_o;\nreg [1:0] fsm_ack;\nreg [1:0] decoder_ack;\nreg [1:0] crc_valid;\nreg [1:0] crc_buffering;\nreg [1:0] crc_out;\nreg [1:0] crc_in;\nreg [1:0] crc_enable;\nreg [1:0] crc_rst;\n\n// State machine\nalways @(posedge sd_clk_in) begin\n    if (rst_in) begin\n        state <= 0;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        0: next_state = 1;\n        1: next_state = 2;\n        2: next_state = 3;\n        3: next_state = 4;\n        4: next_state = 5;\n        5: next_state = 6;\n        6: next_state = 7;\n        7: next_state = 8;\n        8: next_state = 9;\n        9: next_state = 10;\n        10: next_state = 11;\n        11: next_state = 12;\n        12: next_state = 13;\n        13: next_state = 14;\n        14: next_state = 15;\n        15: next_state = 16;\n        default: next_state = 0;\n    endcase\nend\n\n// Output logic\nalways @(*) begin\n    case (state)\n        0: begin\n            cmd_out_o = 0;\n            cmd_oe_o = 0;\n            req_out = 0;\n            ack_out = 0;\n            status = 0;\n        end\n        1: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        2: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        3: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        4: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        5: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        6: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        7: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        8: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        9: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        10: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        11: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        12: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        13: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        14: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        15: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        16: begin\n            cmd_out_o = 1;\n            cmd_oe_o = 1;\n            req_out = 1;\n            ack_out = 0;\n            status = 0;\n        end\n        default: begin\n            cmd_out_o = 0;\n            cmd_oe_o = 0;\n            req_out = 0;\n            ack_out = 0;\n            status = 0;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
