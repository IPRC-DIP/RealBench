{"task": "sdc_controller", "codeid": 1, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    //... (rest of the code remains the same)", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 2, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    //... (rest of the code remains the same)", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 3, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    //... (rest of the code)", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 4, "code": "module sd_controller_wb(\n    input  wire clk_i,\n    input  wire rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire         wb_we_i,\n    input  wire         wb_cyc_i,\n    input  wire         wb_stb_i,\n    output wire         wb_ack_o,\n    output wire         we_m_tx_bd,\n    output wire         we_m_rx_bd,\n    output wire         new_cmd,\n    output wire         we_ack,\n    output wire         int_ack,\n    output wire         cmd_int_busy,\n    output wire         int_busy,\n    input  wire         write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire         Bd_isr_reset,\n    output wire         normal_isr_reset,\n    output wire         error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // ... (rest of the module implementation)", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 5, "code": "module sd_controller_wb(\n    // Wishbone Slave Interface\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    // Master Wishbone Interface Control\n    output wire        m_wb_cyc_o,\n    output wire        m_wb_stb_o,\n    output wire [2:0]  m_wb_cti_o,\n    output wire [1:0]  m_wb_bte_o,\n    output wire        m_wb_we_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire [31:0] m_wb_dat_o,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire        m_wb_ack_i,\n    // SDC IO\n    output wire        sd_cmd_out_o,\n    output wire        sd_cmd_oe_o,\n    input  wire        sd_dat_dat_i,\n    output wire        sd_dat_out_o,\n    output wire        sd_dat_oe_o,\n    output wire        sd_clk_o_pad,\n    input  wire        sd_clk_i_pad,\n    output wire        int_a,\n    output wire        int_b,\n    output wire        int_c,\n    // Optional IO\n    input  wire        sd_clk_i_pad,\n    output wire        int_a,\n    output wire        int_b,\n    output wire        int_c\n);\n\n    // Wishbone Slave Interface\n    reg [31:0] wb_dat_o_reg;\n    reg [7:0]  wb_adr_i_reg;\n    reg [3:0]  wb_sel_i_reg;\n    reg        wb_we_i_reg;\n    reg        wb_cyc_i_reg;\n    reg        wb_stb_i_reg;\n    reg        wb_ack_o_reg;\n\n    // Master Wishbone Interface Control\n    reg        m_wb_cyc_o_reg;\n    reg        m_wb_stb_o_reg;\n    reg [2:0]  m_wb_cti_o_reg;\n    reg [1:0]  m_wb_bte_o_reg;\n    reg        m_wb_we_o_reg;\n    reg [31:0] m_wb_adr_o_reg;\n    reg [31:0] m_wb_dat_o_reg;\n    reg        m_wb_ack_i_reg;\n\n    // SDC IO\n    reg        sd_cmd_out_o_reg;\n    reg        sd_cmd_oe_o_reg;\n    reg [3:0]  sd_dat_dat_i_reg;\n    reg [3:0]  sd_dat_out_o_reg;\n    reg        sd_dat_oe_o_reg;\n    reg        sd_clk_o_pad_reg;\n    reg        sd_clk_i_pad_reg;\n    reg        int_a_reg;\n    reg        int_b_reg;\n    reg        int_c_reg;\n\n    // Optional IO\n    reg        sd_clk_i_pad_reg;\n    reg        int_a_reg;\n    reg        int_b_reg;\n    reg        int_c_reg;\n\n    // Wishbone Slave Interface\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            wb_dat_o_reg <= 32'd0;\n            wb_adr_i_reg <= 8'd0;\n            wb_sel_i_reg <= 4'd0;\n            wb_we_i_reg <= 1'd0;\n            wb_cyc_i_reg <= 1'd0;\n            wb_stb_i_reg <= 1'd0;\n            wb_ack_o_reg <= 1'd0;\n        end else begin\n            wb_dat_o_reg <= wb_dat_i;\n            wb_adr_i_reg <= wb_adr_i;\n            wb_sel_i_reg <= wb_sel_i;\n            wb_we_i_reg <= wb_we_i;\n            wb_cyc_i_reg <= wb_cyc_i;\n            wb_stb_i_reg <= wb_stb_i;\n            wb_ack_o_reg <= wb_ack_o;\n        end\n    end\n\n    // Master Wishbone Interface Control\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            m_wb_cyc_o_reg <= 1'd0;\n            m_wb_stb_o_reg <= 1'd0;\n            m_wb_cti_o_reg <= 3'd0;\n            m_wb_bte_o_reg <= 2'd0;\n            m_wb_we_o_reg <= 1'd0;\n            m_wb_adr_o_reg <= 32'd0;\n            m_wb_dat_o_reg <= 32'd0;\n            m_wb_ack_i_reg <= 1'd0;\n        end else begin\n            m_wb_cyc_o_reg <= m_wb_cyc_o;\n            m_wb_stb_o_reg <= m_wb_stb_o;\n            m_wb_cti_o_reg <= m_wb_cti_o;\n            m_wb_bte_o_reg <= m_wb_bte_o;\n            m_wb_we_o_reg <= m_wb_we_o;\n            m_wb_adr_o_reg <= m_wb_adr_o;\n            m_wb_dat_o_reg <= m_wb_dat_o;\n            m_wb_ack_i_reg <= m_wb_ack_i;\n        end\n    end\n\n    // SDC IO\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            sd_cmd_out_o_reg <= 1'd0;\n            sd_cmd_oe_o_reg <= 1'd0;\n            sd_dat_dat_i_reg <= 4'd0;\n            sd_dat_out_o_reg <= 4'd0;\n            sd_dat_oe_o_reg <= 1'd0;\n            sd_clk_o_pad_reg <= 1'd0;\n            sd_clk_i_pad_reg <= 1'd0;\n            int_a_reg <= 1'd0;\n            int_b_reg <= 1'd0;\n            int_c_reg <= 1'd0;\n        end else begin\n            sd_cmd_out_o_reg <= sd_cmd_out_o;\n            sd_cmd_oe_o_reg <= sd_cmd_oe_o;\n            sd_dat_dat_i_reg <= sd_dat_dat_i;\n            sd_dat_out_o_reg <= sd_dat_out_o;\n            sd_dat_oe_o_reg <= sd_dat_oe_o;\n            sd_clk_o_pad_reg <= sd_clk_o_pad;\n            sd_clk_i_pad_reg <= sd_clk_i_pad;\n            int_a_reg <= int_a;\n            int_b_reg <= int_b;\n            int_c_reg <= int_c;\n        end\n    end\n\n    // Optional IO\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            sd_clk_i_pad_reg <= 1'd0;\n            int_a_reg <= 1'd0;\n            int_b_reg <= 1'd0;\n            int_c_reg <= 1'd0;\n        end else begin\n            sd_clk_i_pad_reg <= sd_clk_i_pad;\n            int_a_reg <= int_a;\n            int_b_reg <= int_b;\n            int_c_reg <= int_c;\n        end\n    end\n\n    // Wishbone Slave Interface\n    assign wb_dat_o = wb_dat_o_reg;\n    assign wb_ack_o = wb_ack_o_reg;\n\n    // Master Wishbone Interface Control\n    assign m_wb_cyc_o = m_wb_cyc_o_reg;\n    assign m_wb_stb_o = m_wb_stb_o_reg;\n    assign m_wb_cti_o = m_wb_cti_o_reg;\n    assign m_wb_bte_o = m_wb_bte_o_reg;\n    assign m_wb_we_o = m_wb_we_o_reg;\n    assign m_wb_adr_o = m_wb_adr_o_reg;\n    assign m_wb_dat_o = m_wb_dat_o_reg;\n    assign m_wb_ack_i = m_wb_ack_i_reg;\n\n    // SDC IO\n    assign sd_cmd_out_o = sd_cmd_out_o_reg;\n    assign sd_cmd_oe_o = sd_cmd_oe_o_reg;\n    assign sd_dat_dat_i = sd_dat_dat_i_reg;\n    assign sd_dat_out_o = sd_dat_out_o_reg;\n    assign sd_dat_oe_o = sd_dat_oe_o_reg;\n    assign sd_clk_o_pad = sd_clk_o_pad_reg;\n    assign sd_clk_i_pad = sd_clk_i_pad_reg;\n    assign int_a = int_a_reg;\n    assign int_b = int_b_reg;\n    assign int_c = int_c_reg;\n\n    // Optional IO\n    assign sd_clk_i_pad = sd_clk_i_pad_reg;\n    assign int_a = int_a_reg;\n    assign int_b = int_b_reg;\n    assign int_c = int_c_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 6, "code": "module sd_controller_wb(\n    input  wire  clk_i,\n    input  wire  rst_i,\n    input  wire  wb_dat_i[31:0],\n    output wire  wb_dat_o[31:0],\n    input  wire  wb_adr_i[7:0],\n    input  wire  wb_sel_i[3:0],\n    input  wire  wb_we_i,\n    input  wire  wb_cyc_i,\n    input  wire  wb_stb_i,\n    output wire  wb_ack_o,\n    output wire  we_m_tx_bd,\n    output wire  we_m_rx_bd,\n    output wire  new_cmd,\n    output wire  we_ack,\n    output wire  int_ack,\n    output wire  cmd_int_busy,\n    output wire  int_busy,\n    input  wire  write_req_s,\n    input  wire  cmd_set_s[15:0],\n    input  wire  cmd_arg_s[31:0],\n    output wire  argument_reg[31:0],\n    output wire  cmd_setting_reg[15:0],\n    input  wire  status_reg[15:0],\n    input  wire  cmd_resp_1[31:0],\n    output wire  software_reset_reg[7:0],\n    output wire  time_out_reg[15:0],\n    input  wire  normal_int_status_reg[15:0],\n    input  wire  error_int_status_reg[15:0],\n    output wire  normal_int_signal_enable_reg[15:0],\n    output wire  error_int_signal_enable_reg[15:0],\n    output wire  clock_divider[7:0],\n    input  wire  Bd_Status_reg[15:0],\n    input  wire  Bd_isr_reg[7:0],\n    output wire  Bd_isr_enable_reg[7:0],\n    output wire  Bd_isr_reset,\n    output wire  normal_isr_reset,\n    output wire  error_isr_reset,\n    output wire  dat_in_m_tx_bd[RAM_MEM_WIDTH-1:0],\n    output wire  dat_in_m_rx_bd[RAM_MEM_WIDTH-1:0]\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_cmd_master(\n    input  wire  clk_i,\n    input  wire  rst_i,\n    input  wire  New_CMD,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire  ARG_REG[31:0],\n    input  wire  CMD_SET_REG[15:0],\n    input  wire  TIMEOUT_REG[15:0],\n    output wire  STATUS_REG[15:0],\n    output wire  RESP_1_REG[31:0],\n    output wire  ERR_INT_REG[5:0],\n    output wire  NORMAL_INT_REG[15:0],\n    input  wire  ERR_INT_RST,\n    input  wire  NORMAL_INT_RST,\n    output wire  settings[15:0],\n    output wire  go_idle_o,\n    output wire  cmd_out[39:0],\n    output wire  req_out,\n    output wire  ack_out,\n    input  wire  req_in,\n    input  wire  ack_in,\n    input  wire  cmd_in[39:0],\n    input  wire  serial_status[7:0],\n    input  wire  card_detect\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_data_master(\n    input  wire  clk_i,\n    input  wire  rst_i,\n    input  wire  dat_in_tx[RAM_MEM_WIDTH-1:0],\n    input  wire  free_tx_bd[BD_WIDTH-1:0],\n    input  wire  ack_i_s_tx,\n    input  wire  dat_in_rx[RAM_MEM_WIDTH-1:0],\n    input  wire  free_rx_bd[BD_WIDTH-1:0],\n    input  wire  ack_i_s_rx,\n    input  wire  cmd_busy,\n    input  wire  we_ack,\n    input  wire  cmd_tsf_err,\n    input  wire  card_status[5:0],\n    input  wire  tx_empt,\n    input  wire  tx_full,\n    input  wire  rx_full,\n    input  wire  busy_n,\n    input  wire  transm_complete,\n    input  wire  crc_ok,\n    input  wire  Dat_Int_Status_rst,\n    input  wire  transfer_type[1:0],\n    output wire  re_s_tx,\n    output wire  a_cmp_tx,\n    output wire  re_s_rx,\n    output wire  a_cmp_rx,\n    output wire  we_req,\n    output wire  d_write,\n    output wire  d_read,\n    output wire  cmd_arg[31:0],\n    output wire  cmd_set[15:0],\n    output wire  start_tx_fifo,\n    output wire  start_rx_fifo,\n    output wire  sys_adr[31:0],\n    output wire  ack_transfer,\n    output wire  Dat_Int_Status[7:0],\n    output wire  CIDAT,\n    output wire  dat_in_m_tx_bd[RAM_MEM_WIDTH-1:0],\n    output wire  dat_in_m_rx_bd[RAM_MEM_WIDTH-1:0]\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_fifo_tx_filler(\n    input  wire  clk_i,\n    input  wire  rst_i,\n    input  wire  m_wb_adr_o[31:0],\n    input  wire  m_wb_we_o,\n    input  wire  m_wb_dat_i[31:0],\n    input  wire  m_wb_cyc_o,\n    input  wire  m_wb_stb_o,\n    input  wire  m_wb_ack_i,\n    input  wire  m_wb_cti_o[2:0],\n    input  wire  m_wb_bte_o[1:0],\n    input  wire  en,\n    input  wire  adr[31:0],\n    input  wire  sd_clk,\n    output wire  dat_o[31:0],\n    input  wire  rd,\n    output wire  empty,\n    output wire  fe\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_fifo_rx_filler(\n    input  wire  clk_i,\n    input  wire  rst_i,\n    input  wire  m_wb_adr_o[31:0],\n    input  wire  m_wb_we_o,\n    input  wire  m_wb_dat_o[31:0],\n    input  wire  m_wb_cyc_o,\n    input  wire  m_wb_stb_o,\n    input  wire  m_wb_ack_i,\n    input  wire  m_wb_cti_o[2:0],\n    input  wire  m_wb_bte_o[1:0],\n    input  wire  en,\n    input  wire  adr[31:0],\n    input  wire  sd_clk,\n    input  wire  dat_i[SD_BUS_W-1:0],\n    input  wire  wr,\n    output wire  full,\n    output wire  empty,\n    output wire  mem_empt[5:0]\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_clock_divider(\n    input  wire  clk_i,\n    input  wire  rst_i,\n    input  wire  DIVIDER[7:0],\n    output wire  sd_clk\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_cmd_serial_host(\n    input  wire  sd_clk_i,\n    input  wire  rst_i,\n    input  wire  New_CMD,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire  ARG_REG[31:0],\n    input  wire  CMD_SET_REG[15:0],\n    input  wire  TIMEOUT_REG[15:0],\n    output wire  STATUS_REG[15:0],\n    output wire  RESP_1_REG[31:0],\n    output wire  ERR_INT_REG[5:0],\n    output wire  NORMAL_INT_REG[15:0],\n    input  wire  ERR_INT_RST,\n    input  wire  NORMAL_INT_RST,\n    output wire  settings[15:0],\n    output wire  go_idle_o,\n    output wire  cmd_out[39:0],\n    output wire  req_out,\n    output wire  ack_out,\n    input  wire  req_in,\n    input  wire  ack_in,\n    input  wire  cmd_in[39:0],\n    input  wire  serial_status[7:0],\n    input  wire  card_detect\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_data_serial_host(\n    input  wire  sd_clk,\n    input  wire  rst_i,\n    input  wire  data_in[31:0],\n    input  wire  start_dat[1:0],\n    input  wire  ack_transfer,\n    input  wire  DAT_dat_i[SD_BUS_W-1:0],\n    output wire  rd,\n    output wire  data_out[SD_BUS_W-1:0],\n    output wire  we,\n    output wire  DAT_oe_o,\n    output wire  DAT_dat_o[SD_BUS_W-1:0],\n    output wire  busy_n,\n    output wire  transm_complete,\n    output wire  crc_ok\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_crc_16(\n    input  wire  BITVAL,\n    input  wire  Enable,\n    input  wire  CLK,\n    input  wire  RST,\n    output wire  CRC[15:0]\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_crc_7(\n    input  wire  BITVAL,\n    input  wire  Enable,\n    input  wire  CLK,\n    input  wire  RST,\n    output wire  CRC[6:0]\n);\n\n    //... rest of the code...\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 7, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire        dat_in_m_tx_bd,\n    output wire        dat_in_m_rx_bd\n);\n\n    // ... (rest of the module implementation)", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 8, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    //... (rest of the code)\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 9, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    //... (rest of the module code)", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 10, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Wishbone Slave Interface\n    wire        wb_cyc_o;\n    wire        wb_stb_o;\n    wire        wb_we_o;\n    wire [31:0] wb_dat_o;\n    wire [7:0]  wb_adr_o;\n    wire        wb_ack_i;\n\n    // Master Wishbone Interface\n    wire        m_wb_cyc_o;\n    wire        m_wb_stb_o;\n    wire        m_wb_we_o;\n    wire [31:0] m_wb_dat_o;\n    wire [7:0]  m_wb_adr_o;\n    wire        m_wb_ack_i;\n\n    // Internal Registers\n    reg [31:0] argument_reg;\n    reg [15:0] cmd_setting_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [7:0]  software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0]  clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [7:0]  Bd_isr_reg;\n    reg [7:0]  Bd_isr_enable_reg;\n    reg        Bd_isr_reset;\n    reg        normal_isr_reset;\n    reg        error_isr_reset;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Wishbone Slave Interface Logic\n    always @(posedge wb_clk_i or posedge wb_rst_i)\n    begin\n        if (wb_rst_i)\n        begin\n            wb_cyc_o <= 1'b0;\n            wb_stb_o <= 1'b0;\n            wb_we_o <= 1'b0;\n            wb_dat_o <= 32'h0;\n            wb_adr_o <= 8'h0;\n            wb_ack_i <= 1'b0;\n        end\n        else\n        begin\n            wb_cyc_o <= wb_cyc_i;\n            wb_stb_o <= wb_stb_i;\n            wb_we_o <= wb_we_i;\n            wb_dat_o <= wb_dat_i;\n            wb_adr_o <= wb_adr_i;\n            wb_ack_i <= wb_ack_o;\n        end\n    end\n\n    // Master Wishbone Interface Logic\n    always @(posedge wb_clk_i or posedge wb_rst_i)\n    begin\n        if (wb_rst_i)\n        begin\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'h0;\n            m_wb_adr_o <= 8'h0;\n            m_wb_ack_i <= 1'b0;\n        end\n        else\n        begin\n            m_wb_cyc_o <= m_wb_cyc_o | (new_cmd & (wb_cyc_i & wb_stb_i));\n            m_wb_stb_o <= m_wb_stb_o | (new_cmd & wb_stb_i);\n            m_wb_we_o <= m_wb_we_o | (new_cmd & wb_we_i);\n            m_wb_dat_o <= m_wb_dat_o | (new_cmd & wb_dat_i);\n            m_wb_adr_o <= m_wb_adr_o | (new_cmd & wb_adr_i);\n            m_wb_ack_i <= m_wb_ack_i | (new_cmd & wb_ack_i);\n        end\n    end\n\n    // Internal Register Logic\n    always @(posedge wb_clk_i or posedge wb_rst_i)\n    begin\n        if (wb_rst_i)\n        begin\n            argument_reg <= 32'h0;\n            cmd_setting_reg <= 16'h0;\n            status_reg <= 16'h0;\n            cmd_resp_1 <= 32'h0;\n            software_reset_reg <= 8'h0;\n            time_out_reg <= 16'h0;\n            normal_int_status_reg <= 16'h0;\n            error_int_status_reg <= 16'h0;\n            normal_int_signal_enable_reg <= 16'h0;\n            error_int_signal_enable_reg <= 16'h0;\n            clock_divider <= 8'h0;\n            Bd_Status_reg <= 16'h0;\n            Bd_isr_reg <= 8'h0;\n            Bd_isr_enable_reg <= 8'h0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= RAM_MEM_WIDTH'h0;\n            dat_in_m_rx_bd <= RAM_MEM_WIDTH'h0;\n        end\n        else\n        begin\n            if (write_req_s)\n            begin\n                if (wb_we_i)\n                begin\n                    case (wb_adr_i[1:0])\n                        2'b00: argument_reg <= wb_dat_i;\n                        2'b01: cmd_setting_reg <= wb_dat_i[15:0];\n                        2'b10: cmd_setting_reg <= wb_dat_i[31:16];\n                        2'b11: cmd_setting_reg <= wb_dat_i[15:0];\n                    endcase\n                end\n                else\n                begin\n                    case (wb_adr_i[1:0])\n                        2'b00: argument_reg <= wb_dat_i;\n                        2'b01: cmd_setting_reg <= wb_dat_i[15:0];\n                        2'b10: cmd_setting_reg <= wb_dat_i[31:16];\n                        2'b11: cmd_setting_reg <= wb_dat_i[15:0];\n                    endcase\n                end\n            end\n        end\n    end\n\n    // Wishbone Slave Interface Logic\n    always @(posedge wb_clk_i or posedge wb_rst_i)\n    begin\n        if (wb_rst_i)\n        begin\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b0;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n        end\n        else\n        begin\n            wb_ack_o <= wb_ack_i;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b0;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            if (wb_cyc_i & wb_stb_i & ~wb_ack_o & int_ack)\n            begin\n                wb_ack_o <= 1'b1;\n            end\n        end\n    end\n\n    // Master Wishbone Interface Logic\n    always @(posedge wb_clk_i or posedge wb_rst_i)\n    begin\n        if (wb_rst_i)\n        begin\n            m_wb_ack_o <= 1'b0;\n        end\n        else\n        begin\n            m_wb_ack_o <= m_wb_ack_i;\n        end\n    end\n\n    // Internal Register Logic\n    always @(posedge wb_clk_i or posedge wb_rst_i)\n    begin\n        if (wb_rst_i)\n        begin\n            argument_reg <= 32'h0;\n            cmd_setting_reg <= 16'h0;\n            status_reg <= 16'h0;\n            cmd_resp_1 <= 32'h0;\n            software_reset_reg <= 8'h0;\n            time_out_reg <= 16'h0;\n            normal_int_status_reg <= 16'h0;\n            error_int_status_reg <= 16'h0;\n            normal_int_signal_enable_reg <= 16'h0;\n            error_int_signal_enable_reg <= 16'h0;\n            clock_divider <= 8'h0;\n            Bd_Status_reg <= 16'h0;\n            Bd_isr_reg <= 8'h0;\n            Bd_isr_enable_reg <= 8'h0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= RAM_MEM_WIDTH'h0;\n            dat_in_m_rx_bd <= RAM_MEM_WIDTH'h0;\n        end\n        else\n        begin\n            if (write_req_s)\n            begin\n                if (wb_we_i)\n                begin\n                    case (wb_adr_i[1:0])\n                        2'b00: argument_reg <= wb_dat_i;\n                        2'b01: cmd_setting_reg <= wb_dat_i[15:0];\n                        2'b10: cmd_setting_reg <= wb_dat_i[31:16];\n                        2'b11: cmd_setting_reg <= wb_dat_i[15:0];\n                    endcase\n                end\n                else\n                begin\n                    case (wb_adr_i[1:0])\n                        2'b00: argument_reg <= wb_dat_i;\n                        2'b01: cmd_setting_reg <= wb_dat_i[15:0];\n                        2'b10: cmd_setting_reg <= wb_dat_i[31:16];\n                        2'b11: cmd_setting_reg <= wb_dat_i[15:0];\n                    endcase\n                end\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 11, "code": "module sdc_controller(\n    // Wishbone interface\n    input  wire  wb_clk_i,\n    input  wire  wb_rst_i,\n    input  wire  wb_dat_i [31:0],\n    output wire  wb_dat_o [31:0],\n    input  wire  wb_adr_i [7:0],\n    input  wire  wb_sel_i [3:0],\n    input  wire  wb_we_i,\n    input  wire  wb_cyc_i,\n    input  wire  wb_stb_i,\n    output wire  wb_ack_o,\n    output wire  we_m_tx_bd,\n    output wire  we_m_rx_bd,\n    output wire  new_cmd,\n    output wire  we_ack,\n    output wire  int_ack,\n    output wire  cmd_int_busy,\n    output wire  int_busy,\n    input  wire  write_req_s,\n    input  wire  cmd_set_s [15:0],\n    input  wire  cmd_arg_s [31:0],\n    output wire  argument_reg [31:0],\n    output wire  cmd_setting_reg [15:0],\n    input  wire  status_reg [15:0],\n    input  wire  cmd_resp_1 [31:0],\n    output wire  software_reset_reg [7:0],\n    output wire  time_out_reg [15:0],\n    input  wire  normal_int_status_reg [15:0],\n    input  wire  error_int_status_reg [15:0],\n    output wire  normal_int_signal_enable_reg [15:0],\n    output wire  error_int_signal_enable_reg [15:0],\n    output wire  clock_divider [7:0],\n    input  wire  Bd_Status_reg [15:0],\n    input  wire  Bd_isr_reg [7:0],\n    output wire  Bd_isr_enable_reg [7:0],\n    output wire  Bd_isr_reset,\n    output wire  normal_isr_reset,\n    output wire  error_isr_reset,\n    output wire  dat_in_m_tx_bd [RAM_MEM_WIDTH-1:0],\n    output wire  dat_in_m_rx_bd [RAM_MEM_WIDTH-1:0],\n\n    // SDC interface\n    input  wire  sd_cmd_dat_i,\n    output wire  sd_cmd_out_o,\n    output wire  sd_cmd_oe_o,\n    input  wire  sd_dat_dat_i [3:0],\n    output wire  sd_dat_out_o [3:0],\n    output wire  sd_dat_oe_o,\n    output wire  sd_clk_o_pad,\n    input  wire  sd_clk_i_pad,\n    output wire  int_a,\n    output wire  int_b,\n    output wire  int_c,\n\n    // Optional interface\n    input  wire  sd_clk_i_pad,\n    output wire  int_a,\n    output wire  int_b,\n    output wire  int_c\n);\n\n    // sd_controller_wb module\n    sd_controller_wb sd_controller_wb(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .Bd_isr_reset(Bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // sd_clock_divider module\n    sd_clock_divider sd_clock_divider(\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // sd_cmd_master module\n    sd_cmd_master sd_cmd_master(\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(write_req_s),\n        .data_read(write_req_s),\n        .ARG_REG(cmd_arg_s),\n        .CMD_SET_REG(cmd_set_s),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(cmd_setting_reg),\n        .go_idle_o(int_ack),\n        .cmd_out(cmd_setting_reg),\n        .req_out(we_ack),\n        .ack_out(we_ack),\n        .req_in(write_req_s),\n        .ack_in(we_ack),\n        .cmd_in(cmd_setting_reg),\n        .serial_status(status_reg),\n        .card_detect(sd_cmd_dat_i)\n    );\n\n    // sd_cmd_serial_host module\n    sd_cmd_serial_host sd_cmd_serial_host(\n        .SD_CLK_IN(wb_clk_i),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(cmd_setting_reg),\n        .REQ_IN(write_req_s),\n        .ACK_IN(we_ack),\n        .cmd_dat_i(sd_dat_dat_i),\n        .cmd_out_o(sd_cmd_out_o),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .st_dat_t(status_reg),\n        .STATUS(status_reg)\n    );\n\n    // sd_data_master module\n    sd_data_master sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(Bd_Status_reg),\n        .ack_i_s_tx(we_ack),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(Bd_Status_reg),\n        .ack_i_s_rx(we_ack),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(status_reg),\n        .card_status(status_reg),\n        .tx_empt(status_reg),\n        .tx_full(status_reg),\n        .rx_full(status_reg),\n        .busy_n(status_reg),\n        .transm_complete(status_reg),\n        .crc_ok(status_reg),\n        .Dat_Int_Status_rst(Bd_isr_reset),\n        .transfer_type(status_reg),\n        .re_s_tx(we_ack),\n        .a_cmp_tx(we_ack),\n        .re_s_rx(we_ack),\n        .a_cmp_rx(we_ack),\n        .we_req(we_ack),\n        .d_write(we_ack),\n        .d_read(we_ack),\n        .cmd_arg(cmd_arg_s),\n        .cmd_set(cmd_setting_reg),\n        .start_tx_fifo(we_ack),\n        .start_rx_fifo(we_ack),\n        .sys_adr(argument_reg),\n        .ack_transfer(we_ack),\n        .Dat_Int_Status(status_reg),\n        .CIDAT(status_reg)\n    );\n\n    // sd_data_serial_host module\n    sd_data_serial_host sd_data_serial_host(\n        .sd_clk(sd_clk_o_pad),\n        .rst(wb_rst_i),\n        .data_in(dat_in_m_tx_bd),\n        .start_dat(status_reg),\n        .ack_transfer(we_ack),\n        .DAR_dat_i(sd_dat_dat_i),\n        .rd(we_ack),\n        .data_out(sd_dat_out_o),\n        .we(we_ack),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(status_reg),\n        .transm_complete(we_ack),\n        .crc_ok(status_reg)\n    );\n\n    // sd_fifo_tx_filler module\n    sd_fifo_tx_filler sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(argument_reg),\n        .m_wb_we_o(we_ack),\n        .m_wb_dat_i(dat_in_m_tx_bd),\n        .m_wb_cyc_o(we_ack),\n        .m_wb_stb_o(we_ack),\n        .m_wb_ack_i(we_ack),\n        .m_wb_cti_o(we_ack),\n        .m_wb_bte_o(we_ack),\n        .en(we_ack),\n        .adr(argument_reg),\n        .sd_clk(sd_clk_o_pad),\n        .dat_o(dat_in_m_tx_bd),\n        .rd(we_ack),\n        .empty(we_ack),\n        .fe(we_ack)\n    );\n\n    // sd_fifo_rx_filler module\n    sd_fifo_rx_filler sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(argument_reg),\n        .m_wb_we_o(we_ack),\n        .m_wb_dat_o(dat_in_m_rx_bd),\n        .m_wb_cyc_o(we_ack),\n        .m_wb_stb_o(we_ack),\n        .m_wb_ack_i(we_ack),\n        .m_wb_cti_o(we_ack),\n        .m_wb_bte_o(we_ack),\n        .en(we_ack),\n        .adr(argument_reg),\n        .sd_clk(sd_clk_o_pad),\n        .dat_i(sd_dat_dat_i),\n        .wr(we_ack),\n        .full(we_ack),\n        .empty(we_ack)\n    );\n\n    // sd_bd module\n    sd_bd sd_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_ack),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(Bd_Status_reg),\n        .re_s(we_ack),\n        .ack_o_s(we_ack),\n        .a_cmp(we_ack),\n        .dat_out_s(dat_in_m_rx_bd)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 12, "code": "module sd_controller_wb(\n    input  wire       wb_clk_i,\n    input  wire       wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // ... (rest of the code)\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 13, "code": "module sd_controller_wb(\n    input  wire  clk_i,\n    input  wire  rst_i,\n    input  wire  wb_dat_i[31:0],\n    output wire  wb_dat_o[31:0],\n    input  wire  wb_adr_i[7:0],\n    input  wire  wb_sel_i[3:0],\n    input  wire  wb_we_i,\n    input  wire  wb_cyc_i,\n    input  wire  wb_stb_i,\n    output wire  wb_ack_o,\n    output wire  we_m_tx_bd,\n    output wire  we_m_rx_bd,\n    output wire  new_cmd,\n    output wire  we_ack,\n    output wire  int_ack,\n    output wire  cmd_int_busy,\n    output wire  int_busy,\n    input  wire  write_req_s,\n    input  wire  cmd_set_s[15:0],\n    input  wire  cmd_arg_s[31:0],\n    output wire  argument_reg[31:0],\n    output wire  cmd_setting_reg[15:0],\n    input  wire  status_reg[15:0],\n    input  wire  cmd_resp_1[31:0],\n    output wire  software_reset_reg[7:0],\n    output wire  time_out_reg[15:0],\n    input  wire  normal_int_status_reg[15:0],\n    input  wire  error_int_status_reg[15:0],\n    output wire  normal_int_signal_enable_reg[15:0],\n    output wire  error_int_signal_enable_reg[15:0],\n    output wire  clock_divider[7:0],\n    input  wire  Bd_Status_reg[15:0],\n    input  wire  Bd_isr_reg[7:0],\n    output wire  Bd_isr_enable_reg[7:0],\n    output wire  Bd_isr_reset,\n    output wire  normal_isr_reset,\n    output wire  error_isr_reset,\n    output wire  dat_in_m_tx_bd[RAM_MEM_WIDTH-1:0],\n    output wire  dat_in_m_rx_bd[RAM_MEM_WIDTH-1:0]\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_clock_divider(\n    input  wire  clk_i,\n    input  wire  divider_i[7:0],\n    input  wire  rst_i,\n    output wire  sd_clk_o\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_cmd_master(\n    input  wire  clk_i,\n    input  wire  rst_i,\n    input  wire  new_cmd,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire  arg_reg[31:0],\n    input  wire  cmd_set_reg[15:0],\n    input  wire  time_out_reg[15:0],\n    output wire  status_reg[15:0],\n    output wire  resp_1_reg[31:0],\n    output wire  err_int_reg[5:0],\n    output wire  normal_int_reg[15:0],\n    input  wire  err_int_reset,\n    input  wire  normal_int_reset,\n    output wire  settings[15:0],\n    output wire  go_idle_o,\n    output wire  cmd_out[39:0],\n    output wire  req_out,\n    output wire  ack_out,\n    input  wire  req_in,\n    input  wire  ack_in,\n    input  wire  cmd_in[39:0],\n    input  wire  serial_status[7:0],\n    input  wire  card_detect\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_data_master(\n    input  wire  clk_i,\n    input  wire  rst_i,\n    input  wire  dat_in_tx[RAM_MEM_WIDTH-1:0],\n    input  wire  free_tx_bd[BD_WIDTH-1:0],\n    input  wire  ack_i_s_tx,\n    input  wire  dat_in_rx[RAM_MEM_WIDTH-1:0],\n    input  wire  free_rx_bd[BD_WIDTH-1:0],\n    input  wire  ack_i_s_rx,\n    input  wire  cmd_busy,\n    input  wire  we_ack,\n    input  wire  cmd_tsf_err,\n    input  wire  card_status[4:0],\n    input  wire  tx_empt,\n    input  wire  tx_full,\n    input  wire  rx_full,\n    input  wire  busy_n,\n    input  wire  transm_complete,\n    input  wire  crc_ok,\n    input  wire  Dat_Int_Status_rst,\n    input  wire  transfer_type[1:0],\n    output wire  re_s_tx,\n    output wire  a_cmp_tx,\n    output wire  re_s_rx,\n    output wire  a_cmp_rx,\n    output wire  we_req,\n    output wire  d_write,\n    output wire  d_read,\n    output wire  cmd_arg[31:0],\n    output wire  cmd_set[15:0],\n    output wire  start_tx_fifo,\n    output wire  start_rx_fifo,\n    output wire  sys_adr[31:0],\n    output wire  ack_transfer,\n    output wire  Dat_Int_Status[7:0],\n    output wire  CIDAT,\n    output wire  dat_in_m_tx_bd[RAM_MEM_WIDTH-1:0],\n    output wire  dat_in_m_rx_bd[RAM_MEM_WIDTH-1:0]\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_fifo_tx_filler(\n    input  wire  clk_i,\n    input  wire  rst_i,\n    output wire  m_wb_adr_o[31:0],\n    output wire  m_wb_we_o,\n    input  wire  m_wb_dat_i[31:0],\n    output wire  m_wb_cyc_o,\n    output wire  m_wb_stb_o,\n    input  wire  m_wb_ack_i,\n    output wire  m_wb_cti_o[2:0],\n    output wire  m_wb_bte_o[1:0],\n    input  wire  en,\n    input  wire  adr[31:0],\n    input  wire  sd_clk_i,\n    output wire  dat_o[31:0],\n    input  wire  rd,\n    output wire  fe,\n    output wire  fe\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_fifo_rx_filler(\n    input  wire  clk_i,\n    input  wire  rst_i,\n    output wire  m_wb_adr_o[31:0],\n    output wire  m_wb_we_o,\n    input  wire  m_wb_dat_i[31:0],\n    output wire  m_wb_cyc_o,\n    output wire  m_wb_stb_o,\n    input  wire  m_wb_ack_i,\n    output wire  m_wb_cti_o[2:0],\n    output wire  m_wb_bte_o[1:0],\n    input  wire  en,\n    input  wire  adr[31:0],\n    input  wire  sd_clk_i,\n    input  wire  dat_i[SD_BUS_W-1:0],\n    input  wire  wr,\n    output wire  full,\n    output wire  empty,\n    output wire  mem_empt[5:0]\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire  clk_i,\n    input  wire  rst_i,\n    output wire  we_m,\n    input  wire  dat_in_m[RAM_MEM_WIDTH-1:0],\n    output wire  free_bd[BD_WIDTH-1:0],\n    input  wire  re_s,\n    output wire  ack_o_s,\n    input  wire  a_cmp,\n    output wire  dat_out_s[RAM_MEM_WIDTH-1:0]\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_cmd_serial_host(\n    input  wire  sd_clk_i,\n    input  wire  rst_i,\n    input  wire  new_cmd,\n    input  wire  data_write,\n    input  wire  data_read,\n    input  wire  arg_reg[31:0],\n    input  wire  cmd_set_reg[15:0],\n    input  wire  time_out_reg[15:0],\n    output wire  status_reg[15:0],\n    output wire  resp_1_reg[31:0],\n    output wire  err_int_reg[5:0],\n    output wire  normal_int_reg[15:0],\n    input  wire  err_int_reset,\n    input  wire  normal_int_reset,\n    output wire  settings[15:0],\n    output wire  go_idle_o,\n    output wire  cmd_out[39:0],\n    output wire  req_out,\n    output wire  ack_out,\n    input  wire  req_in,\n    input  wire  ack_in,\n    input  wire  cmd_in[39:0],\n    input  wire  serial_status[7:0],\n    input  wire  card_detect\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_data_serial_host(\n    input  wire  sd_clk_i,\n    input  wire  rst_i,\n    input  wire  data_in[31:0],\n    input  wire  start_dat[1:0],\n    output wire  rd,\n    output wire  data_out[SD_BUS_W-1:0],\n    output wire  we,\n    output wire  DAT_oe_o,\n    output wire  DAT_dat_o[SD_BUS_W-1:0],\n    input  wire  DAT_dat_i[SD_BUS_W-1:0],\n    output wire  busy_n,\n    output wire  transm_complete,\n    output wire  crc_ok\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_crc_16(\n    input  wire  BITVAL,\n    input  wire  Enable,\n    input  wire  CLK,\n    input  wire  RST,\n    output wire  CRC[15:0]\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_crc_7(\n    input  wire  BITVAL,\n    input  wire  Enable,\n    input  wire  CLK,\n    input  wire  RST,\n    output wire  CRC[6:0]\n);\n\n    //... rest of the code...\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 14, "code": "module sd_controller_wb(\n    input  wire  wb_clk_i,\n    input  wire  wb_rst_i,\n    input  wire  wb_dat_i[31:0],\n    output wire  wb_dat_o[31:0],\n    input  wire  wb_adr_i[7:0],\n    input  wire  wb_sel_i[3:0],\n    input  wire  wb_we_i,\n    input  wire  wb_cyc_i,\n    input  wire  wb_stb_i,\n    output wire  wb_ack_o,\n    output wire  we_m_tx_bd,\n    output wire  we_m_rx_bd,\n    output wire  new_cmd,\n    output wire  we_ack,\n    output wire  int_ack,\n    output wire  cmd_int_busy,\n    output wire  int_busy,\n    input  wire  write_req_s,\n    input  wire  cmd_set_s[15:0],\n    input  wire  cmd_arg_s[31:0],\n    output wire  argument_reg[31:0],\n    output wire  cmd_setting_reg[15:0],\n    input  wire  status_reg[15:0],\n    input  wire  cmd_resp_1[31:0],\n    output wire  software_reset_reg[7:0],\n    output wire  time_out_reg[15:0],\n    input  wire  normal_int_status_reg[15:0],\n    input  wire  error_int_status_reg[15:0],\n    output wire  normal_int_signal_enable_reg[15:0],\n    output wire  error_int_signal_enable_reg[15:0],\n    output wire  clock_divider[7:0],\n    input  wire  Bd_Status_reg[15:0],\n    input  wire  Bd_isr_reg[7:0],\n    output wire  Bd_isr_enable_reg[7:0],\n    output wire  Bd_isr_reset,\n    output wire  normal_isr_reset,\n    output wire  error_isr_reset,\n    output wire  dat_in_m_tx_bd[RAM_MEM_WIDTH-1:0],\n    output wire  dat_in_m_rx_bd[RAM_MEM_WIDTH-1:0]\n);\n\n    // Wishbone Slave Interface\n    wire  wb_dat_o_valid;\n    wire  wb_dat_o_ready;\n    wire  wb_dat_i_valid;\n    wire  wb_dat_i_ready;\n    wire  wb_ack_o_valid;\n    wire  wb_ack_o_ready;\n    wire  wb_we_o_valid;\n    wire  wb_we_o_ready;\n    wire  wb_stb_o_valid;\n    wire  wb_stb_o_ready;\n    wire  wb_cyc_o_valid;\n    wire  wb_cyc_o_ready;\n    wire  wb_adr_o_valid;\n    wire  wb_adr_o_ready;\n    wire  wb_sel_o_valid;\n    wire  wb_sel_o_ready;\n\n    // Wishbone Master Interface\n    wire  m_wb_dat_i_valid;\n    wire  m_wb_dat_i_ready;\n    wire  m_wb_dat_o_valid;\n    wire  m_wb_dat_o_ready;\n    wire  m_wb_adr_o_valid;\n    wire  m_wb_adr_o_ready;\n    wire  m_wb_we_o_valid;\n    wire  m_wb_we_o_ready;\n    wire  m_wb_stb_o_valid;\n    wire  m_wb_stb_o_ready;\n    wire  m_wb_cyc_o_valid;\n    wire  m_wb_cyc_o_ready;\n    wire  m_wb_ack_i_valid;\n    wire  m_wb_ack_i_ready;\n    wire  m_wb_cti_o_valid;\n    wire  m_wb_cti_o_ready;\n    wire  m_wb_bte_o_valid;\n    wire  m_wb_bte_o_ready;\n\n    // Internal Signals\n    wire  new_cmd_int;\n    wire  we_ack_int;\n    wire  int_ack_int;\n    wire  cmd_int_busy_int;\n    wire  int_busy_int;\n    wire  write_req_s_int;\n    wire  cmd_set_s_int[15:0];\n    wire  cmd_arg_s_int[31:0];\n    wire  argument_reg_int[31:0];\n    wire  cmd_setting_reg_int[15:0];\n    wire  status_reg_int[15:0];\n    wire  cmd_resp_1_int[31:0];\n    wire  software_reset_reg_int[7:0];\n    wire  time_out_reg_int[15:0];\n    wire  normal_int_status_reg_int[15:0];\n    wire  error_int_status_reg_int[15:0];\n    wire  normal_int_signal_enable_reg_int[15:0];\n    wire  error_int_signal_enable_reg_int[15:0];\n    wire  clock_divider_int[7:0];\n    wire  Bd_Status_reg_int[15:0];\n    wire  Bd_isr_reg_int[7:0];\n    wire  Bd_isr_enable_reg_int[7:0];\n    wire  Bd_isr_reset_int;\n    wire  normal_isr_reset_int;\n    wire  error_isr_reset_int;\n    wire  dat_in_m_tx_bd_int[RAM_MEM_WIDTH-1:0];\n    wire  dat_in_m_rx_bd_int[RAM_MEM_WIDTH-1:0];\n\n    // Wishbone Slave Interface Logic\n    assign wb_dat_o_valid = wb_dat_i_valid;\n    assign wb_dat_o_ready = wb_dat_i_ready;\n    assign wb_ack_o_valid = wb_ack_o_ready;\n    assign wb_ack_o_ready = wb_ack_o_valid;\n    assign wb_we_o_valid = wb_we_i;\n    assign wb_we_o_ready = wb_we_i;\n    assign wb_stb_o_valid = wb_stb_i;\n    assign wb_stb_o_ready = wb_stb_i;\n    assign wb_cyc_o_valid = wb_cyc_i;\n    assign wb_cyc_o_ready = wb_cyc_i;\n    assign wb_adr_o_valid = wb_adr_i_valid;\n    assign wb_adr_o_ready = wb_adr_i_ready;\n    assign wb_sel_o_valid = wb_sel_i_valid;\n    assign wb_sel_o_ready = wb_sel_i_ready;\n\n    // Wishbone Master Interface Logic\n    assign m_wb_dat_i_valid = m_wb_dat_o_valid;\n    assign m_wb_dat_i_ready = m_wb_dat_o_ready;\n    assign m_wb_dat_o_valid = m_wb_dat_i_valid;\n    assign m_wb_dat_o_ready = m_wb_dat_i_ready;\n    assign m_wb_adr_o_valid = m_wb_adr_i_valid;\n    assign m_wb_adr_o_ready = m_wb_adr_i_ready;\n    assign m_wb_we_o_valid = m_wb_we_i;\n    assign m_wb_we_o_ready = m_wb_we_i;\n    assign m_wb_stb_o_valid = m_wb_stb_i;\n    assign m_wb_stb_o_ready = m_wb_stb_i;\n    assign m_wb_cyc_o_valid = m_wb_cyc_i;\n    assign m_wb_cyc_o_ready = m_wb_cyc_i;\n    assign m_wb_ack_i_valid = m_wb_ack_o_valid;\n    assign m_wb_ack_i_ready = m_wb_ack_o_ready;\n    assign m_wb_cti_o_valid = m_wb_cti_i_valid;\n    assign m_wb_cti_o_ready = m_wb_cti_i_ready;\n    assign m_wb_bte_o_valid = m_wb_bte_i_valid;\n    assign m_wb_bte_o_ready = m_wb_bte_i_ready;\n\n    // Internal Logic\n    assign new_cmd_int = wb_dat_i_valid && wb_dat_i[31:28] == 4'b1010;\n    assign we_ack_int = wb_dat_i_valid && wb_dat_i[31:28] == 4'b1011;\n    assign int_ack_int = wb_dat_i_valid && wb_dat_i[31:28] == 4'b1100;\n    assign cmd_int_busy_int = wb_dat_i_valid && wb_dat_i[31:28] == 4'b1101;\n    assign int_busy_int = wb_dat_i_valid && wb_dat_i[31:28] == 4'b1110;\n    assign write_req_s_int = wb_dat_i_valid && wb_dat_i[31:28] == 4'b1111;\n    assign cmd_set_s_int[15:0] = wb_dat_i[31:16];\n    assign cmd_arg_s_int[31:0] = wb_dat_i[31:0];\n    assign argument_reg_int[31:0] = cmd_arg_s_int[31:0];\n    assign cmd_setting_reg_int[15:0] = cmd_set_s_int[15:0];\n    assign status_reg_int[15:0] = wb_dat_i[15:0];\n    assign cmd_resp_1_int[31:0] = wb_dat_i[31:0];\n    assign software_reset_reg_int[7:0] = wb_dat_i[7:0];\n    assign time_out_reg_int[15:0] = wb_dat_i[15:0];\n    assign normal_int_status_reg_int[15:0] = wb_dat_i[15:0];\n    assign error_int_status_reg_int[15:0] = wb_dat_i[15:0];\n    assign normal_int_signal_enable_reg_int[15:0] = wb_dat_i[15:0];\n    assign error_int_signal_enable_reg_int[15:0] = wb_dat_i[15:0];\n    assign clock_divider_int[7:0] = wb_dat_i[7:0];\n    assign Bd_Status_reg_int[15:0] = wb_dat_i[15:0];\n    assign Bd_isr_reg_int[7:0] = wb_dat_i[7:0];\n    assign Bd_isr_enable_reg_int[7:0] = wb_dat_i[7:0];\n    assign Bd_isr_reset_int = wb_dat_i_valid && wb_dat_i[31:28] == 4'b1000;\n    assign normal_isr_reset_int = wb_dat_i_valid && wb_dat_i[31:28] == 4'b1001;\n    assign error_isr_reset_int = wb_dat_i_valid && wb_dat_i[31:28] == 4'b1010;\n    assign dat_in_m_tx_bd_int[RAM_MEM_WIDTH-1:0] = wb_dat_i[RAM_MEM_WIDTH-1:0];\n    assign dat_in_m_rx_bd_int[RAM_MEM_WIDTH-1:0] = wb_dat_i[RAM_MEM_WIDTH-1:0];\n\n    // Wishbone Slave Interface\n    assign wb_dat_o[31:0] = argument_reg_int[31:0];\n    assign wb_ack_o = int_ack_int;\n    assign wb_we_o = wb_we_i;\n    assign wb_stb_o = wb_stb_i;\n    assign wb_cyc_o = wb_cyc_i;\n    assign wb_adr_o = wb_adr_i;\n    assign wb_sel_o = wb_sel_i;\n\n    // Wishbone Master Interface\n    assign m_wb_dat_o[31:0] = argument_reg_int[31:0];\n    assign m_wb_ack_i = int_ack_int;\n    assign m_wb_we_o = m_wb_we_i;\n    assign m_wb_stb_o = m_wb_stb_i;\n    assign m_wb_cyc_o = m_wb_cyc_i;\n    assign m_wb_adr_o = m_wb_adr_i;\n    assign m_wb_sel_o = m_wb_sel_i;\n    assign m_wb_cti_o = m_wb_cti_i;\n    assign m_wb_bte_o = m_wb_bte_i;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 15, "code": "module sd_controller_wb(\n    input  wire clk_i,\n    input  wire rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire we_m_tx_bd,\n    output wire we_m_rx_bd,\n    output wire new_cmd,\n    output wire we_ack,\n    output wire int_ack,\n    output wire cmd_int_busy,\n    output wire int_busy,\n    input  wire write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0] clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0] Bd_isr_reg,\n    output wire [7:0] Bd_isr_enable_reg,\n    output wire bd_isr_reset,\n    output wire normal_isr_reset,\n    output wire error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Registers\n    reg [31:0] argument_reg;\n    reg [15:0] cmd_setting_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [7:0] software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0] clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [7:0] Bd_isr_reg;\n    reg [7:0] Bd_isr_enable_reg;\n\n    // Outputs\n    assign wb_dat_o = wb_dat_i;\n    assign we_m_tx_bd = 1'b0;\n    assign we_m_rx_bd = 1'b0;\n    assign new_cmd = 1'b0;\n    assign we_ack = 1'b0;\n    assign int_ack = 1'b0;\n    assign cmd_int_busy = 1'b0;\n    assign int_busy = 1'b0;\n    assign argument_reg = cmd_arg_s;\n    assign cmd_setting_reg = cmd_set_s;\n    assign status_reg = status_reg;\n    assign cmd_resp_1 = cmd_resp_1;\n    assign software_reset_reg = 8'b00000000;\n    assign time_out_reg = 16'b0000000000000000;\n    assign normal_int_status_reg = normal_int_status_reg;\n    assign error_int_status_reg = error_int_status_reg;\n    assign normal_int_signal_enable_reg = normal_int_signal_enable_reg;\n    assign error_int_signal_enable_reg = error_int_signal_enable_reg;\n    assign clock_divider = 8'b00000000;\n    assign Bd_Status_reg = Bd_Status_reg;\n    assign Bd_isr_reg = Bd_isr_reg;\n    assign Bd_isr_enable_reg = Bd_isr_enable_reg;\n    assign bd_isr_reset = 1'b0;\n    assign normal_isr_reset = 1'b0;\n    assign error_isr_reset = 1'b0;\n    assign dat_in_m_tx_bd = 32'b00000000000000000000000000000000;\n    assign dat_in_m_rx_bd = 32'b00000000000000000000000000000000;\n\n    // FSM\n    reg [9:0] state;\n    reg [9:0] next_state;\n\n    // FSM State Machine\n    always @(posedge clk_i or posedge rst_i) begin\n        if (rst_i) begin\n            state <= 10'b0000000000;\n        end else begin\n            case (state)\n                10'b0000000000: begin\n                    if (write_req_s) begin\n                        next_state <= 10'b0000000001;\n                    end else begin\n                        next_state <= 10'b0000000000;\n                    end\n                end\n                10'b0000000001: begin\n                    if (wb_cyc_i && wb_stb_i && wb_we_i) begin\n                        next_state <= 10'b0000000002;\n                    end else begin\n                        next_state <= 10'b0000000001;\n                    end\n                end\n                10'b0000000002: begin\n                    if (wb_ack_i) begin\n                        next_state <= 10'b0000000003;\n                    end else begin\n                        next_state <= 10'b0000000002;\n                    end\n                end\n                default: begin\n                    next_state <= 10'b0000000000;\n                end\n            endcase\n        end\n        state <= next_state;\n    end\n\n    // Outputs\n    assign wb_ack_o = (state == 10'b0000000003);\n    assign we_m_tx_bd = (state == 10'b0000000001);\n    assign we_m_rx_bd = (state == 10'b0000000001);\n    assign new_cmd = (state == 10'b0000000001);\n    assign we_ack = (state == 10'b0000000002);\n    assign int_ack = (state == 10'b0000000003);\n    assign cmd_int_busy = (state == 10'b0000000002);\n    assign int_busy = (state == 10'b0000000003);\n\nendmodule\nmodule sd_clock_divider(\n    input  wire clk_i,\n    input  wire [7:0] divider,\n    input  wire rst_i,\n    output wire sd_clk_o\n);\n\n    // Registers\n    reg [31:0] count;\n\n    // Outputs\n    assign sd_clk_o = (count == 0)? 1'b1 : 1'b0;\n\n    // FSM\n    always @(posedge clk_i or posedge rst_i) begin\n        if (rst_i) begin\n            count <= 0;\n        end else begin\n            if (count == (divider + 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\nmodule sd_cmd_master(\n    input  wire clk_i,\n    input  wire rst_i,\n    input  wire new_cmd,\n    input  wire data_write,\n    input  wire data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:8] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [5:0] ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire ERR_INT_RST,\n    input  wire NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire req_out,\n    output wire ack_out,\n    input  wire req_in,\n    input  wire ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0] serial_status,\n    input  wire card_detect\n);\n\n    // Registers\n    reg [15:0] STATUS_REG;\n    reg [31:0] RESP_1_REG;\n    reg [5:0] ERR_INT_REG;\n    reg [15:0] NORMAL_INT_REG;\n    reg [15:0] settings;\n    reg go_idle_o;\n    reg [39:0] cmd_out;\n    reg req_out;\n    reg ack_out;\n\n    // Outputs\n    assign STATUS_REG = STATUS_REG;\n    assign RESP_1_REG = RESP_1_REG;\n    assign ERR_INT_REG = ERR_INT_REG;\n    assign NORMAL_INT_REG = NORMAL_INT_REG;\n    assign settings = settings;\n    assign go_idle_o = go_idle_o;\n    assign cmd_out = cmd_out;\n    assign req_out = req_out;\n    assign ack_out = ack_out;\n\n    // FSM\n    reg [9:0] state;\n    reg [9:0] next_state;\n\n    // FSM State Machine\n    always @(posedge clk_i or posedge rst_i) begin\n        if (rst_i) begin\n            state <= 10'b0000000000;\n        end else begin\n            case (state)\n                10'b0000000000: begin\n                    if (new_cmd) begin\n                        next_state <= 10'b0000000001;\n                    end else begin\n                        next_state <= 10'b0000000000;\n                    end\n                end\n                10'b0000000001: begin\n                    if (data_write) begin\n                        next_state <= 10'b0000000002;\n                    end else if (data_read) begin\n                        next_state <= 10'b0000000003;\n                    end else begin\n                        next_state <= 10'b0000000001;\n                    end\n                end\n                10'b0000000002: begin\n                    if (wb_cyc_i && wb_stb_i && wb_we_i) begin\n                        next_state <= 10'b0000000004;\n                    end else begin\n                        next_state <= 10'b0000000002;\n                    end\n                end\n                10'b0000000003: begin\n                    if (wb_cyc_i && wb_stb_i && wb_we_i) begin\n                        next_state <= 10'b0000000005;\n                    end else begin\n                        next_state <= 10'b0000000003;\n                    end\n                end\n                10'b0000000004: begin\n                    if (wb_ack_i) begin\n                        next_state <= 10'b0000000006;\n                    end else begin\n                        next_state <= 10'b0000000004;\n                    end\n                end\n                10'b0000000005: begin\n                    if (wb_ack_i) begin\n                        next_state <= 10'b0000000006;\n                    end else begin\n                        next_state <= 10'b0000000005;\n                    end\n                end\n                10'b0000000006: begin\n                    if (ack_in) begin\n                        next_state <= 10'b0000000007;\n                    end else begin\n                        next_state <= 10'b0000000006;\n                    end\n                end\n                default: begin\n                    next_state <= 10'b0000000000;\n                end\n            endcase\n        end\n        state <= next_state;\n    end\n\n    // Outputs\n    assign STATUS_REG = (state == 10'b0000000006);\n    assign RESP_1_REG = (state == 10'b0000000006);\n    assign ERR_INT_REG = (state == 10'b0000000006);\n    assign NORMAL_INT_REG = (state == 10'b0000000006);\n    assign settings = (state == 10'b0000000006);\n    assign go_idle_o = (state == 10'b0000000007);\n    assign cmd_out = (state == 10'b0000000006);\n    assign req_out = (state == 10'b0000000006);\n    assign ack_out = (state == 10'b0000000007);\n\nendmodule\nmodule sd_data_master(\n    input  wire clk_i,\n    input  wire rst_i,\n    input  wire [31:0] dat_in_tx,\n    input  wire free_tx_bd,\n    input  wire ack_i_s_tx,\n    input  wire [31:0] dat_in_rx,\n    input  wire free_rx_bd,\n    input  wire ack_i_s_rx,\n    input  wire cmd_busy,\n    input  wire we_ack,\n    input  wire cmd_tsf_err,\n    input  wire [15:0] card_status,\n    input  wire tx_empt,\n    input  wire tx_full,\n    input  wire rx_full,\n    input  wire busy_n,\n    input  wire transm_complete,\n    input  wire crc_ok,\n    input  wire Dat_Int_Status_rst,\n    input  wire transfer_type,\n    output wire re_s_tx,\n    output wire a_cmp_tx,\n    output wire re_s_rx,\n    output wire a_cmp_rx,\n    output wire we_req,\n    output wire d_write,\n    output wire d_read,\n    output wire cmd_arg,\n    output wire cmd_set,\n    output wire start_tx_fifo,\n    output wire start_rx_fifo,\n    output wire sys_adr,\n    output wire ack_transfer,\n    output wire Dat_Int_Status,\n    output wire CIDAT\n);\n\n    // Registers\n    reg [31:0] cmd_arg;\n    reg [15:0] cmd_set;\n    reg re_s_tx;\n    reg a_cmp_tx;\n    reg re_s_rx;\n    reg a_cmp_rx;\n    reg we_req;\n    reg d_write;\n    reg d_read;\n    reg start_tx_fifo;\n    reg start_rx_fifo;\n    reg sys_adr;\n    reg ack_transfer;\n    reg Dat_Int_Status;\n    reg CIDAT;\n\n    // Outputs\n    assign cmd_arg = cmd_arg;\n    assign cmd_set = cmd_set;\n    assign re_s_tx = re_s_tx;\n    assign a_cmp_tx = a_cmp_tx;\n    assign re_s_rx = re_s_rx;\n    assign a_cmp_rx = a_cmp_rx;\n    assign we_req = we_req;\n    assign d_write = d_write;\n    assign d_read = d_read;\n    assign start_tx_fifo = start_tx_fifo;\n    assign start_rx_fifo = start_rx_fifo;\n    assign sys_adr = sys_adr;\n    assign ack_transfer = ack_transfer;\n    assign Dat_Int_Status = Dat_Int_Status;\n    assign CIDAT = CIDAT;\n\n    // FSM\n    reg [9:0] state;\n    reg [9:0] next_state;\n\n    // FSM State Machine\n    always @(posedge clk_i or posedge rst_i) begin\n        if (rst_i) begin\n            state <= 10'b0000000000;\n        end else begin\n            case (state)\n                10'b0000000000: begin\n                    if (free_tx_bd) begin\n                        next_state <= 10'b0000000001;\n                    end else begin\n                        next_state <= 10'b0000000000;\n                    end\n                end\n                10'b0000000001: begin\n                    if (dat_in_tx) begin\n                        next_state <= 10'b0000000002;\n                    end else begin\n                        next_state <= 10'b0000000001;\n                    end\n                end\n                10'b0000000002: begin\n                    if (wb_cyc_i && wb_stb_i && wb_we_i) begin\n                        next_state <= 10'b0000000003;\n                    end else begin\n                        next_state <= 10'b0000000002;\n                    end\n                end\n                10'b0000000003: begin\n                    if (wb_ack_i) begin\n                        next_state <= 10'b0000000004;\n                    end else begin\n                        next_state <= 10'b0000000003;\n                    end\n                end\n                10'b0000000004: begin\n                    if (transm_complete) begin\n                        next_state <= 10'b0000000005;\n                    end else begin\n                        next_state <= 10'b0000000004;\n                    end\n                end\n                10'b0000000005: begin\n                    if (crc_ok) begin\n                        next_state <= 10'b0000000006;\n                    end else begin\n                        next_state <= 10'b0000000005;\n                    end\n                end\n                default: begin\n                    next_state <= 10'b0000000000;\n                end\n            endcase\n        end\n        state <= next_state;\n    end\n\n    // Outputs\n    assign re_s_tx = (state == 10'b0000000001);\n    assign a_cmp_tx = (state == 10'b0000000002);\n    assign re_s_rx = (state == 10'b0000000001);\n    assign a_cmp_rx = (state == 10'b0000000002);\n    assign we_req = (state == 10'b0000000003);\n    assign d_write = (state == 10'b0000000003);\n    assign d_read = (state == 10'b0000000003);\n    assign start_tx_fifo = (state == 10'b0000000002);\n    assign start_rx_fifo = (state == 10'b0000000002);\n    assign sys_adr = (state == 10'b0000000003);\n    assign ack_transfer = (state == 10'b0000000004);\n    assign Dat_Int_Status = (state == 10'b0000000004);\n    assign CIDAT = (state == 10'b0000000004);\n\nendmodule\nmodule sd_fifo_tx_filler(\n    input  wire clk_i,\n    input  wire rst_i,\n    input  wire [31:0] m_wb_adr_o,\n    input  wire [1:0] m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire [1:0] m_wb_cyc_o,\n    input  wire [1:0] m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    input  wire [2:0] m_wb_cti_o,\n    input  wire [1:0] m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    output wire [31:0] dat_o,\n    input  wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    // Registers\n    reg [31:0] dat_o;\n    reg empty;\n    reg fe;\n\n    // Outputs\n    assign dat_o = dat_o;\n    assign empty = empty;\n    assign fe = fe;\n\n    // FSM\n    reg [9:0] state;\n    reg [9:0] next_state;\n\n    // FSM State Machine\n    always @(posedge clk_i or posedge rst_i) begin\n        if (rst_i) begin\n            state <= 10'b0000000000;\n        end else begin\n            case (state)\n                10'b0000000000: begin\n                    if (en) begin\n                        next_state <= 10'b0000000001;\n                    end else begin\n                        next_state <= 10'b0000000000;\n                    end\n                end\n                10'b0000000001: begin\n                    if (m_wb_cyc_o && m_wb_stb_o && m_wb_we_o) begin\n                        next_state <= 10'b0000000002;\n                    end else begin\n                        next_state <= 10'b0000000001;\n                    end\n                end\n                10'b0000000002: begin\n                    if (m_wb_ack_i) begin\n                        next_state <= 10'b0000000003;\n                    end else begin\n                        next_state <= 10'b0000000002;\n                    end\n                end\n                10'b0000000003: begin\n                    if (rd) begin\n                        next_state <= 10'b0000000004;\n                    end else begin\n                        next_state <= 10'b0000000003;\n                    end\n                end\n                10'b0000000004: begin\n                    if (empty) begin\n                        next_state <= 10'b0000000005;\n                    end else begin\n                        next_state <= 10'b0000000004;\n                    end\n                end\n                default: begin\n                    next_state <= 10'b0000000000;\n                end\n            endcase\n        end\n        state <= next_state;\n    end\n\n    // Outputs\n    assign dat_o = (state == 10'b0000000002);\n    assign empty = (state == 10'b0000000004);\n    assign fe = (state == 10'b0000000005);\n\nendmodule\nmodule sd_fifo_rx_filler(\n    input  wire clk_i,\n    input  wire rst_i,\n    input  wire [31:0] m_wb_adr_o,\n    input  wire [1:0] m_wb_we_o,\n    input  wire [31:0] m_wb_dat_o,\n    input  wire [1:0] m_wb_cyc_o,\n    input  wire [1:0] m_wb_stb_o,\n    input  wire m_wb_ack_i,\n    input  wire [2:0] m_wb_cti_o,\n    input  wire [1:0] m_wb_bte_o,\n    input  wire en,\n    input  wire [31:0] adr,\n    input  wire sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire wr,\n    output wire full,\n    output wire fe\n);\n\n    // Registers\n    reg [31:0] dat_o;\n    reg full;\n    reg fe;\n\n    // Outputs\n    assign dat_o = dat_o;\n    assign full = full;\n    assign fe = fe;\n\n    // FSM\n    reg [9:0] state;\n    reg [9:0] next_state;\n\n    // FSM State Machine\n    always @(posedge clk_i or posedge rst_i) begin\n        if (rst_i) begin\n            state <= 10'b0000000000;\n        end else begin\n            case (state)\n                10'b0000000000: begin\n                    if (en) begin\n                        next_state <= 10'b0000000001;\n                    end else begin\n                        next_state <= 10'b0000000000;\n                    end\n                end\n                10'b0000000001: begin\n                    if (m_wb_cyc_o && m_wb_stb_o && m_wb_we_o) begin\n                        next_state <= 10'b0000000002;\n                    end else begin\n                        next_state <= 10'b0000000001;\n                    end\n                end\n                10'b0000000002: begin\n                    if (m_wb_ack_i) begin\n                        next_state <= 10'b0000000003;\n                    end else begin\n                        next_state <= 10'b0000000002;\n                    end\n                end\n                10'b0000000003: begin\n                    if (wr) begin\n                        next_state <= 10'b0000000004;\n                    end else begin\n                        next_state <= 10'b0000000003;\n                    end\n                end\n                10'b0000000004: begin\n                    if (full) begin\n                        next_state <= 10'b0000000005;\n                    end else begin\n                        next_state <= 10'b0000000004;\n                    end\n                end\n                default: begin\n                    next_state <= 10'b0000000000;\n                end\n            endcase\n        end\n        state <= next_state;\n    end\n\n    // Outputs\n    assign dat_o = (state == 10'b0000000002);\n    assign full = (state == 10'b0000000004);\n    assign fe = (state == 10'b0000000005);\n\nendmodule\nmodule sd_bd(\n    input  wire clk_i,\n    input  wire rst_i,\n    input  wire we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    input  wire free_bd,\n    output wire re_s,\n    output wire ack_o_s,\n    output wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Registers\n    reg [RAM_MEM_WIDTH-1:0] dat_out_s;\n    reg re_s;\n    reg ack_o_s;\n    reg a_cmp;\n\n    // Outputs\n    assign dat_out_s = dat_out_s;\n    assign re_s = re_s;\n    assign ack_o_s = ack_o_s;\n    assign a_cmp = a_cmp;\n\n    // FSM\n    reg [9:0] state;\n    reg [9:0] next_state;\n\n    // FSM State Machine\n    always @(posedge clk_i or posedge rst_i) begin\n        if (rst_i) begin\n            state <= 10'b0000000000;\n        end else begin\n            case (state)\n                10'b0000000000: begin\n                    if (free_bd) begin\n                        next_state <= 10'b0000000001;\n                    end else begin\n                        next_state <= 10'b0000000000;\n                    end\n                end\n                10'b0000000001: begin\n                    if (dat_in_m) begin\n                        next_state <= 10'b0000000002;\n                    end else begin\n                        next_state <= 10'b0000000001;\n                    end\n                end\n                10'b0000000002: begin\n                    if (we_m) begin\n                        next_state <= 10'b0000000003;\n                    end else begin\n                        next_state <= 10'b0000000002;\n                    end\n                end\n                10'b0000000003: begin\n                    if (re_s) begin\n                        next_state <= 10'b0000000004;\n                    end else begin\n                        next_state <= 10'b0000000003;\n                    end\n                end\n                10'b0000000004: begin\n                    if (a_cmp) begin\n                        next_state <= 10'b0000000005;\n                    end else begin\n                        next_state <= 10'b0000000004;\n                    end\n                end\n                default: begin\n                    next_state <= 10'b0000000000;\n                end\n            endcase\n        end\n        state <= next_state;\n    end\n\n    // Outputs\n    assign dat_out_s = (state == 10'b0000000002);\n    assign re_s = (state == 10'b0000000003);\n    assign ack_o_s = (state == 10'b0000000004);\n    assign a_cmp = (state == 10'b0000000005);\n\nendmodule\nmodule sd_data_serial_host(\n    input  wire clk_i,\n    input  wire rst_i,\n    input  wire sd_clk,\n    input  wire rst_pad_i,\n    input  wire [31:0] data_in,\n    input  wire [1:0] start_dat,\n    input  wire ack_transfer,\n    input  wire [SD_BUS_W-1:0] DAT_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n    // Registers\n    reg rd;\n    reg [SD_BUS_W-1:0] data_out;\n    reg we;\n    reg DAT_oe_o;\n    reg DAT_dat_o;\n    reg busy_n;\n    reg transm_complete;\n    reg crc_ok;\n\n    // Outputs\n    assign rd = rd;\n    assign data_out = data_out;\n    assign we = we;\n    assign DAT_oe_o = DAT_oe_o;\n    assign DAT_dat_o = DAT_dat_o;\n    assign busy_n = busy_n;\n    assign transm_complete = transm_complete;\n    assign crc_ok = crc_ok;\n\n    // FSM\n    reg [9:0] state;\n    reg [9:0] next_state;\n\n    // FSM State Machine\n    always @(posedge clk_i or posedge rst_i) begin\n        if (rst_i) begin\n            state <= 10'b0000000000;\n        end else begin\n            case (state)\n                10'b0000000000: begin\n                    if (start_dat == 2'b01) begin\n                        next_state <= 10'b0000000001;\n                    end else if (start_dat == 2'b10) begin\n                        next_state <= 10'b0000000002;\n                    end else if (start_dat == 2'b11) begin\n                        next_state <= 10'b0000000003;\n                    end else begin\n                        next_state <= 10'b0000000000;\n                    end\n                end\n                10'b0000000001: begin\n                    if (data_in) begin\n                        next_state <= 10'b0000000004;\n                    end else begin\n                        next_state <= 10'b0000000001;\n                    end\n                end\n                10'b0000000002: begin\n                    if (DAT_dat_i) begin\n                        next_state <= 10'b0000000005;\n                    end else begin\n                        next_state <= 10'b0000000002;\n                    end\n                end\n                10'b0000000003: begin\n                    if (ack_transfer) begin\n                        next_state <= 10'b0000000006;\n                    end else begin\n                        next_state <= 10'b0000000003;\n                    end\n                end\n                10'b0000000004: begin\n                    if (transm_complete) begin\n                        next_state <= 10'b0000000007;\n                    end else begin\n                        next_state <= 10'b0000000004;\n                    end\n                end\n                10'b0000000005: begin\n                    if (crc_ok) begin\n                        next_state <= 10'b0000000008;\n                    end else begin\n                        next_state <= 10'b0000000005;\n                    end\n                end\n                10'b0000000006: begin\n                    if (transm_complete) begin\n                        next_state <= 10'b0000000007;\n                    end else begin\n                        next_state <= 10'b0000000006;\n                    end\n                end\n                10'b0000000007: begin\n                    if (crc_ok) begin\n                        next_state <= 10'b0000000008;\n                    end else begin\n                        next_state <= 10'b0000000007;\n                    end\n                end\n                10'b0000000008: begin\n                    if (busy_n) begin\n                        next_state <= 10'b0000000009;\n                    end else begin\n                        next_state <= 10'b0000000008;\n                    end\n                end\n                default: begin\n                    next_state <= 10'b0000000000;\n                end\n            endcase\n        end\n        state <= next_state;\n    end\n\n    // Outputs\n    assign rd = (state == 10'b0000000004);\n    assign data_out = (state == 10'b0000000005);\n    assign we = (state == 10'b0000000004);\n    assign DAT_oe_o = (state == 10'b0000000005);\n    assign DAT_dat_o = (state == 10'b0000000005);\n    assign busy_n = (state == 10'b0000000008);\n    assign transm_complete = (state == 10'b0000000007);\n    assign crc_ok = (state == 10'b0000000008);\n\nendmodule\nmodule sd_crc_16(\n    input  wire clk_i,\n    input  wire rst_i,\n    input  wire [1:0] BITVAL,\n    input  wire Enable,\n    input  wire CLK,\n    input  wire RST,\n    output wire [15:0] CRC\n);\n\n    // Registers\n    reg [15:0] CRC;\n\n    // Outputs\n    assign CRC = CRC;\n\n    // FSM\n    reg [9:0] state;\n    reg [9:0] next_state;\n\n    // FSM State Machine\n    always @(posedge clk_i or posedge rst_i) begin\n        if (rst_i) begin\n            state <= 10'b0000000000;\n        end else begin\n            case (state)\n                10'b0000000000: begin\n                    if (RST) begin\n                        next_state <= 10'b0000000001;\n                    end else begin\n                        next_state <= 10'b0000000000;\n                    end\n                end\n                10'b0000000001: begin\n                    if (Enable) begin\n                        next_state <= 10'b0000000002;\n                    end else begin\n                        next_state <= 10'b0000000001;\n                    end\n                end\n                10'b0000000002: begin\n                    if (BITVAL) begin\n                        next_state <= 10'b0000000003;\n                    end else begin\n                        next_state <= 10'b0000000002;\n                    end\n                end\n                10'b0000000003: begin\n                    if (CLK) begin\n                        next_state <= 10'b0000000004;\n                    end else begin\n                        next_state <= 10'b0000000003;\n                    end\n                end\n                10'b0000000004: begin\n                    if (BITVAL) begin\n                        next_state <= 10'b0000000005;\n                    end else begin\n                        next_state <= 10'b0000000004;\n                    end\n                end\n                10'b0000000005: begin\n                    if (CLK) begin\n                        next_state <= 10'b0000000006;\n                    end else begin\n                        next_state <= 10'b0000000005;\n                    end\n                end\n                10'b0000000006: begin\n                    if (BITVAL) begin\n                        next_state <= 10'b0000000007;\n                    end else begin\n                        next_state <= 10'b0000000006;\n                    end\n                end\n                10'b0000000007: begin\n                    if (CLK) begin\n                        next_state <= 10'b0000000008;\n                    end else begin\n                        next_state <= 10'b0000000007;\n                    end\n                end\n                default: begin\n                    next_state <= 10'b0000000000;\n                end\n            endcase\n        end\n        state <= next_state;\n    end\n\n    // Outputs\n    assign CRC = (state == 10'b0000000008);\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 16, "code": "module sd_controller_wb(\n    input  wire  clk_i,\n    input  wire  rst_i,\n    input  wire  wb_dat_i[31:0],\n    output wire  wb_dat_o[31:0],\n    input  wire  wb_adr_i[7:0],\n    input  wire  wb_sel_i[3:0],\n    input  wire  wb_we_i,\n    input  wire  wb_cyc_i,\n    input  wire  wb_stb_i,\n    output wire  wb_ack_o,\n    output wire  we_m_tx_bd,\n    output wire  we_m_rx_bd,\n    output wire  new_cmd,\n    output wire  we_ack,\n    output wire  int_ack,\n    output wire  cmd_int_busy,\n    output wire  int_busy,\n    input  wire  write_req_s,\n    input  wire  cmd_set_s[15:0],\n    input  wire  cmd_arg_s[31:0],\n    output wire  argument_reg[31:0],\n    output wire  cmd_setting_reg[15:0],\n    input  wire  status_reg[15:0],\n    input  wire  cmd_resp_1[31:0],\n    output wire  software_reset_reg[7:0],\n    output wire  time_out_reg[15:0],\n    input  wire  normal_int_status_reg[15:0],\n    input  wire  error_int_status_reg[15:0],\n    output wire  normal_int_signal_enable_reg[15:0],\n    output wire  error_int_signal_enable_reg[15:0],\n    output wire  clock_divider[7:0],\n    input  wire  Bd_Status_reg[15:0],\n    input  wire  Bd_isr_reg[7:0],\n    output wire  Bd_isr_enable_reg[7:0],\n    output wire  Bd_isr_reset,\n    output wire  normal_isr_reset,\n    output wire  error_isr_reset,\n    output wire  dat_in_m_tx_bd[RAM_MEM_WIDTH-1:0],\n    output wire  dat_in_m_rx_bd[RAM_MEM_WIDTH-1:0]\n);\n\n    reg [31:0] argument_reg;\n    reg [15:0] cmd_setting_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [7:0] software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0] clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [7:0] Bd_isr_reg;\n    reg [7:0] Bd_isr_enable_reg;\n    reg Bd_isr_reset;\n    reg normal_isr_reset;\n    reg error_isr_reset;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    always @(posedge clk_i or posedge rst_i) begin\n        if (rst_i) begin\n            argument_reg <= 32'd0;\n            cmd_setting_reg <= 16'd0;\n            status_reg <= 16'd0;\n            cmd_resp_1 <= 32'd0;\n            software_reset_reg <= 8'd0;\n            time_out_reg <= 16'd0;\n            normal_int_status_reg <= 16'd0;\n            error_int_status_reg <= 16'd0;\n            normal_int_signal_enable_reg <= 16'd0;\n            error_int_signal_enable_reg <= 16'd0;\n            clock_divider <= 8'd0;\n            Bd_Status_reg <= 16'd0;\n            Bd_isr_reg <= 8'd0;\n            Bd_isr_enable_reg <= 8'd0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= RAM_MEM_WIDTH'd0;\n            dat_in_m_rx_bd <= RAM_MEM_WIDTH'd0;\n        end else begin\n            // TODO: Implement logic here\n        end\n    end\n\n    assign wb_dat_o = argument_reg;\n    assign cmd_setting_reg = cmd_setting_reg;\n    assign status_reg = status_reg;\n    assign cmd_resp_1 = cmd_resp_1;\n    assign software_reset_reg = software_reset_reg;\n    assign time_out_reg = time_out_reg;\n    assign normal_int_status_reg = normal_int_status_reg;\n    assign error_int_status_reg = error_int_status_reg;\n    assign normal_int_signal_enable_reg = normal_int_signal_enable_reg;\n    assign error_int_signal_enable_reg = error_int_signal_enable_reg;\n    assign clock_divider = clock_divider;\n    assign Bd_Status_reg = Bd_Status_reg;\n    assign Bd_isr_reg = Bd_isr_reg;\n    assign Bd_isr_enable_reg = Bd_isr_enable_reg;\n    assign Bd_isr_reset = Bd_isr_reset;\n    assign normal_isr_reset = normal_isr_reset;\n    assign error_isr_reset = error_isr_reset;\n    assign dat_in_m_tx_bd = dat_in_m_tx_bd;\n    assign dat_in_m_rx_bd = dat_in_m_rx_bd;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 1, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    // SubBytes transformation\n    module sub_bytes(\n        input [7:0] a,\n        output [7:0] b\n    );\n        // S-box lookup table\n        reg [7:0] sbox[256:0];\n        initial begin\n            for (int i = 0; i < 256; i++) begin\n                sbox[i] = i;\n            end\n        end\n        assign b = sbox[a];\n    endmodule\n\n    // ShiftRows transformation\n    module shift_rows(\n        input [7:0] a[0:3],\n        output [7:0] b[0:3]\n    );\n        assign b[0] = a[0];\n        assign b[1] = a[1] << 1 | a[0] >> 7;\n        assign b[2] = a[2] << 2 | a[1] >> 6 | a[0] >> 5;\n        assign b[3] = a[3] << 3 | a[2] >> 5 | a[1] >> 4 | a[0] >> 3;\n    endmodule\n\n    // MixColumns transformation\n    module mix_columns(\n        input [7:0] a[0:3],\n        output [7:0] b[0:3]\n    );\n        reg [7:0] t[0:3];\n        assign t[0] = a[0] << 1 | a[1] << 1 | a[2] << 1 | a[3] << 1;\n        assign t[1] = a[0] << 2 | a[1] << 3 | a[2] << 3 | a[3] << 2;\n        assign t[2] = a[0] << 3 | a[1] << 2 | a[2] << 1 | a[3] << 3;\n        assign t[3] = a[0] << 1 | a[1] << 2 | a[2] << 3 | a[3] << 1;\n        assign b[0] = t[0] ^ t[1] ^ t[2] ^ t[3];\n        assign b[1] = t[0] ^ t[1] ^ t[2] ^ t[3];\n        assign b[2] = t[0] ^ t[1] ^ t[2] ^ t[3];\n        assign b[3] = t[0] ^ t[1] ^ t[2] ^ t[3];\n    endmodule\n\n    // AddRoundKey transformation\n    module add_round_key(\n        input [7:0] a[0:3],\n        input [7:0] b[0:3],\n        output [7:0] c[0:3]\n    );\n        assign c[0] = a[0] ^ b[0];\n        assign c[1] = a[1] ^ b[1];\n        assign c[2] = a[2] ^ b[2];\n        assign c[3] = a[3] ^ b[3];\n    endmodule\n\n    // Round transformation\n    module round(\n        input [7:0] a[0:3],\n        input [7:0] b[0:3],\n        input [7:0] c[0:3],\n        output [7:0] d[0:3]\n    );\n        sub_bytes sub_bytes_inst(\n           .a(a),\n           .b(b)\n        );\n        shift_rows shift_rows_inst(\n           .a(a),\n           .b(b)\n        );\n        mix_columns mix_columns_inst(\n           .a(a),\n           .b(b)\n        );\n        add_round_key add_round_key_inst(\n           .a(a),\n           .b(b),\n           .c(c)\n        );\n        assign d = b;\n    endmodule\n\n    // aes_key_expand_128 module\n    module aes_key_expansion(\n        input clk,\n        input kld,\n        input [127:0] key,\n        output [31:0] wo_0,\n        output [31:0] wo_1,\n        output [31:0] wo_2,\n        output [31:0] wo_3\n    );\n        reg [127:0] key_expanded;\n        reg [3:0] rcnt;\n        reg [31:0] wo_0_r;\n        reg [31:0] wo_1_r;\n        reg [31:0] wo_2_r;\n        reg [31:0] wo_3_r;\n\n        // aes_rcon module\n        module aes_rcon(\n            input clk,\n            input kld,\n            output [31:0] out\n        );\n            reg [3:0] rcnt_r;\n            reg [31:0] out_r;\n            initial begin\n                rcnt_r = 0;\n                out_r = 32'h01_00_00_00;\n            end\n            always @(posedge clk) begin\n                if (kld) begin\n                    rcnt_r <= 0;\n                    out_r <= 32'h01_00_00_00;\n                end else begin\n                    rcnt_r <= rcnt_r + 1;\n                    out_r <= out_r << 1 | (rcnt_r == 9)? 32'h36 : 0;\n                end\n            end\n            assign out = out_r;\n        endmodule\n\n        // aes_sbox module\n        module aes_sbox(\n            input [7:0] a,\n            output [7:0] b\n        );\n            // S-box lookup table\n            reg [7:0] sbox[256:0];\n            initial begin\n                for (int i = 0; i < 256; i++) begin\n                    sbox[i] = i;\n                end\n            end\n            assign b = sbox[a];\n        endmodule\n\n        // Key expansion\n        always @(posedge clk) begin\n            if (kld) begin\n                key_expanded <= key;\n                wo_0_r <= key[127:96];\n                wo_1_r <= key[95:64];\n                wo_2_r <= key[63:32];\n                wo_3_r <= key[31:0];\n            end else begin\n                wo_0_r <= wo_0_r << 1 | (rcnt == 9)? wo_0_r[7] ^ wo_0_r[6] ^ wo_0_r[5] ^ wo_0_r[4] ^ wo_0_r[3] ^ wo_0_r[2] ^ wo_0_r[1] ^ wo_0_r[0] : 0;\n                wo_1_r <= wo_1_r << 1 | (rcnt == 9)? wo_1_r[7] ^ wo_1_r[6] ^ wo_1_r[5] ^ wo_1_r[4] ^ wo_1_r[3] ^ wo_1_r[2] ^ wo_1_r[1] ^ wo_1_r[0] : 0;\n                wo_2_r <= wo_2_r << 1 | (rcnt == 9)? wo_2_r[7] ^ wo_2_r[6] ^ wo_2_r[5] ^ wo_2_r[4] ^ wo_2_r[3] ^ wo_2_r[2] ^ wo_2_r[1] ^ wo_2_r[0] : 0;\n                wo_3_r <= wo_3_r << 1 | (rcnt == 9)? wo_3_r[7] ^ wo_3_r[6] ^ wo_3_r[5] ^ wo_3_r[4] ^ wo_3_r[3] ^ wo_3_r[2] ^ wo_3_r[1] ^ wo_3_r[0] : 0;\n            end\n        end\n        assign wo_0 = wo_0_r;\n        assign wo_1 = wo_1_r;\n        assign wo_2 = wo_2_r;\n        assign wo_3 = wo_3_r;\n    endmodule\n\n    // aes_cipher_top implementation\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n            text_out_r <= 0;\n        end else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1;\n        end else begin\n            ld_r <= 0;\n            if (dcnt == 0) begin\n                // Initial round key addition\n                for (int i = 0; i < 4; i++) begin\n                    sa[i][0] <= text_in_r[7+i] ^ key[7+i];\n                end\n                dcnt <= 11;\n            end else if (dcnt == 1) begin\n                // Round 1\n                round round_inst(\n                   .a(sa[0]),\n                   .b(sa[1]),\n                   .c(sa[2]),\n                   .d(sa[3])\n                );\n                dcnt <= dcnt - 1;\n            end else if (dcnt == 10) begin\n                // Final round\n                round round_inst(\n                   .a(sa[0]),\n                   .b(sa[1]),\n                   .c(sa[2]),\n                   .d(sa[3])\n                );\n                dcnt <= dcnt - 1;\n            end else begin\n                // Rounds 2-9\n                round round_inst(\n                   .a(sa[0]),\n                   .b(sa[1]),\n                   .c(sa[2]),\n                   .d(sa[3])\n                );\n                dcnt <= dcnt - 1;\n            end\n        end\n        if (dcnt == 0) begin\n            done <= 1;\n        end else begin\n            done <= 0;\n        end\n        text_out_r <= sa[0] | sa[1] << 8 | sa[2] << 16 | sa[3] << 24;\n    end\n    assign text_out = text_out_r;\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 2, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\nreg [127:0] text_in_r;\nreg [3:0][3:0] sa;\nreg [3:0] dcnt;\nreg ld_r;\nreg [127:0] text_out;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        text_in_r <= 0;\n        sa <= 0;\n        dcnt <= 0;\n        ld_r <= 0;\n        text_out <= 0;\n    end else if (ld) begin\n        text_in_r <= text_in;\n        sa <= 0;\n        dcnt <= 0;\n        ld_r <= 1;\n    end else begin\n        if (dcnt == 0) begin\n            sa <= text_in_r;\n            ld_r <= 0;\n            dcnt <= 0;\n        end else if (ld_r) begin\n            ld_r <= 0;\n            dcnt <= dcnt + 1;\n        end else begin\n            if (dcnt == 10) begin\n                text_out <= sa;\n                done <= 1;\n            end else begin\n                sa <= sub_bytes(shift_rows(mix_columns(add_round_key(sa, aes_key_expand_128(key, ld_r)))));\n                dcnt <= dcnt + 1;\n            end\n        end\n    end\nend\n\nendmodule\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [31:0] w[15:0];\nreg [3:0] rcnt;\nreg [31:0] wo_0_reg, wo_1_reg, wo_2_reg, wo_3_reg;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        w[0] <= key[127:96];\n        w[1] <= key[95:64];\n        w[2] <= key[63:32];\n        w[3] <= key[31:0];\n        wo_0_reg <= w[0];\n        wo_1_reg <= w[1];\n        wo_2_reg <= w[2];\n        wo_3_reg <= w[3];\n    end else begin\n        if (rcnt == 0) begin\n            wo_0_reg <= w[0];\n            wo_1_reg <= w[1];\n            wo_2_reg <= w[2];\n            wo_3_reg <= w[3];\n        end else if (rcnt == 1) begin\n            wo_0_reg <= rot_word(w[0]);\n            wo_1_reg <= rot_word(w[1]);\n            wo_2_reg <= rot_word(w[2]);\n            wo_3_reg <= rot_word(w[3]);\n        end else if (rcnt == 2) begin\n            wo_0_reg <= sub_word(rot_word(w[0]));\n            wo_1_reg <= sub_word(rot_word(w[1]));\n            wo_2_reg <= sub_word(rot_word(w[2]));\n            wo_3_reg <= sub_word(rot_word(w[3]));\n        end else if (rcnt == 3) begin\n            wo_0_reg <= wo_0_reg ^ aes_rcon(rcnt);\n            wo_1_reg <= wo_1_reg ^ aes_rcon(rcnt);\n            wo_2_reg <= wo_2_reg ^ aes_rcon(rcnt);\n            wo_3_reg <= wo_3_reg ^ aes_rcon(rcnt);\n        end else if (rcnt == 4) begin\n            wo_0_reg <= wo_0_reg ^ w[0];\n            wo_1_reg <= wo_1_reg ^ w[1];\n            wo_2_reg <= wo_2_reg ^ w[2];\n            wo_3_reg <= wo_3_reg ^ w[3];\n        end else if (rcnt == 5) begin\n            wo_0_reg <= wo_0_reg ^ w[1];\n            wo_1_reg <= wo_1_reg ^ w[2];\n            wo_2_reg <= wo_2_reg ^ w[3];\n            wo_3_reg <= wo_3_reg ^ w[0];\n        end else if (rcnt == 6) begin\n            wo_0_reg <= wo_0_reg ^ w[2];\n            wo_1_reg <= wo_1_reg ^ w[3];\n            wo_2_reg <= wo_2_reg ^ w[0];\n            wo_3_reg <= wo_3_reg ^ w[1];\n        end else if (rcnt == 7) begin\n            wo_0_reg <= wo_0_reg ^ w[3];\n            wo_1_reg <= wo_1_reg ^ w[0];\n            wo_2_reg <= wo_2_reg ^ w[1];\n            wo_3_reg <= wo_3_reg ^ w[2];\n        end else if (rcnt == 8) begin\n            wo_0_reg <= wo_0_reg ^ w[0];\n            wo_1_reg <= wo_1_reg ^ w[1];\n            wo_2_reg <= wo_2_reg ^ w[2];\n            wo_3_reg <= wo_3_reg ^ w[3];\n        end else if (rcnt == 9) begin\n            wo_0_reg <= wo_0_reg ^ w[1];\n            wo_1_reg <= wo_1_reg ^ w[2];\n            wo_2_reg <= wo_2_reg ^ w[3];\n            wo_3_reg <= wo_3_reg ^ w[0];\n        end else begin\n            wo_0_reg <= wo_0_reg ^ w[0];\n            wo_1_reg <= wo_1_reg ^ w[1];\n            wo_2_reg <= wo_2_reg ^ w[2];\n            wo_3_reg <= wo_3_reg ^ w[3];\n        end\n        rcnt <= rcnt + 1;\n    end\nend\n\nassign wo_0 = wo_0_reg;\nassign wo_1 = wo_1_reg;\nassign wo_2 = wo_2_reg;\nassign wo_3 = wo_3_reg;\n\nendmodule\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] out_reg;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        out_reg <= 32'h00000001;\n        rcnt <= 0;\n    end else begin\n        if (rcnt == 0) begin\n            out_reg <= 32'h00000001;\n        end else if (rcnt == 1) begin\n            out_reg <= 32'h00000002;\n        end else if (rcnt == 2) begin\n            out_reg <= 32'h00000004;\n        end else if (rcnt == 3) begin\n            out_reg <= 32'h00000008;\n        end else if (rcnt == 4) begin\n            out_reg <= 32'h00000010;\n        end else if (rcnt == 5) begin\n            out_reg <= 32'h00000020;\n        end else if (rcnt == 6) begin\n            out_reg <= 32'h00000040;\n        end else if (rcnt == 7) begin\n            out_reg <= 32'h00000080;\n        end else if (rcnt == 8) begin\n            out_reg <= 32'h0000001B;\n        end else if (rcnt == 9) begin\n            out_reg <= 32'h00000036;\n        end else begin\n            out_reg <= 32'h00000000;\n        end\n        rcnt <= rcnt + 1;\n    end\nend\n\nassign out = out_reg;\n\nendmodule\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] b_reg;\n\nalways @(a) begin\n    case(a)\n        8'h00: b_reg = 8'h63;\n        8'h01: b_reg = 8'h7c;\n        8'h02: b_reg = 8'h77;\n        8'h03: b_reg = 8'e7;\n        8'h04: b_reg = 8'x7f;\n        8'h05: b_reg = 8'x9f;\n        8'h06: b_reg = 8'x89;\n        8'h07: b_reg = 8'x9b;\n        8'h08: b_reg = 8'x83;\n        8'h09: b_reg = 8'x9a;\n        8'h0a: b_reg = 8'x1f;\n        8'h0b: b_reg = 8'x8f;\n        8'h0c: b_reg = 8'x94;\n        8'h0d: b_reg = 8'x9d;\n        8'h0e: b_reg = 8'x93;\n        8'h0f: b_reg = 8'x9c;\n        8'h10: b_reg = 8'x82;\n        8'h11: b_reg = 8'x9b;\n        8'h12: b_reg = 8'x9a;\n        8'h13: b_reg = 8'x9f;\n        8'h14: b_reg = 8'x87;\n        8'h15: b_reg = 8'x9e;\n        8'h16: b_reg = 8'x93;\n        8'h17: b_reg = 8'x9d;\n        8'h18: b_reg = 8'x9c;\n        8'h19: b_reg = 8'x9b;\n        8'h1a: b_reg = 8'x9a;\n        8'h1b: b_reg = 8'x9f;\n        8'h1c: b_reg = 8'x87;\n        8'h1d: b_reg = 8'x9e;\n        8'h1e: b_reg = 8'x93;\n        8'h1f: b_reg = 8'x9d;\n        8'h20: b_reg = 8'x9c;\n        8'h21: b_reg = 8'x9b;\n        8'h22: b_reg = 8'x9a;\n        8'h23: b_reg = 8'x9f;\n        8'h24: b_reg = 8'x87;\n        8'h25: b_reg = 8'x9e;\n        8'h26: b_reg = 8'x93;\n        8'h27: b_reg = 8'x9d;\n        8'h28: b_reg = 8'x9c;\n        8'h29: b_reg = 8'x9b;\n        8'h2a: b_reg = 8'x9a;\n        8'h2b: b_reg = 8'x9f;\n        8'h2c: b_reg = 8'x87;\n        8'h2d: b_reg = 8'x9e;\n        8'h2e: b_reg = 8'x93;\n        8'h2f: b_reg = 8'x9d;\n        8'h30: b_reg = 8'x9c;\n        8'h31: b_reg = 8'x9b;\n        8'h32: b_reg = 8'x9a;\n        8'h33: b_reg = 8'x9f;\n        8'h34: b_reg = 8'x87;\n        8'h35: b_reg = 8'x9e;\n        8'h36: b_reg = 8'x93;\n        8'h37: b_reg = 8'x9d;\n        8'h38: b_reg = 8'x9c;\n        8'h39: b_reg = 8'x9b;\n        8'h3a: b_reg = 8'x9a;\n        8'h3b: b_reg = 8'x9f;\n        8'h3c: b_reg = 8'x87;\n        8'h3d: b_reg = 8'x9e;\n        8'h3e: b_reg = 8'x93;\n        8'h3f: b_reg = 8'x9d;\n        8'h40: b_reg = 8'x9c;\n        8'h41: b_reg = 8'x9b;\n        8'h42: b_reg = 8'x9a;\n        8'h43: b_reg = 8'x9f;\n        8'h44: b_reg = 8'x87;\n        8'h45: b_reg = 8'x9e;\n        8'h46: b_reg = 8'x93;\n        8'h47: b_reg = 8'x9d;\n        8'h48: b_reg = 8'x9c;\n        8'h49: b_reg = 8'x9b;\n        8'h4a: b_reg = 8'x9a;\n        8'h4b: b_reg = 8'x9f;\n        8'h4c: b_reg = 8'x87;\n        8'h4d: b_reg = 8'x9e;\n        8'h4e: b_reg = 8'x93;\n        8'h4f: b_reg = 8'x9d;\n        8'h50: b_reg = 8'x9c;\n        8'h51: b_reg = 8'x9b;\n        8'h52: b_reg = 8'x9a;\n        8'h53: b_reg = 8'x9f;\n        8'h54: b_reg = 8'x87;\n        8'h55: b_reg = 8'x9e;\n        8'h56: b_reg = 8'x93;\n        8'h57: b_reg = 8'x9d;\n        8'h58: b_reg = 8'x9c;\n        8'h59: b_reg = 8'x9b;\n        8'h5a: b_reg = 8'x9a;\n        8'h5b: b_reg = 8'x9f;\n        8'h5c: b_reg = 8'x87;\n        8'h5d: b_reg = 8'x9e;\n        8'h5e: b_reg = 8'x93;\n        8'h5f: b_reg = 8'x9d;\n        8'h60: b_reg = 8'x9c;\n        8'h61: b_reg = 8'x9b;\n        8'h62: b_reg = 8'x9a;\n        8'h63: b_reg = 8'x9f;\n        default: b_reg = 8'h63;\n    endcase\nend\n\nassign b = b_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 17, "code": "module sd_controller_wb(\n    // Wishbone Slave Interface\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    // Master Wishbone Interface\n    output wire        m_wb_adr_o,\n    output wire        m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire        m_wb_cyc_o,\n    output wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    // Internal Signals\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0] clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Wishbone Slave Interface\n    reg [31:0] wb_dat_o_reg;\n    reg        wb_ack_o_reg;\n\n    // Master Wishbone Interface\n    reg [31:0] m_wb_dat_o_reg;\n    reg        m_wb_cyc_o_reg;\n    reg        m_wb_stb_o_reg;\n    reg [2:0] m_wb_cti_o_reg;\n    reg [1:0] m_wb_bte_o_reg;\n\n    // Internal Signals\n    reg        we_m_tx_bd_reg;\n    reg        we_m_rx_bd_reg;\n    reg        new_cmd_reg;\n    reg        we_ack_reg;\n    reg        int_ack_reg;\n    reg        cmd_int_busy_reg;\n    reg        int_busy_reg;\n    reg        write_req_s_reg;\n    reg [15:0] cmd_set_s_reg;\n    reg [31:0] cmd_arg_s_reg;\n    reg [31:0] argument_reg_reg;\n    reg [15:0] cmd_setting_reg_reg;\n    reg [15:0] status_reg_reg;\n    reg [31:0] cmd_resp_1_reg;\n    reg [7:0]  software_reset_reg_reg;\n    reg [15:0] time_out_reg_reg;\n    reg [15:0] normal_int_status_reg_reg;\n    reg [15:0] error_int_status_reg_reg;\n    reg [15:0] normal_int_signal_enable_reg_reg;\n    reg [15:0] error_int_signal_enable_reg_reg;\n    reg [7:0]  clock_divider_reg;\n    reg [15:0] Bd_Status_reg_reg;\n    reg [7:0]  Bd_isr_reg_reg;\n    reg [7:0]  Bd_isr_enable_reg_reg;\n    reg        Bd_isr_reset_reg;\n    reg        normal_isr_reset_reg;\n    reg        error_isr_reset_reg;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd_reg;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd_reg;\n\n    // Wishbone Slave Interface\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            wb_dat_o_reg <= 32'd0;\n            wb_ack_o_reg <= 1'b0;\n        end else begin\n            wb_dat_o_reg <= wb_dat_i;\n            wb_ack_o_reg <= wb_ack_o_reg;\n        end\n    end\n\n    // Master Wishbone Interface\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            m_wb_dat_o_reg <= 32'd0;\n            m_wb_cyc_o_reg <= 1'b0;\n            m_wb_stb_o_reg <= 1'b0;\n            m_wb_cti_o_reg <= 3'b000;\n            m_wb_bte_o_reg <= 2'b00;\n        end else begin\n            m_wb_dat_o_reg <= m_wb_dat_o_reg;\n            m_wb_cyc_o_reg <= m_wb_cyc_o_reg;\n            m_wb_stb_o_reg <= m_wb_stb_o_reg;\n            m_wb_cti_o_reg <= m_wb_cti_o_reg;\n            m_wb_bte_o_reg <= m_wb_bte_o_reg;\n        end\n    end\n\n    // Internal Signals\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            we_m_tx_bd_reg <= 1'b0;\n            we_m_rx_bd_reg <= 1'b0;\n            new_cmd_reg <= 1'b0;\n            we_ack_reg <= 1'b0;\n            int_ack_reg <= 1'b0;\n            cmd_int_busy_reg <= 1'b0;\n            int_busy_reg <= 1'b0;\n            write_req_s_reg <= 1'b0;\n            cmd_set_s_reg <= 16'd0;\n            cmd_arg_s_reg <= 32'd0;\n            argument_reg_reg <= 32'd0;\n            cmd_setting_reg_reg <= 16'd0;\n            status_reg_reg <= 16'd0;\n            cmd_resp_1_reg <= 32'd0;\n            software_reset_reg_reg <= 8'd0;\n            time_out_reg_reg <= 16'd0;\n            normal_int_status_reg_reg <= 16'd0;\n            error_int_status_reg_reg <= 16'd0;\n            normal_int_signal_enable_reg_reg <= 16'd0;\n            error_int_signal_enable_reg_reg <= 16'd0;\n            clock_divider_reg <= 8'd0;\n            Bd_Status_reg_reg <= 16'd0;\n            Bd_isr_reg_reg <= 8'd0;\n            Bd_isr_enable_reg_reg <= 8'd0;\n            Bd_isr_reset_reg <= 1'b0;\n            normal_isr_reset_reg <= 1'b0;\n            error_isr_reset_reg <= 1'b0;\n            dat_in_m_tx_bd_reg <= RAM_MEM_WIDTH'd0;\n            dat_in_m_rx_bd_reg <= RAM_MEM_WIDTH'd0;\n        end else begin\n            we_m_tx_bd_reg <= we_m_tx_bd_reg;\n            we_m_rx_bd_reg <= we_m_rx_bd_reg;\n            new_cmd_reg <= new_cmd_reg;\n            we_ack_reg <= we_ack_reg;\n            int_ack_reg <= int_ack_reg;\n            cmd_int_busy_reg <= cmd_int_busy_reg;\n            int_busy_reg <= int_busy_reg;\n            write_req_s_reg <= write_req_s_reg;\n            cmd_set_s_reg <= cmd_set_s_reg;\n            cmd_arg_s_reg <= cmd_arg_s_reg;\n            argument_reg_reg <= argument_reg_reg;\n            cmd_setting_reg_reg <= cmd_setting_reg_reg;\n            status_reg_reg <= status_reg_reg;\n            cmd_resp_1_reg <= cmd_resp_1_reg;\n            software_reset_reg_reg <= software_reset_reg_reg;\n            time_out_reg_reg <= time_out_reg_reg;\n            normal_int_status_reg_reg <= normal_int_status_reg_reg;\n            error_int_status_reg_reg <= error_int_status_reg_reg;\n            normal_int_signal_enable_reg_reg <= normal_int_signal_enable_reg_reg;\n            error_int_signal_enable_reg_reg <= error_int_signal_enable_reg_reg;\n            clock_divider_reg <= clock_divider_reg;\n            Bd_Status_reg_reg <= Bd_Status_reg_reg;\n            Bd_isr_reg_reg <= Bd_isr_reg_reg;\n            Bd_isr_enable_reg_reg <= Bd_isr_enable_reg_reg;\n            Bd_isr_reset_reg <= Bd_isr_reset_reg;\n            normal_isr_reset_reg <= normal_isr_reset_reg;\n            error_isr_reset_reg <= error_isr_reset_reg;\n            dat_in_m_tx_bd_reg <= dat_in_m_tx_bd_reg;\n            dat_in_m_rx_bd_reg <= dat_in_m_rx_bd_reg;\n        end\n    end\n\n    // Wishbone Slave Interface\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            wb_dat_o <= 32'd0;\n            wb_ack_o <= 1'b0;\n        end else begin\n            wb_dat_o <= wb_dat_o_reg;\n            wb_ack_o <= wb_ack_o_reg;\n        end\n    end\n\n    // Master Wishbone Interface\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else begin\n            m_wb_dat_o <= m_wb_dat_o_reg;\n            m_wb_cyc_o <= m_wb_cyc_o_reg;\n            m_wb_stb_o <= m_wb_stb_o_reg;\n            m_wb_cti_o <= m_wb_cti_o_reg;\n            m_wb_bte_o <= m_wb_bte_o_reg;\n        end\n    end\n\n    // Internal Signals\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b0;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            write_req_s <= 1'b0;\n            cmd_set_s <= 16'd0;\n            cmd_arg_s <= 32'd0;\n            argument_reg <= 32'd0;\n            cmd_setting_reg <= 16'd0;\n            status_reg <= 16'd0;\n            cmd_resp_1 <= 32'd0;\n            software_reset_reg <= 8'd0;\n            time_out_reg <= 16'd0;\n            normal_int_status_reg <= 16'd0;\n            error_int_status_reg <= 16'd0;\n            normal_int_signal_enable_reg <= 16'd0;\n            error_int_signal_enable_reg <= 16'd0;\n            clock_divider <= 8'd0;\n            Bd_Status_reg <= 16'd0;\n            Bd_isr_reg <= 8'd0;\n            Bd_isr_enable_reg <= 8'd0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= RAM_MEM_WIDTH'd0;\n            dat_in_m_rx_bd <= RAM_MEM_WIDTH'd0;\n        end else begin\n            we_m_tx_bd <= we_m_tx_bd_reg;\n            we_m_rx_bd <= we_m_rx_bd_reg;\n            new_cmd <= new_cmd_reg;\n            we_ack <= we_ack_reg;\n            int_ack <= int_ack_reg;\n            cmd_int_busy <= cmd_int_busy_reg;\n            int_busy <= int_busy_reg;\n            write_req_s <= write_req_s_reg;\n            cmd_set_s <= cmd_set_s_reg;\n            cmd_arg_s <= cmd_arg_s_reg;\n            argument_reg <= argument_reg_reg;\n            cmd_setting_reg <= cmd_setting_reg_reg;\n            status_reg <= status_reg_reg;\n            cmd_resp_1 <= cmd_resp_1_reg;\n            software_reset_reg <= software_reset_reg_reg;\n            time_out_reg <= time_out_reg_reg;\n            normal_int_status_reg <= normal_int_status_reg_reg;\n            error_int_status_reg <= error_int_status_reg_reg;\n            normal_int_signal_enable_reg <= normal_int_signal_enable_reg_reg;\n            error_int_signal_enable_reg <= error_int_signal_enable_reg_reg;\n            clock_divider <= clock_divider_reg;\n            Bd_Status_reg <= Bd_Status_reg_reg;\n            Bd_isr_reg <= Bd_isr_reg_reg;\n            Bd_isr_enable_reg <= Bd_isr_enable_reg_reg;\n            Bd_isr_reset <= Bd_isr_reset_reg;\n            normal_isr_reset <= normal_isr_reset_reg;\n            error_isr_reset <= error_isr_reset_reg;\n            dat_in_m_tx_bd <= dat_in_m_tx_bd_reg;\n            dat_in_m_rx_bd <= dat_in_m_rx_bd_reg;\n        end\n    end\n\n    // Wishbone Slave Interface\n    assign wb_dat_o = wb_dat_o_reg;\n    assign wb_ack_o = wb_ack_o_reg;\n\n    // Master Wishbone Interface\n    assign m_wb_dat_o = m_wb_dat_o_reg;\n    assign m_wb_cyc_o = m_wb_cyc_o_reg;\n    assign m_wb_stb_o = m_wb_stb_o_reg;\n    assign m_wb_cti_o = m_wb_cti_o_reg;\n    assign m_wb_bte_o = m_wb_bte_o_reg;\n\n    // Internal Signals\n    assign we_m_tx_bd = we_m_tx_bd_reg;\n    assign we_m_rx_bd = we_m_rx_bd_reg;\n    assign new_cmd = new_cmd_reg;\n    assign we_ack = we_ack_reg;\n    assign int_ack = int_ack_reg;\n    assign cmd_int_busy = cmd_int_busy_reg;\n    assign int_busy = int_busy_reg;\n    assign write_req_s = write_req_s_reg;\n    assign cmd_set_s = cmd_set_s_reg;\n    assign cmd_arg_s = cmd_arg_s_reg;\n    assign argument_reg = argument_reg_reg;\n    assign cmd_setting_reg = cmd_setting_reg_reg;\n    assign status_reg = status_reg_reg;\n    assign cmd_resp_1 = cmd_resp_1_reg;\n    assign software_reset_reg = software_reset_reg_reg;\n    assign time_out_reg = time_out_reg_reg;\n    assign normal_int_status_reg = normal_int_status_reg_reg;\n    assign error_int_status_reg = error_int_status_reg_reg;\n    assign normal_int_signal_enable_reg = normal_int_signal_enable_reg_reg;\n    assign error_int_signal_enable_reg = error_int_signal_enable_reg_reg;\n    assign clock_divider = clock_divider_reg;\n    assign Bd_Status_reg = Bd_Status_reg_reg;\n    assign Bd_isr_reg = Bd_isr_reg_reg;\n    assign Bd_isr_enable_reg = Bd_isr_enable_reg_reg;\n    assign Bd_isr_reset = Bd_isr_reset_reg;\n    assign normal_isr_reset = normal_isr_reset_reg;\n    assign error_isr_reset = error_isr_reset_reg;\n    assign dat_in_m_tx_bd = dat_in_m_tx_bd_reg;\n    assign dat_in_m_rx_bd = dat_in_m_rx_bd_reg;\n\nendmodule\nmodule sd_clock_divider(\n    input  wire        CLK,\n    input  wire [7:0]  DIVIDER,\n    input  wire        RST,\n    output wire        SD_CLK\n);\n\n    reg [15:0] count;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            count <= 16'd0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\n    assign SD_CLK = (count == (16'd1 + DIVIDER))? 1'b1 : 1'b0;\n\nendmodule\nmodule sd_cmd_master(\n    input  wire        CLK_PAD_IO,\n    input  wire        RST_PAD_I,\n    input  wire        New_CMD,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:8] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [5:0]  ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire        ERR_INT_RST,\n    input  wire        NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire        go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire        req_out,\n    output wire        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n    reg [15:0] state;\n    reg [15:0] next_state;\n    reg [15:0] cmd_arg;\n    reg [15:0] cmd_set;\n    reg [15:0] cmd_setting_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [15:0] timeout_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0]  clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [7:0]  Bd_isr_reg;\n    reg [7:0]  Bd_isr_enable_reg;\n    reg        Bd_isr_reset;\n    reg        normal_isr_reset;\n    reg        error_isr_reset;\n    reg [15:0] dat_in_m_tx_bd;\n    reg [15:0] dat_in_m_rx_bd;\n\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= 15'd0;\n            next_state <= 15'd0;\n            cmd_arg <= 15'd0;\n            cmd_set <= 15'd0;\n            cmd_setting_reg <= 15'd0;\n            status_reg <= 15'd0;\n            cmd_resp_1 <= 32'd0;\n            timeout_reg <= 15'd0;\n            normal_int_status_reg <= 15'd0;\n            error_int_status_reg <= 15'd0;\n            normal_int_signal_enable_reg <= 15'd0;\n            error_int_signal_enable_reg <= 15'd0;\n            clock_divider <= 7'd0;\n            Bd_Status_reg <= 15'd0;\n            Bd_isr_reg <= 7'd0;\n            Bd_isr_enable_reg <= 7'd0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= 15'd0;\n            dat_in_m_rx_bd <= 15'd0;\n        end else begin\n            state <= next_state;\n            next_state <= next_state;\n            cmd_arg <= cmd_arg;\n            cmd_set <= cmd_set;\n            cmd_setting_reg <= cmd_setting_reg;\n            status_reg <= status_reg;\n            cmd_resp_1 <= cmd_resp_1;\n            timeout_reg <= timeout_reg;\n            normal_int_status_reg <= normal_int_status_reg;\n            error_int_status_reg <= error_int_status_reg;\n            normal_int_signal_enable_reg <= normal_int_signal_enable_reg;\n            error_int_signal_enable_reg <= error_int_signal_enable_reg;\n            clock_divider <= clock_divider;\n            Bd_Status_reg <= Bd_Status_reg;\n            Bd_isr_reg <= Bd_isr_reg;\n            Bd_isr_enable_reg <= Bd_isr_enable_reg;\n            Bd_isr_reset <= Bd_isr_reset;\n            normal_isr_reset <= normal_isr_reset;\n            error_isr_reset <= error_isr_reset;\n            dat_in_m_tx_bd <= dat_in_m_tx_bd;\n            dat_in_m_rx_bd <= dat_in_m_rx_bd;\n        end\n    end\n\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            cmd_arg <= 15'd0;\n            cmd_set <= 15'd0;\n            cmd_setting_reg <= 15'd0;\n            status_reg <= 15'd0;\n            cmd_resp_1 <= 32'd0;\n            timeout_reg <= 15'd0;\n            normal_int_status_reg <= 15'd0;\n            error_int_status_reg <= 15'd0;\n            normal_int_signal_enable_reg <= 15'd0;\n            error_int_signal_enable_reg <= 15'd0;\n            clock_divider <= 7'd0;\n            Bd_Status_reg <= 15'd0;\n            Bd_isr_reg <= 7'd0;\n            Bd_isr_enable_reg <= 7'd0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= 15'd0;\n            dat_in_m_rx_bd <= 15'd0;\n        end else begin\n            cmd_arg <= cmd_arg;\n            cmd_set <= cmd_set;\n            cmd_setting_reg <= cmd_setting_reg;\n            status_reg <= status_reg;\n            cmd_resp_1 <= cmd_resp_1;\n            timeout_reg <= timeout_reg;\n            normal_int_status_reg <= normal_int_status_reg;\n            error_int_status_reg <= error_int_status_reg;\n            normal_int_signal_enable_reg <= normal_int_signal_enable_reg;\n            error_int_signal_enable_reg <= error_int_signal_enable_reg;\n            clock_divider <= clock_divider;\n            Bd_Status_reg <= Bd_Status_reg;\n            Bd_isr_reg <= Bd_isr_reg;\n            Bd_isr_enable_reg <= Bd_isr_enable_reg;\n            Bd_isr_reset <= Bd_isr_reset;\n            normal_isr_reset <= normal_isr_reset;\n            error_isr_reset <= error_isr_reset;\n            dat_in_m_tx_bd <= dat_in_m_tx_bd;\n            dat_in_m_rx_bd <= dat_in_m_rx_bd;\n        end\n    end\n\n    assign settings = cmd_setting_reg;\n    assign go_idle_o = 1'b0;\n    assign cmd_out = cmd_arg;\n    assign req_out = 1'b0;\n    assign ack_out = 1'b0;\n    assign req_in = 1'b0;\n    assign ack_in = 1'b0;\n    assign cmd_in = 39'd0;\n    assign serial_status = 8'd0;\n    assign card_detect = 1'b0;\n\nendmodule\nmodule sd_data_master(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd,\n    input  wire [15:0] free_tx_bd,\n    input  wire [15:0] free_rx_bd,\n    input  wire        ack_i_s_tx,\n    input  wire        ack_i_s_rx,\n    input  wire        cmd_busy,\n    input  wire        we_ack,\n    input  wire        cmd_tsf_err,\n    input  wire [5:0]  card_status,\n    input  wire        tx_empt,\n    input  wire        tx_full,\n    input  wire        rx_full,\n    input  wire        busy_n,\n    input  wire        transm_complete,\n    input  wire        crc_ok,\n    input  wire        Dat_Int_Status_rst,\n    input  wire [1:0]  transfer_type,\n    output wire        re_s_tx,\n    output wire        a_cmp_tx,\n    output wire        re_s_rx,\n    output wire        a_cmp_rx,\n    output wire        we_req,\n    output wire        d_write,\n    output wire        d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire        start_tx_fifo,\n    output wire        start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire        ack_transfer,\n    output wire [7:0]  Dat_Int_Status,\n    output wire        CIDAT\n);\n\n    reg [15:0] state;\n    reg [15:0] next_state;\n    reg [15:0] cmd_arg_reg;\n    reg [15:0] cmd_set_reg;\n    reg [31:0] argument_reg;\n    reg [31:0] cmd_setting_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [15:0] timeout_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0]  clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [7:0]  Bd_isr_reg;\n    reg [7:0]  Bd_isr_enable_reg;\n    reg        Bd_isr_reset;\n    reg        normal_isr_reset;\n    reg        error_isr_reset;\n    reg [15:0] dat_in_m_tx_bd;\n    reg [15:0] dat_in_m_rx_bd;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= 15'd0;\n            next_state <= 15'd0;\n            cmd_arg_reg <= 15'd0;\n            cmd_set_reg <= 15'd0;\n            argument_reg <= 32'd0;\n            cmd_setting_reg <= 32'd0;\n            status_reg <= 15'd0;\n            cmd_resp_1 <= 32'd0;\n            timeout_reg <= 15'd0;\n            normal_int_status_reg <= 15'd0;\n            error_int_status_reg <= 15'd0;\n            normal_int_signal_enable_reg <= 15'd0;\n            error_int_signal_enable_reg <= 15'd0;\n            clock_divider <= 7'd0;\n            Bd_Status_reg <= 15'd0;\n            Bd_isr_reg <= 7'd0;\n            Bd_isr_enable_reg <= 7'd0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= 15'd0;\n            dat_in_m_rx_bd <= 15'd0;\n        end else begin\n            state <= next_state;\n            next_state <= next_state;\n            cmd_arg_reg <= cmd_arg_reg;\n            cmd_set_reg <= cmd_set_reg;\n            argument_reg <= argument_reg;\n            cmd_setting_reg <= cmd_setting_reg;\n            status_reg <= status_reg;\n            cmd_resp_1 <= cmd_resp_1;\n            timeout_reg <= timeout_reg;\n            normal_int_status_reg <= normal_int_status_reg;\n            error_int_status_reg <= error_int_status_reg;\n            normal_int_signal_enable_reg <= normal_int_signal_enable_reg;\n            error_int_signal_enable_reg <= error_int_signal_enable_reg;\n            clock_divider <= clock_divider;\n            Bd_Status_reg <= Bd_Status_reg;\n            Bd_isr_reg <= Bd_isr_reg;\n            Bd_isr_enable_reg <= Bd_isr_enable_reg;\n            Bd_isr_reset <= Bd_isr_reset;\n            normal_isr_reset <= normal_isr_reset;\n            error_isr_reset <= error_isr_reset;\n            dat_in_m_tx_bd <= dat_in_m_tx_bd;\n            dat_in_m_rx_bd <= dat_in_m_rx_bd;\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            cmd_arg_reg <= 15'd0;\n            cmd_set_reg <= 15'd0;\n            argument_reg <= 32'd0;\n            cmd_setting_reg <= 32'd0;\n            status_reg <= 15'd0;\n            cmd_resp_1 <= 32'd0;\n            timeout_reg <= 15'd0;\n            normal_int_status_reg <= 15'd0;\n            error_int_status_reg <= 15'd0;\n            normal_int_signal_enable_reg <= 15'd0;\n            error_int_signal_enable_reg <= 15'd0;\n            clock_divider <= 7'd0;\n            Bd_Status_reg <= 15'd0;\n            Bd_isr_reg <= 7'd0;\n            Bd_isr_enable_reg <= 7'd0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= 15'd0;\n            dat_in_m_rx_bd <= 15'd0;\n        end else begin\n            cmd_arg_reg <= cmd_arg_reg;\n            cmd_set_reg <= cmd_set_reg;\n            argument_reg <= argument_reg;\n            cmd_setting_reg <= cmd_setting_reg;\n            status_reg <= status_reg;\n            cmd_resp_1 <= cmd_resp_1;\n            timeout_reg <= timeout_reg;\n            normal_int_status_reg <= normal_int_status_reg;\n            error_int_status_reg <= error_int_status_reg;\n            normal_int_signal_enable_reg <= normal_int_signal_enable_reg;\n            error_int_signal_enable_reg <= error_int_signal_enable_reg;\n            clock_divider <= clock_divider;\n            Bd_Status_reg <= Bd_Status_reg;\n            Bd_isr_reg <= Bd_isr_reg;\n            Bd_isr_enable_reg <= Bd_isr_enable_reg;\n            Bd_isr_reset <= Bd_isr_reset;\n            normal_isr_reset <= normal_isr_reset;\n            error_isr_reset <= error_isr_reset;\n            dat_in_m_tx_bd <= dat_in_m_tx_bd;\n            dat_in_m_rx_bd <= dat_in_m_rx_bd;\n        end\n    end\n\n    assign re_s_tx = 1'b0;\n    assign a_cmp_tx = 1'b0;\n    assign re_s_rx = 1'b0;\n    assign a_cmp_rx = 1'b0;\n    assign we_req = 1'b0;\n    assign d_write = 1'b0;\n    assign d_read = 1'b0;\n    assign cmd_arg = cmd_arg_reg;\n    assign cmd_set = cmd_set_reg;\n    assign start_tx_fifo = 1'b0;\n    assign start_rx_fifo = 1'b0;\n    assign sys_adr = 32'd0;\n    assign ack_transfer = 1'b0;\n    assign Dat_Int_Status = 8'd0;\n    assign CIDAT = 1'b0;\n\nendmodule\nmodule sd_fifo_tx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [31:0] m_wb_adr_o,\n    input  wire        m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire        m_wb_cyc_o,\n    input  wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    input  wire [2:0]  m_wb_cti_o,\n    input  wire [1:0]  m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    output wire [31:0] dat_o,\n    input  wire        rd,\n    output wire        empty,\n    output wire        fe\n);\n\n    reg [15:0] state;\n    reg [15:0] next_state;\n    reg [31:0] m_wb_adr_o_reg;\n    reg        m_wb_we_o_reg;\n    reg [31:0] m_wb_dat_i_reg;\n    reg        m_wb_cyc_o_reg;\n    reg        m_wb_stb_o_reg;\n    reg        m_wb_ack_i_reg;\n    reg [2:0]  m_wb_cti_o_reg;\n    reg [1:0]  m_wb_bte_o_reg;\n    reg        en_reg;\n    reg [31:0] adr_reg;\n    reg        sd_clk_reg;\n    reg [31:0] dat_o_reg;\n    reg        rd_reg;\n    reg        empty_reg;\n    reg        fe_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= 15'd0;\n            next_state <= 15'd0;\n            m_wb_adr_o_reg <= 32'd0;\n            m_wb_we_o_reg <= 1'b0;\n            m_wb_dat_i_reg <= 32'd0;\n            m_wb_cyc_o_reg <= 1'b0;\n            m_wb_stb_o_reg <= 1'b0;\n            m_wb_ack_i_reg <= 1'b0;\n            m_wb_cti_o_reg <= 3'b000;\n            m_wb_bte_o_reg <= 2'b00;\n            en_reg <= 1'b0;\n            adr_reg <= 32'd0;\n            sd_clk_reg <= 1'b0;\n            dat_o_reg <= 32'd0;\n            rd_reg <= 1'b0;\n            empty_reg <= 1'b0;\n            fe_reg <= 1'b0;\n        end else begin\n            state <= next_state;\n            next_state <= next_state;\n            m_wb_adr_o_reg <= m_wb_adr_o_reg;\n            m_wb_we_o_reg <= m_wb_we_o_reg;\n            m_wb_dat_i_reg <= m_wb_dat_i_reg;\n            m_wb_cyc_o_reg <= m_wb_cyc_o_reg;\n            m_wb_stb_o_reg <= m_wb_stb_o_reg;\n            m_wb_ack_i_reg <= m_wb_ack_i_reg;\n            m_wb_cti_o_reg <= m_wb_cti_o_reg;\n            m_wb_bte_o_reg <= m_wb_bte_o_reg;\n            en_reg <= en_reg;\n            adr_reg <= adr_reg;\n            sd_clk_reg <= sd_clk_reg;\n            dat_o_reg <= dat_o_reg;\n            rd_reg <= rd_reg;\n            empty_reg <= empty_reg;\n            fe_reg <= fe_reg;\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_i <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_ack_i <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n            en <= 1'b0;\n            adr <= 32'd0;\n            sd_clk <= 1'b0;\n            dat_o <= 32'd0;\n            rd <= 1'b0;\n            empty <= 1'b0;\n            fe <= 1'b0;\n        end else begin\n            m_wb_adr_o <= m_wb_adr_o_reg;\n            m_wb_we_o <= m_wb_we_o_reg;\n            m_wb_dat_i <= m_wb_dat_i_reg;\n            m_wb_cyc_o <= m_wb_cyc_o_reg;\n            m_wb_stb_o <= m_wb_stb_o_reg;\n            m_wb_ack_i <= m_wb_ack_i_reg;\n            m_wb_cti_o <= m_wb_cti_o_reg;\n            m_wb_bte_o <= m_wb_bte_o_reg;\n            en <= en_reg;\n            adr <= adr_reg;\n            sd_clk <= sd_clk_reg;\n            dat_o <= dat_o_reg;\n            rd <= rd_reg;\n            empty <= empty_reg;\n            fe <= fe_reg;\n        end\n    end\n\n    assign dat_o = dat_o_reg;\n    assign empty = empty_reg;\n    assign fe = fe_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 18, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_cmd_master(\n    input  wire        CLK_PAD_IO,\n    input  wire        RST_PAD_I,\n    input  wire        New_CMD,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:8] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [5:0]  ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire        ERR_INT_RST,\n    input  wire        NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire        go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire        req_out,\n    output wire        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_data_master(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input  wire [BD_WIDTH-1:0] free_tx_bd,\n    input  wire        ack_i_s_tx,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input  wire [BD_WIDTH-1:0] free_rx_bd,\n    input  wire        ack_i_s_rx,\n    input  wire        cmd_busy,\n    input  wire        we_ack,\n    input  wire        cmd_tsf_err,\n    input  wire [5:0]  card_status,\n    input  wire        tx_empt,\n    input  wire        tx_full,\n    input  wire        rx_full,\n    input  wire        busy_n,\n    input  wire        transm_complete,\n    input  wire        crc_ok,\n    input  wire        Dat_Int_Status_rst,\n    input  wire [1:0] transfer_type,\n    output wire        re_s_tx,\n    output wire        a_cmp_tx,\n    output wire        re_s_rx,\n    output wire        a_cmp_rx,\n    output wire        we_req,\n    output wire        d_write,\n    output wire        d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire        start_tx_fifo,\n    output wire        start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire        ack_transfer,\n    output wire [7:0]  Dat_Int_Status,\n    output wire        CIDAT\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_fifo_tx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    output wire [31:0] m_wb_adr_o,\n    output wire        m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire        m_wb_cyc_o,\n    output wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    output wire [2:0]  m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    output wire [31:0] dat_o,\n    input  wire        rd,\n    output wire        empty,\n    output wire        fe\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_fifo_rx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    output wire [31:0] m_wb_adr_o,\n    output wire        m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire        m_wb_cyc_o,\n    output wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    output wire [2:0]  m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire        wr,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt,\n    input  wire        rclk,\n    input  wire        rst\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_clock_divider(\n    input  wire        CLK,\n    input  wire [7:0]  DIVIDER,\n    input  wire        RST,\n    output wire        SD_CLK\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_cmd_serial_host(\n    input  wire        SD_CLK_IN,\n    input  wire        RST_IN,\n    input  wire        New_CMD,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:8] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [5:0]  ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire        ERR_INT_RST,\n    input  wire        NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire        go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire        req_out,\n    output wire        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_data_serial_host(\n    input  wire        sd_clk,\n    input  wire        rst,\n    output wire        rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire        we,\n    output wire        DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    input  wire [SD_BUS_W-1:0] DAT_dat_i,\n    output wire        busy_n,\n    output wire        transm_complete,\n    output wire        crc_ok\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_crc_16(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output wire [15:0] CRC\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_crc_7(\n    input  wire        BITVAL,\n    input  wire        Enable,\n    input  wire        CLK,\n    input  wire        RST,\n    output wire [6:0] CRC\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_fifo_tx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    output wire [31:0] m_wb_adr_o,\n    output wire        m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire        m_wb_cyc_o,\n    output wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    output wire [2:0]  m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    output wire [31:0] dat_o,\n    input  wire        rd,\n    output wire        empty,\n    output wire        fe\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_fifo_rx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    output wire [31:0] m_wb_adr_o,\n    output wire        m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire        m_wb_cyc_o,\n    output wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    output wire [2:0]  m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire        wr,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt,\n    input  wire        rclk,\n    input  wire        rst\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    output wire        we_m,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input  wire        re_s,\n    input  wire        ack_o_s,\n    input  wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the code...\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 19, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register definitions\n    reg [31:0] argument_reg;\n    reg [15:0] cmd_setting_reg;\n    reg [15:0] status_reg;\n    reg [31:0] cmd_resp_1;\n    reg [7:0]  software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_status_reg;\n    reg [15:0] error_int_status_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0]  clock_divider;\n    reg [15:0] Bd_Status_reg;\n    reg [7:0]  Bd_isr_reg;\n    reg [7:0]  Bd_isr_enable_reg;\n    reg        Bd_isr_reset;\n    reg        normal_isr_reset;\n    reg        error_isr_reset;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // State machine\n    reg [9:0] state;\n    reg [9:0] next_state;\n\n    // FSM state transitions\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            state <= 10'b0000000000;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM state machine logic\n    always @(*) begin\n        case (state)\n            10'b0000000000: next_state = 10'b0000000000; // IDLE\n            10'b0000000001: next_state = 10'b0000000001; // SETUP\n            10'b0000000010: next_state = 10'b0000000010; // EXECUTE\n            default: next_state = 10'b0000000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: wb_ack_o = 1'b0; // IDLE\n            10'b0000000001: wb_ack_o = 1'b0; // SETUP\n            10'b0000000010: wb_ack_o = 1'b0; // EXECUTE\n            default: wb_ack_o = 1'b0;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: we_m_tx_bd = 1'b0; // IDLE\n            10'b0000000001: we_m_tx_bd = 1'b0; // SETUP\n            10'b0000000010: we_m_tx_bd = 1'b0; // EXECUTE\n            default: we_m_tx_bd = 1'b0;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: we_m_rx_bd = 1'b0; // IDLE\n            10'b0000000001: we_m_rx_bd = 1'b0; // SETUP\n            10'b0000000010: we_m_rx_bd = 1'b0; // EXECUTE\n            default: we_m_rx_bd = 1'b0;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: new_cmd = 1'b0; // IDLE\n            10'b0000000001: new_cmd = 1'b0; // SETUP\n            10'b0000000010: new_cmd = 1'b0; // EXECUTE\n            default: new_cmd = 1'b0;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: we_ack = 1'b0; // IDLE\n            10'b0000000001: we_ack = 1'b0; // SETUP\n            10'b0000000010: we_ack = 1'b0; // EXECUTE\n            default: we_ack = 1'b0;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: int_ack = 1'b0; // IDLE\n            10'b0000000001: int_ack = 1'b0; // SETUP\n            10'b0000000010: int_ack = 1'b0; // EXECUTE\n            default: int_ack = 1'b0;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: cmd_int_busy = 1'b0; // IDLE\n            10'b0000000001: cmd_int_busy = 1'b0; // SETUP\n            10'b0000000010: cmd_int_busy = 1'b0; // EXECUTE\n            default: cmd_int_busy = 1'b0;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: int_busy = 1'b0; // IDLE\n            10'b0000000001: int_busy = 1'b0; // SETUP\n            10'b0000000010: int_busy = 1'b0; // EXECUTE\n            default: int_busy = 1'b0;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: write_req_s = 1'b0; // IDLE\n            10'b0000000001: write_req_s = 1'b0; // SETUP\n            10'b0000000010: write_req_s = 1'b0; // EXECUTE\n            default: write_req_s = 1'b0;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: cmd_set_s = 15'b0000000000000000; // IDLE\n            10'b0000000001: cmd_set_s = 15'b0000000000000000; // SETUP\n            10'b0000000010: cmd_set_s = 15'b0000000000000000; // EXECUTE\n            default: cmd_set_s = 15'b0000000000000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: cmd_arg_s = 31'b00000000000000000000000000000000; // IDLE\n            10'b0000000001: cmd_arg_s = 31'b00000000000000000000000000000000; // SETUP\n            10'b0000000010: cmd_arg_s = 31'b00000000000000000000000000000000; // EXECUTE\n            default: cmd_arg_s = 31'b00000000000000000000000000000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: argument_reg = 31'b00000000000000000000000000000000; // IDLE\n            10'b0000000001: argument_reg = 31'b00000000000000000000000000000000; // SETUP\n            10'b0000000010: argument_reg = 31'b00000000000000000000000000000000; // EXECUTE\n            default: argument_reg = 31'b00000000000000000000000000000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: cmd_setting_reg = 15'b0000000000000000; // IDLE\n            10'b0000000001: cmd_setting_reg = 15'b0000000000000000; // SETUP\n            10'b0000000010: cmd_setting_reg = 15'b0000000000000000; // EXECUTE\n            default: cmd_setting_reg = 15'b0000000000000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: status_reg = 15'b0000000000000000; // IDLE\n            10'b0000000001: status_reg = 15'b0000000000000000; // SETUP\n            10'b0000000010: status_reg = 15'b0000000000000000; // EXECUTE\n            default: status_reg = 15'b0000000000000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: cmd_resp_1 = 31'b00000000000000000000000000000000; // IDLE\n            10'b0000000001: cmd_resp_1 = 31'b00000000000000000000000000000000; // SETUP\n            10'b0000000010: cmd_resp_1 = 31'b00000000000000000000000000000000; // EXECUTE\n            default: cmd_resp_1 = 31'b00000000000000000000000000000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: software_reset_reg = 7'b0000000; // IDLE\n            10'b0000000001: software_reset_reg = 7'b0000000; // SETUP\n            10'b0000000010: software_reset_reg = 7'b0000000; // EXECUTE\n            default: software_reset_reg = 7'b0000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: time_out_reg = 15'b0000000000000000; // IDLE\n            10'b0000000001: time_out_reg = 15'b0000000000000000; // SETUP\n            10'b0000000010: time_out_reg = 15'b0000000000000000; // EXECUTE\n            default: time_out_reg = 15'b0000000000000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: normal_int_status_reg = 15'b0000000000000000; // IDLE\n            10'b0000000001: normal_int_status_reg = 15'b0000000000000000; // SETUP\n            10'b0000000010: normal_int_status_reg = 15'b0000000000000000; // EXECUTE\n            default: normal_int_status_reg = 15'b0000000000000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: error_int_status_reg = 15'b0000000000000000; // IDLE\n            10'b0000000001: error_int_status_reg = 15'b0000000000000000; // SETUP\n            10'b0000000010: error_int_status_reg = 15'b0000000000000000; // EXECUTE\n            default: error_int_status_reg = 15'b0000000000000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: normal_int_signal_enable_reg = 15'b0000000000000000; // IDLE\n            10'b0000000001: normal_int_signal_enable_reg = 15'b0000000000000000; // SETUP\n            10'b0000000010: normal_int_signal_enable_reg = 15'b0000000000000000; // EXECUTE\n            default: normal_int_signal_enable_reg = 15'b0000000000000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: error_int_signal_enable_reg = 15'b0000000000000000; // IDLE\n            10'b0000000001: error_int_signal_enable_reg = 15'b0000000000000000; // SETUP\n            10'b0000000010: error_int_signal_enable_reg = 15'b0000000000000000; // EXECUTE\n            default: error_int_signal_enable_reg = 15'b0000000000000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: clock_divider = 7'b0000000; // IDLE\n            10'b0000000001: clock_divider = 7'b0000000; // SETUP\n            10'b0000000010: clock_divider = 7'b0000000; // EXECUTE\n            default: clock_divider = 7'b0000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: Bd_Status_reg = 15'b0000000000000000; // IDLE\n            10'b0000000001: Bd_Status_reg = 15'b0000000000000000; // SETUP\n            10'b0000000010: Bd_Status_reg = 15'b0000000000000000; // EXECUTE\n            default: Bd_Status_reg = 15'b0000000000000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: Bd_isr_reg = 7'b0000000; // IDLE\n            10'b0000000001: Bd_isr_reg = 7'b0000000; // SETUP\n            10'b0000000010: Bd_isr_reg = 7'b0000000; // EXECUTE\n            default: Bd_isr_reg = 7'b0000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: Bd_isr_enable_reg = 7'b0000000; // IDLE\n            10'b0000000001: Bd_isr_enable_reg = 7'b0000000; // SETUP\n            10'b0000000010: Bd_isr_enable_reg = 7'b0000000; // EXECUTE\n            default: Bd_isr_enable_reg = 7'b0000000;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: Bd_isr_reset = 1'b0; // IDLE\n            10'b0000000001: Bd_isr_reset = 1'b0; // SETUP\n            10'b0000000010: Bd_isr_reset = 1'b0; // EXECUTE\n            default: Bd_isr_reset = 1'b0;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: normal_isr_reset = 1'b0; // IDLE\n            10'b0000000001: normal_isr_reset = 1'b0; // SETUP\n            10'b0000000010: normal_isr_reset = 1'b0; // EXECUTE\n            default: normal_isr_reset = 1'b0;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: error_isr_reset = 1'b0; // IDLE\n            10'b0000000001: error_isr_reset = 1'b0; // SETUP\n            10'b0000000010: error_isr_reset = 1'b0; // EXECUTE\n            default: error_isr_reset = 1'b0;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: dat_in_m_tx_bd = RAM_MEM_WIDTH-1'b0; // IDLE\n            10'b0000000001: dat_in_m_tx_bd = RAM_MEM_WIDTH-1'b0; // SETUP\n            10'b0000000010: dat_in_m_tx_bd = RAM_MEM_WIDTH-1'b0; // EXECUTE\n            default: dat_in_m_tx_bd = RAM_MEM_WIDTH-1'b0;\n        endcase\n    end\n\n    // FSM state machine outputs\n    always @(*) begin\n        case (state)\n            10'b0000000000: dat_in_m_rx_bd = RAM_MEM_WIDTH-1'b0; // IDLE\n            10'b0000000001: dat_in_m_rx_bd = RAM_MEM_WIDTH-1'b0; // SETUP\n            10'b0000000010: dat_in_m_rx_bd = RAM_MEM_WIDTH-1'b0; // EXECUTE\n            default: dat_in_m_rx_bd = RAM_MEM_WIDTH-1'b0;\n        endcase\n    end\n\nendmodule\nmodule sd_clock_divider(\n    input  wire        CLK,\n    input  wire [7:0]  DIVIDER,\n    input  wire        RST,\n    output wire        SD_CLK\n);\n\n    // Register definitions\n    reg [7:0]  divider;\n    reg [7:0]  sd_clk_count;\n\n    // State machine\n    reg [9:0]  state;\n    reg [9:0]  next_state;\n\n    // FSM state transitions\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            state <= 10'b0000000000;\n            sd_clk_count <= 8'b00000000;\n        end\n        else begin\n            case (state)\n                10'b0000000000: next_state = 10'b0000000000; // IDLE\n                10'b0000000001: next_state = 10'b0000000001; // DIVIDE\n                default: next_state = 10'b0000000000;\n            endcase\n\n            case (state)\n                10'b0000000000: sd_clk_count <= 8'b00000000; // IDLE\n                10'b0000000001: sd_clk_count <= 8'b00000000; // DIVIDE\n                default: sd_clk_count <= 8'b00000000;\n            endcase\n\n            case (state)\n                10'b0000000000: SD_CLK <= 1'b0; // IDLE\n                10'b0000000001: SD_CLK <= 1'b0; // DIVIDE\n                default: SD_CLK <= 1'b0;\n            endcase\n        end\n    end\n\n    // FSM state machine logic\n    always @(*) begin\n        case (state)\n            10'b0000000000: if (divider == 8'b00000000) next_state = 10'b0000000001; else next_state = 10'b0000000000; // IDLE\n            10'b0000000001: if (sd_clk_count == 8'b11111111) next_state = 10'b0000000000; else next_state = 10'b0000000001; // DIVIDE\n            default: next_state = 10'b0000000000;\n        endcase\n\n        case (state)\n            10'b0000000000: if (divider == 8'b00000000) sd_clk_count <= 8'b00000000; else sd_clk_count <= 8'b00000000; // IDLE\n            10'b0000000001: if (sd_clk_count == 8'b11111111) sd_clk_count <= 8'b00000000; else sd_clk_count <= 8'b00000000; // DIVIDE\n            default: sd_clk_count <= 8'b00000000;\n        endcase\n\n        case (state)\n            10'b0000000000: if (divider == 8'b00000000) SD_CLK <= 1'b0; else SD_CLK <= 1'b0; // IDLE\n            10'b0000000001: if (sd_clk_count == 8'b11111111) SD_CLK <= 1'b0; else SD_CLK <= 1'b0; // DIVIDE\n            default: SD_CLK <= 1'b0;\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 3, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n        begin\n            dcnt <= 11;\n            ld_r <= 0;\n        end\n        else\n        begin\n            if (ld)\n            begin\n                text_in_r <= text_in;\n                ld_r <= 1;\n                dcnt <= 11;\n            end\n            else\n            begin\n                if (dcnt > 0)\n                begin\n                    dcnt <= dcnt - 1;\n                end\n                else\n                begin\n                    done <= 1;\n                    text_out <= text_out_r;\n                end\n            end\n        end\n    end\n\n    always @(posedge clk)\n    begin\n        if (ld_r)\n        begin\n            sa[0][0] <= text_in_r[7:0];\n            sa[0][1] <= text_in_r[15:8];\n            sa[0][2] <= text_in_r[23:16];\n            sa[0][3] <= text_in_r[31:24];\n            sa[1][0] <= text_in_r[39:32];\n            sa[1][1] <= text_in_r[47:40];\n            sa[1][2] <= text_in_r[55:48];\n            sa[1][3] <= text_in_r[63:56];\n            sa[2][0] <= text_in_r[71:64];\n            sa[2][1] <= text_in_r[79:72];\n            sa[2][2] <= text_in_r[87:80];\n            sa[2][3] <= text_in_r[95:88];\n            sa[3][0] <= text_in_r[103:96];\n            sa[3][1] <= text_in_r[111:104];\n            sa[3][2] <= text_in_r[119:112];\n            sa[3][3] <= text_in_r[127:120];\n            ld_r <= 0;\n        end\n        else\n        begin\n            if (dcnt == 10)\n            begin\n                text_out_r <= sa[0][0] ^ sa[1][0] ^ sa[2][0] ^ sa[3][0];\n                text_out_r[8:0] <= sa[0][1] ^ sa[1][1] ^ sa[2][1] ^ sa[3][1];\n                text_out_r[17:9] <= sa[0][2] ^ sa[1][2] ^ sa[2][2] ^ sa[3][2];\n                text_out_r[26:18] <= sa[0][3] ^ sa[1][3] ^ sa[2][3] ^ sa[3][3];\n            end\n            else\n            begin\n                sa[0][0] <= sub_bytes(sa[0][0]);\n                sa[0][1] <= sub_bytes(sa[0][1]);\n                sa[0][2] <= sub_bytes(sa[0][2]);\n                sa[0][3] <= sub_bytes(sa[0][3]);\n                sa[1][0] <= sub_bytes(sa[1][0]);\n                sa[1][1] <= sub_bytes(sa[1][1]);\n                sa[1][2] <= sub_bytes(sa[1][2]);\n                sa[1][3] <= sub_bytes(sa[1][3]);\n                sa[2][0] <= sub_bytes(sa[2][0]);\n                sa[2][1] <= sub_bytes(sa[2][1]);\n                sa[2][2] <= sub_bytes(sa[2][2]);\n                sa[2][3] <= sub_bytes(sa[2][3]);\n                sa[3][0] <= sub_bytes(sa[3][0]);\n                sa[3][1] <= sub_bytes(sa[3][1]);\n                sa[3][2] <= sub_bytes(sa[3][2]);\n                sa[3][3] <= sub_bytes(sa[3][3]);\n                shift_rows(sa);\n                mix_columns(sa);\n                add_round_key(sa, key);\n                dcnt <= dcnt - 1;\n            end\n        end\n    end\n\n    assign text_out = text_out_r;\n\nendmodule\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_r;\n    reg [3:0] rcnt;\n    reg [31:0] wo_0_r;\n    reg [31:0] wo_1_r;\n    reg [31:0] wo_2_r;\n    reg [31:0] wo_3_r;\n\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            key_r <= key;\n            wo_0_r <= 0;\n            wo_1_r <= 0;\n            wo_2_r <= 0;\n            wo_3_r <= 0;\n        end\n        else\n        begin\n            if (rcnt == 0)\n            begin\n                wo_0_r <= key_r[31:0];\n                wo_1_r <= key_r[63:32];\n                wo_2_r <= key_r[95:64];\n                wo_3_r <= key_r[127:96];\n                rcnt <= 1;\n            end\n            else\n            begin\n                wo_0_r <= wo_0_r ^ rot_word(wo_0_r);\n                wo_1_r <= wo_1_r ^ rot_word(wo_1_r);\n                wo_2_r <= wo_2_r ^ rot_word(wo_2_r);\n                wo_3_r <= wo_3_r ^ rot_word(wo_3_r);\n                wo_0_r <= wo_0_r ^ sub_word(rot_word(wo_0_r));\n                wo_1_r <= wo_1_r ^ sub_word(rot_word(wo_1_r));\n                wo_2_r <= wo_2_r ^ sub_word(rot_word(wo_2_r));\n                wo_3_r <= wo_3_r ^ sub_word(rot_word(wo_3_r));\n                wo_0_r <= wo_0_r ^ rcon(rcnt);\n                wo_1_r <= wo_1_r ^ rcon(rcnt);\n                wo_2_r <= wo_2_r ^ rcon(rcnt);\n                wo_3_r <= wo_3_r ^ rcon(rcnt);\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\n    assign wo_0 = wo_0_r;\n    assign wo_1 = wo_1_r;\n    assign wo_2 = wo_2_r;\n    assign wo_3 = wo_3_r;\n\nendmodule\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[255:0];\n\n    initial\n    begin\n        for (int i = 0; i < 256; i++)\n        begin\n            sbox[i] = i;\n        end\n    end\n\n    always_comb\n    begin\n        b = sbox[a];\n    end\n\nendmodule\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n    reg [31:0] out_r;\n\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            rcnt <= 0;\n            out_r <= 32'h01_00_00_00;\n        end\n        else\n        begin\n            if (rcnt == 9)\n            begin\n                out_r <= 32'h36_00_00_00;\n                rcnt <= 10;\n            end\n            else\n            begin\n                out_r <= out_r ^ (out_r << 1);\n                out_r <= out_r ^ (out_r << 2);\n                out_r <= out_r ^ (out_r << 3);\n                out_r <= out_r ^ (out_r << 4);\n                out_r <= out_r ^ (out_r << 5);\n                out_r <= out_r ^ (out_r << 6);\n                out_r <= out_r ^ (out_r << 7);\n                out_r <= out_r ^ (out_r << 8);\n                out_r <= out_r ^ (out_r << 9);\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\n    assign out = out_r;\n\nendmodule\nmodule sub_bytes(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[255:0];\n\n    initial\n    begin\n        for (int i = 0; i < 256; i++)\n        begin\n            sbox[i] = i;\n        end\n    end\n\n    always_comb\n    begin\n        b = sbox[a];\n    end\n\nendmodule\nmodule rot_word(\n    input [31:0] a,\n    output [31:0] b\n);\n\n    reg [31:0] b_r;\n\n    always_comb\n    begin\n        b_r = a[24:17] | a[20:13] | a[16:9] | a[8:1];\n        b = b_r;\n    end\n\nendmodule\nmodule sub_word(\n    input [31:0] a,\n    output [31:0] b\n);\n\n    reg [7:0] sbox[255:0];\n\n    initial\n    begin\n        for (int i = 0; i < 256; i++)\n        begin\n            sbox[i] = i;\n        end\n    end\n\n    always_comb\n    begin\n        b = sbox[a[7:0]] | sbox[a[15:8]] | sbox[a[23:16]] | sbox[a[31:24]];\n    end\n\nendmodule\nmodule rcon(\n    input [3:0] i,\n    output [31:0] o\n);\n\n    reg [31:0] rcon[10:0];\n\n    initial\n    begin\n        rcon[0] = 32'h01_00_00_00;\n        rcon[1] = 32'h02_00_00_00;\n        rcon[2] = 32'h04_00_00_00;\n        rcon[3] = 32'h08_00_00_00;\n        rcon[4] = 32'h10_00_00_00;\n        rcon[5] = 32'h20_00_00_00;\n        rcon[6] = 32'h40_00_00_00;\n        rcon[7] = 32'h80_00_00_00;\n        rcon[8] = 32'h1b_00_00_00;\n        rcon[9] = 32'h36_00_00_00;\n    end\n\n    always_comb\n    begin\n        o = rcon[i];\n    end\n\nendmodule\nmodule shift_rows(\n    input [7:0] sa[0:3][0:3],\n    output [7:0] sb[0:3][0:3]\n);\n\n    reg [7:0] sb_r[0:3][0:3];\n\n    always_comb\n    begin\n        sb_r[0][0] = sa[0][0];\n        sb_r[0][1] = sa[0][1];\n        sb_r[0][2] = sa[0][2];\n        sb_r[0][3] = sa[0][3];\n        sb_r[1][0] = sa[1][1];\n        sb_r[1][1] = sa[1][2];\n        sb_r[1][2] = sa[1][3];\n        sb_r[1][3] = sa[1][0];\n        sb_r[2][0] = sa[2][2];\n        sb_r[2][1] = sa[2][3];\n        sb_r[2][2] = sa[2][0];\n        sb_r[2][3] = sa[2][1];\n        sb_r[3][0] = sa[3][3];\n        sb_r[3][1] = sa[3][0];\n        sb_r[3][2] = sa[3][1];\n        sb_r[3][3] = sa[3][2];\n        sb = sb_r;\n    end\n\nendmodule\nmodule mix_columns(\n    input [7:0] sa[0:3][0:3],\n    output [7:0] sb[0:3][0:3]\n);\n\n    reg [7:0] sb_r[0:3][0:3];\n\n    always_comb\n    begin\n        sb_r[0][0] = (sa[0][0] << 1) ^ (sa[0][1] << 1) ^ (sa[0][2] << 1) ^ (sa[0][3] << 1);\n        sb_r[0][1] = (sa[0][0] << 2) ^ (sa[0][1] << 2) ^ (sa[0][2] << 2) ^ (sa[0][3] << 2);\n        sb_r[0][2] = (sa[0][0] << 3) ^ (sa[0][1] << 3) ^ (sa[0][2] << 3) ^ (sa[0][3] << 3);\n        sb_r[0][3] = (sa[0][0] << 4) ^ (sa[0][1] << 4) ^ (sa[0][2] << 4) ^ (sa[0][3] << 4);\n        sb_r[1][0] = (sa[1][0] << 1) ^ (sa[1][1] << 1) ^ (sa[1][2] << 1) ^ (sa[1][3] << 1);\n        sb_r[1][1] = (sa[1][0] << 2) ^ (sa[1][1] << 2) ^ (sa[1][2] << 2) ^ (sa[1][3] << 2);\n        sb_r[1][2] = (sa[1][0] << 3) ^ (sa[1][1] << 3) ^ (sa[1][2] << 3) ^ (sa[1][3] << 3);\n        sb_r[1][3] = (sa[1][0] << 4) ^ (sa[1][1] << 4) ^ (sa[1][2] << 4) ^ (sa[1][3] << 4);\n        sb_r[2][0] = (sa[2][0] << 1) ^ (sa[2][1] << 1) ^ (sa[2][2] << 1) ^ (sa[2][3] << 1);\n        sb_r[2][1] = (sa[2][0] << 2) ^ (sa[2][1] << 2) ^ (sa[2][2] << 2) ^ (sa[2][3] << 2);\n        sb_r[2][2] = (sa[2][0] << 3) ^ (sa[2][1] << 3) ^ (sa[2][2] << 3) ^ (sa[2][3] << 3);\n        sb_r[2][3] = (sa[2][0] << 4) ^ (sa[2][1] << 4) ^ (sa[2][2] << 4) ^ (sa[2][3] << 4);\n        sb_r[3][0] = (sa[3][0] << 1) ^ (sa[3][1] << 1) ^ (sa[3][2] << 1) ^ (sa[3][3] << 1);\n        sb_r[3][1] = (sa[3][0] << 2) ^ (sa[3][1] << 2) ^ (sa[3][2] << 2) ^ (sa[3][3] << 2);\n        sb_r[3][2] = (sa[3][0] << 3) ^ (sa[3][1] << 3) ^ (sa[3][2] << 3) ^ (sa[3][3] << 3);\n        sb_r[3][3] = (sa[3][0] << 4) ^ (sa[3][1] << 4) ^ (sa[3][2] << 4) ^ (sa[3][3] << 4);\n        sb = sb_r;\n    end\n\nendmodule\nmodule add_round_key(\n    input [7:0] sa[0:3][0:3],\n    input [127:0] key,\n    output [7:0] sb[0:3][0:3]\n);\n\n    reg [7:0] sb_r[0:3][0:3];\n\n    always_comb\n    begin\n        sb_r[0][0] = sa[0][0] ^ key[7:0];\n        sb_r[0][1] = sa[0][1] ^ key[15:8];\n        sb_r[0][2] = sa[0][2] ^ key[23:16];\n        sb_r[0][3] = sa[0][3] ^ key[31:24];\n        sb_r[1][0] = sa[1][0] ^ key[39:32];\n        sb_r[1][1] = sa[1][1] ^ key[47:40];\n        sb_r[1][2] = sa[1][2] ^ key[55:48];\n        sb_r[1][3] = sa[1][3] ^ key[63:56];\n        sb_r[2][0] = sa[2][0] ^ key[71:64];\n        sb_r[2][1] = sa[2][1] ^ key[79:72];\n        sb_r[2][2] = sa[2][2] ^ key[87:80];\n        sb_r[2][3] = sa[2][3] ^ key[95:88];\n        sb_r[3][0] = sa[3][0] ^ key[103:96];\n        sb_r[3][1] = sa[3][1] ^ key[111:104];\n        sb_r[3][2] = sa[3][2] ^ key[119:112];\n        sb_r[3][3] = sa[3][3] ^ key[127:120];\n        sb = sb_r;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 4, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // SubBytes transformation\n    assign sa[0][0] = aes_sbox(sa[0][0]);\n    assign sa[0][1] = aes_sbox(sa[0][1]);\n    assign sa[0][2] = aes_sbox(sa[0][2]);\n    assign sa[0][3] = aes_sbox(sa[0][3]);\n    assign sa[1][0] = aes_sbox(sa[1][0]);\n    assign sa[1][1] = aes_sbox(sa[1][1]);\n    assign sa[1][2] = aes_sbox(sa[1][2]);\n    assign sa[1][3] = aes_sbox(sa[1][3]);\n    assign sa[2][0] = aes_sbox(sa[2][0]);\n    assign sa[2][1] = aes_sbox(sa[2][1]);\n    assign sa[2][2] = aes_sbox(sa[2][2]);\n    assign sa[2][3] = aes_sbox(sa[2][3]);\n    assign sa[3][0] = aes_sbox(sa[3][0]);\n    assign sa[3][1] = aes_sbox(sa[3][1]);\n    assign sa[3][2] = aes_sbox(sa[3][2]);\n    assign sa[3][3] = aes_sbox(sa[3][3]);\n\n    // ShiftRows transformation\n    assign sa[1][0] = sa[1][0] << 1;\n    assign sa[1][1] = sa[1][1] << 2;\n    assign sa[1][2] = sa[1][2] << 3;\n    assign sa[1][3] = sa[1][3] << 0;\n    assign sa[2][0] = sa[2][0] << 2;\n    assign sa[2][1] = sa[2][1] << 3;\n    assign sa[2][2] = sa[2][2] << 0;\n    assign sa[2][3] = sa[2][3] << 1;\n    assign sa[3][0] = sa[3][0] << 3;\n    assign sa[3][1] = sa[3][1] << 0;\n    assign sa[3][2] = sa[3][2] << 1;\n    assign sa[3][3] = sa[3][3] << 2;\n\n    // MixColumns transformation\n    assign sa[0][0] = (sa[0][0] << 1) ^ (sa[0][1] << 1) ^ (sa[0][2] << 1) ^ (sa[0][3] << 1);\n    assign sa[0][1] = (sa[0][0] << 2) ^ (sa[0][1] << 2) ^ (sa[0][2] << 2) ^ (sa[0][3] << 2);\n    assign sa[0][2] = (sa[0][0] << 3) ^ (sa[0][1] << 3) ^ (sa[0][2] << 3) ^ (sa[0][3] << 3);\n    assign sa[0][3] = (sa[0][0] << 1) ^ (sa[0][1] << 2) ^ (sa[0][2] << 3) ^ (sa[0][3] << 0);\n    assign sa[1][0] = (sa[1][0] << 1) ^ (sa[1][1] << 1) ^ (sa[1][2] << 1) ^ (sa[1][3] << 1);\n    assign sa[1][1] = (sa[1][0] << 2) ^ (sa[1][1] << 2) ^ (sa[1][2] << 2) ^ (sa[1][3] << 2);\n    assign sa[1][2] = (sa[1][0] << 3) ^ (sa[1][1] << 3) ^ (sa[1][2] << 3) ^ (sa[1][3] << 3);\n    assign sa[1][3] = (sa[1][0] << 1) ^ (sa[1][1] << 2) ^ (sa[1][2] << 3) ^ (sa[1][3] << 0);\n    assign sa[2][0] = (sa[2][0] << 1) ^ (sa[2][1] << 1) ^ (sa[2][2] << 1) ^ (sa[2][3] << 1);\n    assign sa[2][1] = (sa[2][0] << 2) ^ (sa[2][1] << 2) ^ (sa[2][2] << 2) ^ (sa[2][3] << 2);\n    assign sa[2][2] = (sa[2][0] << 3) ^ (sa[2][1] << 3) ^ (sa[2][2] << 3) ^ (sa[2][3] << 3);\n    assign sa[2][3] = (sa[2][0] << 1) ^ (sa[2][1] << 2) ^ (sa[2][2] << 3) ^ (sa[2][3] << 0);\n    assign sa[3][0] = (sa[3][0] << 1) ^ (sa[3][1] << 1) ^ (sa[3][2] << 1) ^ (sa[3][3] << 1);\n    assign sa[3][1] = (sa[3][0] << 2) ^ (sa[3][1] << 2) ^ (sa[3][2] << 2) ^ (sa[3][3] << 2);\n    assign sa[3][2] = (sa[3][0] << 3) ^ (sa[3][1] << 3) ^ (sa[3][2] << 3) ^ (sa[3][3] << 3);\n    assign sa[3][3] = (sa[3][0] << 1) ^ (sa[3][1] << 2) ^ (sa[3][2] << 3) ^ (sa[3][3] << 0);\n\n    // AddRoundKey transformation\n    assign sa[0][0] = sa[0][0] ^ aes_key_expand_128.key[31:0];\n    assign sa[0][1] = sa[0][1] ^ aes_key_expand_128.key[63:32];\n    assign sa[0][2] = sa[0][2] ^ aes_key_expand_128.key[95:64];\n    assign sa[0][3] = sa[0][3] ^ aes_key_expand_128.key[127:96];\n    assign sa[1][0] = sa[1][0] ^ aes_key_expand_128.key[159:128];\n    assign sa[1][1] = sa[1][1] ^ aes_key_expand_128.key[191:160];\n    assign sa[1][2] = sa[1][2] ^ aes_key_expand_128.key[223:192];\n    assign sa[1][3] = sa[1][3] ^ aes_key_expand_128.key[255:224];\n    assign sa[2][0] = sa[2][0] ^ aes_key_expand_128.key[287:256];\n    assign sa[2][1] = sa[2][1] ^ aes_key_expand_128.key[319:288];\n    assign sa[2][2] = sa[2][2] ^ aes_key_expand_128.key[351:320];\n    assign sa[2][3] = sa[2][3] ^ aes_key_expand_128.key[383:352];\n    assign sa[3][0] = sa[3][0] ^ aes_key_expand_128.key[415:384];\n    assign sa[3][1] = sa[3][1] ^ aes_key_expand_128.key[447:416];\n    assign sa[3][2] = sa[3][2] ^ aes_key_expand_128.key[479:448];\n    assign sa[3][3] = sa[3][3] ^ aes_key_expand_128.key[511:480];\n\n    // Output ciphertext\n    assign text_out = {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                      sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                      sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                      sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n\n    // Control logic\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            ld_r <= 0;\n        end else if (ld) begin\n            ld_r <= 1;\n            dcnt <= 0;\n        end else if (dcnt == 10) begin\n            ld_r <= 0;\n            done <= 1;\n        end else begin\n            ld_r <= 0;\n            dcnt <= dcnt + 1;\n        end\n    end\n\n    // Load initial data\n    always @(posedge clk) begin\n        if (ld_r) begin\n            text_in_r <= text_in;\n        end\n    end\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expansion_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w[0:3];\n    reg [3:0] rcnt;\n\n    // Key expansion\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[31:0];\n            w[1] <= key[63:32];\n            w[2] <= key[95:64];\n            w[3] <= key[127:96];\n            wo_0 <= w[0];\n            wo_1 <= w[1];\n            wo_2 <= w[2];\n            wo_3 <= w[3];\n        end else begin\n            wo_0 <= w[0] ^ aes_rcon(rcnt) ^ aes_sbox(w[1][7:0]) ^ aes_sbox(w[1][15:8]);\n            wo_1 <= w[1] ^ aes_rcon(rcnt) ^ aes_sbox(w[2][7:0]) ^ aes_sbox(w[2][15:8]);\n            wo_2 <= w[2] ^ aes_rcon(rcnt) ^ aes_sbox(w[3][7:0]) ^ aes_sbox(w[3][15:8]);\n            wo_3 <= w[3] ^ aes_rcon(rcnt) ^ aes_sbox(w[0][7:0]) ^ aes_sbox(w[0][15:8]);\n            w[0] <= w[1];\n            w[1] <= w[2];\n            w[2] <= w[3];\n            w[3] <= wo_0;\n            rcnt <= rcnt + 1;\n        end\n    end\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    // Round constant generation\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else begin\n            out <= aes_rcon_table[rcnt];\n            rcnt <= rcnt + 1;\n        end\n    end\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table\n    reg [7:0] sbox_table[256];\n\n    // Initialize S-box table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox_table[i] = aes_sbox_table[i];\n        end\n    end\n\n    // S-box transformation\n    assign b = sbox_table[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 5, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // SubBytes transformation\n    reg [7:0] sbox[255:0];\n\n    // ShiftRows transformation\n    reg [7:0] shift_rows[0:3][0:3];\n\n    // MixColumns transformation\n    reg [7:0] mix_columns[0:3][0:3];\n\n    // AddRoundKey transformation\n    reg [7:0] round_key[0:3][0:3];\n\n    // Round counter\n    reg [3:0] round_counter;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            ld_r <= 0;\n        end\n        else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n            dcnt <= 11;\n        end\n        else if (dcnt > 0) begin\n            ld_r <= 0;\n            if (dcnt == 10) begin\n                // Final round\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ round_key[i][j];\n                    end\n                end\n            end\n            else begin\n                // Regular round\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sbox[sa[i][j]];\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= shift_rows[i][j];\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= mix_columns[i][j];\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ round_key[i][j];\n                    end\n                end\n            end\n            dcnt <= dcnt - 1;\n        end\n    end\n\n    // S-box implementation\n    always @(*) begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n            for (int j = 0; j < 8; j++) begin\n                sbox[i] = sbox[i] >> 1;\n                if (sbox[i][7]) begin\n                    sbox[i] = sbox[i] ^ 0x1b;\n                end\n            end\n        end\n    end\n\n    // ShiftRows implementation\n    always @(*) begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                shift_rows[i][j] = sa[i][j];\n            end\n        end\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                if (i == 0) begin\n                    shift_rows[i][j] = sa[i][j];\n                end\n                else if (i == 1) begin\n                    shift_rows[i][j] = sa[i][(j + 1) % 4];\n                end\n                else if (i == 2) begin\n                    shift_rows[i][j] = sa[i][(j + 2) % 4];\n                end\n                else if (i == 3) begin\n                    shift_rows[i][j] = sa[i][(j + 3) % 4];\n                end\n            end\n        end\n    end\n\n    // MixColumns implementation\n    always @(*) begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                mix_columns[i][j] = 0;\n            end\n        end\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                mix_columns[i][j] = sa[i][j];\n            end\n        end\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                mix_columns[i][j] = mix_columns[i][j] << 1;\n                if (mix_columns[i][j][7]) begin\n                    mix_columns[i][j] = mix_columns[i][j] ^ 0x1b;\n                end\n            end\n        end\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                mix_columns[i][j] = mix_columns[i][j] << 1;\n                if (mix_columns[i][j][7]) begin\n                    mix_columns[i][j] = mix_columns[i][j] ^ 0x1b;\n                end\n            end\n        end\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                mix_columns[i][j] = mix_columns[i][j] << 1;\n                if (mix_columns[i][j][7]) begin\n                    mix_columns[i][j] = mix_columns[i][j] ^ 0x1b;\n                end\n            end\n        end\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                mix_columns[i][j] = mix_columns[i][j] << 1;\n                if (mix_columns[i][j][7]) begin\n                    mix_columns[i][j] = mix_columns[i][j] ^ 0x1b;\n                end\n            end\n        end\n    end\n\n    // AddRoundKey implementation\n    always @(*) begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                round_key[i][j] = key[(i * 32 + j * 8 + 7): (i * 32 + j * 8)];\n            end\n        end\n    end\n\n    // Output generation\n    always @(posedge clk) begin\n        if (rst) begin\n            text_out <= 0;\n        end\n        else if (ld_r) begin\n            text_out <= text_in_r;\n        end\n        else if (dcnt == 10) begin\n            text_out <= text_out;\n        end\n        else begin\n            text_out <= text_out;\n        end\n    end\n\n    // Done signal generation\n    always @(posedge clk) begin\n        if (rst) begin\n            done <= 0;\n        end\n        else if (ld_r) begin\n            done <= 0;\n        end\n        else if (dcnt == 10) begin\n            done <= 1;\n        end\n        else begin\n            done <= 0;\n        end\n    end\n\nendmodule\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_expansion;\n    reg [31:0] wo_0_reg;\n    reg [31:0] wo_1_reg;\n    reg [31:0] wo_2_reg;\n    reg [31:0] wo_3_reg;\n    reg [3:0] rcnt;\n\n    // S-box implementation\n    reg [7:0] sbox[255:0];\n\n    // Round constant implementation\n    reg [7:0] rcon[10:0];\n\n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            key_expansion <= key;\n            wo_0_reg <= key[31:0];\n            wo_1_reg <= key[63:32];\n            wo_2_reg <= key[95:64];\n            wo_3_reg <= key[127:96];\n            rcnt <= 0;\n        end\n        else if (rcnt < 10) begin\n            wo_0_reg <= wo_0_reg ^ (sbox[wo_1_reg[7:0]] ^ rcon[rcnt]);\n            wo_1_reg <= wo_1_reg ^ (wo_0_reg[7:0] ^ sbox[wo_1_reg[7:0]] ^ rcon[rcnt]);\n            wo_2_reg <= wo_2_reg ^ (wo_0_reg[15:8] ^ sbox[wo_2_reg[7:0]] ^ rcon[rcnt]);\n            wo_3_reg <= wo_3_reg ^ (wo_0_reg[23:16] ^ sbox[wo_3_reg[7:0]] ^ rcon[rcnt]);\n            rcnt <= rcnt + 1;\n        end\n        else begin\n            wo_0_reg <= 0;\n            wo_1_reg <= 0;\n            wo_2_reg <= 0;\n            wo_3_reg <= 0;\n        end\n    end\n\n    // S-box implementation\n    always @(*) begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n            for (int j = 0; j < 8; j++) begin\n                sbox[i] = sbox[i] >> 1;\n                if (sbox[i][7]) begin\n                    sbox[i] = sbox[i] ^ 0x1b;\n                end\n            end\n        end\n    end\n\n    // Round constant implementation\n    always @(*) begin\n        for (int i = 0; i < 11; i++) begin\n            rcon[i] = 0;\n        end\n        rcon[0] = 1;\n        rcon[1] = 2;\n        rcon[2] = 4;\n        rcon[3] = 8;\n        rcon[4] = 10;\n        rcon[5] = 20;\n        rcon[6] = 40;\n        rcon[7] = 80;\n        rcon[8] = 1b;\n        rcon[9] = 36;\n    end\n\n    // Output generation\n    always @(posedge clk) begin\n        wo_0 <= wo_0_reg;\n        wo_1 <= wo_1_reg;\n        wo_2 <= wo_2_reg;\n        wo_3 <= wo_3_reg;\n    end\n\nendmodule\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[255:0];\n\n    // S-box implementation\n    always @(*) begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n            for (int j = 0; j < 8; j++) begin\n                sbox[i] = sbox[i] >> 1;\n                if (sbox[i][7]) begin\n                    sbox[i] = sbox[i] ^ 0x1b;\n                end\n            end\n        end\n    end\n\n    // Output generation\n    always @(*) begin\n        b = sbox[a];\n    end\n\nendmodule\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n    reg [7:0] rcon[10:0];\n\n    // Round constant implementation\n    always @(*) begin\n        for (int i = 0; i < 11; i++) begin\n            rcon[i] = 0;\n        end\n        rcon[0] = 1;\n        rcon[1] = 2;\n        rcon[2] = 4;\n        rcon[3] = 8;\n        rcon[4] = 10;\n        rcon[5] = 20;\n        rcon[6] = 40;\n        rcon[7] = 80;\n        rcon[8] = 1b;\n        rcon[9] = 36;\n    end\n\n    // Round counter\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end\n        else if (rcnt < 10) begin\n            out <= rcon[rcnt];\n            rcnt <= rcnt + 1;\n        end\n        else begin\n            out <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 6, "code": "```verilog\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n            text_out_r <= 0;\n        end else if (ld) begin\n            text_in_r <= text_in;\n            sa <= 0;\n            dcnt <= 0;\n            ld_r <= 1;\n        end else begin\n            if (dcnt == 0) begin\n                text_in_r <= text_in_r;\n                sa <= text_in_r[31:0];\n                dcnt <= 0;\n                ld_r <= 0;\n            end else if (dcnt == 1) begin\n                text_in_r <= text_in_r;\n                sa[0] <= sa[0] ^ key[31:24];\n                sa[1] <= sa[1] ^ key[23:16];\n                sa[2] <= sa[2] ^ key[15:8];\n                sa[3] <= sa[3] ^ key[7:0];\n                dcnt <= dcnt + 1;\n                ld_r <= 0;\n            end else if (dcnt == 2) begin\n                text_in_r <= text_in_r;\n                sa[0] <= sa[0] ^ sa[1];\n                sa[1] <= sa[1] ^ sa[2];\n                sa[2] <= sa[2] ^ sa[3];\n                sa[3] <= sa[3] ^ sa[0];\n                dcnt <= dcnt + 1;\n                ld_r <= 0;\n            end else if (dcnt == 3) begin\n                text_in_r <= text_in_r;\n                sa[0] <= sa[0] ^ sa[1] ^ sa[2] ^ sa[3];\n                sa[1] <= sa[1] ^ sa[2] ^ sa[3] ^ sa[0];\n                sa[2] <= sa[2] ^ sa[3] ^ sa[0] ^ sa[1];\n                sa[3] <= sa[3] ^ sa[0] ^ sa[1] ^ sa[2];\n                dcnt <= dcnt + 1;\n                ld_r <= 0;\n            end else if (dcnt == 4) begin\n                text_in_r <= text_in_r;\n                sa[0] <= sa[0] ^ sa[1] ^ sa[2] ^ sa[3];\n                sa[1] <= sa[1] ^ sa[2] ^ sa[3] ^ sa[0];\n                sa[2] <= sa[2] ^ sa[3] ^ sa[0] ^ sa[1];\n                sa[3] <= sa[3] ^ sa[0] ^ sa[1] ^ sa[2];\n                dcnt <= dcnt + 1;\n                ld_r <= 0;\n            end else if (dcnt == 5) begin\n                text_in_r <= text_in_r;\n                sa[0] <= sa[0] ^ sa[1] ^ sa[2] ^ sa[3];\n                sa[1] <= sa[1] ^ sa[2] ^ sa[3] ^ sa[0];\n                sa[2] <= sa[2] ^ sa[3] ^ sa[0] ^ sa[1];\n                sa[3] <= sa[3] ^ sa[0] ^ sa[1] ^ sa[2];\n                dcnt <= dcnt + 1;\n                ld_r <= 0;\n            end else if (dcnt == 6) begin\n                text_in_r <= text_in_r;\n                sa[0] <= sa[0] ^ sa[1] ^ sa[2] ^ sa[3];\n                sa[1] <= sa[1] ^ sa[2] ^ sa[3] ^ sa[0];\n                sa[2] <= sa[2] ^ sa[3] ^ sa[0] ^ sa[1];\n                sa[3] <= sa[3] ^ sa[0] ^ sa[1] ^ sa[2];\n                dcnt <= dcnt + 1;\n                ld_r <= 0;\n            end else if (dcnt == 7) begin\n               ", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 7, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n        begin\n            ld_r <= 0;\n            dcnt <= 0xB;\n            text_in_r <= 0;\n            text_out_r <= 0;\n        end\n        else\n        begin\n            if (ld)\n            begin\n                ld_r <= 1;\n                text_in_r <= text_in;\n                dcnt <= 0xB;\n            end\n            else\n            begin\n                if (dcnt > 0)\n                begin\n                    dcnt <= dcnt - 1;\n                end\n                else\n                begin\n                    done <= 1;\n                    text_out <= text_out_r;\n                end\n            end\n        end\n    end\n\n    always @(posedge clk)\n    begin\n        if (ld_r)\n        begin\n            // SubBytes\n            for (int i = 0; i < 4; i++)\n            begin\n                for (int j = 0; j < 4; j++)\n                begin\n                    sa[i][j] <= aes_sbox(sa[i][j]);\n                end\n            end\n\n            // ShiftRows\n            for (int i = 0; i < 4; i++)\n            begin\n                for (int j = 0; j < 4; j++)\n                begin\n                    case (i)\n                        0: sa[i][j] <= sa[i][j];\n                        1: sa[i][j] <= sa[i][j + 1];\n                        2: sa[i][j] <= sa[i][j + 2];\n                        3: sa[i][j] <= sa[i][j + 3];\n                        default: sa[i][j] <= 0;\n                    endcase\n                end\n            end\n\n            // MixColumns\n            for (int i = 0; i < 4; i++)\n            begin\n                for (int j = 0; j < 4; j++)\n                begin\n                    sa[i][j] <= sa[i][j] ^ (sa[i][j + 1] << 1) ^ (sa[i][j + 2] << 2) ^ (sa[i][j + 3] << 3);\n                end\n            end\n\n            // AddRoundKey\n            for (int i = 0; i < 4; i++)\n            begin\n                for (int j = 0; j < 4; j++)\n                begin\n                    sa[i][j] <= sa[i][j] ^ aes_key_expand_128.sa[i][j];\n                end\n            end\n\n            ld_r <= 0;\n        end\n    end\n\n    always @(posedge clk)\n    begin\n        if (ld_r)\n        begin\n            // SubBytes\n            for (int i = 0; i < 4; i++)\n            begin\n                for (int j = 0; j < 4; j++)\n                begin\n                    sa[i][j] <= aes_sbox(sa[i][j]);\n                end\n            end\n\n            // ShiftRows\n            for (int i = 0; i < 4; i++)\n            begin\n                for (int j = 0; j < 4; j++)\n                begin\n                    case (i)\n                        0: sa[i][j] <= sa[i][j];\n                        1: sa[i][j] <= sa[i][j + 1];\n                        2: sa[i][j] <= sa[i][j + 2];\n                        3: sa[i][j] <= sa[i][j + 3];\n                        default: sa[i][j] <= 0;\n                    endcase\n                end\n            end\n\n            // MixColumns\n            for (int i = 0; i < 4; i++)\n            begin\n                for (int j = 0; j < 4; j++)\n                begin\n                    sa[i][j] <= sa[i][j] ^ (sa[i][j + 1] << 1) ^ (sa[i][j + 2] << 2) ^ (sa[i][j + 3] << 3);\n                end\n            end\n\n            // AddRoundKey\n            for (int i = 0; i < 4; i++)\n            begin\n                for (int j = 0; j < 4; j++)\n                begin\n                    sa[i][j] <= sa[i][j] ^ aes_key_expand_128.sa[i][j];\n                end\n            end\n\n            ld_r <= 0;\n        end\n    end\n\n    assign text_out_r = {sa[0][0], sa[0][1], sa[0][2], sa[0][3], sa[1][0], sa[1][1], sa[1][2], sa[1][3], sa[2][0], sa[2][1], sa[2][2], sa[2][3], sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n\nendmodule\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w[15:0];\n    reg [3:0] rcnt;\n    reg [7:0] rcon;\n\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            w[0] <= key[31:0];\n            w[1] <= key[63:32];\n            w[2] <= key[95:64];\n            w[3] <= key[127:96];\n            rcnt <= 0;\n            rcon <= 1;\n        end\n        else\n        begin\n            if (rcnt < 10)\n            begin\n                rcon <= rcon << 1;\n                if (rcon > 8\\'h80)\n                begin\n                    rcon <= rcon ^ 8\\'h11b;\n                end\n                wo_0 <= w[rcnt] ^ aes_rcon(rcon);\n                wo_1 <= w[rcnt + 1] ^ aes_rcon(rcon);\n                wo_2 <= w[rcnt + 2] ^ aes_rcon(rcon);\n                wo_3 <= w[rcnt + 3] ^ aes_rcon(rcon);\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\nendmodule\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            rcnt <= 0;\n            out <= 32\\'h01_00_00_00;\n        end\n        else\n        begin\n            if (rcnt < 10)\n            begin\n                out <= rcnt < 9? (rcnt < 8? (rcnt < 7? (rcnt < 6? (rcnt < 5? (rcnt < 4? (rcnt < 3? (rcnt < 2? (rcnt < 1? (rcnt < 0? 32\\'h01_00_00_00 : 32\\'h02_00_00_00) : 32\\'h04_00_00_00) : 32\\'h08_00_00_00) : 32\\'h10_00_00_00) : 32\\'h20_00_00_00) : 32\\'h40_00_00_00) : 32\\'h80_00_00_00) : 32\\'h1b_00_00_00) : 32\\'h36_00_00_00);\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\nendmodule\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[256:0];\n\n    initial\n    begin\n        for (int i = 0; i < 256; i++)\n        begin\n            sbox[i] = aes_sbox_lookup(i);\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\nmodule aes_sbox_lookup(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[256:0];\n\n    initial\n    begin\n        for (int i = 0; i < 256; i++)\n        begin\n            sbox[i] = aes_sbox_lookup_table[i];\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\nmodule aes_sbox_lookup_table(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[256:0];\n\n    initial\n    begin\n        sbox[0] = 63;\n        sbox[1] = 0;\n        sbox[2] = 0;\n        sbox[3] = 0;\n        sbox[4] = 0;\n        sbox[5] = 0;\n        sbox[6] = 0;\n        sbox[7] = 0;\n        sbox[8] = 0;\n        sbox[9] = 0;\n        sbox[10] = 0;\n        sbox[11] = 0;\n        sbox[12] = 0;\n        sbox[13] = 0;\n        sbox[14] = 0;\n        sbox[15] = 0;\n        sbox[16] = 0;\n        sbox[17] = 0;\n        sbox[18] = 0;\n        sbox[19] = 0;\n        sbox[20] = 0;\n        sbox[21] = 0;\n        sbox[22] = 0;\n        sbox[23] = 0;\n        sbox[24] = 0;\n        sbox[25] = 0;\n        sbox[26] = 0;\n        sbox[27] = 0;\n        sbox[28] = 0;\n        sbox[29] = 0;\n        sbox[30] = 0;\n        sbox[31] = 0;\n        sbox[32] = 0;\n        sbox[33] = 0;\n        sbox[34] = 0;\n        sbox[35] = 0;\n        sbox[36] = 0;\n        sbox[37] = 0;\n        sbox[38] = 0;\n        sbox[39] = 0;\n        sbox[40] = 0;\n        sbox[41] = 0;\n        sbox[42] = 0;\n        sbox[43] = 0;\n        sbox[44] = 0;\n        sbox[45] = 0;\n        sbox[46] = 0;\n        sbox[47] = 0;\n        sbox[48] = 0;\n        sbox[49] = 0;\n        sbox[50] = 0;\n        sbox[51] = 0;\n        sbox[52] = 0;\n        sbox[53] = 0;\n        sbox[54] = 0;\n        sbox[55] = 0;\n        sbox[56] = 0;\n        sbox[57] = 0;\n        sbox[58] = 0;\n        sbox[59] = 0;\n        sbox[60] = 0;\n        sbox[61] = 0;\n        sbox[62] = 0;\n        sbox[63] = 0;\n        sbox[64] = 0;\n        sbox[65] = 0;\n        sbox[66] = 0;\n        sbox[67] = 0;\n        sbox[68] = 0;\n        sbox[69] = 0;\n        sbox[70] = 0;\n        sbox[71] = 0;\n        sbox[72] = 0;\n        sbox[73] = 0;\n        sbox[74] = 0;\n        sbox[75] = 0;\n        sbox[76] = 0;\n        sbox[77] = 0;\n        sbox[78] = 0;\n        sbox[79] = 0;\n        sbox[80] = 0;\n        sbox[81] = 0;\n        sbox[82] = 0;\n        sbox[83] = 0;\n        sbox[84] = 0;\n        sbox[85] = 0;\n        sbox[86] = 0;\n        sbox[87] = 0;\n        sbox[88] = 0;\n        sbox[89] = 0;\n        sbox[90] = 0;\n        sbox[91] = 0;\n        sbox[92] = 0;\n        sbox[93] = 0;\n        sbox[94] = 0;\n        sbox[95] = 0;\n        sbox[96] = 0;\n        sbox[97] = 0;\n        sbox[98] = 0;\n        sbox[99] = 0;\n        sbox[100] = 0;\n        sbox[101] = 0;\n        sbox[102] = 0;\n        sbox[103] = 0;\n        sbox[104] = 0;\n        sbox[105] = 0;\n        sbox[106] = 0;\n        sbox[107] = 0;\n        sbox[108] = 0;\n        sbox[109] = 0;\n        sbox[110] = 0;\n        sbox[111] = 0;\n        sbox[112] = 0;\n        sbox[113] = 0;\n        sbox[114] = 0;\n        sbox[115] = 0;\n        sbox[116] = 0;\n        sbox[117] = 0;\n        sbox[118] = 0;\n        sbox[119] = 0;\n        sbox[120] = 0;\n        sbox[121] = 0;\n        sbox[122] = 0;\n        sbox[123] = 0;\n        sbox[124] = 0;\n        sbox[125] = 0;\n        sbox[126] = 0;\n        sbox[127] = 0;\n        sbox[128] = 0;\n        sbox[129] = 0;\n        sbox[130] = 0;\n        sbox[131] = 0;\n        sbox[132] = 0;\n        sbox[133] = 0;\n        sbox[134] = 0;\n        sbox[135] = 0;\n        sbox[136] = 0;\n        sbox[137] = 0;\n        sbox[138] = 0;\n        sbox[139] = 0;\n        sbox[140] = 0;\n        sbox[141] = 0;\n        sbox[142] = 0;\n        sbox[143] = 0;\n        sbox[144] = 0;\n        sbox[145] = 0;\n        sbox[146] = 0;\n        sbox[147] = 0;\n        sbox[148] = 0;\n        sbox[149] = 0;\n        sbox[150] = 0;\n        sbox[151] = 0;\n        sbox[152] = 0;\n        sbox[153] = 0;\n        sbox[154] = 0;\n        sbox[155] = 0;\n        sbox[156] = 0;\n        sbox[157] = 0;\n        sbox[158] = 0;\n        sbox[159] = 0;\n        sbox[160] = 0;\n        sbox[161] = 0;\n        sbox[162] = 0;\n        sbox[163] = 0;\n        sbox[164] = 0;\n        sbox[165] = 0;\n        sbox[166] = 0;\n        sbox[167] = 0;\n        sbox[168] = 0;\n        sbox[169] = 0;\n        sbox[170] = 0;\n        sbox[171] = 0;\n        sbox[172] = 0;\n        sbox[173] = 0;\n        sbox[174] = 0;\n        sbox[175] = 0;\n        sbox[176] = 0;\n        sbox[177] = 0;\n        sbox[178] = 0;\n        sbox[179] = 0;\n        sbox[180] = 0;\n        sbox[181] = 0;\n        sbox[182] = 0;\n        sbox[183] = 0;\n        sbox[184] = 0;\n        sbox[185] = 0;\n        sbox[186] = 0;\n        sbox[187] = 0;\n        sbox[188] = 0;\n        sbox[189] = 0;\n        sbox[190] = 0;\n        sbox[191] = 0;\n        sbox[192] = 0;\n        sbox[193] = 0;\n        sbox[194] = 0;\n        sbox[195] = 0;\n        sbox[196] = 0;\n        sbox[197] = 0;\n        sbox[198] = 0;\n        sbox[199] = 0;\n        sbox[200] = 0;\n        sbox[201] = 0;\n        sbox[202] = 0;\n        sbox[203] = 0;\n        sbox[204] = 0;\n        sbox[205] = 0;\n        sbox[206] = 0;\n        sbox[207] = 0;\n        sbox[208] = 0;\n        sbox[209] = 0;\n        sbox[210] = 0;\n        sbox[211] = 0;\n        sbox[212] = 0;\n        sbox[213] = 0;\n        sbox[214] = 0;\n        sbox[215] = 0;\n        sbox[216] = 0;\n        sbox[217] = 0;\n        sbox[218] = 0;\n        sbox[219] = 0;\n        sbox[220] = 0;\n        sbox[221] = 0;\n        sbox[222] = 0;\n        sbox[223] = 0;\n        sbox[224] = 0;\n        sbox[225] = 0;\n        sbox[226] = 0;\n        sbox[227] = 0;\n        sbox[228] = 0;\n        sbox[229] = 0;\n        sbox[230] = 0;\n        sbox[231] = 0;\n        sbox[232] = 0;\n        sbox[233] = 0;\n        sbox[234] = 0;\n        sbox[235] = 0;\n        sbox[236] = 0;\n        sbox[237] = 0;\n        sbox[238] = 0;\n        sbox[239] = 0;\n        sbox[240] = 0;\n        sbox[241] = 0;\n        sbox[242] = 0;\n        sbox[243] = 0;\n        sbox[244] = 0;\n        sbox[245] = 0;\n        sbox[246] = 0;\n        sbox[247] = 0;\n        sbox[248] = 0;\n        sbox[249] = 0;\n        sbox[250] = 0;\n        sbox[251] = 0;\n        sbox[252] = 0;\n        sbox[253] = 0;\n        sbox[254] = 0;\n        sbox[255] = 0;\n    end\n\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 8, "code": "// aes_cipher_top.v\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n        begin\n            text_in_r <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n        end\n        else\n        begin\n            if (ld)\n            begin\n                text_in_r <= text_in;\n                dcnt <= 11;\n                ld_r <= 1;\n            end\n            else\n            begin\n                if (dcnt > 0)\n                begin\n                    dcnt <= dcnt - 1;\n                    ld_r <= 0;\n                end\n            end\n        end\n    end\n\n    always @(posedge clk)\n    begin\n        if (rst)\n        begin\n            text_out <= 0;\n        end\n        else\n        begin\n            if (ld_r)\n            begin\n                text_out <= text_in_r;\n            end\n            else\n            begin\n                if (dcnt == 0)\n                begin\n                    // SubBytes\n                    for (int i = 0; i < 4; i++)\n                    begin\n                        for (int j = 0; j < 4; j++)\n                        begin\n                            sa[i][j] <= aes_sbox(text_in_r[8*i + j]);\n                        end\n                    end\n                    // ShiftRows\n                    for (int i = 1; i < 4; i++)\n                    begin\n                        for (int j = 0; j < 4; j++)\n                        begin\n                            sa[i][j] <= sa[i][(j + i) % 4];\n                        end\n                    end\n                    // MixColumns\n                    for (int i = 0; i < 4; i++)\n                    begin\n                        for (int j = 0; j < 4; j++)\n                        begin\n                            sa[i][j] <= (sa[i][j] << 1) ^ (sa[i][j] >> 7) ^ (sa[(i + 1) % 4][j] << 2) ^ (sa[(i + 3) % 4][j] << 3) ^ (sa[(i + 2) % 4][j] << 1);\n                        end\n                    end\n                    // AddRoundKey\n                    for (int i = 0; i < 4; i++)\n                    begin\n                        for (int j = 0; j < 4; j++)\n                        begin\n                            sa[i][j] <= sa[i][j] ^ aes_key_expand_128.key_expansion[8*i + j];\n                        end\n                    end\n                    ld_r <= 1;\n                end\n                else if (dcnt == 10)\n                begin\n                    // FinalRound\n                    for (int i = 0; i < 4; i++)\n                    begin\n                        for (int j = 0; j < 4; j++)\n                        begin\n                            sa[i][j] <= sa[i][j] ^ aes_key_expand_128.key_expansion[8*i + j];\n                        end\n                    end\n                    ld_r <= 1;\n                end\n            end\n        end\n    end\n\n    always @(posedge clk)\n    begin\n        if (rst)\n        begin\n            done <= 0;\n        end\n        else\n        begin\n            if (ld_r)\n            begin\n                done <= 0;\n            end\n            else\n            begin\n                if (dcnt == 10)\n                begin\n                    done <= 1;\n                end\n            end\n        end\n    end\n\n    assign text_out = text_in_r;\n\nendmodule\n\n// aes_key_expand_128.v\nmodule aes_key_expansion(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_expansion;\n    reg [3:0] rcnt;\n    reg [7:0] sbox_out[0:15];\n\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            key_expansion <= key;\n            rcnt <= 0;\n        end\n        else\n        begin\n            if (rcnt == 0)\n            begin\n                key_expansion <= {key_expansion[31:24], key[23:16], key[15:8], key[7:0]};\n                rcnt <= 1;\n            end\n            else\n            begin\n                for (int i = 0; i < 4; i++)\n                begin\n                    sbox_out[i] <= aes_sbox(key_expansion[8*i + 3]);\n                end\n                key_expansion <= {key_expansion[31:24], key_expansion[23:16], key_expansion[15:8], key_expansion[7:0]} ^ {sbox_out[0], sbox_out[1], sbox_out[2], sbox_out[3]};\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            wo_0 <= 0;\n            wo_1 <= 0;\n            wo_2 <= 0;\n            wo_3 <= 0;\n        end\n        else\n        begin\n            if (rcnt == 1)\n            begin\n                wo_0 <= key_expansion[31:24];\n                wo_1 <= key_expansion[23:16];\n                wo_2 <= key_expansion[15:8];\n                wo_3 <= key_expansion[7:0];\n            end\n            else\n            begin\n                wo_0 <= {wo_0[31:24], wo_0[23:16], wo_0[15:8], wo_0[7:0]} ^ {sbox_out[0], sbox_out[1], sbox_out[2], sbox_out[3]};\n                wo_1 <= {wo_1[31:24], wo_1[23:16], wo_1[15:8], wo_1[7:0]} ^ {sbox_out[4], sbox_out[5], sbox_out[6], sbox_out[7]};\n                wo_2 <= {wo_2[31:24], wo_2[23:16], wo_2[15:8], wo_2[7:0]} ^ {sbox_out[8], sbox_out[9], sbox_out[10], sbox_out[11]};\n                wo_3 <= {wo_3[31:24], wo_3[23:16], wo_3[15:8], wo_3[7:0]} ^ {sbox_out[12], sbox_out[13], sbox_out[14], sbox_out[15]};\n            end\n        end\n    end\n\nendmodule\n\n// aes_sbox.v\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[0:255];\n\n    initial\n    begin\n        for (int i = 0; i < 256; i++)\n        begin\n            sbox[i] = aes_sbox_lookup(i);\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\n// aes_sbox_lookup.v\nmodule aes_sbox_lookup(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[0:255];\n\n    initial\n    begin\n        for (int i = 0; i < 256; i++)\n        begin\n            sbox[i] = i;\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\n// aes_rcon.v\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n    reg [7:0] rcon;\n\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            rcnt <= 0;\n            rcon <= 0;\n        end\n        else\n        begin\n            if (rcnt == 0)\n            begin\n                rcon <= 1;\n                rcnt <= 1;\n            end\n            else\n            begin\n                rcon <= rcon << 1;\n                if (rcon[7])\n                begin\n                    rcon <= rcon ^ 0x11b;\n                end\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            out <= 0;\n        end\n        else\n        begin\n            out <= {rcon[7:0], 0, 0, 0};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 20, "code": "module sd_controller_wb(\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n    output wire        we_m_tx_bd,\n    output wire        we_m_rx_bd,\n    output wire        new_cmd,\n    output wire        we_ack,\n    output wire        int_ack,\n    output wire        cmd_int_busy,\n    output wire        int_busy,\n    input  wire        write_req_s,\n    input  wire [15:0] cmd_set_s,\n    input  wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input  wire [15:0] status_reg,\n    input  wire [31:0] cmd_resp_1,\n    output wire [7:0]  software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input  wire [15:0] normal_int_status_reg,\n    input  wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0]  clock_divider,\n    input  wire [15:0] Bd_Status_reg,\n    input  wire [7:0]  Bd_isr_reg,\n    output wire [7:0]  Bd_isr_enable_reg,\n    output wire        Bd_isr_reset,\n    output wire        normal_isr_reset,\n    output wire        error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_clock_divider(\n    input  wire        CLK,\n    input  wire [7:0]  DIVIDER,\n    input  wire        RST,\n    output wire        SD_CLK\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_cmd_master(\n    input  wire        CLK_PAD_IO,\n    input  wire        RST_PAD_I,\n    input  wire        New_CMD,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:8] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [4:0]  ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire        ERR_INT_RST,\n    input  wire        NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire        go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire        req_out,\n    output wire        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_cmd_serial_host(\n    input  wire        SD_CLK_IN,\n    input  wire        RST_IN,\n    input  wire        New_CMD,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:8] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [4:0]  ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire        ERR_INT_RST,\n    input  wire        NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire        go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire        req_out,\n    output wire        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_data_master(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input  wire [BD_WIDTH-1:0] free_tx_bd,\n    input  wire        ack_i_s_tx,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input  wire [BD_WIDTH-1:0] free_rx_bd,\n    input  wire        ack_i_s_rx,\n    input  wire        cmd_busy,\n    input  wire        we_ack,\n    input  wire        cmd_tsf_err,\n    input  wire [4:0]  card_status,\n    input  wire        tx_empt,\n    input  wire        tx_full,\n    input  wire        rx_full,\n    input  wire        busy_n,\n    input  wire        transm_complete,\n    input  wire        crc_ok,\n    input  wire        Dat_Int_Status_rst,\n    input  wire [1:0]  transfer_type,\n    output wire        re_s_tx,\n    output wire        a_cmp_tx,\n    output wire        re_s_rx,\n    output wire        a_cmp_rx,\n    output wire        we_req,\n    output wire        d_write,\n    output wire        d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire        start_tx_fifo,\n    output wire        start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire        ack_transfer,\n    output wire [7:0]  Dat_Int_Status,\n    output wire        CIDAT\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_data_serial_host(\n    input  wire        sd_clk,\n    input  wire        rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0]  start_dat,\n    input  wire        ack_transfer,\n    input  wire [3:0]  DAT_dat_i,\n    output wire        rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire        we,\n    output wire        DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire        busy_n,\n    output wire        transm_complete,\n    output wire        crc_ok\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_fifo_rx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [31:0] m_wb_adr_o,\n    input  wire        m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire        m_wb_cyc_o,\n    input  wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    input  wire [2:0]  m_wb_cti_o,\n    input  wire [1:0]  m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire        wr,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_fifo_tx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [31:0] m_wb_adr_o,\n    input  wire        m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire        m_wb_cyc_o,\n    input  wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    input  wire [2:0]  m_wb_cti_o,\n    input  wire [1:0]  m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    output wire [31:0] dat_o,\n    input  wire        rd,\n    output wire        empty,\n    output wire        fe\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire        we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    input  wire [BD_WIDTH-1:0] free_bd,\n    output wire        re_s,\n    output wire        ack_o_s,\n    output wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_fifo_tx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [31:0] m_wb_adr_o,\n    input  wire        m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire        m_wb_cyc_o,\n    input  wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    input  wire [2:0]  m_wb_cti_o,\n    input  wire [1:0]  m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    output wire [31:0] dat_o,\n    input  wire        rd,\n    output wire        empty,\n    output wire        fe\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_fifo_rx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [31:0] m_wb_adr_o,\n    input  wire        m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire        m_wb_cyc_o,\n    input  wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    input  wire [2:0]  m_wb_cti_o,\n    input  wire [1:0]  m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire        wr,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire        we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    input  wire [BD_WIDTH-1:0] free_bd,\n    output wire        re_s,\n    output wire        ack_o_s,\n    output wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_clock_divider(\n    input  wire        CLK,\n    input  wire [7:0]  DIVIDER,\n    input  wire        RST,\n    output wire        SD_CLK\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_cmd_serial_host(\n    input  wire        SD_CLK_IN,\n    input  wire        RST_IN,\n    input  wire        New_CMD,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:8] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [4:0]  ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire        ERR_INT_RST,\n    input  wire        NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire        go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire        req_out,\n    output wire        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_cmd_master(\n    input  wire        CLK_PAD_IO,\n    input  wire        RST_PAD_I,\n    input  wire        New_CMD,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:8] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [4:0]  ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire        ERR_INT_RST,\n    input  wire        NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire        go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire        req_out,\n    output wire        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_data_master(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input  wire [BD_WIDTH-1:0] free_tx_bd,\n    input  wire        ack_i_s_tx,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input  wire [BD_WIDTH-1:0] free_rx_bd,\n    input  wire        ack_i_s_rx,\n    input  wire        cmd_busy,\n    input  wire        we_ack,\n    input  wire        cmd_tsf_err,\n    input  wire [4:0]  card_status,\n    input  wire        tx_empt,\n    input  wire        tx_full,\n    input  wire        rx_full,\n    input  wire        busy_n,\n    input  wire        transm_complete,\n    input  wire        crc_ok,\n    input  wire        Dat_Int_Status_rst,\n    input  wire [1:0]  transfer_type,\n    output wire        re_s_tx,\n    output wire        a_cmp_tx,\n    output wire        re_s_rx,\n    output wire        a_cmp_rx,\n    output wire        we_req,\n    output wire        d_write,\n    output wire        d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire        start_tx_fifo,\n    output wire        start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire        ack_transfer,\n    output wire [7:0]  Dat_Int_Status,\n    output wire        CIDAT\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_data_serial_host(\n    input  wire        sd_clk,\n    input  wire        rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0]  start_dat,\n    input  wire        ack_transfer,\n    input  wire [3:0]  DAT_dat_i,\n    output wire        rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire        we,\n    output wire        DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire        busy_n,\n    output wire        transm_complete,\n    output wire        crc_ok\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_fifo_rx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [31:0] m_wb_adr_o,\n    input  wire        m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire        m_wb_cyc_o,\n    input  wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    input  wire [2:0]  m_wb_cti_o,\n    input  wire [1:0]  m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire        wr,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_fifo_tx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [31:0] m_wb_adr_o,\n    input  wire        m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire        m_wb_cyc_o,\n    input  wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    input  wire [2:0]  m_wb_cti_o,\n    input  wire [1:0]  m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    output wire [31:0] dat_o,\n    input  wire        rd,\n    output wire        empty,\n    output wire        fe\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire        we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    input  wire [BD_WIDTH-1:0] free_bd,\n    output wire        re_s,\n    output wire        ack_o_s,\n    output wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_clock_divider(\n    input  wire        CLK,\n    input  wire [7:0]  DIVIDER,\n    input  wire        RST,\n    output wire        SD_CLK\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_cmd_serial_host(\n    input  wire        SD_CLK_IN,\n    input  wire        RST_IN,\n    input  wire        New_CMD,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:8] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [4:0]  ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire        ERR_INT_RST,\n    input  wire        NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire        go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire        req_out,\n    output wire        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_cmd_master(\n    input  wire        CLK_PAD_IO,\n    input  wire        RST_PAD_I,\n    input  wire        New_CMD,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:8] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [4:0]  ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire        ERR_INT_RST,\n    input  wire        NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire        go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire        req_out,\n    output wire        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_data_master(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input  wire [BD_WIDTH-1:0] free_tx_bd,\n    input  wire        ack_i_s_tx,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input  wire [BD_WIDTH-1:0] free_rx_bd,\n    input  wire        ack_i_s_rx,\n    input  wire        cmd_busy,\n    input  wire        we_ack,\n    input  wire        cmd_tsf_err,\n    input  wire [4:0]  card_status,\n    input  wire        tx_empt,\n    input  wire        tx_full,\n    input  wire        rx_full,\n    input  wire        busy_n,\n    input  wire        transm_complete,\n    input  wire        crc_ok,\n    input  wire        Dat_Int_Status_rst,\n    input  wire [1:0]  transfer_type,\n    output wire        re_s_tx,\n    output wire        a_cmp_tx,\n    output wire        re_s_rx,\n    output wire        a_cmp_rx,\n    output wire        we_req,\n    output wire        d_write,\n    output wire        d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire        start_tx_fifo,\n    output wire        start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire        ack_transfer,\n    output wire [7:0]  Dat_Int_Status,\n    output wire        CIDAT\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_data_serial_host(\n    input  wire        sd_clk,\n    input  wire        rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0]  start_dat,\n    input  wire        ack_transfer,\n    input  wire [3:0]  DAT_dat_i,\n    output wire        rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire        we,\n    output wire        DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire        busy_n,\n    output wire        transm_complete,\n    output wire        crc_ok\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_fifo_rx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [31:0] m_wb_adr_o,\n    input  wire        m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire        m_wb_cyc_o,\n    input  wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    input  wire [2:0]  m_wb_cti_o,\n    input  wire [1:0]  m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire        wr,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_fifo_tx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [31:0] m_wb_adr_o,\n    input  wire        m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire        m_wb_cyc_o,\n    input  wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    input  wire [2:0]  m_wb_cti_o,\n    input  wire [1:0]  m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    output wire [31:0] dat_o,\n    input  wire        rd,\n    output wire        empty,\n    output wire        fe\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire        we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    input  wire [BD_WIDTH-1:0] free_bd,\n    output wire        re_s,\n    output wire        ack_o_s,\n    output wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_clock_divider(\n    input  wire        CLK,\n    input  wire [7:0]  DIVIDER,\n    input  wire        RST,\n    output wire        SD_CLK\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_cmd_serial_host(\n    input  wire        SD_CLK_IN,\n    input  wire        RST_IN,\n    input  wire        New_CMD,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:8] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [4:0]  ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire        ERR_INT_RST,\n    input  wire        NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire        go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire        req_out,\n    output wire        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_cmd_master(\n    input  wire        CLK_PAD_IO,\n    input  wire        RST_PAD_I,\n    input  wire        New_CMD,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:8] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [4:0]  ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire        ERR_INT_RST,\n    input  wire        NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire        go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire        req_out,\n    output wire        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_data_master(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input  wire [BD_WIDTH-1:0] free_tx_bd,\n    input  wire        ack_i_s_tx,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input  wire [BD_WIDTH-1:0] free_rx_bd,\n    input  wire        ack_i_s_rx,\n    input  wire        cmd_busy,\n    input  wire        we_ack,\n    input  wire        cmd_tsf_err,\n    input  wire [4:0]  card_status,\n    input  wire        tx_empt,\n    input  wire        tx_full,\n    input  wire        rx_full,\n    input  wire        busy_n,\n    input  wire        transm_complete,\n    input  wire        crc_ok,\n    input  wire        Dat_Int_Status_rst,\n    input  wire [1:0]  transfer_type,\n    output wire        re_s_tx,\n    output wire        a_cmp_tx,\n    output wire        re_s_rx,\n    output wire        a_cmp_rx,\n    output wire        we_req,\n    output wire        d_write,\n    output wire        d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire        start_tx_fifo,\n    output wire        start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire        ack_transfer,\n    output wire [7:0]  Dat_Int_Status,\n    output wire        CIDAT\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_data_serial_host(\n    input  wire        sd_clk,\n    input  wire        rst,\n    input  wire [31:0] data_in,\n    input  wire [1:0]  start_dat,\n    input  wire        ack_transfer,\n    input  wire [3:0]  DAT_dat_i,\n    output wire        rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire        we,\n    output wire        DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire        busy_n,\n    output wire        transm_complete,\n    output wire        crc_ok\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_fifo_rx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [31:0] m_wb_adr_o,\n    input  wire        m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire        m_wb_cyc_o,\n    input  wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    input  wire [2:0]  m_wb_cti_o,\n    input  wire [1:0]  m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    input  wire [SD_BUS_W-1:0] dat_i,\n    input  wire        wr,\n    output wire        full,\n    output wire        empty,\n    output wire [5:0]  mem_empt\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_fifo_tx_filler(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire [31:0] m_wb_adr_o,\n    input  wire        m_wb_we_o,\n    input  wire [31:0] m_wb_dat_i,\n    input  wire        m_wb_cyc_o,\n    input  wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    input  wire [2:0]  m_wb_cti_o,\n    input  wire [1:0]  m_wb_bte_o,\n    input  wire        en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    output wire [31:0] dat_o,\n    input  wire        rd,\n    output wire        empty,\n    output wire        fe\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_bd(\n    input  wire        clk,\n    input  wire        rst,\n    input  wire        we_m,\n    input  wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    input  wire [BD_WIDTH-1:0] free_bd,\n    output wire        re_s,\n    output wire        ack_o_s,\n    output wire        a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_clock_divider(\n    input  wire        CLK,\n    input  wire [7:0]  DIVIDER,\n    input  wire        RST,\n    output wire        SD_CLK\n);\n\n    //... rest of the module implementation...\nendmodule\nmodule sd_cmd_serial_host(\n    input  wire        SD_CLK_IN,\n    input  wire        RST_IN,\n    input  wire        New_CMD,\n    input  wire        data_write,\n    input  wire        data_read,\n    input  wire [31:0] ARG_REG,\n    input  wire [13:8] CMD_SET_REG,\n    input  wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [4:0]  ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input  wire        ERR_INT_RST,\n    input  wire        NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire        go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire        req_out,\n    output wire        ack_out,\n    input  wire        req_in,\n    input  wire        ack_in,\n    input  wire [39:0] cmd_in,\n    input  wire [7:0]  serial_status,\n    input  wire        card_detect\n);\n\n    //... rest of the module implementation...\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 9, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg ld_r;\nreg [127:0] text_out_r;\n\nalways @(posedge clk)\nbegin\n    if (rst)\n    begin\n        text_in_r <= 0;\n        sa <= 0;\n        dcnt <= 0;\n        ld_r <= 0;\n        text_out_r <= 0;\n    end\n    else\n    begin\n        if (ld)\n        begin\n            text_in_r <= text_in;\n            sa <= 0;\n            dcnt <= 0;\n            ld_r <= 1;\n        end\n        else\n        begin\n            if (dcnt == 0)\n            begin\n                text_in_r <= text_in_r;\n                sa <= {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                       sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                       sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                       sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n                dcnt <= dcnt + 1;\n                ld_r <= 0;\n            end\n            else\n            begin\n                if (dcnt == 1)\n                begin\n                    text_in_r <= text_in_r;\n                    sa <= {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                           sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                           sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                           sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n                    dcnt <= dcnt + 1;\n                    ld_r <= 0;\n                end\n                else\n                begin\n                    if (dcnt == 2)\n                    begin\n                        text_in_r <= text_in_r;\n                        sa <= {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                               sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                               sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                               sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n                        dcnt <= dcnt + 1;\n                        ld_r <= 0;\n                    end\n                    else\n                    begin\n                        if (dcnt == 3)\n                        begin\n                            text_in_r <= text_in_r;\n                            sa <= {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                                   sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                                   sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                                   sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n                            dcnt <= dcnt + 1;\n                            ld_r <= 0;\n                        end\n                        else\n                        begin\n                            if (dcnt == 4)\n                            begin\n                                text_in_r <= text_in_r;\n                                sa <= {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                                       sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                                       sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                                       sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n                                dcnt <= dcnt + 1;\n                                ld_r <= 0;\n                            end\n                            else\n                            begin\n                                if (dcnt == 5)\n                                begin\n                                    text_in_r <= text_in_r;\n                                    sa <= {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                                           sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                                           sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                                           sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n                                    dcnt <= dcnt + 1;\n                                    ld_r <= 0;\n                                end\n                                else\n                                begin\n                                    if (dcnt == 6)\n                                    begin\n                                        text_in_r <= text_in_r;\n                                        sa <= {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                                               sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                                               sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                                               sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n                                        dcnt <= dcnt + 1;\n                                        ld_r <= 0;\n                                    end\n                                    else\n                                    begin\n                                        if (dcnt == 7)\n                                        begin\n                                            text_in_r <= text_in_r;\n                                            sa <= {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                                                   sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                                                   sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                                                   sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n                                            dcnt <= dcnt + 1;\n                                            ld_r <= 0;\n                                        end\n                                        else\n                                        begin\n                                            if (dcnt == 8)\n                                            begin\n                                                text_in_r <= text_in_r;\n                                                sa <= {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                                                       sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                                                       sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                                                       sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n                                                dcnt <= dcnt + 1;\n                                                ld_r <= 0;\n                                            end\n                                            else\n                                            begin\n                                                if (dcnt == 9)\n                                                begin\n                                                    text_in_r <= text_in_r;\n                                                    sa <= {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                                                           sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                                                           sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                                                           sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n                                                    dcnt <= dcnt + 1;\n                                                    ld_r <= 0;\n                                                end\n                                                else\n                                                begin\n                                                    text_in_r <= text_in_r;\n                                                    sa <= {sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n                                                           sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n                                                           sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n                                                           sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n                                                    ld_r <= 0;\n                                                end\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n\n    if (ld_r)\n    begin\n        text_out_r <= text_in_r;\n    end\n    else\n    begin\n        if (dcnt == 10)\n        begin\n            text_out_r <= text_in_r;\n            done <= 1;\n        end\n        else\n        begin\n            text_out_r <= text_in_r;\n        end\n    end\nend\n\nassign text_out = text_out_r;\n\nendmodule\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [31:0] w[0:3];\nreg [3:0] rcnt;\nreg [7:0] sbox_out[0:15];\n\nalways @(posedge clk)\nbegin\n    if (kld)\n    begin\n        w[0] <= key[31:0];\n        w[1] <= key[63:32];\n        w[2] <= key[95:64];\n        w[3] <= key[127:96];\n        rcnt <= 0;\n    end\n    else\n    begin\n        if (rcnt == 0)\n        begin\n            w[0] <= w[0];\n            w[1] <= w[1];\n            w[2] <= w[2];\n            w[3] <= w[3];\n            rcnt <= rcnt + 1;\n        end\n        else\n        begin\n            if (rcnt == 1)\n            begin\n                w[0] <= w[0];\n                w[1] <= w[1];\n                w[2] <= w[2];\n                w[3] <= w[3];\n                rcnt <= rcnt + 1;\n            end\n            else\n            begin\n                if (rcnt == 2)\n                begin\n                    w[0] <= w[0];\n                    w[1] <= w[1];\n                    w[2] <= w[2];\n                    w[3] <= w[3];\n                    rcnt <= rcnt + 1;\n                end\n                else\n                begin\n                    if (rcnt == 3)\n                    begin\n                        w[0] <= w[0];\n                        w[1] <= w[1];\n                        w[2] <= w[2];\n                        w[3] <= w[3];\n                        rcnt <= rcnt + 1;\n                    end\n                    else\n                    begin\n                        if (rcnt == 4)\n                        begin\n                            w[0] <= w[0];\n                            w[1] <= w[1];\n                            w[2] <= w[2];\n                            w[3] <= w[3];\n                            rcnt <= rcnt + 1;\n                        end\n                        else\n                        begin\n                            if (rcnt == 5)\n                            begin\n                                w[0] <= w[0];\n                                w[1] <= w[1];\n                                w[2] <= w[2];\n                                w[3] <= w[3];\n                                rcnt <= rcnt + 1;\n                            end\n                            else\n                            begin\n                                if (rcnt == 6)\n                                begin\n                                    w[0] <= w[0];\n                                    w[1] <= w[1];\n                                    w[2] <= w[2];\n                                    w[3] <= w[3];\n                                    rcnt <= rcnt + 1;\n                                end\n                                else\n                                begin\n                                    if (rcnt == 7)\n                                    begin\n                                        w[0] <= w[0];\n                                        w[1] <= w[1];\n                                        w[2] <= w[2];\n                                        w[3] <= w[3];\n                                        rcnt <= rcnt + 1;\n                                    end\n                                    else\n                                    begin\n                                        if (rcnt == 8)\n                                        begin\n                                            w[0] <= w[0];\n                                            w[1] <= w[1];\n                                            w[2] <= w[2];\n                                            w[3] <= w[3];\n                                            rcnt <= rcnt + 1;\n                                        end\n                                        else\n                                        begin\n                                            if (rcnt == 9)\n                                            begin\n                                                w[0] <= w[0];\n                                                w[1] <= w[1];\n                                                w[2] <= w[2];\n                                                w[3] <= w[3];\n                                                rcnt <= rcnt + 1;\n                                            end\n                                            else\n                                            begin\n                                                w[0] <= w[0];\n                                                w[1] <= w[1];\n                                                w[2] <= w[2];\n                                                w[3] <= w[3];\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n\n    wo_0 <= w[0];\n    wo_1 <= w[1];\n    wo_2 <= w[2];\n    wo_3 <= w[3];\nend\n\nendmodule\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] sbox_out[0:255];\n\ninitial\nbegin\n    for (int i = 0; i < 256; i++)\n    begin\n        sbox_out[i] = i;\n    end\nend\n\nalways @(a)\nbegin\n    b <= sbox_out[a];\nend\n\nendmodule\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [7:0] rcon_out;\n\nalways @(posedge clk)\nbegin\n    if (kld)\n    begin\n        rcnt <= 0;\n        rcon_out <= 0;\n    end\n    else\n    begin\n        if (rcnt == 0)\n        begin\n            rcon_out <= 0;\n            rcnt <= rcnt + 1;\n        end\n        else\n        begin\n            if (rcnt == 1)\n            begin\n                rcon_out <= 0;\n                rcnt <= rcnt + 1;\n            end\n            else\n            begin\n                if (rcnt == 2)\n                begin\n                    rcon_out <= 0;\n                    rcnt <= rcnt + 1;\n                end\n                else\n                begin\n                    if (rcnt == 3)\n                    begin\n                        rcon_out <= 0;\n                        rcnt <= rcnt + 1;\n                    end\n                    else\n                    begin\n                        if (rcnt == 4)\n                        begin\n                            rcon_out <= 0;\n                            rcnt <= rcnt + 1;\n                        end\n                        else\n                        begin\n                            if (rcnt == 5)\n                            begin\n                                rcon_out <= 0;\n                                rcnt <= rcnt + 1;\n                            end\n                            else\n                            begin\n                                if (rcnt == 6)\n                                begin\n                                    rcon_out <= 0;\n                                    rcnt <= rcnt + 1;\n                                end\n                                else\n                                begin\n                                    if (rcnt == 7)\n                                    begin\n                                        rcon_out <= 0;\n                                        rcnt <= rcnt + 1;\n                                    end\n                                    else\n                                    begin\n                                        if (rcnt == 8)\n                                        begin\n                                            rcon_out <= 0;\n                                            rcnt <= rcnt + 1;\n                                        end\n                                        else\n                                        begin\n                                            if (rcnt == 9)\n                                            begin\n                                                rcon_out <= 0;\n                                                rcnt <= rcnt + 1;\n                                            end\n                                            else\n                                            begin\n                                                rcon_out <= 0;\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n\n    case (rcnt)\n        1: out <= 32'h01_00_00_00;\n        2: out <= 32'h02_00_00_00;\n        3: out <= 32'h04_00_00_00;\n        4: out <= 32'h08_00_00_00;\n        5: out <= 32'h10_00_00_00;\n        6: out <= 32'h20_00_00_00;\n        7: out <= 32'h40_00_00_00;\n        8: out <= 32'h80_00_00_00;\n        9: out <= 32'h1b_00_00_00;\n        10: out <= 32'h36_00_00_00;\n        default: out <= 32'h00_00_00_00;\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 10, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    // SubBytes transformation\n    aes_sbox sub_bytes(\n        .a({sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n            sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n            sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n            sa[3][0], sa[3][1], sa[3][2], sa[3][3]}),\n        .b({sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n            sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n            sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n            sa[0][3], sa[1][3], sa[2][3], sa[3][3]})\n    );\n\n    // ShiftRows transformation\n    assign sa[0][0] = sa[0][0];\n    assign sa[0][1] = sa[0][1];\n    assign sa[0][2] = sa[0][2];\n    assign sa[0][3] = sa[0][3];\n    assign sa[1][0] = sa[1][1];\n    assign sa[1][1] = sa[1][2];\n    assign sa[1][2] = sa[1][3];\n    assign sa[1][3] = sa[1][0];\n    assign sa[2][0] = sa[2][2];\n    assign sa[2][1] = sa[2][3];\n    assign sa[2][2] = sa[2][0];\n    assign sa[2][3] = sa[2][1];\n    assign sa[3][0] = sa[3][3];\n    assign sa[3][1] = sa[3][0];\n    assign sa[3][2] = sa[3][1];\n    assign sa[3][3] = sa[3][2];\n\n    // MixColumns transformation\n    assign sa[0][0] = (sa[0][0] * 2 + sa[0][1] * 3 + sa[0][2] + sa[0][3]) ^ (sa[1][0] * 2 + sa[1][1] * 3 + sa[1][2] + sa[1][3]);\n    assign sa[0][1] = (sa[0][0] * 2 + sa[0][1] * 3 + sa[0][2] + sa[0][3]) ^ (sa[1][1] * 2 + sa[1][2] * 3 + sa[1][3] + sa[2][0]);\n    assign sa[0][2] = (sa[0][0] * 2 + sa[0][1] * 3 + sa[0][2] + sa[0][3]) ^ (sa[1][2] * 2 + sa[1][3] * 3 + sa[2][0] + sa[2][1]);\n    assign sa[0][3] = (sa[0][0] * 2 + sa[0][1] * 3 + sa[0][2] + sa[0][3]) ^ (sa[1][3] * 2 + sa[2][0] * 3 + sa[2][1] + sa[2][2]);\n    assign sa[1][0] = (sa[1][0] * 2 + sa[1][1] * 3 + sa[1][2] + sa[1][3]) ^ (sa[2][0] * 2 + sa[2][1] * 3 + sa[2][2] + sa[2][3]);\n    assign sa[1][1] = (sa[1][0] * 2 + sa[1][1] * 3 + sa[1][2] + sa[1][3]) ^ (sa[2][1] * 2 + sa[2][2] * 3 + sa[2][3] + sa[3][0]);\n    assign sa[1][2] = (sa[1][0] * 2 + sa[1][1] * 3 + sa[1][2] + sa[1][3]) ^ (sa[2][2] * 2 + sa[2][3] * 3 + sa[3][0] + sa[3][1]);\n    assign sa[1][3] = (sa[1][0] * 2 + sa[1][1] * 3 + sa[1][2] + sa[1][3]) ^ (sa[2][3] * 2 + sa[3][0] * 3 + sa[3][1] + sa[3][2]);\n    assign sa[2][0] = (sa[2][0] * 2 + sa[2][1] * 3 + sa[2][2] + sa[2][3]) ^ (sa[3][0] * 2 + sa[3][1] * 3 + sa[3][2] + sa[3][3]);\n    assign sa[2][1] = (sa[2][0] * 2 + sa[2][1] * 3 + sa[2][2] + sa[2][3]) ^ (sa[3][1] * 2 + sa[3][2] * 3 + sa[3][3] + sa[0][0]);\n    assign sa[2][2] = (sa[2][0] * 2 + sa[2][1] * 3 + sa[2][2] + sa[2][3]) ^ (sa[3][2] * 2 + sa[3][3] * 3 + sa[0][0] + sa[0][1]);\n    assign sa[2][3] = (sa[2][0] * 2 + sa[2][1] * 3 + sa[2][2] + sa[2][3]) ^ (sa[3][3] * 2 + sa[0][0] * 3 + sa[0][1] + sa[0][2]);\n    assign sa[3][0] = (sa[3][0] * 2 + sa[3][1] * 3 + sa[3][2] + sa[3][3]) ^ (sa[0][0] * 2 + sa[0][1] * 3 + sa[0][2] + sa[0][3]);\n    assign sa[3][1] = (sa[3][0] * 2 + sa[3][1] * 3 + sa[3][2] + sa[3][3]) ^ (sa[0][1] * 2 + sa[0][2] * 3 + sa[0][3] + sa[1][0]);\n    assign sa[3][2] = (sa[3][0] * 2 + sa[3][1] * 3 + sa[3][2] + sa[3][3]) ^ (sa[0][2] * 2 + sa[0][3] * 3 + sa[1][0] + sa[1][1]);\n    assign sa[3][3] = (sa[3][0] * 2 + sa[3][1] * 3 + sa[3][2] + sa[3][3]) ^ (sa[0][3] * 2 + sa[1][0] * 3 + sa[1][1] + sa[1][2]);\n\n    // AddRoundKey transformation\n    assign sa[0][0] = sa[0][0] ^ key[0];\n    assign sa[0][1] = sa[0][1] ^ key[1];\n    assign sa[0][2] = sa[0][2] ^ key[2];\n    assign sa[0][3] = sa[0][3] ^ key[3];\n    assign sa[1][0] = sa[1][0] ^ key[4];\n    assign sa[1][1] = sa[1][1] ^ key[5];\n    assign sa[1][2] = sa[1][2] ^ key[6];\n    assign sa[1][3] = sa[1][3] ^ key[7];\n    assign sa[2][0] = sa[2][0] ^ key[8];\n    assign sa[2][1] = sa[2][1] ^ key[9];\n    assign sa[2][2] = sa[2][2] ^ key[10];\n    assign sa[2][3] = sa[2][3] ^ key[11];\n    assign sa[3][0] = sa[3][0] ^ key[12];\n    assign sa[3][1] = sa[3][1] ^ key[13];\n    assign sa[3][2] = sa[3][2] ^ key[14];\n    assign sa[3][3] = sa[3][3] ^ key[15];\n\n    // Round counter\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n        end else if (ld) begin\n            dcnt <= 0;\n        end else if (dcnt > 0) begin\n            dcnt <= dcnt - 1;\n        end\n    end\n\n    // Load operation\n    always @(posedge clk) begin\n        if (rst) begin\n            ld_r <= 0;\n        end else if (ld) begin\n            ld_r <= 1;\n        end else if (ld_r) begin\n            ld_r <= 0;\n        end\n    end\n\n    // Data flow control\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n        end else if (ld) begin\n            text_in_r <= text_in;\n        end\n    end\n\n    // Output generation\n    always @(posedge clk) begin\n        if (rst) begin\n            text_out_r <= 0;\n        end else if (ld_r) begin\n            text_out_r <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                          sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                          sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                          sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n        end\n    end\n\n    // Done signal generation\n    assign done = (dcnt == 0);\n\nendmodule\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w[0:3];\n    reg [7:0] rcon;\n    reg [7:0] sbox[255:0];\n\n    // S-box transformation\n    aes_sbox sbox_unit(\n        .a({key[7:0]}),\n        .b({sbox[key[7:0]]})\n    );\n\n    // Round constant generation\n    aes_rcon rcon_unit(\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    // Key expansion\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= {key[31:24], key[23:16], key[15:8], key[7:0]};\n            w[1] <= {key[39:32], key[31:24], key[23:16], key[15:8]};\n            w[2] <= {key[55:48], key[47:40], key[39:32], key[31:24]};\n            w[3] <= {key[71:64], key[63:56], key[55:48], key[47:40]};\n        end else begin\n            w[0] <= w[0] ^ rcon ^ sbox_unit.w;\n            w[1] <= w[1] ^ w[0] ^ sbox_unit.w;\n            w[2] <= w[2] ^ w[1] ^ sbox_unit.w;\n            w[3] <= w[3] ^ w[2] ^ sbox_unit.w;\n        end\n    end\n\n    // Output generation\n    assign wo_0 = w[0];\n    assign wo_1 = w[1];\n    assign wo_2 = w[2];\n    assign wo_3 = w[3];\n\nendmodule\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table\n    reg [7:0] sbox[255:0];\n\n    // S-box transformation\n    assign b = sbox[a];\n\nendmodule\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [7:0] out\n);\n\n    reg [3:0] rcnt;\n\n    // Round counter\n    always @(posedge clk) begin\n        if (rst) begin\n            rcnt <= 0;\n        end else if (kld) begin\n            rcnt <= 0;\n        end else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n        end\n    end\n\n    // Round constant generation\n    always @(posedge clk) begin\n        if (kld) begin\n            out <= 1;\n        end else if (rcnt == 0) begin\n            out <= 1;\n        end else if (rcnt == 1) begin\n            out <= 2;\n        end else if (rcnt == 2) begin\n            out <= 4;\n        end else if (rcnt == 3) begin\n            out <= 8;\n        end else if (rcnt == 4) begin\n            out <= 10;\n        end else if (rcnt == 5) begin\n            out <= 20;\n        end else if (rcnt == 6) begin\n            out <= 40;\n        end else if (rcnt == 7) begin\n            out <= 80;\n        end else if (rcnt == 8) begin\n            out <= 1b;\n        end else if (rcnt == 9) begin\n            out <= 36;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 11, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // SubBytes transformation\n    aes_sbox subbytes(\n        .a({sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n            sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n            sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n            sa[3][0], sa[3][1], sa[3][2], sa[3][3]}),\n        .b({sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n            sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n            sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n            sa[0][3], sa[1][3], sa[2][3], sa[3][3]})\n    );\n\n    // ShiftRows transformation\n    assign sa[0][0] = sa[0][0];\n    assign sa[0][1] = sa[0][1];\n    assign sa[0][2] = sa[0][2];\n    assign sa[0][3] = sa[0][3];\n    assign sa[1][0] = sa[1][1];\n    assign sa[1][1] = sa[1][2];\n    assign sa[1][2] = sa[1][3];\n    assign sa[1][3] = sa[1][0];\n    assign sa[2][0] = sa[2][2];\n    assign sa[2][1] = sa[2][3];\n    assign sa[2][2] = sa[2][0];\n    assign sa[2][3] = sa[2][1];\n    assign sa[3][0] = sa[3][3];\n    assign sa[3][1] = sa[3][0];\n    assign sa[3][2] = sa[3][1];\n    assign sa[3][3] = sa[3][2];\n\n    // MixColumns transformation\n    assign sa[0][0] = (sa[0][0] * 2 + sa[1][0] * 3 + sa[2][0] + sa[3][0]) ^ (sa[0][1] * 2 + sa[1][1] * 3 + sa[2][1] + sa[3][1]);\n    assign sa[0][1] = (sa[0][1] * 2 + sa[1][1] * 3 + sa[2][1] + sa[3][1]) ^ (sa[0][2] * 2 + sa[1][2] * 3 + sa[2][2] + sa[3][2]);\n    assign sa[0][2] = (sa[0][2] * 2 + sa[1][2] * 3 + sa[2][2] + sa[3][2]) ^ (sa[0][3] * 2 + sa[1][3] * 3 + sa[2][3] + sa[3][3]);\n    assign sa[0][3] = (sa[0][3] * 2 + sa[1][3] * 3 + sa[2][3] + sa[3][3]) ^ (sa[0][0] * 2 + sa[1][0] * 3 + sa[2][0] + sa[3][0]);\n    assign sa[1][0] = (sa[1][0] * 2 + sa[2][0] * 3 + sa[3][0] + sa[0][0]) ^ (sa[1][1] * 2 + sa[2][1] * 3 + sa[3][1] + sa[0][1]);\n    assign sa[1][1] = (sa[1][1] * 2 + sa[2][1] * 3 + sa[3][1] + sa[0][1]) ^ (sa[1][2] * 2 + sa[2][2] * 3 + sa[3][2] + sa[0][2]);\n    assign sa[1][2] = (sa[1][2] * 2 + sa[2][2] * 3 + sa[3][2] + sa[0][2]) ^ (sa[1][3] * 2 + sa[2][3] * 3 + sa[3][3] + sa[0][3]);\n    assign sa[1][3] = (sa[1][3] * 2 + sa[2][3] * 3 + sa[3][3] + sa[0][3]) ^ (sa[1][0] * 2 + sa[2][0] * 3 + sa[3][0] + sa[0][0]);\n    assign sa[2][0] = (sa[2][0] * 2 + sa[3][0] * 3 + sa[0][0] + sa[1][0]) ^ (sa[2][1] * 2 + sa[3][1] * 3 + sa[0][1] + sa[1][1]);\n    assign sa[2][1] = (sa[2][1] * 2 + sa[3][1] * 3 + sa[0][1] + sa[1][1]) ^ (sa[2][2] * 2 + sa[3][2] * 3 + sa[0][2] + sa[1][2]);\n    assign sa[2][2] = (sa[2][2] * 2 + sa[3][2] * 3 + sa[0][2] + sa[1][2]) ^ (sa[2][3] * 2 + sa[3][3] * 3 + sa[0][3] + sa[1][3]);\n    assign sa[2][3] = (sa[2][3] * 2 + sa[3][3] * 3 + sa[0][3] + sa[1][3]) ^ (sa[2][0] * 2 + sa[3][0] * 3 + sa[0][0] + sa[1][0]);\n    assign sa[3][0] = (sa[3][0] * 2 + sa[0][0] * 3 + sa[1][0] + sa[2][0]) ^ (sa[3][1] * 2 + sa[0][1] * 3 + sa[1][1] + sa[2][1]);\n    assign sa[3][1] = (sa[3][1] * 2 + sa[0][1] * 3 + sa[1][1] + sa[2][1]) ^ (sa[3][2] * 2 + sa[0][2] * 3 + sa[1][2] + sa[2][2]);\n    assign sa[3][2] = (sa[3][2] * 2 + sa[0][2] * 3 + sa[1][2] + sa[2][2]) ^ (sa[3][3] * 2 + sa[0][3] * 3 + sa[1][3] + sa[2][3]);\n    assign sa[3][3] = (sa[3][3] * 2 + sa[0][3] * 3 + sa[1][3] + sa[2][3]) ^ (sa[3][0] * 2 + sa[0][0] * 3 + sa[1][0] + sa[2][0]);\n\n    // AddRoundKey transformation\n    assign sa[0][0] = sa[0][0] ^ key[0];\n    assign sa[0][1] = sa[0][1] ^ key[1];\n    assign sa[0][2] = sa[0][2] ^ key[2];\n    assign sa[0][3] = sa[0][3] ^ key[3];\n    assign sa[1][0] = sa[1][0] ^ key[4];\n    assign sa[1][1] = sa[1][1] ^ key[5];\n    assign sa[1][2] = sa[1][2] ^ key[6];\n    assign sa[1][3] = sa[1][3] ^ key[7];\n    assign sa[2][0] = sa[2][0] ^ key[8];\n    assign sa[2][1] = sa[2][1] ^ key[9];\n    assign sa[2][2] = sa[2][2] ^ key[10];\n    assign sa[2][3] = sa[2][3] ^ key[11];\n    assign sa[3][0] = sa[3][0] ^ key[12];\n    assign sa[3][1] = sa[3][1] ^ key[13];\n    assign sa[3][2] = sa[3][2] ^ key[14];\n    assign sa[3][3] = sa[3][3] ^ key[15];\n\n    // Round counter\n    always @(posedge clk)\n    begin\n        if (rst)\n            dcnt <= 0;\n        else if (ld)\n            dcnt <= 11;\n        else\n            dcnt <= dcnt - 1;\n    end\n\n    // Load operation\n    always @(posedge clk)\n    begin\n        if (rst)\n            ld_r <= 0;\n        else if (ld)\n            ld_r <= 1;\n        else\n            ld_r <= ld_r;\n    end\n\n    // Output generation\n    always @(posedge clk)\n    begin\n        if (rst)\n            text_out <= 0;\n        else if (ld)\n            text_out <= text_in;\n        else if (dcnt == 0)\n            text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                        sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                        sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                        sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n        else if (dcnt == 10)\n            text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                        sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                        sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                        sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n        else\n            text_out <= 0;\n    end\n\n    // Done signal\n    assign done = (dcnt == 10);\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expansion_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w[0:3];\n    reg [7:0] rcon;\n    reg [7:0] sbox[0:15];\n    reg [7:0] temp[0:3];\n\n    // S-box\n    aes_sbox aes_sbox(\n        .a({key[7], key[15], key[23], key[31]}),\n        .b({sbox[0], sbox[1], sbox[2], sbox[3]})\n    );\n\n    // Round constant\n    aes_rcon aes_rcon(\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    // Key expansion\n    always @(posedge clk)\n    begin\n        if (kld)\n        begin\n            w[0] <= key[31:0];\n            w[1] <= key[63:32];\n            w[2] <= key[95:64];\n            w[3] <= key[127:96];\n        end\n        else\n        begin\n            temp[0] = w[3];\n            temp[1] = w[0];\n            temp[2] = w[1];\n            temp[3] = w[2];\n\n            w[0] = w[0] ^ rcon;\n            w[1] = w[1] ^ temp[0];\n            w[2] = w[2] ^ temp[1];\n            w[3] = w[3] ^ temp[2];\n\n            wo_0 <= w[0];\n            wo_1 <= w[1];\n            wo_2 <= w[2];\n            wo_3 <= w[3];\n        end\n    end\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table\n    reg [7:0] sbox[0:15] = {\n        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0\n    };\n\n    // S-box transformation\n    assign b = sbox[a];\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [7:0] out\n);\n\n    reg [3:0] rcnt;\n\n    // Round counter\n    always @(posedge clk)\n    begin\n        if (kld)\n            rcnt <= 0;\n        else\n            rcnt <= rcnt + 1;\n    end\n\n    // Round constant generation\n    always @(posedge clk)\n    begin\n        case (rcnt)\n            0: out <= 1;\n            1: out <= 2;\n            2: out <= 4;\n            3: out <= 8;\n            4: out <= 10;\n            5: out <= 20;\n            6: out <= 40;\n            7: out <= 80;\n            8: out <= 1B;\n            9: out <= 36;\n            default: out <= 0;\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 12, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // SubBytes transformation\n    aes_sbox sub_bytes(.a(sa[0][0]), .b(sa[0][0]));\n    aes_sbox sub_bytes_1(.a(sa[0][1]), .b(sa[0][1]));\n    aes_sbox sub_bytes_2(.a(sa[0][2]), .b(sa[0][2]));\n    aes_sbox sub_bytes_3(.a(sa[0][3]), .b(sa[0][3]));\n    aes_sbox sub_bytes_4(.a(sa[1][0]), .b(sa[1][0]));\n    aes_sbox sub_bytes_5(.a(sa[1][1]), .b(sa[1][1]));\n    aes_sbox sub_bytes_6(.a(sa[1][2]), .b(sa[1][2]));\n    aes_sbox sub_bytes_7(.a(sa[1][3]), .b(sa[1][3]));\n    aes_sbox sub_bytes_8(.a(sa[2][0]), .b(sa[2][0]));\n    aes_sbox sub_bytes_9(.a(sa[2][1]), .b(sa[2][1]));\n    aes_sbox sub_bytes_10(.a(sa[2][2]), .b(sa[2][2]));\n    aes_sbox sub_bytes_11(.a(sa[2][3]), .b(sa[2][3]));\n    aes_sbox sub_bytes_12(.a(sa[3][0]), .b(sa[3][0]));\n    aes_sbox sub_bytes_13(.a(sa[3][1]), .b(sa[3][1]));\n    aes_sbox sub_bytes_14(.a(sa[3][2]), .b(sa[3][2]));\n    aes_sbox sub_bytes_15(.a(sa[3][3]), .b(sa[3][3]));\n\n    // ShiftRows transformation\n    assign sa[0][0] = sa[0][0];\n    assign sa[0][1] = sa[0][1];\n    assign sa[0][2] = sa[0][2];\n    assign sa[0][3] = sa[0][3];\n    assign sa[1][0] = sa[1][1];\n    assign sa[1][1] = sa[1][2];\n    assign sa[1][2] = sa[1][3];\n    assign sa[1][3] = sa[1][0];\n    assign sa[2][0] = sa[2][2];\n    assign sa[2][1] = sa[2][3];\n    assign sa[2][2] = sa[2][0];\n    assign sa[2][3] = sa[2][1];\n    assign sa[3][0] = sa[3][3];\n    assign sa[3][1] = sa[3][0];\n    assign sa[3][2] = sa[3][1];\n    assign sa[3][3] = sa[3][2];\n\n    // MixColumns transformation\n    assign sa[0][0] = (sa[0][0] * 2 + sa[0][1] * 3 + sa[0][2] + sa[0][3]) ^ (sa[1][0] * 2 + sa[1][1] * 3 + sa[1][2] + sa[1][3]);\n    assign sa[0][1] = (sa[0][1] * 2 + sa[0][2] * 3 + sa[0][3] + sa[1][0]) ^ (sa[1][1] * 2 + sa[1][2] * 3 + sa[1][3] + sa[2][0]);\n    assign sa[0][2] = (sa[0][2] * 2 + sa[0][3] * 3 + sa[1][0] + sa[1][1]) ^ (sa[1][2] * 2 + sa[1][3] * 3 + sa[2][0] + sa[2][1]);\n    assign sa[0][3] = (sa[0][3] * 2 + sa[1][0] * 3 + sa[1][1] + sa[1][2]) ^ (sa[1][3] * 2 + sa[2][0] * 3 + sa[2][1] + sa[2][2]);\n    assign sa[1][0] = (sa[1][0] * 2 + sa[1][1] * 3 + sa[1][2] + sa[1][3]) ^ (sa[2][0] * 2 + sa[2][1] * 3 + sa[2][2] + sa[2][3]);\n    assign sa[1][1] = (sa[1][1] * 2 + sa[1][2] * 3 + sa[1][3] + sa[2][0]) ^ (sa[2][1] * 2 + sa[2][2] * 3 + sa[2][3] + sa[3][0]);\n    assign sa[1][2] = (sa[1][2] * 2 + sa[1][3] * 3 + sa[2][0] + sa[2][1]) ^ (sa[2][2] * 2 + sa[2][3] * 3 + sa[3][0] + sa[3][1]);\n    assign sa[1][3] = (sa[1][3] * 2 + sa[2][0] * 3 + sa[2][1] + sa[2][2]) ^ (sa[2][3] * 2 + sa[3][0] * 3 + sa[3][1] + sa[3][2]);\n    assign sa[2][0] = (sa[2][0] * 2 + sa[2][1] * 3 + sa[2][2] + sa[2][3]) ^ (sa[3][0] * 2 + sa[3][1] * 3 + sa[3][2] + sa[3][3]);\n    assign sa[2][1] = (sa[2][1] * 2 + sa[2][2] * 3 + sa[2][3] + sa[3][0]) ^ (sa[3][1] * 2 + sa[3][2] * 3 + sa[3][3] + sa[0][0]);\n    assign sa[2][2] = (sa[2][2] * 2 + sa[2][3] * 3 + sa[3][0] + sa[3][1]) ^ (sa[3][2] * 2 + sa[3][3] * 3 + sa[0][0] + sa[0][1]);\n    assign sa[2][3] = (sa[2][3] * 2 + sa[3][0] * 3 + sa[3][1] + sa[3][2]) ^ (sa[3][3] * 2 + sa[0][0] * 3 + sa[0][1] + sa[0][2]);\n    assign sa[3][0] = (sa[3][0] * 2 + sa[3][1] * 3 + sa[3][2] + sa[3][3]) ^ (sa[0][0] * 2 + sa[0][1] * 3 + sa[0][2] + sa[0][3]);\n    assign sa[3][1] = (sa[3][1] * 2 + sa[3][2] * 3 + sa[3][3] + sa[0][0]) ^ (sa[0][1] * 2 + sa[0][2] * 3 + sa[0][3] + sa[1][0]);\n    assign sa[3][2] = (sa[3][2] * 2 + sa[3][3] * 3 + sa[0][0] + sa[0][1]) ^ (sa[0][2] * 2 + sa[0][3] * 3 + sa[1][0] + sa[1][1]);\n    assign sa[3][3] = (sa[3][3] * 2 + sa[0][0] * 3 + sa[0][1] + sa[0][2]) ^ (sa[0][3] * 2 + sa[1][0] * 3 + sa[1][1] + sa[1][2]);\n\n    // AddRoundKey transformation\n    assign sa[0][0] = sa[0][0] ^ key[31:24];\n    assign sa[0][1] = sa[0][1] ^ key[55:48];\n    assign sa[0][2] = sa[0][2] ^ key[79:72];\n    assign sa[0][3] = sa[0][3] ^ key[103:96];\n    assign sa[1][0] = sa[1][0] ^ key[127:120];\n    assign sa[1][1] = sa[1][1] ^ key[151:144];\n    assign sa[1][2] = sa[1][2] ^ key[175:168];\n    assign sa[1][3] = sa[1][3] ^ key[199:192];\n    assign sa[2][0] = sa[2][0] ^ key[223:216];\n    assign sa[2][1] = sa[2][1] ^ key[247:240];\n    assign sa[2][2] = sa[2][2] ^ key[271:264];\n    assign sa[2][3] = sa[2][3] ^ key[295:288];\n    assign sa[3][0] = sa[3][0] ^ key[319:312];\n    assign sa[3][1] = sa[3][1] ^ key[343:336];\n    assign sa[3][2] = sa[3][2] ^ key[367:360];\n    assign sa[3][3] = sa[3][3] ^ key[391:384];\n\n    // Round counter\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n        end\n        else if (ld) begin\n            dcnt <= 0;\n        end\n        else if (dcnt > 0) begin\n            dcnt <= dcnt - 1;\n        end\n    end\n\n    // Load operation\n    always @(posedge clk) begin\n        if (rst) begin\n            ld_r <= 0;\n        end\n        else if (ld) begin\n            ld_r <= 1;\n        end\n    end\n\n    // Data loading\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n        end\n        else if (ld_r) begin\n            text_in_r <= text_in;\n        end\n    end\n\n    // Output generation\n    always @(posedge clk) begin\n        if (rst) begin\n            text_out <= 0;\n        end\n        else if (dcnt == 10) begin\n            text_out <= sa[0][0] << 24 | sa[0][1] << 16 | sa[0][2] << 8 | sa[0][3];\n            done <= 1;\n        end\n        else begin\n            text_out <= sa[0][0] << 24 | sa[0][1] << 16 | sa[0][2] << 8 | sa[0][3];\n        end\n    end\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expansion_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_expanded;\n    reg [31:0] wo_0_reg;\n    reg [31:0] wo_1_reg;\n    reg [31:0] wo_2_reg;\n    reg [31:0] wo_3_reg;\n    reg [3:0] rcnt;\n\n    // Round counter\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n        end\n        else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n        end\n    end\n\n    // Round constant generation\n    aes_rcon rcon(.clk(clk), .kld(kld), .out(wo_0_reg[31:24]));\n\n    // Key expansion\n    always @(posedge clk) begin\n        if (kld) begin\n            wo_0_reg <= key[31:0];\n            wo_1_reg <= key[63:32];\n            wo_2_reg <= key[95:64];\n            wo_3_reg <= key[127:96];\n        end\n        else begin\n            wo_0_reg <= wo_0_reg ^ (wo_1_reg << 8) ^ wo_2_reg;\n            wo_1_reg <= wo_1_reg ^ (wo_2_reg << 8) ^ wo_3_reg;\n            wo_2_reg <= wo_2_reg ^ (wo_3_reg << 8) ^ (wo_0_reg << 24);\n            wo_3_reg <= wo_3_reg ^ (wo_0_reg << 8) ^ (wo_1_reg << 24);\n        end\n    end\n\n    // Output\n    always @(posedge clk) begin\n        wo_0 <= wo_0_reg;\n        wo_1 <= wo_1_reg;\n        wo_2 <= wo_2_reg;\n        wo_3 <= wo_3_reg;\n    end\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    // Round counter\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n        end\n        else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n        end\n    end\n\n    // Round constant generation\n    always @(posedge clk) begin\n        if (rcnt == 0) begin\n            out <= 32'h01_00_00_00;\n        end\n        else if (rcnt == 1) begin\n            out <= 32'h02_00_00_00;\n        end\n        else if (rcnt == 2) begin\n            out <= 32'h04_00_00_00;\n        end\n        else if (rcnt == 3) begin\n            out <= 32'h08_00_00_00;\n        end\n        else if (rcnt == 4) begin\n            out <= 32'h10_00_00_00;\n        end\n        else if (rcnt == 5) begin\n            out <= 32'h20_00_00_00;\n        end\n        else if (rcnt == 6) begin\n            out <= 32'h40_00_00_00;\n        end\n        else if (rcnt == 7) begin\n            out <= 32'h80_00_00_00;\n        end\n        else if (rcnt == 8) begin\n            out <= 32'h1b_00_00_00;\n        end\n        else if (rcnt == 9) begin\n            out <= 32'h36_00_00_00;\n        end\n        else begin\n            out <= 32'h00_00_00_00;\n        end\n    end\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table\n    reg [7:0] sbox[255:0];\n\n    // Initialize S-box lookup table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n        end\n    end\n\n    // S-box transformation\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 13, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n            begin\n                text_in_r <= 0;\n                dcnt <= 0;\n                ld_r <= 0;\n            end\n        else if (ld)\n            begin\n                text_in_r <= text_in;\n                ld_r <= 1;\n                dcnt <= 0;\n            end\n        else\n            begin\n                if (ld_r)\n                    ld_r <= 0;\n                else\n                    begin\n                        if (dcnt == 0)\n                            begin\n                                // SubBytes\n                                for (int i = 0; i < 4; i++)\n                                    for (int j = 0; j < 4; j++)\n                                        sa[i][j] = aes_sbox(sa[i][j]);\n                                // ShiftRows\n                                for (int i = 1; i < 4; i++)\n                                    for (int j = 0; j < 4; j++)\n                                        sa[i][j] = {sa[i][j+1], sa[i][j]};\n                                // MixColumns\n                                for (int i = 0; i < 4; i++)\n                                    for (int j = 0; j < 4; j++)\n                                        sa[i][j] = mix_columns(sa[i][j]);\n                                // AddRoundKey\n                                for (int i = 0; i < 4; i++)\n                                    for (int j = 0; j < 4; j++)\n                                        sa[i][j] = sa[i][j] ^ aes_key_expand_128.key_expansion(dcnt, i, j);\n                                ld_r <= 1;\n                            end\n                        else\n                            begin\n                                dcnt <= dcnt - 1;\n                            end\n                    end\n            end\n    end\n\n    assign text_out = text_in_r;\n    assign done = (dcnt == 10);\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expansion(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_expansion;\n    reg [3:0] rcnt;\n    reg [7:0] sbox[255:0];\n\n    initial\n    begin\n        for (int i = 0; i < 256; i++)\n            sbox[i] = aes_sbox(i);\n    end\n\n    always @(posedge clk)\n    begin\n        if (kld)\n            begin\n                key_expansion <= key;\n                rcnt <= 0;\n                wo_0 <= 0;\n                wo_1 <= 0;\n                wo_2 <= 0;\n                wo_3 <= 0;\n            end\n        else\n            begin\n                if (rcnt == 0)\n                    begin\n                        wo_0 <= key_expansion[31:0];\n                        wo_1 <= key_expansion[63:32];\n                        wo_2 <= key_expansion[95:64];\n                        wo_3 <= key_expansion[127:96];\n                        key_expansion <= {key_expansion[127:96], key_expansion[95:64], key_expansion[63:32], key_expansion[31:0]};\n                        rcnt <= rcnt + 1;\n                    end\n                else\n                    begin\n                        wo_0 <= wo_1;\n                        wo_1 <= wo_2;\n                        wo_2 <= wo_3;\n                        wo_3 <= aes_key_expansion(rcnt, key_expansion);\n                        key_expansion <= {key_expansion[127:96], key_expansion[95:64], key_expansion[63:32], key_expansion[31:0]};\n                        rcnt <= rcnt + 1;\n                    end\n            end\n    end\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[255:0];\n\n    initial\n    begin\n        for (int i = 0; i < 256; i++)\n            sbox[i] = i;\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n    reg [7:0] rcon[10:0];\n\n    initial\n    begin\n        rcon[0] = 1;\n        rcon[1] = 2;\n        rcon[2] = 4;\n        rcon[3] = 8;\n        rcon[4] = 10;\n        rcon[5] = 20;\n        rcon[6] = 40;\n        rcon[7] = 80;\n        rcon[8] = 1b;\n        rcon[9] = 36;\n    end\n\n    always @(posedge clk)\n    begin\n        if (kld)\n            begin\n                rcnt <= 0;\n                out <= 32'h01_00_00_00;\n            end\n        else\n            begin\n                if (rcnt == 0)\n                    out <= rcon[0];\n                else\n                    begin\n                        out <= rcon[rcnt];\n                        rcnt <= rcnt + 1;\n                    end\n            end\n    end\n\nendmodule\n\n// mix_columns function\nfunction [7:0] mix_columns([7:0] a);\n    reg [7:0] b;\n    reg [7:0] c;\n    reg [7:0] d;\n\n    b = {a[3], a[2], a[1], a[0]};\n    c = {a[2], a[3], a[0], a[1]};\n    d = {a[1], a[0], a[3], a[2]};\n\n    b = b ^ (b << 1);\n    c = c ^ (c << 1);\n    d = d ^ (d << 1);\n\n    b = b ^ (b << 2);\n    c = c ^ (c << 2);\n    d = d ^ (d << 2);\n\n    b = b ^ (b << 4);\n    c = c ^ (c << 4);\n    d = d ^ (d << 4);\n\n    b = b ^ (b << 8);\n    c = c ^ (c << 8);\n    d = d ^ (d << 8);\n\n    mix_columns = {b[3], c[3], d[3], b[2], c[2], d[2], b[1], c[1], d[1], b[0], c[0], d[0]};\nendfunction", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 14, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    // SubBytes transformation\n    module sub_bytes(\n        input [7:0] a,\n        output [7:0] b\n    );\n        // S-box lookup table\n        reg [7:0] sbox[256];\n        initial begin\n            for (int i = 0; i < 256; i++) begin\n                sbox[i] = i;\n            end\n        end\n        assign b = sbox[a];\n    endmodule\n\n    // ShiftRows transformation\n    module shift_rows(\n        input [7:0] a[0:3],\n        output [7:0] b[0:3]\n    );\n        assign b[0] = a[0];\n        assign b[1] = a[1] << 1 | a[0] >> 7;\n        assign b[2] = a[2] << 2 | a[1] >> 6 | a[0] >> 5;\n        assign b[3] = a[3] << 3 | a[2] >> 5 | a[1] >> 4 | a[0] >> 3;\n    endmodule\n\n    // MixColumns transformation\n    module mix_columns(\n        input [7:0] a[0:3],\n        output [7:0] b[0:3]\n    );\n        reg [7:0] temp[0:3];\n        assign temp[0] = a[0] << 1 | a[1] << 1 | a[2] << 1 | a[3] << 1;\n        assign temp[1] = a[0] << 2 | a[1] << 2 | a[2] << 2 | a[3] << 2;\n        assign temp[2] = a[0] << 3 | a[1] << 3 | a[2] << 3 | a[3] << 3;\n        assign temp[3] = a[0] << 4 | a[1] << 4 | a[2] << 4 | a[3] << 4;\n        assign b[0] = temp[0] ^ temp[1] ^ temp[2] ^ temp[3];\n        assign b[1] = temp[0] ^ temp[1] ^ temp[2] ^ temp[3];\n        assign b[2] = temp[0] ^ temp[1] ^ temp[2] ^ temp[3];\n        assign b[3] = temp[0] ^ temp[1] ^ temp[2] ^ temp[3];\n    endmodule\n\n    // AddRoundKey transformation\n    module add_round_key(\n        input [7:0] a[0:3],\n        input [7:0] b[0:3],\n        output [7:0] c[0:3]\n    );\n        assign c[0] = a[0] ^ b[0];\n        assign c[1] = a[1] ^ b[1];\n        assign c[2] = a[2] ^ b[2];\n        assign c[3] = a[3] ^ b[3];\n    endmodule\n\n    // aes_key_expand_128 module\n    module aes_key_expand_128(\n        input clk,\n        input kld,\n        input [127:0] key,\n        output [31:0] wo_0,\n        output [31:0] wo_1,\n        output [31:0] wo_2,\n        output [31:0] wo_3\n    );\n        reg [31:0] w[0:3];\n        reg [3:0] rcnt;\n        reg [7:0] rcon;\n\n        // aes_rcon module\n        module aes_rcon(\n            input clk,\n            input kld,\n            output [7:0] rcon\n        );\n            reg [3:0] cnt;\n            initial begin\n                cnt = 0;\n            end\n            always @(posedge clk) begin\n                if (kld) begin\n                    cnt <= 0;\n                    rcon <= 1;\n                end else begin\n                    cnt <= cnt + 1;\n                    rcon <= (cnt == 0)? 1 : (cnt == 1)? 2 : (cnt == 2)? 4 : (cnt == 3)? 8 : (cnt == 4)? 10 : (cnt == 5)? 20 : (cnt == 6)? 40 : (cnt == 7)? 80 : (cnt == 8)? 1B : (cnt == 9)? 36 : 0;\n                end\n            end\n        endmodule\n\n        // aes_sbox module\n        module aes_sbox(\n            input [7:0] a,\n            output [7:0] b\n        );\n            // S-box lookup table\n            reg [7:0] sbox[256];\n            initial begin\n                for (int i = 0; i < 256; i++) begin\n                    sbox[i] = i;\n                end\n            end\n            assign b = sbox[a];\n        endmodule\n\n        // SubBytes transformation\n        sub_bytes sub_bytes_inst(\n           .a(a),\n           .b(b)\n        );\n\n        // ShiftRows transformation\n        shift_rows shift_rows_inst(\n           .a(a),\n           .b(b)\n        );\n\n        // MixColumns transformation\n        mix_columns mix_columns_inst(\n           .a(a),\n           .b(b)\n        );\n\n        // AddRoundKey transformation\n        add_round_key add_round_key_inst(\n           .a(a),\n           .b(b),\n           .c(c)\n        );\n\n        // Key expansion process\n        always @(posedge clk) begin\n            if (kld) begin\n                w[0] <= key[31:0];\n                w[1] <= key[63:32];\n                w[2] <= key[95:64];\n                w[3] <= key[127:96];\n                rcnt <= 0;\n            end else begin\n                w[0] <= w[0] ^ (w[1] << 1 | w[2] << 1 | w[3] << 1);\n                w[1] <= w[1] ^ (w[2] << 2 | w[3] << 2);\n                w[2] <= w[2] ^ (w[3] << 3 | w[0] << 3);\n                w[3] <= w[3] ^ (w[0] << 4 | w[1] << 4 | w[2] << 4);\n                rcnt <= rcnt + 1;\n                if (rcnt == 9) begin\n                    w[0] <= w[0] ^ (w[1] << 1 | w[2] << 1 | w[3] << 1);\n                    w[1] <= w[1] ^ (w[2] << 2 | w[3] << 2);\n                    w[2] <= w[2] ^ (w[3] << 3 | w[0] << 3);\n                    w[3] <= w[3] ^ (w[0] << 4 | w[1] << 4 | w[2] << 4);\n                end\n            end\n        end\n\n        // Output round key words\n        assign wo_0 = w[0];\n        assign wo_1 = w[1];\n        assign wo_2 = w[2];\n        assign wo_3 = w[3];\n    endmodule\n\n    // aes_cipher_top module\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n            text_out_r <= 0;\n        end else if (ld) begin\n            text_in_r <= text_in;\n            sa <= 0;\n            dcnt <= 0;\n            ld_r <= 1;\n            text_out_r <= 0;\n        end else begin\n            if (dcnt == 0) begin\n                sa[0][0] <= text_in_r[7:0];\n                sa[0][1] <= text_in_r[15:8];\n                sa[0][2] <= text_in_r[23:16];\n                sa[0][3] <= text_in_r[31:24];\n                sa[1][0] <= text_in_r[39:32];\n                sa[1][1] <= text_in_r[47:40];\n                sa[1][2] <= text_in_r[55:48];\n                sa[1][3] <= text_in_r[63:56];\n                sa[2][0] <= text_in_r[71:64];\n                sa[2][1] <= text_in_r[79:72];\n                sa[2][2] <= text_in_r[87:80];\n                sa[2][3] <= text_in_r[95:88];\n                sa[3][0] <= text_in_r[103:96];\n                sa[3][1] <= text_in_r[111:104];\n                sa[3][2] <= text_in_r[119:112];\n                sa[3][3] <= text_in_r[127:120];\n                dcnt <= 0xB;\n                ld_r <= 0;\n            end else if (dcnt > 0) begin\n                // SubBytes transformation\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sub_bytes_inst.sub_bytes(sa[i][j], sa[i][j]);\n                    end\n                end\n\n                // ShiftRows transformation\n                shift_rows_inst.shift_rows(sa[0][0:3], sa[0][0:3]);\n                shift_rows_inst.shift_rows(sa[1][0:3], sa[1][0:3]);\n                shift_rows_inst.shift_rows(sa[2][0:3], sa[2][0:3]);\n                shift_rows_inst.shift_rows(sa[3][0:3], sa[3][0:3]);\n\n                // MixColumns transformation\n                mix_columns_inst.mix_columns(sa[0][0:3], sa[0][0:3]);\n                mix_columns_inst.mix_columns(sa[1][0:3], sa[1][0:3]);\n                mix_columns_inst.mix_columns(sa[2][0:3], sa[2][0:3]);\n                mix_columns_inst.mix_columns(sa[3][0:3], sa[3][0:3]);\n\n                // AddRoundKey transformation\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        add_round_key_inst.add_round_key(sa[i][j], sa[i][j], sa[i][j]);\n                    end\n                end\n\n                dcnt <= dcnt - 1;\n            end else if (dcnt == -1) begin\n                // Final round\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j];\n                    end\n                end\n\n                // Output ciphertext\n                text_out_r <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                              sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                              sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                              sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                done <= 1;\n            end\n        end\n    end\n\n    // Output ciphertext\n    assign text_out = text_out_r;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 15, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n        end\n        else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1;\n        end\n        else begin\n            if (ld_r) begin\n                ld_r <= 0;\n                dcnt <= 0;\n            end\n            else begin\n                if (dcnt < 10) begin\n                    dcnt <= dcnt + 1;\n                end\n                else begin\n                    done <= 1;\n                end\n            end\n        end\n    end\n\n    // SubBytes\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end\n        else if (ld) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i+j];\n                end\n            end\n        end\n        else if (dcnt < 10) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= aes_sbox(sa[i][j]);\n                end\n            end\n        end\n    end\n\n    // ShiftRows\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end\n        else if (ld) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i+j];\n                end\n            end\n        end\n        else if (dcnt < 10) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    case (i)\n                        0: sa[i][j] <= sa[i][j];\n                        1: sa[i][j] <= sa[i][j+1];\n                        2: sa[i][j] <= sa[i][j+2];\n                        3: sa[i][j] <= sa[i][j+3];\n                    endcase\n                end\n            end\n        end\n    end\n\n    // MixColumns\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end\n        else if (ld) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i+j];\n                end\n            end\n        end\n        else if (dcnt < 9) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= (sa[i][j] * 2 + sa[i][j+1]) ^ (sa[i][j+2] * 3 + sa[i][j+3]);\n                end\n            end\n        end\n    end\n\n    // AddRoundKey\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end\n        else if (ld) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i+j];\n                end\n            end\n        end\n        else if (dcnt < 10) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ aes_key_expand_128(key, dcnt)[8*i+j];\n                end\n            end\n        end\n    end\n\n    // Output\n    always @(posedge clk) begin\n        if (rst) begin\n            text_out <= 0;\n        end\n        else if (ld) begin\n            text_out <= text_in;\n        end\n        else if (dcnt == 10) begin\n            text_out <= text_in_r;\n        end\n    end\n\nendmodule\n// aes_key_expand_128 module\nmodule aes_key_expansion_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_expanded;\n    reg [3:0] rcnt;\n    reg [31:0] wo_0_reg, wo_1_reg, wo_2_reg, wo_3_reg;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            key_expanded <= key;\n            rcnt <= 0;\n            wo_0_reg <= 0;\n            wo_1_reg <= 0;\n            wo_2_reg <= 0;\n            wo_3_reg <= 0;\n        end\n        else begin\n            if (rcnt == 0) begin\n                wo_0_reg <= key_expanded[31:0];\n                wo_1_reg <= key_expanded[63:32];\n                wo_2_reg <= key_expanded[95:64];\n                wo_3_reg <= key_expanded[127:96];\n            end\n            else if (rcnt == 1) begin\n                wo_0_reg <= wo_1_reg;\n                wo_1_reg <= wo_2_reg;\n                wo_2_reg <= wo_3_reg;\n                wo_3_reg <= (wo_0_reg ^ aes_rcon(rcnt)) ^ aes_sbox(wo_0_reg[7:0]);\n            end\n            else if (rcnt == 2) begin\n                wo_0_reg <= wo_1_reg;\n                wo_1_reg <= wo_2_reg;\n                wo_2_reg <= wo_3_reg;\n                wo_3_reg <= (wo_0_reg ^ wo_1_reg) ^ aes_sbox(wo_0_reg[7:0]);\n            end\n            else if (rcnt == 3) begin\n                wo_0_reg <= wo_1_reg;\n                wo_1_reg <= wo_2_reg;\n                wo_2_reg <= wo_3_reg;\n                wo_3_reg <= (wo_0_reg ^ wo_1_reg ^ wo_2_reg) ^ aes_sbox(wo_0_reg[7:0]);\n            end\n            else if (rcnt == 4) begin\n                wo_0_reg <= wo_1_reg;\n                wo_1_reg <= wo_2_reg;\n                wo_2_reg <= wo_3_reg;\n                wo_3_reg <= (wo_0_reg ^ wo_1_reg ^ wo_2_reg ^ wo_3_reg) ^ aes_sbox(wo_0_reg[7:0]);\n            end\n            else if (rcnt == 5) begin\n                wo_0_reg <= wo_1_reg;\n                wo_1_reg <= wo_2_reg;\n                wo_2_reg <= wo_3_reg;\n                wo_3_reg <= (wo_0_reg ^ wo_1_reg ^ wo_2_reg ^ wo_3_reg ^ aes_rcon(rcnt)) ^ aes_sbox(wo_0_reg[7:0]);\n            end\n            else if (rcnt == 6) begin\n                wo_0_reg <= wo_1_reg;\n                wo_1_reg <= wo_2_reg;\n                wo_2_reg <= wo_3_reg;\n                wo_3_reg <= (wo_0_reg ^ wo_1_reg ^ wo_2_reg ^ wo_3_reg ^ wo_0_reg) ^ aes_sbox(wo_0_reg[7:0]);\n            end\n            else if (rcnt == 7) begin\n                wo_0_reg <= wo_1_reg;\n                wo_1_reg <= wo_2_reg;\n                wo_2_reg <= wo_3_reg;\n                wo_3_reg <= (wo_0_reg ^ wo_1_reg ^ wo_2_reg ^ wo_3_reg ^ wo_0_reg ^ wo_1_reg) ^ aes_sbox(wo_0_reg[7:0]);\n            end\n            else if (rcnt == 8) begin\n                wo_0_reg <= wo_1_reg;\n                wo_1_reg <= wo_2_reg;\n                wo_2_reg <= wo_3_reg;\n                wo_3_reg <= (wo_0_reg ^ wo_1_reg ^ wo_2_reg ^ wo_3_reg ^ wo_0_reg ^ wo_1_reg ^ wo_2_reg) ^ aes_sbox(wo_0_reg[7:0]);\n            end\n            else if (rcnt == 9) begin\n                wo_0_reg <= wo_1_reg;\n                wo_1_reg <= wo_2_reg;\n                wo_2_reg <= wo_3_reg;\n                wo_3_reg <= (wo_0_reg ^ wo_1_reg ^ wo_2_reg ^ wo_3_reg ^ wo_0_reg ^ wo_1_reg ^ wo_2_reg ^ wo_3_reg) ^ aes_sbox(wo_0_reg[7:0]);\n            end\n            else begin\n                wo_0_reg <= wo_1_reg;\n                wo_1_reg <= wo_2_reg;\n                wo_2_reg <= wo_3_reg;\n                wo_3_reg <= (wo_0_reg ^ wo_1_reg ^ wo_2_reg ^ wo_3_reg ^ wo_0_reg ^ wo_1_reg ^ wo_2_reg ^ wo_3_reg ^ aes_rcon(rcnt)) ^ aes_sbox(wo_0_reg[7:0]);\n            end\n            rcnt <= rcnt + 1;\n        end\n    end\n\n    assign wo_0 = wo_0_reg;\n    assign wo_1 = wo_1_reg;\n    assign wo_2 = wo_2_reg;\n    assign wo_3 = wo_3_reg;\n\nendmodule\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n    reg [31:0] out_reg;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out_reg <= 0;\n        end\n        else begin\n            if (rcnt == 0) begin\n                out_reg <= 32'h01;\n            end\n            else if (rcnt == 1) begin\n                out_reg <= 32'h02;\n            end\n            else if (rcnt == 2) begin\n                out_reg <= 32'h04;\n            end\n            else if (rcnt == 3) begin\n                out_reg <= 32'h08;\n            end\n            else if (rcnt == 4) begin\n                out_reg <= 32'h10;\n            end\n            else if (rcnt == 5) begin\n                out_reg <= 32'h20;\n            end\n            else if (rcnt == 6) begin\n                out_reg <= 32'h40;\n            end\n            else if (rcnt == 7) begin\n                out_reg <= 32'h80;\n            end\n            else if (rcnt == 8) begin\n                out_reg <= 32'h1b;\n            end\n            else if (rcnt == 9) begin\n                out_reg <= 32'h36;\n            end\n            else begin\n                out_reg <= 32'h00;\n            end\n            rcnt <= rcnt + 1;\n        end\n    end\n\n    assign out = out_reg;\n\nendmodule\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[255:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = aes_sbox_lookup(i);\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\n// aes_sbox_lookup module\nmodule aes_sbox_lookup(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[255:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = aes_sbox_calc(i);\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\n// aes_sbox_calc module\nmodule aes_sbox_calc(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] a_inv;\n    reg [7:0] b_inv;\n    reg [7:0] b;\n\n    assign a_inv = aes_inv(a);\n    assign b_inv = aes_affine(a_inv);\n    assign b = b_inv;\n\nendmodule\n// aes_inv module\nmodule aes_inv(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] b;\n\n    assign b = aes_inv_calc(a);\n\nendmodule\n// aes_inv_calc module\nmodule aes_inv_calc(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] b;\n\n    assign b = aes_inv_lookup(a);\n\nendmodule\n// aes_inv_lookup module\nmodule aes_inv_lookup(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] inv_sbox[255:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = aes_inv_calc(i);\n        end\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule\n// aes_affine module\nmodule aes_affine(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] b;\n\n    assign b = aes_affine_calc(a);\n\nendmodule\n// aes_affine_calc module\nmodule aes_affine_calc(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] b;\n\n    assign b = aes_affine_lookup(a);\n\nendmodule\n// aes_affine_lookup module\nmodule aes_affine_lookup(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] affine_sbox[255:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            affine_sbox[i] = aes_affine_calc(i);\n        end\n    end\n\n    assign b = affine_sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 1, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    assign done = (dcnt == 11) & (~ld_r);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 10;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n        end else if (kld) begin\n            kcnt <= 10;\n            kb[10] <= key[127:96];\n            kb[9] <= key[95:64];\n            kb[8] <= key[63:32];\n            kb[7] <= key[31:0];\n        end else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n            dcnt <= 1;\n        end else if (ld_r) begin\n            ld_r <= 0;\n            if (dcnt < 11) begin\n                dcnt <= dcnt + 1;\n            end\n        end else if (dcnt < 11) begin\n            if (dcnt == 0) begin\n                sa[0][0] <= text_in_r[7:0];\n                sa[0][1] <= text_in_r[15:8];\n                sa[0][2] <= text_in_r[23:16];\n                sa[0][3] <= text_in_r[31:24];\n                sa[1][0] <= text_in_r[39:32];\n                sa[1][1] <= text_in_r[47:40];\n                sa[1][2] <= text_in_r[55:48];\n                sa[1][3] <= text_in_r[63:56];\n                sa[2][0] <= text_in_r[71:64];\n                sa[2][1] <= text_in_r[79:72];\n                sa[2][2] <= text_in_r[87:80];\n                sa[2][3] <= text_in_r[95:88];\n                sa[3][0] <= text_in_r[103:96];\n                sa[3][1] <= text_in_r[111:104];\n                sa[3][2] <= text_in_r[119:112];\n                sa[3][3] <= text_in_r[127:120];\n            end else if (dcnt == 1) begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb[kcnt]);\n                InvMixColumns(sa);\n                kcnt <= kcnt - 1;\n            end else begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb[kcnt]);\n                kcnt <= kcnt - 1;\n            end\n        end else begin\n            text_out_r <= sa[0][0] << 120 | sa[0][1] << 112 | sa[0][2] << 104 | sa[0][3] << 96 |\n                          sa[1][0] << 88 | sa[1][1] << 80 | sa[1][2] << 72 | sa[1][3] << 64 |\n                          sa[2][0] << 56 | sa[2][1] << 48 | sa[2][2] << 40 | sa[2][3] << 32 |\n                          sa[3][0] << 24 | sa[3][1] << 16 | sa[3][2] << 8 | sa[3][3];\n        end\n    end\n\n    assign text_out = text_out_r;\n\n    module InvShiftRows(sa);\n        input [7:0] sa[0:3][0:3];\n        output [7:0] sa[0:3][0:3];\n\n        always @(posedge clk) begin\n            if (rst) begin\n                sa[0][0] <= 0;\n                sa[0][1] <= 0;\n                sa[0][2] <= 0;\n                sa[0][3] <= 0;\n                sa[1][0] <= 0;\n                sa[1][1] <= 0;\n                sa[1][2] <= 0;\n                sa[1][3] <= 0;\n                sa[2][0] <= 0;\n                sa[2][1] <= 0;\n                sa[2][2] <= 0;\n                sa[2][3] <= 0;\n                sa[3][0] <= 0;\n                sa[3][1] <= 0;\n                sa[3][2] <= 0;\n                sa[3][3] <= 0;\n            end else if (dcnt == 0) begin\n                sa[0][0] <= text_in_r[7:0];\n                sa[0][1] <= text_in_r[15:8];\n                sa[0][2] <= text_in_r[23:16];\n                sa[0][3] <= text_in_r[31:24];\n                sa[1][0] <= text_in_r[39:32];\n                sa[1][1] <= text_in_r[47:40];\n                sa[1][2] <= text_in_r[55:48];\n                sa[1][3] <= text_in_r[63:56];\n                sa[2][0] <= text_in_r[71:64];\n                sa[2][1] <= text_in_r[79:72];\n                sa[2][2] <= text_in_r[87:80];\n                sa[2][3] <= text_in_r[95:88];\n                sa[3][0] <= text_in_r[103:96];\n                sa[3][1] <= text_in_r[111:104];\n                sa[3][2] <= text_in_r[119:112];\n                sa[3][3] <= text_in_r[127:120];\n            end else begin\n                sa[0][0] <= sa[0][0];\n                sa[0][1] <= sa[0][1];\n                sa[0][2] <= sa[0][2];\n                sa[0][3] <= sa[0][3];\n                sa[1][0] <= sa[1][3];\n                sa[1][1] <= sa[1][0];\n                sa[1][2] <= sa[1][1];\n                sa[1][3] <= sa[1][2];\n                sa[2][0] <= sa[2][2];\n                sa[2][1] <= sa[2][3];\n                sa[2][2] <= sa[2][0];\n                sa[2][3] <= sa[2][1];\n                sa[3][0] <= sa[3][1];\n                sa[3][1] <= sa[3][2];\n                sa[3][2] <= sa[3][3];\n                sa[3][3] <= sa[3][0];\n            end\n        end\n    end\n\n    module InvSubBytes(sa);\n        input [7:0] sa[0:3][0:3];\n        output [7:0] sa[0:3][0:3];\n\n        reg [7:0] us[0:15];\n\n        initial begin\n            us[0] = 0x52;\n            us[1] = 0x09;\n            us[2] = 0x6f;\n            us[3] = 0x9b;\n            us[4] = 0x0b;\n            us[5] = 0x62;\n            us[6] = 0x0c;\n            us[7] = 0x1d;\n            us[8] = 0x2a;\n            us[9] = 0x33;\n            us[10] = 0x3a;\n            us[11] = 0x5a;\n            us[12] = 0x72;\n            us[13] = 0x7b;\n            us[14] = 0xf7;\n            us[15] = 0x81;\n        end\n\n        always @(posedge clk) begin\n            if (rst) begin\n                sa[0][0] <= 0;\n                sa[0][1] <= 0;\n                sa[0][2] <= 0;\n                sa[0][3] <= 0;\n                sa[1][0] <= 0;\n                sa[1][1] <= 0;\n                sa[1][2] <= 0;\n                sa[1][3] <= 0;\n                sa[2][0] <= 0;\n                sa[2][1] <= 0;\n                sa[2][2] <= 0;\n                sa[2][3] <= 0;\n                sa[3][0] <= 0;\n                sa[3][1] <= 0;\n                sa[3][2] <= 0;\n                sa[3][3] <= 0;\n            end else begin\n                for (int i = 0; i < 16; i++) begin\n                    if (sa[0][0] == us[i]) begin\n                        sa[0][0] <= i;\n                    end\n                    if (sa[0][1] == us[i]) begin\n                        sa[0][1] <= i;\n                    end\n                    if (sa[0][2] == us[i]) begin\n                        sa[0][2] <= i;\n                    end\n                    if (sa[0][3] == us[i]) begin\n                        sa[0][3] <= i;\n                    end\n                    if (sa[1][0] == us[i]) begin\n                        sa[1][0] <= i;\n                    end\n                    if (sa[1][1] == us[i]) begin\n                        sa[1][1] <= i;\n                    end\n                    if (sa[1][2] == us[i]) begin\n                        sa[1][2] <= i;\n                    end\n                    if (sa[1][3] == us[i]) begin\n                        sa[1][3] <= i;\n                    end\n                    if (sa[2][0] == us[i]) begin\n                        sa[2][0] <= i;\n                    end\n                    if (sa[2][1] == us[i]) begin\n                        sa[2][1] <= i;\n                    end\n                    if (sa[2][2] == us[i]) begin\n                        sa[2][2] <= i;\n                    end\n                    if (sa[2][3] == us[i]) begin\n                        sa[2][3] <= i;\n                    end\n                    if (sa[3][0] == us[i]) begin\n                        sa[3][0] <= i;\n                    end\n                    if (sa[3][1] == us[i]) begin\n                        sa[3][1] <= i;\n                    end\n                    if (sa[3][2] == us[i]) begin\n                        sa[3][2] <= i;\n                    end\n                    if (sa[3][3] == us[i]) begin\n                        sa[3][3] <= i;\n                    end\n                end\n            end\n        end\n    end\n\n    module InvMixColumns(sa);\n        input [7:0] sa[0:3][0:3];\n        output [7:0] sa[0:3][0:3];\n\n        reg [7:0] pmul_e[0:3];\n        reg [7:0] pmul_b[0:3];\n        reg [7:0] pmul_d[0:3];\n        reg [7:0] pmul_9[0:3];\n\n        initial begin\n            pmul_e[0] = 0x01;\n            pmul_e[1] = 0x02;\n            pmul_e[2] = 0x04;\n            pmul_e[3] = 0x08;\n            pmul_b[0] = 0x09;\n            pmul_b[1] = 0x0e;\n            pmul_b[2] = 0x0d;\n            pmul_b[3] = 0x0b;\n            pmul_d[0] = 0x0b;\n            pmul_d[1] = 0x0d;\n            pmul_d[2] = 0x0e;\n            pmul_d[3] = 0x09;\n            pmul_9[0] = 0x09;\n            pmul_9[1] = 0x0e;\n            pmul_9[2] = 0x0d;\n            pmul_9[3] = 0x0b;\n        end\n\n        always @(posedge clk) begin\n            if (rst) begin\n                sa[0][0] <= 0;\n                sa[0][1] <= 0;\n                sa[0][2] <= 0;\n                sa[0][3] <= 0;\n                sa[1][0] <= 0;\n                sa[1][1] <= 0;\n                sa[1][2] <= 0;\n                sa[1][3] <= 0;\n                sa[2][0] <= 0;\n                sa[2][1] <= 0;\n                sa[2][2] <= 0;\n                sa[2][3] <= 0;\n                sa[3][0] <= 0;\n                sa[3][1] <= 0;\n                sa[3][2] <= 0;\n                sa[3][3] <= 0;\n            end else begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= (sa[i][j] ^ (pmul_e[i] * sa[0][j])) ^ (pmul_b[i] * sa[1][j]) ^ (pmul_d[i] * sa[2][j]) ^ (pmul_9[i] * sa[3][j]);\n                    end\n                end\n            end\n        end\n    end\n\n    module AddRoundKey(sa, kb);\n        input [7:0] sa[0:3][0:3];\n        input [7:0] kb[0:3];\n        output [7:0] sa[0:3][0:3];\n\n        always @(posedge clk) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ kb[j];\n                end\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 16, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n        end else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n        end else if (ld_r) begin\n            ld_r <= 0;\n            if (dcnt == 0) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= text_in_r[8*i+j];\n                    end\n                end\n                dcnt <= 0xB;\n            end else if (dcnt > 0) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= aes_sbox(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] <<< j;\n                    end\n                end\n                if (dcnt < 0x0A) begin\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= (sa[i][j] ^ aes_mixcolumn(sa[i][j])) ^ key[8*i+j+dcnt*32];\n                        end\n                    end\n                end else begin\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= (sa[i][j] ^ aes_mixcolumn(sa[i][j])) ^ key[8*i+j+0x0A*32];\n                        end\n                    end\n                end\n                dcnt <= dcnt - 1;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            done <= 0;\n        end else if (ld_r) begin\n            if (dcnt == 0) begin\n                done <= 0;\n            end else if (dcnt == 0x0A) begin\n                done <= 1;\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        text_out_r[8*i+j] <= sa[i][j];\n                    end\n                end\n            end\n        end\n    end\n\n    assign text_out = text_out_r;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 17, "code": "// aes_cipher_top.v\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n        end\n        else if (ld) begin\n            text_in_r <= text_in;\n            dcnt <= 11;\n            ld_r <= 1;\n        end\n        else if (ld_r) begin\n            ld_r <= 0;\n            if (dcnt > 0) begin\n                dcnt <= dcnt - 1;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_out <= 0;\n        end\n        else if (ld_r) begin\n            if (dcnt == 0) begin\n                // Initial round key addition\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= text_in_r[8*i+j] ^ key[8*i+j];\n                    end\n                end\n                dcnt <= 10;\n            end\n            else if (dcnt < 10) begin\n                // SubBytes, ShiftRows, MixColumns, AddRoundKey\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= aes_sbox(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (i == 0) begin\n                            sa[i][j] <= sa[i][j];\n                        end\n                        else begin\n                            sa[i][j] <= sa[i][(j+1)%4];\n                        end\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= (sa[i][j] << 1) ^ (sa[i][j] >> 7) ^ (sa[(i+1)%4][j] << 1) ^ (sa[(i+1)%4][j] >> 7) ^ (sa[(i+2)%4][j] << 1) ^ (sa[(i+2)%4][j] >> 7) ^ (sa[(i+3)%4][j] << 1) ^ (sa[(i+3)%4][j] >> 7);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ aes_key_expand_128.sa[i][j];\n                    end\n                end\n                dcnt <= dcnt - 1;\n            end\n            else begin\n                // Final round\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= aes_sbox(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (i == 0) begin\n                            sa[i][j] <= sa[i][j];\n                        end\n                        else begin\n                            sa[i][j] <= sa[i][(j+1)%4];\n                        end\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= (sa[i][j] << 1) ^ (sa[i][j] >> 7) ^ (sa[(i+1)%4][j] << 1) ^ (sa[(i+1)%4][j] >> 7) ^ (sa[(i+2)%4][j] << 1) ^ (sa[(i+2)%4][j] >> 7) ^ (sa[(i+3)%4][j] << 1) ^ (sa[(i+3)%4][j] >> 7);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ aes_key_expand_128.sa[i][j];\n                    end\n                end\n                dcnt <= 0;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            done <= 0;\n        end\n        else if (ld_r && dcnt == 0) begin\n            done <= 1;\n        end\n        else begin\n            done <= 0;\n        end\n    end\n\n    assign text_out = {sa[0][0], sa[0][1], sa[0][2], sa[0][3], sa[1][0], sa[1][1], sa[1][2], sa[1][3], sa[2][0], sa[2][1], sa[2][2], sa[2][3], sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n\nendmodule\n\n// aes_key_expand_128.v\nmodule aes_key_expansion_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w[0:3];\n    reg [7:0] rcon;\n    reg [7:0] sbox[0:15];\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[31:0];\n            w[1] <= key[63:32];\n            w[2] <= key[95:64];\n            w[3] <= key[127:96];\n            wo_0 <= w[0];\n            wo_1 <= w[1];\n            wo_2 <= w[2];\n            wo_3 <= w[3];\n        end\n        else begin\n            if (w[0][7] == 1) begin\n                w[0] <= {w[0][7:0], w[0][6], w[0][5], w[0][4], w[0][3], w[0][2], w[0][1], w[0][0]};\n            end\n            w[0] <= {w[0][7:4], w[0][3], w[0][2], w[0][1], w[0][0], w[1][7], w[1][6], w[1][5]};\n            w[0] <= w[0] ^ aes_rcon(rcon);\n            w[1] <= {w[1][7:4], w[0][3], w[0][2], w[0][1], w[0][0], w[2][7], w[2][6], w[2][5]};\n            w[2] <= {w[2][7:4], w[1][3], w[1][2], w[1][1], w[1][0], w[3][7], w[3][6], w[3][5]};\n            w[3] <= {w[3][7:4], w[2][3], w[2][2], w[2][1], w[2][0], w[0][7], w[0][6], w[0][5]};\n            wo_0 <= w[0];\n            wo_1 <= w[1];\n            wo_2 <= w[2];\n            wo_3 <= w[3];\n            rcon <= rcon + 1;\n        end\n    end\n\n    assign w[0][7:0] = {sbox[w[0][7]], sbox[w[0][6]], sbox[w[0][5]], sbox[w[0][4]], sbox[w[0][3]], sbox[w[0][2]], sbox[w[0][1]], sbox[w[0][0]]};\n    assign w[1][7:0] = {sbox[w[1][7]], sbox[w[1][6]], sbox[w[1][5]], sbox[w[1][4]], sbox[w[1][3]], sbox[w[1][2]], sbox[w[1][1]], sbox[w[1][0]]};\n    assign w[2][7:0] = {sbox[w[2][7]], sbox[w[2][6]], sbox[w[2][5]], sbox[w[2][4]], sbox[w[2][3]], sbox[w[2][2]], sbox[w[2][1]], sbox[w[2][0]]};\n    assign w[3][7:0] = {sbox[w[3][7]], sbox[w[3][6]], sbox[w[3][5]], sbox[w[3][4]], sbox[w[3][3]], sbox[w[3][2]], sbox[w[3][1]], sbox[w[3][0]]};\n\nendmodule\n\n// aes_rcon.v\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end\n        else begin\n            if (rcnt < 9) begin\n                rcnt <= rcnt + 1;\n                out <= {rcnt, {24{1'b0}};\n            end\n            else begin\n                out <= 32'h00_00_00_00;\n            end\n        end\n    end\n\nendmodule\n\n// aes_sbox.v\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[0:255];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = aes_sbox_lookup(i);\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\n// aes_sbox_lookup.v\nmodule aes_sbox_lookup(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[0:255];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = aes_sbox_lookup_table[i];\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\n// aes_sbox_lookup_table.v\nmodule aes_sbox_lookup_table(\n    output [7:0] sbox[0:255]\n);\n\n    initial begin\n        sbox[0] = 0x63;\n        sbox[1] = 0x7c;\n        sbox[2] = 0x77;\n        sbox[3] = 0x7b;\n        sbox[4] = 0xf2;\n        sbox[5] = 0x6b;\n        sbox[6] = 0xf0;\n        sbox[7] = 0x78;\n        sbox[8] = 0xc6;\n        sbox[9] = 0xe3;\n        sbox[10] = 0x3f;\n        sbox[11] = 0x0f;\n        sbox[12] = 0x69;\n        sbox[13] = 0x1e;\n        sbox[14] = 0x51;\n        sbox[15] = 0x04;\n        sbox[16] = 0x9f;\n        sbox[17] = 0x2f;\n        sbox[18] = 0x5b;\n        sbox[19] = 0x46;\n        sbox[20] = 0x30;\n        sbox[21] = 0x61;\n        sbox[22] = 0x56;\n        sbox[23] = 0x35;\n        sbox[24] = 0xb5;\n        sbox[25] = 0x26;\n        sbox[26] = 0x77;\n        sbox[27] = 0x1c;\n        sbox[28] = 0x5e;\n        sbox[29] = 0x7d;\n        sbox[30] = 0x34;\n        sbox[31] = 0xa5;\n        sbox[32] = 0x58;\n        sbox[33] = 0x5a;\n        sbox[34] = 0x55;\n        sbox[35] = 0x2a;\n        sbox[36] = 0x7f;\n        sbox[37] = 0x3a;\n        sbox[38] = 0x78;\n        sbox[39] = 0x6e;\n        sbox[40] = 0x48;\n        sbox[41] = 0x03;\n        sbox[42] = 0xd3;\n        sbox[43] = 0x02;\n        sbox[44] = 0x1f;\n        sbox[45] = 0x6d;\n        sbox[46] = 0x5a;\n        sbox[47] = 0x5e;\n        sbox[48] = 0x15;\n        sbox[49] = 0x6a;\n        sbox[50] = 0x0d;\n        sbox[51] = 0x0a;\n        sbox[52] = 0x49;\n        sbox[53] = 0x6e;\n        sbox[54] = 0x9e;\n        sbox[55] = 0x71;\n        sbox[56] = 0x54;\n        sbox[57] = 0x7f;\n        sbox[58] = 0x7c;\n        sbox[59] = 0x7b;\n        sbox[60] = 0xfa;\n        sbox[61] = 0x6c;\n        sbox[62] = 0xa7;\n        sbox[63] = 0x1d;\n        sbox[64] = 0x19;\n        sbox[65] = 0x14;\n        sbox[66] = 0x9a;\n        sbox[67] = 0x86;\n        sbox[68] = 0xb8;\n        sbox[69] = 0x45;\n        sbox[70] = 0x75;\n        sbox[71] = 0x4b;\n        sbox[72] = 0x8a;\n        sbox[73] = 0x9f;\n        sbox[74] = 0x93;\n        sbox[75] = 0x4d;\n        sbox[76] = 0x68;\n        sbox[77] = 0x01;\n        sbox[78] = 0x34;\n        sbox[79] = 0x4c;\n        sbox[80] = 0x5d;\n        sbox[81] = 0x2a;\n        sbox[82] = 0x7d;\n        sbox[83] = 0x4e;\n        sbox[84] = 0x73;\n        sbox[85] = 0x96;\n        sbox[86] = 0x91;\n        sbox[87] = 0x35;\n        sbox[88] = 0x8e;\n        sbox[89] = 0x37;\n        sbox[90] = 0x7b;\n        sbox[91] = 0x7c;\n        sbox[92] = 0x33;\n        sbox[93] = 0x82;\n        sbox[94] = 0xc9;\n        sbox[95] = 0x2f;\n        sbox[96] = 0x6d;\n        sbox[97] = 0x3f;\n        sbox[98] = 0x5e;\n        sbox[99] = 0xb6;\n        sbox[100] = 0x60;\n        sbox[101] = 0x91;\n        sbox[102] = 0x85;\n        sbox[103] = 0x98;\n        sbox[104] = 0x4f;\n        sbox[105] = 0x79;\n        sbox[106] = 0x6e;\n        sbox[107] = 0x3e;\n        sbox[108] = 0x67;\n        sbox[109] = 0x0b;\n        sbox[110] = 0xfe;\n        sbox[111] = 0x4a;\n        sbox[112] = 0x59;\n        sbox[113] = 0x4c;\n        sbox[114] = 0x56;\n        sbox[115] = 0x1c;\n        sbox[116] = 0x54;\n        sbox[117] = 0x7f;\n        sbox[118] = 0x8c;\n        sbox[119] = 0xa1;\n        sbox[120] = 0x1b;\n        sbox[121] = 0x82;\n        sbox[122] = 0xc1;\n        sbox[123] = 0x00;\n        sbox[124] = 0x79;\n        sbox[125] = 0xe5;\n        sbox[126] = 0x2a;\n        sbox[127] = 0x1d;\n        sbox[128] = 0x37;\n        sbox[129] = 0x2d;\n        sbox[130] = 0x9d;\n        sbox[131] = 0x59;\n        sbox[132] = 0x05;\n        sbox[133] = 0x2a;\n        sbox[134] = 0x7d;\n        sbox[135] = 0x35;\n        sbox[136] = 0x4a;\n        sbox[137] = 0x42;\n        sbox[138] = 0x7f;\n        sbox[139] = 0x5a;\n        sbox[140] = 0xc4;\n        sbox[141] = 0x5d;\n        sbox[142] = 0x2f;\n        sbox[143] = 0x80;\n        sbox[144] = 0x77;\n        sbox[145] = 0x3a;\n        sbox[146] = 0x5c;\n        sbox[147] = 0x7d;\n        sbox[148] = 0x4f;\n        sbox[149] = 0x60;\n        sbox[150] = 0x1f;\n        sbox[151] = 0x4d;\n        sbox[152] = 0x65;\n        sbox[153] = 0x56;\n        sbox[154] = 0x31;\n        sbox[155] = 0x13;\n        sbox[156] = 0x38;\n        sbox[157] = 0x25;\n        sbox[158] = 0x43;\n        sbox[159] = 0x09;\n        sbox[160] = 0x1c;\n        sbox[161] = 0x46;\n        sbox[162] = 0x29;\n        sbox[163] = 0x53;\n        sbox[164] = 0x72;\n        sbox[165] = 0x17;\n        sbox[166] = 0xa2;\n        sbox[167] = 0x51;\n        sbox[168] = 0x3a;\n        sbox[169] = 0x28;\n        sbox[170] = 0x77;\n        sbox[171] = 0x5e;\n        sbox[172] = 0x48;\n        sbox[173] = 0x94;\n        sbox[174] = 0x33;\n        sbox[175] = 0x14;\n        sbox[176] = 0x55;\n        sbox[177] = 0x20;\n        sbox[178] = 0x85;\n        sbox[179] = 0x45;\n        sbox[180] = 0xf9;\n        sbox[181] = 0x02;\n        sbox[182] = 0xa7;\n        sbox[183] = 0x62;\n        sbox[184] = 0x3b;\n        sbox[185] = 0x76;\n        sbox[186] = 0xc5;\n        sbox[187] = 0x32;\n        sbox[188] = 0x1b;\n        sbox[189] = 0x2f;\n        sbox[190] = 0x65;\n        sbox[191] = 0x2c;\n        sbox[192] = 0x7a;\n        sbox[193] = 0x7d;\n        sbox[194] = 0x5a;\n        sbox[195] = 0x39;\n        sbox[196] = 0x4c;\n        sbox[197] = 0x4d;\n        sbox[198] = 0x63;\n        sbox[199] = 0x0f;\n        sbox[200] = 0x9a;\n        sbox[201] = 0x8d;\n        sbox[202] = 0x1f;\n        sbox[203] = 0x6d;\n        sbox[204] = 0x80;\n        sbox[205] = 0xe4;\n        sbox[206] = 0x5f;\n        sbox[207] = 0x6f;\n        sbox[208] = 0x8c;\n        sbox[209] = 0x02;\n        sbox[210] = 0x1b;\n        sbox[211] = 0x0a;\n        sbox[212] = 0x7d;\n        sbox[213] = 0x18;\n        sbox[214] = 0x4e;\n        sbox[215] = 0x8b;\n        sbox[216] = 0x22;\n        sbox[217] = 0x9a;\n        sbox[218] = 0x0d;\n        sbox[219] = 0x2d;\n        sbox[220] = 0x98;\n        sbox[221] = 0x10;\n        sbox[222] = 0x11;\n        sbox[223] = 0x13;\n        sbox[224] = 0x70;\n        sbox[225] = 0x4f;\n        sbox[226] = 0x8e;\n        sbox[227] = 0x43;\n        sbox[228] = 0x49;\n        sbox[229] = 0x87;\n        sbox[230] = 0x7e;\n        sbox[231] = 0x9f;\n        sbox[232] = 0x15;\n        sbox[233] = 0x00;\n        sbox[234] = 0x8c;\n        sbox[235] = 0x81;\n        sbox[236] = 0x4f;\n        sbox[237] = 0x45;\n        sbox[238] = 0x75;\n        sbox[239] = 0x3b;\n        sbox[240] = 0x3d;\n        sbox[241] = 0x3a;\n        sbox[242] = 0x09;\n        sbox[243] = 0x8b;\n        sbox[244] = 0x1f;\n        sbox[245] = 0x79;\n        sbox[246] = 0x6e;\n        sbox[247] = 0x3e;\n        sbox[248] = 0x7c;\n        sbox[249] = 0x7b;\n        sbox[250] = 0x6f;\n        sbox[251] = 0x5c;\n        sbox[252] = 0x1d;\n        sbox[253] = 0x4b;\n        sbox[254] = 0x4c;\n        sbox[255] = 0x95;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 2, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n              sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n              sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n              sa[3][0], sa[3][1], sa[3][2], sa[3][3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    // Key Expansion Module\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    // Inverse S-box Module\n    aes_inv_sbox aes_inv_sbox_00(\n        .a(sa[0][0]),\n        .b(us00)\n    );\n    aes_inv_sbox aes_inv_sbox_01(\n        .a(sa[0][1]),\n        .b(us01)\n    );\n    aes_inv_sbox aes_inv_sbox_02(\n        .a(sa[0][2]),\n        .b(us02)\n    );\n    aes_inv_sbox aes_inv_sbox_03(\n        .a(sa[0][3]),\n        .b(us03)\n    );\n    aes_inv_sbox aes_inv_sbox_10(\n        .a(sa[1][0]),\n        .b(us10)\n    );\n    aes_inv_sbox aes_inv_sbox_11(\n        .a(sa[1][1]),\n        .b(us11)\n    );\n    aes_inv_sbox aes_inv_sbox_12(\n        .a(sa[1][2]),\n        .b(us12)\n    );\n    aes_inv_sbox aes_inv_sbox_13(\n        .a(sa[1][3]),\n        .b(us13)\n    );\n    aes_inv_sbox aes_inv_sbox_20(\n        .a(sa[2][0]),\n        .b(us20)\n    );\n    aes_inv_sbox aes_inv_sbox_21(\n        .a(sa[2][1]),\n        .b(us21)\n    );\n    aes_inv_sbox aes_inv_sbox_22(\n        .a(sa[2][2]),\n        .b(us22)\n    );\n    aes_inv_sbox aes_inv_sbox_23(\n        .a(sa[2][3]),\n        .b(us23)\n    );\n    aes_inv_sbox aes_inv_sbox_30(\n        .a(sa[3][0]),\n        .b(us30)\n    );\n    aes_inv_sbox aes_inv_sbox_31(\n        .a(sa[3][1]),\n        .b(us31)\n    );\n    aes_inv_sbox aes_inv_sbox_32(\n        .a(sa[3][2]),\n        .b(us32)\n    );\n    aes_inv_sbox aes_inv_sbox_33(\n        .a(sa[3][3]),\n        .b(us33)\n    );\n\n    // InvShiftRows\n    assign sa[0][0] = sa[0][0];\n    assign sa[1][0] = sa[1][3];\n    assign sa[2][0] = sa[2][2];\n    assign sa[3][0] = sa[3][1];\n\n    assign sa[0][1] = sa[0][1];\n    assign sa[1][1] = sa[1][0];\n    assign sa[2][1] = sa[2][3];\n    assign sa[3][1] = sa[3][2];\n\n    assign sa[0][2] = sa[0][2];\n    assign sa[1][2] = sa[1][1];\n    assign sa[2][2] = sa[2][0];\n    assign sa[3][2] = sa[3][3];\n\n    assign sa[0][3] = sa[0][3];\n    assign sa[1][3] = sa[1][2];\n    assign sa[2][3] = sa[2][1];\n    assign sa[3][3] = sa[3][0];\n\n    // InvSubBytes\n    assign sa_ark = us00 ^ wk0[0] ^ wk0[1] ^ wk0[2] ^ wk0[3];\n    assign sa_ark1 = us01 ^ wk0[4] ^ wk0[5] ^ wk0[6] ^ wk0[7];\n    assign sa_ark2 = us02 ^ wk0[8] ^ wk0[9] ^ wk0[10] ^ wk0[11];\n    assign sa_ark3 = us03 ^ wk0[12] ^ wk0[13] ^ wk0[14] ^ wk0[15];\n    assign sa_ark4 = us10 ^ wk1[0] ^ wk1[1] ^ wk1[2] ^ wk1[3];\n    assign sa_ark5 = us11 ^ wk1[4] ^ wk1[5] ^ wk1[6] ^ wk1[7];\n    assign sa_ark6 = us12 ^ wk1[8] ^ wk1[9] ^ wk1[10] ^ wk1[11];\n    assign sa_ark7 = us13 ^ wk1[12] ^ wk1[13] ^ wk1[14] ^ wk1[15];\n    assign sa_ark8 = us20 ^ wk2[0] ^ wk2[1] ^ wk2[2] ^ wk2[3];\n    assign sa_ark9 = us21 ^ wk2[4] ^ wk2[5] ^ wk2[6] ^ wk2[7];\n    assign sa_ark10 = us22 ^ wk2[8] ^ wk2[9] ^ wk2[10] ^ wk2[11];\n    assign sa_ark11 = us23 ^ wk2[12] ^ wk2[13] ^ wk2[14] ^ wk2[15];\n    assign sa_ark12 = us30 ^ wk3[0] ^ wk3[1] ^ wk3[2] ^ wk3[3];\n    assign sa_ark13 = us31 ^ wk3[4] ^ wk3[5] ^ wk3[6] ^ wk3[7];\n    assign sa_ark14 = us32 ^ wk3[8] ^ wk3[9] ^ wk3[10] ^ wk3[11];\n    assign sa_ark15 = us33 ^ wk3[12] ^ wk3[13] ^ wk3[14] ^ wk3[15];\n\n    // InvMixColumns\n    assign sa_next[0] = (sa_ark ^ sa_ark1 ^ sa_ark2 ^ sa_ark3) << 8;\n    assign sa_next[1] = (sa_ark4 ^ sa_ark5 ^ sa_ark6 ^ sa_ark7) << 8;\n    assign sa_next[2] = (sa_ark8 ^ sa_ark9 ^ sa_ark10 ^ sa_ark11) << 8;\n    assign sa_next[3] = (sa_ark12 ^ sa_ark13 ^ sa_ark14 ^ sa_ark15) << 8;\n\n    // AddRoundKey\n    assign sa_next[0] = sa_next[0] ^ wk0;\n    assign sa_next[1] = sa_next[1] ^ wk1;\n    assign sa_next[2] = sa_next[2] ^ wk2;\n    assign sa_next[3] = sa_next[3] ^ wk3;\n\n    // State Transition Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 10;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n        end\n        else if (kld) begin\n            kcnt <= 10;\n            ld_r <= 0;\n            text_in_r <= text_in;\n        end\n        else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n        end\n        else if (ld_r) begin\n            if (dcnt == 0) begin\n                ld_r <= 0;\n                text_out_r <= sa_next[0] << 24 | sa_next[1] << 16 | sa_next[2] << 8 | sa_next[3];\n                done <= 1;\n            end\n            else begin\n                dcnt <= dcnt + 1;\n                ld_r <= 0;\n            end\n        end\n        else begin\n            if (kcnt > 0) begin\n                kcnt <= kcnt - 1;\n                kb[kcnt] <= wk3;\n            end\n            if (dcnt < 10) begin\n                dcnt <= dcnt + 1;\n            end\n        end\n    end\n\n    // Output\n    assign text_out = text_out_r;\n\nendmodule\n// aes_key_expand_128 module\nmodule aes_key_expansion_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_r;\n    reg [31:0] wk0, wk1, wk2, wk3;\n    reg [3:0] kcnt;\n    reg [3:0] rcnt;\n    reg [31:0] rcon;\n\n    // Key Buffer\n    reg [127:0] kb[10:0];\n\n    // Round Constant Generator\n    aes_rcon aes_rcon(\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    // S-box\n    aes_sbox aes_sbox_00(\n        .a(key_r[7:0]),\n        .b(wk0[0])\n    );\n    aes_sbox aes_sbox_01(\n        .a(key_r[15:8]),\n        .b(wk0[1])\n    );\n    aes_sbox aes_sbox_02(\n        .a(key_r[23:16]),\n        .b(wk0[2])\n    );\n    aes_sbox aes_sbox_03(\n        .a(key_r[31:24]),\n        .b(wk0[3])\n    );\n    aes_sbox aes_sbox_10(\n        .a(key_r[39:32]),\n        .b(wk1[0])\n    );\n    aes_sbox aes_sbox_11(\n        .a(key_r[47:40]),\n        .b(wk1[1])\n    );\n    aes_sbox aes_sbox_12(\n        .a(key_r[55:48]),\n        .b(wk1[2])\n    );\n    aes_sbox aes_sbox_13(\n        .a(key_r[63:56]),\n        .b(wk1[3])\n    );\n    aes_sbox aes_sbox_20(\n        .a(key_r[71:64]),\n        .b(wk2[0])\n    );\n    aes_sbox aes_sbox_21(\n        .a(key_r[79:72]),\n        .b(wk2[1])\n    );\n    aes_sbox aes_sbox_22(\n        .a(key_r[87:80]),\n        .b(wk2[2])\n    );\n    aes_sbox aes_sbox_23(\n        .a(key_r[95:88]),\n        .b(wk2[3])\n    );\n    aes_sbox aes_sbox_30(\n        .a(key_r[103:96]),\n        .b(wk3[0])\n    );\n    aes_sbox aes_sbox_31(\n        .a(key_r[111:104]),\n        .b(wk3[1])\n    );\n    aes_sbox aes_sbox_32(\n        .a(key_r[119:112]),\n        .b(wk3[2])\n    );\n    aes_sbox aes_sbox_33(\n        .a(key_r[127:120]),\n        .b(wk3[3])\n    );\n\n    // Key Expansion Logic\n    always @(posedge clk) begin\n        if (kld) begin\n            key_r <= key;\n            wk0 <= 0;\n            wk1 <= 0;\n            wk2 <= 0;\n            wk3 <= 0;\n            kcnt <= 10;\n            rcnt <= 0;\n        end\n        else if (kcnt > 0) begin\n            kcnt <= kcnt - 1;\n            if (rcnt == 0) begin\n                wk0 <= {wk0[24:0], rcon};\n            end\n            else begin\n                wk0 <= {wk0[24:0], wk0[23:0]};\n            end\n            if (rcnt == 1) begin\n                wk1 <= {wk1[24:0], wk0[23:0]};\n            end\n            else begin\n                wk1 <= {wk1[24:0], wk1[23:0]};\n            end\n            if (rcnt == 2) begin\n                wk2 <= {wk2[24:0], wk1[23:0]};\n            end\n            else begin\n                wk2 <= {wk2[24:0], wk2[23:0]};\n            end\n            if (rcnt == 3) begin\n                wk3 <= {wk3[24:0], wk2[23:0]};\n            end\n            else begin\n                wk3 <= {wk3[24:0], wk3[23:0]};\n            end\n            if (rcnt == 4) begin\n                wk0 <= {wk0[24:0], wk3[23:0]};\n            end\n            if (rcnt == 5) begin\n                wk1 <= {wk1[24:0], wk0[23:0]};\n            end\n            if (rcnt == 6) begin\n                wk2 <= {wk2[24:0], wk1[23:0]};\n            end\n            if (rcnt == 7) begin\n                wk3 <= {wk3[24:0], wk2[23:0]};\n            end\n            if (rcnt == 8) begin\n                wk0 <= {wk0[24:0], wk3[23:0]};\n            end\n            if (rcnt == 9) begin\n                wk1 <= {wk1[24:0], wk0[23:0]};\n            end\n            if (rcnt == 10) begin\n                wk2 <= {wk2[24:0], wk1[23:0]};\n            end\n            if (rcnt == 11) begin\n                wk3 <= {wk3[24:0], wk2[23:0]};\n            end\n            rcnt <= rcnt + 1;\n        end\n        else begin\n            wo_0 <= wk0;\n            wo_1 <= wk1;\n            wo_2 <= wk2;\n            wo_3 <= wk3;\n        end\n    end\n\nendmodule\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n    reg [31:0] rcon;\n\n    // Round Constant Generator\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h00000001;\n        end\n        else begin\n            if (rcnt == 0) begin\n                out <= 32'h00000001;\n            end\n            else if (rcnt == 1) begin\n                out <= 32'h00000002;\n            end\n            else if (rcnt == 2) begin\n                out <= 32'h00000004;\n            end\n            else if (rcnt == 3) begin\n                out <= 32'h00000008;\n            end\n            else if (rcnt == 4) begin\n                out <= 32'h00000010;\n            end\n            else if (rcnt == 5) begin\n                out <= 32'h00000020;\n            end\n            else if (rcnt == 6) begin\n                out <= 32'h00000040;\n            end\n            else if (rcnt == 7) begin\n                out <= 32'h00000080;\n            end\n            else if (rcnt == 8) begin\n                out <= 32'h0000001b;\n            end\n            else if (rcnt == 9) begin\n                out <= 32'h00000036;\n            end\n            else if (rcnt == 10) begin\n                out <= 32'h0000006c;\n            end\n            else begin\n                out <= 32'h00000000;\n            end\n            rcnt <= rcnt + 1;\n        end\n    end\n\nendmodule\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // Inverse S-box Table\n    reg [7:0] inv_sbox[255:0];\n\n    // Inverse S-box Implementation\n    assign b = inv_sbox[a];\n\nendmodule\n// aes_inv_sbox module\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // Inverse S-box Table\n    reg [7:0] inv_sbox[255:0];\n\n    // Inverse S-box Implementation\n    assign b = inv_sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 18, "code": "```verilog\n// aes_cipher_top.v\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            dcnt <= 0;\n            ld_r <= 0;\n        end\n        else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1;\n            dcnt <= 11;\n        end\n        else begin\n            if (dcnt > 0) begin\n                ld_r <= 0;\n                dcnt <= dcnt - 1;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (ld_r) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n        end\n        else begin\n            if (dcnt == 0) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ key[8*i + j];\n                    end\n                end\n                dcnt <= dcnt + 1;\n            end\n            else if (dcnt > 0) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= SubBytes(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= ShiftRows(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= MixColumns(sa[i][j]);\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ key[8*i + j];\n                    end\n                end\n                dcnt <= dcnt - 1;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (ld_r) begin\n            text_out_r <= text_in_r;\n        end\n        else begin\n            if (dcnt == 0) begin\n                text_out_r <= text_out_r;\n            end\n            else if (dcnt > 0) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        text_out_r[8*i + j] <= sa[i][j];\n                    end\n                end\n                dcnt <= dcnt - 1;\n            end\n        end\n    end\n\n    assign done = (dcnt == 0);\n    assign text_out = text_out_r;\n\n    // SubBytes function\n    function [7:0] SubBytes([7:0] a);\n        case (a)\n            8'b00000000: SubBytes = 8'b63;\n            8'b00000001: SubBytes = 8'b9d;\n            8'b00000010: SubBytes = 8'bc;\n            8'b00000011: SubBytes = 8'bd;\n            8'b00000100: SubBytes = 8'be;\n            8'b00000101: SubBytes = 8'bf;\n            8'b00000110: SubBytes = 8'c1;\n            8'b00000111: SubBytes = 8'40;\n            8'b00001000: SubBytes = 8'9f;\n            8'b00001001: SubBytes = 8'a4;\n            8'b00001010: SubBytes = 8'aa;\n            8'b00001011: SubBytes = 8'ac;\n            8'b00001100: SubBytes = 8'c5;\n            8'b00001101: SubBytes = 8'f7;\n            8'b00001110: SubBytes = 8'38;\n            8'b00001111: SubBytes = 8'5b;\n            8'b00010000: SubBytes = 8'f5;\n            8'b00010001: SubBytes = 8'85;\n            8'b00010010: SubBytes = 8'f2;\n            8'b00010011: SubBytes = 8'ca;\n            8'b00010100: SubBytes = 8'92;\n            8'b00010101: SubBytes = 8'9d;\n            8'b00010110: SubBytes = 8'83;\n            8'b00010111: SubBytes = 8'1b;\n            8'b00011000: SubBytes = 8'6b;\n            8'b00011001: SubBytes = 8'0e;\n            8'b00011010: SubBytes = 8'47;\n            8'b00011011: SubBytes = 8'57;\n            8'b00011100: SubBytes = 8'6c;\n            8'b00011101: SubBytes = 8'7f;\n            8'b00011110: SubBytes = 8'9c;\n            8'b00011111: SubBytes = 8'8f;\n            8'b00100000: SubBytes = 8'74;\n            8'b00100001: SubBytes = 8'4e;\n            8'b00100010: SubBytes = 8'10;\n            8'b00100011: SubBytes = 8'49;\n            8'b00100100: SubBytes = 8'6d;\n            8'b00100101: SubBytes = 8'95;\n            8'b00100110: SubBytes = 8'79;\n            8'b00100111: SubBytes = 8'7a;\n            8'b00101000: SubBytes = 8'15;\n            8'b00101001: SubBytes = 8'5a;\n            8'b00101010: SubBytes = 8'5e;\n            8'b00101011: SubBytes = 8'70;\n            8'b00101100: SubBytes = 8'4a;\n            8'b00101101: SubBytes = 8'71;\n            8'b00101110: SubBytes = 8'13;\n            8'b00101111: SubBytes = 8'74;\n            8'b00110000: SubBytes = 8'0b;\n            8'b00110001: SubBytes = 8'0d;\n            8'b00110010: SubBytes = 8'0f;\n            8'b00110011: SubBytes = 8'17;\n            8'b00110100: SubBytes = 8'1d;\n            8'b00110101: SubBytes = 8'1f;\n            8'b00110110: SubBytes = 8'25;\n            8'b00110111: SubBytes = 8'2a;\n            8'b00111000: SubBytes = 8'2e;\n            8'b00111001: SubBytes = 8'35;\n            8'b00111010: SubBytes = 8'3b;\n            8'b00111011: SubBytes = 8'39;\n            8'b00111100: SubBytes = 8'38;\n            8'b00111101: SubBytes = 8'45;\n            8'b00111110: SubBytes = 8'4b;\n            8'b00111111: SubBytes = 8'4f;\n            8'b01000000: SubBytes = 8'5b;\n            8'b01000001: SubBytes = 8'6b;\n            8'b01000010: SubBytes = 8'6f;\n            8'b01000011: SubBytes = 8'77;\n            8'b01000100: SubBytes = 8'7f;\n            8'b01000101: SubBytes = 8'83;\n            8'b01000110: SubBytes = 8'89;\n            8'b01000111: SubBytes = 8'8f;\n            8'b01001000: SubBytes = 8'9f;\n            8'b01001001: SubBytes = 8'a5;\n            8'b01001010: SubBytes = 8'ab;\n            8'b01001011: SubBytes = 8'af;\n            8'b01001100: SubBytes = 8'b1;\n            8'b01001101: SubBytes = 8'b5;\n            8'b01001110: SubBytes = 8'b9;\n            8'b01001111: SubBytes = 8'bf;\n            8'b01010000: SubBytes = 8'1d;\n            8'b01010001: SubBytes = 8'1f;\n            8'b01010010: SubBytes = 8'23;\n            8'b01010011: SubBytes = 8'29;\n            8'b01010100: SubBytes = 8'2f;\n            8'b01010101: SubBytes = 8'35;\n            8'b01010110: SubBytes = 8'3b;\n            8'b01010111: SubBytes = 8'3f;\n            8'b01011000: SubBytes = 8'43;\n            8'b01011001: SubBytes = 8'4b;\n            8'b01011010: SubBytes = 8'4f;\n            8'b01011011: SubBytes = 8'55;\n            8'b01011100: SubBytes = 8'5b;\n            8'b01011101: SubBytes = 8'61;\n            8'b01011110: SubBytes = 8'67;\n            8'b01011111: SubBytes = 8'6f;\n            8'b01100000: SubBytes = 8'75;\n            8'b01100001: SubBytes = 8'7d;\n            8'b01100010: SubBytes = 8'83;\n            8'b01100011: SubBytes = 8'8b;\n            8'b01100100: SubBytes = 8'91;\n            8'b01100101: SubBytes = 8'99;\n            8'b01100110: SubBytes = 8'9f;\n            8'b01100111: SubBytes = 8'a5;\n            8'b01101000: SubBytes = 8'ab;\n            8'b01101001: SubBytes = 8'b1;\n            8'b01101010: SubBytes = 8'b5;\n            8'b01101011: SubBytes = 8'b9;\n            8'b01101100: SubBytes = 8'bf;\n            8'b01101101: SubBytes = 8'c7;\n            8'b01101110: SubBytes = 8'd1;\n            8'b01101111: SubBytes = 8'd5;\n            8'b01110000: SubBytes = 8'd9;\n            8'b01110001: SubBytes = 8'ef;\n            8'b01110010: SubBytes = 8'f3;\n            8'b01110011: SubBytes = 8'f7;\n            8'b01110100: SubBytes = 8'fb;\n            8'b01110101: SubBytes = 8'ff;\n            8'b01110110: SubBytes = 8'0b;\n            8'b01110111: SubBytes = 8'0f;\n            8'b01111000: SubBytes = 8'15;\n            8'b01111001: SubBytes = 8'19;\n            8'b01111010: SubBytes = 8'1d;\n            8'b01111011: SubBytes = 8'21;\n            8'b01111100: SubBytes = 8'27;\n            8'b01111101: SubBytes = 8'2b;\n            8'b01111110: SubBytes = 8'2f;\n            8'b01111111: SubBytes = 8'33;\n            8'b10000000: SubBytes = 8'37;\n            8'b10000001: SubBytes = 8'3b;\n            8'b10000010: SubBytes = 8'3f;\n            8'b10000011: SubBytes = 8'43;\n            8'b10000100: SubBytes = 8'47;\n            8'b10000101: SubBytes = 8'4b;\n            8'b10000110: SubBytes = 8'4f;\n            8'b10000111: SubBytes = 8'53;\n            8'b10001000: SubBytes = 8'57;\n            8'b10001001: SubBytes = 8'5b;\n            8'b10001010: SubBytes = 8'5f;\n            8'b10001011: SubBytes = 8'63;\n            8'b10001100: SubBytes = 8'67;\n            8'b10001101: SubBytes = 8'6b;\n            8'b10001110: SubBytes = 8'6f;\n            8'b10001111: SubBytes = 8'73;\n            8'b10010000: SubBytes = 8'77;\n            8'b10010001: SubBytes = 8'7b;\n            8'b10010010: SubBytes = 8'7f;\n            8'b10010011: SubBytes = 8'83;\n            8'b10010100: SubBytes = 8'87;\n            8'b10010101: SubBytes = 8'8b;\n            8'b10010110: SubBytes = 8'8f;\n            8'b10010111: SubBytes = 8'93;\n            8'b10011000: SubBytes = 8'97;\n            8'b10011001: SubBytes = 8'9b;\n            8'b10011010: SubBytes = 8'9f;\n            8'b10011011: SubBytes = 8'a3;\n            8'b10011100: SubBytes = 8'a7;\n            8'b10011101: SubBytes = 8'ab;\n            8'b10011110: SubBytes = 8'af;\n            8'b10011111: SubBytes = 8'b1;\n            8'b10100000: SubBytes = 8'b5;\n            8'b10100001: SubBytes = 8'b9;\n            8'b10100010: SubBytes = 8'bd;\n            8'b10100011: SubBytes = 8'bf;\n            8'b10100100: SubBytes = 8'c3;\n            8'b10100101: SubBytes = 8'c7;\n            8'b10100110: SubBytes = 8'cb;\n            8'b10100111: SubBytes = 8'cf;\n            8'b10101000: SubBytes = 8'd1;\n            8'b10101001: SubBytes = 8'd5;\n            8'b10101010: SubBytes = 8'd9;\n            8'b10101011: SubBytes = 8'dd;\n            8'b10101100: SubBytes = 8'df;\n            8'b10101101: SubBytes = 8'e3;\n            8'b10101110: SubBytes = 8'e7;\n            8'b10101111: SubBytes = 8'eb;\n            8'b10110000: SubBytes = 8'f1;\n            8'b10110001: SubBytes = 8'f5;\n            8'b10110010: SubBytes = 8'f9;\n            8'b10110011: SubBytes = 8'fd;\n            8'b10110100: SubBytes = 8'01;\n            8'b10110101: SubBytes = 8'05;\n            8'b10110110: SubBytes = 8'09;\n            8'b10110111: SubBytes = 8'0d;\n            8'b10111000: SubBytes = 8'11;\n            8'b10111001: SubBytes = 8'15;\n            8'b10111010: SubBytes = 8'19;\n            8'b10111011: SubBytes = 8'1d;\n            8'b10111100: SubBytes = 8'21;\n            8'b10111101: SubBytes = 8'25;\n            8'b10111110: SubBytes = 8'29;\n            8'b10111111: SubBytes = 8'2d;\n            8'b11000000: SubBytes = 8'2f;\n            8'b11000001: SubBytes = 8'33;\n            8'b11000010: SubBytes = 8'37;\n            8'b11000011: SubBytes = 8'3b;\n            8'b11000100: SubBytes = 8'3f;\n            8'b11000101: SubBytes = 8'43;\n            8'b11000110: SubBytes = 8'47;\n            8'b11000111: SubBytes = 8'4b;\n            8'b11001000: SubBytes = 8'4f;\n            8'b11001001: SubBytes = 8'53;\n            8'b11001010: SubBytes = 8'57;\n            8'b11001011: SubBytes = 8'5b;\n            8'b11001100: SubBytes = 8'5f;\n            8'b11001101: SubBytes = 8'63;\n            8'b11001110: SubBytes = 8'67;\n            8'b11001111: SubBytes = 8'6b;\n            8'b11010000: SubBytes = 8'6f;\n            8'b11010001: SubBytes = 8'73;\n            8'b11010010: SubBytes = 8'77;\n            8'b11010011: SubBytes = 8'7b;\n            8'b11010100: SubBytes = 8'7f;\n            8'b11010101: SubBytes = 8'83;\n            8'b11010110: SubBytes = 8'87;\n            8'b11010111: SubBytes = 8'8b;\n            8'b11011000: SubBytes = 8'8f;\n            8'b11011001: SubBytes = 8'93;\n            8'b11011010: SubBytes = 8'97;\n            8'b11011011: SubBytes = 8'9b;\n            8'b11011100: SubBytes = 8'9f;\n            8'b11011101: SubBytes = 8'a3;\n            8'b11011110: SubBytes = 8'a7;\n            8'b11011111: SubBytes = 8'ab;\n            8'b11100000: SubBytes = 8'af;\n            8'b11100001: SubBytes = 8'b1;\n            8'b11100010: SubBytes = 8'b5;\n            8'b11100011: SubBytes = 8'b9;\n            8'b11100100: SubBytes = 8'bd;\n            8'b11100101: SubBytes = 8'bf;\n            8'b11100110: SubBytes = 8'c3;\n            8'b11100111: SubBytes = 8'c7;\n            8'b11101000: SubBytes = 8'cb;\n            8'b11101001: SubBytes = 8'cf;\n            8'b11101010: SubBytes = 8'd1;\n            8'b11101011: SubBytes = 8'd5;\n            8'b11101100: SubBytes = 8'd9;\n            8'b11101101: SubBytes = 8'dd;\n            8'b11101110: SubBytes = 8'df;\n            8'b11101111: SubBytes = 8'e3;\n            8'b11110000: SubBytes = 8'e7;\n            8'b11110001: SubBytes = 8'eb;\n            8'b11110010: SubBytes = 8'f1;\n            8'b11110011: SubBytes = 8'f5;\n            8'b11110100: SubBytes = 8'f9;\n            8'b11110101: SubBytes = 8'fd;\n            8'b11110110: SubBytes = 8'01;\n            8'b11110111: SubBytes = 8'05;\n            8'b11111000: SubBytes = 8'09;\n            8'b11111001: SubBytes = 8'0d;\n            8'b11111010: SubBytes = 8'11;\n            8'b11111011: SubBytes = 8'15;\n            8'b11111100: SubBytes = 8'19;\n            8'b11111101: SubBytes = 8'1d;\n            8'b11111110: SubBytes = 8'21;\n            8'b11111111: SubBytes = 8'25;\n        endcase\n    end\n\n    // ShiftRows function\n    function [7:0] ShiftRows([7:0] a);\n        case (a[7:4])\n            8'b0000: ShiftRows = a;\n            8'b0001: ShiftRows = {a[2:0], a[7:4]};\n            8'b0010: ShiftRows = {a[3:0], a[7:4]};\n            8'b0011: ShiftRows = {a[4:0], a[7:4]};\n            8'b0100: ShiftRows = {a[5:0], a[7:4]};\n            8'b0101: ShiftRows = {a[6:0], a[7:4]};\n            8'b0110: ShiftRows = {a[7:0]};\n            8'b0111: ShiftRows = {a[7:0]};\n        endcase\n    endfunction\n\n    // MixColumns function\n    function [7:0] MixColumns([7:0] a);\n        reg [7:0] t0, t1, t2, t3;\n        reg [7:0] t4, t5, t6, t7;\n        reg [7:0] t8, t9, t10, t11;\n        reg [7:0] t12, t13, t14, t15;\n        reg [7:0] t16, t17, t18, t19;\n        reg [7:0] t20, t21, t22, t23;\n        reg [7:0] t24, t25, t26, t27;\n        reg [7:0] t28, t29, t30, t31;\n        reg [7:0] t32, t33, t34, t35;\n        reg [7:0] t36, t37, t38, t39;\n        reg [7:0] t40, t41, t42, t43;\n        reg [7:0] t44, t45, t46, t47;\n        reg [7:0] t48, t49, t50, t51;\n        reg [7:0] t52, t53, t54, t55;\n        reg [7:0] t56, t57, t58, t59;\n        reg [7:0] t60, t61, t62, t63;\n        reg [7:0] t64, t65, t66, t67;\n        reg [7:0] t68, t69, t70, t71;\n        reg [7:0] t72, t73, t74, t75;\n        reg [7:0] t76, t77, t78, t79;\n        reg [7:0] t80, t81, t82, t83;\n        reg [7:0] t84, t85, t86, t87;\n        reg [7:0] t88, t89, t90, t91;\n        reg [7:0] t92, t93, t94, t95;\n        reg [7:0] t96, t97, t98, t99;\n        reg [7:0] t100, t101, t102, t103;\n        reg [7:0] t104, t105, t106, t107;\n        reg [7:0] t108, t109, t110, t111;\n        reg [7:0] t112, t113, t114, t115;\n        reg [7:0] t116, t117, t118, t119;\n        reg [7:0] t120, t121, t122, t123;\n        reg [7:0] t124, t125, t126, t127;\n        reg [7:0] t128, t129, t130, t131;\n        reg [7:0] t132, t133, t134, t135;\n        reg [7:0] t136, t137, t138, t139;\n        reg [7:0] t140, t141, t142, t143;\n        reg [7:0] t144, t145, t146, t147;\n        reg [7:0] t148, t149, t150, t151;\n        reg [7:0] t152, t153, t154, t155;\n        reg [7:0] t156, t157, t158, t159;\n        reg [7:0] t160, t161, t162, t163;\n        reg [7:0] t164, t165, t166, t167;\n        reg [7:0] t168, t169, t170, t171;\n        reg [7:0] t172, t173, t174, t175;\n        reg [7:0] t176, t177, t178, t179;\n        reg [7:0] t180, t181, t182, t183;\n        reg [7:0] t184, t185, t186, t187;\n        reg [7:0] t188, t189, t190, t191;\n        reg [7:0] t192, t193, t194, t195;\n        reg [7:0] t196, t197, t198, t199;\n        reg [7:0] t200, t201, t202, t203;\n        reg [7:0] t204, t205, t206, t207;\n        reg [7:0] t208, t209, t210, t211;\n        reg [7:0] t212, t213, t214, t215;\n        reg [7:0] t216, t217, t218, t219;\n        reg [7:0] t220, t221, t222, t223;\n        reg [7:0] t224, t225, t226, t227;\n        reg [7:0] t228, t229, t230, t231;\n        reg [7:0] t232, t233, t234, t235;\n        reg [7:0] t236, t237, t238, t239;\n        reg [7:0] t240, t241, t242, t243;\n        reg [7:0] t244, t245, t246, t247;\n        reg [7:0] t248, t249, t250, t251;\n        reg [7:0] t252, t253, t254, t255;\n        reg [7:0] t256, t257, t258, t259;\n        reg [7:0] t260, t261, t262, t263;\n        reg [7:0] t264, t265, t266, t267;\n        reg [7:0] t268, t269, t270, t271;\n        reg [7:0] t272, t273, t274, t275;\n        reg [7:0] t276, t277, t278, t279;\n        reg [7:0] t280, t281, t282, t283;\n        reg [7:0] t284, t285, t286, t287;\n        reg [7:0] t288, t289, t290, t291;\n        reg [7:0] t292, t293, t294, t295;\n        reg [7:0] t296, t297, t298, t299;\n        reg [7:0] t300, t301, t302, t303;\n        reg [7:0] t304, t305, t306, t307;\n        reg [7:0] t308, t309, t310, t311;\n        reg [7:0] t312, t313, t314, t315;\n        reg [7:0] t316, t317, t318, t319;\n        reg [7:0] t320, t321, t322, t323;\n        reg [7:0] t324, t325, t326, t327;\n        reg [7:0] t328, t329, t330, t331;\n        reg [7:0] t332, t333, t334, t335;\n        reg [7:0] t336, t337, t338, t339;\n        reg [7:0] t340, t341, t342, t343;\n        reg [7:0] t344, t345, t346, t347;\n        reg [7:0] t348, t349, t350, t351;\n        reg [7:0] t352, t353, t354, t355;\n        reg [7:0] t356, t357, t358, t359;\n        reg [7:0] t360, t361, t362, t363;\n        reg [7:0] t364, t365, t366, t367;\n        reg [7:0] t368, t369, t370, t371;\n        reg [7:0] t372, t373, t374, t375;\n        reg [7:0] t376, t377, t378, t379;\n        reg [7:0] t380, t381, t382, t383;\n        reg [7:0] t384, t385, t386, t387;\n        reg [7:0] t388, t389, t390, t391;\n        reg [7:0] t392, t393, t394, t395;\n        reg [7:0] t396, t397, t398, t399;\n        reg [7:0] t400, t401, t402, t403;\n        reg [7:0] t404, t405, t406, t407;\n        reg [7:0] t408, t409, t410, t411;\n        reg [7:0] t412, t413, t414, t415;\n        reg [7:0] t416, t417, t418, t419;\n        reg [7:0] t420, t421, t422, t423;\n        reg [7:0] t424, t425, t426, t427;\n        reg [7:0] t428, t429, t430, t431;\n        reg [7:0] t432, t433, t434, t435;\n        reg [7:0] t436, t437, t438, t439;\n        reg [7:0] t440, t441, t442, t443;\n        reg [7:0] t444, t445, t446, t447;\n        reg [7:0] t448, t449, t450, t451;\n        reg [7:0] t452, t453, t454, t455;\n        reg [7:0] t456, t457, t458, t459;\n        reg [7:0] t460, t461, t462, t463;\n        reg [7:0] t464, t465, t466, t467;\n        reg [7:0] t468, t469, t470, t471;\n        reg [7:0] t472, t473, t474, t475;\n        reg [7:0] t476, t477, t478, t479;\n        reg [7:0] t480, t481, t482, t483;\n        reg [7:0] t484, t485, t486, t487;\n        reg [7:0] t488, t489, t490, t491;\n        reg [7:0] t492, t493, t494, t495;\n        reg [7:0] t496, t497, t498, t499;\n        reg [7:0] t500, t501, t502, t503;\n        reg [7:0] t504, t505, t506, t507;\n        reg [7:0] t508, t509, t510, t511;\n        reg [7:0] t512, t513, t514, t515;\n        reg [7:0] t516, t517, t518, t519;\n        reg [7:0] t520, t521, t522, t523;\n        reg [7:0] t524, t525, t526, t527;\n        reg [7:0] t528, t529, t530, t531;\n        reg [7:0] t532, t533, t534, t535;\n        reg [7:0] t536, t537, t538, t539;\n        reg [7:0] t540, t541, t542, t543;\n        reg [7:0] t544, t545, t546, t547;\n        reg [7:0] t548, t549, t550, t551;\n        reg [7:0] t552, t553, t554, t555;\n        reg [7:0] t556, t557, t558, t559;\n        reg [7:0] t560, t561, t562, t563;\n        reg [7:0] t564, t565, t566, t567;\n        reg [7:0] t568, t569, t570, t571;\n        reg [7:0] t572, t573, t574, t575;\n        reg [7:0] t576, t577, t578, t579;\n        reg [7:0] t580, t581, t582, t583;\n        reg [7:0] t584, t585, t586, t587;\n        reg [7:0] t588, t589, t590, t591;\n        reg [7:0] t592, t593, t594, t595;\n        reg [7:0] t596, t597, t598, t599;\n        reg [7:0] t600, t601, t602, t603;\n        reg [7:0] t604, t605, t606, t607;\n        reg [7:0] t608, t609, t610, t611;\n        reg [7:0]", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 3, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    // Registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expand_128_module(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox aes_inv_sbox_module[0:15];\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n            for (int i = 0; i < 16; i++) begin\n                aes_inv_sbox_module[i].a <= 0;\n                aes_inv_sbox_module[i].b <= 0;\n            end\n        end else if (kld) begin\n            // Key Load State\n            kcnt <= 0xA;\n            ld_r <= 0;\n            for (int i = 0; i < 16; i++) begin\n                aes_inv_sbox_module[i].a <= 0;\n                aes_inv_sbox_module[i].b <= 0;\n            end\n        end else if (ld) begin\n            // Initial Round State\n            ld_r <= 1;\n            dcnt <= 1;\n            text_in_r <= text_in;\n            for (int i = 0; i < 16; i++) begin\n                aes_inv_sbox_module[i].a <= text_in_r[8*i+7:8*i];\n                aes_inv_sbox_module[i].b <= 0;\n            end\n        end else if (dcnt < 11) begin\n            // Standard Round State\n            ld_r <= 0;\n            dcnt <= dcnt + 1;\n            for (int i = 0; i < 16; i++) begin\n                aes_inv_sbox_module[i].a <= sa[0][i];\n                aes_inv_sbox_module[i].b <= 0;\n            end\n        end else begin\n            // Final Round State\n            ld_r <= 0;\n            for (int i = 0; i < 16; i++) begin\n                aes_inv_sbox_module[i].a <= sa[0][i];\n                aes_inv_sbox_module[i].b <= 0;\n            end\n        end\n    end\n\n    // InvShiftRows Operation\n    always @(posedge clk) begin\n        if (ld_r) begin\n            // Load State\n            for (int i = 0; i < 4; i++) begin\n                sa[1][i] <= sa[0][i+4];\n                sa[2][i] <= sa[0][i+8];\n                sa[3][i] <= sa[0][i+12];\n            end\n        end else if (dcnt < 11) begin\n            // Standard Round State\n            for (int i = 0; i < 4; i++) begin\n                sa[1][i] <= sa[0][i+4];\n                sa[2][i] <= sa[0][i+8];\n                sa[3][i] <= sa[0][i+12];\n            end\n        end\n    end\n\n    // InvSubBytes Operation\n    always @(posedge clk) begin\n        if (ld_r) begin\n            // Load State\n            for (int i = 0; i < 16; i++) begin\n                aes_inv_sbox_module[i].b <= aes_inv_sbox_module[i].a;\n            end\n        end else if (dcnt < 11) begin\n            // Standard Round State\n            for (int i = 0; i < 16; i++) begin\n                aes_inv_sbox_module[i].b <= aes_inv_sbox_module[i].a;\n            end\n        end\n    end\n\n    // AddRoundKey Operation\n    always @(posedge clk) begin\n        if (ld_r) begin\n            // Load State\n            for (int i = 0; i < 16; i++) begin\n                sa[0][i] <= text_in_r[8*i+7:8*i] ^ wk3[8*i+7:8*i];\n            end\n        end else if (dcnt < 11) begin\n            // Standard Round State\n            for (int i = 0; i < 16; i++) begin\n                sa[0][i] <= sa[1][i] ^ wk3[8*i+7:8*i];\n            end\n        end\n    end\n\n    // InvMixColumns Operation\n    always @(posedge clk) begin\n        if (ld_r) begin\n            // Load State\n            for (int i = 0; i < 4; i++) begin\n                sa[0][i] <= (sa[0][i] ^ sa[0][i+4]) ^ (sa[0][i+1] ^ sa[0][i+5]);\n                sa[0][i+4] <= (sa[0][i+4] ^ sa[0][i]) ^ (sa[0][i+1] ^ sa[0][i+5]);\n                sa[0][i+1] <= (sa[0][i+1] ^ sa[0][i]) ^ (sa[0][i+4] ^ sa[0][i+5]);\n                sa[0][i+5] <= (sa[0][i+5] ^ sa[0][i]) ^ (sa[0][i+4] ^ sa[0][i+1]);\n            end\n        end else if (dcnt < 10) begin\n            // Standard Round State\n            for (int i = 0; i < 4; i++) begin\n                sa[0][i] <= (sa[0][i] ^ sa[0][i+4]) ^ (sa[0][i+1] ^ sa[0][i+5]);\n                sa[0][i+4] <= (sa[0][i+4] ^ sa[0][i]) ^ (sa[0][i+1] ^ sa[0][i+5]);\n                sa[0][i+1] <= (sa[0][i+1] ^ sa[0][i]) ^ (sa[0][i+4] ^ sa[0][i+5]);\n                sa[0][i+5] <= (sa[0][i+5] ^ sa[0][i]) ^ (sa[0][i+4] ^ sa[0][i+1]);\n            end\n        end\n    end\n\n    // Key Expansion Buffer\n    always @(posedge clk) begin\n        if (kld) begin\n            // Key Load State\n            for (int i = 0; i < 11; i++) begin\n                kb[i] <= 0;\n            end\n            kcnt <= 0xA;\n        end else if (kcnt > 0) begin\n            // Key Expansion State\n            if (kcnt == 0) begin\n                // Key Stored State\n                kcnt <= 0;\n            end else if (kcnt == 0xA) begin\n                // Key Load State\n                kcnt <= 0xA;\n            end else begin\n                // Key Expansion State\n                for (int i = 0; i < 4; i++) begin\n                    kb[i] <= (kb[i] ^ wk3[32*i+7:32*i]) ^ (kb[i+4] ^ wk3[32*i+31:32*i+24]);\n                end\n                kcnt <= kcnt - 1;\n            end\n        end\n    end\n\n    // Output Generation\n    always @(posedge clk) begin\n        if (ld_r) begin\n            // Load State\n            text_out_r <= text_in_r;\n        end else if (dcnt < 11) begin\n            // Standard Round State\n            for (int i = 0; i < 16; i++) begin\n                text_out_r[8*i+7:8*i] <= sa[0][i];\n            end\n        end\n    end\n\n    // Done Signal\n    assign done = (dcnt == 11) & (~ld_r);\n\nendmodule\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    // Registers\n    reg [31:0] wk0;\n    reg [31:0] wk1;\n    reg [31:0] wk2;\n    reg [31:0] wk3;\n    reg [3:0] kcnt;\n\n    // Submodules\n    aes_rcon aes_rcon_module(\n        .clk(clk),\n        .kld(kld),\n        .out(wk3)\n    );\n\n    aes_sbox aes_sbox_module[0:3];\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (kld) begin\n            // Key Load State\n            wk0 <= key[31:0];\n            wk1 <= key[63:32];\n            wk2 <= key[95:64];\n            wk3 <= key[127:96];\n            kcnt <= 0xA;\n        end else if (kcnt > 0) begin\n            // Key Expansion State\n            if (kcnt == 0) begin\n                // Key Stored State\n                kcnt <= 0;\n            end else if (kcnt == 0xA) begin\n                // Key Load State\n                kcnt <= 0xA;\n            end else begin\n                // Key Expansion State\n                wk0 <= (wk0 ^ wk1) ^ aes_sbox_module[0].b;\n                wk1 <= (wk1 ^ wk2) ^ aes_sbox_module[1].b;\n                wk2 <= (wk2 ^ wk3) ^ aes_sbox_module[2].b;\n                wk3 <= (wk3 ^ wk0) ^ aes_sbox_module[3].b ^ aes_rcon_module.out;\n                kcnt <= kcnt - 1;\n            end\n        end\n    end\n\n    // Output Generation\n    always @(posedge clk) begin\n        if (kld) begin\n            // Key Load State\n            wo_0 <= wk0;\n            wo_1 <= wk1;\n            wo_2 <= wk2;\n            wo_3 <= wk3;\n        end else if (kcnt == 0) begin\n            // Key Stored State\n            wo_0 <= wk0;\n            wo_1 <= wk1;\n            wo_2 <= wk2;\n            wo_3 <= wk3;\n        end\n    end\n\nendmodule\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    // Registers\n    reg [3:0] rcnt;\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (kld) begin\n            // Key Load State\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt > 9) begin\n            // Key Expansion State\n            out <= 32'h00_00_00_00;\n        end else begin\n            // Key Expansion State\n            out <= (rcnt == 0) ? 32'h01_00_00_00 :\n                   (rcnt == 1) ? 32'h02_00_00_00 :\n                   (rcnt == 2) ? 32'h04_00_00_00 :\n                   (rcnt == 3) ? 32'h08_00_00_00 :\n                   (rcnt == 4) ? 32'h10_00_00_00 :\n                   (rcnt == 5) ? 32'h20_00_00_00 :\n                   (rcnt == 6) ? 32'h40_00_00_00 :\n                   (rcnt == 7) ? 32'h80_00_00_00 :\n                   (rcnt == 8) ? 32'h1b_00_00_00 :\n                   (rcnt == 9) ? 32'h36_00_00_00 :\n                   32'h00_00_00_00;\n            rcnt <= rcnt + 1;\n        end\n    end\n\nendmodule\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // ROM structure uses 256 x 8-bit mapping table\n    reg [7:0] sbox[0:255];\n\n    // Initialize ROM with S-box values\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n        end\n    end\n\n    // Output Generation\n    assign b = sbox[a];\n\nendmodule\n// aes_inv_sbox module\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // ROM structure uses 256 x 8-bit mapping table\n    reg [7:0] inv_sbox[0:255];\n\n    // Initialize ROM with inverse S-box values\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = i;\n        end\n    end\n\n    // Output Generation\n    assign b = inv_sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 4, "code": "```verilog\n// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n              sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n              sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n              sa[3][0], sa[3][1], sa[3][2], sa[3][3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expand_128_module(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox aes_inv_sbox_module0(\n        .a(sa[0][0]),\n        .b(us00)\n    );\n    aes_inv_sbox aes_inv_sbox_module1(\n        .a(sa[0][1]),\n        .b(us01)\n    );\n    aes_inv_sbox aes_inv_sbox_module2(\n        .a(sa[0][2]),\n        .b(us02)\n    );\n    aes_inv_sbox aes_inv_sbox_module3(\n        .a(sa[0][3]),\n        .b(us03)\n    );\n    aes_inv_sbox aes_inv_sbox_module4(\n        .a(sa[1][0]),\n        .b(us10)\n    );\n    aes_inv_sbox aes_inv_sbox_module5(\n        .a(sa[1][1]),\n        .b(us11)\n    );\n    aes_inv_sbox aes_inv_sbox_module6(\n        .a(sa[1][2]),\n        .b(us12)\n    );\n    aes_inv_sbox aes_inv_sbox_module7(\n        .a(sa[1][3]),\n        .b(us13)\n    );\n    aes_inv_sbox aes_inv_sbox_module8(\n        .a(sa[2][0]),\n        .b(us20)\n    );\n    aes_inv_sbox aes_inv_sbox_module9(\n        .a(sa[2][1]),\n        .b(us21)\n    );\n    aes_inv_sbox aes_inv_sbox_module10(\n        .a(sa[2][2]),\n        .b(us22)\n    );\n    aes_inv_sbox aes_inv_sbox_module11(\n        .a(sa[2][3]),\n        .b(us23)\n    );\n    aes_inv_sbox aes_inv_sbox_module12(\n        .a(sa[3][0]),\n        .b(us30)\n    );\n    aes_inv_sbox aes_inv_sbox_module13(\n        .a(sa[3][1]),\n        .b(us31)\n    );\n    aes_inv_sbox aes_inv_sbox_module14(\n        .a(sa[3][2]),\n        .b(us32)\n    );\n    aes_inv_sbox aes_inv_sbox_module15(\n        .a(sa[3][3]),\n        .b(us33)\n    );\n\n    // State Transition Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n        end\n        else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n        end\n        else if (ld_r) begin\n            ld_r <= 0;\n            // Load initial round key\n            kb[10] <= wk0;\n            // Load intermediate round keys\n            for (int i = 9; i >= 1; i--) begin\n                kb[i] <= wk3;\n                wk3 <= wk2;\n                wk2 <= wk1;\n                wk1 <= wk0;\n                wk0 <= kb[i + 1];\n            end\n            // Load last round key\n            kb[0] <= wk3;\n            // Reset round counter\n            dcnt <= 1;\n            // Reset key buffer counter\n            kcnt <= 0xA;\n        end\n        else if (dcnt < 11) begin\n            // Increment round counter\n            dcnt <= dcnt + 1;\n            // Select current round key\n            case (dcnt)\n                1: begin\n                    sa[0][0] <= kb[10];\n                    sa[0][1] <= kb[9];\n                    sa[0][2] <= kb[8];\n                    sa[0][3] <= kb[7];\n                    sa[1][0] <= kb[6];\n                    sa[1][1] <= kb[5];\n                    sa[1][2] <= kb[4];\n                    sa[1][3] <= kb[3];\n                    sa[2][0] <= kb[2];\n                    sa[2][1] <= kb[1];\n                    sa[2][2] <= kb[0];\n                    sa[3][0] <= 0;\n                    sa[3][1] <= 0;\n                    sa[3][2] <= 0;\n                    sa[3][3] <= 0;\n                end\n                2: begin\n                    sa[0][0] <= kb[10];\n                    sa[0][1] <= kb[9];\n                    sa[0][2] <= kb[8];\n                    sa[0][3] <= kb[7];\n                    sa[1][0] <= kb[6];\n                    sa[1][1] <= kb[5];\n                    sa[1][2] <= kb[4];\n                    sa[1][3] <= kb[3];\n                    sa[2][0] <= kb[2];\n                    sa[2][1] <= kb[1];\n                    sa[2][2] <= kb[0];\n                    sa[3][0] <= InvShiftRows(sa[3][0], dcnt);\n                    sa[3][1] <= InvShiftRows(sa[3][1], dcnt);\n                    sa[3][2] <= InvShiftRows(sa[3][2], dcnt);\n                    sa[3][3] <= InvShiftRows(sa[3][3], dcnt);\n                end\n                3: begin\n                    sa[0][0] <= kb[10];\n                    sa[0][1] <= kb[9];\n                    sa[0][2] <= kb[8];\n                    sa[0][3] <= kb[7];\n                    sa[1][0] <= kb[6];\n                    sa[1][1] <= kb[5];\n                    sa[1][2] <= kb[4];\n                    sa[1][3] <= kb[3];\n                    sa[2][0] <= kb[2];\n                    sa[2][1] <= kb[1];\n                    sa[2][2] <= kb[0];\n                    sa[3][0] <= InvShiftRows(sa[3][0], dcnt);\n                    sa[3][1] <= InvShiftRows(sa[3][1], dcnt);\n                    sa[3][2] <= InvShiftRows(sa[3][2], dcnt);\n                    sa[3][3] <= InvShiftRows(sa[3][3], dcnt);\n                end\n                4: begin\n                    sa[0][0] <= kb[10];\n                    sa[0][1] <= kb[9];\n                    sa[0][2] <= kb[8];\n                    sa[0][3] <= kb[7];\n                    sa[1][0] <= kb[6];\n                    sa[1][1] <= kb[5];\n                    sa[1][2] <= kb[4];\n                    sa[1][3] <= kb[3];\n                    sa[2][0] <= kb[2];\n                    sa[2][1] <= kb[1];\n                    sa[2][2] <= kb[0];\n                    sa[3][0] <= InvShiftRows(sa[3][0], dcnt);\n                    sa[3][1] <= InvShiftRows(sa[3][1], dcnt);\n                    sa[3][2] <= InvShiftRows(sa[3][2], dcnt);\n                    sa[3][3] <= InvShiftRows(sa[3][3], dcnt);\n                end\n                5: begin\n                    sa[0][0] <= kb[10];\n                    sa[0][1] <= kb[9];\n                    sa[0][2] <= kb[8];\n                    sa[0][3] <= kb[7];\n                    sa[1][0] <= kb[6];\n                    sa[1][1] <= kb[5];\n                    sa[1][2] <= kb[4];\n                    sa[1][3] <= kb[3];\n                    sa[2][0] <= kb[2];\n                    sa[2][1] <= kb[1];\n                    sa[2][2] <= kb[0];\n                    sa[3][0] <= InvShiftRows(sa[3][0], dcnt);\n                    sa[3][1] <= InvShiftRows(sa[3][1], dcnt);\n                    sa[3][2] <= InvShiftRows(sa[3][2], dcnt);\n                    sa[3][3] <= InvShiftRows(sa[3][3], dcnt);\n                end\n                6: begin\n                    sa[0][0] <= kb[10];\n                    sa[0][1] <= kb[9];\n                    sa[0][2] <= kb[8];\n                    sa[0][3] <= kb[7];\n                    sa[1][0] <= kb[6];\n                    sa[1][1] <= kb[5];\n                    sa[1][2] <= kb[4];\n                    sa[1][3] <= kb[3];\n                    sa[2][0] <= kb[2];\n                    sa[2][1] <= kb[1];\n                    sa[2][2] <= kb[0];\n                    sa[3][0] <= InvShiftRows(sa[3][0], dcnt);\n                    sa[3][1] <= InvShiftRows(sa[3][1], dcnt);\n                    sa[3][2] <= InvShiftRows(sa[3][2], dcnt);\n                    sa[3][3] <= InvShiftRows(sa[3][3], dcnt);\n                end\n                7: begin\n                    sa[0][0] <= kb[10];\n                    sa[0][1] <= kb[9];\n                    sa[0][2] <= kb[8];\n                    sa[0][3] <= kb[7];\n                    sa[1][0] <= kb[6];\n                    sa[1][1] <= kb[5];\n                    sa[1][2] <= kb[4];\n                    sa[1][3] <= kb[3];\n                    sa[2][0] <= kb[2];\n                    sa[2][1] <= kb[1];\n                    sa[2][2] <= kb[0];\n                    sa[3][0] <= InvShiftRows(sa[3][0], dcnt);\n                    sa[3][1] <= InvShiftRows(sa[3][1], dcnt);\n                    sa[3][2] <= InvShiftRows(sa[3][2], dcnt);\n                    sa[3][3] <= InvShiftRows(sa[3][3], dcnt);\n                end\n                8: begin\n                    sa[0][0] <= kb[10];\n                    sa[0][1] <= kb[9];\n                    sa[0][2] <= kb[8];\n                    sa[0][3] <= kb[7];\n                    sa[1][0] <= kb[6];\n                    sa[1][1] <= kb[5];\n                    sa[1][2] <= kb[4];\n                    sa[1][3] <= kb[3];\n                    sa[2][0] <= kb[2];\n                    sa[2][1] <= kb[1];\n                    sa[2][2] <= kb[0];\n                    sa[3][0] <= InvShiftRows(sa[3][0], dcnt);\n                    sa[3][1] <= InvShiftRows(sa[3][1], dcnt);\n                    sa[3][2] <= InvShiftRows(sa[3][2], dcnt);\n                    sa[3][3] <= InvShiftRows(sa[3][3], dcnt);\n                end\n                9: begin\n                    sa[0][0] <= kb[10];\n                    sa[0][1] <= kb[9];\n                    sa[0][2] <= kb[8];\n                    sa[0][3] <= kb[7];\n                    sa[1][0] <= kb[6];\n                    sa[1][1] <= kb[5];\n                    sa[1][2] <= kb[4];\n                    sa[1][3] <= kb[3];\n                    sa[2][0] <= kb[2];\n                    sa[2][1] <= kb[1];\n                    sa[2][2] <= kb[0];\n                    sa[3][0] <= InvShiftRows(sa[3][0], dcnt);\n                    sa[3][1] <= InvShiftRows(sa[3][1], dcnt);\n                    sa[3][2] <= InvShiftRows(sa[3][2], dcnt);\n                    sa[3][3] <= InvShiftRows(sa[3][3], dcnt);\n                end\n                10: begin\n                    sa[0][0] <= kb[10];\n                    sa[0][1] <= kb[9];\n                    sa[0][2] <= kb[8];\n                    sa[0][3] <= kb[7];\n                    sa[1][0] <= kb[6];\n                    sa[1][1] <= kb[5];\n                    sa[1][2] <= kb[4];\n                    sa[1][3] <= kb[3];\n                    sa[2][0] <= kb[2];\n                    sa[2][1] <= kb[1];\n                    sa[2][2] <= kb[0];\n                    sa[3][0] <= InvShiftRows(sa[3][0], dcnt);\n                    sa[3][1] <= InvShiftRows(sa[3][1], dcnt);\n                    sa[3][2] <= InvShiftRows(sa[3][2], dcnt);\n                    sa[3][3] <= InvShiftRows(sa[3][3], dcnt);\n                end\n                default: begin\n                    sa[0][0] <= 0;\n                    sa[0][1] <= 0;\n                    sa[0][2] <= 0;\n                    sa[0][3] <= 0;\n                    sa[1][0] <= 0;\n                    sa[1][1] <= 0;\n                    sa[1][2] <= 0;\n                    sa[1][3] <= 0;\n                    sa[2][0] <= 0;\n                    sa[2][1] <= 0;\n                    sa[2][2] <= 0;\n                    sa[2][3] <= 0;\n                    sa[3][0] <= 0;\n                    sa[3][1] <= 0;\n                    sa[3][2] <= 0;\n                    sa[3][3] <= 0;\n                end\n            endcase\n            // Perform InvSubBytes operation\n            InvSubBytes(sa[0][0], us00);\n            InvSubBytes(sa[0][1], us01);\n            InvSubBytes(sa[0][2], us02);\n            InvSubBytes(sa[0][3], us03);\n            InvSubBytes(sa[1][0], us10);\n            InvSubBytes(sa[1][1], us11);\n            InvSubBytes(sa[1][2], us12);\n            InvSubBytes(sa[1][3], us13);\n            InvSubBytes(sa[2][0], us20);\n            InvSubBytes(sa[2][1], us21);\n            InvSubBytes(sa[2][2], us22);\n            InvSubBytes(sa[2][3], us23);\n            InvSubBytes(sa[3][0], us30);\n            InvSubBytes(sa[3][1], us31);\n            InvSubBytes(sa[3][2], us32);\n            InvSubBytes(sa[3][3], us33);\n            // Perform AddRoundKey operation\n            AddRoundKey(sa[0][0], sa_ark0);\n            AddRoundKey(sa[0][1], sa_ark1);\n            AddRoundKey(sa[0][2], sa_ark2);\n            AddRoundKey(sa[0][3], sa_ark3);\n            AddRoundKey(sa[1][0], sa_ark4);\n            AddRoundKey(sa[1][1], sa_ark5);\n            AddRoundKey(sa[1][2], sa_ark6);\n            AddRoundKey(sa[1][3], sa_ark7);\n            AddRoundKey(sa[2][0], sa_ark8);\n            AddRoundKey(sa[2][1], sa_ark9);\n            AddRoundKey(sa[2][2], sa_ark10);\n            AddRoundKey(sa[2][3], sa_ark11);\n            AddRoundKey(sa[3][0], sa_ark12);\n            AddRoundKey(sa[3][1], sa_ark13);\n            AddRoundKey(sa[3][2], sa_ark14);\n            AddRoundKey(sa[3][3], sa_ark15);\n            // Perform InvMixColumns operation\n            InvMixColumns(sa[0][0], sa_next0);\n            InvMixColumns(sa[0][1], sa_next1);\n            InvMixColumns(sa[0][2], sa_next2);\n            InvMixColumns(sa[0][3], sa_next3);\n            InvMixColumns(sa[1][0], sa_next4);\n            InvMixColumns(sa[1][1], sa_next5);\n            InvMixColumns(sa[1][2], sa_next6);\n            InvMixColumns(sa[1][3], sa_next7);\n            InvMixColumns(sa[2][0], sa_next8);\n            InvMixColumns(sa[2][1], sa_next9);\n            InvMixColumns(sa[2][2], sa_next10);\n            InvMixColumns(sa[2][3], sa_next11);\n            InvMixColumns(sa[3][0], sa_next12);\n            InvMixColumns(sa[3][1], sa_next13);\n            InvMixColumns(sa[3][2], sa_next14);\n            InvMixColumns(sa[3][3], sa_next15);\n            // Update state matrix\n            sa[0][0] <= sa_next0;\n            sa[0][1] <= sa_next1;\n            sa[0][2] <= sa_next2;\n            sa[0][3] <= sa_next3;\n            sa[1][0] <= sa_next4;\n            sa[1][1] <= sa_next5;\n            sa[1][2] <= sa_next6;\n            sa[1][3] <= sa_next7;\n            sa[2][0] <= sa_next8;\n            sa[2][1] <= sa_next9;\n            sa[2][2] <= sa_next10;\n            sa[2][3] <= sa_next11;\n            sa[3][0] <= sa_next12;\n            sa[3][1] <= sa_next13;\n            sa[3][2] <= sa_next14;\n            sa[3][3] <= sa_next15;\n        end\n        else if (dcnt == 11) begin\n            // Perform InvSubBytes operation\n            InvSubBytes(sa[0][0], us00);\n            InvSubBytes(sa[0][1], us01);\n            InvSubBytes(sa[0][2], us02);\n            InvSubBytes(sa[0][3], us03);\n            InvSubBytes(sa[1][0], us10);\n            InvSubBytes(sa[1][1], us11);\n            InvSubBytes(sa[1][2], us12);\n            InvSubBytes(sa[1][3], us13);\n            InvSubBytes(sa[2][0], us20);\n            InvSubBytes(sa[2][1], us21);\n            InvSubBytes(sa[2][2], us22);\n            InvSubBytes(sa[2][3], us23);\n            InvSubBytes(sa[3][0], us30);\n            InvSubBytes(sa[3][1], us31);\n            InvSubBytes(sa[3][2], us32);\n            InvSubBytes(sa[3][3], us33);\n            // Perform AddRoundKey operation\n            AddRoundKey(sa[0][0], sa_ark0);\n            AddRoundKey(sa[0][1], sa_ark1);\n            AddRoundKey(sa[0][2], sa_ark2", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 5, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expand_128_module(\n       .clk(clk),\n       .kld(kld),\n       .key(key),\n       .wo_0(wk0),\n       .wo_1(wk1),\n       .wo_2(wk2),\n       .wo_3(wk3)\n    );\n\n    aes_inv_sbox aes_inv_sbox_module(\n       .a(_sr),\n       .b(_sub)\n    );\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n        end else if (kld) begin\n            // Key loading stage\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_in_r <= text_in;\n        end else if (ld) begin\n            // Data loading stage\n            ld_r <= 1;\n            text_in_r <= text_in;\n        end else if (dcnt < 11) begin\n            // Standard round stage\n            if (dcnt == 0) begin\n                // Initial round key addition\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= text_in_r[8 * (i * 4 + j) +: 8] ^ wk0[8 * (i * 4 + j) +: 8];\n                    end\n                end\n            end else begin\n                // Standard round transformation\n                InvShiftRows();\n                InvSubBytes();\n                AddRoundKey();\n                InvMixColumns();\n            end\n            dcnt <= dcnt + 1;\n        end else begin\n            // Final round stage\n            InvShiftRows();\n            InvSubBytes();\n            AddRoundKey();\n            done <= 1;\n        end\n    end\n\n    // Round Transformation Functions\n    task InvShiftRows();\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                if (i == 0) begin\n                    sa[i][j] <= sa[i][j];\n                end else if (i == 1) begin\n                    sa[i][j] <= sa[i][3];\n                end else if (i == 2) begin\n                    sa[i][j] <= sa[i][2];\n                end else if (i == 3) begin\n                    sa[i][j] <= sa[i][1];\n                end\n            end\n        end\n    endtask\n\n    task InvSubBytes();\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                _sr <= sa[i][j];\n                aes_inv_sbox_module.a <= _sr;\n                _sub <= aes_inv_sbox_module.b;\n                sa[i][j] <= _sub;\n            end\n        end\n    endtask\n\n    task AddRoundKey();\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i][j] ^ wk0[8 * (i * 4 + j) +: 8];\n            end\n        end\n    endtask\n\n    task InvMixColumns();\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                _sr <= sa[i][j];\n                _sub <= _sr;\n                _sub <= _sub ^ (pmul_e(_sub) << 1);\n                _sub <= _sub ^ (pmul_b(_sub) << 2);\n                _sub <= _sub ^ (pmul_d(_sub) << 3);\n                _sub <= _sub ^ (pmul_9(_sub) << 4);\n                sa[i][j] <= _sub;\n            end\n        end\n    endtask\n\n    // Key Expansion Buffer\n    always @(posedge clk) begin\n        if (kld) begin\n            // Key loading stage\n            for (int i = 10; i >= 0; i--) begin\n                kb[i] <= key[8 * i +: 8];\n            end\n            kcnt <= 0xA;\n        end else if (kcnt > 0) begin\n            // Key expansion stage\n            if (kcnt == 0) begin\n                // Last round key\n                wk3 <= kb[0];\n            end else if (kcnt == 1) begin\n                // Second last round key\n                wk2 <= kb[0];\n                wk3 <= kb[1];\n            end else if (kcnt == 2) begin\n                // Third last round key\n                wk1 <= kb[0];\n                wk2 <= kb[1];\n                wk3 <= kb[2];\n            end else if (kcnt == 3) begin\n                // Fourth last round key\n                wk0 <= kb[0];\n                wk1 <= kb[1];\n                wk2 <= kb[2];\n                wk3 <= kb[3];\n            end else begin\n                // Other round keys\n                wk0 <= kb[kcnt - 4];\n                wk1 <= kb[kcnt - 3];\n                wk2 <= kb[kcnt - 2];\n                wk3 <= kb[kcnt - 1];\n            end\n            kcnt <= kcnt - 1;\n        end\n    end\n\n    // Output Generation\n    always @(posedge clk) begin\n        if (ld_r) begin\n            // Data loading stage\n            text_out_r <= text_in_r;\n        end else if (dcnt == 11) begin\n            // Final round output\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out_r[8 * (i * 4 + j) +: 8] <= sa[i][j];\n                end\n            end\n        end\n    end\n\n    // Output Assignment\n    assign text_out = text_out_r;\n\nendmodule\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_r;\n    reg [31:0] wk0, wk1, wk2, wk3;\n    reg [3:0] kcnt;\n    reg [7:0] rcnt;\n\n    // Submodules\n    aes_rcon aes_rcon_module(\n       .clk(clk),\n       .kld(kld),\n       .out(rcnt)\n    );\n\n    aes_sbox aes_sbox_module(\n       .a(_a),\n       .b(_b)\n    );\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (kld) begin\n            // Key loading stage\n            key_r <= key;\n            kcnt <= 10;\n            wk0 <= 0;\n            wk1 <= 0;\n            wk2 <= 0;\n            wk3 <= 0;\n        end else if (kcnt > 0) begin\n            // Key expansion stage\n            if (kcnt == 0) begin\n                // Last round key\n                wk3 <= wk2;\n                wk2 <= wk1;\n                wk1 <= wk0;\n                wk0 <= {rcnt, 24'h0, 8'h0, 8'h0};\n            end else if (kcnt == 1) begin\n                // Second last round key\n                wk3 <= wk2;\n                wk2 <= wk1;\n                wk1 <= {rcnt, 24'h0, 8'h0, 8'h0};\n                wk0 <= wk0;\n            end else if (kcnt == 2) begin\n                // Third last round key\n                wk3 <= wk2;\n                wk2 <= {rcnt, 24'h0, 8'h0, 8'h0};\n                wk1 <= wk1;\n                wk0 <= wk0;\n            end else if (kcnt == 3) begin\n                // Fourth last round key\n                wk3 <= {rcnt, 24'h0, 8'h0, 8'h0};\n                wk2 <= wk2;\n                wk1 <= wk1;\n                wk0 <= wk0;\n            end else begin\n                // Other round keys\n                wk3 <= {rcnt, 24'h0, 8'h0, 8'h0};\n                wk2 <= wk2;\n                wk1 <= wk1;\n                wk0 <= {rcnt, 24'h0, 8'h0, 8'h0};\n            end\n            kcnt <= kcnt - 1;\n        end\n    end\n\n    // Round Key Generation\n    always @(posedge clk) begin\n        if (kcnt == 0) begin\n            // Last round key\n            wo_0 <= wk3;\n            wo_1 <= wk2;\n            wo_2 <= wk1;\n            wo_3 <= wk0;\n        end else if (kcnt == 1) begin\n            // Second last round key\n            wo_0 <= wk2;\n            wo_1 <= wk1;\n            wo_2 <= wk0;\n            wo_3 <= 0;\n        end else if (kcnt == 2) begin\n            // Third last round key\n            wo_0 <= wk1;\n            wo_1 <= wk0;\n            wo_2 <= 0;\n            wo_3 <= 0;\n        end else if (kcnt == 3) begin\n            // Fourth last round key\n            wo_0 <= wk0;\n            wo_1 <= 0;\n            wo_2 <= 0;\n            wo_3 <= 0;\n        end else begin\n            // Other round keys\n            wo_0 <= {rcnt, 24'h0, 8'h0, 8'h0};\n            wo_1 <= wk0;\n            wo_2 <= 0;\n            wo_3 <= 0;\n        end\n    end\n\nendmodule\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] kcnt;\n    reg [7:0] rcnt;\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (kld) begin\n            // Key loading stage\n            kcnt <= 0;\n            rcnt <= 1;\n        end else if (kcnt < 10) begin\n            // Key expansion stage\n            if (kcnt == 0) begin\n                // Initial round constant\n                rcnt <= 1;\n            end else if (kcnt == 1) begin\n                // Second round constant\n                rcnt <= 2;\n            end else if (kcnt == 2) begin\n                // Third round constant\n                rcnt <= 4;\n            end else if (kcnt == 3) begin\n                // Fourth round constant\n                rcnt <= 8;\n            end else if (kcnt == 4) begin\n                // Fifth round constant\n                rcnt <= 10;\n            end else if (kcnt == 5) begin\n                // Sixth round constant\n                rcnt <= 20;\n            end else if (kcnt == 6) begin\n                // Seventh round constant\n                rcnt <= 40;\n            end else if (kcnt == 7) begin\n                // Eighth round constant\n                rcnt <= 80;\n            end else if (kcnt == 8) begin\n                // Ninth round constant\n                rcnt <= 1B;\n            end else if (kcnt == 9) begin\n                // Tenth round constant\n                rcnt <= 36;\n            end else begin\n                // Other round constants\n                rcnt <= 0;\n            end\n            kcnt <= kcnt + 1;\n        end\n    end\n\n    // Round Constant Generation\n    always @(posedge clk) begin\n        if (kcnt == 0) begin\n            // Initial round constant\n            out <= 32'h01_00_00_00;\n        end else if (kcnt == 1) begin\n            // Second round constant\n            out <= 32'h02_00_00_00;\n        end else if (kcnt == 2) begin\n            // Third round constant\n            out <= 32'h04_00_00_00;\n        end else if (kcnt == 3) begin\n            // Fourth round constant\n            out <= 32'h08_00_00_00;\n        end else if (kcnt == 4) begin\n            // Fifth round constant\n            out <= 32'h10_00_00_00;\n        end else if (kcnt == 5) begin\n            // Sixth round constant\n            out <= 32'h20_00_00_00;\n        end else if (kcnt == 6) begin\n            // Seventh round constant\n            out <= 32'h40_00_00_00;\n        end else if (kcnt == 7) begin\n            // Eighth round constant\n            out <= 32'h80_00_00_00;\n        end else if (kcnt == 8) begin\n            // Ninth round constant\n            out <= 32'h1B_00_00_00;\n        end else if (kcnt == 9) begin\n            // Tenth round constant\n            out <= 32'h36_00_00_00;\n        end else begin\n            // Other round constants\n            out <= 32'h00_00_00_00;\n        end\n    end\n\nendmodule\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[256:0];\n\n    // S-box Lookup Table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n        end\n    end\n\n    // S-box Transformation\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 6, "code": "```verilog\n// aes_inv_cipher_top.v\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    assign done = (dcnt == 11) & ~ld_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa <= 0;\n            dcnt <= 0;\n            kb <= 0;\n            kcnt <= 10;\n            ld_r <= 0;\n            text_out_r <= 0;\n        end\n        else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n            dcnt <= 1;\n        end\n        else if (kld) begin\n            kcnt <= 10;\n            kb <= key;\n        end\n        else if (dcnt < 11) begin\n            if (kcnt > 0) begin\n                kcnt <= kcnt - 1;\n                kb[kcnt] <= kb[kcnt + 1];\n            end\n            if (ld_r) begin\n                ld_r <= 0;\n                text_out_r <= sa[0][0] ^ kb[0];\n            end\n            else begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                InvMixColumns(sa);\n                AddRoundKey(sa, kb);\n                text_out_r <= sa[0][0];\n            end\n            dcnt <= dcnt + 1;\n        end\n    end\n\n    assign text_out = text_out_r;\n\n    // aes_key_expand_128 module\n    aes_key_expand_128 aes_key_expand_128_module(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    // aes_inv_sbox module\n    aes_inv_sbox aes_inv_sbox_module(\n        .a(sr),\n        .b(sub)\n    );\n\n    // aes_rcon module\n    aes_rcon aes_rcon_module(\n        .clk(clk),\n        .kld(kld),\n        .out(rc)\n    );\n\n    // aes_inv_cipher_top state machine\n    always @(posedge clk) begin\n        case (dcnt)\n            0: begin\n                if (ld) begin\n                    InvShiftRows(sa);\n                    InvSubBytes(sa);\n                    AddRoundKey(sa, kb);\n                    dcnt <= 1;\n                end\n            end\n            1: begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb);\n                dcnt <= 2;\n            end\n            2: begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb);\n                dcnt <= 3;\n            end\n            3: begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb);\n                dcnt <= 4;\n            end\n            4: begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb);\n                dcnt <= 5;\n            end\n            5: begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb);\n                dcnt <= 6;\n            end\n            6: begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb);\n                dcnt <= 7;\n            end\n            7: begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb);\n                dcnt <= 8;\n            end\n            8: begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb);\n                dcnt <= 9;\n            end\n            9: begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb);\n                dcnt <= 10;\n            end\n            10: begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb);\n                dcnt <= 11;\n            end\n            default: begin\n                dcnt <= 0;\n            end\n        endcase\n    end\n\n    // InvShiftRows function\n    function void InvShiftRows(ref reg [7:0] sa[0:3][0:3]);\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                if (i != 0) begin\n                    sa[i][j] <= sa[i - 1][j + 1];\n                end\n            end\n        end\n    endfunction\n\n    // InvSubBytes function\n    function void InvSubBytes(ref reg [7:0] sa[0:3][0:3]);\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sr <= sa[i][j];\n                InvSbox(sr);\n                sa[i][j] <= sub;\n            end\n        end\n    endfunction\n\n    // InvMixColumns function\n    function void InvMixColumns(ref reg [7:0] sa[0:3][0:3]);\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                out0 <= sa[i][j] ^ sa[i][j + 1] ^ sa[i][j + 2] ^ sa[i][j + 3];\n                out1 <= sa[i][j + 1] ^ sa[i][j + 2] ^ sa[i][j + 3] ^ sa[i][j];\n                out2 <= sa[i][j + 2] ^ sa[i][j + 3] ^ sa[i][j] ^ sa[i][j + 1];\n                out3 <= sa[i][j + 3] ^ sa[i][j] ^ sa[i][j + 1] ^ sa[i][j + 2];\n                sa[i][j] <= out0 ^ pmul_e(out0) ^ pmul_b(out1) ^ pmul_d(out2) ^ pmul_9(out3);\n                sa[i][j + 1] <= out1 ^ pmul_e(out1) ^ pmul_b(out2) ^ pmul_d(out3) ^ pmul_9(out0);\n                sa[i][j + 2] <= out2 ^ pmul_e(out2) ^ pmul_b(out3) ^ pmul_d(out0) ^ pmul_9(out1);\n                sa[i][j + 3] <= out3 ^ pmul_e(out3) ^ pmul_b(out0) ^ pmul_d(out1) ^ pmul_9(out2);\n            end\n        end\n    endfunction\n\n    // AddRoundKey function\n    function void AddRoundKey(ref reg [7:0] sa[0:3][0:3], ref reg [7:0] kb[0:3]);\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i][j] ^ kb[i][j];\n            end\n        end\n    endfunction\n\n    // InvSbox function\n    function void InvSbox(ref reg [7:0] sr, out reg [7:0] sub);\n        case (sr)\n            8'h00: sub <= 8'h52;\n            8'h01: sub <= 8'h06;\n            8'h02: sub <= 8'h52;\n            8'h03: sub <= 8'h09;\n            8'h04: sub <= 8'h49;\n            8'h05: sub <= 8'h09;\n            8'h06: sub <= 8'h49;\n            8'h07: sub <= 8'h24;\n            8'h08: sub <= 8'h24;\n            8'h09: sub <= 8'h50;\n            8'h0a: sub <= 8'h50;\n            8'h0b: sub <= 8'h30;\n            8'h0c: sub <= 8'h30;\n            8'h0d: sub <= 8'h19;\n            8'h0e: sub <= 8'h19;\n            8'h0f: sub <= 8'h36;\n            8'h10: sub <= 8'h36;\n            8'h11: sub <= 8'h31;\n            8'h12: sub <= 8'h31;\n            8'h13: sub <= 8'h26;\n            8'h14: sub <= 8'h26;\n            8'h15: sub <= 8'h34;\n            8'h16: sub <= 8'h34;\n            8'h17: sub <= 8'h23;\n            8'h18: sub <= 8'h23;\n            8'h19: sub <= 8'h37;\n            8'h1a: sub <= 8'h37;\n            8'h1b: sub <= 8'h32;\n            8'h1c: sub <= 8'h32;\n            8'h1d: sub <= 8'h2e;\n            8'h1e: sub <= 8'h2e;\n            8'h1f: sub <= 8'h29;\n            8'h20: sub <= 8'h29;\n            8'h21: sub <= 8'h35;\n            8'h22: sub <= 8'h35;\n            8'h23: sub <= 8'h2c;\n            8'h24: sub <= 8'h2c;\n            8'h25: sub <= 8'h33;\n            8'h26: sub <= 8'h33;\n            8'h27: sub <= 8'h25;\n            8'h28: sub <= 8'h25;\n            8'h29: sub <= 8'h3b;\n            8'h2a: sub <= 8'h3b;\n            8'h2b: sub <= 8'h3a;\n            8'h2c: sub <= 8'h3a;\n            8'h2d: sub <= 8'h38;\n            8'h2e: sub <= 8'h38;\n            8'h2f: sub <= 8'h28;\n            8'h30: sub <= 8'h28;\n            8'h31: sub <= 8'h39;\n            8'h32: sub <= 8'h39;\n            8'h33: sub <= 8'h22;\n            8'h34: sub <= 8'h22;\n            8'h35: sub <= 8'h2f;\n            8'h36: sub <= 8'h2f;\n            8'h37: sub <= 8'h21;\n            8'h38: sub <= 8'h21;\n            8'h39: sub <= 8'h2d;\n            8'h3a: sub <= 8'h2d;\n            8'h3b: sub <= 8'h2a;\n            8'h3c: sub <= 8'h2a;\n            8'h3d: sub <= 8'h2b;\n            8'h3e: sub <= 8'h2b;\n            8'h3f: sub <= 8'h2e;\n            default: sub <= 8'h00;\n        endcase\n    endfunction\n\n    // pmul_e function\n    function reg [7:0] pmul_e(ref reg [7:0] a);\n        case (a)\n            8'h01: pmul_e <= 8'h01;\n            8'h02: pmul_e <= 8'h02;\n            8'h04: pmul_e <= 8'h04;\n            8'h08: pmul_e <= 8'h08;\n            8'h10: pmul_e <= 8'h10;\n            8'h20: pmul_e <= 8'h20;\n            8'h40: pmul_e <= 8'h40;\n            8'h80: pmul_e <= 8'h80;\n            8'h0b: pmul_e <= 8'h0b;\n            8'h0d: pmul_e <= 8'h0d;\n            8'h0f: pmul_e <= 8'h0f;\n            8'h1b: pmul_e <= 8'h1b;\n            8'h1d: pmul_e <= 8'h1d;\n            8'h1f: pmul_e <= 8'h1f;\n            8'h2b: pmul_e <= 8'h2b;\n            8'h2d: pmul_e <= 8'h2d;\n            8'h2f: pmul_e <= 8'h2f;\n            8'h3b: pmul_e <= 8'h3b;\n            8'h3d: pmul_e <= 8'h3d;\n            8'h3f: pmul_e <= 8'h3f;\n            8'h69: pmul_e <= 8'h69;\n            8'h6b: pmul_e <= 8'h6b;\n            8'h6d: pmul_e <= 8'h6d;\n            8'h6f: pmul_e <= 8'h6f;\n            8'h73: pmul_e <= 8'h73;\n            8'h75: pmul_e <= 8'h75;\n            8'h77: pmul_e <= 8'h77;\n            8'h7b: pmul_e <= 8'h7b;\n            8'h7d: pmul_e <= 8'h7d;\n            8'h7f: pmul_e <= 8'h7f;\n            8'h83: pmul_e <= 8'h83;\n            8'h85: pmul_e <= 8'h85;\n            8'h87: pmul_e <= 8'h87;\n            8'h8b: pmul_e <= 8'h8b;\n            8'h8d: pmul_e <= 8'h8d;\n            8'h8f: pmul_e <= 8'h8f;\n            8'h93: pmul_e <= 8'h93;\n            8'h95: pmul_e <= 8'h95;\n            8'h97: pmul_e <= 8'h97;\n            8'h9b: pmul_e <= 8'h9b;\n            8'h9d: pmul_e <= 8'h9d;\n            8'h9f: pmul_e <= 8'h9f;\n            8'a3: pmul_e <= 8'a3;\n            8'a5: pmul_e <= 8'a5;\n            8'a7: pmul_e <= 8'a7;\n            8'ab: pmul_e <= 8'ab;\n            8'ad: pmul_e <= 8'ad;\n            8'af: pmul_e <= 8'af;\n            8'b3: pmul_e <= 8'b3;\n            8'b5: pmul_e <= 8'b5;\n            8'b7: pmul_e <= 8'b7;\n            8'bb: pmul_e <= 8'bb;\n            8'bd: pmul_e <= 8'bd;\n            8'bf: pmul_e <= 8'bf;\n            8xc: pmul_e <= 8'xc;\n            8'xd: pmul_e <= 8'xd;\n            8'xf: pmul_e <= 8'xf;\n            8'x3: pmul_e <= 8'x3;\n            8'x5: pmul_e <= 8'x5;\n            8'x7: pmul_e <= 8'x7;\n            8'xb: pmul_e <= 8'xb;\n            8'xd: pmul_e <= 8'xd;\n            8'xf: pmul_e <= 8'xf;\n            8'x9: pmul_e <= 8'x9;\n            8'xb: pmul_e <= 8'xb;\n            8'xd: pmul_e <= 8'xd;\n            8'xf: pmul_e <= 8'xf;\n            8'x1: pmul_e <= 8'x1;\n            8'x3: pmul_e <= 8'x3;\n            8'x5: pmul_e <= 8'x5;\n            8'x7: pmul_e <= 8'x7;\n            8'x9: pmul_e <= 8'x9;\n            8'xb: pmul_e <= 8'xb;\n            8'xd: pmul_e <= 8'xd;\n            8'xf: pmul_e <= 8'xf;\n            8'x1: pmul_e <= 8'x1;\n            8'x3: pmul_e <= 8'x3;\n            8'x5: pmul_e <= 8'x5;\n            8'x7: pmul_e <= 8'x7;\n            8'x9: pmul_e <= 8'x9;\n            8'xb: pmul_e <= 8'xb;\n            8'xd: pmul_e <= 8'xd;\n            8'xf: pmul_e <= 8'xf;\n            8'x1: pmul_e <= 8'x1;\n            8'x3: pmul_e <= 8'x3;\n            8'x5: pmul_e <= 8'x5;\n            8'x7: pmul_e <= 8'x7;\n            8'x9: pmul_e <= 8'x9;\n            8'xb: pmul_e <= 8'xb;\n            8'xd: pmul_e <= 8'xd;\n            8'xf: pmul_e <= 8'xf;\n            default: pmul_e <= 8'00;\n        endcase\n    endfunction\n\n    // pmul_b function\n    function reg [7:0] pmul_b(ref reg [7:0] a);\n        case (a)\n            8'h01: pmul_b <= 8'h01;\n            8'h02: pmul_b <= 8'h02;\n            8'h04: pmul_b <= 8'h04;\n            8'h08: pmul_b <= 8'h08;\n            8'h10: pmul_b <= 8'h10;\n            8'h20: pmul_b <= 8'h20;\n            8'h40: pmul_b <= 8'h40;\n            8'h80: pmul_b <= 8'h80;\n            8'h0b: pmul_b <= 8'h0b;\n            8'h0d: pmul_b <= 8'h0d;\n            8'h0f: pmul_b <= 8'h0f;\n            8'h1b: pmul_b <= 8'h1b;\n            8'h1d: pmul_b <= 8'h1d;\n            8'h1f: pmul_b <= 8'h1f;\n            8'h2b: pmul_b <= 8'h2b;\n            8'h2d: pmul_b <= 8'h2d;\n            8'h2f: pmul_b <= 8'h2f;\n            8'h3b: pmul_b <= 8'h3b;\n            8'h3d: pmul_b <= 8'h3d;\n            8'h3f: pmul_b <= 8'h3f;\n            8'h69: pmul_b <= 8'h69;\n            8'h6b: pmul_b <= 8'h6b;\n            8'h6d: pmul_b <= 8'h6d;\n            8'h6f: pmul_b <= 8'h6f;\n            8'h73: pmul_b <= 8'h73;\n            8'h75: pmul_b <= 8'h75;\n           ", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 7, "code": "// aes_inv_cipher_top.v\n\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 4'd0;\n            kcnt <= 4'd10;\n            ld_r <= 1'b0;\n        end\n        else if (kld) begin\n            // Key Loading\n            for (int i = 10; i >= 0; i--) begin\n                kb[i] <= key[31 + i*32 - 1: i*32];\n            end\n            kcnt <= 4'd10;\n            ld_r <= 1'b0;\n        end\n        else if (ld) begin\n            // Initial Round\n            ld_r <= 1'b1;\n            for (int i = 0; i < 4; i++) begin\n                sa[i][0] <= text_in[7 + i*32 - 1: i*32];\n            end\n            dcnt <= 4'd1;\n        end\n        else if (ld_r) begin\n            // Standard Round\n            InvShiftRows(sa);\n            InvSubBytes(sa);\n            AddRoundKey(sa);\n            InvMixColumns(sa);\n            dcnt <= dcnt + 1;\n        end\n        else if (dcnt == 11) begin\n            // Final Round\n            InvShiftRows(sa);\n            InvSubBytes(sa);\n            AddRoundKey(sa);\n            text_out_r <= sa[0][0] << 120 | sa[1][0] << 112 | sa[2][0] << 104 | sa[3][0] << 96 |\n                         sa[0][1] << 88 | sa[1][1] << 80 | sa[2][1] << 72 | sa[3][1] << 64 |\n                         sa[0][2] << 56 | sa[1][2] << 48 | sa[2][2] << 40 | sa[3][2] << 32 |\n                         sa[0][3] << 24 | sa[1][3] << 16 | sa[2][3] << 8  | sa[3][3];\n            done <= 1'b1;\n        end\n        else begin\n            // Idle State\n            ld_r <= 1'b0;\n        end\n    end\n\n    // InvShiftRows\n    task InvShiftRows();\n        for (int i = 1; i < 4; i++) begin\n            for (int j = 3; j >= i; j--) begin\n                sa[i][j] <= sa[i][j-1];\n            end\n            sa[i][0] <= sa[i][3];\n        end\n    endtask\n\n    // InvSubBytes\n    task InvSubBytes();\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= InvSBox(sa[i][j]);\n            end\n        end\n    endtask\n\n    // InvSBox\n    function [7:0] InvSBox([7:0] a);\n        case (a)\n            8'h00: InvSBox = 8'h52;\n            8'h01: InvSBox = 8'h09;\n            8'h02: InvSBox = 8'h18;\n            8'h03: InvSBox = 8'h20;\n            8'h04: InvSBox = 8'h28;\n            8'h05: InvSBox = 8'h1B;\n            8'h06: InvSBox = 8'h22;\n            8'h07: InvSBox = 8'h24;\n            8'h08: InvSBox = 8'h2A;\n            8'h09: InvSBox = 8'h2E;\n            8'h0A: InvSBox = 8'h38;\n            8'h0B: InvSBox = 8'h3F;\n            8'h0C: InvSBox = 8'h40;\n            8'h0D: InvSBox = 8'h4E;\n            8'h0E: InvSBox = 8'h5A;\n            8'h0F: InvSBox = 8'h65;\n            8'h10: InvSBox = 8'h6D;\n            8'h11: InvSBox = 8'h7A;\n            8'h12: InvSBox = 8'h75;\n            8'h13: InvSBox = 8'hF2;\n            8'h14: InvSBox = 8'h5C;\n            8'h15: InvSBox = 8'hB5;\n            8'h16: InvSBox = 8'h46;\n            8'h17: InvSBox = 8'h18;\n            8'h18: InvSBox = 8'h38;\n            8'h19: InvSBox = 8'h55;\n            8'h1A: InvSBox = 8'h4B;\n            8'h1B: InvSBox = 8'hF8;\n            8'h1C: InvSBox = 8'h5A;\n            8'h1D: InvSBox = 8'h8E;\n            8'h1E: InvSBox = 8'hAB;\n            8'h1F: InvSBox = 8'hAC;\n            8'h20: InvSBox = 8'h4F;\n            8'h21: InvSBox = 8'h8D;\n            8'h22: InvSBox = 8'hB3;\n            8'h23: InvSBox = 8'h26;\n            8'h24: InvSBox = 8'hC8;\n            8'h25: InvSBox = 8'hBE;\n            8'h26: InvSBox = 8'h40;\n            8'h27: InvSBox = 8'h3B;\n            8'h28: InvSBox = 8'h79;\n            8'h29: InvSBox = 8'h5C;\n            8'h2A: InvSBox = 8'h62;\n            8'h2B: InvSBox = 8'hF0;\n            8'h2C: InvSBox = 8'h78;\n            8'h2D: InvSBox = 8'h6E;\n            8'h2E: InvSBox = 8'h6C;\n            8'h2F: InvSBox = 8'h5A;\n            8'h30: InvSBox = 8'h07;\n            8'h31: InvSBox = 8'h3F;\n            8'h32: InvSBox = 8'h5D;\n            8'h33: InvSBox = 8'h0A;\n            8'h34: InvSBox = 8'hF7;\n            8'h35: InvSBox = 8'h38;\n            8'h36: InvSBox = 8'h5E;\n            8'h37: InvSBox = 8'h49;\n            8'h38: InvSBox = 8'h6D;\n            8'h39: InvSBox = 8'h66;\n            8'h3A: InvSBox = 8'h10;\n            8'h3B: InvSBox = 8'h35;\n            8'h3C: InvSBox = 8'h41;\n            8'h3D: InvSBox = 8'h1A;\n            8'h3E: InvSBox = 8'h29;\n            8'h3F: InvSBox = 8'h25;\n            8'h40: InvSBox = 8'h48;\n            8'h41: InvSBox = 8'hD8;\n            8'h42: InvSBox = 8'h5C;\n            8'h43: InvSBox = 8'h5F;\n            8'h44: InvSBox = 8'h65;\n            8'h45: InvSBox = 8'h19;\n            8'h46: InvSBox = 8'h04;\n            8'h47: InvSBox = 8'h62;\n            8'h48: InvSBox = 8'h2A;\n            8'h49: InvSBox = 8'h66;\n            8'h4A: InvSBox = 8'h3C;\n            8'h4B: InvSBox = 8'h74;\n            8'h4C: InvSBox = 8'hB0;\n            8'h4D: InvSBox = 8'h4E;\n            8'h4E: InvSBox = 8'h69;\n            8'h4F: InvSBox = 8'h36;\n            8'h50: InvSBox = 8'hC0;\n            8'h51: InvSBox = 8'h9F;\n            8'h52: InvSBox = 8'hE8;\n            8'h53: InvSBox = 8'h5B;\n            8'h54: InvSBox = 8'hB9;\n            8'h55: InvSBox = 8'h5A;\n            8'h56: InvSBox = 8'hF4;\n            8'h57: InvSBox = 8'h8E;\n            8'h58: InvSBox = 8'h34;\n            8'h59: InvSBox = 8'hB3;\n            8'h5A: InvSBox = 8'h73;\n            8'h5B: InvSBox = 8'h35;\n            8'h5C: InvSBox = 8'h2C;\n            8'h5D: InvSBox = 8'h07;\n            8'h5E: InvSBox = 8'h3C;\n            8'h5F: InvSBox = 8'hB3;\n            8'h60: InvSBox = 8'h77;\n            8'h61: InvSBox = 8'hB7;\n            8'h62: InvSBox = 8'hC6;\n            8'h63: InvSBox = 8'hE1;\n            default: InvSBox = 8'h00;\n        endcase\n    endfunction\n\n    // InvMixColumns\n    task InvMixColumns();\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i][j] ^ (sa[0][j] << 1) ^ (sa[1][j] << 3) ^ (sa[2][j] << 2) ^ (sa[3][j] << 4);\n            end\n        end\n    endtask\n\n    // AddRoundKey\n    task AddRoundKey();\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i][j] ^ kb[dcnt][31 + j*8 - 1: j*8];\n            end\n        end\n    endtask\n\n    // Output\n    assign text_out = text_out_r;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 8, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    // Registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expand_128_inst(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox aes_inv_sbox_inst[0:15] (\n        .a(sa[0][0]),\n        .b(us00)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[16:31] (\n        .a(sa[0][1]),\n        .b(us01)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[32:47] (\n        .a(sa[0][2]),\n        .b(us02)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[48:63] (\n        .a(sa[0][3]),\n        .b(us03)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[64:79] (\n        .a(sa[1][0]),\n        .b(us10)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[80:95] (\n        .a(sa[1][1]),\n        .b(us11)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[96:111] (\n        .a(sa[1][2]),\n        .b(us12)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[112:127] (\n        .a(sa[1][3]),\n        .b(us13)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[128:143] (\n        .a(sa[2][0]),\n        .b(us20)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[144:159] (\n        .a(sa[2][1]),\n        .b(us21)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[160:175] (\n        .a(sa[2][2]),\n        .b(us22)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[176:191] (\n        .a(sa[2][3]),\n        .b(us23)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[192:207] (\n        .a(sa[3][0]),\n        .b(us30)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[208:223] (\n        .a(sa[3][1]),\n        .b(us31)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[224:239] (\n        .a(sa[3][2]),\n        .b(us32)\n    );\n    aes_inv_sbox aes_inv_sbox_inst[240:255] (\n        .a(sa[3][3]),\n        .b(us33)\n    );\n\n    // State Transition Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end\n        else if (ld_r) begin\n            text_in_r <= text_in;\n            ld_r <= 0;\n        end\n        else if (kld) begin\n            kcnt <= 0xA;\n            kb[10] <= key[127:96];\n            kb[9] <= key[95:64];\n            kb[8] <= key[63:32];\n            kb[7] <= key[31:0];\n            ld_r <= 1;\n        end\n        else if (dcnt < 11) begin\n            if (kcnt > 0) begin\n                kcnt <= kcnt - 1;\n            end\n            if (kcnt == 0) begin\n                ld_r <= 1;\n            end\n            if (ld_r) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= kb[10 + (i * 4 + j)];\n                    end\n                end\n                ld_r <= 0;\n            end\n            if (dcnt == 0) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ wk3[32 * i + j];\n                    end\n                end\n            end\n            if (dcnt > 0) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (j == 0) begin\n                            sa[i][j] <= sa[i][j + 1];\n                        end\n                        else if (j == 3) begin\n                            sa[i][j] <= sa[i][0];\n                        end\n                        else begin\n                            sa[i][j] <= sa[i][j + 1];\n                        end\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (j == 0) begin\n                            sa[i][j] <= us00 ^ sa[i][j + 1];\n                        end\n                        else if (j == 3) begin\n                            sa[i][j] <= us03 ^ sa[i][0];\n                        end\n                        else begin\n                            sa[i][j] <= us0[j + 1] ^ sa[i][j + 1];\n                        end\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (j == 0) begin\n                            sa[i][j] <= sa[i][j] ^ wk2[32 * i + j];\n                        end\n                        else if (j == 3) begin\n                            sa[i][j] <= sa[i][0] ^ wk2[32 * i + j];\n                        end\n                        else begin\n                            sa[i][j] <= sa[i][j] ^ wk2[32 * i + j];\n                        end\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (j == 0) begin\n                            sa[i][j] <= sa[i][j + 1];\n                        end\n                        else if (j == 3) begin\n                            sa[i][j] <= sa[i][0];\n                        end\n                        else begin\n                            sa[i][j] <= sa[i][j + 1];\n                        end\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (j == 0) begin\n                            sa[i][j] <= us10 ^ sa[i][j + 1];\n                        end\n                        else if (j == 3) begin\n                            sa[i][j] <= us13 ^ sa[i][0];\n                        end\n                        else begin\n                            sa[i][j] <= us1[j + 1] ^ sa[i][j + 1];\n                        end\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (j == 0) begin\n                            sa[i][j] <= sa[i][j] ^ wk1[32 * i + j];\n                        end\n                        else if (j == 3) begin\n                            sa[i][j] <= sa[i][0] ^ wk1[32 * i + j];\n                        end\n                        else begin\n                            sa[i][j] <= sa[i][j] ^ wk1[32 * i + j];\n                        end\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (j == 0) begin\n                            sa[i][j] <= sa[i][j + 1];\n                        end\n                        else if (j == 3) begin\n                            sa[i][j] <= sa[i][0];\n                        end\n                        else begin\n                            sa[i][j] <= sa[i][j + 1];\n                        end\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (j == 0) begin\n                            sa[i][j] <= us20 ^ sa[i][j + 1];\n                        end\n                        else if (j == 3) begin\n                            sa[i][j] <= us23 ^ sa[i][0];\n                        end\n                        else begin\n                            sa[i][j] <= us2[j + 1] ^ sa[i][j + 1];\n                        end\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (j == 0) begin\n                            sa[i][j] <= sa[i][j] ^ wk0[32 * i + j];\n                        end\n                        else if (j == 3) begin\n                            sa[i][j] <= sa[i][0] ^ wk0[32 * i + j];\n                        end\n                        else begin\n                            sa[i][j] <= sa[i][j] ^ wk0[32 * i + j];\n                        end\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (j == 0) begin\n                            sa[i][j] <= sa[i][j + 1];\n                        end\n                        else if (j == 3) begin\n                            sa[i][j] <= sa[i][0];\n                        end\n                        else begin\n                            sa[i][j] <= sa[i][j + 1];\n                        end\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (j == 0) begin\n                            sa[i][j] <= us30 ^ sa[i][j + 1];\n                        end\n                        else if (j == 3) begin\n                            sa[i][j] <= us33 ^ sa[i][0];\n                        end\n                        else begin\n                            sa[i][j] <= us3[j + 1] ^ sa[i][j + 1];\n                        end\n                    end\n                end\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        if (j == 0) begin\n                            sa[i][j] <= sa[i][j] ^ wk3[32 * i + j];\n                        end\n                        else if (j == 3) begin\n                            sa[i][j] <= sa[i][0] ^ wk3[32 * i + j];\n                        end\n                        else begin\n                            sa[i][j] <= sa[i][j] ^ wk3[32 * i + j];\n                        end\n                    end\n                end\n                dcnt <= dcnt + 1;\n            end\n        end\n        else if (dcnt == 11) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    if (j == 0) begin\n                        sa[i][j] <= sa[i][j + 1];\n                    end\n                    else if (j == 3) begin\n                        sa[i][j] <= sa[i][0];\n                    end\n                    else begin\n                        sa[i][j] <= sa[i][j + 1];\n                    end\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    if (j == 0) begin\n                        sa[i][j] <= us30 ^ sa[i][j + 1];\n                    end\n                    else if (j == 3) begin\n                        sa[i][j] <= us33 ^ sa[i][0];\n                    end\n                    else begin\n                        sa[i][j] <= us3[j + 1] ^ sa[i][j + 1];\n                    end\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    if (j == 0) begin\n                        sa[i][j] <= sa[i][j] ^ wk3[32 * i + j];\n                    end\n                    else if (j == 3) begin\n                        sa[i][j] <= sa[i][0] ^ wk3[32 * i + j];\n                    end\n                    else begin\n                        sa[i][j] <= sa[i][j] ^ wk3[32 * i + j];\n                    end\n                end\n            end\n            done <= 1;\n        end\n        else begin\n            done <= 0;\n        end\n    end\n\n    // Output\n    always @(posedge clk) begin\n        if (ld_r) begin\n            text_out_r <= text_in_r;\n        end\n        else begin\n            text_out_r <= 0;\n        end\n    end\n\n    // Output\n    assign text_out = text_out_r;\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expansion_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    // Registers\n    reg [31:0] w[0:3];\n    reg [3:0] kcnt;\n    reg [7:0] rcon;\n\n    // Submodules\n    aes_rcon aes_rcon_inst(\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n    aes_sbox aes_sbox_inst[0:3] (\n        .a(w[0]),\n        .b(wk0)\n    );\n    aes_sbox aes_sbox_inst[4:7] (\n        .a(w[1]),\n        .b(wk1)\n    );\n    aes_sbox aes_sbox_inst[8:11] (\n        .a(w[2]),\n        .b(wk2)\n    );\n    aes_sbox aes_sbox_inst[12:15] (\n        .a(w[3]),\n        .b(wk3)\n    );\n\n    // State Transition Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            kcnt <= 0;\n            w[0] <= key[31:0];\n            w[1] <= key[63:32];\n            w[2] <= key[95:64];\n            w[3] <= key[127:96];\n        end\n        else if (kld) begin\n            kcnt <= 0;\n            w[0] <= key[31:0];\n            w[1] <= key[63:32];\n            w[2] <= key[95:64];\n            w[3] <= key[127:96];\n        end\n        else if (kcnt < 10) begin\n            kcnt <= kcnt + 1;\n            if (kcnt == 1) begin\n                w[0] <= w[3];\n                w[1] <= w[0] ^ rcon;\n                w[2] <= w[1];\n                w[3] <= w[2];\n            end\n            else if (kcnt == 2) begin\n                w[0] <= w[3];\n                w[1] <= w[0] ^ rcon;\n                w[2] <= w[1];\n                w[3] <= w[2];\n            end\n            else if (kcnt == 3) begin\n                w[0] <= w[3];\n                w[1] <= w[0] ^ rcon;\n                w[2] <= w[1];\n                w[3] <= w[2];\n            end\n            else if (kcnt == 4) begin\n                w[0] <= w[3];\n                w[1] <= w[0] ^ rcon;\n                w[2] <= w[1];\n                w[3] <= w[2];\n            end\n            else if (kcnt == 5) begin\n                w[0] <= w[3];\n                w[1] <= w[0] ^ rcon;\n                w[2] <= w[1];\n                w[3] <= w[2];\n            end\n            else if (kcnt == 6) begin\n                w[0] <= w[3];\n                w[1] <= w[0] ^ rcon;\n                w[2] <= w[1];\n                w[3] <= w[2];\n            end\n            else if (kcnt == 7) begin\n                w[0] <= w[3];\n                w[1] <= w[0] ^ rcon;\n                w[2] <= w[1];\n                w[3] <= w[2];\n            end\n            else if (kcnt == 8) begin\n                w[0] <= w[3];\n                w[1] <= w[0] ^ rcon;\n                w[2] <= w[1];\n                w[3] <= w[2];\n            end\n            else if (kcnt == 9) begin\n                w[0] <= w[3];\n                w[1] <= w[0] ^ rcon;\n                w[2] <= w[1];\n                w[3] <= w[2];\n            end\n            else begin\n                w[0] <= w[3];\n                w[1] <= w[0] ^ rcon;\n                w[2] <= w[1];\n                w[3] <= w[2];\n            end\n        end\n        else begin\n            wo_0 <= w[0];\n            wo_1 <= w[1];\n            wo_2 <= w[2];\n            wo_3 <= w[3];\n        end\n    end\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    // Registers\n    reg [3:0] rcnt;\n\n    // State Transition Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end\n        else if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end\n        else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            if (rcnt == 1) begin\n                out <= 32'h02_00_00_00;\n            end\n            else if (rcnt == 2) begin\n                out <= 32'h04_00_00_00;\n            end\n            else if (rcnt == 3) begin\n                out <= 32'h08_00_00_00;\n            end\n            else if (rcnt == 4) begin\n                out <= 32'h10_00_00_00;\n            end\n            else if (rcnt == 5) begin\n                out <= 32'h20_00_00_00;\n            end\n            else if (rcnt == 6) begin\n                out <= 32'h40_00_00_00;\n            end\n            else if (rcnt == 7) begin\n                out <= 32'h80_00_00_00;\n            end\n            else if (rcnt == 8) begin\n                out <= 32'h1b_00_00_00;\n            end\n            else if (rcnt == 9) begin\n                out <= 32'h36_00_00_00;\n            end\n            else begin\n                out <= 32'h00_00_00_00;\n            end\n        end\n        else begin\n            out <= 32'h00_00_00_00;\n        end\n    end\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // ROM\n    reg [7:0] sbox[0:255];\n\n    // Initialization\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n        end\n    end\n\n    // Output\n    assign b = sbox[a];\n\nendmodule\n\n// aes_inv_sbox module\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // ROM\n    reg [7:0] inv_sbox[0:255];\n\n    // Initialization\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = i;\n        end\n    end\n\n    // Output\n    assign b = inv_sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 9, "code": "```verilog\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\nreg [3:0] dcnt;\nreg [3:0] kcnt;\nreg [127:0] kb[10:0];\nreg [127:0] sa[0:3][0:3];\nreg ld_r;\nreg [127:0] text_in_r;\nreg [127:0] text_out_r;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        dcnt <= 0;\n        kcnt <= 0xA;\n        kb <= 0;\n        sa <= 0;\n        ld_r <= 0;\n        text_in_r <= 0;\n        text_out_r <= 0;\n    end else if (kld) begin\n        if (kcnt == 0) begin\n            kcnt <= 0xA;\n            kb <= 0;\n        end else begin\n            kcnt <= kcnt - 1;\n            kb[kcnt] <= key[(kcnt*32 + 31):kcnt*32];\n        end\n    end else if (ld) begin\n        text_in_r <= text_in;\n        ld_r <= 1;\n    end else if (ld_r) begin\n        ld_r <= 0;\n        if (dcnt == 0) begin\n            dcnt <= 1;\n            text_out_r <= sa[0][0];\n        end else if (dcnt == 1) begin\n            dcnt <= 2;\n            text_out_r <= sa[0][1];\n        end else if (dcnt == 2) begin\n            dcnt <= 3;\n            text_out_r <= sa[0][2];\n        end else if (dcnt == 3) begin\n            dcnt <= 4;\n            text_out_r <= sa[0][3];\n        end else if (dcnt == 4) begin\n            dcnt <= 5;\n            text_out_r <= sa[1][0];\n        end else if (dcnt == 5) begin\n            dcnt <= 6;\n            text_out_r <= sa[1][1];\n        end else if (dcnt == 6) begin\n            dcnt <= 7;\n            text_out_r <= sa[1][2];\n        end else if (dcnt == 7) begin\n            dcnt <= 8;\n            text_out_r <= sa[1][3];\n        end else if (dcnt == 8) begin\n            dcnt <= 9;\n            text_out_r <= sa[2][0];\n        end else if (dcnt == 9) begin\n            dcnt <= 10;\n            text_out_r <= sa[2][1];\n        end else if (dcnt == 10) begin\n            dcnt <= 11;\n            text_out_r <= sa[2][2];\n        end else if (dcnt == 11) begin\n            dcnt <= 12;\n            text_out_r <= sa[2][3];\n        end else if (dcnt == 12) begin\n            dcnt <= 13;\n            text_out_r <= sa[3][0];\n        end else if (dcnt == 13) begin\n            dcnt <= 14;\n            text_out_r <= sa[3][1];\n        end else if (dcnt == 14) begin\n            dcnt <= 15;\n            text_out_r <= sa[3][2];\n        end else if (dcnt == 15) begin\n            dcnt <= 16;\n            text_out_r <= sa[3][3];\n        end else if (dcnt == 16) begin\n            dcnt <= 17;\n            text_out_r <= sa[0][0] ^ kb[kcnt];\n        end else if (dcnt == 17) begin\n            dcnt <= 18;\n            text_out_r <= sa[0][1] ^ kb[kcnt];\n        end else if (dcnt == 18) begin\n            dcnt <= 19;\n            text_out_r <= sa[0][2] ^ kb[kcnt];\n        end else if (dcnt == 19) begin\n            dcnt <= 20;\n            text_out_r <= sa[0][3] ^ kb[kcnt];\n        end else if (dcnt == 20) begin\n            dcnt <= 21;\n            text_out_r <= sa[1][0] ^ kb[kcnt];\n        end else if (dcnt == 21) begin\n            dcnt <= 22;\n            text_out_r <= sa[1][1] ^ kb[kcnt];\n        end else if (dcnt == 22) begin\n            dcnt <= 23;\n            text_out_r <= sa[1][2] ^ kb[kcnt];\n        end else if (dcnt == 23) begin\n            dcnt <= 24;\n            text_out_r <= sa[1][3] ^ kb[kcnt];\n        end else if (dcnt == 24) begin\n            dcnt <= 25;\n            text_out_r <= sa[2][0] ^ kb[kcnt];\n        end else if (dcnt == 25) begin\n            dcnt <= 26;\n            text_out_r <= sa[2][1] ^ kb[kcnt];\n        end else if (dcnt == 26) begin\n            dcnt <= 27;\n            text_out_r <= sa[2][2] ^ kb[kcnt];\n        end else if (dcnt == 27) begin\n            dcnt <= 28;\n            text_out_r <= sa[2][3] ^ kb[kcnt];\n        end else if (dcnt == 28) begin\n            dcnt <= 29;\n            text_out_r <= sa[3][0] ^ kb[kcnt];\n        end else if (dcnt == 29) begin\n            dcnt <= 30;\n            text_out_r <= sa[3][1] ^ kb[kcnt];\n        end else if (dcnt == 30) begin\n            dcnt <= 31;\n            text_out_r <= sa[3][2] ^ kb[kcnt];\n        end else if (dcnt == 31) begin\n            dcnt <= 32;\n            text_out_r <= sa[3][3] ^ kb[kcnt];\n        end else if (dcnt == 32) begin\n            dcnt <= 33;\n            text_out_r <= sa[0][0];\n        end else if (dcnt == 33) begin\n            dcnt <= 34;\n            text_out_r <= sa[0][1];\n        end else if (dcnt == 34) begin\n            dcnt <= 35;\n            text_out_r <= sa[0][2];\n        end else if (dcnt == 35) begin\n            dcnt <= 36;\n            text_out_r <= sa[0][3];\n        end else if (dcnt == 36) begin\n            dcnt <= 37;\n            text_out_r <= sa[1][0];\n        end else if (dcnt == 37) begin\n            dcnt <= 38;\n            text_out_r <= sa[1][1];\n        end else if (dcnt == 38) begin\n            dcnt <= 39;\n            text_out_r <= sa[1][2];\n        end else if (dcnt == 39) begin\n            dcnt <= 40;\n            text_out_r <= sa[1][3];\n        end else if (dcnt == 40) begin\n            dcnt <= 41;\n            text_out_r <= sa[2][0];\n        end else if (dcnt == 41) begin\n            dcnt <= 42;\n            text_out_r <= sa[2][1];\n        end else if (dcnt == 42) begin\n            dcnt <= 43;\n            text_out_r <= sa[2][2];\n        end else if (dcnt == 43) begin\n            dcnt <= 44;\n            text_out_r <= sa[2][3];\n        end else if (dcnt == 44) begin\n            dcnt <= 45;\n            text_out_r <= sa[3][0];\n        end else if (dcnt == 45) begin\n            dcnt <= 46;\n            text_out_r <= sa[3][1];\n        end else if (dcnt == 46) begin\n            dcnt <= 47;\n            text_out_r <= sa[3][2];\n        end else if (dcnt == 47) begin\n            dcnt <= 48;\n            text_out_r <= sa[3][3];\n        end else if (dcnt == 48) begin\n            dcnt <= 49;\n            text_out_r <= sa[0][0] ^ kb[kcnt];\n        end else if (dcnt == 49) begin\n            dcnt <= 50;\n            text_out_r <= sa[0][1] ^ kb[kcnt];\n        end else if (dcnt == 50) begin\n            dcnt <= 51;\n            text_out_r <= sa[0][2] ^ kb[kcnt];\n        end else if (dcnt == 51) begin\n            dcnt <= 52;\n            text_out_r <= sa[0][3] ^ kb[kcnt];\n        end else if (dcnt == 52) begin\n            dcnt <= 53;\n            text_out_r <= sa[1][0] ^ kb[kcnt];\n        end else if (dcnt == 53) begin\n            dcnt <= 54;\n            text_out_r <= sa[1][1] ^ kb[kcnt];\n        end else if (dcnt == 54) begin\n            dcnt <= 55;\n            text_out_r <= sa[1][2] ^ kb[kcnt];\n        end else if (dcnt == 55) begin\n            dcnt <= 56;\n            text_out_r <= sa[1][3] ^ kb[kcnt];\n        end else if (dcnt == 56) begin\n            dcnt <= 57;\n            text_out_r <= sa[2][0] ^ kb[kcnt];\n        end else if (dcnt == 57) begin\n            dcnt <= 58;\n            text_out_r <= sa[2][1] ^ kb[kcnt];\n        end else if (dcnt == 58) begin\n            dcnt <= 59;\n            text_out_r <= sa[2][2] ^ kb[kcnt];\n        end else if (dcnt == 59) begin\n            dcnt <= 60;\n            text_out_r <= sa[2][3] ^ kb[kcnt];\n        end else if (dcnt == 60) begin\n            dcnt <= 61;\n            text_out_r <= sa[3][0] ^ kb[kcnt];\n        end else if (dcnt == 61) begin\n            dcnt <= 62;\n            text_out_r <= sa[3][1] ^ kb[kcnt];\n        end else if (dcnt == 62) begin\n            dcnt <= 63;\n            text_out_r <= sa[3][2] ^ kb[kcnt];\n        end else if (dcnt == 63) begin\n            dcnt <= 64;\n            text_out_r <= sa[3][3] ^ kb[kcnt];\n        end else if (dcnt == 64) begin\n            dcnt <= 65;\n            text_out_r <= sa[0][0];\n        end else if (dcnt == 65) begin\n            dcnt <= 66;\n            text_out_r <= sa[0][1];\n        end else if (dcnt == 66) begin\n            dcnt <= 67;\n            text_out_r <= sa[0][2];\n        end else if (dcnt == 67) begin\n            dcnt <= 68;\n            text_out_r <= sa[0][3];\n        end else if (dcnt == 68) begin\n            dcnt <= 69;\n            text_out_r <= sa[1][0];\n        end else if (dcnt == 69) begin\n            dcnt <= 70;\n            text_out_r <= sa[1][1];\n        end else if (dcnt == 70) begin\n            dcnt <= 71;\n            text_out_r <= sa[1][2];\n        end else if (dcnt == 71) begin\n            dcnt <= 72;\n            text_out_r <= sa[1][3];\n        end else if (dcnt == 72) begin\n            dcnt <= 73;\n            text_out_r <= sa[2][0];\n        end else if (dcnt == 73) begin\n            dcnt <= 74;\n            text_out_r <= sa[2][1];\n        end else if (dcnt == 74) begin\n            dcnt <= 75;\n            text_out_r <= sa[2][2];\n        end else if (dcnt == 75) begin\n            dcnt <= 76;\n            text_out_r <= sa[2][3];\n        end else if (dcnt == 76) begin\n            dcnt <= 77;\n            text_out_r <= sa[3][0];\n        end else if (dcnt == 77) begin\n            dcnt <= 78;\n            text_out_r <= sa[3][1];\n        end else if (dcnt == 78) begin\n            dcnt <= 79;\n            text_out_r <= sa[3][2];\n        end else if (dcnt == 79) begin\n            dcnt <= 80;\n            text_out_r <= sa[3][3];\n        end else if (dcnt == 80) begin\n            dcnt <= 81;\n            text_out_r <= sa[0][0] ^ kb[kcnt];\n        end else if (dcnt == 81) begin\n            dcnt <= 82;\n            text_out_r <= sa[0][1] ^ kb[kcnt];\n        end else if (dcnt == 82) begin\n            dcnt <= 83;\n            text_out_r <= sa[0][2] ^ kb[kcnt];\n        end else if (dcnt == 83) begin\n            dcnt <= 84;\n            text_out_r <= sa[0][3] ^ kb[kcnt];\n        end else if (dcnt == 84) begin\n            dcnt <= 85;\n            text_out_r <= sa[1][0] ^ kb[kcnt];\n        end else if (dcnt == 85) begin\n            dcnt <= 86;\n            text_out_r <= sa[1][1] ^ kb[kcnt];\n        end else if (dcnt == 86) begin\n            dcnt <= 87;\n            text_out_r <= sa[1][2] ^ kb[kcnt];\n        end else if (dcnt == 87) begin\n            dcnt <= 88;\n            text_out_r <= sa[1][3] ^ kb[kcnt];\n        end else if (dcnt == 88) begin\n            dcnt <= 89;\n            text_out_r <= sa[2][0] ^ kb[kcnt];\n        end else if (dcnt == 89) begin\n            dcnt <= 90;\n            text_out_r <= sa[2][1] ^ kb[kcnt];\n        end else if (dcnt == 90) begin\n            dcnt <= 91;\n            text_out_r <= sa[2][2] ^ kb[kcnt];\n        end else if (dcnt == 91) begin\n            dcnt <= 92;\n            text_out_r <= sa[2][3] ^ kb[kcnt];\n        end else if (dcnt == 92) begin\n            dcnt <= 93;\n            text_out_r <= sa[3][0] ^ kb[kcnt];\n        end else if (dcnt == 93) begin\n            dcnt <= 94;\n            text_out_r <= sa[3][1] ^ kb[kcnt];\n        end else if (dcnt == 94) begin\n            dcnt <= 95;\n            text_out_r <= sa[3][2] ^ kb[kcnt];\n        end else if (dcnt == 95) begin\n            dcnt <= 96;\n            text_out_r <= sa[3][3] ^ kb[kcnt];\n        end else if (dcnt == 96) begin\n            dcnt <= 97;\n            text_out_r <= sa[0][0];\n        end else if (dcnt == 97) begin\n            dcnt <= 98;\n            text_out_r <= sa[0][1];\n        end else if (dcnt == 98) begin\n            dcnt <= 99;\n            text_out_r <= sa[0][2];\n        end else if (dcnt == 99) begin\n            dcnt <= 100;\n            text_out_r <= sa[0][3];\n        end else if (dcnt == 100) begin\n            dcnt <= 101;\n            text_out_r <= sa[1][0];\n        end else if (dcnt == 101) begin\n            dcnt <= 102;\n            text_out_r <= sa[1][1];\n        end else if (dcnt == 102) begin\n            dcnt <= 103;\n            text_out_r <= sa[1][2];\n        end else if (dcnt == 103) begin\n            dcnt <= 104;\n            text_out_r <= sa[1][3];\n        end else if (dcnt == 104) begin\n            dcnt <= 105;\n            text_out_r <= sa[2][0];\n        end else if (dcnt == 105) begin\n            dcnt <= 106;\n            text_out_r <= sa[2][1];\n        end else if (dcnt == 106) begin\n            dcnt <= 107;\n            text_out_r <= sa[2][2];\n        end else if (dcnt == 107) begin\n            dcnt <= 108;\n            text_out_r <= sa[2][3];\n        end else if (dcnt == 108) begin\n            dcnt <= 109;\n            text_out_r <= sa[3][0];\n        end else if (dcnt == 109) begin\n            dcnt <= 110;\n            text_out_r <= sa[3][1];\n        end else if (dcnt == 110) begin\n            dcnt <= 111;\n            text_out_r <= sa[3][2];\n        end else if (dcnt == 111) begin\n            dcnt <= 112;\n            text_out_r <= sa[3][3];\n        end else if (dcnt == 112) begin\n            dcnt <= 113;\n            text_out_r <= sa[0][0] ^ kb[kcnt];\n        end else if (dcnt == 113) begin\n            dcnt <= 114;\n            text_out_r <= sa[0][1] ^ kb[kcnt];\n        end else if (dcnt == 114) begin\n            dcnt <= 115;\n            text_out_r <= sa[0][2] ^ kb[kcnt];\n        end else if (dcnt == 115) begin\n            dcnt <= 116;\n            text_out_r <= sa[0][3] ^ kb[kcnt];\n        end else if (dcnt == 116) begin\n            dcnt <= 117;\n            text_out_r <= sa[1][0] ^ kb[kcnt];\n        end else if (dcnt == 117) begin\n            dcnt <= 118;\n            text_out_r <= sa[1][1] ^ kb[kcnt];\n        end else if (dcnt == 118) begin\n            dcnt <= 119;\n            text_out_r <= sa[1][2] ^ kb[kcnt];\n        end else if (dcnt == 119) begin\n            dcnt <= 120;\n            text_out_r <= sa[1][3] ^ kb[kcnt];\n        end else if (dcnt == 120) begin\n            dcnt <= 121;\n            text_out_r <= sa[2][0] ^ kb[kcnt];\n        end else if (dcnt == 121) begin\n            dcnt <= 122;\n            text_out_r <= sa[2][1] ^ kb[kcnt];\n        end else if (dcnt == 122) begin\n            dcnt <= 123;\n            text_out_r <= sa[2][2] ^ kb[kcnt];\n        end else if (dcnt == 123) begin\n            dcnt <= 124;\n            text_out_r <= sa[2][3] ^ kb[kcnt];\n        end else if (dcnt == 124) begin\n            dcnt <= 125;\n            text_out_r <= sa[3][0] ^ kb[kcnt];\n        end else if (dcnt == 125) begin\n            dcnt <= 126;\n            text_out_r <= sa[3][1] ^ kb[kcnt];\n        end else if (dcnt == 126) begin\n            dcnt <= 127;\n            text_out_r <= sa[3][2] ^ kb[kcnt];\n        end else if (dcnt == 127) begin\n            dcnt <= 128;\n            text_out_r <= sa[3][3] ^ kb[kcnt];\n        end else if (dcnt == 128) begin\n            done <= 1;\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        kb <= 0;\n    end else if (kld) begin\n        if (kcnt == 0) begin\n            kcnt <= 0xA;\n            kb <= 0;\n        end else begin\n            kcnt <= kcnt - 1;\n            kb[kcnt] <= key[(kcnt*32 + 31):kcnt*32];\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        sa <= 0;\n    end else if (ld) begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= text_in_r[(i*32 + j*8 + 7):i*32 + j*8];\n            end\n        end\n    end else if (dcnt == 0) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 1) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 2) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 3) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 4) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 5) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 6) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 7) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 8) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 9) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 10) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 11) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 12) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 13) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        sa[1][0] <= sa[1][0];\n        sa[1][1] <= sa[1][1];\n        sa[1][2] <= sa[1][2];\n        sa[1][3] <= sa[1][3];\n        sa[2][0] <= sa[2][0];\n        sa[2][1] <= sa[2][1];\n        sa[2][2] <= sa[2][2];\n        sa[2][3] <= sa[2][3];\n        sa[3][0] <= sa[3][0];\n        sa[3][1] <= sa[3][1];\n        sa[3][2] <= sa[3][2];\n        sa[3][3] <= sa[3][3];\n    end else if (dcnt == 14) begin\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2]", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 10, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [3:0] dcnt;\n    reg [3:0] kcnt;\n    reg [127:0] kb[10:0];\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    wire [3:0] sa[0:3][0:3];\n    wire [3:0] sa_next[0:3][0:3];\n    wire [3:0] sa_ark[0:3][0:3];\n    wire [3:0] w3, w2, w1, w0;\n\n    assign done = (dcnt == 11 && !ld_r);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n            dcnt <= 1;\n            kcnt <= 0xA;\n        end else if (kld) begin\n            ld_r <= 0;\n            kcnt <= kcnt + 1;\n            if (kcnt == 0) begin\n                kcnt <= 0xA;\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= kb[4*i + j];\n                    end\n                end\n            end\n        end else begin\n            ld_r <= ld_r;\n            if (dcnt < 11) begin\n                dcnt <= dcnt + 1;\n            end\n            if (dcnt == 11) begin\n                ld_r <= 0;\n            end\n        end\n    end\n\n    aes_key_expand_128 aes_key_exp(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(w0),\n        .wo_1(w1),\n        .wo_2(w2),\n        .wo_3(w3)\n    );\n\n    aes_inv_sbox us00(\n        .a(sa[0][0]),\n        .b(sa_next[0][0])\n    );\n    aes_inv_sbox us01(\n        .a(sa[0][1]),\n        .b(sa_next[0][1])\n    );\n    aes_inv_sbox us02(\n        .a(sa[0][2]),\n        .b(sa_next[0][2])\n    );\n    aes_inv_sbox us03(\n        .a(sa[0][3]),\n        .b(sa_next[0][3])\n    );\n    aes_inv_sbox us10(\n        .a(sa[1][0]),\n        .b(sa_next[1][0])\n    );\n    aes_inv_sbox us11(\n        .a(sa[1][1]),\n        .b(sa_next[1][1])\n    );\n    aes_inv_sbox us12(\n        .a(sa[1][2]),\n        .b(sa_next[1][2])\n    );\n    aes_inv_sbox us13(\n        .a(sa[1][3]),\n        .b(sa_next[1][3])\n    );\n    aes_inv_sbox us20(\n        .a(sa[2][0]),\n        .b(sa_next[2][0])\n    );\n    aes_inv_sbox us21(\n        .a(sa[2][1]),\n        .b(sa_next[2][1])\n    );\n    aes_inv_sbox us22(\n        .a(sa[2][2]),\n        .b(sa_next[2][2])\n    );\n    aes_inv_sbox us23(\n        .a(sa[2][3]),\n        .b(sa_next[2][3])\n    );\n    aes_inv_sbox us30(\n        .a(sa[3][0]),\n        .b(sa_next[3][0])\n    );\n    aes_inv_sbox us31(\n        .a(sa[3][1]),\n        .b(sa_next[3][1])\n    );\n    aes_inv_sbox us32(\n        .a(sa[3][2]),\n        .b(sa_next[3][2])\n    );\n    aes_inv_sbox us33(\n        .a(sa[3][3]),\n        .b(sa_next[3][3])\n    );\n\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_next[i][j] <= 0;\n                end\n            end\n        end else if (ld_r) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_next[i][j] <= sa[i][j];\n                end\n            end\n        end else begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_next[i][j] <= sa_ark[i][j];\n                end\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_ark[i][j] <= 0;\n                end\n            end\n        end else if (ld_r) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_ark[i][j] <= sa[i][j];\n                end\n            end\n        end else begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_ark[i][j] <= sa_next[i][j];\n                end\n            end\n        end\n    end\n\n    assign sa_ark[0][0] = sa_next[0][0] ^ w0[0];\n    assign sa_ark[0][1] = sa_next[0][1] ^ w0[1];\n    assign sa_ark[0][2] = sa_next[0][2] ^ w0[2];\n    assign sa_ark[0][3] = sa_next[0][3] ^ w0[3];\n    assign sa_ark[1][0] = sa_next[1][0] ^ w1[0];\n    assign sa_ark[1][1] = sa_next[1][1] ^ w1[1];\n    assign sa_ark[1][2] = sa_next[1][2] ^ w1[2];\n    assign sa_ark[1][3] = sa_next[1][3] ^ w1[3];\n    assign sa_ark[2][0] = sa_next[2][0] ^ w2[0];\n    assign sa_ark[2][1] = sa_next[2][1] ^ w2[1];\n    assign sa_ark[2][2] = sa_next[2][2] ^ w2[2];\n    assign sa_ark[2][3] = sa_next[2][3] ^ w2[3];\n    assign sa_ark[3][0] = sa_next[3][0] ^ w3[0];\n    assign sa_ark[3][1] = sa_next[3][1] ^ w3[1];\n    assign sa_ark[3][2] = sa_next[3][2] ^ w3[2];\n    assign sa_ark[3][3] = sa_next[3][3] ^ w3[3];\n\n    aes_inv_mix_columns aes_inv_mix(\n        .clk(clk),\n        .rst(rst),\n        .sa(sa_ark),\n        .sa_next(sa_next)\n    );\n\n    aes_add_round_key aes_add(\n        .clk(clk),\n        .rst(rst),\n        .sa(sa_next),\n        .w(w3, w2, w1, w0),\n        .sa_out(sa_next)\n    );\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_out_r <= 0;\n        end else if (ld_r) begin\n            text_out_r <= text_in_r;\n        end else begin\n            text_out_r <= sa_next[3][3] << 112 | sa_next[3][2] << 96 | sa_next[3][1] << 80 | sa_next[3][0] << 64 | sa_next[2][3] << 48 | sa_next[2][2] << 32 | sa_next[2][1] << 16 | sa_next[2][0];\n        end\n    end\n\n    assign text_out = text_out_r;\n\nendmodule\n\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_r;\n    reg [3:0] kcnt;\n    reg [31:0] wk0, wk1, wk2, wk3;\n\n    assign wo_0 = wk0;\n    assign wo_1 = wk1;\n    assign wo_2 = wk2;\n    assign wo_3 = wk3;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            kcnt <= 0;\n            wk0 <= 0;\n            wk1 <= 0;\n            wk2 <= 0;\n            wk3 <= 0;\n        end else if (kld) begin\n            kcnt <= 0;\n            wk0 <= key[31:0];\n            wk1 <= key[63:32];\n            wk2 <= key[95:64];\n            wk3 <= key[127:96];\n        end else begin\n            if (kcnt == 0) begin\n                wk0 <= wk0 ^ (wk1 << 8 | wk2 >> 24);\n                wk1 <= wk1 ^ (wk2 << 8 | wk3 >> 24);\n                wk2 <= wk2 ^ (wk3 << 8);\n                wk3 <= wk3 >> 8;\n            end else if (kcnt == 1) begin\n                wk0 <= wk0 ^ (wk1 << 8 | wk2 >> 24);\n                wk1 <= wk1 ^ (wk2 << 8 | wk3 >> 24);\n                wk2 <= wk2 ^ (wk3 << 8);\n                wk3 <= wk3 >> 8;\n            end else if (kcnt == 2) begin\n                wk0 <= wk0 ^ (wk1 << 8 | wk2 >> 24);\n                wk1 <= wk1 ^ (wk2 << 8 | wk3 >> 24);\n                wk2 <= wk2 ^ (wk3 << 8);\n                wk3 <= wk3 >> 8;\n            end else if (kcnt == 3) begin\n                wk0 <= wk0 ^ (wk1 << 8 | wk2 >> 24);\n                wk1 <= wk1 ^ (wk2 << 8 | wk3 >> 24);\n                wk2 <= wk2 ^ (wk3 << 8);\n                wk3 <= wk3 >> 8;\n            end else if (kcnt == 4) begin\n                wk0 <= wk0 ^ (wk1 << 8 | wk2 >> 24);\n                wk1 <= wk1 ^ (wk2 << 8 | wk3 >> 24);\n                wk2 <= wk2 ^ (wk3 << 8);\n                wk3 <= wk3 >> 8;\n            end else if (kcnt == 5) begin\n                wk0 <= wk0 ^ (wk1 << 8 | wk2 >> 24);\n                wk1 <= wk1 ^ (wk2 << 8 | wk3 >> 24);\n                wk2 <= wk2 ^ (wk3 << 8);\n                wk3 <= wk3 >> 8;\n            end else if (kcnt == 6) begin\n                wk0 <= wk0 ^ (wk1 << 8 | wk2 >> 24);\n                wk1 <= wk1 ^ (wk2 << 8 | wk3 >> 24);\n                wk2 <= wk2 ^ (wk3 << 8);\n                wk3 <= wk3 >> 8;\n            end else if (kcnt == 7) begin\n                wk0 <= wk0 ^ (wk1 << 8 | wk2 >> 24);\n                wk1 <= wk1 ^ (wk2 << 8 | wk3 >> 24);\n                wk2 <= wk2 ^ (wk3 << 8);\n                wk3 <= wk3 >> 8;\n            end else if (kcnt == 8) begin\n                wk0 <= wk0 ^ (wk1 << 8 | wk2 >> 24);\n                wk1 <= wk1 ^ (wk2 << 8 | wk3 >> 24);\n                wk2 <= wk2 ^ (wk3 << 8);\n                wk3 <= wk3 >> 8;\n            end else if (kcnt == 9) begin\n                wk0 <= wk0 ^ (wk1 << 8 | wk2 >> 24);\n                wk1 <= wk1 ^ (wk2 << 8 | wk3 >> 24);\n                wk2 <= wk2 ^ (wk3 << 8);\n                wk3 <= wk3 >> 8;\n            end else if (kcnt == 10) begin\n                wk0 <= wk0 ^ (wk1 << 8 | wk2 >> 24);\n                wk1 <= wk1 ^ (wk2 << 8 | wk3 >> 24);\n                wk2 <= wk2 ^ (wk3 << 8);\n                wk3 <= wk3 >> 8;\n            end else begin\n                wk0 <= wk0;\n                wk1 <= wk1;\n                wk2 <= wk2;\n                wk3 <= wk3;\n            end\n            kcnt <= kcnt + 1;\n        end\n    end\n\nendmodule\n\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] inv_sbox[255:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = i;\n        end\n        for (int i = 0; i < 256; i++) begin\n            for (int j = 0; j < 8; j++) begin\n                if (inv_sbox[i] & (1 << j)) begin\n                    inv_sbox[i] = inv_sbox[i] ^ (1 << (j + 1));\n                end\n            end\n            for (int j = 0; j < 8; j++) begin\n                if (inv_sbox[i] & (1 << j)) begin\n                    inv_sbox[i] = inv_sbox[i] ^ (1 << (j + 1));\n                end\n            end\n        end\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule\n\nmodule aes_inv_mix_columns(\n    input clk,\n    input rst,\n    input [3:0][3:0] sa,\n    output [3:0][3:0] sa_next\n);\n\n    reg [3:0][3:0] sa_next_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_next_r[i][j] <= 0;\n                end\n            end\n        end else begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_next_r[i][j] <= sa[i][j];\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_next_r[i][j] <= sa_next_r[i][j] ^ (sa[i][j] << 1) ^ (sa[i][j] << 2) ^ (sa[i][j] << 3) ^ (sa[i][j] << 4);\n                end\n            end\n        end\n    end\n\n    assign sa_next = sa_next_r;\n\nendmodule\n\nmodule aes_add_round_key(\n    input clk,\n    input rst,\n    input [3:0][3:0] sa,\n    input [3:0][3:0] w,\n    output [3:0][3:0] sa_out\n);\n\n    reg [3:0][3:0] sa_out_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_out_r[i][j] <= 0;\n                end\n            end\n        end else begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_out_r[i][j] <= sa[i][j];\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_out_r[i][j] <= sa_out_r[i][j] ^ w[i][j];\n                end\n            end\n        end\n    end\n\n    assign sa_out = sa_out_r;\n\nendmodule\n\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            rcnt <= 0;\n            out <= 0;\n        end else if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01;\n        end else begin\n            if (rcnt == 0) begin\n                out <= 32'h01;\n            end else if (rcnt == 1) begin\n                out <= 32'h02;\n            end else if (rcnt == 2) begin\n                out <= 32'h04;\n            end else if (rcnt == 3) begin\n                out <= 32'h08;\n            end else if (rcnt == 4) begin\n                out <= 32'h10;\n            end else if (rcnt == 5) begin\n                out <= 32'h20;\n            end else if (rcnt == 6) begin\n                out <= 32'h40;\n            end else if (rcnt == 7) begin\n                out <= 32'h80;\n            end else if (rcnt == 8) begin\n                out <= 32'h1b;\n            end else if (rcnt == 9) begin\n                out <= 32'h36;\n            end else begin\n                out <= 0;\n            end\n            rcnt <= rcnt + 1;\n        end\n    end\n\nendmodule\n\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[255:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n        end\n        for (int i = 0; i < 256; i++) begin\n            for (int j = 0; j < 8; j++) begin\n                if (sbox[i] & (1 << j)) begin\n                    sbox[i] = sbox[i] ^ (1 << (j + 1));\n                end\n            end\n            for (int j = 0; j < 8; j++) begin\n                if (sbox[i] & (1 << j)) begin\n                    sbox[i] = sbox[i] ^ (1 << (j + 1));\n                end\n            end\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 11, "code": "```verilog\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\nreg [3:0] dcnt;\nreg [3:0] kcnt;\nreg [10:0] kb[10:0];\nreg ld_r;\nreg [127:0] text_in_r;\nreg [127:0] sa[0:3][0:3];\nreg [127:0] sa_ark;\n\n// InvShiftRows\nreg [7:0] sa00, sa01, sa02, sa03, sa10, sa11, sa12, sa13, sa20, sa21, sa22, sa23, sa30, sa31, sa32, sa33;\nreg [7:0] sa00_t, sa01_t, sa02_t, sa03_t, sa10_t, sa11_t, sa12_t, sa13_t, sa20_t, sa21_t, sa22_t, sa23_t, sa30_t, sa31_t, sa32_t, sa33_t;\n\n// InvSubBytes\nreg [7:0] us00, us01, us02, us03, us10, us11, us12, us13, us20, us21, us22, us23, us30, us31, us32, us33;\n\n// InvMixColumns\nreg [7:0] pmul_e, pmul_b, pmul_d, pmul_9;\nreg [7:0] sa00_m, sa01_m, sa02_m, sa03_m, sa10_m, sa11_m, sa12_m, sa13_m, sa20_m, sa21_m, sa22_m, sa23_m, sa30_m, sa31_m, sa32_m, sa33_m;\n\n// AddRoundKey\nreg [7:0] w3, w2, w1, w0;\n\n// InvMixColumns\nreg [7:0] sa00_n, sa01_n, sa02_n, sa03_n, sa10_n, sa11_n, sa12_n, sa13_n, sa20_n, sa21_n, sa22_n, sa23_n, sa30_n, sa31_n, sa32_n, sa33_n;\n\n// Round Counter\nreg [3:0] dcnt_r;\nreg [3:0] kcnt_r;\n\n// Key Buffer\nreg [31:0] wk0, wk1, wk2, wk3;\n\n// Key Expansion\nreg [31:0] wo_0, wo_1, wo_2, wo_3;\n\n// S-box\nreg [7:0] a, b;\n\n// R-con\nreg [31:0] out;\n\n// State Transition Diagram\nalways @(posedge clk) begin\n    if (rst) begin\n        dcnt <= 0;\n        kcnt <= 0;\n        kb <= 0;\n        ld_r <= 0;\n        text_in_r <= 0;\n        sa <= 0;\n        sa_ark <= 0;\n        sa00 <= 0;\n        sa01 <= 0;\n        sa02 <= 0;\n        sa03 <= 0;\n        sa10 <= 0;\n        sa11 <= 0;\n        sa12 <= 0;\n        sa13 <= 0;\n        sa20 <= 0;\n        sa21 <= 0;\n        sa22 <= 0;\n        sa23 <= 0;\n        sa30 <= 0;\n        sa31 <= 0;\n        sa32 <= 0;\n        sa33 <= 0;\n        sa00_t <= 0;\n        sa01_t <= 0;\n        sa02_t <= 0;\n        sa03_t <= 0;\n        sa10_t <= 0;\n        sa11_t <= 0;\n        sa12_t <= 0;\n        sa13_t <= 0;\n        sa20_t <= 0;\n        sa21_t <= 0;\n        sa22_t <= 0;\n        sa23_t <= 0;\n        sa30_t <= 0;\n        sa31_t <= 0;\n        sa32_t <= 0;\n        sa33_t <= 0;\n        us00 <= 0;\n        us01 <= 0;\n        us02 <= 0;\n        us03 <= 0;\n        us10 <= 0;\n        us11 <= 0;\n        us12 <= 0;\n        us13 <= 0;\n        us20 <= 0;\n        us21 <= 0;\n        us22 <= 0;\n        us23 <= 0;\n        us30 <= 0;\n        us31 <= 0;\n        us32 <= 0;\n        us33 <= 0;\n        pmul_e <= 0;\n        pmul_b <= 0;\n        pmul_d <= 0;\n        pmul_9 <= 0;\n        sa00_m <= 0;\n        sa01_m <= 0;\n        sa02_m <= 0;\n        sa03_m <= 0;\n        sa10_m <= 0;\n        sa11_m <= 0;\n        sa12_m <= 0;\n        sa13_m <= 0;\n        sa20_m <= 0;\n        sa21_m <= 0;\n        sa22_m <= 0;\n        sa23_m <= 0;\n        sa30_m <= 0;\n        sa31_m <= 0;\n        sa32_m <= 0;\n        sa33_m <= 0;\n        w3 <= 0;\n        w2 <= 0;\n        w1 <= 0;\n        w0 <= 0;\n        sa00_n <= 0;\n        sa01_n <= 0;\n        sa02_n <= 0;\n        sa03_n <= 0;\n        sa10_n <= 0;\n        sa11_n <= 0;\n        sa12_n <= 0;\n        sa13_n <= 0;\n        sa20_n <= 0;\n        sa21_n <= 0;\n        sa22_n <= 0;\n        sa23_n <= 0;\n        sa30_n <= 0;\n        sa31_n <= 0;\n        sa32_n <= 0;\n        sa33_n <= 0;\n        wk0 <= 0;\n        wk1 <= 0;\n        wk2 <= 0;\n        wk3 <= 0;\n        wo_0 <= 0;\n        wo_1 <= 0;\n        wo_2 <= 0;\n        wo_3 <= 0;\n        a <= 0;\n        b <= 0;\n        out <= 0;\n    end else begin\n        if (kld) begin\n            kb <= 0;\n            kcnt <= 10;\n            wk0 <= 0;\n            wk1 <= 0;\n            wk2 <= 0;\n            wk3 <= 0;\n            wo_0 <= 0;\n            wo_1 <= 0;\n            wo_2 <= 0;\n            wo_3 <= 0;\n        end else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1;\n        end else if (dcnt == 0) begin\n            InvShiftRows();\n            InvSubBytes();\n            AddRoundKey();\n            InvMixColumns();\n            dcnt <= dcnt + 1;\n        end else if (dcnt == 10) begin\n            AddRoundKey();\n            dcnt <= dcnt + 1;\n        end else begin\n            InvShiftRows();\n            InvSubBytes();\n            AddRoundKey();\n            InvMixColumns();\n            dcnt <= dcnt + 1;\n        end\n    end\n\n    if (dcnt == 11) begin\n        done <= 1;\n    end else begin\n        done <= 0;\n    end\n\n    if (ld_r) begin\n        InvShiftRows();\n        InvSubBytes();\n        AddRoundKey();\n        InvMixColumns();\n        ld_r <= 0;\n    end\n\n    if (kcnt == 0) begin\n        KeyExpansion();\n        kcnt <= 10;\n    end else if (kcnt > 0) begin\n        kcnt <= kcnt - 1;\n    end\n\n    if (kcnt == 0) begin\n        kb <= wk0 | wk1 | wk2 | wk3;\n    end\n\n    if (dcnt == 0) begin\n        w3 <= wk0[31:24];\n        w2 <= wk0[23:16];\n        w1 <= wk0[15:8];\n        w0 <= wk0[7:0];\n    end else if (dcnt == 1) begin\n        w3 <= wk1[31:24];\n        w2 <= wk1[23:16];\n        w1 <= wk1[15:8];\n        w0 <= wk1[7:0];\n    end else if (dcnt == 2) begin\n        w3 <= wk2[31:24];\n        w2 <= wk2[23:16];\n        w1 <= wk2[15:8];\n        w0 <= wk2[7:0];\n    end else if (dcnt == 3) begin\n        w3 <= wk3[31:24];\n        w2 <= wk3[23:16];\n        w1 <= wk3[15:8];\n        w0 <= wk3[7:0];\n    end else begin\n        w3 <= kb[kcnt][31:24];\n        w2 <= kb[kcnt][23:16];\n        w1 <= kb[kcnt][15:8];\n        w0 <= kb[kcnt][7:0];\n    end\n\n    if (dcnt == 0) begin\n        sa00 <= text_in_r[7:0];\n        sa01 <= text_in_r[15:8];\n        sa02 <= text_in_r[23:16];\n        sa03 <= text_in_r[31:24];\n        sa10 <= text_in_r[39:32];\n        sa11 <= text_in_r[47:40];\n        sa12 <= text_in_r[55:48];\n        sa13 <= text_in_r[63:56];\n        sa20 <= text_in_r[71:64];\n        sa21 <= text_in_r[79:72];\n        sa22 <= text_in_r[87:80];\n        sa23 <= text_in_r[95:88];\n        sa30 <= text_in_r[103:96];\n        sa31 <= text_in_r[111:104];\n        sa32 <= text_in_r[119:112];\n        sa33 <= text_in_r[127:120];\n    end else begin\n        InvShiftRows();\n        InvSubBytes();\n        AddRoundKey();\n        InvMixColumns();\n    end\n\n    if (dcnt == 0) begin\n        sa00_t <= sa00;\n        sa01_t <= sa01;\n        sa02_t <= sa02;\n        sa03_t <= sa03;\n        sa10_t <= sa10;\n        sa11_t <= sa11;\n        sa12_t <= sa12;\n        sa13_t <= sa13;\n        sa20_t <= sa20;\n        sa21_t <= sa21;\n        sa22_t <= sa22;\n        sa23_t <= sa23;\n        sa30_t <= sa30;\n        sa31_t <= sa31;\n        sa32_t <= sa32;\n        sa33_t <= sa33;\n    end else begin\n        InvShiftRows();\n    end\n\n    if (dcnt == 0) begin\n        us00 <= sa00_t;\n        us01 <= sa01_t;\n        us02 <= sa02_t;\n        us03 <= sa03_t;\n        us10 <= sa10_t;\n        us11 <= sa11_t;\n        us12 <= sa12_t;\n        us13 <= sa13_t;\n        us20 <= sa20_t;\n        us21 <= sa21_t;\n        us22 <= sa22_t;\n        us23 <= sa23_t;\n        us30 <= sa30_t;\n        us31 <= sa31_t;\n        us32 <= sa32_t;\n        us33 <= sa33_t;\n    end else begin\n        InvSubBytes();\n    end\n\n    if (dcnt == 0) begin\n        pmul_e <= us00;\n        pmul_b <= us01;\n        pmul_d <= us02;\n        pmul_9 <= us03;\n        sa00_m <= us10;\n        sa01_m <= us11;\n        sa02_m <= us12;\n        sa03_m <= us13;\n        sa10_m <= us20;\n        sa11_m <= us21;\n        sa12_m <= us22;\n        sa13_m <= us23;\n        sa20_m <= us30;\n        sa21_m <= us31;\n        sa22_m <= us32;\n        sa23_m <= sa33;\n        sa30_m <= us10;\n        sa31_m <= us11;\n        sa32_m <= us12;\n        sa33_m <= us13;\n    end else begin\n        InvMixColumns();\n    end\n\n    if (dcnt == 0) begin\n        sa00_n <= sa00_m;\n        sa01_n <= sa01_m;\n        sa02_n <= sa02_m;\n        sa03_n <= sa03_m;\n        sa10_n <= sa10_m;\n        sa11_n <= sa11_m;\n        sa12_n <= sa12_m;\n        sa13_n <= sa13_m;\n        sa20_n <= sa20_m;\n        sa21_n <= sa21_m;\n        sa22_n <= sa22_m;\n        sa23_n <= sa23_m;\n        sa30_n <= sa30_m;\n        sa31_n <= sa31_m;\n        sa32_n <= sa32_m;\n        sa33_n <= sa33_m;\n    end else begin\n        InvMixColumns();\n    end\n\n    if (dcnt == 0) begin\n        w3 <= sa00_n[31:24];\n        w2 <= sa00_n[23:16];\n        w1 <= sa00_n[15:8];\n        w0 <= sa00_n[7:0];\n    end else if (dcnt == 1) begin\n        w3 <= sa01_n[31:24];\n        w2 <= sa01_n[23:16];\n        w1 <= sa01_n[15:8];\n        w0 <= sa01_n[7:0];\n    end else if (dcnt == 2) begin\n        w3 <= sa02_n[31:24];\n        w2 <= sa02_n[23:16];\n        w1 <= sa02_n[15:8];\n        w0 <= sa02_n[7:0];\n    end else if (dcnt == 3) begin\n        w3 <= sa03_n[31:24];\n        w2 <= sa03_n[23:16];\n        w1 <= sa03_n[15:8];\n        w0 <= sa03_n[7:0];\n    end else begin\n        w3 <= sa00_n[31:24];\n        w2 <= sa00_n[23:16];\n        w1 <= sa00_n[15:8];\n        w0 <= sa00_n[7:0];\n    end\n\n    if (dcnt == 0) begin\n        sa00 <= w3;\n        sa01 <= w2;\n        sa02 <= w1;\n        sa03 <= w0;\n        sa10 <= sa10_n;\n        sa11 <= sa11_n;\n        sa12 <= sa12_n;\n        sa13 <= sa13_n;\n        sa20 <= sa20_n;\n        sa21 <= sa21_n;\n        sa22 <= sa22_n;\n        sa23 <= sa23_n;\n        sa30 <= sa30_n;\n        sa31 <= sa31_n;\n        sa32 <= sa32_n;\n        sa33 <= sa33_n;\n    end else begin\n        AddRoundKey();\n    end\n\n    if (dcnt == 0) begin\n        sa00_ark <= sa00;\n        sa01_ark <= sa01;\n        sa02_ark <= sa02;\n        sa03_ark <= sa03;\n        sa10_ark <= sa10;\n        sa11_ark <= sa11;\n        sa12_ark <= sa12;\n        sa13_ark <= sa13;\n        sa20_ark <= sa20;\n        sa21_ark <= sa21;\n        sa22_ark <= sa22;\n        sa23_ark <= sa23;\n        sa30_ark <= sa30;\n        sa31_ark <= sa31;\n        sa32_ark <= sa32;\n        sa33_ark <= sa33;\n    end else begin\n        AddRoundKey();\n    end\n\n    if (dcnt == 0) begin\n        text_out <= sa00_ark;\n    end else begin\n        text_out <= sa00_ark | sa01_ark | sa02_ark | sa03_ark | sa10_ark | sa11_ark | sa12_ark | sa13_ark | sa20_ark | sa21_ark | sa22_ark | sa23_ark | sa30_ark | sa31_ark | sa32_ark | sa33_ark;\n    end\nend\n\n// InvShiftRows\nalways_comb begin\n    case(dcnt)\n        0: begin\n            sa00_t = sa00;\n            sa01_t = sa01;\n            sa02_t = sa02;\n            sa03_t = sa03;\n            sa10_t = sa10;\n            sa11_t = sa11;\n            sa12_t = sa12;\n            sa13_t = sa13;\n            sa20_t = sa20;\n            sa21_t = sa21;\n            sa22_t = sa22;\n            sa23_t = sa23;\n            sa30_t = sa30;\n            sa31_t = sa31;\n            sa32_t = sa32;\n            sa33_t = sa33;\n        end\n        1: begin\n            sa00_t = sa13;\n            sa01_t = sa10;\n            sa02_t = sa11;\n            sa03_t = sa12;\n            sa10_t = sa20;\n            sa11_t = sa21;\n            sa12_t = sa22;\n            sa13_t = sa23;\n            sa20_t = sa30;\n            sa21_t = sa31;\n            sa22_t = sa32;\n            sa23_t = sa33;\n            sa30_t = sa00;\n            sa31_t = sa01;\n            sa32_t = sa02;\n            sa33_t = sa03;\n        end\n        2: begin\n            sa00_t = sa22;\n            sa01_t = sa23;\n            sa02_t = sa20;\n            sa03_t = sa21;\n            sa10_t = sa32;\n            sa11_t = sa33;\n            sa12_t = sa30;\n            sa13_t = sa31;\n            sa20_t = sa02;\n            sa21_t = sa03;\n            sa22_t = sa00;\n            sa23_t = sa01;\n            sa30_t = sa12;\n            sa31_t = sa13;\n            sa32_t = sa10;\n            sa33_t = sa11;\n        end\n        3: begin\n            sa00_t = sa31;\n            sa01_t = sa32;\n            sa02_t = sa30;\n            sa03_t = sa33;\n            sa10_t = sa01;\n            sa11_t = sa02;\n            sa12_t = sa03;\n            sa13_t = sa00;\n            sa20_t = sa11;\n            sa21_t = sa12;\n            sa22_t = sa13;\n            sa23_t = sa10;\n            sa30_t = sa21;\n            sa31_t = sa22;\n            sa32_t = sa23;\n            sa33_t = sa20;\n        end\n        default: begin\n            sa00_t = sa00;\n            sa01_t = sa01;\n            sa02_t = sa02;\n            sa03_t = sa03;\n            sa10_t = sa10;\n            sa11_t = sa11;\n            sa12_t = sa12;\n            sa13_t = sa13;\n            sa20_t = sa20;\n            sa21_t = sa21;\n            sa22_t = sa22;\n            sa23_t = sa23;\n            sa30_t = sa30;\n            sa31_t = sa31;\n            sa32_t = sa32;\n            sa33_t = sa33;\n        end\n    endcase\nend\n\n// InvSubBytes\nalways_comb begin\n    case(dcnt)\n        0: begin\n            us00 = sa00_t;\n            us01 = sa01_t;\n            us02 = sa02_t;\n            us03 = sa03_t;\n            us10 = sa10_t;\n            us11 = sa11_t;\n            us12 = sa12_t;\n            us13 = sa13_t;\n            us20 = sa20_t;\n            us21 = sa21_t;\n            us22 = sa22_t;\n            us23 = sa23_t;\n            us30 = sa30_t;\n            us31 = sa31_t;\n            us32 = sa32_t;\n            us33 = sa33_t;\n        end\n        1: begin\n            us00 = sa13_t;\n            us01 = sa10_t;\n            us02 = sa11_t;\n            us03 = sa12_t;\n            us10 = sa20_t;\n            us11 = sa21_t;\n            us12 = sa22_t;\n            us13 = sa23_t;\n            us20 = sa30_t;\n            us21 = sa31_t;\n            us22 = sa32_t;\n            us23 = sa33_t;\n            us30 = sa00_t;\n            us31 = sa01_t;\n            us32 = sa02_t;\n            us33 = sa03_t;\n        end\n        2: begin\n            us00 = sa22_t;\n            us01 = sa23_t;\n            us02 = sa20_t;\n            us03 = sa21_t;\n            us10 = sa32_t;\n            us11 = sa33_t;\n            us12 = sa30_t;\n            us13 = sa31_t;\n            us20 = sa02_t;\n            us21 = sa03_t;\n            us22 = sa00_t;\n            us23 = sa01_t;\n            us30 = sa12_t;\n            us31 = sa13_t;\n            us32 = sa10_t;\n            us33 = sa11_t;\n        end\n        3: begin\n            us00 = sa31_t;\n            us01 = sa32_t;\n            us02 = sa30_t;\n            us03 = sa33_t;\n            us10 = sa01_t;\n            us11 = sa02_t;\n            us12 = sa03_t;\n            us13 = sa00_t;\n            us20 = sa11_t;\n            us21 = sa12_t;\n            us22 = sa13_t;\n            us23 = sa10_t;\n            us30 = sa21_t;\n            us31 = sa22_t;\n            us32 = sa23_t;\n            us33 = sa20_t;\n        end\n        default: begin\n            us00 = sa00_t;\n            us01 = sa01_t;\n            us02 = sa02_t;\n            us03 = sa03_t;\n            us10 = sa10_t;\n            us11 = sa11_t;\n            us12 = sa12_t;\n            us13 = sa13_t;\n            us20 = sa20_t;\n            us21 = sa21_t;\n            us22 = sa22_t;\n            us23 = sa23_t;\n            us30 = sa30_t;\n            us31 = sa31_t;\n            us32 = sa32_t;\n            us33 = sa33_t;\n        end\n    endcase\nend\n\n// InvMixColumns\nalways_comb begin\n    case(dcnt)\n        0: begin\n            pmul_e = us00;\n            pmul_b = us01;\n            pmul_d = us02;\n            pmul_9 = us03;\n            sa00_m = us10;\n            sa01_m = us11;\n            sa02_m = us12;\n            sa03_m = us13;\n            sa10_m = us20;\n            sa11_m = us21;\n            sa12_m = us22;\n            sa13_m = us23;\n            sa20_m = us30;\n            sa21_m = us31;\n            sa22_m = us32;\n            sa23_m = us33;\n            sa30_m = us10;\n            sa31_m = us11;\n            sa32_m = us12;\n            sa33_m = us13;\n        end\n        1: begin\n            pmul_e = us13;\n            pmul_b = us10;\n            pmul_d = us11;\n            pmul_9 = us12;\n            sa00_m = us20;\n            sa01_m = us21;\n            sa02_m = us22;\n            sa03_m = us23;\n            sa10_m = us30;\n            sa11_m = us31;\n            sa12_m = us32;\n            sa13_m = us33;\n            sa20_m = us00;\n            sa21_m = us01;\n            sa22_m = us02;\n            sa23_m = us03;\n            sa30_m = us12;\n            sa31_m = us13;\n            sa32_m = us10;\n            sa33_m = us11;\n        end\n        2: begin\n            pmul_e = us22;\n            pmul_b = us23;\n            pmul_d = us20;\n            pmul_9 = us21;\n            sa00_m = us32;\n            sa01_m = us33;\n            sa02_m = us30;\n            sa03_m = us31;\n            sa10_m = us02;\n            sa11_m = us03;\n            sa12_m = us00;\n            sa13_m = us01;\n            sa20_m = us12;\n            sa21_m = us13;\n            sa22_m = us10;\n            sa23_m = us11;\n            sa30_m = us22;\n            sa31_m = us23;\n            sa32_m = us20;\n            sa33_m = us21;\n        end\n        3: begin\n            pmul_e = us31;\n            pmul_b = us32;\n            pmul_d = us30;\n            pmul_9 = us33;\n            sa00_m = us01;\n            sa01_m = us02;\n            sa02_m = us03;\n            sa03_m = us00;\n            sa10_m = us11;\n            sa11_m = us12;\n            sa12_m = us13;\n            sa13_m = us10;\n            sa20_m = us21;\n            sa21_m = us22;\n            sa22_m = us23;\n            sa23_m = us20;\n            sa30_m = us13;\n            sa31_m = us10;\n            sa32_m = us11;\n            sa33_m = us12;\n        end\n        default: begin\n            pmul_e = us00;\n            pmul_b = us01;\n            pmul_d = us02;\n            pmul_9 = us03;\n            sa00_m = us10;\n            sa01_m = us11;\n            sa02_m = us12;\n            sa03_m = us13;\n            sa10_m = us20;\n            sa11_m = us21;\n            sa12_m = us22;\n            sa13_m = us23;\n            sa20_m = us30;\n            sa21_m = us31;\n            sa22_m = us32;\n            sa23_m = us33;\n            sa30_m = us10;\n            sa31_m = us11;\n            sa32_m = us12;\n            sa33_m = us13;\n        end\n    endcase\nend\n\n// AddRoundKey\nalways_comb begin\n    case(dcnt)\n        0: begin\n            w3 = wk0[31:24];\n            w2 = wk0[23:16];\n            w1 = wk0[15:8];\n            w0 = wk0[7:0];\n        end\n        1: begin\n            w3 = wk1[31:24];\n            w2 = wk1[23:16];\n            w1 = wk1[15:8];\n            w0 = wk1[7:0];\n        end\n        2: begin\n            w3 = wk2[31:24];\n            w2 = wk2[23:16];\n            w1 = wk2[15:8];\n            w0 = wk2[7:0];\n        end\n        3: begin\n            w3 = wk3[31:24];\n            w2 = wk3[23:16];\n            w1 = wk3[15:8];\n            w0 = wk3[7:0];\n        end\n        default: begin\n            w3 = kb[kcnt][31:24];\n            w2 = kb[kcnt][23:16];\n            w1 = kb[kcnt][15:8];\n            w0 = kb[kcnt][7:0];\n        end\n    endcase\nend\n\n// InvMixColumns\nalways_comb begin\n    case(dcnt)\n        0: begin\n            sa00_n = sa00_m;\n            sa01_n = sa01_m;\n            sa02_n = sa02_m;\n            sa03_n = sa03_m;\n            sa10_n = sa10_m;\n            sa11_n = sa11_m;\n            sa12_n = sa12_m;\n            sa13_n = sa13_m;\n            sa20_n = sa20_m;\n            sa21_n = sa21_m;\n            sa22_n = sa22_m;\n            sa23_n = sa23_m;\n            sa30_n = sa30_m;\n            sa31_n = sa31_m;\n            sa32_n = sa32_m;\n            sa33_n = sa33_m;\n        end\n        1: begin\n            sa00_n = sa13_m;\n            sa01_n = sa10_m;\n            sa02_n = sa11_m;\n            sa03_n = sa12_m;\n            sa10_n = sa20_m;\n            sa11_n = sa21_m;\n            sa12_n = sa22_m;\n            sa13_n = sa23_m;\n            sa20_n = sa30_m;\n            sa21_n = sa31_m;\n            sa22_n = sa32_m;\n            sa23_n = sa33_m;\n            sa30_n = sa00_m;\n            sa31_n = sa01_m;\n            sa32_n = sa02_m;\n            sa33_n = sa03_m;\n        end\n        2: begin\n            sa00_n = sa22_m;\n            sa01_n = sa23_m;\n            sa02_n = sa20_m;\n            sa03_n = sa21_m;\n            sa10_n = sa32_m;\n            sa11_n = sa33_m;\n            sa12_n = sa30_m;\n            sa13_n = sa31_m;\n            sa20_n = sa02_m;\n            sa21_n = sa03_m;\n            sa22_n = sa00_m;\n            sa23_n = sa01_m;\n            sa30_n = sa12_m;\n            sa31_n = sa13_m;\n            sa32_n = sa10_m;\n            sa33_n = sa11_m;\n        end\n        3: begin\n            sa00_n = sa31_m;\n            sa01_n = sa32_m;\n            sa02_n = sa30_m;\n            sa03_n = sa33_m;\n            sa10_n = sa01_m;\n            sa11_n = sa02_m;\n            sa12_n = sa03_m;\n            sa13_n = sa00_m;\n            sa20_n = sa11_m;\n            sa21_n = sa12_m;\n            sa22_n = sa13_m;\n            sa23_n = sa10_m;\n            sa30_n = sa21_m;\n            sa31_n = sa22_m;\n            sa32_n = sa23_m;\n            sa33_n = sa20_m;\n        end\n        default: begin\n            sa00_n = sa00_m;\n            sa01_n = sa01_m;\n            sa02_n = sa02_m;\n            sa03_n = sa03_m;\n            sa10_n = sa10_m;\n            sa11_n = sa11_m;\n            sa12_n = sa12_m;\n            sa13_n = sa13_m;\n            sa20_n = sa20_m;\n            sa21_n = sa21_m;\n            sa22_n = sa22_m;\n            sa23_n = sa23_m;\n            sa30_n = sa30_m;\n            sa31_n = sa31_m;\n            sa32_n = sa32_m;\n            sa33_n = sa33_m;\n        end\n    endcase\nend\n\n// AddRoundKey\nalways_comb begin\n    case(dcnt)\n        0: begin\n            sa00_ark = sa00_n;\n            sa01_ark = sa01_n;\n            sa02_ark = sa02_n;\n            sa03_ark = sa03_n;\n            sa10_ark = sa10_n;\n            sa11_ark = sa11_n;\n            sa12_ark = sa12_n;\n            sa13_ark = sa13_n;\n            sa20_ark = sa20_n;\n            sa21_ark = sa21_n;\n            sa22_ark = sa22_n;\n            sa23_ark = sa23_n;\n            sa30_ark = sa30_n;\n            sa31_ark = sa31_n;\n            sa32_ark = sa32_n;\n            sa33_ark = sa33_n;\n        end\n        1: begin\n            sa00_ark = sa13_n;\n            sa01_ark = sa10_n;\n            sa02_ark = sa11_n;\n            sa03_ark = sa12_n;\n            sa10_ark = sa20_n;\n            sa11_ark = sa21_n;\n            sa12_ark = sa22_n;\n            sa13_ark = sa23_n;\n            sa20_ark = sa30_n;\n            sa21_ark = sa31_n;\n            sa22_ark = sa32_n;\n            sa23_ark = sa33_n;\n            sa30_ark = sa00_n;\n            sa31_ark = sa01_n;\n            sa32_ark = sa02_n;\n            sa33_ark = sa03_n;\n        end\n        2: begin\n            sa00_ark = sa22_n;\n            sa01_ark = sa23_n;\n            sa02_ark = sa20_n;\n            sa03_ark = sa21_n;\n            sa10_ark = sa32_n;\n            sa11_ark = sa33_n;\n            sa12_ark = sa30_n;\n            sa13_ark = sa31_n;\n            sa20_ark = sa02_n;\n            sa21_ark = sa03_n;\n            sa22_ark = sa00_n;\n            sa23_ark = sa01_n;\n            sa30_ark = sa12_n;\n            sa31_ark = sa13_n;\n            sa32_ark = sa10_n;\n            sa33_ark = sa11_n;\n        end\n        3: begin\n            sa00_ark = sa31_n;\n            sa01_ark = sa32_n;\n            sa02_ark = sa30_n;\n            sa03_ark = sa33_n;\n            sa10_ark = sa01_n;\n            sa11_ark = sa02_n;\n            sa12_ark = sa03_n;\n            sa13_ark = sa00_n;\n            sa20_ark = sa11_n;\n            sa21_ark = sa12_n;\n            sa22_ark = sa13_n;\n            sa23_ark = sa10_n;\n            sa30_ark = sa21_n;\n            sa31_ark = sa22_n;\n            sa32_ark = sa23_n;\n            sa33_ark = sa20_n;\n        end\n        default: begin\n            sa00_ark = sa00_n;\n            sa01_ark = sa01_n;\n            sa02_ark = sa02_n;\n            sa03_ark = sa03_n;\n            sa10_ark = sa10_n;\n            sa11_ark = sa11_n;\n            sa12_ark = sa12_n;\n            sa13_ark = sa13_n;\n            sa20_ark = sa20_n;\n            sa21_ark = sa21_n;\n            sa22_ark = sa22_n;\n            sa23_ark = sa23_n;\n            sa30_ark = sa30_n;\n            sa31_ark = sa31_n;\n            sa32_ark = sa32_n;\n            sa33_ark = sa33_n;\n        end\n    endcase\nend\n\n// Key Expansion\nalways_comb begin\n    case(kcnt)\n        0: begin\n            wk0 = 0;\n            wk1 = 0;\n            wk2 = 0;\n            wk3 = 0;\n        end\n        1: begin\n            wk0 = 0;\n            wk1 = 0;\n            wk2 = 0;\n            wk3 = 0;\n        end\n        2: begin\n            wk0 = 0;\n            wk1 = 0;\n            wk2 = 0;\n            wk3 = 0;\n        end\n        3: begin\n            wk0 = 0;\n            wk1 = 0;\n            wk2 = 0;\n            wk3 = 0;\n        end\n        default: begin\n            wk0 = kb[kcnt][31:0];\n            wk1 = kb[kcnt-1][31:0];\n            wk2 = kb[kcnt-2][31:0];\n            wk3 = kb[kcnt-3][31:0];\n        end\n    endcase\nend\n\n// S-box\nalways_comb begin\n    case(a)\n        0x63: b = 0x52;\n        0x7c: b = 0x9a;\n        0x7b: b = 0x7d;\n", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 12, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    wire [7:0] w0, w1, w2, w3;\n\n    aes_key_expand_128 aes_key_exp(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(w0),\n        .wo_1(w1),\n        .wo_2(w2),\n        .wo_3(w3)\n    );\n\n    aes_inv_sbox us00(.a(sa[0][0]), .b(sa[0][0]));\n    aes_inv_sbox us01(.a(sa[0][1]), .b(sa[0][1]));\n    aes_inv_sbox us02(.a(sa[0][2]), .b(sa[0][2]));\n    aes_inv_sbox us03(.a(sa[0][3]), .b(sa[0][3]));\n    aes_inv_sbox us10(.a(sa[1][0]), .b(sa[1][0]));\n    aes_inv_sbox us11(.a(sa[1][1]), .b(sa[1][1]));\n    aes_inv_sbox us12(.a(sa[1][2]), .b(sa[1][2]));\n    aes_inv_sbox us13(.a(sa[1][3]), .b(sa[1][3]));\n    aes_inv_sbox us20(.a(sa[2][0]), .b(sa[2][0]));\n    aes_inv_sbox us21(.a(sa[2][1]), .b(sa[2][1]));\n    aes_inv_sbox us22(.a(sa[2][2]), .b(sa[2][2]));\n    aes_inv_sbox us23(.a(sa[2][3]), .b(sa[2][3]));\n    aes_inv_sbox us30(.a(sa[3][0]), .b(sa[3][0]));\n    aes_inv_sbox us31(.a(sa[3][1]), .b(sa[3][1]));\n    aes_inv_sbox us32(.a(sa[3][2]), .b(sa[3][2]));\n    aes_inv_sbox us33(.a(sa[3][3]), .b(sa[3][3]));\n\n    assign sa[0][0] = us00.b;\n    assign sa[0][1] = us01.b;\n    assign sa[0][2] = us02.b;\n    assign sa[0][3] = us03.b;\n    assign sa[1][0] = us10.b;\n    assign sa[1][1] = us11.b;\n    assign sa[1][2] = us12.b;\n    assign sa[1][3] = us13.b;\n    assign sa[2][0] = us20.b;\n    assign sa[2][1] = us21.b;\n    assign sa[2][2] = us22.b;\n    assign sa[2][3] = us23.b;\n    assign sa[3][0] = us30.b;\n    assign sa[3][1] = us31.b;\n    assign sa[3][2] = us32.b;\n    assign sa[3][3] = us33.b;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_out_r <= 0;\n        end\n        else begin\n            if (kld) begin\n                kcnt <= 0xA;\n                kb[10] <= key[127:96];\n                kb[9] <= key[95:64];\n                kb[8] <= key[63:32];\n                kb[7] <= key[31:0];\n            end\n            else if (ld) begin\n                ld_r <= 1;\n                text_in_r <= text_in;\n                dcnt <= 1;\n            end\n            else begin\n                if (dcnt == 0) begin\n                    ld_r <= 0;\n                    text_out_r <= sa[0][0] ^ w0;\n                end\n                else if (dcnt == 1) begin\n                    text_out_r <= {text_out_r[127:120], sa[0][1] ^ w1, text_out_r[119:0]};\n                end\n                else if (dcnt == 2) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], sa[0][2] ^ w2, text_out_r[111:0]};\n                end\n                else if (dcnt == 3) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], text_out_r[111:104], sa[0][3] ^ w3, text_out_r[103:0]};\n                end\n                else if (dcnt == 4) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], text_out_r[111:104], text_out_r[103:96], sa[1][0] ^ w0, text_out_r[95:0]};\n                end\n                else if (dcnt == 5) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], text_out_r[111:104], text_out_r[103:96], text_out_r[95:88], sa[1][1] ^ w1, text_out_r[87:0]};\n                end\n                else if (dcnt == 6) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], text_out_r[111:104], text_out_r[103:96], text_out_r[95:88], text_out_r[87:80], sa[1][2] ^ w2, text_out_r[79:0]};\n                end\n                else if (dcnt == 7) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], text_out_r[111:104], text_out_r[103:96], text_out_r[95:88], text_out_r[87:80], text_out_r[79:72], sa[1][3] ^ w3, text_out_r[71:0]};\n                end\n                else if (dcnt == 8) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], text_out_r[111:104], text_out_r[103:96], text_out_r[95:88], text_out_r[87:80], text_out_r[79:72], text_out_r[71:64], sa[2][0] ^ w0, text_out_r[63:0]};\n                end\n                else if (dcnt == 9) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], text_out_r[111:104], text_out_r[103:96], text_out_r[95:88], text_out_r[87:80], text_out_r[79:72], text_out_r[71:64], text_out_r[63:56], sa[2][1] ^ w1, text_out_r[55:0]};\n                end\n                else if (dcnt == 10) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], text_out_r[111:104], text_out_r[103:96], text_out_r[95:88], text_out_r[87:80], text_out_r[79:72], text_out_r[71:64], text_out_r[63:56], text_out_r[55:48], sa[2][2] ^ w2, text_out_r[47:0]};\n                end\n                else if (dcnt == 11) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], text_out_r[111:104], text_out_r[103:96], text_out_r[95:88], text_out_r[87:80], text_out_r[79:72], text_out_r[71:64], text_out_r[63:56], text_out_r[55:48], text_out_r[47:40], sa[2][3] ^ w3, text_out_r[39:0]};\n                end\n                else if (dcnt == 12) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], text_out_r[111:104], text_out_r[103:96], text_out_r[95:88], text_out_r[87:80], text_out_r[79:72], text_out_r[71:64], text_out_r[63:56], text_out_r[55:48], text_out_r[47:40], text_out_r[39:32], sa[3][0] ^ w0, text_out_r[31:0]};\n                end\n                else if (dcnt == 13) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], text_out_r[111:104], text_out_r[103:96], text_out_r[95:88], text_out_r[87:80], text_out_r[79:72], text_out_r[71:64], text_out_r[63:56], text_out_r[55:48], text_out_r[47:40], text_out_r[39:32], text_out_r[31:24], sa[3][1] ^ w1, text_out_r[23:0]};\n                end\n                else if (dcnt == 14) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], text_out_r[111:104], text_out_r[103:96], text_out_r[95:88], text_out_r[87:80], text_out_r[79:72], text_out_r[71:64], text_out_r[63:56], text_out_r[55:48], text_out_r[47:40], text_out_r[39:32], text_out_r[31:24], text_out_r[23:16], sa[3][2] ^ w2, text_out_r[15:0]};\n                end\n                else if (dcnt == 15) begin\n                    text_out_r <= {text_out_r[127:120], text_out_r[119:112], text_out_r[111:104], text_out_r[103:96], text_out_r[95:88], text_out_r[87:80], text_out_r[79:72], text_out_r[71:64], text_out_r[63:56], text_out_r[55:48], text_out_r[47:40], text_out_r[39:32], text_out_r[31:24], text_out_r[23:16], text_out_r[15:8], sa[3][3] ^ w3, text_out_r[7:0]};\n                end\n                else begin\n                    dcnt <= dcnt + 1;\n                end\n            end\n        end\n    end\n\n    assign done = (dcnt == 11 && !ld_r);\n\n    assign text_out = text_out_r;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 13, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // aes_key_expand_128 module\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    // aes_inv_sbox module\n    aes_inv_sbox aes_inv_sbox[0:15];\n    for (genvar i = 0; i < 16; i++) begin\n        aes_inv_sbox[i].a(a[i]);\n        aes_inv_sbox[i].b(b[i]);\n    end\n\n    // InvShiftRows operation\n    assign sa[0][0] = text_in_r[127:120];\n    assign sa[0][1] = text_in_r[119:112];\n    assign sa[0][2] = text_in_r[111:104];\n    assign sa[0][3] = text_in_r[103:96];\n    assign sa[1][0] = text_in_r[95:88];\n    assign sa[1][1] = text_in_r[87:80];\n    assign sa[1][2] = text_in_r[79:72];\n    assign sa[1][3] = text_in_r[71:64];\n    assign sa[2][0] = text_in_r[63:56];\n    assign sa[2][1] = text_in_r[55:48];\n    assign sa[2][2] = text_in_r[47:40];\n    assign sa[2][3] = text_in_r[39:32];\n    assign sa[3][0] = text_in_r[31:24];\n    assign sa[3][1] = text_in_r[23:16];\n    assign sa[3][2] = text_in_r[15:8];\n    assign sa[3][3] = text_in_r[7:0];\n\n    // InvSubBytes operation\n    for (genvar i = 0; i < 16; i++) begin\n        assign b[i] = aes_inv_sbox[i].b;\n    end\n\n    // AddRoundKey operation\n    assign sa_ark = sa[0][0] ^ wk0[0] ^ wk1[0] ^ wk2[0] ^ wk3[0];\n    assign sa_ark = sa_ark ^ sa[0][1] ^ wk0[1] ^ wk1[1] ^ wk2[1] ^ wk3[1];\n    assign sa_ark = sa_ark ^ sa[0][2] ^ wk0[2] ^ wk1[2] ^ wk2[2] ^ wk3[2];\n    assign sa_ark = sa_ark ^ sa[0][3] ^ wk0[3] ^ wk1[3] ^ wk2[3] ^ wk3[3];\n    assign sa_ark = sa_ark ^ sa[1][0] ^ wk0[4] ^ wk1[4] ^ wk2[4] ^ wk3[4];\n    assign sa_ark = sa_ark ^ sa[1][1] ^ wk0[5] ^ wk1[5] ^ wk2[5] ^ wk3[5];\n    assign sa_ark = sa_ark ^ sa[1][2] ^ wk0[6] ^ wk1[6] ^ wk2[6] ^ wk3[6];\n    assign sa_ark = sa_ark ^ sa[1][3] ^ wk0[7] ^ wk1[7] ^ wk2[7] ^ wk3[7];\n    assign sa_ark = sa_ark ^ sa[2][0] ^ wk0[8] ^ wk1[8] ^ wk2[8] ^ wk3[8];\n    assign sa_ark = sa_ark ^ sa[2][1] ^ wk0[9] ^ wk1[9] ^ wk2[9] ^ wk3[9];\n    assign sa_ark = sa_ark ^ sa[2][2] ^ wk0[10] ^ wk1[10] ^ wk2[10] ^ wk3[10];\n    assign sa_ark = sa_ark ^ sa[2][3] ^ wk0[11] ^ wk1[11] ^ wk2[11] ^ wk3[11];\n    assign sa_ark = sa_ark ^ sa[3][0] ^ wk0[12] ^ wk1[12] ^ wk2[12] ^ wk3[12];\n    assign sa_ark = sa_ark ^ sa[3][1] ^ wk0[13] ^ wk1[13] ^ wk2[13] ^ wk3[13];\n    assign sa_ark = sa_ark ^ sa[3][2] ^ wk0[14] ^ wk1[14] ^ wk2[14] ^ wk3[14];\n    assign sa_ark = sa_ark ^ sa[3][3] ^ wk0[15] ^ wk1[15] ^ wk2[15] ^ wk3[15];\n\n    // InvMixColumns operation\n    assign sa_next[0] = (sa_ark[7] ^ sa_ark[24] ^ sa_ark[39] ^ sa_ark[54]) << 1;\n    assign sa_next[1] = (sa_ark[13] ^ sa_ark[40] ^ sa_ark[51] ^ sa_ark[59]) << 1;\n    assign sa_next[2] = (sa_ark[18] ^ sa_ark[43] ^ sa_ark[52] ^ sa_ark[58]) << 1;\n    assign sa_next[3] = (sa_ark[19] ^ sa_ark[42] ^ sa_ark[50] ^ sa_ark[57]) << 1;\n\n    // Round counter and control logic\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n        end\n        else if (ld) begin\n            dcnt <= 1;\n            ld_r <= 1;\n        end\n        else if (dcnt == 11) begin\n            done <= 1;\n        end\n        else if (dcnt < 11) begin\n            dcnt <= dcnt + 1;\n            ld_r <= 0;\n        end\n    end\n\n    // Key buffer control logic\n    always @(posedge clk) begin\n        if (rst) begin\n            kcnt <= 0xA;\n            kb[10] <= 0;\n            kb[9] <= 0;\n            kb[8] <= 0;\n            kb[7] <= 0;\n            kb[6] <= 0;\n            kb[5] <= 0;\n            kb[4] <= 0;\n            kb[3] <= 0;\n            kb[2] <= 0;\n            kb[1] <= 0;\n            kb[0] <= 0;\n        end\n        else if (kld) begin\n            kcnt <= 0xA;\n            kb[10] <= wk3;\n            kb[9] <= wk2;\n            kb[8] <= wk1;\n            kb[7] <= wk0;\n            kb[6] <= 0;\n            kb[5] <= 0;\n            kb[4] <= 0;\n            kb[3] <= 0;\n            kb[2] <= 0;\n            kb[1] <= 0;\n            kb[0] <= 0;\n        end\n        else if (kcnt > 0) begin\n            kcnt <= kcnt - 1;\n            kb[10] <= kb[9];\n            kb[9] <= kb[8];\n            kb[8] <= kb[7];\n            kb[7] <= kb[6];\n            kb[6] <= kb[5];\n            kb[5] <= kb[4];\n            kb[4] <= kb[3];\n            kb[3] <= kb[2];\n            kb[2] <= kb[1];\n            kb[1] <= kb[0];\n            kb[0] <= 0;\n        end\n    end\n\n    // Output generation\n    always @(posedge clk) begin\n        if (rst) begin\n            text_out <= 0;\n        end\n        else if (ld_r) begin\n            text_out <= sa[0][0] << 120 | sa[1][0] << 112 | sa[2][0] << 104 | sa[3][0] << 96 |\n                        sa[0][1] << 88 | sa[1][1] << 80 | sa[2][1] << 72 | sa[3][1] << 64 |\n                        sa[0][2] << 56 | sa[1][2] << 48 | sa[2][2] << 40 | sa[3][2] << 32 |\n                        sa[0][3] << 24 | sa[1][3] << 16 | sa[2][3] << 8 | sa[3][3];\n        end\n    end\n\nendmodule\n// aes_key_expand_128 module\nmodule aes_key_expansion_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_buffer;\n    reg [31:0] wk0, wk1, wk2, wk3;\n    reg [3:0] kcnt;\n\n    // aes_rcon module\n    aes_rcon aes_rcon(\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    // aes_sbox module\n    aes_sbox aes_sbox[0:3];\n    for (genvar i = 0; i < 4; i++) begin\n        aes_sbox[i].a(a[i]);\n        aes_sbox[i].b(b[i]);\n    end\n\n    // Key loading operation\n    always @(posedge clk) begin\n        if (kld) begin\n            key_buffer[127:96] <= key[127:96];\n            key_buffer[95:64] <= key[95:64];\n            key_buffer[63:32] <= key[63:32];\n            key_buffer[31:0] <= key[31:0];\n            wk0 <= key_buffer[31:0];\n            wk1 <= key_buffer[63:32];\n            wk2 <= key_buffer[95:64];\n            wk3 <= key_buffer[127:96];\n            wo_0 <= wk0;\n            wo_1 <= wk1;\n            wo_2 <= wk2;\n            wo_3 <= wk3;\n        end\n        else begin\n            // Key expansion operation\n            if (kcnt == 0) begin\n                wk0 <= wk1;\n                wk1 <= wk2;\n                wk2 <= wk3;\n                wk3 <= (rcon ^ aes_sbox[0].b(wk0[7:0]) ^ aes_sbox[1].b(wk0[15:8]) ^ aes_sbox[2].b(wk0[23:16]) ^ aes_sbox[3].b(wk0[31:24]));\n            end\n            else if (kcnt == 1) begin\n                wk0 <= wk1;\n                wk1 <= wk2;\n                wk2 <= wk3;\n                wk3 <= (wk2 ^ aes_sbox[0].b(wk0[7:0]) ^ aes_sbox[1].b(wk0[15:8]) ^ aes_sbox[2].b(wk0[23:16]) ^ aes_sbox[3].b(wk0[31:24]));\n            end\n            else if (kcnt == 2) begin\n                wk0 <= wk1;\n                wk1 <= wk2;\n                wk2 <= wk3;\n                wk3 <= (wk1 ^ aes_sbox[0].b(wk0[7:0]) ^ aes_sbox[1].b(wk0[15:8]) ^ aes_sbox[2].b(wk0[23:16]) ^ aes_sbox[3].b(wk0[31:24]));\n            end\n            else if (kcnt == 3) begin\n                wk0 <= wk1;\n                wk1 <= wk2;\n                wk2 <= wk3;\n                wk3 <= (wk0 ^ aes_sbox[0].b(wk0[7:0]) ^ aes_sbox[1].b(wk0[15:8]) ^ aes_sbox[2].b(wk0[23:16]) ^ aes_sbox[3].b(wk0[31:24]));\n            end\n            else if (kcnt == 4) begin\n                wk0 <= wk1;\n                wk1 <= wk2;\n                wk2 <= wk3;\n                wk3 <= (wk0 ^ wk1 ^ aes_sbox[0].b(wk0[7:0]) ^ aes_sbox[1].b(wk0[15:8]) ^ aes_sbox[2].b(wk0[23:16]) ^ aes_sbox[3].b(wk0[31:24]));\n            end\n            else if (kcnt == 5) begin\n                wk0 <= wk1;\n                wk1 <= wk2;\n                wk2 <= wk3;\n                wk3 <= (wk1 ^ wk0 ^ aes_sbox[0].b(wk0[7:0]) ^ aes_sbox[1].b(wk0[15:8]) ^ aes_sbox[2].b(wk0[23:16]) ^ aes_sbox[3].b(wk0[31:24]));\n            end\n            else if (kcnt == 6) begin\n                wk0 <= wk1;\n                wk1 <= wk2;\n                wk2 <= wk3;\n                wk3 <= (wk2 ^ wk0 ^ aes_sbox[0].b(wk0[7:0]) ^ aes_sbox[1].b(wk0[15:8]) ^ aes_sbox[2].b(wk0[23:16]) ^ aes_sbox[3].b(wk0[31:24]));\n            end\n            else if (kcnt == 7) begin\n                wk0 <= wk1;\n                wk1 <= wk2;\n                wk2 <= wk3;\n                wk3 <= (wk3 ^ wk0 ^ aes_sbox[0].b(wk0[7:0]) ^ aes_sbox[1].b(wk0[15:8]) ^ aes_sbox[2].b(wk0[23:16]) ^ aes_sbox[3].b(wk0[31:24]));\n            end\n            else if (kcnt == 8) begin\n                wk0 <= wk1;\n                wk1 <= wk2;\n                wk2 <= wk3;\n                wk3 <= (wk3 ^ wk1 ^ aes_sbox[0].b(wk0[7:0]) ^ aes_sbox[1].b(wk0[15:8]) ^ aes_sbox[2].b(wk0[23:16]) ^ aes_sbox[3].b(wk0[31:24]));\n            end\n            else if (kcnt == 9) begin\n                wk0 <= wk1;\n                wk1 <= wk2;\n                wk2 <= wk3;\n                wk3 <= (wk2 ^ wk1 ^ aes_sbox[0].b(wk0[7:0]) ^ aes_sbox[1].b(wk0[15:8]) ^ aes_sbox[2].b(wk0[23:16]) ^ aes_sbox[3].b(wk0[31:24]));\n            end\n            else if (kcnt == 10) begin\n                wk0 <= wk1;\n                wk1 <= wk2;\n                wk2 <= wk3;\n                wk3 <= (wk0 ^ wk2 ^ aes_sbox[0].b(wk0[7:0]) ^ aes_sbox[1].b(wk0[15:8]) ^ aes_sbox[2].b(wk0[23:16]) ^ aes_sbox[3].b(wk0[31:24]));\n            end\n            else if (kcnt == 11) begin\n                wk0 <= wk1;\n                wk1 <= wk2;\n                wk2 <= wk3;\n                wk3 <= (wk0 ^ wk3 ^ aes_sbox[0].b(wk0[7:0]) ^ aes_sbox[1].b(wk0[15:8]) ^ aes_sbox[2].b(wk0[23:16]) ^ aes_sbox[3].b(wk0[31:24]));\n            end\n            else begin\n                kcnt <= kcnt - 1;\n                wk0 <= wk1;\n                wk1 <= wk2;\n                wk2 <= wk3;\n                wk3 <= (wk0 ^ aes_sbox[0].b(wk0[7:0]) ^ aes_sbox[1].b(wk0[15:8]) ^ aes_sbox[2].b(wk0[23:16]) ^ aes_sbox[3].b(wk0[31:24]));\n            end\n        end\n    end\n\n    // Output\n    assign wo_0 = wk0;\n    assign wo_1 = wk1;\n    assign wo_2 = wk2;\n    assign wo_3 = wk3;\n\nendmodule\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    // Round counter\n    always @(posedge clk) begin\n        if (rst) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end\n        else if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end\n        else begin\n            if (rcnt == 9) begin\n                out <= 32'h00_00_00_00;\n            end\n            else begin\n                rcnt <= rcnt + 1;\n                out <= (rcnt == 1) ? 32'h02_00_00_00 :\n                       (rcnt == 2) ? 32'h04_00_00_00 :\n                       (rcnt == 3) ? 32'h08_00_00_00 :\n                       (rcnt == 4) ? 32'h10_00_00_00 :\n                       (rcnt == 5) ? 32'h20_00_00_00 :\n                       (rcnt == 6) ? 32'h40_00_00_00 :\n                       (rcnt == 7) ? 32'h80_00_00_00 :\n                       (rcnt == 8) ? 32'h1b_00_00_00 :\n                       (rcnt == 9) ? 32'h36_00_00_00 :\n                       32'h00_00_00_00;\n            end\n        end\n    end\n\nendmodule\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table\n    reg [7:0] sbox[256];\n\n    // Initialize S-box table\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n        end\n    end\n\n    // Inverse S-box transformation\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 14, "code": "```verilog\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa <= 0;\n            dcnt <= 0;\n            kb <= 0;\n            kcnt <= 0;\n            ld_r <= 0;\n            text_out_r <= 0;\n        end\n        else begin\n            if (kld) begin\n                kcnt <= 10;\n                kb <= {key, {10{1'b0}};\n            end\n            else if (ld) begin\n                text_in_r <= text_in;\n                ld_r <= 1;\n            end\n            else if (ld_r) begin\n                ld_r <= 0;\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= text_in_r[8*i + j];\n                    end\n                end\n                dcnt <= 1;\n            end\n            else if (dcnt < 11) begin\n                if (dcnt == 1) begin\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ kb[32*(dcnt-1) + 8*j + i];\n                        end\n                    end\n                end\n                else begin\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= InvShiftRows(sa[i][j], dcnt);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= InvSubBytes(sa[i][j]);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ kb[32*(dcnt-1) + 8*j + i];\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= InvMixColumns(sa[i][j]);\n                        end\n                    end\n                end\n                dcnt <= dcnt + 1;\n            end\n            else begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        text_out_r[8*i + j] <= sa[i][j];\n                    end\n                end\n                done <= 1;\n            end\n        end\n    end\n\n    assign text_out = text_out_r;\n\n    function [7:0] InvShiftRows([7:0] a, [3:0] dcnt);\n        case (dcnt)\n            1: begin\n                InvShiftRows = a;\n            end\n            2: begin\n                InvShiftRows = {sa[2][3], sa[2][2], sa[2][1], sa[2][0]};\n            end\n            3: begin\n                InvShiftRows = {sa[3][2], sa[3][3], sa[3][0], sa[3][1]};\n            end\n            4: begin\n                InvShiftRows = {sa[1][3], sa[1][2], sa[1][1], sa[1][0]};\n            end\n            default: begin\n                InvShiftRows = a;\n            end\n        endcase\n    endfunction\n\n    function [7:0] InvSubBytes([7:0] a);\n        InvSubBytes = aes_inv_sbox(a);\n    endfunction\n\n    function [7:0] InvMixColumns([7:0] a);\n        InvMixColumns = (a[7] * 0x0E) ^ (a[6] * 0x0B) ^ (a[5] * 0x0D) ^ (a[4] * 0x09) ^ a[3] ^ a[2] ^ a[1] ^ a[0];\n    endfunction\n\n    module aes_key_expand_128(\n        input clk,\n        input kld,\n        input [127:0] key,\n        output [31:0] wo_0,\n        output [31:0] wo_1,\n        output [31:0] wo_2,\n        output [31:0] wo_3\n    );\n\n        reg [127:0] kb[10:0];\n        reg [3:0] kcnt;\n        reg [31:0] wo_0_r, wo_1_r, wo_2_r, wo_3_r;\n\n        always @(posedge clk) begin\n            if (kld) begin\n                kcnt <= 10;\n                kb <= {key, {10{1'b0}};\n            end\n            else if (kcnt > 0) begin\n                kcnt <= kcnt - 1;\n                case (kcnt)\n                    9: begin\n                        wo_0_r <= {kb[32], kb[31:24], kb[23:16], kb[15:8]};\n                        wo_1_r <= {kb[7], kb[6:0], {4{1'b0}};\n                        wo_2_r <= {kb[15], kb[14:8], {3{1'b0}};\n                        wo_3_r <= {kb[23], kb[22:16], {2{1'b0}};\n                    end\n                    8: begin\n                        wo_0_r <= {kb[24], kb[23:16], kb[15:8], kb[7:0]};\n                        wo_1_r <= {kb[31], kb[30:24], kb[23:16], kb[15:8]};\n                        wo_2_r <= {kb[7], kb[6:0], {4{1'b0}};\n                        wo_3_r <= {kb[15], kb[14:8], {3{1'b0}};\n                    end\n                    7: begin\n                        wo_0_r <= {kb[16], kb[15:8], kb[7:0], {4{1'b0}};\n                        wo_1_r <= {kb[24], kb[23:16], kb[15:8], kb[7:0]};\n                        wo_2_r <= {kb[31], kb[30:24], kb[23:16], kb[15:8]};\n                        wo_3_r <= {kb[7], kb[6:0], {4{1'b0}};\n                    end\n                    6: begin\n                        wo_0_r <= {kb[8], kb[7:0], {4{1'b0}};\n                        wo_1_r <= {kb[16], kb[15:8], kb[7:0], {4{1'b0}};\n                        wo_2_r <= {kb[24], kb[23:16], kb[15:8], kb[7:0]};\n                        wo_3_r <= {kb[31], kb[30:24], kb[23:16], kb[15:8]};\n                    end\n                    5: begin\n                        wo_0_r <= {kb[0], kb[7:0], {4{1'b0}};\n                        wo_1_r <= {kb[8], kb[7:0], {4{1'b0}};\n                        wo_2_r <= {kb[16], kb[15:8], kb[7:0], {4{1'b0}};\n                        wo_3_r <= {kb[24], kb[23:16], kb[15:8], kb[7:0]};\n                    end\n                    4: begin\n                        wo_0_r <= {kb[1], kb[7:0], {4{1'b0}};\n                        wo_1_r <= {kb[0], kb[7:0], {4{1'b0}};\n                        wo_2_r <= {kb[8], kb[7:0], {4{1'b0}};\n                        wo_3_r <= {kb[16], kb[15:8], kb[7:0], {4{1'b0}};\n                    end\n                    3: begin\n                        wo_0_r <= {kb[2], kb[7:0], {4{1'b0}};\n                        wo_1_r <= {kb[1], kb[7:0], {4{1'b0}};\n                        wo_2_r <= {kb[0], kb[7:0], {4{1'b0}};\n                        wo_3_r <= {kb[8], kb[7:0], {4{1'b0}};\n                    end\n                    2: begin\n                        wo_0_r <= {kb[3], kb[7:0], {4{1'b0}};\n                        wo_1_r <= {kb[2], kb[7:0], {4{1'b0}};\n                        wo_2_r <= {kb[1], kb[7:0], {4{1'b0}};\n                        wo_3_r <= {kb[0], kb[7:0}, {4{1'b0}};\n                    end\n                    1: begin\n                        wo_0_r <= {kb[4], kb[7:0], {4{1'b0}};\n                        wo_1_r <= {kb[3], kb[7:0], {4{1'b0}};\n                        wo_2_r <= {kb[2], kb[7:0}, {4{1'b0}};\n                        wo_3_r <= {kb[1], kb[7:0}, {4{1'b0}};\n                    end\n                    default: begin\n                        wo_0_r <= {kb[5], kb[7:0], {4{1'b0}};\n                        wo_1_r <= {kb[4], kb[7:0], {4{1'b0}};\n                        wo_2_r <= {kb[3], kb[7:0}, {4{1'b0}};\n                        wo_3_r <= {kb[2], kb[7:0}, {4{1'b0}};\n                    end\n                end\n                wo_0 <= wo_0_r;\n                wo_1 <= wo_1_r;\n                wo_2 <= wo_2_r;\n                wo_3 <= wo_3_r;\n            end\n        end\n    endmodule\n\n    module aes_inv_sbox(\n        input [7:0] a,\n        output [7:0] b\n    );\n\n        reg [7:0] inv_sbox[255:0];\n\n        initial begin\n            for (int i = 0; i < 256; i++) begin\n                inv_sbox[i] = aes_inv_sbox_calc(i);\n            end\n        end\n\n        function [7:0] aes_inv_sbox_calc([7:0] a);\n            case (a)\n                0: aes_inv_sbox_calc = 9;\n                1: aes_inv_sbox_calc = 14;\n                2: aes_inv_sbox_calc = 17;\n                3: aes_inv_sbox_calc = 22;\n                4: aes_inv_sbox_calc = 23;\n                5: aes_inv_sbox_calc = 16;\n                6: aes_inv_sbox_calc = 24;\n                7: aes_inv_sbox_calc = 20;\n                8: aes_inv_sbox_calc = 7;\n                9: aes_inv_sbox_calc = 9;\n                10: aes_inv_sbox_calc = 2;\n                11: aes_inv_sbox_calc = 18;\n                12: aes_inv_sbox_calc = 23;\n                13: aes_inv_sbox_calc = 10;\n                14: aes_inv_sbox_calc = 5;\n                15: aes_inv_sbox_calc = 7;\n                16: aes_inv_sbox_calc = 6;\n                17: aes_inv_sbox_calc = 11;\n                18: aes_inv_sbox_calc = 3;\n                19: aes_inv_sbox_calc = 15;\n                20: aes_inv_sbox_calc = 25;\n                21: aes_inv_sbox_calc = 21;\n                22: aes_inv_sbox_calc = 8;\n                23: aes_inv_sbox_calc = 17;\n                24: aes_inv_sbox_calc = 20;\n                25: aes_inv_sbox_calc = 19;\n                26: aes_inv_sbox_calc = 13;\n                27: aes_inv_sbox_calc = 8;\n                28: aes_inv_sbox_calc = 26;\n                29: aes_inv_sbox_calc = 24;\n                30: aes_inv_sbox_calc = 12;\n                31: aes_inv_sbox_calc = 16;\n                32: aes_inv_sbox_calc = 4;\n                33: aes_inv_sbox_calc = 27;\n                34: aes_inv_sbox_calc = 22;\n                35: aes_inv_sbox_calc = 6;\n                36: aes_inv_sbox_calc = 11;\n                37: aes_inv_sbox_calc = 15;\n                38: aes_inv_sbox_calc = 28;\n                39: aes_inv_sbox_calc = 23;\n                40: aes_inv_sbox_calc = 5;\n                41: aes_inv_sbox_calc = 18;\n                42: aes_inv_sbox_calc = 42;\n                43: aes_inv_sbox_calc = 22;\n                44: aes_inv_sbox_calc = 31;\n                45: aes_inv_sbox_calc = 17;\n                46: aes_inv_sbox_calc = 25;\n                47: aes_inv_sbox_calc = 24;\n                48: aes_inv_sbox_calc = 21;\n                49: aes_inv_sbox_calc = 13;\n                50: aes_inv_sbox_calc = 8;\n                51: aes_inv_sbox_calc = 2;\n                52: aes_inv_sbox_calc = 11;\n                53: aes_inv_sbox_calc = 30;\n                54: aes_inv_sbox_calc = 28;\n                55: aes_inv_sbox_calc = 18;\n                56: aes_inv_sbox_calc = 14;\n                57: aes_inv_sbox_calc = 26;\n                58: aes_inv_sbox_calc = 20;\n                59: aes_inv_sbox_calc = 12;\n                60: aes_inv_sbox_calc = 24;\n                61: aes_inv_sbox_calc = 34;\n                62: aes_inv_sbox_calc = 32;\n                63: aes_inv_sbox_calc = 29;\n                64: aes_inv_sbox_calc = 39;\n                65: aes_inv_sbox_calc = 40;\n                66: aes_inv_sbox_calc = 28;\n                67: aes_inv_sbox_calc = 25;\n                68: aes_inv_sbox_calc = 33;\n                69: aes_inv_sbox_calc = 31;\n                70: aes_inv_sbox_calc = 9;\n                71: aes_inv_sbox_calc = 35;\n                72: aes_inv_sbox_calc = 16;\n                73: aes_inv_sbox_calc = 1;\n                74: aes_inv_sbox_calc = 24;\n                75: aes_inv_sbox_calc = 38;\n                76: aes_inv_sbox_calc = 42;\n                77: aes_inv_sbox_calc = 40;\n                78: aes_inv_sbox_calc = 37;\n                79: aes_inv_sbox_calc = 32;\n                80: aes_inv_sbox_calc = 30;\n                81: aes_inv_sbox_calc = 41;\n                82: aes_inv_sbox_calc = 19;\n                83: aes_inv_sbox_calc = 15;\n                84: aes_inv_sbox_calc = 21;\n                85: aes_inv_sbox_calc = 2;\n                86: aes_inv_sbox_calc = 23;\n                87: aes_inv_sbox_calc = 38;\n                88: aes_inv_sbox_calc = 14;\n                89: aes_inv_sbox_calc = 26;\n                90: aes_inv_sbox_calc = 36;\n                91: aes_inv_sbox_calc = 31;\n                92: aes_inv_sbox_calc = 13;\n                93: aes_inv_sbox_calc = 18;\n                94: aes_inv_sbox_calc = 41;\n                95: aes_inv_sbox_calc = 25;\n                96: aes_inv_sbox_calc = 17;\n                97: aes_inv_sbox_calc = 33;\n                98: aes_inv_sbox_calc = 43;\n                99: aes_inv_sbox_calc = 30;\n                100: aes_inv_sbox_calc = 27;\n                101: aes_inv_sbox_calc = 22;\n                102: aes_inv_sbox_calc = 40;\n                103: aes_inv_sbox_calc = 10;\n                104: aes_inv_sbox_calc = 1;\n                105: aes_inv_sbox_calc = 39;\n                106: aes_inv_sbox_calc = 48;\n                107: aes_inv_sbox_calc = 16;\n                108: aes_inv_sbox_calc = 24;\n                109: aes_inv_sbox_calc = 38;\n                110: aes_inv_sbox_calc = 42;\n                111: aes_inv_sbox_calc = 36;\n                112: aes_inv_sbox_calc = 26;\n                113: aes_inv_sbox_calc = 32;\n                114: aes_inv_sbox_calc = 29;\n                115: aes_inv_sbox_calc = 19;\n                116: aes_inv_sbox_calc = 15;\n                117: aes_inv_sbox_calc = 41;\n                118: aes_inv_sbox_calc = 2;\n                119: aes_inv_sbox_calc = 31;\n                120: aes_inv_sbox_calc = 6;\n                121: aes_inv_sbox_calc = 27;\n                122: aes_inv_sbox_calc = 22;\n                123: aes_inv_sbox_calc = 44;\n                124: aes_inv_sbox_calc = 43;\n                125: aes_inv_sbox_calc = 50;\n                126: aes_inv_sbox_calc = 21;\n                127: aes_inv_sbox_calc = 49;\n                128: aes_inv_sbox_calc = 39;\n                129: aes_inv_sbox_calc = 29;\n                130: aes_inv_sbox_calc = 48;\n                131: aes_inv_sbox_calc = 16;\n                132: aes_inv_sbox_calc = 63;\n                133: aes_inv_sbox_calc = 46;\n                134: aes_inv_sbox_calc = 47;\n                135: aes_inv_sbox_calc = 62;\n                136: aes_inv_sbox_calc = 53;\n                137: aes_inv_sbox_calc = 30;\n                138: aes_inv_sbox_calc = 34;\n                139: aes_inv_sbox_calc = 49;\n                140: aes_inv_sbox_calc = 24;\n                141: aes_inv_sbox_calc = 4;\n                142: aes_inv_sbox_calc = 52;\n                143: aes_inv_sbox_calc = 59;\n                144: aes_inv_sbox_calc = 57;\n                145: aes_inv_sbox_calc = 1;\n                146: aes_inv_sbox_calc = 14;\n                147: aes_inv_sbox_calc = 29;\n                148: aes_inv_sbox_calc = 48;\n                149: aes_inv_sbox_calc = 56;\n                150: aes_inv_sbox_calc = 36;\n                151: aes_inv_sbox_calc = 13;\n                152", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 15, "code": "// aes_inv_cipher_top.v\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            dcnt <= 0;\n            kcnt <= 4'd10;\n            ld_r <= 0;\n            text_out_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end else begin\n            if (kld) begin\n                kcnt <= 4'd10;\n                ld_r <= 0;\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= 0;\n                    end\n                end\n                text_in_r <= key;\n            end else if (ld) begin\n                ld_r <= 1;\n                text_in_r <= text_in;\n            end else if (ld_r) begin\n                ld_r <= 0;\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= text_in_r[7 + j + i*4];\n                    end\n                end\n                dcnt <= 1;\n            end else if (dcnt < 11) begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb[dcnt]);\n                InvMixColumns(sa);\n                dcnt <= dcnt + 1;\n            end else begin\n                AddRoundKey(sa, kb[dcnt]);\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        text_out_r[7 + j + i*4] <= sa[i][j];\n                    end\n                end\n                text_out <= text_out_r;\n                done <= 1;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            kcnt <= 4'd0;\n        end else if (kld) begin\n            kcnt <= 4'd10;\n            for (int i = 0; i < 11; i++) begin\n                kb[i] <= 0;\n            end\n        end else if (kcnt > 0) begin\n            kcnt <= kcnt - 1;\n            if (kcnt == 0) begin\n                kb[10] <= key[31:24];\n                kb[9] <= key[47:40];\n                kb[8] <= key[63:56];\n                kb[7] <= key[79:72];\n                kb[6] <= key[95:88];\n                kb[5] <= key[111:104];\n                kb[4] <= key[127:120];\n                for (int i = 3; i > 0; i--) begin\n                    kb[i] <= (kb[i-1] ^ kb[i+3]);\n                end\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            done <= 0;\n        end else if (ld_r) begin\n            done <= 0;\n        end else if (dcnt == 11) begin\n            done <= 1;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            go <= 0;\n        end else if (ld_r) begin\n            go <= 0;\n        end else if (dcnt == 0) begin\n            go <= 1;\n        end else if (dcnt == 11) begin\n            go <= 0;\n        end\n    end\n\n    InvShiftRows sa_inv_shift_rows(\n        .clk(clk),\n        .rst(rst),\n        .sa(sa)\n    );\n\n    InvSubBytes sa_inv_sub_bytes(\n        .clk(clk),\n        .rst(rst),\n        .sa(sa)\n    );\n\n    InvMixColumns sa_inv_mix_columns(\n        .clk(clk),\n        .rst(rst),\n        .sa(sa)\n    );\n\n    AddRoundKey sa_add_round_key(\n        .clk(clk),\n        .rst(rst),\n        .sa(sa),\n        .kb(kb),\n        .dcnt(dcnt)\n    );\n\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .rst(rst),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox us00(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[0][0]),\n        .b(sa_inv[0][0])\n    );\n\n    aes_inv_sbox us01(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[0][1]),\n        .b(sa_inv[0][1])\n    );\n\n    aes_inv_sbox us02(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[0][2]),\n        .b(sa_inv[0][2])\n    );\n\n    aes_inv_sbox us03(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[0][3]),\n        .b(sa_inv[0][3])\n    );\n\n    aes_inv_sbox us10(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[1][0]),\n        .b(sa_inv[1][0])\n    );\n\n    aes_inv_sbox us11(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[1][1]),\n        .b(sa_inv[1][1])\n    );\n\n    aes_inv_sbox us12(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[1][2]),\n        .b(sa_inv[1][2])\n    );\n\n    aes_inv_sbox us13(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[1][3]),\n        .b(sa_inv[1][3])\n    );\n\n    aes_inv_sbox us20(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[2][0]),\n        .b(sa_inv[2][0])\n    );\n\n    aes_inv_sbox us21(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[2][1]),\n        .b(sa_inv[2][1])\n    );\n\n    aes_inv_sbox us22(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[2][2]),\n        .b(sa_inv[2][2])\n    );\n\n    aes_inv_sbox us23(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[2][3]),\n        .b(sa_inv[2][3])\n    );\n\n    aes_inv_sbox us30(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[3][0]),\n        .b(sa_inv[3][0])\n    );\n\n    aes_inv_sbox us31(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[3][1]),\n        .b(sa_inv[3][1])\n    );\n\n    aes_inv_sbox us32(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[3][2]),\n        .b(sa_inv[3][2])\n    );\n\n    aes_inv_sbox us33(\n        .clk(clk),\n        .rst(rst),\n        .a(sa[3][3]),\n        .b(sa_inv[3][3])\n    );\n\n    assign sa_inv[0][0] = us00.b;\n    assign sa_inv[0][1] = us01.b;\n    assign sa_inv[0][2] = us02.b;\n    assign sa_inv[0][3] = us03.b;\n    assign sa_inv[1][0] = us10.b;\n    assign sa_inv[1][1] = us11.b;\n    assign sa_inv[1][2] = us12.b;\n    assign sa_inv[1][3] = us13.b;\n    assign sa_inv[2][0] = us20.b;\n    assign sa_inv[2][1] = us21.b;\n    assign sa_inv[2][2] = us22.b;\n    assign sa_inv[2][3] = us23.b;\n    assign sa_inv[3][0] = us30.b;\n    assign sa_inv[3][1] = us31.b;\n    assign sa_inv[3][2] = us32.b;\n    assign sa_inv[3][3] = us33.b;\n\nendmodule\n\n// aes_key_expand_128.v\nmodule aes_key_expansion_128(\n    input clk,\n    input rst,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_r;\n    reg [31:0] wk0, wk1, wk2, wk3;\n    reg [3:0] kcnt;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            kcnt <= 4'd0;\n            wk0 <= 0;\n            wk1 <= 0;\n            wk2 <= 0;\n            wk3 <= 0;\n        end else if (kld) begin\n            kcnt <= 4'd10;\n            wk0 <= key[31:0];\n            wk1 <= key[63:32];\n            wk2 <= key[95:64];\n            wk3 <= key[127:96];\n        end else if (kcnt > 0) begin\n            kcnt <= kcnt - 1;\n            if (kcnt == 0) begin\n                wk0 <= key[31:0];\n                wk1 <= key[63:32];\n                wk2 <= key[95:64];\n                wk3 <= key[127:96];\n            end else if (kcnt % 4 == 0) begin\n                wk0 <= (wk0 ^ (SubWord(RotWord(wk1)) ^ Rcon(kcnt)));\n                wk1 <= (wk1 ^ wk0);\n                wk2 <= (wk2 ^ wk0);\n                wk3 <= (wk3 ^ wk0);\n            end else begin\n                wk0 <= (wk0 ^ wk1);\n                wk1 <= (wk1 ^ wk2);\n                wk2 <= (wk2 ^ wk3);\n                wk3 <= (wk3 ^ wk0);\n            end\n        end\n    end\n\n    assign wo_0 = wk0;\n    assign wo_1 = wk1;\n    assign wo_2 = wk2;\n    assign wo_3 = wk3;\n\nendmodule\n\n// aes_rcon.v\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            rcnt <= 4'd0;\n            out <= 32'h00000001;\n        end else if (kld) begin\n            rcnt <= 4'd0;\n            out <= 32'h00000001;\n        end else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            case (rcnt)\n                1: out <= 32'h00000001;\n                2: out <= 32'h00000002;\n                3: out <= 32'h00000004;\n                4: out <= 32'h00000008;\n                5: out <= 32'h00000010;\n                6: out <= 32'h00000020;\n                7: out <= 32'h00000040;\n                8: out <= 32'h00000080;\n                9: out <= 32'h0000001b;\n                10: out <= 32'h00000036;\n                default: out <= 32'h00000000;\n            endcase\n        end\n    end\n\nendmodule\n\n// aes_sbox.v\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[256:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n        end\n        for (int i = 0; i < 256; i++) begin\n            for (int j = 0; j < 8; j++) begin\n                if (sbox[i] & (1 << j)) begin\n                    sbox[i] = sbox[i] ^ 0x1b;\n                end\n            end\n            for (int j = 0; j < 4; j++) begin\n                if (sbox[i] & (1 << (j*8 + 4))) begin\n                    sbox[i] = sbox[i] ^ 0x93;\n                end\n            end\n            for (int j = 0; j < 8; j++) begin\n                if (sbox[i] & (1 << j)) begin\n                    sbox[i] = sbox[i] ^ 0x1f;\n                end\n            end\n            for (int j = 0; j < 4; j++) begin\n                if (sbox[i] & (1 << (j*8 + 4))) begin\n                    sbox[i] = sbox[i] ^ 0x0e;\n                end\n            end\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\n// aes_inv_sbox.v\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] inv_sbox[256:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = i;\n        end\n        for (int i = 0; i < 256; i++) begin\n            for (int j = 0; j < 8; j++) begin\n                if (inv_sbox[i] & (1 << j)) begin\n                    inv_sbox[i] = inv_sbox[i] ^ 0x63;\n                end\n            end\n            for (int j = 0; j < 4; j++) begin\n                if (inv_sbox[i] & (1 << (j*8 + 4))) begin\n                    inv_sbox[i] = inv_sbox[i] ^ 0x05;\n                end\n            end\n            for (int j = 0; j < 8; j++) begin\n                if (inv_sbox[i] & (1 << j)) begin\n                    inv_sbox[i] = inv_sbox[i] ^ 0x0b;\n                end\n            end\n            for (int j = 0; j < 4; j++) begin\n                if (inv_sbox[i] & (1 << (j*8 + 4))) begin\n                    inv_sbox[i] = inv_sbox[i] ^ 0x09;\n                end\n            end\n        end\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule\n\n// InvShiftRows.v\nmodule InvShiftRows(\n    input clk,\n    input rst,\n    output [7:0] sa[0:3][0:3]\n);\n\n    reg [7:0] sa_r[0:3][0:3];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_r[i][j] <= 0;\n                end\n            end\n        end else begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_r[i][j] <= sa[i][j];\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    case (i)\n                        0: begin\n                            sa[i][j] <= sa_r[i][j];\n                        end\n                        1: begin\n                            sa[i][j] <= sa_r[3][j];\n                        end\n                        2: begin\n                            sa[i][j] <= sa_r[2][j];\n                        end\n                        3: begin\n                            sa[i][j] <= sa_r[1][j];\n                        end\n                    endcase\n                end\n            end\n        end\n    end\n\nendmodule\n\n// InvSubBytes.v\nmodule InvSubBytes(\n    input clk,\n    input rst,\n    output [7:0] sa[0:3][0:3]\n);\n\n    reg [7:0] sa_r[0:3][0:3];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_r[i][j] <= 0;\n                end\n            end\n        end else begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_r[i][j] <= sa[i][j];\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= InvSbox(sa_r[i][j]);\n                end\n            end\n        end\n    end\n\nendmodule\n\n// InvMixColumns.v\nmodule InvMixColumns(\n    input clk,\n    input rst,\n    output [7:0] sa[0:3][0:3]\n);\n\n    reg [7:0] sa_r[0:3][0:3];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_r[i][j] <= 0;\n                end\n            end\n        end else begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_r[i][j] <= sa[i][j];\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= MixColumns(sa_r[i][j]);\n                end\n            end\n        end\n    end\n\nendmodule\n\n// AddRoundKey.v\nmodule AddRoundKey(\n    input clk,\n    input rst,\n    output [7:0] sa[0:3][0:3],\n    input [7:0] kb[0:10],\n    input [3:0] dcnt\n);\n\n    reg [7:0] sa_r[0:3][0:3];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_r[i][j] <= 0;\n                end\n            end\n        end else begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_r[i][j] <= sa[i][j];\n                end\n            end\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa_r[i][j] ^ kb[dcnt + j + i*4];\n                end\n            end\n        end\n    end\n\nendmodule\n\n// SubWord.v\nmodule SubWord(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[256:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n        end\n        for (int i = 0; i < 256; i++) begin\n            for (int j = 0; j < 8; j++) begin\n                if (sbox[i] & (1 << j)) begin\n                    sbox[i] = sbox[i] ^ 0x1b;\n                end\n            end\n            for (int j = 0; j < 4; j++) begin\n                if (sbox[i] & (1 << (j*8 + 4))) begin\n                    sbox[i] = sbox[i] ^ 0x93;\n                end\n            end\n            for (int j = 0; j < 8; j++) begin\n                if (sbox[i] & (1 << j)) begin\n                    sbox[i] = sbox[i] ^ 0x1f;\n                end\n            end\n            for (int j = 0; j < 4; j++) begin\n                if (sbox[i] & (1 << (j*8 + 4))) begin\n                    sbox[i] = sbox[i] ^ 0x0e;\n                end\n            end\n        end\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\n// RotWord.v\nmodule RotWord(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    assign b = {a[7:4], a[3:0]};\n\nendmodule\n\n// Rcon.v\nmodule Rcon(\n    input [3:0] kcnt,\n    output [7:0] out\n);\n\n    reg [7:0] rcon[10:0];\n\n    initial begin\n        rcon[0] = 8'h01;\n        rcon[1] = 8'h02;\n        rcon[2] = 8'h04;\n        rcon[3] = 8'h08;\n        rcon[4] = 8'h10;\n        rcon[5] = 8'h20;\n        rcon[6] = 8'h40;\n        rcon[7] = 8'h80;\n        rcon[8] = 8'h1b;\n        rcon[9] = 8'h36;\n    end\n\n    assign out = rcon[kcnt];\n\nendmodule\n\n// MixColumns.v\nmodule MixColumns(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] mul_e, mul_b, mul_d, mul_9;\n\n    assign mul_e = a * 0xe;\n    assign mul_b = a * 0xb;\n    assign mul_d = a * 0xd;\n    assign mul_9 = a * 0x9;\n\n    assign b = {mul_e[7], mul_b[7], mul_d[7], mul_9[7]} |\n              {mul_e[6], mul_b[6], mul_d[6], mul_9[6]} |\n              {mul_e[5], mul_b[5], mul_d[5], mul_9[5]} |\n              {mul_e[4], mul_b[4], mul_d[4], mul_9[4]} |\n              {mul_e[3], mul_b[3], mul_d[3], mul_9[3]} |\n              {mul_e[2], mul_b[2], mul_d[2], mul_9[2]} |\n              {mul_e[1], mul_b[1], mul_d[1], mul_9[1]} |\n              {mul_e[0], mul_b[0], mul_d[0], mul_9[0]};\n\nendmodule\n\n// InvSbox.v\nmodule InvSbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] inv_sbox[256:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = i;\n        end\n        for (int i = 0; i < 256; i++) begin\n            for (int j = 0; j < 8; j++) begin\n                if (inv_sbox[i] & (1 << j)) begin\n                    inv_sbox[i] = inv_sbox[i] ^ 0x63;\n                end\n            end\n            for (int j = 0; j < 4; j++) begin\n                if (inv_sbox[i] & (1 << (j*8 + 4))) begin\n                    inv_sbox[i] = inv_sbox[i] ^ 0x05;\n                end\n            end\n            for (int j = 0; j < 8; j++) begin\n                if (inv_sbox[i] & (1 << j)) begin\n                    inv_sbox[i] = inv_sbox[i] ^ 0x0b;\n                end\n            end\n            for (int j = 0; j < 4; j++) begin\n                if (inv_sbox[i] & (1 << (j*8 + 4))) begin\n                    inv_sbox[i] = inv_sbox[i] ^ 0x09;\n                end\n            end\n        end\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 16, "code": "```verilog\n// aes_inv_cipher_top.v\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n               sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n               sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n               sa[3][0], sa[3][1], sa[3][2], sa[3][3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 4'b0;\n            kcnt <= 4'b10;\n            ld_r <= 1'b0;\n            text_in_r <= 128'b0;\n            text_out_r <= 128'b0;\n        end\n        else if (kld) begin\n            kcnt <= 4'b10;\n            ld_r <= 1'b0;\n        end\n        else if (ld) begin\n            ld_r <= 1'b1;\n            text_in_r <= text_in;\n        end\n        else if (ld_r) begin\n            ld_r <= 1'b0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n            dcnt <= 4'b1;\n            kcnt <= 4'b10;\n        end\n        else if (dcnt < 11) begin\n            if (dcnt == 1) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ kb[10];\n                    end\n                end\n            end\n            else begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ kb[10 - dcnt + 1];\n                    end\n                end\n            end\n            dcnt <= dcnt + 1;\n            kcnt <= kcnt - 1;\n        end\n        else begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out_r[8*i + j] <= sa[i][j];\n                end\n            end\n            done <= 1'b1;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            kb[10] <= 128'b0;\n        end\n        else if (kld) begin\n            kb[10] <= key;\n            for (int i = 9; i > 0; i--) begin\n                kb[i] <= kb[i + 1];\n            end\n        end\n        else if (kcnt > 0) begin\n            if (kcnt == 1) begin\n                kb[0] <= kb[1];\n            end\n            else begin\n                kb[0] <= kb[1] ^ aes_inv_sbox(kb[2]);\n            end\n            kcnt <= kcnt - 1;\n        end\n    end\n\n    assign text_out = text_out_r;\n\nendmodule\n\n// aes_inv_sbox.v\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] inv_sbox[255:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = aes_inv_sbox_calc(i);\n        end\n    end\n\n    function [7:0] aes_inv_sbox_calc(input [7:0] a);\n        case (a)\n            8'h00: aes_inv_sbox_calc = 8'h52;\n            8'h01: aes_inv_sbox_calc = 8'h6f;\n            8'h02: aes_inv_sbox_calc = 8'hc9;\n            8'h03: aes_inv_sbox_calc = 8'he0;\n            8'h04: aes_inv_sbox_calc = 8'xc6;\n            8'h05: aes_inv_sbox_calc = 8'x45;\n            8'h06: aes_inv_sbox_calc = 8'x5a;\n            8'h07: aes_inv_sbox_calc = 8'x5;\n            8'h08: aes_inv_sbox_calc = 8'x9c;\n            8'h09: aes_inv_sbox_calc = 8'x8;\n            8'h0a: aes_inv_sbox_calc = 8'x83;\n            8'h0b: aes_inv_sbox_calc = 8'x1;\n            8'h0c: aes_inv_sbox_calc = 8'x86;\n            8'h0d: aes_inv_sbox_calc = 8'xbe;\n            8'h0e: aes_inv_sbox_calc = 8'x3b;\n            8'h0f: aes_inv_sbox_calc = 8'x6d;\n            8'h10: aes_inv_sbox_calc = 8'x45;\n            8'h11: aes_inv_sbox_calc = 8'xfa;\n            8'h12: aes_inv_sbox_calc = 8'xc2;\n            8'h13: aes_inv_sbox_calc = 8'xdf;\n            8'h14: aes_inv_sbox_calc = 8'x3e;\n            8'h15: aes_inv_sbox_calc = 8'x78;\n            8'h16: aes_inv_sbox_calc = 8'x6b;\n            8'h17: aes_inv_sbox_calc = 8'x5a;\n            8'h18: aes_inv_sbox_calc = 8'xa;\n            8'h19: aes_inv_sbox_calc = 8'x2f;\n            8'h1a: aes_inv_sbox_calc = 8'x09;\n            8'h1b: aes_inv_sbox_calc = 8'x1f;\n            8'h1c: aes_inv_sbox_calc = 8'x87;\n            8'h1d: aes_inv_sbox_calc = 8'x34;\n            8'h1e: aes_inv_sbox_calc = 8'x8;\n            8'h1f: aes_inv_sbox_calc = 8'x4;\n            8'h20: aes_inv_sbox_calc = 8'x93;\n            8'h21: aes_inv_sbox_calc = 8'x9;\n            8'h22: aes_inv_sbox_calc = 8'x1d;\n            8'h23: aes_inv_sbox_calc = 8'x17;\n            8'h24: aes_inv_sbox_calc = 8'x38;\n            8'h25: aes_inv_sbox_calc = 8'x5;\n            8'h26: aes_inv_sbox_calc = 8'x18;\n            8'h27: aes_inv_sbox_calc = 8'x89;\n            8'h28: aes_inv_sbox_calc = 8'x4;\n            8'h29: aes_inv_sbox_calc = 8'x79;\n            8'h2a: aes_inv_sbox_calc = 8'x6e;\n            8'h2b: aes_inv_sbox_calc = 8'x33;\n            8'h2c: aes_inv_sbox_calc = 8'x66;\n            8'h2d: aes_inv_sbox_calc = 8'x3;\n            8'h2e: aes_inv_sbox_calc = 8'x46;\n            8'h2f: aes_inv_sbox_calc = 8'x56;\n            8'h30: aes_inv_sbox_calc = 8'x34;\n            8'h31: aes_inv_sbox_calc = 8'xc;\n            8'h32: aes_inv_sbox_calc = 8'x5;\n            8'h33: aes_inv_sbox_calc = 8'x1;\n            8'h34: aes_inv_sbox_calc = 8'x74;\n            8'h35: aes_inv_sbox_calc = 8'x4b;\n            8'h36: aes_inv_sbox_calc = 8'xbd;\n            8'h37: aes_inv_sbox_calc = 8'x3;\n            8'h38: aes_inv_sbox_calc = 8'x2;\n            8'h39: aes_inv_sbox_calc = 8'xff;\n            8'h3a: aes_inv_sbox_calc = 8'xf;\n            8'h3b: aes_inv_sbox_calc = 8'x6;\n            8'h3c: aes_inv_sbox_calc = 8'xee;\n            8'h3d: aes_inv_sbox_calc = 8'x79;\n            8'h3e: aes_inv_sbox_calc = 8'x20;\n            8'h3f: aes_inv_sbox_calc = 8'x69;\n            8'h40: aes_inv_sbox_calc = 8'x32;\n            8'h41: aes_inv_sbox_calc = 8'xac;\n            8'h42: aes_inv_sbox_calc = 8'x62;\n            8'h43: aes_inv_sbox_calc = 8'x91;\n            8'h44: aes_inv_sbox_calc = 8'x42;\n            8'h45: aes_inv_sbox_calc = 8'xfa;\n            8'h46: aes_inv_sbox_calc = 8'c;\n            8'h47: aes_inv_sbox_calc = 8'x65;\n            8'h48: aes_inv_sbox_calc = 8'x19;\n            8'h49: aes_inv_sbox_calc = 8'x12;\n            8'h4a: aes_inv_sbox_calc = 8'xda;\n            8'h4b: aes_inv_sbox_calc = 8'x94;\n            8'h4c: aes_inv_sbox_calc = 8'x9;\n            8'h4d: aes_inv_sbox_calc = 8'x9d;\n            8'h4e: aes_inv_sbox_calc = 8'x2f;\n            8'h4f: aes_inv_sbox_calc = 8'x8f;\n            8'h50: aes_inv_sbox_calc = 8'x4c;\n            8'h51: aes_inv_sbox_calc = 8'xa4;\n            8'h52: aes_inv_sbox_calc = 8'x55;\n            8'h53: aes_inv_sbox_calc = 8'x21;\n            8'h54: aes_inv_sbox_calc = 8'x60;\n            8'h55: aes_inv_sbox_calc = 8'x1c;\n            8'h56: aes_inv_sbox_calc = 8'x81;\n            8'h57: aes_inv_sbox_calc = 8'x4f;\n            8'h58: aes_inv_sbox_calc = 8'xd;\n            8'h59: aes_inv_sbox_calc = 8'x2;\n            8'h5a: aes_inv_sbox_calc = 8'x66;\n            8'h5b: aes_inv_sbox_calc = 8'x5;\n            8'h5c: aes_inv_sbox_calc = 8'x48;\n            8'h5d: aes_inv_sbox_calc = 8'x29;\n            8'h5e: aes_inv_sbox_calc = 8'x9;\n            8'h5f: aes_inv_sbox_calc = 8'xdb;\n            8'h60: aes_inv_sbox_calc = 8'x16;\n            8'h61: aes_inv_sbox_calc = 8'x3;\n            8'h62: aes_inv_sbox_calc = 8'xba;\n            8'h63: aes_inv_sbox_calc = 8'x78;\n            default: aes_inv_sbox_calc = 8'h00;\n        endcase\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule\n\n// aes_key_expand_128.v\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_r;\n    reg [31:0] wo_0_r, wo_1_r, wo_2_r, wo_3_r;\n    reg [3:0] kcnt;\n    reg [7:0] rcon;\n    reg [7:0] sbox[255:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = aes_sbox_calc(i);\n        end\n    end\n\n    function [7:0] aes_sbox_calc(input [7:0] a);\n        case (a)\n            8'h00: aes_sbox_calc = 8'h52;\n            8'h01: aes_sbox_calc = 8'h09;\n            8'h02: aes_sbox_calc = 8'h6f;\n            8'h03: aes_sbox_calc = 8'h9b;\n            8'h04: aes_sbox_calc = 8'hc6;\n            8'h05: aes_sbox_calc = 8'hf7;\n            8'h06: aes_sbox_calc = 8'xe5;\n            8'h07: aes_sbox_calc = 8'x4f;\n            8'h08: aes_sbox_calc = 8'x8d;\n            8'h09: aes_sbox_calc = 8'x3b;\n            8'h0a: aes_sbox_calc = 8'x2f;\n            8'h0b: aes_sbox_calc = 8'x6d;\n            8'h0c: aes_sbox_calc = 8'xda;\n            8'h0d: aes_sbox_calc = 8'x30;\n            8'h0e: aes_sbox_calc = 8'x5a;\n            8'h0f: aes_sbox_calc = 8'x0;\n            8'h10: aes_sbox_calc = 8'x5;\n            8'h11: aes_sbox_calc = 8'x4;\n            8'h12: aes_sbox_calc = 8'x9;\n            8'h13: aes_sbox_calc = 8'x2;\n            8'h14: aes_sbox_calc = 8'x3;\n            8'h15: aes_sbox_calc = 8'x1;\n            8'h16: aes_sbox_calc = 8'x0;\n            8'h17: aes_sbox_calc = 8'x3;\n            8'h18: aes_sbox_calc = 8'x9;\n            8'h19: aes_sbox_calc = 8'x2;\n            8'h1a: aes_sbox_calc = 8'x1;\n            8'h1b: aes_sbox_calc = 8'x4;\n            8'h1c: aes_sbox_calc = 8'x5;\n            8'h1d: aes_sbox_calc = 8'x0;\n            8'h1e: aes_sbox_calc = 8'x6;\n            8'h1f: aes_sbox_calc = 8'x2;\n            8'h20: aes_sbox_calc = 8'x9;\n            8'h21: aes_sbox_calc = 8'x3;\n            8'h22: aes_sbox_calc = 8'x1;\n            8'h23: aes_sbox_calc = 8'x4;\n            8'h24: aes_sbox_calc = 8'x5;\n            8'h25: aes_sbox_calc = 8'x0;\n            8'h26: aes_sbox_calc = 8'x6;\n            8'h27: aes_sbox_calc = 8'x2;\n            8'h28: aes_sbox_calc = 8'x9;\n            8'h29: aes_sbox_calc = 8'x3;\n            8'h2a: aes_sbox_calc = 8'x1;\n            8'h2b: aes_sbox_calc = 8'x4;\n            8'h2c: aes_sbox_calc = 8'x5;\n            8'h2d: aes_sbox_calc = 8'x0;\n            8'h2e: aes_sbox_calc = 8'x6;\n            8'h2f: aes_sbox_calc = 8'x2;\n            8'h30: aes_sbox_calc = 8'x9;\n            8'h31: aes_sbox_calc = 8'x3;\n            8'h32: aes_sbox_calc = 8'x1;\n            8'h33: aes_sbox_calc = 8'x4;\n            8'h34: aes_sbox_calc = 8'x5;\n            8'h35: aes_sbox_calc = 8'x0;\n            8'h36: aes_sbox_calc = 8'x6;\n            8'h37: aes_sbox_calc = 8'x2;\n            8'h38: aes_sbox_calc = 8'x9;\n            8'h39: aes_sbox_calc = 8'x3;\n            8'h3a: aes_sbox_calc = 8'x1;\n            8'h3b: aes_sbox_calc = 8'x4;\n            8'h3c: aes_sbox_calc = 8'x5;\n            8'h3d: aes_sbox_calc = 8'x0;\n            8'h3e: aes_sbox_calc = 8'x6;\n            8'h3f: aes_sbox_calc = 8'x2;\n            8'h40: aes_sbox_calc = 8'x9;\n            8'h41: aes_sbox_calc = 8'x3;\n            8'h42: aes_sbox_calc = 8'x1;\n            8'h43: aes_sbox_calc = 8'x4;\n            8'h44: aes_sbox_calc = 8'x5;\n            8'h45: aes_sbox_calc = 8'x0;\n            8'h46: aes_sbox_calc = 8'x6;\n            8'h47: aes_sbox_calc = 8'x2;\n            8'h48: aes_sbox_calc = 8'x9;\n            8'h49: aes_sbox_calc = 8'x3;\n            8'h4a: aes_sbox_calc = 8'x1;\n            8'h4b: aes_sbox_calc = 8'x4;\n            8'h4c: aes_sbox_calc = 8'x5;\n            8'h4d: aes_sbox_calc = 8'x0;\n            8'h4e: aes_sbox_calc = 8'x6;\n            8'h4f: aes_sbox_calc = 8'x2;\n            8'h50: aes_sbox_calc = 8'x9;\n            8'h51: aes_sbox_calc = 8'x3;\n            8'h52: aes_sbox_calc = 8'x1;\n            8'h53: aes_sbox_calc = 8'x4;\n            8'h54: aes_sbox_calc = 8'x5;\n            8'h55: aes_sbox_calc = 8'x0;\n            8'h56: aes_sbox_calc = 8'x6;\n            8'h57: aes_sbox_calc = 8'x2;\n            8'h58: aes_sbox_calc = 8'x9;\n            8'h59: aes_sbox_calc = 8'x3;\n            8'h5a: aes_sbox_calc = 8'x1;\n            8'h5b: aes_sbox_calc = 8'x4;\n            8'h5c: aes_sbox_calc = 8'x5;\n            8'h5d: aes_sbox_calc = 8'x0;\n            8'h5e: aes_sbox_calc = 8'x6;\n            8'h5f: aes_sbox_calc = 8'x2;\n            8'h60: aes_sbox_calc = 8'x9;\n            8'h61: aes_sbox_calc = 8'x3;\n            8'h62: aes_sbox_calc = 8'x1;\n            8'h63: aes_sbox_calc = 8'x4;\n            default: aes_sbox_calc = 8'h00;\n        endcase\n    end\n\n    assign wo_0 = wo_0_r;\n    assign wo_1 = wo_1_r;\n    assign wo_2 = wo_2_r;\n    assign wo_3 = wo_3_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            kcnt <= 4'b10;\n            rcon <= 8'h01;\n            wo_0_r <= 32'b0;\n            wo_1_r <= 32'b0;\n            wo_2_r <= 32'b0;\n            wo_3_r <= 32'b0;\n        end\n        else if (kld) begin\n            kcnt <= 4'b10;\n            rcon <= 8'h01;\n            wo_0_r <= key[31:0];\n            wo_1_r <= key[63:32];\n            wo_2_r <= key", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 17, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    assign done = (dcnt == 11) & (~ld_r);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 10;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n        end else if (kld) begin\n            kcnt <= 10;\n            kb[10] <= key[127:96];\n            kb[9] <= key[95:64];\n            kb[8] <= key[63:32];\n            kb[7] <= key[31:0];\n        end else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n            dcnt <= 1;\n        end else if (ld_r) begin\n            ld_r <= 0;\n            if (dcnt < 11) begin\n                dcnt <= dcnt + 1;\n            end\n        end else if (dcnt < 11) begin\n            if (dcnt == 0) begin\n                sa[0][0] <= text_in_r[7:0];\n                sa[0][1] <= text_in_r[15:8];\n                sa[0][2] <= text_in_r[23:16];\n                sa[0][3] <= text_in_r[31:24];\n                sa[1][0] <= text_in_r[39:32];\n                sa[1][1] <= text_in_r[47:40];\n                sa[1][2] <= text_in_r[55:48];\n                sa[1][3] <= text_in_r[63:56];\n                sa[2][0] <= text_in_r[71:64];\n                sa[2][1] <= text_in_r[79:72];\n                sa[2][2] <= text_in_r[87:80];\n                sa[2][3] <= text_in_r[95:88];\n                sa[3][0] <= text_in_r[103:96];\n                sa[3][1] <= text_in_r[111:104];\n                sa[3][2] <= text_in_r[119:112];\n                sa[3][3] <= text_in_r[127:120];\n            end else if (dcnt == 1) begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb[kcnt]);\n                InvMixColumns(sa);\n                kcnt <= kcnt - 1;\n            end else if (dcnt > 1) begin\n                InvShiftRows(sa);\n                InvSubBytes(sa);\n                AddRoundKey(sa, kb[kcnt]);\n                InvMixColumns(sa);\n                kcnt <= kcnt - 1;\n            end\n        end else begin\n            if (dcnt == 11) begin\n                text_out_r <= sa[0][0] ^ sa[1][0] ^ sa[2][0] ^ sa[3][0];\n                text_out_r <= {text_out_r[7:0], sa[0][1] ^ sa[1][1] ^ sa[2][1] ^ sa[3][1]};\n                text_out_r <= {text_out_r[15:8], sa[0][2] ^ sa[1][2] ^ sa[2][2] ^ sa[3][2]};\n                text_out_r <= {text_out_r[23:16], sa[0][3] ^ sa[1][3] ^ sa[2][3] ^ sa[3][3]};\n                text_out_r <= {text_out_r[31:24], sa[0][0] ^ sa[1][0] ^ sa[2][0] ^ sa[3][0]};\n                text_out_r <= {text_out_r[39:32], sa[0][1] ^ sa[1][1] ^ sa[2][1] ^ sa[3][1]};\n                text_out_r <= {text_out_r[47:40], sa[0][2] ^ sa[1][2] ^ sa[2][2] ^ sa[3][2]};\n                text_out_r <= {text_out_r[55:48], sa[0][3] ^ sa[1][3] ^ sa[2][3] ^ sa[3][3]};\n                text_out_r <= {text_out_r[63:56], sa[0][0] ^ sa[1][0] ^ sa[2][0] ^ sa[3][0]};\n                text_out_r <= {text_out_r[71:64], sa[0][1] ^ sa[1][1] ^ sa[2][1] ^ sa[3][1]};\n                text_out_r <= {text_out_r[79:72], sa[0][2] ^ sa[1][2] ^ sa[2][2] ^ sa[3][2]};\n                text_out_r <= {text_out_r[87:80], sa[0][3] ^ sa[1][3] ^ sa[2][3] ^ sa[3][3]};\n                text_out_r <= {text_out_r[95:88], sa[0][0] ^ sa[1][0] ^ sa[2][0] ^ sa[3][0]};\n                text_out_r <= {text_out_r[103:96], sa[0][1] ^ sa[1][1] ^ sa[2][1] ^ sa[3][1]};\n                text_out_r <= {text_out_r[111:104], sa[0][2] ^ sa[1][2] ^ sa[2][2] ^ sa[3][2]};\n                text_out_r <= {text_out_r[119:112], sa[0][3] ^ sa[1][3] ^ sa[2][3] ^ sa[3][3]};\n                text_out_r <= {text_out_r[127:120], sa[0][0] ^ sa[1][0] ^ sa[2][0] ^ sa[3][0]};\n            end\n        end\n    end\n\n    assign text_out = text_out_r;\n\n    // InvShiftRows\n    task InvShiftRows;\n        begin\n            for (int i = 1; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][(j + 3) % 4];\n                end\n            end\n        end\n    endtask\n\n    // InvSubBytes\n    task InvSubBytes;\n        begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= InvSBox(sa[i][j]);\n                end\n            end\n        end\n    endtask\n\n    // InvMixColumns\n    task InvMixColumns;\n        begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= InvMixCol(sa[i][j]);\n                end\n            end\n        end\n    endtask\n\n    // InvSBox\n    function [7:0] InvSBox;\n        input [7:0] a;\n        begin\n            case (a)\n                8'h00: InvSBox = 8'h52;\n                8'h01: InvSBox = 8'h06;\n                8'h02: InvSBox = 8'h52;\n                8'h03: InvSBox = 8'h09;\n                8'h04: InvSBox = 8'h49;\n                8'h05: InvSBox = 8'h24;\n                8'h06: InvSBox = 8'h50;\n                8'h07: InvSBox = 8'h30;\n                8'h08: InvSBox = 8'h0C;\n                8'h09: InvSBox = 8'h61;\n                8'h0A: InvSBox = 8'h25;\n                8'h0B: InvSBox = 8'h32;\n                8'h0C: InvSBox = 8'h0A;\n                8'h0D: InvSBox = 8'h01;\n                8'h0E: InvSBox = 8'h29;\n                8'h0F: InvSBox = 8'h23;\n                8'h10: InvSBox = 8'h0B;\n                8'h11: InvSBox = 8'h0D;\n                8'h12: InvSBox = 8'h0E;\n                8'h13: InvSBox = 8'h0F;\n                8'h14: InvSBox = 8'h36;\n                8'h15: InvSBox = 8'h0C;\n                8'h16: InvSBox = 8'h33;\n                8'h17: InvSBox = 8'h42;\n                8'h18: InvSBox = 8'h35;\n                8'h19: InvSBox = 8'h31;\n                8'h1A: InvSBox = 8'h26;\n                8'h1B: InvSBox = 8'h22;\n                8'h1C: InvSBox = 8'h37;\n                8'h1D: InvSBox = 8'h2A;\n                8'h1E: InvSBox = 8'h2E;\n                8'h1F: InvSBox = 8'h38;\n                8'h20: InvSBox = 8'h19;\n                8'h21: InvSBox = 8'h34;\n                8'h22: InvSBox = 8'h30;\n                8'h23: InvSBox = 8'h0F;\n                8'h24: InvSBox = 8'h37;\n                8'h25: InvSBox = 8'h2D;\n                8'h26: InvSBox = 8'h2E;\n                8'h27: InvSBox = 8'h2B;\n                8'h28: InvSBox = 8'h39;\n                8'h29: InvSBox = 8'h3A;\n                8'h2A: InvSBox = 8'h20;\n                8'h2B: InvSBox = 8'h3D;\n                8'h2C: InvSBox = 8'h3C;\n                8'h2D: InvSBox = 8'h3F;\n                8'h2E: InvSBox = 8'h33;\n                8'h2F: InvSBox = 8'h25;\n                8'h30: InvSBox = 8'h31;\n                8'h31: InvSBox = 8'h26;\n                8'h32: InvSBox = 8'h38;\n                8'h33: InvSBox = 8'h24;\n                8'h34: InvSBox = 8'h36;\n                8'h35: InvSBox = 8'h22;\n                8'h36: InvSBox = 8'h23;\n                8'h37: InvSBox = 8'h43;\n                8'h38: InvSBox = 8'h3C;\n                8'h39: InvSBox = 8'h30;\n                8'h3A: InvSBox = 8'h3B;\n                8'h3B: InvSBox = 8'h2F;\n                8'h3C: InvSBox = 8'h21;\n                8'h3D: InvSBox = 8'h2C;\n                8'h3E: InvSBox = 8'h41;\n                8'h3F: InvSBox = 8'h45;\n                default: InvSBox = 8'h00;\n            endcase\n        end\n    endfunction\n\n    // InvMixCol\n    function [7:0] InvMixCol;\n        input [7:0] a;\n        begin\n            case (a)\n                8'h00: InvMixCol = 8'h07;\n                8'h01: InvMixCol = 8'h0E;\n                8'h02: InvMixCol = 8'h0C;\n                8'h03: InvMixCol = 8'h13;\n                8'h04: InvMixCol = 8'h12;\n                8'h05: InvMixCol = 8'h11;\n                8'h06: InvMixCol = 8'h31;\n                8'h07: InvMixCol = 8'h22;\n                8'h08: InvMixCol = 8'h2A;\n                8'h09: InvMixCol = 8'h29;\n                8'h0A: InvMixCol = 8'h21;\n                8'h0B: InvMixCol = 8'h06;\n                8'h0C: InvMixCol = 8'h19;\n                8'h0D: InvMixCol = 8'h1B;\n                8'h0E: InvMixCol = 8'h75;\n                8'h0F: InvMixCol = 8'h17;\n                8'h10: InvMixCol = 8'h18;\n                8'h11: InvMixCol = 8'h1E;\n                8'h12: InvMixCol = 8'h16;\n                8'h13: InvMixCol = 8'h08;\n                8'h14: InvMixCol = 8'h03;\n                8'h15: InvMixCol = 8'h09;\n                8'h16: InvMixCol = 8'h1C;\n                8'h17: InvMixCol = 8'h9F;\n                8'h18: InvMixCol = 8'h0B;\n                8'h19: InvMixCol = 8'h93;\n                8'h1A: InvMixCol = 8'h0D;\n                8'h1B: InvMixCol = 8'h0A;\n                8'h1C: InvMixCol = 8'h01;\n                8'h1D: InvMixCol = 8'h06;\n                8'h1E: InvMixCol = 8'h1F;\n                8'h1F: InvMixCol = 8'h5A;\n                default: InvMixCol = 8'h00;\n            endcase\n        end\n    endfunction\n\n    // AddRoundKey\n    task AddRoundKey;\n        input [7:0] sa[0:3][0:3];\n        input [7:0] kb[0:3];\n        begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ kb[j];\n                end\n            end\n        end\n    endtask\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 18, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    // Submodules\n    aes_key_expand_128 aes_key_expand_128_module(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox aes_inv_sbox_module[0:15] (\n        .a(sa[0][0]),\n        .b(us00)\n    );\n    aes_inv_sbox aes_inv_sbox_module[16:31] (\n        .a(sa[0][1]),\n        .b(us01)\n    );\n    aes_inv_sbox aes_inv_sbox_module[32:47] (\n        .a(sa[0][2]),\n        .b(us02)\n    );\n    aes_inv_sbox aes_inv_sbox_module[48:63] (\n        .a(sa[0][3]),\n        .b(us03)\n    );\n    aes_inv_sbox aes_inv_sbox_module[64:79] (\n        .a(sa[1][0]),\n        .b(us10)\n    );\n    aes_inv_sbox aes_inv_sbox_module[80:95] (\n        .a(sa[1][1]),\n        .b(us11)\n    );\n    aes_inv_sbox aes_inv_sbox_module[96:111] (\n        .a(sa[1][2]),\n        .b(us12)\n    );\n    aes_inv_sbox aes_inv_sbox_module[112:127] (\n        .a(sa[1][3]),\n        .b(us13)\n    );\n    aes_inv_sbox aes_inv_sbox_module[128:143] (\n        .a(sa[2][0]),\n        .b(us20)\n    );\n    aes_inv_sbox aes_inv_sbox_module[144:159] (\n        .a(sa[2][1]),\n        .b(us21)\n    );\n    aes_inv_sbox aes_inv_sbox_module[160:175] (\n        .a(sa[2][2]),\n        .b(us22)\n    );\n    aes_inv_sbox aes_inv_sbox_module[176:191] (\n        .a(sa[2][3]),\n        .b(us23)\n    );\n    aes_inv_sbox aes_inv_sbox_module[192:207] (\n        .a(sa[3][0]),\n        .b(us30)\n    );\n    aes_inv_sbox aes_inv_sbox_module[208:223] (\n        .a(sa[3][1]),\n        .b(us31)\n    );\n    aes_inv_sbox aes_inv_sbox_module[224:239] (\n        .a(sa[3][2]),\n        .b(us32)\n    );\n    aes_inv_sbox aes_inv_sbox_module[240:255] (\n        .a(sa[3][3]),\n        .b(us33)\n    );\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 0xA;\n            ld_r <= 0;\n            text_in_r <= 0;\n            text_out_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end\n        else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[7 + i * 4 + j];\n                end\n            end\n        end\n        else if (kld) begin\n            kcnt <= 0xA;\n            kb[10] <= wk3;\n            kb[9] <= wk2;\n            kb[8] <= wk1;\n            kb[7] <= wk0;\n            for (int i = 6; i > 0; i--) begin\n                kb[i] <= kb[i + 1];\n            end\n        end\n        else if (dcnt < 11) begin\n            ld_r <= 0;\n            if (dcnt == 0) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= text_in_r[7 + i * 4 + j];\n                    end\n                end\n            end\n            if (dcnt > 0) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j] ^ kb[15 - dcnt + i * 4 + j];\n                    end\n                end\n            end\n            if (dcnt == 1) begin\n                InvShiftRows(sa);\n            end\n            if (dcnt > 1) begin\n                InvSubBytes(sa);\n                InvMixColumns(sa);\n            end\n            if (dcnt < 11) begin\n                dcnt <= dcnt + 1;\n            end\n        end\n        else begin\n            done <= 1;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out_r[7 + i * 4 + j] <= sa[i][j];\n                end\n            end\n        end\n    end\n\n    // InvShiftRows\n    task InvShiftRows(input reg [7:0] sa[0:3][0:3]);\n        for (int i = 1; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i][j + 1];\n            end\n            sa[i][3] <= sa[i][0];\n        end\n    endtask\n\n    // InvSubBytes\n    task InvSubBytes(input reg [7:0] sa[0:3][0:3]);\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= us00[i][j];\n            end\n        end\n    endtask\n\n    // InvMixColumns\n    task InvMixColumns(input reg [7:0] sa[0:3][0:3]);\n        reg [7:0] sa_next[0:3][0:3];\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa_next[i][j] <= sa[i][j];\n            end\n        end\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa_next[i][j] <= (sa_next[i][j] ^ (sa_next[0][j] << 1) ^ (sa_next[1][j] << 2) ^ (sa_next[2][j] << 3) ^ (sa_next[3][j] << 4));\n            end\n        end\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa_next[i][j];\n            end\n        end\n    endtask\n\n    // Output\n    assign text_out = text_out_r;\n\nendmodule\n// aes_key_expand_128 module\nmodule aes_key_expansion_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_expanded;\n    reg [3:0] kcnt;\n    reg [31:0] wk0, wk1, wk2, wk3;\n\n    // Submodules\n    aes_rcon aes_rcon_module(\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n    aes_sbox aes_sbox_module[0:3] (\n        .a(key_expanded[31:24]),\n        .b(wk0[31:24])\n    );\n    aes_sbox aes_sbox_module[4:7] (\n        .a(key_expanded[23:16]),\n        .b(wk0[23:16])\n    );\n    aes_sbox aes_sbox_module[8:11] (\n        .a(key_expanded[15:8]),\n        .b(wk0[15:8])\n    );\n    aes_sbox aes_sbox_module[12:15] (\n        .a(key_expanded[7:0]),\n        .b(wk0[7:0])\n    );\n    aes_sbox aes_sbox_module[16:19] (\n        .a(key_expanded[39:32]),\n        .b(wk1[31:24])\n    );\n    aes_sbox aes_sbox_module[20:23] (\n        .a(key_expanded[31:24]),\n        .b(wk1[23:16])\n    );\n    aes_sbox aes_sbox_module[24:27] (\n        .a(key_expanded[23:16]),\n        .b(wk1[15:8])\n    );\n    aes_sbox aes_sbox_module[28:31] (\n        .a(key_expanded[15:8]),\n        .b(wk1[7:0])\n    );\n    aes_sbox aes_sbox_module[32:35] (\n        .a(key_expanded[47:40]),\n        .b(wk2[31:24])\n    );\n    aes_sbox aes_sbox_module[36:39] (\n        .a(key_expanded[39:32]),\n        .b(wk2[23:16])\n    );\n    aes_sbox aes_sbox_module[40:43] (\n        .a(key_expanded[31:24]),\n        .b(wk2[15:8])\n    );\n    aes_sbox aes_sbox_module[44:47] (\n        .a(key_expanded[23:16]),\n        .b(wk2[7:0])\n    );\n    aes_sbox aes_sbox_module[48:51] (\n        .a(key_expanded[55:48]),\n        .b(wk3[31:24])\n    );\n    aes_sbox aes_sbox_module[52:55] (\n        .a(key_expanded[47:40]),\n        .b(wk3[23:16])\n    );\n    aes_sbox aes_sbox_module[56:59] (\n        .a(key_expanded[39:32]),\n        .b(wk3[15:8])\n    );\n    aes_sbox aes_sbox_module[60:63] (\n        .a(key_expanded[31:24]),\n        .b(wk3[7:0])\n    );\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (kld) begin\n            key_expanded <= key;\n            wk0 <= 0;\n            wk1 <= 0;\n            wk2 <= 0;\n            wk3 <= 0;\n            kcnt <= 10;\n        end\n        else if (kcnt > 0) begin\n            if (kcnt == 10) begin\n                wk0 <= rcon;\n                wk1 <= key_expanded[31:24];\n                wk2 <= key_expanded[39:32];\n                wk3 <= key_expanded[47:40];\n            end\n            else if (kcnt == 9) begin\n                wk0 <= wk0 ^ (wk1 << 1) ^ (wk2 << 2) ^ (wk3 << 3) ^ (rcon << 24);\n                wk1 <= wk1 ^ (wk2 << 1) ^ (wk3 << 2) ^ (rcon << 16);\n                wk2 <= wk2 ^ (wk3 << 1) ^ (rcon << 8);\n                wk3 <= wk3 ^ rcon;\n            end\n            else if (kcnt == 8) begin\n                wk0 <= wk0 ^ (wk1 << 1) ^ (wk2 << 2) ^ (wk3 << 3);\n                wk1 <= wk1 ^ (wk2 << 1) ^ (wk3 << 2);\n                wk2 <= wk2 ^ wk3;\n                wk3 <= wk3;\n            end\n            else if (kcnt == 7) begin\n                wk0 <= wk0 ^ (wk1 << 1) ^ (wk2 << 2) ^ (wk3 << 3);\n                wk1 <= wk1 ^ (wk2 << 1) ^ (wk3 << 2);\n                wk2 <= wk2 ^ wk3;\n                wk3 <= wk3;\n            end\n            else if (kcnt == 6) begin\n                wk0 <= wk0 ^ (wk1 << 1) ^ (wk2 << 2) ^ (wk3 << 3);\n                wk1 <= wk1 ^ (wk2 << 1) ^ (wk3 << 2);\n                wk2 <= wk2 ^ wk3;\n                wk3 <= wk3;\n            end\n            else if (kcnt == 5) begin\n                wk0 <= wk0 ^ (wk1 << 1) ^ (wk2 << 2) ^ (wk3 << 3);\n                wk1 <= wk1 ^ (wk2 << 1) ^ (wk3 << 2);\n                wk2 <= wk2 ^ wk3;\n                wk3 <= wk3;\n            end\n            else if (kcnt == 4) begin\n                wk0 <= wk0 ^ (wk1 << 1) ^ (wk2 << 2) ^ (wk3 << 3);\n                wk1 <= wk1 ^ (wk2 << 1) ^ (wk3 << 2);\n                wk2 <= wk2 ^ wk3;\n                wk3 <= wk3;\n            end\n            else if (kcnt == 3) begin\n                wk0 <= wk0 ^ (wk1 << 1) ^ (wk2 << 2) ^ (wk3 << 3);\n                wk1 <= wk1 ^ (wk2 << 1) ^ (wk3 << 2);\n                wk2 <= wk2 ^ wk3;\n                wk3 <= wk3;\n            end\n            else if (kcnt == 2) begin\n                wk0 <= wk0 ^ (wk1 << 1) ^ (wk2 << 2) ^ (wk3 << 3);\n                wk1 <= wk1 ^ (wk2 << 1) ^ (wk3 << 2);\n                wk2 <= wk2 ^ wk3;\n                wk3 <= wk3;\n            end\n            else if (kcnt == 1) begin\n                wk0 <= wk0 ^ (wk1 << 1) ^ (wk2 << 2) ^ (wk3 << 3);\n                wk1 <= wk1 ^ (wk2 << 1) ^ (wk3 << 2);\n                wk2 <= wk2 ^ wk3;\n                wk3 <= wk3;\n            end\n            else begin\n                wk0 <= wk0 ^ (wk1 << 1) ^ (wk2 << 2) ^ (wk3 << 3);\n                wk1 <= wk1 ^ (wk2 << 1) ^ (wk3 << 2);\n                wk2 <= wk2 ^ wk3;\n                wk3 <= wk3;\n            end\n            kcnt <= kcnt - 1;\n        end\n        else begin\n            wo_0 <= wk0;\n            wo_1 <= wk1;\n            wo_2 <= wk2;\n            wo_3 <= wk3;\n        end\n    end\n\nendmodule\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    // State Transition Diagram\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end\n        else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            case (rcnt)\n                1: out <= 32'h02_00_00_00;\n                2: out <= 32'h04_00_00_00;\n                3: out <= 32'h08_00_00_00;\n                4: out <= 32'h10_00_00_00;\n                5: out <= 32'h20_00_00_00;\n                6: out <= 32'h40_00_00_00;\n                7: out <= 32'h80_00_00_00;\n                8: out <= 32'h1b_00_00_00;\n                9: out <= 32'h36_00_00_00;\n                default: out <= 32'h00_00_00_00;\n            endcase\n        end\n        else begin\n            out <= 32'h00_00_00_00;\n        end\n    end\n\nendmodule\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // ROM structure uses 256 x 8-bit mapping table\n    reg [7:0] sbox[0:255];\n\n    // ROM initialization\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] = i;\n        end\n    end\n\n    // ROM output\n    assign b = sbox[a];\n\nendmodule\n// aes_inv_sbox module\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // ROM structure uses 256 x 8-bit mapping table\n    reg [7:0] inv_sbox[0:255];\n\n    // ROM initialization\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = i;\n        end\n    end\n\n    // ROM output\n    assign b = inv_sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 19, "code": "// aes_inv_cipher_top.v\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [3:0] dcnt;\n    reg [3:0] kcnt;\n    reg [127:0] kb[10:0];\n    reg ld_r;\n    reg [127:0] sa[0:3][0:3];\n    reg [127:0] sa_ark;\n\n    // State Transition Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 10;\n            ld_r <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end\n        else if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n            dcnt <= 1;\n            kcnt <= 10;\n        end\n        else if (kld) begin\n            kcnt <= 10;\n            ld_r <= 0;\n        end\n        else if (dcnt < 11) begin\n            ld_r <= 0;\n            if (dcnt == 1) begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= text_in_r[8*i + j];\n                    end\n                end\n            end\n            InvShiftRows(sa);\n            InvSubBytes(sa);\n            AddRoundKey(sa, kb);\n            InvMixColumns(sa);\n            if (dcnt == 10) begin\n                AddRoundKey(sa, kb);\n            end\n            dcnt <= dcnt + 1;\n        end\n        else begin\n            ld_r <= 0;\n            done <= 1;\n        end\n    end\n\n    // Key Expansion Module\n    aes_key_expand_128 aes_key_expand_128(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    // Key Buffer\n    always @(posedge clk) begin\n        if (kld) begin\n            kb[10] <= wk0;\n            kb[9] <= wk1;\n            kb[8] <= wk2;\n            kb[7] <= wk3;\n            for (int i = 6; i > 0; i--) begin\n                kb[i] <= kb[i+1];\n            end\n        end\n        else if (kcnt > 0) begin\n            kcnt <= kcnt - 1;\n        end\n    end\n\n    // Round Key Selection\n    always @(posedge clk) begin\n        if (ld_r) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ kb[10 - dcnt + i][8*j + j];\n                end\n            end\n        end\n    end\n\n    // Output Generation\n    always @(posedge clk) begin\n        if (ld_r) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out[8*i + j] <= sa[i][j];\n                end\n            end\n        end\n    end\n\n    // InvShiftRows\n    task InvShiftRows(ref reg [3:0][3:0] sa);\n        for (int i = 1; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i][j+1];\n            end\n            sa[i][3] <= sa[i][0];\n        end\n    endtask\n\n    // InvSubBytes\n    task InvSubBytes(ref reg [3:0][3:0] sa);\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= aes_inv_sbox(sa[i][j]);\n            end\n        end\n    endtask\n\n    // AddRoundKey\n    task AddRoundKey(ref reg [3:0][3:0] sa, reg [127:0] kb);\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i][j] ^ kb[8*i + j];\n            end\n        end\n    endtask\n\n    // InvMixColumns\n    task InvMixColumns(ref reg [3:0][3:0] sa);\n        reg [3:0][3:0] sa_next;\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa_next[i][j] <= sa[i][j];\n            end\n        end\n        sa_next[0][0] <= (sa[0][0] ^ sa[1][1] ^ sa[2][2] ^ sa[3][3]);\n        sa_next[0][1] <= (sa[0][1] ^ sa[1][0] ^ sa[2][3] ^ sa[3][2]);\n        sa_next[0][2] <= (sa[0][2] ^ sa[1][3] ^ sa[2][0] ^ sa[3][1]);\n        sa_next[0][3] <= (sa[0][3] ^ sa[1][2] ^ sa[2][1] ^ sa[3][0]);\n        sa_next[1][0] <= (sa[1][0] ^ sa[2][1] ^ sa[3][2] ^ sa[0][3]);\n        sa_next[1][1] <= (sa[1][1] ^ sa[2][0] ^ sa[3][3] ^ sa[0][2]);\n        sa_next[1][2] <= (sa[1][2] ^ sa[2][3] ^ sa[3][0] ^ sa[0][1]);\n        sa_next[1][3] <= (sa[1][3] ^ sa[2][2] ^ sa[3][1] ^ sa[0][0]);\n        sa_next[2][0] <= (sa[2][0] ^ sa[3][1] ^ sa[0][2] ^ sa[1][3]);\n        sa_next[2][1] <= (sa[2][1] ^ sa[3][0] ^ sa[0][3] ^ sa[1][2]);\n        sa_next[2][2] <= (sa[2][2] ^ sa[3][3] ^ sa[0][1] ^ sa[1][0]);\n        sa_next[2][3] <= (sa[2][3] ^ sa[3][2] ^ sa[0][0] ^ sa[1][1]);\n        sa_next[3][0] <= (sa[3][0] ^ sa[0][1] ^ sa[1][2] ^ sa[2][3]);\n        sa_next[3][1] <= (sa[3][1] ^ sa[0][2] ^ sa[1][3] ^ sa[2][0]);\n        sa_next[3][2] <= (sa[3][2] ^ sa[0][3] ^ sa[1][0] ^ sa[2][1]);\n        sa_next[3][3] <= (sa[3][3] ^ sa[0][0] ^ sa[1][1] ^ sa[2][2]);\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa_next[i][j];\n            end\n        end\n    endtask\n\nendmodule\n\n// aes_key_expand_128.v\nmodule aes_key_expansion_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_buffer;\n    reg [3:0] kcnt;\n    reg [31:0] wk0, wk1, wk2, wk3;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            key_buffer <= key;\n            kcnt <= 10;\n            wk0 <= key[31:0];\n            wk1 <= key[63:32];\n            wk2 <= key[95:64];\n            wk3 <= key[127:96];\n        end\n        else if (kcnt > 0) begin\n            kcnt <= kcnt - 1;\n            if (kcnt == 0) begin\n                wk0 <= wk3;\n                wk1 <= wk0 ^ (wk1 << 8) ^ 0x01;\n                wk2 <= wk1 ^ (wk2 << 8) ^ 0x02;\n                wk3 <= wk2 ^ (wk3 << 8) ^ 0x04;\n            end\n            else if (kcnt == 1) begin\n                wk0 <= wk3;\n                wk1 <= wk0 ^ (wk1 << 8) ^ 0x02;\n                wk2 <= wk1 ^ (wk2 << 8) ^ 0x04;\n                wk3 <= wk2 ^ (wk3 << 8) ^ 0x08;\n            end\n            else if (kcnt == 2) begin\n                wk0 <= wk3;\n                wk1 <= wk0 ^ (wk1 << 8) ^ 0x04;\n                wk2 <= wk1 ^ (wk2 << 8) ^ 0x08;\n                wk3 <= wk2 ^ (wk3 << 8) ^ 0x10;\n            end\n            else if (kcnt == 3) begin\n                wk0 <= wk3;\n                wk1 <= wk0 ^ (wk1 << 8) ^ 0x08;\n                wk2 <= wk1 ^ (wk2 << 8) ^ 0x10;\n                wk3 <= wk2 ^ (wk3 << 8) ^ 0x20;\n            end\n            else if (kcnt == 4) begin\n                wk0 <= wk3;\n                wk1 <= wk0 ^ (wk1 << 8) ^ 0x10;\n                wk2 <= wk1 ^ (wk2 << 8) ^ 0x20;\n                wk3 <= wk2 ^ (wk3 << 8) ^ 0x40;\n            end\n            else if (kcnt == 5) begin\n                wk0 <= wk3;\n                wk1 <= wk0 ^ (wk1 << 8) ^ 0x20;\n                wk2 <= wk1 ^ (wk2 << 8) ^ 0x40;\n                wk3 <= wk2 ^ (wk3 << 8) ^ 0x80;\n            end\n            else if (kcnt == 6) begin\n                wk0 <= wk3;\n                wk1 <= wk0 ^ (wk1 << 8) ^ 0x40;\n                wk2 <= wk1 ^ (wk2 << 8) ^ 0x80;\n                wk3 <= wk2 ^ (wk3 << 8) ^ 0x1B;\n            end\n            else if (kcnt == 7) begin\n                wk0 <= wk3;\n                wk1 <= wk0 ^ (wk1 << 8) ^ 0x80;\n                wk2 <= wk1 ^ (wk2 << 8) ^ 0x1B;\n                wk3 <= wk2 ^ (wk3 << 8) ^ 0x36;\n            end\n            else if (kcnt == 8) begin\n                wk0 <= wk3;\n                wk1 <= wk0 ^ (wk1 << 8) ^ 0x1B;\n                wk2 <= wk1 ^ (wk2 << 8) ^ 0x36;\n                wk3 <= wk2 ^ (wk3 << 8) ^ 0x6;\n            end\n            else if (kcnt == 9) begin\n                wk0 <= wk3;\n                wk1 <= wk0 ^ (wk1 << 8) ^ 0x36;\n                wk2 <= wk1 ^ (wk2 << 8) ^ 0x6;\n                wk3 <= wk2 ^ (wk3 << 8) ^ 0x4;\n            end\n            else if (kcnt == 10) begin\n                wk0 <= wk3;\n                wk1 <= wk0 ^ (wk1 << 8) ^ 0x6;\n                wk2 <= wk1 ^ (wk2 << 8) ^ 0x4;\n                wk3 <= wk2 ^ (wk3 << 8) ^ 0x5;\n            end\n        end\n        wo_0 <= wk0;\n        wo_1 <= wk1;\n        wo_2 <= wk2;\n        wo_3 <= wk3;\n    end\n\nendmodule\n\n// aes_inv_sbox.v\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] inv_sbox[255:0];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            inv_sbox[i] = aes_inv_sbox_calc(i);\n        end\n    end\n\n    function [7:0] aes_inv_sbox_calc(input [7:0] a);\n        case (a)\n            0x00: aes_inv_sbox_calc = 0x52;\n            0x01: aes_inv_sbox_calc = 0x09;\n            0x02: aes_inv_sbox_calc = 0x6F;\n            0x03: aes_inv_sbox_calc = 0x25;\n            0x04: aes_inv_sbox_calc = 0x0B;\n            0x05: aes_inv_sbox_calc = 0x08;\n            0x06: aes_inv_sbox_calc = 0x18;\n            0x07: aes_inv_sbox_calc = 0x39;\n            0x08: aes_inv_sbox_calc = 0x4D;\n            0x09: aes_inv_sbox_calc = 0x22;\n            0x0A: aes_inv_sbox_calc = 0x29;\n            0x0B: aes_inv_sbox_calc = 0x0A;\n            0x0C: aes_inv_sbox_calc = 0x51;\n            0x0D: aes_inv_sbox_calc = 0x2F;\n            0x0E: aes_inv_sbox_calc = 0x7D;\n            0x0F: aes_inv_sbox_calc = 0x3B;\n            0x10: aes_inv_sbox_calc = 0x6A;\n            0x11: aes_inv_sbox_calc = 0x5A;\n            0x12: aes_inv_sbox_calc = 0x0C;\n            0x13: aes_inv_sbox_calc = 0x78;\n            0x14: aes_inv_sbox_calc = 0x4E;\n            0x15: aes_inv_sbox_calc = 0x58;\n            0x16: aes_inv_sbox_calc = 0x31;\n            0x17: aes_inv_sbox_calc = 0x01;\n            0x18: aes_inv_sbox_calc = 0x67;\n            0x19: aes_inv_sbox_calc = 0x3C;\n            0x1A: aes_inv_sbox_calc = 0x07;\n            0x1B: aes_inv_sbox_calc = 0x31;\n            0x1C: aes_inv_sbox_calc = 0x30;\n            0x1D: aes_inv_sbox_calc = 0x73;\n            0x1E: aes_inv_sbox_calc = 0x2D;\n            0x1F: aes_inv_sbox_calc = 0x0B;\n            0x20: aes_inv_sbox_calc = 0x0C;\n            0x21: aes_inv_sbox_calc = 0x38;\n            0x22: aes_inv_sbox_calc = 0x4A;\n            0x23: aes_inv_sbox_calc = 0x4E;\n            0x24: aes_inv_sbox_calc = 0x5B;\n            0x25: aes_inv_sbox_calc = 0x79;\n            0x26: aes_inv_sbox_calc = 0x6E;\n            0x27: aes_inv_sbox_calc = 0x33;\n            0x28: aes_inv_sbox_calc = 0x66;\n            0x29: aes_inv_sbox_calc = 0x3C;\n            0x2A: aes_inv_sbox_calc = 0x46;\n            0x2B: aes_inv_sbox_calc = 0x47;\n            0x2C: aes_inv_sbox_calc = 0x18;\n            0x2D: aes_inv_sbox_calc = 0x40;\n            0x2E: aes_inv_sbox_calc = 0x92;\n            0x2F: aes_inv_sbox_calc = 0x6C;\n            0x30: aes_inv_sbox_calc = 0x4F;\n            0x31: aes_inv_sbox_calc = 0x5F;\n            0x32: aes_inv_sbox_calc = 0x6D;\n            0x33: aes_inv_sbox_calc = 0x33;\n            0x34: aes_inv_sbox_calc = 0x5A;\n            0x35: aes_inv_sbox_calc = 0x51;\n            0x36: aes_inv_sbox_calc = 0x3A;\n            0x37: aes_inv_sbox_calc = 0x49;\n            0x38: aes_inv_sbox_calc = 0x06;\n            0x39: aes_inv_sbox_calc = 0x24;\n            0x3A: aes_inv_sbox_calc = 0x5C;\n            0x3B: aes_inv_sbox_calc = 0x52;\n            0x3C: aes_inv_sbox_calc = 0x35;\n            0x3D: aes_inv_sbox_calc = 0x4A;\n            0x3E: aes_inv_sbox_calc = 0x50;\n            0x3F: aes_inv_sbox_calc = 0x3B;\n            0x40: aes_inv_sbox_calc = 0x2F;\n            0x41: aes_inv_sbox_calc = 0x43;\n            0x42: aes_inv_sbox_calc = 0x1F;\n            0x43: aes_inv_sbox_calc = 0x5D;\n            0x44: aes_inv_sbox_calc = 0x0F;\n            0x45: aes_inv_sbox_calc = 0x61;\n            0x46: aes_inv_sbox_calc = 0x3A;\n            0x47: aes_inv_sbox_calc = 0x51;\n            0x48: aes_inv_sbox_calc = 0x4C;\n            0x49: aes_inv_sbox_calc = 0x39;\n            0x4A: aes_inv_sbox_calc = 0x4E;\n            0x4B: aes_inv_sbox_calc = 0x6F;\n            0x4C: aes_inv_sbox_calc = 0x5F;\n            0x4D: aes_inv_sbox_calc = 0x77;\n            0x4E: aes_inv_sbox_calc = 0x3D;\n            0x4F: aes_inv_sbox_calc = 0x34;\n            0x50: aes_inv_sbox_calc = 0x8E;\n            0x51: aes_inv_sbox_calc = 0x79;\n            0x52: aes_inv_sbox_calc = 0x24;\n            0x53: aes_inv_sbox_calc = 0x5B;\n            0x54: aes_inv_sbox_calc = 0x5A;\n            0x55: aes_inv_sbox_calc = 0x0B;\n            0x56: aes_inv_sbox_calc = 0x00;\n            0x57: aes_inv_sbox_calc = 0x8D;\n            0x58: aes_inv_sbox_calc = 0x0C;\n            0x59: aes_inv_sbox_calc = 0x72;\n            0x5A: aes_inv_sbox_calc = 0x18;\n            0x5B: aes_inv_sbox_calc = 0x6E;\n            0x5C: aes_inv_sbox_calc = 0x7B;\n            0x5D: aes_inv_sbox_calc = 0x2F;\n            0x5E: aes_inv_sbox_calc = 0x43;\n            0x5F: aes_inv_sbox_calc = 0x1F;\n            0x60: aes_inv_sbox_calc = 0x41;\n            0x61: aes_inv_sbox_calc = 0x5A;\n            0x62: aes_inv_sbox_calc = 0x3C;\n            0x63: aes_inv_sbox_calc = 0x31;\n            0x64: aes_inv_sbox_calc = 0x15;\n            0x65: aes_inv_sbox_calc = 0x04;\n            0x66: aes_inv_sbox_calc = 0x45;\n            0x67: aes_inv_sbox_calc = 0x35;\n            0x68: aes_inv_sbox_calc = 0x14;\n            0x69: aes_inv_sbox_calc = 0x0A;\n            0x6A: aes_inv_sbox_calc = 0x2A;\n            0x6B: aes_inv_sbox_calc = 0x1B;\n            0x6C: aes_inv_sbox_calc = 0x2D;\n            0x6D: aes_inv_sbox_calc = 0x2C;\n            0x6E: aes_inv_sbox_calc = 0x21;\n            0x6F: aes_inv_sbox_calc = 0x10;\n            0x70: aes_inv_sbox_calc = 0x49;\n            0x71: aes_inv_sbox_calc = 0x6E;\n            0x72: aes_inv_sbox_calc = 0x32;\n            0x73: aes_inv_sbox_calc = 0x3A;\n            0x74: aes_inv_sbox_calc = 0x41;\n            0x75: aes_inv_sbox_calc = 0x00;\n            0x76: aes_inv_sbox_calc = 0x1C;\n            0x77: aes_inv_sbox_calc = 0x5B;\n            0x78: aes_inv_sbox_calc = 0x36;\n            0x79: aes_inv_sbox_calc = 0x5A;\n            0x7A: aes_inv_sbox_calc = 0x51;\n            0x7B: aes_inv_sbox_calc = 0x38;\n            0x7C: aes_inv_sbox_calc = 0x4F;\n            0x7D: aes_inv_sbox_calc = 0x47;\n            0x7E: aes_inv_sbox_calc = 0x29;\n            0x7F: aes_inv_sbox_calc = 0x15;\n            0x80: aes_inv_sbox_calc = 0x06;\n            0x81: aes_inv_sbox_calc = 0x19;\n            0x82: aes_inv_sbox_calc = 0x1A;\n            0x83: aes_inv_sbox_calc = 0x07;\n            0x84: aes_inv_sbox_calc = 0x2A;\n            0x85: aes_inv_sbox_calc = 0x48;\n            0x86: aes_inv_sbox_calc = 0x04;\n            0x87: aes_inv_sbox_calc = 0x5C;\n            0x88: aes_inv_sbox_calc = 0x5E;\n            0x89: aes_inv_sbox_calc = 0x37;\n            0x8A: aes_inv_sbox_calc = 0x4C;\n            0x8B: aes_inv_sbox_calc = 0x95;\n            0x8C: aes_inv_sbox_calc = 0x35;\n            0x8D: aes_inv_sbox_calc = 0x41;\n            0x8E: aes_inv_sbox_calc = 0x45;\n            0x8F: aes_inv_sbox_calc = 0x4B;\n            0x90: aes_inv_sbox_calc = 0x15;\n            0x91: aes_inv_sbox_calc = 0x4E;\n            0x92: aes_inv_sbox_calc = 0x75;\n            0x93: aes_inv_sbox_calc = 0x3C;\n            0x94: aes_inv_sbox_calc = 0x09;\n            0x95: aes_inv_sbox_calc = 0x7F;\n            0x96: aes_inv_sbox_calc = 0x3D;\n            0x97: aes_inv_sbox_calc = 0x2E;\n            0x98: aes_inv_sbox_calc = 0x79;\n            0x99: aes_inv_sbox_calc = 0x5B;\n            0x9A: aes_inv_sbox_calc = 0x5A;\n            0x9B: aes_inv_sbox_calc = 0x0B;\n            0x9C: aes_inv_sbox_calc = 0x00;\n            0x9D: aes_inv_sbox_calc = 0x1C;\n            0x9E: aes_inv_sbox_calc = 0x82;\n            0x9F: aes_inv_sbox_calc = 0x7D;\n            0xA0: aes_inv_sbox_calc = 0x3A;\n            0xA1: aes_inv_sbox_calc = 0x1F;\n            0xA2: aes_inv_sbox_calc = 0x37;\n            0xA3: aes_inv_sbox_calc = 0x2D;\n            0xA4: aes_inv_sbox_calc = 0x8E;\n            0xA5: aes_inv_sbox_calc = 0x79;\n            0xA6: aes_inv_sbox_calc = 0x6E;\n            0xA7: aes_inv_sbox_calc = 0x33;\n            0xA8: aes_inv_sbox_calc = 0x3B;\n            0xA9: aes_inv_sbox_calc = 0x73;\n            0xAA: aes_inv_sbox_calc = 0x2A;\n            0xAB: aes_inv_sbox_calc = 0x9A;\n            0xAC: aes_inv_sbox_calc = 0x00;\n            0xAD: aes_inv_sbox_calc = 0x8D;\n            0xAE: aes_inv_sbox_calc = 0x32;\n            0xAF: aes_inv_sbox_calc = 0x5F;\n            0xB0: aes_inv_sbox_calc = 0x6F;\n            0xB1: aes_inv_sbox_calc = 0x51;\n            0xB2: aes_inv_sbox_calc = 0x0C;\n            0xB3: aes_inv_sbox_calc = 0x79;\n            0xB4: aes_inv_sbox_calc = 0x2E;\n            0xB5: aes_inv_sbox_calc = 0x7C;\n            0xB6: aes_inv_sbox_calc = 0x07;\n            0xB7: aes_inv_sbox_calc = 0x3D;\n            0xB8: aes_inv_sbox_calc = 0x4B;\n            0xB9: aes_inv_sbox_calc = 0x1B;\n            0xBA: aes_inv_sbox_calc = 0x2F;\n            0xBB: aes_inv_sbox_calc = 0x52;\n            0xBC: aes_inv_sbox_calc = 0x7A;\n            0xBD: aes_inv_sbox_calc = 0x5A;\n            0xBE: aes_inv_sbox_calc = 0x65;\n            0xBF: aes_inv_sbox_calc = 0x41;\n            0xC0: aes_inv_sbox_calc = 0x5E;\n            0xC1: aes_inv_sbox_calc = 0x31;\n            0xC2: aes_inv_sbox_calc = 0x15;\n            0xC3: aes_inv_sbox_calc = 0x04;\n            0xC4: aes_inv_sbox_calc = 0x45;\n            0xC5: aes_inv_sbox_calc = 0x4E;\n            0xC6: aes_inv_sbox_calc = 0x35;\n            0xC7: aes_inv_sbox_calc = 0x41;\n            0xC8: aes_inv_sbox_calc = 0x18;\n            0xC9: aes_inv_sbox_calc = 0x92;\n            0xCA: aes_inv_sbox_calc = 0x5C;\n            0xCB: aes_inv_sbox_calc = 0x19;\n            0xCC: aes_inv_sbox_calc = 0x9A;\n            0xCD: aes_inv_sbox_calc = 0x0B;\n            0xCE: aes_inv_sbox_calc = 0x1C;\n            0xCF: aes_inv_sbox_calc = 0x79;\n            0xD0: aes_inv_sbox_calc = 0x7D;\n            0xD1: aes_inv_sbox_calc = 0x59;\n            0xD2: aes_inv_sbox_calc = 0x2E;\n            0xD3: aes_inv_sbox_calc = 0x6E;\n            0xD4: aes_inv_sbox_calc = 0x2A;\n            0xD5: aes_inv_sbox_calc = 0x41;\n            0xD6: aes_inv_sbox_calc = 0x1F;\n            0xD7: aes_inv_sbox_calc = 0x41;\n            0xD8: aes_inv_sbox_calc = 0x3A;\n            0xD9: aes_inv_sbox_calc = 0x29;\n            0xDA: aes_inv_sbox_calc = 0x5B;\n            0xDB: aes_inv_sbox_calc = 0x5A;\n            0xDC: aes_inv_sbox_calc = 0x0B;\n            0xDD: aes_inv_sbox_calc = 0x00;\n            0xDE: aes_inv_sbox_calc = 0x1C;\n            0xDF: aes_inv_sbox_calc = 0x82;\n            0xE0: aes_inv_sbox_calc = 0x7F;\n            0xE1: aes_inv_sbox_calc = 0x3D;\n            0xE2: aes_inv_sbox_calc = 0x2E;\n            0xE3: aes_inv_sbox_calc = 0x79;\n            0xE4: aes_inv_sbox_calc = 0x5B;\n            0xE5: aes_inv_sbox_calc = 0x5A;\n            0xE6: aes_inv_sbox_calc = 0x0B;\n            0xE7: aes_inv_sbox_calc = 0x00;\n            0xE8: aes_inv_sbox_calc = 0x1C;\n            0xE9: aes_inv_sbox_calc = 0x82;\n            0xEA: aes_inv_sbox_calc = 0x7D;\n            0xEB: aes_inv_sbox_calc = 0x3A;\n            0xEC: aes_inv_sbox_calc = 0x29;\n            0xED: aes_inv_sbox_calc = 0x5B;\n            0xEE: aes_inv_sbox_calc = 0x5A;\n            0xEF: aes_inv_sbox_calc = 0x0B;\n            0xF0: aes_inv_sbox_calc = 0x00;\n            0xF1: aes_inv_sbox_calc = 0x1C;\n            0xF2: aes_inv_sbox_calc = 0x82;\n            0xF3: aes_inv_sbox_calc = 0x7D;\n            0xF4: aes_inv_sbox_calc = 0x3A;\n            0xF5: aes_inv_sbox_calc = 0x29;\n            0xF6: aes_inv_sbox_calc = 0x5B;\n            0xF7: aes_inv_sbox_calc = 0x5A;\n            0xF8: aes_inv_sbox_calc = 0x0B;\n            0xF9: aes_inv_sbox_calc = 0x00;\n            0xFA: aes_inv_sbox_calc = 0x1C;\n            0xFB: aes_inv_sbox_calc = 0x82;\n            0xFC: aes_inv_sbox_calc = 0x7D;\n            0xFD: aes_inv_sbox_calc = 0x3A;\n            0xFE: aes_inv_sbox_calc = 0x29;\n            0xFF: aes_inv_sbox_calc = 0x5B;\n        endcase\n    end\n\n    assign b = inv_sbox[a];\nendmodule\n\n// aes_rcon.v\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n    reg [31:0] rcon;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            rcon <= 32'h01_00_00_00;\n        end\n        else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            case (rcnt)\n                1: rcon <= 32'h02_00_00_00;\n                2: rcon <= 32'h04_00_00_00;\n                3: rcon <= 32'h08_00_00_00;\n                4: rcon <= 32'h10_00_00_00;\n                5: rcon <= 32'h20_00_00_00;\n                6: rcon <= 32'h40_00_00_00;\n                7: rcon <= 32'h80_00_00_00;\n                8: rcon <= 32'h1B_00_00_00;\n                9: rcon <= 32'h36_00_00_00;\n                10: rcon <= 32'h6_00_00_00;\n                default: rcon <= 32'h00_00_00_00;\n            endcase\n        end\n        out <= rcon;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 19, "code": "```verilog\n// aes_cipher_top.v\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0][0], sa[0][1], sa[0][2], sa[0][3],\n              sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n              sa[2][0], sa[2][1], sa[2][2], sa[2][3],\n              sa[3][0], sa[3][1], sa[3][2], sa[3][3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 4'b0000;\n            ld_r <= 1'b0;\n        end\n        else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1'b1;\n        end\n        else if (ld_r) begin\n            ld_r <= 1'b0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n            dcnt <= 4'b0000;\n        end\n        else begin\n            if (dcnt == 11) begin\n                done <= 1'b1;\n                text_out <= text_out_r;\n            end\n            else begin\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa[i][j];\n                    end\n                end\n                if (dcnt == 0) begin\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ key[8*i + j];\n                        end\n                    end\n                end\n                else begin\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= aes_sub_bytes(sa[i][j]);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= aes_shift_rows(sa[i][j]);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= aes_mix_columns(sa[i][j]);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ aes_add_round_key(sa[i][j]);\n                        end\n                    end\n                end\n                dcnt <= dcnt + 1;\n            end\n        end\n    end\n\n    assign text_out_r = {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                        sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                        sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                        sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n\nendmodule\n\n// aes_sub_bytes.v\nmodule aes_sub_bytes(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    always @(a) begin\n        case (a)\n            8'h00: b = 8'h63;\n            8'h01: b = 8'h7c;\n            8'h02: b = 8'h77;\n            8'h03: b = 8'e7;\n            8'h04: b = 8'bf;\n            8'h05: b = 8'c6;\n            8'h06: b = 8'9f;\n            8'h07: b = 8'e3;\n            8'h08: b = 8'42;\n            8'h09: b = 8'fa;\n            8'h0a: b = 8'c1;\n            8'h0b: b = 8'bf;\n            8'h0c: b = 8'a3;\n            8'h0d: b = 8'9d;\n            8'h0e: b = 8'19;\n            8'h0f: b = 8'1b;\n            8'h10: b = 8'9e;\n            8'h11: b = 8'ab;\n            8'h12: b = 8'8a;\n            8'h13: b = 8'9e;\n            8'h14: b = 8'bc;\n            8'h15: b = 8'97;\n            8'h16: b = 8'8e;\n            8'h17: b = 8'9b;\n            8'h18: b = 8'87;\n            8'h19: b = 8'94;\n            8'h1a: b = 8'9d;\n            8'h1b: b = 8'a5;\n            8'h1c: b = 8'ba;\n            8'h1d: b = 8'73;\n            8'h1e: b = 8'dc;\n            8'h1f: b = 8'9f;\n            8'h20: b = 8'85;\n            8'h21: b = 8'a5;\n            8'h22: b = 8'8e;\n            8'h23: b = 8'8f;\n            8'h24: b = 8'7c;\n            8'h25: b = 8'7b;\n            8'h26: b = 8'7e;\n            8'h27: b = 8'7f;\n            8'h28: b = 8'9f;\n            8'h29: b = 8'75;\n            8'h2a: b = 8'8a;\n            8'h2b: b = 8'9c;\n            8'h2c: b = 8'8e;\n            8'h2d: b = 8'8a;\n            8'h2e: b = 8'9e;\n            8'h2f: b = 8'8c;\n            8'h30: b = 8'9c;\n            8'h31: b = 8'82;\n            8'h32: b = 8'9b;\n            8'h33: b = 8'9a;\n            8'h34: b = 8'8a;\n            8'h35: b = 8'9e;\n            8'h36: b = 8'8d;\n            8'h37: b = 8'9c;\n            8'h38: b = 8'8f;\n            8'h39: b = 8'8d;\n            8'h3a: b = 8'9f;\n            8'h3b: b = 8'8b;\n            8'h3c: b = 8'8e;\n            8'h3d: b = 8'9a;\n            8'h3e: b = 8'9e;\n            8'h3f: b = 8'8c;\n            default: b = 8'h00;\n        endcase\n    end\n\nendmodule\n\n// aes_shift_rows.v\nmodule aes_shift_rows(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    always @(a) begin\n        case (a[3])\n            3'b000: b = a;\n            3'b001: b = {a[1], a[2], a[3], a[0]};\n            3'b010: b = {a[2], a[3], a[0], a[1]};\n            3'b011: b = {a[3], a[0], a[1], a[2]};\n            default: b = a;\n        endcase\n    end\n\nendmodule\n\n// aes_mix_columns.v\nmodule aes_mix_columns(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] t0, t1, t2, t3;\n\n    always @(a) begin\n        t0 = a[7] ? 8'h02 : 8'00;\n        t1 = a[6] ? 8'h03 : 8'00;\n        t2 = a[5] ? 8'h01 : 8'00;\n        t3 = a[4] ? 8'h01 : 8'00;\n        t0 = t0 << 1;\n        t1 = t1 << 1;\n        t2 = t2 << 1;\n        t3 = t3 << 1;\n        t0 = t0 ^ t1;\n        t2 = t2 ^ t3;\n        t0 = t0 ^ t2;\n        b = {t0[3], t0[2], t0[1], t0[0],\n             t1[3], t1[2], t1[1], t1[0],\n             t2[3], t2[2], t2[1], t2[0],\n             t3[3], t3[2], t3[1], t3[0]};\n    end\n\nendmodule\n\n// aes_add_round_key.v\nmodule aes_add_round_key(\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] c\n);\n\n    always @(a, b) begin\n        c = a ^ b;\n    end\n\nendmodule\n\n// aes_key_expand_128.v\nmodule aes_key_expansion(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_r;\n    reg [31:0] wo_0_r, wo_1_r, wo_2_r, wo_3_r;\n    reg [3:0] rcnt;\n    reg [7:0] rcon;\n    reg [7:0] sbox[255:0];\n\n    always @(posedge clk) begin\n        if (kld) begin\n            key_r <= key;\n            wo_0_r <= key[31:0];\n            wo_1_r <= key[63:32];\n            wo_2_r <= key[95:64];\n            wo_3_r <= key[127:96];\n            rcnt <= 4'b0000;\n        end\n        else begin\n            if (rcnt == 0) begin\n                wo_0_r <= wo_0_r ^ {sbox[key_r[7]], sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]],\n                                    sbox[key_r[3]], sbox[key_r[2]], sbox[key_r[1]], sbox[key_r[0]]};\n                wo_1_r <= wo_1_r ^ {sbox[key_r[7]], sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]],\n                                    sbox[key_r[3]], sbox[key_r[2]], sbox[key_r[1]], sbox[key_r[0]]};\n                wo_2_r <= wo_2_r ^ {sbox[key_r[7]], sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]],\n                                    sbox[key_r[3]], sbox[key_r[2]], sbox[key_r[1]], sbox[key_r[0]]};\n                wo_3_r <= wo_3_r ^ {sbox[key_r[7]], sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]],\n                                    sbox[key_r[3]], sbox[key_r[2]], sbox[key_r[1]], sbox[key_r[0]]};\n                rcnt <= rcnt + 1;\n            end\n            else if (rcnt == 1) begin\n                wo_0_r <= wo_0_r ^ {rcon, sbox[key_r[7]], sbox[key_r[6]], sbox[key_r[5]],\n                                    sbox[key_r[4]], sbox[key_r[3]], sbox[key_r[2]], sbox[key_r[1]]};\n                wo_1_r <= wo_1_r ^ {sbox[key_r[7]], sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]],\n                                    sbox[key_r[3]], sbox[key_r[2]], sbox[key_r[1]], sbox[key_r[0]]};\n                wo_2_r <= wo_2_r ^ {sbox[key_r[7]], sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]],\n                                    sbox[key_r[3]], sbox[key_r[2]], sbox[key_r[1]], sbox[key_r[0]]};\n                wo_3_r <= wo_3_r ^ {sbox[key_r[7]], sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]],\n                                    sbox[key_r[3]], sbox[key_r[2]], sbox[key_r[1]], sbox[key_r[0]]};\n                rcnt <= rcnt + 1;\n            end\n            else if (rcnt == 2) begin\n                wo_0_r <= wo_0_r ^ {wo_0_r[7], sbox[key_r[7]], sbox[key_r[6]], sbox[key_r[5]],\n                                    sbox[key_r[4]], sbox[key_r[3]], sbox[key_r[2]], sbox[key_r[1]]};\n                wo_1_r <= wo_1_r ^ {wo_1_r[7], sbox[key_r[7]], sbox[key_r[6]], sbox[key_r[5]],\n                                    sbox[key_r[4]], sbox[key_r[3]], sbox[key_r[2]], sbox[key_r[1]]};\n                wo_2_r <= wo_2_r ^ {wo_2_r[7], sbox[key_r[7]], sbox[key_r[6]], sbox[key_r[5]],\n                                    sbox[key_r[4]], sbox[key_r[3]], sbox[key_r[2]], sbox[key_r[1]]};\n                wo_3_r <= wo_3_r ^ {wo_3_r[7], sbox[key_r[7]], sbox[key_r[6]], sbox[key_r[5]],\n                                    sbox[key_r[4]], sbox[key_r[3]], sbox[key_r[2]], sbox[key_r[1]]};\n                rcnt <= rcnt + 1;\n            end\n            else if (rcnt == 3) begin\n                wo_0_r <= wo_0_r ^ {wo_0_r[7], wo_0_r[6], sbox[key_r[7]], sbox[key_r[6]],\n                                    sbox[key_r[5]], sbox[key_r[4]], sbox[key_r[3]], sbox[key_r[2]]};\n                wo_1_r <= wo_1_r ^ {wo_1_r[7], wo_1_r[6], sbox[key_r[7]], sbox[key_r[6]],\n                                    sbox[key_r[5]], sbox[key_r[4]], sbox[key_r[3]], sbox[key_r[2]]};\n                wo_2_r <= wo_2_r ^ {wo_2_r[7], wo_2_r[6], sbox[key_r[7]], sbox[key_r[6]],\n                                    sbox[key_r[5]], sbox[key_r[4]], sbox[key_r[3]], sbox[key_r[2]]};\n                wo_3_r <= wo_3_r ^ {wo_3_r[7], wo_3_r[6], sbox[key_r[7]], sbox[key_r[6]],\n                                    sbox[key_r[5]], sbox[key_r[4]], sbox[key_r[3]], sbox[key_r[2]]};\n                rcnt <= rcnt + 1;\n            end\n            else if (rcnt == 4) begin\n                wo_0_r <= wo_0_r ^ {wo_0_r[7], wo_0_r[6], wo_0_r[5], sbox[key_r[7]],\n                                    sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]], sbox[key_r[3]]};\n                wo_1_r <= wo_1_r ^ {wo_1_r[7], wo_1_r[6], wo_1_r[5], sbox[key_r[7]],\n                                    sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]], sbox[key_r[3]]};\n                wo_2_r <= wo_2_r ^ {wo_2_r[7], wo_2_r[6], wo_2_r[5], sbox[key_r[7]],\n                                    sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]], sbox[key_r[3]]};\n                wo_3_r <= wo_3_r ^ {wo_3_r[7], wo_3_r[6], wo_3_r[5], sbox[key_r[7]],\n                                    sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]], sbox[key_r[3]]};\n                rcnt <= rcnt + 1;\n            end\n            else if (rcnt == 5) begin\n                wo_0_r <= wo_0_r ^ {wo_0_r[7], wo_0_r[6], wo_0_r[5], wo_0_r[4], sbox[key_r[7]],\n                                    sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]]};\n                wo_1_r <= wo_1_r ^ {wo_1_r[7], wo_1_r[6], wo_1_r[5], wo_1_r[4], sbox[key_r[7]],\n                                    sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]]};\n                wo_2_r <= wo_2_r ^ {wo_2_r[7], wo_2_r[6], wo_2_r[5], wo_2_r[4], sbox[key_r[7]],\n                                    sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]]};\n                wo_3_r <= wo_3_r ^ {wo_3_r[7], wo_3_r[6], wo_3_r[5], wo_3_r[4], sbox[key_r[7]],\n                                    sbox[key_r[6]], sbox[key_r[5]], sbox[key_r[4]]};\n                rcnt <= rcnt + 1;\n            end\n            else if (rcnt == 6) begin\n                wo_0_r <= wo_0_r ^ {wo_0_r[7], wo_0_r[6], wo_0_r[5], wo_0_r[4], wo_0_r[3], sbox[key_r[7]],\n                                    sbox[key_r[6]], sbox[key_r[5]]};\n                wo_1_r <= wo_1_r ^ {wo_1_r[7], wo_1_r[6], wo_1_r[5], wo_1_r[4], wo_1_r[3], sbox[key_r[7]],\n                                    sbox[key_r[6]], sbox[key_r[5]]};\n                wo_2_r <= wo_2_r ^ {wo_2_r[7], wo_2_r[6], wo_2_r[5], wo_2_r[4], wo_2_r[3], sbox[key_r[7]],\n                                    sbox[key_r[6]], sbox[key_r[5]]};\n                wo_3_r <= wo_3_r ^ {wo_3_r[7], wo_3_r[6], wo_3_r[5], wo_3_r[4], wo_3_r[3], sbox[key_r[7]],\n                                    sbox[key_r[6]], sbox[key_r[5]]};\n                rcnt <= rcnt + 1;\n            end\n            else if (rcnt == 7) begin\n                wo_0_r <= wo_0_r ^ {wo_0_r[7], wo_0_r[6], wo_0_r[5], wo_0_r[4], wo_0_r[3], wo_0_r[2], sbox[key_r[7]],\n                                    sbox[key_r[6]]};\n                wo_1_r <= wo_1_r ^ {wo_1_r[7], wo_1_r[6], wo_1_r[5], wo_1_r[4], wo_1_r[3], wo_1_r[2], sbox[key_r[7]],\n                                    sbox[key_r[6]]};\n                wo_2_r <= wo_2_r ^ {wo_2_r[7], wo_2_r[6], wo_2_r[5], wo_2_r[4], wo_2_r[3], wo_2_r[2], sbox[key_r[7]],\n                                    sbox[key_r[6]]};\n                wo_3_r <= wo_3_r ^ {wo_3_r[7], wo_3_r[6], wo_3_r[5], wo_3_r[4], wo_3_r[3], wo_3_r[2], sbox[key_r[7]],\n                                    sbox[key_r[6]]};\n                rcnt <= rcnt + 1;\n            end\n            else if (rcnt == 8) begin\n                wo_0_r <= wo_0_r ^ {wo_0_r[7], wo_0_r[6], wo_0_r[5], wo_0_r[4], wo_0_r[3], wo_0_r[2], wo_0_r[1], sbox[key_r[7]]};\n                wo_1_r <= wo_1_r ^ {wo_1_r[7], wo_1_r[6], wo_1_r[5], wo_1_r[4], wo_1_r[3], wo_1_r[2], wo_1_r[1], sbox[key_r[7]]};\n                wo_2_r <= wo_2_r ^ {wo_2_r[7], wo_2_r[6], wo_2_r[5], wo_2_r[4], wo_2_r[3], wo_2_r[2], wo_2_r[1], sbox[key_r[7]]};\n                wo_3_r", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 20, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dcnt <= 11;\n            ld_r <= 0;\n        end else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1;\n        end else begin\n            if (dcnt > 0) begin\n                ld_r <= 0;\n                dcnt <= dcnt - 1;\n            end else begin\n                ld_r <= 0;\n                done <= 1;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (ld_r) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[8*i + j];\n                end\n            end\n        end else begin\n            // SubBytes\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= aes_sbox(sa[i][j]);\n                end\n            end\n\n            // ShiftRows\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    if (i == 0) begin\n                        sa[i][j] <= sa[i][j];\n                    end else begin\n                        sa[i][j] <= sa[i][(j + i) % 4];\n                    end\n                end\n            end\n\n            // MixColumns\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= (sa[i][j] * 2 + sa[i][(j + 1) % 4]) ^ (sa[i][j] * 3 + sa[i][(j + 2) % 4]);\n                end\n            end\n\n            // AddRoundKey\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ aes_key_expand_128.key_expansion[dcnt][8*i + j];\n                end\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (ld_r) begin\n            text_out <= text_in_r;\n        end else begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out[8*i + j] <= sa[i][j];\n                end\n            end\n        end\n    end\n\nendmodule\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [127:0] key_expansion[10][4];\n    reg [3:0] rcnt;\n    reg [7:0] w[4];\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[31:24];\n            w[1] <= key[23:16];\n            w[2] <= key[15:8];\n            w[3] <= key[7:0];\n            wo_0 <= w[0];\n            wo_1 <= w[1];\n            wo_2 <= w[2];\n            wo_3 <= w[3];\n        end else begin\n            if (rcnt == 0) begin\n                key_expansion[0][0] <= w[0];\n                key_expansion[0][1] <= w[1];\n                key_expansion[0][2] <= w[2];\n                key_expansion[0][3] <= w[3];\n                wo_0 <= w[0];\n                wo_1 <= w[1];\n                wo_2 <= w[2];\n                wo_3 <= w[3];\n            end else begin\n                for (int i = 0; i < 4; i++) begin\n                    key_expansion[rcnt][i] <= (key_expansion[rcnt-1][i] ^ aes_rcon.out);\n                end\n                wo_0 <= key_expansion[rcnt][0];\n                wo_1 <= key_expansion[rcnt][1];\n                wo_2 <= key_expansion[rcnt][2];\n                wo_3 <= key_expansion[rcnt][3];\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n        end else begin\n            rcnt <= rcnt + 1;\n        end\n    end\n\nendmodule\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else begin\n            if (rcnt == 9) begin\n                out <= 32'h36_00_00_00;\n            end else begin\n                out <= (out * 2) ^ (out * 3);\n            end\n            rcnt <= rcnt + 1;\n        end\n    end\n\nendmodule\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[256];\n\n    initial begin\n        for (int i = 0; i < 256; i++) begin\n            sbox[i] <= i;\n        end\n    end\n\n    always @(a) begin\n        b <= sbox[a];\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 20, "code": "// aes_inv_cipher_top.v\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            text_in_r <= 0;\n            sa <= 0;\n            dcnt <= 0;\n            kb <= 0;\n            kcnt <= 4'd10;\n            ld_r <= 0;\n            text_out_r <= 0;\n        end\n        else begin\n            if (kld) begin\n                kcnt <= 4'd10;\n                kb <= {key, {10{1'b0}};\n                ld_r <= 0;\n            end\n            else if (ld) begin\n                ld_r <= 1;\n            end\n            else if (ld_r) begin\n                ld_r <= 0;\n                text_in_r <= text_in;\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= text_in_r[8*i + j];\n                    end\n                end\n                dcnt <= 1;\n                text_out_r <= 0;\n            end\n            else if (dcnt < 11) begin\n                dcnt <= dcnt + 1;\n                if (dcnt == 1) begin\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ kb[32*(dcnt-1) + 8*j + i];\n                        end\n                    end\n                end\n                else begin\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= InvShiftRows(sa[i][j], dcnt);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= InvSubBytes(sa[i][j]);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= InvMixColumns(sa[i][j]);\n                        end\n                    end\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ kb[32*(dcnt-1) + 8*j + i];\n                        end\n                    end\n                end\n                if (dcnt == 11) begin\n                    done <= 1;\n                end\n            end\n            else begin\n                done <= 0;\n            end\n            text_out <= text_out_r;\n        end\n    end\n\n    function [7:0] InvShiftRows([7:0] a, [3:0] dcnt);\n        case (dcnt)\n            1: begin\n                InvShiftRows = a;\n            end\n            2: begin\n                InvShiftRows = {sa[2][3], sa[3][2], sa[0][1], sa[1][0]};\n            end\n            3: begin\n                InvShiftRows = {sa[3][1], sa[0][3], sa[1][2], sa[2][0]};\n            end\n            4: begin\n                InvShiftRows = {sa[2][0], sa[3][1], sa[1][3], sa[0][2]};\n            end\n            default: begin\n                InvShiftRows = a;\n            end\n        endcase\n    endfunction\n\n    function [7:0] InvSubBytes([7:0] a);\n        InvSubBytes = InvSbox(a);\n    endfunction\n\n    function [7:0] InvSbox([7:0] a);\n        case (a)\n            8'h00: InvSbox = 8'h52;\n            8'h01: InvSbox = 8'h09;\n            8'h02: InvSbox = 8'h18;\n            8'h03: InvSbox = 8'h1E;\n            8'h04: InvSbox = 8'h29;\n            8'h05: InvSbox = 8'h24;\n            8'h06: InvSbox = 8'h23;\n            8'h07: InvSbox = 8'h20;\n            8'h08: InvSbox = 8'h1A;\n            8'h09: InvSbox = 8'h0A;\n            8'h0A: InvSbox = 8'h1F;\n            8'h0B: InvSbox = 8'h15;\n            8'h0C: InvSbox = 8'h1D;\n            8'h0D: InvSbox = 8'h0B;\n            8'h0E: InvSbox = 8'h0C;\n            8'h0F: InvSbox = 8'h13;\n            8'h10: InvSbox = 8'h19;\n            8'h11: InvSbox = 8'h12;\n            8'h12: InvSbox = 8'h07;\n            8'h13: InvSbox = 8'h0E;\n            8'h14: InvSbox = 8'h0C;\n            8'h15: InvSbox = 8'h05;\n            8'h16: InvSbox = 8'h09;\n            8'h17: InvSbox = 8'h0A;\n            8'h18: InvSbox = 8'h18;\n            8'h19: InvSbox = 8'h14;\n            8'h1A: InvSbox = 8'h00;\n            8'h1B: InvSbox = 8'h0B;\n            8'h1C: InvSbox = 8'h04;\n            8'h1D: InvSbox = 8'h0E;\n            8'h1E: InvSbox = 8'h16;\n            8'h1F: InvSbox = 8'h0D;\n            default: InvSbox = 8'h00;\n        endcase\n    endfunction\n\n    function [7:0] InvMixColumns([7:0] a);\n        case (a)\n            8'h00: InvMixColumns = 8'h00;\n            8'h01: InvMixColumns = 8'h0E;\n            8'h02: InvMixColumns = 8'h15;\n            8'h03: InvMixColumns = 8'h16;\n            8'h04: InvMixColumns = 8'h1F;\n            8'h05: InvMixColumns = 8'h1C;\n            8'h06: InvMixColumns = 8'h1B;\n            8'h07: InvMixColumns = 8'h0D;\n            8'h08: InvMixColumns = 8'h0B;\n            8'h09: InvMixColumns = 8'h0C;\n            8'h0A: InvMixColumns = 8'h0F;\n            8'h0B: InvMixColumns = 8'h0A;\n            8'h0C: InvMixColumns = 8'h09;\n            8'h0D: InvMixColumns = 8'h06;\n            8'h0E: InvMixColumns = 8'h0E;\n            8'h0F: InvMixColumns = 8'h07;\n            default: InvMixColumns = 8'h00;\n        endcase\n    endfunction\n\n    function [7:0] InvMixColumns([7:0] a);\n        case (a)\n            8'h00: InvMixColumns = 8'h00;\n            8'h01: InvMixColumns = 8'h0E;\n            8'h02: InvMixColumns = 8'h15;\n            8'h03: InvMixColumns = 8'h16;\n            8'h04: InvMixColumns = 8'h1F;\n            8'h05: InvMixColumns = 8'h1C;\n            8'h06: InvMixColumns = 8'h1B;\n            8'h07: InvMixColumns = 8'h0D;\n            8'h08: InvMixColumns = 8'h0B;\n            8'h09: InvMixColumns = 8'h0C;\n            8'h0A: InvMixColumns = 8'h0F;\n            8'h0B: InvMixColumns = 8'h0A;\n            8'h0C: InvMixColumns = 8'h09;\n            8'h0D: InvMixColumns = 8'h06;\n            8'h0E: InvMixColumns = 8'h0E;\n            8'h0F: InvMixColumns = 8'h07;\n            default: InvMixColumns = 8'h00;\n        endcase\n    endfunction\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 1, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 2, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 3, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 4, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 5, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 6, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 7, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 8, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 9, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 10, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 11, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 12, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 13, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 14, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 15, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 16, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 17, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 18, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 19, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 20, "code": "'NoneType' object is not subscriptable", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
