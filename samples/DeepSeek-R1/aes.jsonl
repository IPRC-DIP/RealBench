{"task": "aes_inv_cipher_top", "codeid": 1, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Register declarations\nreg [127:0] text_in_r;\nreg [7:0] sa [0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb [10:0];\nreg [3:0] kcnt;\nreg ld_r;\nreg [127:0] text_out_reg;\n\n// Wire declarations\nwire [31:0] wo_0, wo_1, wo_2, wo_3;\nwire [127:0] w;\nwire [7:0] sbox_out [0:3][0:3];\nwire [127:0] sa_shift, sa_sub, sa_ark, sa_mix;\nwire [3:0] next_dcnt;\nwire done_next;\n\n// FSM states\ntypedef enum {\n    IDLE, KeyLoad, KeyExpansion, KeyStored,\n    InitialRound, StandardRound, FinalRound, Done\n} state_t;\nreg [2:0] state;\n\n// Key expansion module instantiation\naes_key_expand_128 key_expand (\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(wo_0),\n    .wo_1(wo_1),\n    .wo_2(wo_2),\n    .wo_3(wo_3)\n);\n\n// Inverse S-box instances\ngenvar i, j;\ngenerate\n    for (i=0; i<4; i=i+1) begin : row\n        for (j=0; j<4; j=j+1) begin : col\n            aes_inv_sbox u_sbox (\n                .a(sa[i][j]),\n                .b(sbox_out[i][j])\n            );\n        end\n    end\nendgenerate\n\n// Key buffer and counter\nalways @(posedge clk) begin\n    if (rst) begin\n        kcnt <= 4'hA;\n    end else if (state == KeyExpansion) begin\n        if (kcnt > 0) begin\n            kb[kcnt] <= {wo_3, wo_2, wo_1, wo_0};\n            kcnt <= kcnt - 1;\n        end\n    end\nend\n\n// FSM and main control\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        dcnt <= 0;\n        ld_r <= 0;\n        text_out_reg <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (kld) state <= KeyLoad;\n                else if (ld) begin\n                    text_in_r <= text_in;\n                    state <= InitialRound;\n                    dcnt <= 0;\n                end\n            end\n            KeyLoad: state <= KeyExpansion;\n            KeyExpansion: begin\n                if (kcnt == 0) state <= KeyStored;\n            end\n            KeyStored: begin\n                if (ld) state <= InitialRound;\n            end\n            InitialRound: begin\n                state <= StandardRound;\n                dcnt <= dcnt + 1;\n            end\n            StandardRound: begin\n                if (dcnt == 10) state <= FinalRound;\n                else dcnt <= dcnt + 1;\n            end\n            FinalRound: begin\n                state <= Done;\n                dcnt <= dcnt + 1;\n            end\n            Done: begin\n                text_out_reg <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                                sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                                sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                                sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                state <= IDLE;\n            end\n        endcase\n        ld_r <= ld;\n    end\nend\n\n// Data path transformations\nalways @* begin\n    // InvShiftRows\n    sa_shift = {\n        sa[0][0], sa[3][1], sa[2][2], sa[1][3],\n        sa[1][0], sa[0][1], sa[3][2], sa[2][3],\n        sa[2][0], sa[1][1], sa[0][2], sa[3][3],\n        sa[3][0], sa[2][1], sa[1][2], sa[0][3]\n    };\n\n    // InvSubBytes\n    for (int i=0; i<4; i++)\n        for (int j=0; j<4; j++)\n            sa_sub[i][j] = sbox_out[i][j];\n\n    // AddRoundKey\n    sa_ark = sa_sub ^ kb[dcnt];\n\n    // InvMixColumns (except final round)\n    if (dcnt < 10) begin\n        for (int col=0; col<4; col++) begin\n            sa_mix[col*32 +: 8] = pmul_e(sa_ark[col*32 +: 8]) ^ pmul_b(sa_ark[col*32+8 +: 8]) ^ pmul_d(sa_ark[col*32+16 +: 8]) ^ pmul_9(sa_ark[col*32+24 +: 8]);\n            // ... Similar for other rows\n        end\n    end else begin\n        sa_mix = sa_ark;\n    end\nend\n\n// State matrix update\nalways @(posedge clk) begin\n    if (state == InitialRound) begin\n        // Initial round key addition\n        sa <= text_in_r ^ kb[0];\n    end else if (state == StandardRound || state == FinalRound) begin\n        // Update state with transformed values\n        sa <= sa_mix;\n    end\nend\n\n// Output assignments\nassign done = (state == Done);\nassign text_out = text_out_reg;\n\n// Galois Field multiplication functions\nfunction [7:0] pmul_e(input [7:0] b);\n    // Implementation of 0x0E multiplication\nendfunction\n\nfunction [7:0] pmul_b(input [7:0] b);\n    // Implementation of 0x0B multiplication\nendfunction\n\nfunction [7:0] pmul_d(input [7:0] b);\n    // Implementation of 0x0D multiplication\nendfunction\n\nfunction [7:0] pmul_9(input [7:0] b);\n    // Implementation of 0x09 multiplication\nendfunction\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 2, "code": "module aes_inv_cipher_top(\n    input               clk,\n    input               rst,\n    input               kld,\n    input               ld,\n    output reg          done,\n    input       [127:0] key,\n    input       [127:0] text_in,\n    output reg  [127:0] text_out\n);\n\n// State machine definitions\nlocalparam IDLE         = 3'd0;\nlocalparam KEY_LOAD     = 3'd1;\nlocalparam KEY_EXPANSION= 3'd2;\nlocalparam KEY_STORED   = 3'd3;\nlocalparam INITIAL_ROUND= 3'd4;\nlocalparam STANDARD_ROUND=3'd5;\nlocalparam FINAL_ROUND  = 3'd6;\nlocalparam DONE_STATE   = 3'd7;\n\n// Internal registers\nreg [127:0] text_in_r;\nreg [7:0]   sa [0:3][0:3];  // State array\nreg [3:0]   dcnt;           // Round counter\nreg [127:0] kb [10:0];      // Key buffer\nreg [3:0]   kcnt;           // Key counter\nreg         ld_r;\nreg [2:0]   state;\n\n// Key expansion interface\nwire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n// Inverse S-box wires\nwire [7:0] sbox_out [0:3][0:3];\n\n// Transformation intermediates\nreg [7:0]   sa_shift [0:3][0:3];\nreg [7:0]   sa_sub [0:3][0:3];\nreg [7:0]   sa_ark [0:3][0:3];\nreg [7:0]   sa_mix [0:3][0:3];\n\n// Key expansion module\naes_key_expand_128 key_expand_inst (\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(wo_0),\n    .wo_1(wo_1),\n    .wo_2(wo_2),\n    .wo_3(wo_3)\n);\n\n// Generate inverse S-box instances\ngenvar i, j;\ngenerate\n    for (i=0; i<4; i=i+1) begin : row\n        for (j=0; j<4; j=j+1) begin : col\n            aes_inv_sbox sbox_inst (\n                .a(sa_shift[i][j]),\n                .b(sbox_out[i][j])\n            );\n        end\n    end\nendgenerate\n\n// State machine and main control\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        done <= 0;\n        dcnt <= 0;\n        kcnt <= 10;\n        ld_r <= 0;\n        text_out <= 0;\n        // Reset state matrix\n        // Reset key buffer\n    end else begin\n        case(state)\n            IDLE: begin\n                if (kld) state <= KEY_LOAD;\n                else if (ld) begin\n                    // Load data\n                    state <= INITIAL_ROUND;\n                end\n            end\n            KEY_LOAD: begin\n                // Start key expansion\n                state <= KEY_EXPANSION;\n            end\n            KEY_EXPANSION: begin\n                if (kcnt == 0) state <= KEY_STORED;\n                // Decrement kcnt each cycle\n            end\n            KEY_STORED: begin\n                if (ld) state <= INITIAL_ROUND;\n            end\n            INITIAL_ROUND: begin\n                dcnt <= dcnt + 1;\n                state <= STANDARD_ROUND;\n            end\n            STANDARD_ROUND: begin\n                if (dcnt == 10) state <= FINAL_ROUND;\n                else dcnt <= dcnt + 1;\n            end\n            FINAL_ROUND: begin\n                state <= DONE_STATE;\n                done <= 1;\n            end\n            DONE_STATE: begin\n                done <= 0;\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// Key buffer loading\nalways @(posedge clk) begin\n    if (state == KEY_EXPANSION) begin\n        kb[kcnt] <= {wo_3, wo_2, wo_1, wo_0};\n        kcnt <= kcnt - 1;\n    end\nend\n\n// Data path transformations\nalways @(*) begin\n    // InvShiftRows\n    // Implement row shifts\n    // InvSubBytes through sbox_out\n    // AddRoundKey using kb[dcnt]\n    // InvMixColumns if not final round\nend\n\n// Output mapping\nalways @(posedge clk) begin\n    if (state == DONE_STATE) begin\n        // Map sa_ark to text_out in column-major order\n    end\nend\n\n// GF(2^8) multiplication functions\nfunction [7:0] pmul_e; input [7:0] x; ... endfunction\nfunction [7:0] pmul_b; input [7:0] x; ... endfunction\nfunction [7:0] pmul_d; input [7:0] x; ... endfunction\nfunction [7:0] pmul_9; input [7:0] x; ... endfunction\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 1, "code": "module aes_sbox (\n    input  [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] b_reg;\n\nalways @* begin\n    case (a)\n        8'h00: b_reg = 8'h63;\n        8'h01: b_reg = 8'h7c;\n        8'h02: b_reg = 8'h77;\n        8'h03: b_reg = 8'h7b;\n        8'h04: b_reg = 8'hf2;\n        8'h05: b_reg = 8'h6b;\n        8'h06: b_reg = 8'h6f;\n        8'h07: b_reg = 8'hc5;\n        8'h08: b_reg = 8'h30;\n        8'h09: b_reg = 8'h01;\n        8'h0a: b_reg = 8'h67;\n        8'h0b: b_reg = 8'h2b;\n        8'h0c: b_reg = 8'hfe;\n        8'h0d: b_reg = 8'hd7;\n        8'h0e: b_reg = 8'hab;\n        8'h0f: b_reg = 8'h76;\n        // ... (All 256 cases must be explicitly listed)\n        8'hf0: b_reg = 8'h8c;\n        8'hf1: b_reg = 8'ha1;\n        8'hf2: b_reg = 8'h89;\n        8'hf3: b_reg = 8'h0d;\n        8'hf4: b_reg = 8'hbf;\n        8'hf5: b_reg = 8'he6;\n        8'hf6: b_reg = 8'h42;\n        8'hf7: b_reg = 8'h68;\n        8'hf8: b_reg = 8'h41;\n        8'hf9: b_reg = 8'h99;\n        8'hfa: b_reg = 8'h2d;\n        8'hfb: b_reg = 8'h0f;\n        8'hfc: b_reg = 8'hb0;\n        8'hfd: b_reg = 8'h54;\n        8'hfe: b_reg = 8'hbb;\n        8'hff: b_reg = 8'h16;\n    endcase\nend\n\nassign b = b_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 3, "code": "module aes_inv_cipher_top (\n    input          clk,\n    input          rst,\n    input          kld,\n    input          ld,\n    output reg     done,\n    input  [127:0] key,\n    input  [127:0] text_in,\n    output [127:0] text_out\n);\n\n// State machine states\nlocalparam [3:0] IDLE         = 4'd0,\n                 KEY_LOAD     = 4'd1,\n                 KEY_EXPANSION= 4'd2,\n                 KEY_STORED   = 4'd3,\n                 INITIAL_ROUND= 4'd4,\n                 STANDARD_ROUND=4'd5,\n                 FINAL_ROUND  = 4'd6,\n                 DONE_STATE   = 4'd7;\n\nreg [3:0] state, next_state;\nreg [127:0] text_in_r;\nreg [7:0] sa [0:3][0:3];  // State matrix\nreg [3:0] dcnt;           // Round counter\nreg [127:0] kb [0:10];    // Key buffer\nreg [3:0] kcnt;           // Key counter\nreg ld_r;\n\n// Key expansion signals\nwire [31:0] wo_0, wo_1, wo_2, wo_3;\naes_key_expand_128 key_expand (\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(wo_0),\n    .wo_1(wo_1),\n    .wo_2(wo_2),\n    .wo_3(wo_3)\n);\n\n// Inverse S-box instances\nwire [7:0] inv_sbox_out [0:3][0:3];\ngenvar i, j;\ngenerate\n    for (i=0; i<4; i=i+1) begin : row\n        for (j=0; j<4; j=j+1) begin : col\n            aes_inv_sbox u_sbox (\n                .a(sa[i][j]),\n                .b(inv_sbox_out[i][j])\n            );\n        end\n    end\nendgenerate\n\n// Internal signals\nwire [127:0] current_key;\nreg [127:0] sa_shifted, sa_sub, sa_ark, sa_mix;\nreg [3:0] round_type;\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) state <= IDLE;\n    else state <= next_state;\nend\n\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE:          if (kld) next_state = KEY_LOAD;\n                       else if (ld) next_state = INITIAL_ROUND;\n        KEY_LOAD:      next_state = KEY_EXPANSION;\n        KEY_EXPANSION: if (kcnt == 0) next_state = KEY_STORED;\n        KEY_STORED:    if (ld) next_state = INITIAL_ROUND;\n        INITIAL_ROUND: next_state = STANDARD_ROUND;\n        STANDARD_ROUND:if (dcnt == 10) next_state = FINAL_ROUND;\n        FINAL_ROUND:   next_state = DONE_STATE;\n        DONE_STATE:    next_state = IDLE;\n        default:       next_state = IDLE;\n    endcase\nend\n\n// Key buffer loading\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        kcnt <= 4'hA;\n        for (integer i=0; i<11; i=i+1) kb[i] <= 0;\n    end else if (state == KEY_EXPANSION) begin\n        kb[kcnt] <= {wo_3, wo_2, wo_1, wo_0};\n        kcnt <= kcnt - 1;\n    end\nend\n\n// Data path\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        text_in_r <= 0;\n        dcnt <= 0;\n        ld_r <= 0;\n        done <= 0;\n        for (integer i=0; i<4; i=i+1)\n            for (integer j=0; j<4; j=j+1)\n                sa[i][j] <= 0;\n    end else begin\n        ld_r <= ld;\n        case (state)\n            IDLE: begin\n                done <= 0;\n                if (ld) text_in_r <= text_in;\n            end\n            INITIAL_ROUND: begin\n                // Load initial state and add round key\n                for (integer i=0; i<4; i=i+1)\n                    for (integer j=0; j<4; j=j+1)\n                        sa[i][j] <= text_in_r[127-8*(i+4*j) -:8] ^ current_key[127-8*(i+4*j) -:8];\n                dcnt <= 1;\n            end\n            STANDARD_ROUND: begin\n                // Apply transformations\n                sa <= inv_mix_columns(sa_ark);\n                dcnt <= dcnt + 1;\n            end\n            FINAL_ROUND: begin\n                // Final round without mix columns\n                for (integer i=0; i<4; i=i+1)\n                    for (integer j=0; j<4; j=j+1)\n                        sa[i][j] <= sa_ark[i][j];\n                dcnt <= 11;\n                done <= 1;\n            end\n            DONE_STATE: done <= 0;\n        endcase\n    end\nend\n\n// Inverse ShiftRows\nalways @(*) begin\n    sa_shifted = sa;\n    // Row 0: no shift\n    // Row 1: right shift 3\n    {sa_shifted[1][0], sa_shifted[1][1], sa_shifted[1][2], sa_shifted[1][3]} = \n    {sa[1][3], sa[1][0], sa[1][1], sa[1][2]};\n    // Row 2: right shift 2\n    {sa_shifted[2][0], sa_shifted[2][1], sa_shifted[2][2], sa_shifted[2][3]} = \n    {sa[2][2], sa[2][3], sa[2][0], sa[2][1]};\n    // Row 3: right shift 1\n    {sa_shifted[3][0], sa_shifted[3][1], sa_shifted[3][2], sa_shifted[3][3]} = \n    {sa[3][1], sa[3][2], sa[3][3], sa[3][0]};\nend\n\n// AddRoundKey\nassign current_key = kb[dcnt];\nalways @(*) begin\n    for (integer i=0; i<4; i=i+1)\n        for (integer j=0; j<4; j=j+1)\n            sa_ark[i][j] = inv_sbox_out[i][j] ^ current_key[127-8*(i+4*j) -:8];\nend\n\n// Inverse MixColumns function\nfunction [7:0] inv_mix_column;\n    input [7:0] s0, s1, s2, s3;\n    begin\n        inv_mix_column = \n            pmul_e(s0) ^ pmul_b(s1) ^ pmul_d(s2) ^ pmul_9(s3);\n    end\nendfunction\n\nfunction [7:0] pmul_e; input [7:0] b; /* Implementation */ endfunction\nfunction [7:0] pmul_b; input [7:0] b; /* Implementation */ endfunction\nfunction [7:0] pmul_d; input [7:0] b; /* Implementation */ endfunction\nfunction [7:0] pmul_9; input [7:0] b; /* Implementation */ endfunction\n\n// Output mapping\nassign text_out = {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                   sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                   sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                   sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 1, "code": "module aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n\nreg [3:0] rcnt;\n\nalways @(posedge clk) begin\n    if (kld)\n        rcnt <= 4'b0;\n    else\n        rcnt <= rcnt + 1;\nend\n\nalways @(posedge clk) begin\n    case (rcnt)\n        4'd0:  out <= 32'h01000000;\n        4'd1:  out <= 32'h02000000;\n        4'd2:  out <= 32'h04000000;\n        4'd3:  out <= 32'h08000000;\n        4'd4:  out <= 32'h10000000;\n        4'd5:  out <= 32'h20000000;\n        4'd6:  out <= 32'h40000000;\n        4'd7:  out <= 32'h80000000;\n        4'd8:  out <= 32'h1B000000;\n        4'd9:  out <= 32'h36000000;\n        default: out <= 32'h00000000;\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 4, "code": "module aes_inv_cipher_top (\n    input         clk,\n    input         rst,\n    input         kld,\n    input         ld,\n    output        done,\n    input  [127:0] key,\n    input  [127:0] text_in,\n    output [127:0] text_out\n);\n\n// State definitions\nlocalparam IDLE         = 0;\nlocalparam KEY_LOAD     = 1;\nlocalparam KEY_EXPAND   = 2;\nlocalparam KEY_STORED   = 3;\nlocalparam INITIAL_ROUND= 4;\nlocalparam STANDARD_ROUND=5;\nlocalparam FINAL_ROUND  = 6;\nlocalparam DONE_STATE   = 7;\n\nreg [2:0] state, next_state;\nreg [3:0] dcnt;\nreg [3:0] kcnt;\nreg [127:0] text_in_r;\nreg [127:0] kb [10:0];\nreg ld_r;\nreg [7:0] sa [0:3][0:3];\nreg [127:0] text_out_reg;\n\nwire [31:0] wo_0, wo_1, wo_2, wo_3;\nwire [127:0] round_key;\nwire [7:0] inv_sbox_out [0:3][0:3];\nwire [7:0] shifted_rows [0:3][0:3];\nwire [7:0] ark [0:3][0:3];\nwire [7:0] mix_col_out [0:3][0:3];\n\n// Key expansion module\naes_key_expand_128 key_expand (\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(wo_0),\n    .wo_1(wo_1),\n    .wo_2(wo_2),\n    .wo_3(wo_3)\n);\n\n// Inverse S-box instances\ngenvar i, j;\ngenerate\n    for (i=0; i<4; i=i+1) begin : row\n        for (j=0; j<4; j=j+1) begin : col\n            aes_inv_sbox sbox_inst (\n                .a(shifted_rows[i][j]),\n                .b(inv_sbox_out[i][j])\n            );\n        end\n    end\nendgenerate\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) state <= IDLE;\n    else state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        IDLE:          next_state = kld ? KEY_LOAD : ld ? KEY_STORED : IDLE;\n        KEY_LOAD:      next_state = KEY_EXPAND;\n        KEY_EXPAND:    next_state = (kcnt == 0) ? KEY_STORED : KEY_EXPAND;\n        KEY_STORED:    next_state = ld ? INITIAL_ROUND : KEY_STORED;\n        INITIAL_ROUND: next_state = STANDARD_ROUND;\n        STANDARD_ROUND:next_state = (dcnt == 10) ? FINAL_ROUND : STANDARD_ROUND;\n        FINAL_ROUND:   next_state = (dcnt == 11) ? DONE_STATE : FINAL_ROUND;\n        DONE_STATE:    next_state = IDLE;\n        default:       next_state = IDLE;\n    endcase\nend\n\n// Key buffer loading\nalways @(posedge clk) begin\n    if (state == KEY_EXPAND) begin\n        kb[kcnt] <= {wo_3, wo_2, wo_1, wo_0};\n        kcnt <= kcnt - 1;\n    end\n    else if (state == IDLE) kcnt <= 4'hA;\nend\n\n// Data processing\nalways @(posedge clk) begin\n    if (rst) begin\n        dcnt <= 0;\n        text_out_reg <= 0;\n        ld_r <= 0;\n    end else begin\n        ld_r <= ld;\n        case (state)\n            INITIAL_ROUND: begin\n                // Load initial data and add round key\n                if (ld_r) begin\n                    // Map text_in_r to state matrix\n                    // Implementation omitted for brevity\n                    dcnt <= dcnt + 1;\n                end\n            end\n            STANDARD_ROUND: begin\n                // Perform transformations\n                // InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns\n                dcnt <= dcnt + 1;\n            end\n            FINAL_ROUND: begin\n                // Final round without InvMixColumns\n                dcnt <= dcnt + 1;\n            end\n            DONE_STATE: begin\n                // Map state to text_out\n                text_out_reg <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0], \n                                sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                                sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                                sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                dcnt <= 0;\n            end\n        endcase\n    end\nend\n\n// Round key selection\nassign round_key = kb[dcnt];\n\n// InvShiftRows implementation\nassign shifted_rows[0][0] = sa[0][0];\nassign shifted_rows[0][1] = sa[0][1];\nassign shifted_rows[0][2] = sa[0][2];\nassign shifted_rows[0][3] = sa[0][3];\n\nassign shifted_rows[1][0] = sa[1][3];\nassign shifted_rows[1][1] = sa[1][0];\nassign shifted_rows[1][2] = sa[1][1];\nassign shifted_rows[1][3] = sa[1][2];\n\nassign shifted_rows[2][0] = sa[2][2];\nassign shifted_rows[2][1] = sa[2][3];\nassign shifted_rows[2][2] = sa[2][0];\nassign shifted_rows[2][3] = sa[2][1];\n\nassign shifted_rows[3][0] = sa[3][1];\nassign shifted_rows[3][1] = sa[3][2];\nassign shifted_rows[3][2] = sa[3][3];\nassign shifted_rows[3][3] = sa[3][0];\n\n// AddRoundKey implementation\ngenvar x, y;\ngenerate\n    for (x=0; x<4; x=x+1) begin : add_key_x\n        for (y=0; y<4; y=y+1) begin : add_key_y\n            assign ark[x][y] = inv_sbox_out[x][y] ^ round_key[127-(32*x + 8*y +7) -:8];\n        end\n    end\nendgenerate\n\n// InvMixColumns implementation\n// Implementation using GF(2^8) multiplication functions\n// (pmul_e, pmul_b, pmul_d, pmul_9 functions required)\n\nassign done = (state == DONE_STATE);\nassign text_out = text_out_reg;\n\nendmodule\n\n// Key expansion and inverse S-box modules should be implemented separately", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 5, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output reg done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n// Internal registers and wires\nreg [127:0] text_in_r;\nreg [7:0] sa [0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb [10:0];\nreg [3:0] kcnt;\nreg ld_r;\n\nwire [31:0] wo_0, wo_1, wo_2, wo_3;\nwire [127:0] w;\nreg [127:0] sa_shift, sa_sub, sa_ark, sa_next;\nreg [3:0] state;\n\n// State definitions\nlocalparam IDLE        = 4'd0;\nlocalparam KeyLoad     = 4'd1;\nlocalparam KeyExpansion= 4'd2;\nlocalparam KeyStored   = 4'd3;\nlocalparam InitialRound= 4'd4;\nlocalparam StandardRound=4'd5;\nlocalparam FinalRound  = 4'd6;\nlocalparam Done        = 4'd7;\n\n// Key expansion submodule\naes_key_expand_128 key_expand (\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(wo_0),\n    .wo_1(wo_1),\n    .wo_2(wo_2),\n    .wo_3(wo_3)\n);\n\n// Inverse S-box instances\ngenvar i, j;\ngenerate\n    for (i=0; i<4; i=i+1) begin: row\n        for (j=0; j<4; j=j+1) begin: col\n            aes_inv_sbox u_sbox (\n                .a(sa_shift[i*4 + j]),\n                .b(sa_sub[i*4 + j])\n            );\n        end\n    end\nendgenerate\n\n// State machine and control logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        dcnt <= 0;\n        kcnt <= 10;\n        ld_r <= 0;\n        done <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (kld) state <= KeyLoad;\n                else if (ld) begin\n                    text_in_r <= text_in;\n                    state <= KeyStored;\n                end\n            end\n            KeyLoad: state <= KeyExpansion;\n            KeyExpansion: begin\n                if (kcnt == 0) state <= KeyStored;\n                else kcnt <= kcnt - 1;\n            end\n            KeyStored: if (ld) state <= InitialRound;\n            InitialRound: begin\n                dcnt <= dcnt + 1;\n                state <= StandardRound;\n            end\n            StandardRound: begin\n                if (dcnt == 10) state <= FinalRound;\n                else dcnt <= dcnt + 1;\n            end\n            FinalRound: begin\n                if (dcnt == 11) begin\n                    state <= Done;\n                    done <= 1;\n                end\n            end\n            Done: begin\n                done <= 0;\n                state <= IDLE;\n            end\n        endcase\n        ld_r <= ld;\n    end\nend\n\n// Key buffer loading\nalways @(posedge clk) begin\n    if (state == KeyExpansion) begin\n        kb[kcnt] <= {wo_3, wo_2, wo_1, wo_0};\n    end\nend\n\n// Data path transformations\nalways @* begin\n    // InvShiftRows\n    sa_shift[0] = sa[0][0];\n    sa_shift[1] = sa[1][3];\n    sa_shift[2] = sa[2][2];\n    sa_shift[3] = sa[3][1];\n    sa_shift[4] = sa[0][1];\n    sa_shift[5] = sa[1][0];\n    sa_shift[6] = sa[2][3];\n    sa_shift[7] = sa[3][2];\n    sa_shift[8] = sa[0][2];\n    sa_shift[9] = sa[1][1];\n    sa_shift[10] = sa[2][0];\n    sa_shift[11] = sa[3][3];\n    sa_shift[12] = sa[0][3];\n    sa_shift[13] = sa[1][2];\n    sa_shift[14] = sa[2][1];\n    sa_shift[15] = sa[3][0];\n\n    // AddRoundKey\n    w = kb[dcnt];\n    sa_ark = sa_sub ^ w;\n\n    // InvMixColumns (except last round)\n    if (state != FinalRound) begin\n        for (int c=0; c<4; c++) begin\n            sa_next[c*4 + 0] = pmul_e(sa_ark[c*4 + 0]) ^ pmul_b(sa_ark[c*4 + 1]) ^ pmul_d(sa_ark[c*4 + 2]) ^ pmul_9(sa_ark[c*4 + 3]);\n            sa_next[c*4 + 1] = pmul_9(sa_ark[c*4 + 0]) ^ pmul_e(sa_ark[c*4 + 1]) ^ pmul_b(sa_ark[c*4 + 2]) ^ pmul_d(sa_ark[c*4 + 3]);\n            sa_next[c*4 + 2] = pmul_d(sa_ark[c*4 + 0]) ^ pmul_9(sa_ark[c*4 + 1]) ^ pmul_e(sa_ark[c*4 + 2]) ^ pmul_b(sa_ark[c*4 + 3]);\n            sa_next[c*4 + 3] = pmul_b(sa_ark[c*4 + 0]) ^ pmul_d(sa_ark[c*4 + 1]) ^ pmul_9(sa_ark[c*4 + 2]) ^ pmul_e(sa_ark[c*4 + 3]);\n        end\n    end else begin\n        sa_next = sa_ark;\n    end\nend\n\n// GF(2^8) multiplication functions\nfunction [7:0] pmul_e(input [7:0] b);\n    // Implementation of multiply by 0x0E\nendfunction\n\nfunction [7:0] pmul_b(input [7:0] b);\n    // Implementation of multiply by 0x0B\nendfunction\n\nfunction [7:0] pmul_d(input [7:0] b);\n    // Implementation of multiply by 0x0D\nendfunction\n\nfunction [7:0] pmul_9(input [7:0] b);\n    // Implementation of multiply by 0x09\nendfunction\n\n// Output mapping\nalways @(posedge clk) begin\n    if (state == Done) begin\n        text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                     sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                     sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                     sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 6, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output reg done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n// State definitions\nlocalparam IDLE         = 0;\nlocalparam KEY_LOAD     = 1;\nlocalparam KEY_EXPANSION= 2;\nlocalparam KEY_STORED   = 3;\nlocalparam INITIAL_ROUND= 4;\nlocalparam STANDARD_ROUND=5;\nlocalparam FINAL_ROUND  = 6;\nlocalparam DONE_STATE   = 7;\n\nreg [2:0] state;\nreg [3:0] dcnt;\nreg [3:0] kcnt;\nreg [127:0] text_in_r;\nreg [7:0] sa [0:3][0:3];\nreg [127:0] kb [10:0];\nreg ld_r;\n\nwire [31:0] wo_0, wo_1, wo_2, wo_3;\nwire [127:0] round_key = {wo_3, wo_2, wo_1, wo_0};\nwire kb_ld = (state == KEY_EXPANSION);\nwire [3:0] key_index = 10 - dcnt;\n\n// Key expansion module\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(wo_0),\n    .wo_1(wo_1),\n    .wo_2(wo_2),\n    .wo_3(wo_3)\n);\n\n// Inverse S-box instances\nwire [7:0] sub_bytes [0:3][0:3];\ngenvar i, j;\ngenerate\n    for (i=0; i<4; i=i+1) begin : row\n        for (j=0; j<4; j=j+1) begin : col\n            aes_inv_sbox sbox_inst(\n                .a(sa[i][j]),\n                .b(sub_bytes[i][j])\n            );\n        end\n    end\nendgenerate\n\n// State machine and control logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        dcnt <= 0;\n        kcnt <= 10;\n        ld_r <= 0;\n        done <= 0;\n    end else begin\n        ld_r <= ld;\n        case(state)\n            IDLE: begin\n                if (kld) state <= KEY_LOAD;\n                else if (ld) state <= INITIAL_ROUND;\n            end\n            KEY_LOAD: state <= KEY_EXPANSION;\n            KEY_EXPANSION: begin\n                if (kcnt == 0) state <= KEY_STORED;\n                else kcnt <= kcnt - 1;\n            end\n            KEY_STORED: if (ld) state <= INITIAL_ROUND;\n            INITIAL_ROUND: begin\n                dcnt <= dcnt + 1;\n                state <= STANDARD_ROUND;\n            end\n            STANDARD_ROUND: begin\n                if (dcnt == 10) state <= FINAL_ROUND;\n                else dcnt <= dcnt + 1;\n            end\n            FINAL_ROUND: begin\n                dcnt <= 0;\n                state <= DONE_STATE;\n            end\n            DONE_STATE: begin\n                done <= 1;\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// Key buffer loading\nalways @(posedge clk) begin\n    if (kb_ld) begin\n        kb[kcnt] <= round_key;\n    end\nend\n\n// Data processing\nalways @(posedge clk) begin\n    if (ld) begin\n        text_in_r <= text_in;\n        // Initialize state matrix with AddRoundKey\n        {sa[3][3], sa[2][3], sa[1][3], sa[0][3],\n         sa[3][2], sa[2][2], sa[1][2], sa[0][2],\n         sa[3][1], sa[2][1], sa[1][1], sa[0][1],\n         sa[3][0], sa[2][0], sa[1][0], sa[0][0]} <= text_in_r ^ kb[10];\n    end else if (state == STANDARD_ROUND || state == FINAL_ROUND) begin\n        // InvShiftRows\n        sa[0][0] <= sa[0][0];\n        sa[0][1] <= sa[0][1];\n        sa[0][2] <= sa[0][2];\n        sa[0][3] <= sa[0][3];\n        \n        sa[1][0] <= sa[1][3];\n        sa[1][1] <= sa[1][0];\n        sa[1][2] <= sa[1][1];\n        sa[1][3] <= sa[1][2];\n        \n        sa[2][0] <= sa[2][2];\n        sa[2][1] <= sa[2][3];\n        sa[2][2] <= sa[2][0];\n        sa[2][3] <= sa[2][1];\n        \n        sa[3][0] <= sa[3][1];\n        sa[3][1] <= sa[3][2];\n        sa[3][2] <= sa[3][3];\n        sa[3][3] <= sa[3][0];\n        \n        // InvSubBytes\n        for (int i=0; i<4; i++) begin\n            for (int j=0; j<4; j++) begin\n                sa[i][j] <= sub_bytes[i][j];\n            end\n        end\n        \n        // AddRoundKey\n        {sa[3][3], sa[2][3], sa[1][3], sa[0][3],\n         sa[3][2], sa[2][2], sa[1][2], sa[0][2],\n         sa[3][1], sa[2][1], sa[1][1], sa[0][1],\n         sa[3][0], sa[2][0], sa[1][0], sa[0][0]} <= {sa[3][3], sa[2][3], sa[1][3], sa[0][3],\n         sa[3][2], sa[2][2], sa[1][2], sa[0][2],\n         sa[3][1], sa[2][1], sa[1][1], sa[0][1],\n         sa[3][0], sa[2][0], sa[1][0], sa[0][0]} ^ kb[key_index];\n        \n        // InvMixColumns (except final round)\n        if (state != FINAL_ROUND) begin\n            // Implement InvMixColumns here using GF multipliers\n            // (Implementation of pmul functions required)\n        end\n    end\nend\n\n// Output mapping\nalways @(posedge clk) begin\n    if (state == DONE_STATE) begin\n        text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                    sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                    sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                    sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n    end\nend\n\nendmodule\n\n// Key expansion submodule\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n    // Key expansion implementation required\nendmodule\n\n// Inverse S-box submodule\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n    // S-box lookup table implementation required\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 7, "code": "module aes_inv_cipher_top(\n    input               clk,\n    input               rst,\n    input               kld,\n    input               ld,\n    output reg          done,\n    input       [127:0] key,\n    input       [127:0] text_in,\n    output reg  [127:0] text_out\n);\n\n// Register declarations\nreg [127:0] text_in_r;\nreg [7:0]   sa [0:3][0:3];\nreg [3:0]   dcnt;\nreg [127:0] kb [10:0];\nreg [3:0]   kcnt;\nreg         ld_r;\n\n// Wire declarations\nwire [127:0] w;\nwire [31:0]  wo_0, wo_1, wo_2, wo_3;\nwire [7:0]   sa_sr [0:3][0:3];\nwire [7:0]   sa_sub [0:3][0:3];\nwire [7:0]   sa_ark [0:3][0:3];\nwire [7:0]   sa_next [0:3][0:3];\n\n// Key expansion module instantiation\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(wo_0),\n    .wo_1(wo_1),\n    .wo_2(wo_2),\n    .wo_3(wo_3)\n);\n\n// Inverse S-box instances\ngenvar i, j;\ngenerate\n    for (i=0; i<4; i=i+1) begin : row\n        for (j=0; j<4; j=j+1) begin : col\n            aes_inv_sbox inv_sbox_inst(\n                .a(sa_sr[i][j]),\n                .b(sa_sub[i][j])\n            );\n        end\n    end\nendgenerate\n\n// State machine states\ntypedef enum {\n    IDLE, KeyLoad, KeyExpansion, KeyStored,\n    InitialRound, StandardRound, FinalRound, Done\n} state_t;\nreg [3:0] state;\n\n// Key buffer control\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        kcnt <= 4'hA;\n    end else if (state == KeyExpansion) begin\n        if (kcnt > 0) kcnt <= kcnt - 1;\n    end\nend\n\n// Key buffer loading\nalways @(posedge clk) begin\n    if (state == KeyExpansion) begin\n        kb[kcnt] <= {wo_3, wo_2, wo_1, wo_0};\n    end\nend\n\n// State machine transitions\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        dcnt <= 0;\n        done <= 0;\n        ld_r <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (kld) state <= KeyLoad;\n                else if (ld) begin\n                    text_in_r <= text_in;\n                    state <= InitialRound;\n                    dcnt <= 0;\n                    ld_r <= 1;\n                end\n            end\n            KeyLoad: state <= KeyExpansion;\n            KeyExpansion: if (kcnt == 0) state <= KeyStored;\n            KeyStored: if (ld) state <= InitialRound;\n            InitialRound: begin\n                state <= StandardRound;\n                dcnt <= dcnt + 1;\n                ld_r <= 0;\n            end\n            StandardRound: begin\n                if (dcnt == 10) state <= FinalRound;\n                else dcnt <= dcnt + 1;\n            end\n            FinalRound: begin\n                state <= Done;\n                dcnt <= dcnt + 1;\n            end\n            Done: begin\n                done <= 1;\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// InvShiftRows transformation\nassign sa_sr[0][0] = sa[0][0];\nassign sa_sr[0][1] = sa[0][1];\nassign sa_sr[0][2] = sa[0][2];\nassign sa_sr[0][3] = sa[0][3];\nassign sa_sr[1][0] = sa[1][3];\nassign sa_sr[1][1] = sa[1][0];\nassign sa_sr[1][2] = sa[1][1];\nassign sa_sr[1][3] = sa[1][2];\nassign sa_sr[2][0] = sa[2][2];\nassign sa_sr[2][1] = sa[2][3];\nassign sa_sr[2][2] = sa[2][0];\nassign sa_sr[2][3] = sa[2][1];\nassign sa_sr[3][0] = sa[3][1];\nassign sa_sr[3][1] = sa[3][2];\nassign sa_sr[3][2] = sa[3][3];\nassign sa_sr[3][3] = sa[3][0];\n\n// AddRoundKey transformation\nwire [127:0] round_key = kb[dcnt];\ngenerate\n    for (i=0; i<4; i=i+1) begin\n        for (j=0; j<4; j=j+1) begin\n            assign sa_ark[i][j] = sa_sub[i][j] ^ round_key[127 - (i*32 + j*8 + 7) -: 8];\n        end\n    end\nendgenerate\n\n// InvMixColumns transformation\ngenerate\n    for (j=0; j<4; j=j+1) begin : mix_col\n        wire [7:0] b0 = sa_ark[0][j];\n        wire [7:0] b1 = sa_ark[1][j];\n        wire [7:0] b2 = sa_ark[2][j];\n        wire [7:0] b3 = sa_ark[3][j];\n        \n        assign sa_next[0][j] = pmul_e(b0) ^ pmul_b(b1) ^ pmul_d(b2) ^ pmul_9(b3);\n        assign sa_next[1][j] = pmul_9(b0) ^ pmul_e(b1) ^ pmul_b(b2) ^ pmul_d(b3);\n        assign sa_next[2][j] = pmul_d(b0) ^ pmul_9(b1) ^ pmul_e(b2) ^ pmul_b(b3);\n        assign sa_next[3][j] = pmul_b(b0) ^ pmul_d(b1) ^ pmul_9(b2) ^ pmul_e(b3);\n    end\nendgenerate\n\n// State matrix update\nalways @(posedge clk) begin\n    if (rst) begin\n        for (integer i=0; i<4; i=i+1)\n            for (integer j=0; j<4; j=j+1)\n                sa[i][j] <= 0;\n    end else if (ld_r) begin\n        // Initial load with AddRoundKey\n        sa[0][0] <= text_in_r[127:120] ^ round_key[127:120];\n        sa[1][0] <= text_in_r[119:112] ^ round_key[119:112];\n        // ... (similar mapping for all state elements)\n    end else if (state == StandardRound) begin\n        // Apply InvMixColumns\n        for (integer i=0; i<4; i=i+1)\n            for (integer j=0; j<4; j=j+1)\n                sa[i][j] <= sa_next[i][j];\n    end else if (state == FinalRound) begin\n        // Bypass InvMixColumns\n        for (integer i=0; i<4; i=i+1)\n            for (integer j=0; j<4; j=j+1)\n                sa[i][j] <= sa_ark[i][j];\n    end\nend\n\n// Output mapping\nalways @(posedge clk) begin\n    if (state == Done) begin\n        text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                     sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                     sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                     sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 1, "code": "module aes_key_expand_128 (\n    input         clk,\n    input         kld,\n    input  [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [31:0] w0, w1, w2, w3;\n\n// Round constant generation\nwire [31:0] rcon;\naes_rcon rcon_inst (\n    .clk(clk),\n    .kld(kld),\n    .out(rcon)\n);\n\n// RotWord and SubWord transformations\nwire [31:0] rot_word = {w3[23:0], w3[31:24]};\n\nwire [7:0] sbox_out [0:3];\naes_sbox sbox3 (.a(rot_word[31:24]), .b(sbox_out[0]));\naes_sbox sbox2 (.a(rot_word[23:16]), .b(sbox_out[1]));\naes_sbox sbox1 (.a(rot_word[15:8]),  .b(sbox_out[2]));\naes_sbox sbox0 (.a(rot_word[7:0]),   .b(sbox_out[3]));\n\nwire [31:0] sub_word = {sbox_out[0], sbox_out[1], sbox_out[2], sbox_out[3]};\nwire [31:0] t = sub_word ^ rcon;\n\n// Next word calculations\nwire [31:0] w0_next = kld ? key[127:96] : w0 ^ t;\nwire [31:0] w1_next = kld ? key[95:64]  : w1 ^ w0_next;\nwire [31:0] w2_next = kld ? key[63:32]  : w2 ^ w1_next;\nwire [31:0] w3_next = kld ? key[31:0]   : w3 ^ w2_next;\n\n// Register updates\nalways @(posedge clk) begin\n    w0 <= w0_next;\n    w1 <= w1_next;\n    w2 <= w2_next;\n    w3 <= w3_next;\nend\n\nassign wo_0 = w0;\nassign wo_1 = w1;\nassign wo_2 = w2;\nassign wo_3 = w3;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 8, "code": "module aes_inv_cipher_top(\n    input         clk,\n    input         rst,\n    input         kld,\n    input         ld,\n    output        done,\n    input  [127:0] key,\n    input  [127:0] text_in,\n    output [127:0] text_out\n);\n\n// State machine parameters\nlocalparam IDLE         = 4'h0;\nlocalparam KEY_LOAD     = 4'h1;\nlocalparam KEY_EXPAND   = 4'h2;\nlocalparam KEY_STORED   = 4'h3;\nlocalparam INITIAL_ROUND= 4'h4;\nlocalparam STANDARD_ROUND=4'h5;\nlocalparam FINAL_ROUND  = 4'h6;\nlocalparam DONE_STATE   = 4'h7;\n\nreg [3:0] state;\nreg [3:0] next_state;\n\n// Internal registers\nreg [127:0] text_in_r;\nreg [7:0] sa [0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb [10:0];\nreg [3:0] kcnt;\nreg ld_r;\nreg [127:0] text_out_reg;\n\n// Key expansion interface\nwire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n// Intermediate signals\nwire [7:0] sa_sub [0:3][0:3];\nwire [7:0] sa_shift [0:3][0:3];\nwire [7:0] sa_ark [0:3][0:3];\nwire [7:0] sa_mix [0:3][0:3];\nwire [127:0] round_key;\nreg  [127:0] sa_next;\n\n// Key expansion module\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(wo_0),\n    .wo_1(wo_1),\n    .wo_2(wo_2),\n    .wo_3(wo_3)\n);\n\n// Generate 16 inverse S-boxes\ngenvar i, j;\ngenerate\n    for (i=0; i<4; i=i+1) begin : row\n        for (j=0; j<4; j=j+1) begin : col\n            aes_inv_sbox sbox_inst(\n                .a(sa[i][j]),\n                .b(sa_sub[i][j])\n            );\n        end\n    end\nendgenerate\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) state <= IDLE;\n    else state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        IDLE:          next_state = (kld) ? KEY_LOAD : (ld ? KEY_STORED : IDLE);\n        KEY_LOAD:      next_state = KEY_EXPAND;\n        KEY_EXPAND:    next_state = (kcnt == 0) ? KEY_STORED : KEY_EXPAND;\n        KEY_STORED:    next_state = (ld) ? INITIAL_ROUND : KEY_STORED;\n        INITIAL_ROUND: next_state = STANDARD_ROUND;\n        STANDARD_ROUND:next_state = (dcnt == 10) ? FINAL_ROUND : STANDARD_ROUND;\n        FINAL_ROUND:   next_state = (dcnt == 11) ? DONE_STATE : FINAL_ROUND;\n        DONE_STATE:    next_state = IDLE;\n        default:       next_state = IDLE;\n    endcase\nend\n\n// Key buffer loading\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        kcnt <= 4'hA;\n    end else if (state == KEY_EXPAND) begin\n        kb[kcnt] <= {wo_3, wo_2, wo_1, wo_0};\n        kcnt <= kcnt - 1;\n    end\nend\n\n// Data path\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        text_in_r <= 0;\n        ld_r <= 0;\n        dcnt <= 0;\n        sa_next <= 0;\n        text_out_reg <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (ld) text_in_r <= text_in;\n                ld_r <= ld;\n            end\n            \n            KEY_STORED: begin\n                if (ld) begin\n                    // Map text_in_r to state matrix\n                    {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                     sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                     sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                     sa[0][3], sa[1][3], sa[2][3], sa[3][3]} <= text_in_r ^ kb[10];\n                    dcnt <= 1;\n                end\n            end\n            \n            INITIAL_ROUND: begin\n                // InvShiftRows & InvSubBytes\n                {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                 sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                 sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                 sa[0][3], sa[1][3], sa[2][3], sa[3][3]} <= sa_shift;\n                dcnt <= dcnt + 1;\n            end\n            \n            STANDARD_ROUND: begin\n                // Apply InvMixColumns\n                sa_next <= sa_mix;\n                dcnt <= dcnt + 1;\n            end\n            \n            FINAL_ROUND: begin\n                // Bypass InvMixColumns\n                text_out_reg <= {sa_ark[0][0], sa_ark[1][0], sa_ark[2][0], sa_ark[3][0],\n                                sa_ark[0][1], sa_ark[1][1], sa_ark[2][1], sa_ark[3][1],\n                                sa_ark[0][2], sa_ark[1][2], sa_ark[2][2], sa_ark[3][2],\n                                sa_ark[0][3], sa_ark[1][3], sa_ark[2][3], sa_ark[3][3]};\n                dcnt <= dcnt + 1;\n            end\n            \n            DONE_STATE: begin\n                dcnt <= 0;\n            end\n        endcase\n    end\nend\n\n// InvShiftRows transformation\nassign sa_shift[0][0] = sa_sub[0][0];\nassign sa_shift[0][1] = sa_sub[0][1];\nassign sa_shift[0][2] = sa_sub[0][2];\nassign sa_shift[0][3] = sa_sub[0][3];\n\nassign sa_shift[1][0] = sa_sub[1][3];\nassign sa_shift[1][1] = sa_sub[1][0];\nassign sa_shift[1][2] = sa_sub[1][1];\nassign sa_shift[1][3] = sa_sub[1][2];\n\nassign sa_shift[2][0] = sa_sub[2][2];\nassign sa_shift[2][1] = sa_sub[2][3];\nassign sa_shift[2][2] = sa_sub[2][0];\nassign sa_shift[2][3] = sa_sub[2][1];\n\nassign sa_shift[3][0] = sa_sub[3][1];\nassign sa_shift[3][1] = sa_sub[3][2];\nassign sa_shift[3][2] = sa_sub[3][3];\nassign sa_shift[3][3] = sa_sub[3][0];\n\n// AddRoundKey\nassign round_key = kb[10 - dcnt];\ngenerate\n    for (i=0; i<4; i=i+1) begin\n        for (j=0; j<4; j=j+1) begin\n            assign sa_ark[i][j] = sa_shift[i][j] ^ round_key[127 - (i*32 + j*8) -:8];\n        end\n    end\nendgenerate\n\n// InvMixColumns (simplified representation)\n// Note: Actual GF multiplication implementation required\nfunction [7:0] pmul_e(input [7:0] b);\n    // Implementation of multiply by 0x0E\nendfunction\n\nfunction [7:0] pmul_b(input [7:0] b);\n    // Implementation of multiply by 0x0B\nendfunction\n\nfunction [7:0] pmul_d(input [7:0] b);\n    // Implementation of multiply by 0x0D\nendfunction\n\nfunction [7:0] pmul_9(input [7:0] b);\n    // Implementation of multiply by 0x09\nendfunction\n\ngenerate\n    for (j=0; j<4; j=j+1) begin : mix_col\n        wire [7:0] s0 = sa_ark[0][j];\n        wire [7:0] s1 = sa_ark[1][j];\n        wire [7:0] s2 = sa_ark[2][j];\n        wire [7:0] s3 = sa_ark[3][j];\n        \n        assign sa_mix[0][j] = pmul_e(s0) ^ pmul_b(s1) ^ pmul_d(s2) ^ pmul_9(s3);\n        assign sa_mix[1][j] = pmul_9(s0) ^ pmul_e(s1) ^ pmul_b(s2) ^ pmul_d(s3);\n        assign sa_mix[2][j] = pmul_d(s0) ^ pmul_9(s1) ^ pmul_e(s2) ^ pmul_b(s3);\n        assign sa_mix[3][j] = pmul_b(s0) ^ pmul_d(s1) ^ pmul_9(s2) ^ pmul_e(s3);\n    end\nendgenerate\n\nassign done = (state == DONE_STATE);\nassign text_out = text_out_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 9, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output reg done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n// State matrix registers\nreg [7:0] sa [0:3][0:3];\nreg [7:0] sa_next [0:3][0:3];\n\n// Key buffer and counters\nreg [127:0] kb [10:0];\nreg [3:0] kcnt;\nreg [3:0] dcnt;\n\n// Control registers\nreg ld_r;\nreg [2:0] state;\n\n// Key expansion wires\nwire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n// Intermediate signals\nwire [127:0] w;\nreg [127:0] sa_ark;\nreg [127:0] sa_mix [0:3];\n\n// Inverse S-box instances\nwire [7:0] sbox_out [0:3][0:3];\ngenvar i, j;\ngenerate\n    for (i=0; i<4; i=i+1) begin : sbox_row\n        for (j=0; j<4; j=j+1) begin : sbox_col\n            aes_inv_sbox u_sbox(.a(sa[i][j]), .b(sbox_out[i][j]));\n        end\n    end\nendgenerate\n\n// Key expansion module\naes_key_expand_128 key_expand (\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(wo_0),\n    .wo_1(wo_1),\n    .wo_2(wo_2),\n    .wo_3(wo_3)\n);\n\n// FSM states\nlocalparam [2:0]\n    IDLE        = 3'd0,\n    KEY_LOAD    = 3'd1,\n    KEY_EXPAND  = 3'd2,\n    KEY_STORED  = 3'd3,\n    INITIAL     = 3'd4,\n    ROUND       = 3'd5,\n    FINAL       = 3'd6,\n    DONE_STATE  = 3'd7;\n\n// Key buffer loading\nalways @(posedge clk) begin\n    if (rst) begin\n        kcnt <= 4'hA;\n    end else if (state == KEY_EXPAND) begin\n        kb[kcnt] <= {wo_3, wo_2, wo_1, wo_0};\n        kcnt <= kcnt - 1;\n    end\nend\n\n// FSM transitions\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        dcnt <= 0;\n        done <= 0;\n        ld_r <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (kld) state <= KEY_LOAD;\n                else if (ld) begin\n                    ld_r <= 1;\n                    state <= INITIAL;\n                end\n            end\n            KEY_LOAD: state <= KEY_EXPAND;\n            KEY_EXPAND: begin\n                if (kcnt == 0) state <= KEY_STORED;\n            end\n            KEY_STORED: begin\n                if (ld) state <= INITIAL;\n            end\n            INITIAL: begin\n                dcnt <= dcnt + 1;\n                state <= ROUND;\n            end\n            ROUND: begin\n                if (dcnt == 10) state <= FINAL;\n                else dcnt <= dcnt + 1;\n            end\n            FINAL: begin\n                state <= DONE_STATE;\n                done <= 1;\n            end\n            DONE_STATE: begin\n                done <= 0;\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// InvShiftRows and AddRoundKey\nalways @(*) begin\n    // InvShiftRows\n    // Row 0: No shift\n    // Row 1: Right shift 3\n    // Row 2: Right shift 2\n    // Row 3: Right shift 1\n    // Implementation omitted for brevity\n\n    // AddRoundKey\n    sa_ark = {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n              sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n              sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n              sa[0][3], sa[1][3], sa[2][3], sa[3][3]} ^ kb[dcnt];\nend\n\n// InvMixColumns (combinational)\nfunction [7:0] pmul_e(input [7:0] b);\n    // Implementation of multiplication by 0x0E\nendfunction\n\nfunction [7:0] pmul_b(input [7:0] b);\n    // Implementation of multiplication by 0x0B\nendfunction\n\nfunction [7:0] pmul_d(input [7:0] b);\n    // Implementation of multiplication by 0x0D\nendfunction\n\nfunction [7:0] pmul_9(input [7:0] b);\n    // Implementation of multiplication by 0x09\nendfunction\n\nalways @(*) begin\n    // Apply InvMixColumns to each column\n    // Implementation omitted for brevity\nend\n\n// State matrix update\nalways @(posedge clk) begin\n    if (rst) begin\n        // Reset state matrix\n    end else if (ld_r) begin\n        // Load initial state\n    end else if (state == ROUND || state == FINAL) begin\n        // Update state matrix\n    end\nend\n\n// Output mapping\nalways @(posedge clk) begin\n    if (state == DONE_STATE) begin\n        text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                     sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                     sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                     sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 2, "code": "module aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\nreg [3:0] rcnt;\n\nalways @(posedge clk) begin\n    if (kld)\n        rcnt <= 4'b0;\n    else\n        rcnt <= rcnt + 1;\nend\n\nalways @(posedge clk) begin\n    case (rcnt)\n        4'd0:  out <= 32'h01000000;\n        4'd1:  out <= 32'h02000000;\n        4'd2:  out <= 32'h04000000;\n        4'd3:  out <= 32'h08000000;\n        4'd4:  out <= 32'h10000000;\n        4'd5:  out <= 32'h20000000;\n        4'd6:  out <= 32'h40000000;\n        4'd7:  out <= 32'h80000000;\n        4'd8:  out <= 32'h1B000000;\n        4'd9:  out <= 32'h36000000;\n        default: out <= 32'h00000000;\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 3, "code": "module aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\nreg [3:0] rcnt;\n\nalways @(posedge clk) begin\n    if (kld)\n        rcnt <= 4'b0;\n    else\n        rcnt <= rcnt + 1;\nend\n\nalways @(posedge clk) begin\n    case (rcnt)\n        4'd0:  out <= 32'h01000000;\n        4'd1:  out <= 32'h02000000;\n        4'd2:  out <= 32'h04000000;\n        4'd3:  out <= 32'h08000000;\n        4'd4:  out <= 32'h10000000;\n        4'd5:  out <= 32'h20000000;\n        4'd6:  out <= 32'h40000000;\n        4'd7:  out <= 32'h80000000;\n        4'd8:  out <= 32'h1B000000;\n        4'd9:  out <= 32'h36000000;\n        default: out <= 32'h00000000;\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 4, "code": "module aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n\nreg [3:0] rcnt;\nwire [3:0] rcnt_next = kld ? 4'd0 : (rcnt + 1'b1);\n\nalways @(posedge clk) begin\n    rcnt <= rcnt_next;\n    case (rcnt_next)\n        4'd0:  out <= 32'h01000000;\n        4'd1:  out <= 32'h02000000;\n        4'd2:  out <= 32'h04000000;\n        4'd3:  out <= 32'h08000000;\n        4'd4:  out <= 32'h10000000;\n        4'd5:  out <= 32'h20000000;\n        4'd6:  out <= 32'h40000000;\n        4'd7:  out <= 32'h80000000;\n        4'd8:  out <= 32'h1B000000;\n        4'd9:  out <= 32'h36000000;\n        default: out <= 32'h00000000;\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 2, "code": "module d_flip_flop (\n    input wire clk,\n    input wire reset_n,\n    input wire d,\n    output reg q\n);\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 2, "code": "module d_flip_flop (\n    input wire clk,\n    input wire reset,\n    input wire d,\n    output reg q\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) q <= 1'b0;\n    else       q <= d;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 10, "code": "module counter (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        count <= 4'b0;\n    else\n        count <= count + 4'b1;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 11, "code": "module d_flip_flop (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 5, "code": "module and_gate (\n    input  wire a,\n    input  wire b,\n    output wire y\n);\n    assign y = a & b;\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 1, "code": "module example_module (\n    input clk,\n    input reset_n,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        data_out <= 8'h00;\n    end\n    else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 3, "code": "module and_gate (\n    input  a,\n    input  b,\n    output y\n);\n    assign y = a & b;\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 2, "code": "module counter (\n    input clk,\n    input reset,\n    output reg [7:0] count\n);\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 8'b0;\n    end else begin\n        count <= count + 1;\n    end\nend\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 3, "code": "module mux2to1(\n    input wire a,\n    input wire b,\n    input wire sel,\n    output reg y\n);\n    always @(*) begin\n        y = sel ? b : a;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 1, "code": "module adder_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\nassign {Cout, Sum} = A + B + Cin;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 2, "code": "module d_ff (\n    input clk,\n    input rst_n,\n    input d,\n    output reg q\n);\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 3, "code": "module counter_4bit (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset)          // Synchronous reset\n        count <= 4'b0000;\n    else if (enable)    // Increment when enabled\n        count <= count + 1'b1;\n    // No else: counter maintains value when not enabled\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 6, "code": "module aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n\nreg [3:0] rcnt;\nwire [3:0] rcnt_next = kld ? 4'b0 : (rcnt + 1);\n\nalways @(posedge clk) begin\n    rcnt <= rcnt_next;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        out <= 32'h01000000;\n    end else begin\n        case (rcnt_next)\n            4'd0:  out <= 32'h01000000;\n            4'd1:  out <= 32'h02000000;\n            4'd2:  out <= 32'h04000000;\n            4'd3:  out <= 32'h08000000;\n            4'd4:  out <= 32'h10000000;\n            4'd5:  out <= 32'h20000000;\n            4'd6:  out <= 32'h40000000;\n            4'd7:  out <= 32'h80000000;\n            4'd8:  out <= 32'h1B000000;\n            4'd9:  out <= 32'h36000000;\n            default: out <= 32'h00000000;\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 7, "code": "module d_flip_flop (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 4, "code": "// Content missing - placeholder module\nmodule template (\n    input  wire clk,\n    input  wire rst,\n    output reg  out\n);\n    // Add hardware description here\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 3, "code": "module counter (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire [3:0] data_in,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 4'b0;\n    end else begin\n        if (load) begin\n            count <= data_in;\n        end else begin\n            count <= count + 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 4, "code": "module counter (\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 5, "code": "module d_ff (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 4, "code": "module counter (\n    input clk,\n    input reset,\n    output reg [7:0] count\n);\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 8'b0;\n    end\n    else begin\n        count <= count + 1;\n    end\nend\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 8, "code": "module counter_4bit (\n    input wire clk,\n    input wire reset_n,\n    input wire enable,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        count <= 4'b0000;\n    end\n    else if (enable) begin\n        count <= count + 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 5, "code": "module register_8bit (\n    input clk,\n    input rst,\n    input en,\n    input [7:0] d,\n    output reg [7:0] q\n);\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        q <= 8'b0;\n    end else if (en) begin\n        q <= d;\n    end\nend\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 4, "code": "module counter_4bit (\n    input clk,\n    input rst_n,\n    input en,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (!rst_n) begin\n        count <= 4'b0;\n    end\n    else begin\n        count <= en ? count + 1 : count;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 9, "code": "module d_flip_flop (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 5, "code": "module counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [7:0] count\n);\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count <= 8'b0;\n    end else if (enable) begin\n        count <= count + 1;\n    end\nend\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 12, "code": "module counter (\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n    always @(posedge clk) begin\n        if (reset) count <= 4'b0;\n        else count <= count + 1;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 13, "code": "module mux_2to1 (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n    assign out = sel ? b : a;\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 6, "code": "module adder_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n    \n    // Use concatenation to handle carry propagation\n    assign {cout, sum} = a + b + cin;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 6, "code": "module binary_counter (\n    input wire clk,          // Clock input\n    input wire rst_n,        // Active-low asynchronous reset\n    input wire enable,       // Count enable signal\n    output reg [3:0] count,  // 4-bit counter output\n    output wire tc           // Terminal count (high at max value)\n);\n\n// Terminal count assignment (combinational logic)\nassign tc = (count == 4'b1111);\n\n// Counter behavior with asynchronous reset\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin        // Active-low reset condition\n        count <= 4'b0000;\n    end else begin\n        if (enable) begin    // Increment only when enabled\n            count <= count + 1'b1;\n        end\n        // (Implicit else: maintain current count when disabled)\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 14, "code": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule ripple_adder_4bit(\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n    wire c0, c1, c2;\n    \n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c0));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c0), .sum(sum[1]), .cout(c1));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(c1), .sum(sum[2]), .cout(c2));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(c2), .sum(sum[3]), .cout(cout));\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 15, "code": "module adder_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n    wire [3:0] c;\n    \n    assign c[0] = cin;\n    \n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(c[0]), .sum(sum[0]), .cout(c[1]));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(c[1]), .sum(sum[1]), .cout(c[2]));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(c[2]), .sum(sum[2]), .cout(c[3]));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(c[3]), .sum(sum[3]), .cout(cout));\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 7, "code": "module sync_counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset)          // Synchronous reset\n        count <= 4'b0;\n    else if (enable)    // Increment when enabled\n        count <= count + 1'b1;\n    // No else: counter holds value when disabled\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 7, "code": "module adder_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 8, "code": "module d_flip_flop (\n    input wire clk,\n    input wire reset,\n    input wire d,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 9, "code": "module counter (\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        count <= 4'b0000;\n    else\n        count <= count + 1;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 6, "code": "module d_flip_flop (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 10, "code": "\n\nSince you haven't provided hardware specifications or functionality details, I cannot generate meaningful Verilog code. Please describe:  \n1. **Module purpose** (e.g., adder, FIFO, state machine)  \n2. **Input/Output ports** (names, bit-widths, types)  \n3. **Timing/Behavior** (synchronous/asynchronous, clock edges, protocols)  \n4. **Additional requirements** (reset behavior, power constraints, etc.)  \n\nExample format:  \n```\nDesign a 4-bit ripple-carry adder with:  \n- Inputs: a[3:0], b[3:0], cin  \n- Outputs: sum[3:0], cout  \n- Behavior: Combinational logic (no clock)  \n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 10, "code": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output p,\n    output g\n);\n    assign sum = a ^ b ^ cin;\n    assign p = a | b;\n    assign g = a & b;\nendmodule\n\nmodule carry_lookahead_unit(\n    input [3:0] p,\n    input [3:0] g,\n    input cin,\n    output [3:0] c,\n    output cout\n);\n    assign c[0] = g[0] | (p[0] & cin);\n    assign c[1] = g[1] | (p[1] & g[0]) | (p[1] & p[0] & cin);\n    assign c[2] = g[2] | (p[2] & g[1]) | (p[2] & p[1] & g[0]) | (p[2] & p[1] & p[0] & cin);\n    assign c[3] = g[3] | (p[3] & g[2]) | (p[3] & p[2] & g[1]) | (p[3] & p[2] & p[1] & g[0]) | (p[3] & p[2] & p[1] & p[0] & cin);\n    assign cout = c[3];\nendmodule\n\nmodule adder_4bit_cla(\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n    wire [3:0] p, g;\n    wire [3:0] c;\n\n    full_adder fa0(a[0], b[0], cin,  sum[0], p[0], g[0]);\n    full_adder fa1(a[1], b[1], c[0], sum[1], p[1], g[1]);\n    full_adder fa2(a[2], b[2], c[1], sum[2], p[2], g[2]);\n    full_adder fa3(a[3], b[3], c[2], sum[3], p[3], g[3]);\n\n    carry_lookahead_unit clu(p, g, cin, c, cout);\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 11, "code": "module adder_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 12, "code": "module ripple_carry_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input cin,\n    output [3:0] Sum,\n    output cout\n);\n    wire c0, c1, c2;\n    \n    full_adder fa0(.a(A[0]), .b(B[0]), .cin(cin), .sum(Sum[0]), .cout(c0));\n    full_adder fa1(.a(A[1]), .b(B[1]), .cin(c0), .sum(Sum[1]), .cout(c1));\n    full_adder fa2(.a(A[2]), .b(B[2]), .cin(c1), .sum(Sum[2]), .cout(c2));\n    full_adder fa3(.a(A[3]), .b(B[3]), .cin(c2), .sum(Sum[3]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 13, "code": "module bit_counter (\n    input clk,\n    input rst_n,        // Active-low asynchronous reset\n    input en,           // Synchronous enable\n    input load,         // Parallel load control\n    input [3:0] data_in,// Parallel load data\n    output reg [3:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin          // Asynchronous reset\n        count <= 4'b0;\n    end\n    else begin\n        if (load) begin        // Synchronous parallel load\n            count <= data_in;\n        end\n        else if (en) begin     // Synchronous increment\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 7, "code": "\n\nTo create the Verilog implementation, please provide:  \n1. **Functionality**: Describe the circuit's purpose (e.g., adder, counter, UART, PWM).  \n2. **I/O Ports**: List inputs/outputs (names, bit-widths, active-high/low signals like `clk`, `rst_n`).  \n3. **Behavior**: Specify timing requirements, state transitions (for FSMs), or data processing rules.  \n4. **Additional Constraints**: Include clock frequency, power considerations, or target FPGA/ASIC tools.  \n\nExample format:  \n```  \nDesign a 4-bit counter with:  \n- Inputs: clk (1-bit), rst_n (1-bit active-low), en (1-bit enable)  \n- Outputs: count (4-bit)  \n- Behavior: Synchronous reset, increment on rising clock edge when en=1.  \n```  \n\nI’ll generate the corresponding Verilog code once you provide these details!", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 8, "code": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule ripple_adder_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input CIN,\n    output [3:0] SUM,\n    output COUT\n);\n    wire [4:0] carry;\n    \n    assign carry[0] = CIN;\n    assign COUT = carry[4];\n    \n    generate\n        genvar i;\n        for(i=0; i<4; i=i+1) begin: adder_chain\n            full_adder fa(\n                .a(A[i]),\n                .b(B[i]),\n                .cin(carry[i]),\n                .sum(SUM[i]),\n                .cout(carry[i+1])\n            );\n        end\n    endgenerate\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 9, "code": "// Note: Specific hardware description was not provided.\n// Below is a placeholder example of a simple D flip-flop.\n\nmodule d_ff (\n    input wire clk,\n    input wire reset_n,\n    input wire d,\n    output reg q\n);\n\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 14, "code": "module empty_module ();\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 16, "code": "module sync_up_counter (\n    input clk,\n    input async_reset,\n    input enable,\n    output reg [3:0] count\n);\n    \nalways @(posedge clk or posedge async_reset) begin\n    if (async_reset) begin\n        count <= 4'b0;\n    end\n    else if (enable) begin\n        count <= count + 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 11, "code": "module sync_counter_4bit (\n    input clk,          // Clock input\n    input rst_n,        // Active-low asynchronous reset\n    input load,         // Parallel load control\n    input [3:0] data_in,// Parallel data input\n    output reg [3:0] count // Counter output\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin       // Asynchronous reset (active low)\n        count <= 4'b0000;\n    end\n    else if (load) begin    // Synchronous parallel load\n        count <= data_in;\n    end\n    else begin              // Synchronous increment\n        count <= count + 1'b1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 10, "code": "module HalfAdder(input a, b, output sum, carry);\n    assign sum = a ^ b;\n    assign carry = a & b;\nendmodule\n\nmodule FullAdder(input a, b, cin, output sum, cout);\n    wire c1, c2, s1;\n    \n    HalfAdder ha1(a, b, s1, c1);\n    HalfAdder ha2(s1, cin, sum, c2);\n    or(cout, c1, c2);\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 11, "code": "module example (\n  input  wire clk,\n  input  wire rst,\n  output reg  [7:0] counter\n);\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) counter <= 8'b0;\n  else     counter <= counter + 1;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 17, "code": "module counter_4bit (\n    input clk,          // Clock input\n    input rst_n,        // Active-low asynchronous reset\n    input enable,       // Count enable control\n    output reg [3:0] count  // 4-bit counter output\n);\n\n// Counter behavior with asynchronous reset\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin          // Active-low reset condition\n        count <= 4'b0;\n    end\n    else begin\n        if (enable) begin      // Increment only when enabled\n            count <= (count == 4'b1111) ? 4'b0000 : count + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 15, "code": "module adder_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n    \n    wire c0, c1, c2;\n    \n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c0));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(c0), .sum(sum[1]), .cout(c1));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(c1), .sum(sum[2]), .cout(c2));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(c2), .sum(sum[3]), .cout(cout));\n\nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    \n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\n    \nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 12, "code": "module counter_4bit (\n    input clk,\n    input rst_n,        // Active-low asynchronous reset\n    input enable,       // Count enable\n    input load,         // Parallel load control\n    input [3:0] data_in,// Parallel load data\n    output reg [3:0] count, // Counter output\n    output reg overflow // Overflow indicator\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 4'b0;\n        overflow <= 1'b0;\n    end\n    else begin\n        if (load) begin\n            count <= data_in;\n            overflow <= 1'b0;\n        end\n        else if (enable) begin\n            if (count == 4'b1111) begin\n                count <= 4'b0;\n                overflow <= 1'b1;\n            end\n            else begin\n                count <= count + 1;\n                overflow <= 1'b0;\n            end\n        end\n        else begin\n            overflow <= 1'b0;  // Clear overflow when not enabled\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 13, "code": "\n\nTo generate the Verilog code, I still need the following details:  \n\n**Please provide:**  \n1. **Module purpose**: What does the hardware block do? (e.g., \"4-bit ripple-carry adder,\" \"UART transmitter,\" \"7-segment display decoder\").  \n2. **Port specifications**: List inputs/outputs (e.g., `input clk, input [3:0] data, output reg tx`).  \n3. **Clock/reset behavior**: Is it synchronous or asynchronous? Active-high/low reset?  \n4. **Timing/protocols**: Any specific timing diagrams or standards to follow (e.g., AXI, SPI)?  \n\nExample format:  \n```  \nDesign a 4-bit counter with:  \n- Inputs: clk (posedge), rst_n (active-low async reset), enable  \n- Outputs: [3:0] count  \n- Behavior: Increments count on clock edge if enable=1. Resets to 0 on rst_n=0.  \n```  \n\nThis ensures the code matches your requirements precisely.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 8, "code": "\n\nSince you haven't provided hardware specifications yet, I cannot generate meaningful Verilog code. Please share details about:\n\n1. **Component Purpose** (e.g., \"A 32-bit FIFO buffer with fall-through capability\")\n2. **Inputs/Outputs** (names, bit-widths, direction, timing relationships)\n3. **Functionality** (e.g., \"Stores 8 entries, read/write pointer logic, full/empty flags\")\n4. **Timing Requirements** (clock domains, setup/hold times, propagation delays)\n5. **Control Signals** (reset, enable, read/write strobes)\n6. **Special Features** (error checking, synchronous/asynchronous operation)\n\nExample specification format:\n```\nDesign a 4-bit counter with:\n- Inputs: clk, rst_n, enable\n- Outputs: count [3:0]\n- Behavior: Increments on rising clock edge when enable=1\n           Synchronous active-low reset\n```\n\nProvide these details and I'll generate the corresponding Verilog implementation.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 12, "code": "module and_gate (\n    input  a,\n    input  b,\n    output y\n);\n    assign y = a & b;\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 5, "code": "// Error: Hardware specification missing\n// Please provide component details such as:\n// - Module name and port list\n// - Functional description (e.g., adder, counter, FSM)\n// - Timing requirements\n// - Control signals\n// - Data path specifications\n\n// Example valid request format:\n// \"Design a 4-bit ripple carry adder with inputs A[3:0], B[3:0], \n// cin and outputs S[3:0], cout using structural Verilog\"\n\n// Please provide specific hardware implementation requirements\n// to generate the corresponding Verilog code.", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 16, "code": "module basic_counter (\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 4'b0000;\n    end\n    else if (enable) begin\n        count <= count + 1'b1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 18, "code": "module d_flip_flop (\n  input clk,\n  input reset,\n  input d,\n  output reg q\n);\n  always @(posedge clk) begin\n    if (reset)\n      q <= 1'b0;\n    else\n      q <= d;\n  end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 17, "code": "module adder_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n    // Uses concatenation to handle 5-bit result (cout + sum)\n    assign {cout, sum} = a + b + cin;\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 9, "code": "module d_flipflop (\n    input clk,\n    input rst_n,\n    input d,\n    output reg q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) q <= 1'b0;\n        else        q <= d;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 18, "code": "module adder_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n// Combinational logic for 4-bit addition with carry\nassign {Cout, Sum} = A + B + Cin;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 14, "code": "module counter_16bit (\n    input clk,\n    input reset,    // Synchronous active-high reset\n    input enable,   // Count enable\n    output reg [15:0] count,\n    output tc       // Terminal count (max value indicator)\n);\n\n// Counter logic with synchronous reset\nalways @(posedge clk) begin\n    if (reset)\n        count <= 16'h0000;\n    else if (enable)\n        count <= count + 1'b1;\n    else\n        count <= count;  // Maintain current value when disabled\nend\n\n// Terminal count generation (combinational)\nassign tc = (count == 16'hFFFF);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 13, "code": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output s,\n    output cout\n);\n    assign s = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule ripple_adder_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n    wire c0, c1, c2;\n    \n    full_adder fa0(\n        .a(A[0]),\n        .b(B[0]),\n        .cin(Cin),\n        .s(S[0]),\n        .cout(c0)\n    );\n    \n    full_adder fa1(\n        .a(A[1]),\n        .b(B[1]),\n        .cin(c0),\n        .s(S[1]),\n        .cout(c1)\n    );\n    \n    full_adder fa2(\n        .a(A[2]),\n        .b(B[2]),\n        .cin(c1),\n        .s(S[2]),\n        .cout(c2)\n    );\n    \n    full_adder fa3(\n        .a(A[3]),\n        .b(B[3]),\n        .cin(c2),\n        .s(S[3]),\n        .cout(Cout)\n    );\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 19, "code": "module bit_counter (\n    input clk,\n    input rst_n,\n    input en,\n    output reg [3:0] count,\n    output max_tick\n);\n\n// Counter logic with synchronous reset\nalways @(posedge clk) begin\n    if (!rst_n) begin         // Active-low synchronous reset\n        count <= 4'b0;\n    end\n    else if (en) begin        // Increment when enabled\n        count <= count + 1;\n    end\nend\n\n// Maximum count detection\nassign max_tick = (count == 4'b1111);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 19, "code": "module counter_4bit (\n    input clk,          // Clock input\n    input rst_n,        // Active-low asynchronous reset\n    input load_en,      // Synchronous load enable\n    input cnt_en,       // Count enable\n    input up_down,      // Count direction (1=up, 0=down)\n    input [3:0] data_in,// Parallel load data\n    output reg [3:0] cnt // Counter output\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        cnt <= 4'b0;    // Async reset\n    end else begin\n        if (load_en) begin\n            cnt <= data_in; // Synchronous load\n        end else if (cnt_en) begin\n            cnt <= up_down ? cnt + 1 : cnt - 1; // Directional counting\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 15, "code": "module ripple_carry_adder_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\nwire [3:0] carry;\n\n// First full adder (LSB)\nassign sum[0] = a[0] ^ b[0] ^ cin;\nassign carry[0] = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);\n\n// Subsequent adders\ngenvar i;\ngenerate\n    for (i = 1; i < 4; i = i + 1) begin : adder_chain\n        assign sum[i] = a[i] ^ b[i] ^ carry[i-1];\n        assign carry[i] = (a[i] & b[i]) | (a[i] & carry[i-1]) | (b[i] & carry[i-1]);\n    end\nendgenerate\n\n// Final carry-out\nassign cout = carry[3];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 16, "code": "module template (\n    input  wire clk,\n    input  wire rst_n,\n    output reg  [7:0] counter\n);\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) counter <= 0;\n    else        counter <= counter + 1;\nend\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 6, "code": "module shift_reg_8bit (\n    input wire clk,\n    input wire reset,\n    input wire data_in,\n    output reg [7:0] data_out\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= {data_out[6:0], data_in};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 14, "code": "module aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [31:0] w0, w1, w2, w3;\nwire [31:0] w0_next, w1_next, w2_next, w3_next;\n\nwire [31:0] rcon;\naes_rcon rcon_inst (\n    .clk(clk),\n    .kld(kld),\n    .out(rcon)\n);\n\nwire [31:0] rot_word = {w3[23:0], w3[31:24]};\nwire [31:0] sub_word;\n\naes_sbox sbox3 (.a(rot_word[31:24]), .b(sub_word[31:24]));\naes_sbox sbox2 (.a(rot_word[23:16]), .b(sub_word[23:16]));\naes_sbox sbox1 (.a(rot_word[15:8]), .b(sub_word[15:8]));\naes_sbox sbox0 (.a(rot_word[7:0]), .b(sub_word[7:0]));\n\nassign w0_next = w0 ^ (sub_word ^ rcon) ^ w3;\nassign w1_next = w1 ^ w0_next;\nassign w2_next = w2 ^ w1_next;\nassign w3_next = w3 ^ w2_next;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        w0 <= key[127:96];\n        w1 <= key[95:64];\n        w2 <= key[63:32];\n        w3 <= key[31:0];\n    end else begin\n        w0 <= w0_next;\n        w1 <= w1_next;\n        w2 <= w2_next;\n        w3 <= w3_next;\n    end\nend\n\nassign wo_0 = w0;\nassign wo_1 = w1;\nassign wo_2 = w2;\nassign wo_3 = w3;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 10, "code": "module up_counter (\n    input clk,          // Clock signal\n    input reset,        // Synchronous reset (active high)\n    input enable,       // Counter enable (active high)\n    output reg [3:0] count // 4-bit counter output\n);\n\n// Counter behavior\nalways @(posedge clk) begin\n    if (reset)          // Synchronous reset\n        count <= 4'b0;\n    else if (enable)    // Increment when enabled\n        count <= count + 1'b1;\n    // No else: counter holds value when not enabled\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 7, "code": "module aes_sbox (\n    input  [7:0] a,\n    output reg [7:0] b\n);\n\nalways @(*) begin\n    case(a)\n        8'h00: b = 8'h63;\n        8'h01: b = 8'h7c;\n        8'h02: b = 8'h77;\n        8'h03: b = 8'h7b;\n        8'h04: b = 8'hf2;\n        8'h05: b = 8'h6b;\n        8'h06: b = 8'h6f;\n        8'h07: b = 8'hc5;\n        8'h08: b = 8'h30;\n        8'h09: b = 8'h01;\n        8'h0a: b = 8'h67;\n        8'h0b: b = 8'h2b;\n        8'h0c: b = 8'hfe;\n        8'h0d: b = 8'hd7;\n        8'h0e: b = 8'hab;\n        8'h0f: b = 8'h76;\n        8'h10: b = 8'hca;\n        8'h11: b = 8'h82;\n        8'h12: b = 8'hc9;\n        8'h13: b = 8'h7d;\n        8'h14: b = 8'hfa;\n        8'h15: b = 8'h59;\n        8'h16: b = 8'h47;\n        8'h17: b = 8'hf0;\n        8'h18: b = 8'had;\n        8'h19: b = 8'hd4;\n        8'h1a: b = 8'ha2;\n        8'h1b: b = 8'haf;\n        8'h1c: b = 8'h9c;\n        8'h1d: b = 8'ha4;\n        8'h1e: b = 8'h72;\n        8'h1f: b = 8'hc0;\n        8'h20: b = 8'hb7;\n        8'h21: b = 8'hfd;\n        8'h22: b = 8'h93;\n        8'h23: b = 8'h26;\n        8'h24: b = 8'h36;\n        8'h25: b = 8'h3f;\n        8'h26: b = 8'hf7;\n        8'h27: b = 8'hcc;\n        8'h28: b = 8'h34;\n        8'h29: b = 8'ha5;\n        8'h2a: b = 8'he5;\n        8'h2b: b = 8'hf1;\n        8'h2c: b = 8'h71;\n        8'h2d: b = 8'hd8;\n        8'h2e: b = 8'h31;\n        8'h2f: b = 8'h15;\n        8'h30: b = 8'h04;\n        8'h31: b = 8'hc7;\n        8'h32: b = 8'h23;\n        8'h33: b = 8'hc3;\n        8'h34: b = 8'h18;\n        8'h35: b = 8'h96;\n        8'h36: b = 8'h05;\n        8'h37: b = 8'h9a;\n        8'h38: b = 8'h07;\n        8'h39: b = 8'h12;\n        8'h3a: b = 8'h80;\n        8'h3b: b = 8'he2;\n        8'h3c: b = 8'heb;\n        8'h3d: b = 8'h27;\n        8'h3e: b = 8'hb2;\n        8'h3f: b = 8'h75;\n        8'h40: b = 8'h09;\n        8'h41: b = 8'h83;\n        8'h42: b = 8'h2c;\n        8'h43: b = 8'h1a;\n        8'h44: b = 8'h1b;\n        8'h45: b = 8'h6e;\n        8'h46: b = 8'h5a;\n        8'h47: b = 8'ha0;\n        8'h48: b = 8'h52;\n        8'h49: b = 8'h3b;\n        8'h4a: b = 8'hd6;\n        8'h4b: b = 8'hb3;\n        8'h4c: b = 8'h29;\n        8'h4d: b = 8'he3;\n        8'h4e: b = 8'h2f;\n        8'h4f: b = 8'h84;\n        8'h50: b = 8'h53;\n        8'h51: b = 8'hd1;\n        8'h52: b = 8'h00;\n        8'h53: b = 8'hed;\n        8'h54: b = 8'h20;\n        8'h55: b = 8'hfc;\n        8'h56: b = 8'hb1;\n        8'h57: b = 8'h5b;\n        8'h58: b = 8'h6a;\n        8'h59: b = 8'hcb;\n        8'h5a: b = 8'hbe;\n        8'h5b: b = 8'h39;\n        8'h5c: b = 8'h4a;\n        8'h5d: b = 8'h4c;\n        8'h5e: b = 8'h58;\n        8'h5f: b = 8'hcf;\n        8'h60: b = 8'hd0;\n        8'h61: b = 8'hef;\n        8'h62: b = 8'haa;\n        8'h63: b = 8'hfb;\n        8'h64: b = 8'h43;\n        8'h65: b = 8'h4d;\n        8'h66: b = 8'h33;\n        8'h67: b = 8'h85;\n        8'h68: b = 8'h45;\n        8'h69: b = 8'hf9;\n        8'h6a: b = 8'h02;\n        8'h6b: b = 8'h7f;\n        8'h6c: b = 8'h50;\n        8'h6d: b = 8'h3c;\n        8'h6e: b = 8'h9f;\n        8'h6f: b = 8'ha8;\n        8'h70: b = 8'h51;\n        8'h71: b = 8'ha3;\n        8'h72: b = 8'h40;\n        8'h73: b = 8'h8f;\n        8'h74: b = 8'h92;\n        8'h75: b = 8'h9d;\n        8'h76: b = 8'h38;\n        8'h77: b = 8'hf5;\n        8'h78: b = 8'hbc;\n        8'h79: b = 8'hb6;\n        8'h7a: b = 8'hda;\n        8'h7b: b = 8'h21;\n        8'h7c: b = 8'h10;\n        8'h7d: b = 8'hff;\n        8'h7e: b = 8'hf3;\n        8'h7f: b = 8'hd2;\n        8'h80: b = 8'hcd;\n        8'h81: b = 8'h0c;\n        8'h82: b = 8'h13;\n        8'h83: b = 8'hec;\n        8'h84: b = 8'h5f;\n        8'h85: b = 8'h97;\n        8'h86: b = 8'h44;\n        8'h87: b = 8'h17;\n        8'h88: b = 8'hc4;\n        8'h89: b = 8'ha7;\n        8'h8a: b = 8'h7e;\n        8'h8b: b = 8'h3d;\n        8'h8c: b = 8'h64;\n        8'h8d: b = 8'h5d;\n        8'h8e: b = 8'h19;\n        8'h8f: b = 8'h73;\n        8'h90: b = 8'h60;\n        8'h91: b = 8'h81;\n        8'h92: b = 8'h4f;\n        8'h93: b = 8'hdc;\n        8'h94: b = 8'h22;\n        8'h95: b = 8'h2a;\n        8'h96: b = 8'h90;\n        8'h97: b = 8'h88;\n        8'h98: b = 8'h46;\n        8'h99: b = 8'hee;\n        8'h9a: b = 8'hb8;\n        8'h9b: b = 8'h14;\n        8'h9c: b = 8'hde;\n        8'h9d: b = 8'h5e;\n        8'h9e: b = 8'h0b;\n        8'h9f: b = 8'hdb;\n        8'ha0: b = 8'he0;\n        8'ha1: b = 8'h32;\n        8'ha2: b = 8'h3a;\n        8'ha3: b = 8'h0a;\n        8'ha4: b = 8'h49;\n        8'ha5: b = 8'h06;\n        8'ha6: b = 8'h24;\n        8'ha7: b = 8'h5c;\n        8'ha8: b = 8'hc2;\n        8'ha9: b = 8'hd3;\n        8'haa: b = 8'hac;\n        8'hab: b = 8'h62;\n        8'hac: b = 8'h91;\n        8'had: b = 8'h95;\n        8'hae: b = 8'he4;\n        8'haf: b = 8'h79;\n        8'hb0: b = 8'he7;\n        8'hb1: b = 8'hc8;\n        8'hb2: b = 8'h37;\n        8'hb3: b = 8'h6d;\n        8'hb4: b = 8'h8d;\n        8'hb5: b = 8'hd5;\n        8'hb6: b = 8'h4e;\n        8'hb7: b = 8'ha9;\n        8'hb8: b = 8'h6c;\n        8'hb9: b = 8'h56;\n        8'hba: b = 8'hf4;\n        8'hbb: b = 8'hea;\n        8'hbc: b = 8'h65;\n        8'hbd: b = 8'h7a;\n        8'hbe: b = 8'hae;\n        8'hbf: b = 8'h08;\n        8'hc0: b = 8'hba;\n        8'hc1: b = 8'h78;\n        8'hc2: b = 8'h25;\n        8'hc3: b = 8'h2e;\n        8'hc4: b = 8'h1c;\n        8'hc5: b = 8'ha6;\n        8'hc6: b = 8'hb4;\n        8'hc7: b = 8'hc6;\n        8'hc8: b = 8'he8;\n        8'hc9: b = 8'hdd;\n        8'hca: b = 8'h74;\n        8'hcb: b = 8'h1f;\n        8'hcc: b = 8'h4b;\n        8'hcd: b = 8'hbd;\n        8'hce: b = 8'h8b;\n        8'hcf: b = 8'h8a;\n        8'hd0: b = 8'h70;\n        8'hd1: b = 8'h3e;\n        8'hd2: b = 8'hb5;\n        8'hd3: b = 8'h66;\n        8'hd4: b = 8'h48;\n        8'hd5: b = 8'h03;\n        8'hd6: b = 8'hf6;\n        8'hd7: b = 8'h0e;\n        8'hd8: b = 8'h61;\n        8'hd9: b = 8'h35;\n        8'hda: b = 8'h57;\n        8'hdb: b = 8'hb9;\n        8'hdc: b = 8'h86;\n        8'hdd: b = 8'hc1;\n        8'hde: b = 8'h1d;\n        8'hdf: b = 8'h9e;\n        8'he0: b = 8'he1;\n        8'he1: b = 8'hf8;\n        8'he2: b = 8'h98;\n        8'he3: b = 8'h11;\n        8'he4: b = 8'h69;\n        8'he5: b = 8'hd9;\n        8'he6: b = 8'h8e;\n        8'he7: b = 8'h94;\n        8'he8: b = 8'h9b;\n        8'he9: b = 8'h1e;\n        8'hea: b = 8'h87;\n        8'heb: b = 8'he9;\n        8'hec: b = 8'hce;\n        8'hed: b = 8'h55;\n        8'hee: b = 8'h28;\n        8'hef: b = 8'hdf;\n        8'hf0: b = 8'h8c;\n        8'hf1: b = 8'ha1;\n        8'hf2: b = 8'h89;\n        8'hf3: b = 8'h0d;\n        8'hf4: b = 8'hbf;\n        8'hf5: b = 8'he6;\n        8'hf6: b = 8'h42;\n        8'hf7: b = 8'h68;\n        8'hf8: b = 8'h41;\n        8'hf9: b = 8'h99;\n        8'hfa: b = 8'h2d;\n        8'hfb: b = 8'h0f;\n        8'hfc: b = 8'hb0;\n        8'hfd: b = 8'h54;\n        8'hfe: b = 8'hbb;\n        8'hff: b = 8'h16;\n    endcase\nend\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 11, "code": "module data_register (\n    input         clk,      // 100MHz clock\n    input         reset_n,  // Active-low asynchronous reset\n    input         enable,   // Data capture enable\n    input  [3:0]  data_in,  // 4-bit input data\n    output reg [3:0] data_out, // 4-bit registered output\n    output reg    data_valid  // Data valid indicator\n);\n\n// Register update logic\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        data_out <= 4'b0;\n        data_valid <= 1'b0;\n    end\n    else begin\n        // Capture data when enabled\n        if (enable) begin\n            data_out <= data_in;\n        end\n        \n        // Data valid follows enable with 1-cycle delay\n        data_valid <= enable;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 20, "code": "module PulseGenerator (\n    input clk,\n    input rst_n,\n    input enable,\n    input [31:0] pulse_interval,\n    input [31:0] pulse_width,\n    output reg pulse_out,\n    output status\n);\n\n// State definitions\nlocalparam [1:0]\n    IDLE = 2'b00,\n    PULSE_HIGH = 2'b01,\n    INTERVAL = 2'b10;\n\nreg [1:0] state_reg, next_state;\nreg [31:0] counter_reg;\n\n// State transition logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state_reg <= IDLE;\n        counter_reg <= 32'b0;\n    end\n    else begin\n        state_reg <= next_state;\n        counter_reg <= (state_reg != next_state) ? 32'b0 : counter_reg + 1;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    next_state = state_reg;\n    case (state_reg)\n        IDLE: begin\n            if (enable)\n                next_state = PULSE_HIGH;\n        end\n        PULSE_HIGH: begin\n            if (counter_reg >= pulse_width - 1)\n                next_state = INTERVAL;\n        end\n        INTERVAL: begin\n            if (counter_reg >= pulse_interval - 1)\n                next_state = enable ? PULSE_HIGH : IDLE;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        pulse_out <= 1'b0;\n    end\n    else begin\n        pulse_out <= (state_reg == PULSE_HIGH);\n    end\nend\n\nassign status = (state_reg == PULSE_HIGH);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 15, "code": "module aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [31:0] w0, w1, w2, w3;\n\nassign wo_0 = w0;\nassign wo_1 = w1;\nassign wo_2 = w2;\nassign wo_3 = w3;\n\nwire [31:0] rcon;\naes_rcon rcon_gen (\n    .clk(clk),\n    .kld(kld),\n    .out(rcon)\n);\n\nwire [31:0] rotated_word = {w3[23:0], w3[31:24]};\n\nwire [31:0] sub_word;\naes_sbox sbox3 (.a(rotated_word[31:24]), .b(sub_word[31:24]));\naes_sbox sbox2 (.a(rotated_word[23:16]), .b(sub_word[23:16]));\naes_sbox sbox1 (.a(rotated_word[15:8]),  .b(sub_word[15:8]));\naes_sbox sbox0 (.a(rotated_word[7:0]),   .b(sub_word[7:0]));\n\nwire [31:0] t = sub_word ^ rcon;\n\nwire [31:0] next_w0 = w0 ^ t;\nwire [31:0] next_w1 = w1 ^ next_w0;\nwire [31:0] next_w2 = w2 ^ next_w1;\nwire [31:0] next_w3 = w3 ^ next_w2;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        w0 <= key[127:96];\n        w1 <= key[95:64];\n        w2 <= key[63:32];\n        w3 <= key[31:0];\n    end else begin\n        w0 <= next_w0;\n        w1 <= next_w1;\n        w2 <= next_w2;\n        w3 <= next_w3;\n    end\nend\n\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n\nreg [3:0] counter;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        counter <= 4'h0;\n        out <= 32'h01000000;\n    end else begin\n        if (counter < 4'hA) begin\n            counter <= counter + 1;\n            out <= { (out[31:24] << 1) ^ (8'h1b & {8{out[31:24][7]}}), 24'h0 };\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 17, "code": "module adder_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input carry_in,\n    output [3:0] sum,\n    output carry_out\n);\n\n// Combinational logic for 4-bit addition with carry\nassign {carry_out, sum} = a + b + carry_in;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 18, "code": "module shift_register (\n    input wire clk,          // 100MHz clock\n    input wire rst_n,        // Active-low asynchronous reset\n    input wire load,         // Parallel load control\n    input wire [15:0] data_in,  // Parallel data input\n    input wire shift_in,     // Serial data input\n    output reg [15:0] data_out, // Parallel data output\n    output wire shift_out    // Serial data output\n);\n\n// Register implementation\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 16'h0000;  // Async reset\n    end else begin\n        if (load) begin\n            data_out <= data_in;  // Parallel load\n        end else begin\n            // Right shift operation with serial input\n            data_out <= {shift_in, data_out[15:1]};\n        end\n    end\nend\n\n// Continuous assignment for serial output (LSB)\nassign shift_out = data_out[0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 16, "code": "module adder_8bit (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum,\n    output cout\n);\n    assign {cout, sum} = a + b;\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 8, "code": "\n\nPlease provide the following details for your hardware design:  \n1. **Module Name**  \n2. **Input/Output Ports** (include names, directions, and bit-widths)  \n3. **Functional Behavior** (describe what the module does, timing requirements, etc.)  \n\nExample format:  \n```  \nModule: example_module  \nInputs: clk (1b), rst_n (1b), data_in (8b)  \nOutputs: data_out (8b)  \nFunction: Shifts input data by 1 bit every clock cycle when reset is inactive.  \n```  \n\nI’ll generate the Verilog code once you provide these specifications!", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 17, "code": "module [MODULE_NAME] (\n    input wire clk,       // Clock signal\n    input wire rst,       // Reset signal\n    input wire [WIDTH-1:0] data_in,  // Example input\n    output reg [WIDTH-1:0] data_out  // Example output\n);\n\n// Define parameters or states here\nparameter WIDTH = 8;\n\n// Describe hardware behavior here\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        data_out <= 0;\n    end\n    else begin\n        // Add your logic here\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 18, "code": "module PulseGenerator (\n    input clk,\n    input rst_n,\n    input start,\n    input [31:0] duration,\n    output reg pulse\n);\n\nreg [1:0] state;\nreg [31:0] counter;\nreg start_prev;\n\nlocalparam IDLE     = 2'b00;\nlocalparam COUNTING = 2'b01;\n\nwire start_rise = start && !start_prev;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= IDLE;\n        counter <= 0;\n        pulse <= 0;\n        start_prev <= 0;\n    end else begin\n        start_prev <= start;\n        case (state)\n            IDLE: begin\n                pulse <= 0;\n                if (start_rise) begin\n                    state <= COUNTING;\n                    counter <= duration;\n                end\n            end\n            \n            COUNTING: begin\n                if (start_rise) begin\n                    counter <= duration;\n                end\n                else if (counter > 0) begin\n                    counter <= counter - 1;\n                end\n\n                if (counter == 0) begin\n                    pulse <= 1;\n                    state <= IDLE;\n                end else begin\n                    pulse <= 0;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 19, "code": "module example_module (\n    input wire clk,\n    input wire rst,\n    input wire [7:0] data_in,\n    output reg [7:0] data_out\n);\n    // Default example: Registered output\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 8'h00;\n        end else begin\n            data_out <= data_in;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 12, "code": "module mux2to1(\n    input a,\n    input b,\n    input sel,\n    output reg out\n);\n    always @(*) begin\n        out = sel ? b : a;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 13, "code": "module d_flip_flop (\n    input wire clk,\n    input wire reset,\n    input wire d,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            q <= 1'b0;\n        else \n            q <= d;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_key_expand_128", "codeid": 20, "code": "module d_flip_flop (\n    input wire clk,\n    input wire reset_n,\n    input wire d,\n    output reg q\n);\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) q <= 1'b0;\n    else q <= d;\nend\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 14, "code": "module d_flip_flop (\n  input clk,\n  input reset,\n  input d,\n  output reg q\n);\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      q <= 1'b0;\n    end else begin\n      q <= d;\n    end\n  end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 15, "code": "module [MODULE_NAME] (\n    input [INPUT_BITS] [INPUT_NAME],\n    output [OUTPUT_BITS] [OUTPUT_NAME],\n    // Add other I/O ports\n);\n\n    // Declare internal registers/wires\n    reg [REG_BITS] [REG_NAME];\n    wire [WIRE_BITS] [WIRE_NAME];\n\n    // Combinational logic\n    assign [OUTPUT_NAME] = [LOGIC_EXPRESSION];\n\n    // Sequential logic\n    always @(posedge [CLOCK_NAME] or posedge [RESET_NAME]) begin\n        if ([RESET_NAME]) begin\n            // Reset logic\n        end\n        else begin\n            // Normal operation\n        end\n    end\n\n    // Add additional logic blocks\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 19, "code": "module binary_counter (\n    input wire clk,        // Clock input\n    input wire reset,      // Synchronous reset (active high)\n    input wire enable,     // Count enable (active high)\n    output reg [3:0] count,// 4-bit counter output\n    output wire terminal   // Terminal count (high at 15)\n);\n\n// Counter logic\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 4'b0000;  // Synchronous reset\n    end else if (enable) begin\n        count <= count + 1; // Increment when enabled\n    end\nend\n\n// Terminal count detection\nassign terminal = (count == 4'b1111); // High when count reaches 15\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 16, "code": "module simple_counter (\n    input wire clk,\n    input wire rst_n,\n    output reg [7:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 8'b0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_rcon", "codeid": 20, "code": "module template (\n    input        clk,      // Clock\n    input        rst_n,    // Active-low reset\n    input  [3:0] data_in,  // 4-bit input bus\n    output reg [3:0] data_out  // 4-bit registered output\n);\n\n// 4-bit register with asynchronous reset\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 4'b0;  // Reset output to 0\n    end else begin\n        data_out <= data_in;  // Pass-through input\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 17, "code": "module aes_inv_sbox (\n    input  [7:0] a,\n    output reg [7:0] b\n);\n\nalways @* begin\n    case (a)\n        8'h00: b = 8'h52;\n        8'h01: b = 8'h09;\n        8'h02: b = 8'h6a;\n        8'h03: b = 8'hd5;\n        8'h04: b = 8'h30;\n        8'h05: b = 8'h36;\n        8'h06: b = 8'ha5;\n        8'h07: b = 8'h38;\n        8'h08: b = 8'hbf;\n        8'h09: b = 8'h40;\n        8'h0a: b = 8'ha3;\n        8'h0b: b = 8'h9e;\n        8'h0c: b = 8'h81;\n        8'h0d: b = 8'hf3;\n        8'h0e: b = 8'hd7;\n        8'h0f: b = 8'hfb;\n        8'h10: b = 8'h7c;\n        8'h11: b = 8'he3;\n        8'h12: b = 8'h39;\n        8'h13: b = 8'h82;\n        8'h14: b = 8'h9b;\n        8'h15: b = 8'h2f;\n        8'h16: b = 8'hff;\n        8'h17: b = 8'h87;\n        8'h18: b = 8'h34;\n        8'h19: b = 8'h8e;\n        8'h1a: b = 8'h43;\n        8'h1b: b = 8'h44;\n        8'h1c: b = 8'hc4;\n        8'h1d: b = 8'hde;\n        8'h1e: b = 8'he9;\n        8'h1f: b = 8'hcb;\n        8'h20: b = 8'h54;\n        8'h21: b = 8'h7b;\n        8'h22: b = 8'h94;\n        8'h23: b = 8'h32;\n        8'h24: b = 8'ha6;\n        8'h25: b = 8'hc2;\n        8'h26: b = 8'h23;\n        8'h27: b = 8'h3d;\n        8'h28: b = 8'hee;\n        8'h29: b = 8'h4c;\n        8'h2a: b = 8'h95;\n        8'h2b: b = 8'h0b;\n        8'h2c: b = 8'h42;\n        8'h2d: b = 8'hfa;\n        8'h2e: b = 8'hc3;\n        8'h2f: b = 8'h4e;\n        8'h30: b = 8'h08;\n        8'h31: b = 8'h2e;\n        8'h32: b = 8'ha1;\n        8'h33: b = 8'h66;\n        8'h34: b = 8'h28;\n        8'h35: b = 8'hd9;\n        8'h36: b = 8'h24;\n        8'h37: b = 8'hb2;\n        8'h38: b = 8'h76;\n        8'h39: b = 8'h5b;\n        8'h3a: b = 8'ha2;\n        8'h3b: b = 8'h49;\n        8'h3c: b = 8'h6d;\n        8'h3d: b = 8'h8b;\n        8'h3e: b = 8'hd1;\n        8'h3f: b = 8'h25;\n        8'h40: b = 8'h72;\n        8'h41: b = 8'hf8;\n        8'h42: b = 8'hf6;\n        8'h43: b = 8'h64;\n        8'h44: b = 8'h86;\n        8'h45: b = 8'h68;\n        8'h46: b = 8'h98;\n        8'h47: b = 8'h16;\n        8'h48: b = 8'hd4;\n        8'h49: b = 8'ha4;\n        8'h4a: b = 8'h5c;\n        8'h4b: b = 8'hcc;\n        8'h4c: b = 8'h5d;\n        8'h4d: b = 8'h65;\n        8'h4e: b = 8'hb6;\n        8'h4f: b = 8'h92;\n        8'h50: b = 8'h6c;\n        8'h51: b = 8'h70;\n        8'h52: b = 8'h48;\n        8'h53: b = 8'h50;\n        8'h54: b = 8'hfd;\n        8'h55: b = 8'hed;\n        // ... remaining case items should follow the same pattern\n        default: b = 8'h00; // Handle undefined cases\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 9, "code": "module aes_sbox (\n    input  [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] b_reg;\n\nalways @(*) begin\n    case (a)\n        8'h00: b_reg = 8'h63;\n        8'h01: b_reg = 8'h7c;\n        8'h02: b_reg = 8'h77;\n        8'h03: b_reg = 8'h7b;\n        8'h04: b_reg = 8'hf2;\n        8'h05: b_reg = 8'h6b;\n        8'h06: b_reg = 8'h6f;\n        8'h07: b_reg = 8'hc5;\n        8'h08: b_reg = 8'h30;\n        8'h09: b_reg = 8'h01;\n        8'h0a: b_reg = 8'h67;\n        8'h0b: b_reg = 8'h2b;\n        8'h0c: b_reg = 8'hfe;\n        8'h0d: b_reg = 8'hd7;\n        8'h0e: b_reg = 8'hab;\n        8'h0f: b_reg = 8'h76;\n        8'h10: b_reg = 8'hca;\n        8'h11: b_reg = 8'h82;\n        8'h12: b_reg = 8'hc9;\n        8'h13: b_reg = 8'h7d;\n        8'h14: b_reg = 8'hfa;\n        8'h15: b_reg = 8'h59;\n        8'h16: b_reg = 8'h47;\n        8'h17: b_reg = 8'hf0;\n        8'h18: b_reg = 8'had;\n        8'h19: b_reg = 8'hd4;\n        8'h1a: b_reg = 8'ha2;\n        8'h1b: b_reg = 8'haf;\n        8'h1c: b_reg = 8'h9c;\n        8'h1d: b_reg = 8'ha4;\n        8'h1e: b_reg = 8'h72;\n        8'h1f: b_reg = 8'hc0;\n        8'h20: b_reg = 8'hb7;\n        8'h21: b_reg = 8'hfd;\n        8'h22: b_reg = 8'h93;\n        8'h23: b_reg = 8'h26;\n        8'h24: b_reg = 8'h36;\n        8'h25: b_reg = 8'h3f;\n        8'h26: b_reg = 8'hf7;\n        8'h27: b_reg = 8'hcc;\n        8'h28: b_reg = 8'h34;\n        8'h29: b_reg = 8'ha5;\n        8'h2a: b_reg = 8'he5;\n        8'h2b: b_reg = 8'hf1;\n        8'h2c: b_reg = 8'h71;\n        8'h2d: b_reg = 8'hd8;\n        8'h2e: b_reg = 8'h31;\n        8'h2f: b_reg = 8'h15;\n        8'h30: b_reg = 8'h04;\n        8'h31: b_reg = 8'hc7;\n        8'h32: b_reg = 8'h23;\n        8'h33: b_reg = 8'hc3;\n        8'h34: b_reg = 8'h18;\n        8'h35: b_reg = 8'h96;\n        8'h36: b_reg = 8'h05;\n        8'h37: b_reg = 8'h9a;\n        8'h38: b_reg = 8'h07;\n        8'h39: b_reg = 8'h12;\n        8'h3a: b_reg = 8'h80;\n        8'h3b: b_reg = 8'he2;\n        8'h3c: b_reg = 8'heb;\n        8'h3d: b_reg = 8'h27;\n        8'h3e: b_reg = 8'hb2;\n        8'h3f: b_reg = 8'h75;\n        8'h40: b_reg = 8'h09;\n        8'h41: b_reg = 8'h83;\n        8'h42: b_reg = 8'h2c;\n        8'h43: b_reg = 8'h1a;\n        8'h44: b_reg = 8'h1b;\n        8'h45: b_reg = 8'h6e;\n        8'h46: b_reg = 8'h5a;\n        8'h47: b_reg = 8'ha0;\n        8'h48: b_reg = 8'h52;\n        8'h49: b_reg = 8'h3b;\n        8'h4a: b_reg = 8'hd6;\n        8'h4b: b_reg = 8'hb3;\n        8'h4c: b_reg = 8'h29;\n        8'h4d: b_reg = 8'he3;\n        8'h4e: b_reg = 8'h2f;\n        8'h4f: b_reg = 8'h84;\n        8'h50: b_reg = 8'h53;\n        8'h51: b_reg = 8'hd1;\n        8'h52: b_reg = 8'h00;\n        8'h53: b_reg = 8'hed;\n        8'h54: b_reg = 8'h20;\n        8'h55: b_reg = 8'hfc;\n        8'h56: b_reg = 8'hb1;\n        8'h57: b_reg = 8'h5b;\n        8'h58: b_reg = 8'h6a;\n        8'h59: b_reg = 8'hcb;\n        8'h5a: b_reg = 8'hbe;\n        8'h5b: b_reg = 8'h39;\n        8'h5c: b_reg = 8'h4a;\n        8'h5d: b_reg = 8'h4c;\n        8'h5e: b_reg = 8'h58;\n        8'h5f: b_reg = 8'hcf;\n        8'h60: b_reg = 8'hd0;\n        8'h61: b_reg = 8'hef;\n        8'h62: b_reg = 8'haa;\n        8'h63: b_reg = 8'hfb;\n        8'h64: b_reg = 8'h43;\n        8'h65: b_reg = 8'h4d;\n        8'h66: b_reg = 8'h33;\n        8'h67: b_reg = 8'h85;\n        8'h68: b_reg = 8'h45;\n        8'h69: b_reg = 8'hf9;\n        8'h6a: b_reg = 8'h02;\n        8'h6b: b_reg = 8'h7f;\n        8'h6c: b_reg = 8'h50;\n        8'h6d: b_reg = 8'h3c;\n        8'h6e: b_reg = 8'h9f;\n        8'h6f: b_reg = 8'ha8;\n        8'h70: b_reg = 8'h51;\n        8'h71: b_reg = 8'ha3;\n        8'h72: b_reg = 8'h40;\n        8'h73: b_reg = 8'h8f;\n        8'h74: b_reg = 8'h92;\n        8'h75: b_reg = 8'h9d;\n        8'h76: b_reg = 8'h38;\n        8'h77: b_reg = 8'hf5;\n        8'h78: b_reg = 8'hbc;\n        8'h79: b_reg = 8'hb6;\n        8'h7a: b_reg = 8'hda;\n        8'h7b: b_reg = 8'h21;\n        8'h7c: b_reg = 8'h10;\n        8'h7d: b_reg = 8'hff;\n        8'h7e: b_reg = 8'hf3;\n        8'h7f: b_reg = 8'hd6;\n        default: b_reg = 8'h00;\n    endcase\nend\n\nassign b = b_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 18, "code": "// Example: 8-bit Register with Synchronous Reset\nmodule simple_register (\n    input wire clk,\n    input wire rst_n,       // Active-low reset\n    input wire [7:0] d_in,  // Data input\n    output reg [7:0] d_out  // Data output\n);\n\nalways @(posedge clk) begin\n    if (!rst_n) \n        d_out <= 8'b0;      // Reset to 0\n    else \n        d_out <= d_in;      // Normal operation\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 20, "code": "module RippleCarryAdder (\n    input clk,\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output reg [3:0] Sum,\n    output reg Cout\n);\n\nwire [3:0] sum_comb;\nwire [4:0] carry;\n\nassign carry[0] = Cin;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 4; i = i + 1) begin : adder_loop\n        assign sum_comb[i] = A[i] ^ B[i] ^ carry[i];\n        assign carry[i+1] = (A[i] & B[i]) | (A[i] & carry[i]) | (B[i] & carry[i]);\n    end\nendgenerate\n\nalways @(posedge clk) begin\n    Sum <= sum_comb;\n    Cout <= carry[4];\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 10, "code": "module aes_sbox (\n    input  [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] b_reg;\n\nalways @* begin\n    case (a)\n        8'h00: b_reg = 8'h63;\n        8'h01: b_reg = 8'h7c;\n        8'h02: b_reg = 8'h77;\n        8'h03: b_reg = 8'h7b;\n        8'h04: b_reg = 8'hf2;\n        8'h05: b_reg = 8'h6b;\n        8'h06: b_reg = 8'h6f;\n        8'h07: b_reg = 8'hc5;\n        8'h08: b_reg = 8'h30;\n        8'h09: b_reg = 8'h01;\n        8'h0a: b_reg = 8'h67;\n        8'h0b: b_reg = 8'h2b;\n        8'h0c: b_reg = 8'hfe;\n        8'h0d: b_reg = 8'hd7;\n        8'h0e: b_reg = 8'hab;\n        8'h0f: b_reg = 8'h76;\n        8'h10: b_reg = 8'hca;\n        8'h11: b_reg = 8'h82;\n        8'h12: b_reg = 8'hc9;\n        8'h13: b_reg = 8'h7d;\n        8'h14: b_reg = 8'hfa;\n        8'h15: b_reg = 8'h59;\n        8'h16: b_reg = 8'h47;\n        8'h17: b_reg = 8'hf0;\n        8'h18: b_reg = 8'had;\n        8'h19: b_reg = 8'hd4;\n        8'h1a: b_reg = 8'ha2;\n        8'h1b: b_reg = 8'haf;\n        8'h1c: b_reg = 8'h9c;\n        8'h1d: b_reg = 8'ha4;\n        8'h1e: b_reg = 8'h72;\n        8'h1f: b_reg = 8'hc0;\n        8'h20: b_reg = 8'hb7;\n        8'h21: b_reg = 8'hfd;\n        8'h22: b_reg = 8'h93;\n        8'h23: b_reg = 8'h26;\n        8'h24: b_reg = 8'h36;\n        8'h25: b_reg = 8'h3f;\n        8'h26: b_reg = 8'hf7;\n        8'h27: b_reg = 8'hcc;\n        8'h28: b_reg = 8'h34;\n        8'h29: b_reg = 8'ha5;\n        8'h2a: b_reg = 8'he5;\n        8'h2b: b_reg = 8'hf1;\n        8'h2c: b_reg = 8'h71;\n        8'h2d: b_reg = 8'hd8;\n        8'h2e: b_reg = 8'h31;\n        8'h2f: b_reg = 8'h15;\n        8'h30: b_reg = 8'h04;\n        8'h31: b_reg = 8'hc7;\n        8'h32: b_reg = 8'h23;\n        8'h33: b_reg = 8'hc3;\n        8'h34: b_reg = 8'h18;\n        8'h35: b_reg = 8'h96;\n        8'h36: b_reg = 8'h05;\n        8'h37: b_reg = 8'h9a;\n        8'h38: b_reg = 8'h07;\n        8'h39: b_reg = 8'h12;\n        8'h3a: b_reg = 8'h80;\n        8'h3b: b_reg = 8'he2;\n        8'h3c: b_reg = 8'heb;\n        8'h3d: b_reg = 8'h27;\n        8'h3e: b_reg = 8'hb2;\n        8'h3f: b_reg = 8'h75;\n        8'h40: b_reg = 8'h09;\n        8'h41: b_reg = 8'h83;\n        8'h42: b_reg = 8'h2c;\n        8'h43: b_reg = 8'h1a;\n        8'h44: b_reg = 8'h1b;\n        8'h45: b_reg = 8'h6e;\n        8'h46: b_reg = 8'h5a;\n        8'h47: b_reg = 8'ha0;\n        8'h48: b_reg = 8'h52;\n        8'h49: b_reg = 8'h3b;\n        8'h4a: b_reg = 8'hd6;\n        8'h4b: b_reg = 8'hb3;\n        8'h4c: b_reg = 8'h29;\n        8'h4d: b_reg = 8'he3;\n        8'h4e: b_reg = 8'h2f;\n        8'h4f: b_reg = 8'h84;\n        8'h50: b_reg = 8'h53;\n        8'h51: b_reg = 8'hd1;\n        8'h52: b_reg = 8'h00;\n        8'h53: b_reg = 8'hed;\n        // ... (All 256 case items continue here following AES S-box table)\n        8'hfd: b_reg = 8'he6;\n        8'hfe: b_reg = 8'h47;\n        8'hff: b_reg = 8'hfe;\n    endcase\nend\n\nassign b = b_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 11, "code": "module adder_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 12, "code": "module example_module (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] counter\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        counter <= 4'b0;\n    end else if (enable) begin\n        counter <= counter + 4'b1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 13, "code": "module aes_sbox (\n    input  wire [7:0] a,\n    output reg  [7:0] b\n);\n\nalways @* begin\n    case (a)\n        8'h00: b = 8'h63;\n        8'h01: b = 8'h7c;\n        8'h02: b = 8'h77;\n        8'h03: b = 8'h7b;\n        8'h04: b = 8'hf2;\n        8'h05: b = 8'h6b;\n        8'h06: b = 8'h6f;\n        8'h07: b = 8'hc5;\n        8'h08: b = 8'h30;\n        8'h09: b = 8'h01;\n        8'h0a: b = 8'h67;\n        8'h0b: b = 8'h2b;\n        8'h0c: b = 8'hfe;\n        8'h0d: b = 8'hd7;\n        8'h0e: b = 8'hab;\n        8'h0f: b = 8'h76;\n        8'h10: b = 8'hca;\n        8'h11: b = 8'h82;\n        8'h12: b = 8'hc9;\n        8'h13: b = 8'h7d;\n        8'h14: b = 8'hfa;\n        8'h15: b = 8'h59;\n        8'h16: b = 8'h47;\n        8'h17: b = 8'hf0;\n        8'h18: b = 8'had;\n        8'h19: b = 8'hd4;\n        8'h1a: b = 8'ha2;\n        8'h1b: b = 8'haf;\n        8'h1c: b = 8'h9c;\n        8'h1d: b = 8'ha4;\n        8'h1e: b = 8'h72;\n        8'h1f: b = 8'hc0;\n        8'h20: b = 8'hb7;\n        8'h21: b = 8'hfd;\n        8'h22: b = 8'h93;\n        8'h23: b = 8'h26;\n        8'h24: b = 8'h36;\n        8'h25: b = 8'h3f;\n        8'h26: b = 8'hf7;\n        8'h27: b = 8'hcc;\n        8'h28: b = 8'h34;\n        8'h29: b = 8'ha5;\n        8'h2a: b = 8'he5;\n        8'h2b: b = 8'hf1;\n        8'h2c: b = 8'h71;\n        8'h2d: b = 8'hd8;\n        8'h2e: b = 8'h31;\n        8'h2f: b = 8'h15;\n        8'h30: b = 8'h04;\n        8'h31: b = 8'hc7;\n        8'h32: b = 8'h23;\n        8'h33: b = 8'hc3;\n        8'h34: b = 8'h18;\n        8'h35: b = 8'h96;\n        8'h36: b = 8'h05;\n        8'h37: b = 8'h9a;\n        8'h38: b = 8'h07;\n        8'h39: b = 8'h12;\n        8'h3a: b = 8'h80;\n        8'h3b: b = 8'he2;\n        8'h3c: b = 8'heb;\n        8'h3d: b = 8'h27;\n        8'h3e: b = 8'hb2;\n        8'h3f: b = 8'h75;\n        8'h40: b = 8'h09;\n        8'h41: b = 8'h83;\n        8'h42: b = 8'h2c;\n        8'h43: b = 8'h1a;\n        8'h44: b = 8'h1b;\n        8'h45: b = 8'h6e;\n        8'h46: b = 8'h5a;\n        8'h47: b = 8'ha0;\n        8'h48: b = 8'h52;\n        8'h49: b = 8'h3b;\n        8'h4a: b = 8'hd6;\n        8'h4b: b = 8'hb3;\n        8'h4c: b = 8'h29;\n        8'h4d: b = 8'he3;\n        8'h4e: b = 8'h2f;\n        8'h4f: b = 8'h84;\n        8'h50: b = 8'h53;\n        8'h51: b = 8'hd1;\n        8'h52: b = 8'h00;\n        8'h53: b = 8'hed;\n        8'h54: b = 8'h20;\n        8'h55: b = 8'hfc;\n        8'h56: b = 8'hb1;\n        8'h57: b = 8'h5b;\n        8'h58: b = 8'h6a;\n        8'h59: b = 8'hcb;\n        8'h5a: b = 8'hbe;\n        8'h5b: b = 8'h39;\n        8'h5c: b = 8'h4a;\n        8'h5d: b = 8'h4c;\n        8'h5e: b = 8'h58;\n        8'h5f: b = 8'hcf;\n        8'h60: b = 8'hd0;\n        8'h61: b = 8'hef;\n        8'h62: b = 8'haa;\n        8'h63: b = 8'hfb;\n        8'h64: b = 8'h43;\n        8'h65: b = 8'h4d;\n        8'h66: b = 8'h33;\n        8'h67: b = 8'h85;\n        8'h68: b = 8'h45;\n        8'h69: b = 8'hf9;\n        8'h6a: b = 8'h02;\n        8'h6b: b = 8'h7f;\n        8'h6c: b = 8'h50;\n        8'h6d: b = 8'h3c;\n        8'h6e: b = 8'h9f;\n        8'h6f: b = 8'ha8;\n        8'h70: b = 8'h51;\n        8'h71: b = 8'ha3;\n        8'h72: b = 8'h40;\n        8'h73: b = 8'h8f;\n        8'h74: b = 8'h92;\n        8'h75: b = 8'h9d;\n        8'h76: b = 8'h38;\n        8'h77: b = 8'hf5;\n        8'h78: b = 8'hbc;\n        8'h79: b = 8'hb6;\n        8'h7a: b = 8'hda;\n        8'h7b: b = 8'h21;\n        8'h7c: b = 8'h10;\n        8'h7d: b = 8'hff;\n        8'h7e: b = 8'hf3;\n        8'h7f: b = 8'hd2;\n        8'h80: b = 8'hcd;\n        8'h81: b = 8'h0c;\n        8'h82: b = 8'h13;\n        8'h83: b = 8'hec;\n        8'h84: b = 8'h5f;\n        8'h85: b = 8'h97;\n        8'h86: b = 8'h44;\n        8'h87: b = 8'h17;\n        8'h88: b = 8'hc4;\n        8'h89: b = 8'ha7;\n        8'h8a: b = 8'h7e;\n        8'h8b: b = 8'h3d;\n        8'h8c: b = 8'h64;\n        8'h8d: b = 8'h5d;\n        8'h8e: b = 8'h19;\n        8'h8f: b = 8'h73;\n        8'h90: b = 8'h60;\n        8'h91: b = 8'h81;\n        8'h92: b = 8'h4f;\n        8'h93: b = 8'hdc;\n        8'h94: b = 8'h22;\n        8'h95: b = 8'h2a;\n        8'h96: b = 8'h90;\n        8'h97: b = 8'h88;\n        8'h98: b = 8'h46;\n        8'h99: b = 8'hee;\n        8'h9a: b = 8'hb8;\n        8'h9b: b = 8'h14;\n        8'h9c: b = 8'hde;\n        8'h9d: b = 8'h5e;\n        8'h9e: b = 8'h0b;\n        8'h9f: b = 8'hdb;\n        8'ha0: b = 8'he0;\n        8'ha1: b = 8'h32;\n        8'ha2: b = 8'h3a;\n        8'ha3: b = 8'h0a;\n        8'ha4: b = 8'h49;\n        8'ha5: b = 8'h06;\n        8'ha6: b = 8'h24;\n        8'ha7: b = 8'h5c;\n        8'ha8: b = 8'hc2;\n        8'ha9: b = 8'hd3;\n        8'haa: b = 8'hac;\n        8'hab: b = 8'h62;\n        8'hac: b = 8'h91;\n        8'had: b = 8'h95;\n        8'hae: b = 8'he4;\n        8'haf: b = 8'h79;\n        8'hb0: b = 8'he7;\n        8'hb1: b = 8'hc8;\n        8'hb2: b = 8'h37;\n        8'hb3: b = 8'h6d;\n        8'hb4: b = 8'h8d;\n        8'hb5: b = 8'hd5;\n        8'hb6: b = 8'h4e;\n        8'hb7: b = 8'ha9;\n        8'hb8: b = 8'h6c;\n        8'hb9: b = 8'h56;\n        8'hba: b = 8'hf4;\n        8'hbb: b = 8'hea;\n        8'hbc: b = 8'h65;\n        8'hbd: b = 8'h7a;\n        8'hbe: b = 8'hae;\n        8'hbf: b = 8'h08;\n        8'hc0: b = 8'hba;\n        8'hc1: b = 8'h78;\n        8'hc2: b = 8'h25;\n        8'hc3: b = 8'h2e;\n        8'hc4: b = 8'h1c;\n        8'hc5: b = 8'ha6;\n        8'hc6: b = 8'hb4;\n        8'hc7: b = 8'hc6;\n        8'hc8: b = 8'he8;\n        8'hc9: b = 8'hdd;\n        8'hca: b = 8'h74;\n        8'hcb: b = 8'h1f;\n        8'hcc: b = 8'h4b;\n        8'hcd: b = 8'hbd;\n        8'hce: b = 8'h8b;\n        8'hcf: b = 8'h8a;\n        8'hd0: b = 8'h70;\n        8'hd1: b = 8'h3e;\n        8'hd2: b = 8'hb5;\n        8'hd3: b = 8'h66;\n        8'hd4: b = 8'h48;\n        8'hd5: b = 8'h03;\n        8'hd6: b = 8'hf6;\n        8'hd7: b = 8'h0e;\n        8'hd8: b = 8'h61;\n        8'hd9: b = 8'h35;\n        8'hda: b = 8'h57;\n        8'hdb: b = 8'hb9;\n        8'hdc: b = 8'h86;\n        8'hdd: b = 8'hc1;\n        8'hde: b = 8'h1d;\n        8'hdf: b = 8'h9e;\n        8'he0: b = 8'he1;\n        8'he1: b = 8'hf8;\n        8'he2: b = 8'h98;\n        8'he3: b = 8'h11;\n        8'he4: b = 8'h69;\n        8'he5: b = 8'hd9;\n        8'he6: b = 8'h8e;\n        8'he7: b = 8'h94;\n        8'he8: b = 8'h9b;\n        8'he9: b = 8'h1e;\n        8'hea: b = 8'h87;\n        8'heb: b = 8'he9;\n        8'hec: b = 8'hce;\n        8'hed: b = 8'h55;\n        8'hee: b = 8'h28;\n        8'hef: b = 8'hdf;\n        8'hf0: b = 8'h8c;\n        8'hf1: b = 8'ha1;\n        8'hf2: b = 8'h89;\n        8'hf3: b = 8'h0d;\n        8'hf4: b = 8'hbf;\n        8'hf5: b = 8'he6;\n        8'hf6: b = 8'h42;\n        8'hf7: b = 8'h68;\n        8'hf8: b = 8'h41;\n        8'hf9: b = 8'h99;\n        8'hfa: b = 8'h2d;\n        8'hfb: b = 8'h0f;\n        8'hfc: b = 8'hb0;\n        8'hfd: b = 8'h54;\n        8'hfe: b = 8'hbb;\n        8'hff: b = 8'h16;\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 14, "code": "module d_flip_flop (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 0;\n        else\n            q <= d;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 19, "code": "module uart_tx (\n    input wire clk,\n    input wire rst_n,\n    input wire tx_start,\n    input wire [7:0] data_in,\n    output reg tx,\n    output wire tx_done\n);\n\nparameter CLK_FREQ = 100_000_000;  // 100 MHz system clock\nparameter BAUD_RATE = 115_200;\nlocalparam BAUD_PERIOD = CLK_FREQ / BAUD_RATE;\n\ntypedef enum logic [1:0] {\n    IDLE,\n    START,\n    DATA,\n    STOP\n} state_t;\n\nreg [1:0] state;\nreg [15:0] baud_counter;\nreg [2:0] bit_counter;\nreg [7:0] data_reg;\nreg done;\n\nassign tx_done = done;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= IDLE;\n        tx <= 1'b1;\n        done <= 1'b0;\n        baud_counter <= 0;\n        bit_counter <= 0;\n        data_reg <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                tx <= 1'b1;\n                done <= 1'b0;\n                if (tx_start) begin\n                    state <= START;\n                    data_reg <= data_in;\n                    baud_counter <= 0;\n                end\n            end\n\n            START: begin\n                tx <= 1'b0;\n                if (baud_counter == BAUD_PERIOD - 1) begin\n                    state <= DATA;\n                    baud_counter <= 0;\n                    bit_counter <= 0;\n                end else begin\n                    baud_counter <= baud_counter + 1;\n                end\n            end\n\n            DATA: begin\n                tx <= data_reg[bit_counter];\n                if (baud_counter == BAUD_PERIOD - 1) begin\n                    baud_counter <= 0;\n                    if (bit_counter == 7) begin\n                        state <= STOP;\n                    end else begin\n                        bit_counter <= bit_counter + 1;\n                    end\n                end else begin\n                    baud_counter <= baud_counter + 1;\n                end\n            end\n\n            STOP: begin\n                tx <= 1'b1;\n                if (baud_counter == BAUD_PERIOD - 1) begin\n                    state <= IDLE;\n                    done <= 1'b1;\n                    baud_counter <= 0;\n                end else begin\n                    baud_counter <= baud_counter + 1;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 15, "code": "module example_counter (\n    input clk,\n    input rst_n,\n    input enable,\n    output reg [3:0] count\n);\n\n// Async active-low reset with clocked behavior\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 4'b0;\n    end\n    else begin\n        count <= (enable) ? count + 1 : count;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 16, "code": "module aes_sbox (\n    input  [7:0] a,\n    output reg [7:0] b\n);\n\nalways @* begin\n    case (a)\n        8'h00: b = 8'h63; 8'h01: b = 8'h7c; 8'h02: b = 8'h77; 8'h03: b = 8'h7b;\n        8'h04: b = 8'hf2; 8'h05: b = 8'h6b; 8'h06: b = 8'h6f; 8'h07: b = 8'hc5;\n        8'h08: b = 8'h30; 8'h09: b = 8'h01; 8'h0a: b = 8'h67; 8'h0b: b = 8'h2b;\n        8'h0c: b = 8'hfe; 8'h0d: b = 8'hd7; 8'h0e: b = 8'hab; 8'h0f: b = 8'h76;\n        8'h10: b = 8'hca; 8'h11: b = 8'h82; 8'h12: b = 8'hc9; 8'h13: b = 8'h7d;\n        8'h14: b = 8'hfa; 8'h15: b = 8'h59; 8'h16: b = 8'h47; 8'h17: b = 8'hf0;\n        8'h18: b = 8'had; 8'h19: b = 8'hd4; 8'h1a: b = 8'ha2; 8'h1b: b = 8'haf;\n        8'h1c: b = 8'h9c; 8'h1d: b = 8'ha4; 8'h1e: b = 8'h72; 8'h1f: b = 8'hc0;\n        8'h20: b = 8'hb7; 8'h21: b = 8'hfd; 8'h22: b = 8'h93; 8'h23: b = 8'h26;\n        8'h24: b = 8'h36; 8'h25: b = 8'h3f; 8'h26: b = 8'hf7; 8'h27: b = 8'hcc;\n        8'h28: b = 8'h34; 8'h29: b = 8'ha5; 8'h2a: b = 8'he5; 8'h2b: b = 8'hf1;\n        8'h2c: b = 8'h71; 8'h2d: b = 8'hd8; 8'h2e: b = 8'h31; 8'h2f: b = 8'h15;\n        8'h30: b = 8'h04; 8'h31: b = 8'hc7; 8'h32: b = 8'h23; 8'h33: b = 8'hc3;\n        8'h34: b = 8'h18; 8'h35: b = 8'h96; 8'h36: b = 8'h05; 8'h37: b = 8'h9a;\n        8'h38: b = 8'h07; 8'h39: b = 8'h12; 8'h3a: b = 8'h80; 8'h3b: b = 8'he2;\n        8'h3c: b = 8'heb; 8'h3d: b = 8'h27; 8'h3e: b = 8'hb2; 8'h3f: b = 8'h75;\n        8'h40: b = 8'h09; 8'h41: b = 8'h83; 8'h42: b = 8'h2c; 8'h43: b = 8'h1a;\n        8'h44: b = 8'h1b; 8'h45: b = 8'h6e; 8'h46: b = 8'h5a; 8'h47: b = 8'ha0;\n        8'h48: b = 8'h52; 8'h49: b = 8'h3b; 8'h4a: b = 8'hd6; 8'h4b: b = 8'hb3;\n        8'h4c: b = 8'h29; 8'h4d: b = 8'he3; 8'h4e: b = 8'h2f; 8'h4f: b = 8'h84;\n        8'h50: b = 8'h53; 8'h51: b = 8'hd1; 8'h52: b = 8'h00; 8'h53: b = 8'hed;\n        8'h54: b = 8'h20; 8'h55: b = 8'hfc; 8'h56: b = 8'hb1; 8'h57: b = 8'h5b;\n        8'h58: b = 8'h6a; 8'h59: b = 8'hcb; 8'h5a: b = 8'hbe; 8'h5b: b = 8'h39;\n        8'h5c: b = 8'h4a; 8'h5d: b = 8'h4c; 8'h5e: b = 8'h58; 8'h5f: b = 8'hcf;\n        8'h60: b = 8'hd0; 8'h61: b = 8'hef; 8'h62: b = 8'haa; 8'h63: b = 8'hfb;\n        8'h64: b = 8'h43; 8'h65: b = 8'h4d; 8'h66: b = 8'h33; 8'h67: b = 8'h85;\n        8'h68: b = 8'h45; 8'h69: b = 8'hf9; 8'h6a: b = 8'h02; 8'h6b: b = 8'h7f;\n        8'h6c: b = 8'h50; 8'h6d: b = 8'h3c; 8'h6e: b = 8'h9f; 8'h6f: b = 8'ha8;\n        8'h70: b = 8'h51; 8'h71: b = 8'ha3; 8'h72: b = 8'h40; 8'h73: b = 8'h8f;\n        8'h74: b = 8'h92; 8'h75: b = 8'h9d; 8'h76: b = 8'h38; 8'h77: b = 8'hf5;\n        8'h78: b = 8'hbc; 8'h79: b = 8'hb6; 8'h7a: b = 8'hda; 8'h7b: b = 8'h21;\n        8'h7c: b = 8'h10; 8'h7d: b = 8'hff; 8'h7e: b = 8'hf3; 8'h7f: b = 8'hd2;\n        8'h80: b = 8'hcd; 8'h81: b = 8'h0c; 8'h82: b = 8'h13; 8'h83: b = 8'hec;\n        8'h84: b = 8'h5f; 8'h85: b = 8'h97; 8'h86: b = 8'h44; 8'h87: b = 8'h17;\n        8'h88: b = 8'hc4; 8'h89: b = 8'ha7; 8'h8a: b = 8'h7e; 8'h8b: b = 8'h3d;\n        8'h8c: b = 8'h64; 8'h8d: b = 8'h5d; 8'h8e: b = 8'h19; 8'h8f: b = 8'h73;\n        8'h90: b = 8'h60; 8'h91: b = 8'h81; 8'h92: b = 8'h4f; 8'h93: b = 8'hdc;\n        8'h94: b = 8'h22; 8'h95: b = 8'h2a; 8'h96: b = 8'h90; 8'h97: b = 8'h88;\n        8'h98: b = 8'h46; 8'h99: b = 8'hee; 8'h9a: b = 8'hb8; 8'h9b: b = 8'h14;\n        8'h9c: b = 8'hde; 8'h9d: b = 8'h5e; 8'h9e: b = 8'h0b; 8'h9f: b = 8'hdb;\n        8'ha0: b = 8'he0; 8'ha1: b = 8'h32; 8'ha2: b = 8'h3a; 8'ha3: b = 8'h0a;\n        8'ha4: b = 8'h49; 8'ha5: b = 8'h06; 8'ha6: b = 8'h24; 8'ha7: b = 8'h5c;\n        8'ha8: b = 8'hc2; 8'ha9: b = 8'hd3; 8'haa: b = 8'hac; 8'hab: b = 8'h62;\n        8'hac: b = 8'h91; 8'had: b = 8'h95; 8'hae: b = 8'he4; 8'haf: b = 8'h79;\n        8'hb0: b = 8'he7; 8'hb1: b = 8'hc8; 8'hb2: b = 8'h37; 8'hb3: b = 8'h6d;\n        8'hb4: b = 8'h8d; 8'hb5: b = 8'hd5; 8'hb6: b = 8'h4e; 8'hb7: b = 8'ha9;\n        8'hb8: b = 8'h6c; 8'hb9: b = 8'h56; 8'hba: b = 8'hf4; 8'hbb: b = 8'hea;\n        8'hbc: b = 8'h65; 8'hbd: b = 8'h7a; 8'hbe: b = 8'hae; 8'hbf: b = 8'h08;\n        8'hc0: b = 8'hba; 8'hc1: b = 8'h78; 8'hc2: b = 8'h25; 8'hc3: b = 8'h2e;\n        8'hc4: b = 8'h1c; 8'hc5: b = 8'ha6; 8'hc6: b = 8'hb4; 8'hc7: b = 8'hc6;\n        8'hc8: b = 8'he8; 8'hc9: b = 8'hdd; 8'hca: b = 8'h74; 8'hcb: b = 8'h1f;\n        8'hcc: b = 8'h4b; 8'hcd: b = 8'hbd; 8'hce: b = 8'h8b; 8'hcf: b = 8'h8a;\n        8'hd0: b = 8'h70; 8'hd1: b = 8'h3e; 8'hd2: b = 8'hb5; 8'hd3: b = 8'h66;\n        8'hd4: b = 8'h48; 8'hd5: b = 8'h03; 8'hd6: b = 8'hf6; 8'hd7: b = 8'h0e;\n        8'hd8: b = 8'h61; 8'hd9: b = 8'h35; 8'hda: b = 8'h57; 8'hdb: b = 8'hb9;\n        8'hdc: b = 8'h86; 8'hdd: b = 8'hc1; 8'hde: b = 8'h1d; 8'hdf: b = 8'h9e;\n        8'he0: b = 8'he1; 8'he1: b = 8'hf8; 8'he2: b = 8'h98; 8'he3: b = 8'h11;\n        8'he4: b = 8'h69; 8'he5: b = 8'hd9; 8'he6: b = 8'h8e; 8'he7: b = 8'h94;\n        8'he8: b = 8'h9b; 8'he9: b = 8'h1e; 8'hea: b = 8'h87; 8'heb: b = 8'he9;\n        8'hec: b = 8'hce; 8'hed: b = 8'h55; 8'hee: b = 8'h28; 8'hef: b = 8'hdf;\n        8'hf0: b = 8'h8c; 8'hf1: b = 8'ha1; 8'hf2: b = 8'h89; 8'hf3: b = 8'h0d;\n        8'hf4: b = 8'hbf; 8'hf5: b = 8'he6; 8'hf6: b = 8'h42; 8'hf7: b = 8'h68;\n        8'hf8: b = 8'h41; 8'hf9: b = 8'h99; 8'hfa: b = 8'h2d; 8'hfb: b = 8'h0f;\n        8'hfc: b = 8'hb0; 8'hfd: b = 8'h54; 8'hfe: b = 8'hbb; 8'hff: b = 8'h16;\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 17, "code": "module aes_sbox (\n    input  wire [7:0] a,\n    output reg  [7:0] b\n);\n\nalways @* begin\n    case (a)\n        // AES S-Box Lookup Table\n        8'h00: b = 8'h63;\n        8'h01: b = 8'h7c;\n        8'h02: b = 8'h77;\n        8'h03: b = 8'h7b;\n        8'h04: b = 8'hf2;\n        8'h05: b = 8'h6b;\n        8'h06: b = 8'h6f;\n        8'h07: b = 8'hc5;\n        8'h08: b = 8'h30;\n        8'h09: b = 8'h01;\n        8'h0a: b = 8'h67;\n        8'h0b: b = 8'h2b;\n        8'h0c: b = 8'hfe;\n        8'h0d: b = 8'hd7;\n        8'h0e: b = 8'hab;\n        8'h0f: b = 8'h76;\n        8'h10: b = 8'hca;\n        8'h11: b = 8'h82;\n        8'h12: b = 8'hc9;\n        8'h13: b = 8'h7d;\n        8'h14: b = 8'hfa;\n        8'h15: b = 8'h59;\n        8'h16: b = 8'h47;\n        8'h17: b = 8'hf0;\n        8'h18: b = 8'had;\n        8'h19: b = 8'hd4;\n        8'h1a: b = 8'ha2;\n        8'h1b: b = 8'haf;\n        8'h1c: b = 8'h9c;\n        8'h1d: b = 8'ha4;\n        8'h1e: b = 8'h72;\n        8'h1f: b = 8'hc0;\n        8'h20: b = 8'hb7;\n        8'h21: b = 8'hfd;\n        8'h22: b = 8'h93;\n        8'h23: b = 8'h26;\n        8'h24: b = 8'h36;\n        8'h25: b = 8'h3f;\n        8'h26: b = 8'hf7;\n        8'h27: b = 8'hcc;\n        8'h28: b = 8'h34;\n        8'h29: b = 8'ha5;\n        8'h2a: b = 8'he5;\n        8'h2b: b = 8'hf1;\n        8'h2c: b = 8'h71;\n        8'h2d: b = 8'hd8;\n        8'h2e: b = 8'h31;\n        8'h2f: b = 8'h15;\n        8'h30: b = 8'h04;\n        8'h31: b = 8'hc7;\n        8'h32: b = 8'h23;\n        8'h33: b = 8'hc3;\n        8'h34: b = 8'h18;\n        8'h35: b = 8'h96;\n        8'h36: b = 8'h05;\n        8'h37: b = 8'h9a;\n        8'h38: b = 8'h07;\n        8'h39: b = 8'h12;\n        8'h3a: b = 8'h80;\n        8'h3b: b = 8'he2;\n        8'h3c: b = 8'heb;\n        8'h3d: b = 8'h27;\n        8'h3e: b = 8'hb2;\n        8'h3f: b = 8'h75;\n        8'h40: b = 8'h09;\n        8'h41: b = 8'h83;\n        8'h42: b = 8'h2c;\n        8'h43: b = 8'h1a;\n        8'h44: b = 8'h1b;\n        8'h45: b = 8'h6e;\n        8'h46: b = 8'h5a;\n        8'h47: b = 8'ha0;\n        8'h48: b = 8'h52;\n        8'h49: b = 8'h3b;\n        8'h4a: b = 8'hd6;\n        8'h4b: b = 8'hb3;\n        8'h4c: b = 8'h29;\n        8'h4d: b = 8'he3;\n        8'h4e: b = 8'h2f;\n        8'h4f: b = 8'h84;\n        8'h50: b = 8'h53;\n        8'h51: b = 8'hd1;\n        8'h52: b = 8'h00;\n        8'h53: b = 8'hed;\n        8'h54: b = 8'h20;\n        8'h55: b = 8'hfc;\n        8'h56: b = 8'hb1;\n        8'h57: b = 8'h5b;\n        8'h58: b = 8'h6a;\n        8'h59: b = 8'hcb;\n        8'h5a: b = 8'hbe;\n        8'h5b: b = 8'h39;\n        8'h5c: b = 8'h4a;\n        8'h5d: b = 8'h4c;\n        8'h5e: b = 8'h58;\n        8'h5f: b = 8'hcf;\n        8'h60: b = 8'hd0;\n        8'h61: b = 8'hef;\n        8'h62: b = 8'haa;\n        8'h63: b = 8'hfb;\n        8'h64: b = 8'h43;\n        8'h65: b = 8'h4d;\n        8'h66: b = 8'h33;\n        8'h67: b = 8'h85;\n        8'h68: b = 8'h45;\n        8'h69: b = 8'hf9;\n        8'h6a: b = 8'h02;\n        8'h6b: b = 8'h7f;\n        8'h6c: b = 8'h50;\n        8'h6d: b = 8'h3c;\n        8'h6e: b = 8'h9f;\n        8'h6f: b = 8'ha8;\n        8'h70: b = 8'h51;\n        8'h71: b = 8'ha3;\n        8'h72: b = 8'h40;\n        8'h73: b = 8'h8f;\n        8'h74: b = 8'h92;\n        8'h75: b = 8'h9d;\n        8'h76: b = 8'h38;\n        8'h77: b = 8'hf5;\n        8'h78: b = 8'hbc;\n        8'h79: b = 8'hb6;\n        8'h7a: b = 8'hda;\n        8'h7b: b = 8'h21;\n        8'h7c: b = 8'h10;\n        8'h7d: b = 8'hff;\n        8'h7e: b = 8'hf3;\n        8'h7f: b = 8'hd2;\n        8'h80: b = 8'hcd;\n        8'h81: b = 8'h0c;\n        8'h82: b = 8'h13;\n        8'h83: b = 8'hec;\n        8'h84: b = 8'h5f;\n        8'h85: b = 8'h97;\n        // ... (remaining entries should be added here for completeness)\n        default: b = 8'h00; // Handle undefined cases\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 18, "code": "module aes_sbox (\n    input  [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] b_reg;\n\nalways @(*) begin\n    case (a)\n        8'h00: b_reg = 8'h63;\n        8'h01: b_reg = 8'h7c;\n        8'h02: b_reg = 8'h77;\n        // ... (all 256 case entries from AES S-box table)\n        8'hfd: b_reg = 8'h86;\n        8'hfe: b_reg = 8'hb1;\n        8'hff: b_reg = 8'h1b;\n    endcase\nend\n\nassign b = b_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 19, "code": "module adder_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input carry_in,\n    output [3:0] sum,\n    output carry_out\n);\n\n    // Concatenate carry_out and sum using bitwise addition\n    wire [4:0] result_temp;\n    assign result_temp = A + B + carry_in;\n    \n    assign sum = result_temp[3:0];\n    assign carry_out = result_temp[4];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_sbox", "codeid": 20, "code": "module bit_counter(\n    input clk,\n    input reset_n,\n    input enable,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        count <= 4'b0000;\n    end\n    else begin\n        if (enable) begin\n            count <= count + 1'b1;\n        end\n        // No else: counter holds value when enable is low\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_sbox", "codeid": 20, "code": "module pulse_generator (\n    input wire clk,\n    input wire reset_n,\n    input wire enable,\n    input wire pulse_type,\n    output reg pulse_out\n);\n\nreg [3:0] counter;\n\n// Counter control logic\nalways @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        counter <= 4'b0;\n    end else begin\n        if (!enable) begin\n            counter <= 4'b0;       // Reset counter when disabled\n        end else begin\n            counter <= counter + 1; // Free-running counter when enabled\n        end\n    end\nend\n\n// Pulse generation logic\nalways @(*) begin\n    pulse_out = 1'b0;\n    if (enable) begin\n        case (pulse_type)\n            1'b0: pulse_out = (counter == 4'b1111);          // Single-cycle pulse\n            1'b1: pulse_out = (counter == 4'b1111) ||        // Two-cycle pulse\n                             (counter == 4'b0000);\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
