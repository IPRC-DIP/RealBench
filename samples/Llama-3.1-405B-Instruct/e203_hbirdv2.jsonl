{"task": "e203_cpu_top", "codeid": 1, "code": "module e203_cpu_top(\n    // ... interface signals ...\n);\n\n// ... internal logic and instantiations ...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 1, "code": "```ilog\nmodule e203_exu_excp (\n    // ... (input/output ports)\n);\n\n// ... (module body)\n\nendmodule\n", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 1, "code": "module e203_clkgate(\n    input  wire        clk_in,      // Input clock signal\n    input  wire        test_mode,   // Test mode enable signal\n    input  wire        clock_en,    // Clock enable signal\n    output wire        clk_out      // Output clock signal\n);\n\n`include \"e203_defines.v\"\n\nreg enb;\n\nalways @(negedge clk_in) begin\n    enb <= clock_en | test_mode;\nend\n\nassign clk_out = enb & clk_in;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 2, "code": "```ate(\n    input  clk_in,      // Input clock signal\n    input  test_mode,   // Test mode enable signal\n    input  clock_en,    // Clock enable signal\n    output clk_out      // Output clock signal\n);\n\n`include \"e203_defines.v\"\n\nreg enb;\n\nalways @(negedge clk_in) begin\n    enb <= clock_en || test_mode;\nend\n\nassign clk_out = clk_in & enb;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 1, "code": "module e203_extend_csr(\n    input  logic               clk,\n    input  logic               rst_n,\n    input  logic               nice_csr_valid,\n    output logic               nice_csr_ready,\n    input  logic [31:0]        nice_csr_addr,\n    input  logic               nice_csr_wr,\n    input  logic [31:0]        nice_csr_wdata,\n    output logic [31:0]        nice_csr_rdata\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        nice_csr_ready <= 1'b1;\n        nice_csr_rdata <= 32'd0;\n    end else begin\n        nice_csr_ready <= 1'b1;\n        nice_csr_rdata <= 32'd0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 3, "code": "module e203_clkgate(\n    input  logic        clk_in,      // Input clock signal\n    input  logic        test_mode,   // Test mode enable signal\n    input  logic        clock_en,    // Clock enable signal\n    output logic        clk_out      // Output clock signal\n);\n\n// Internal enable signal\nlogic enb;\n\n// FPGA mode: direct connection between input and output clocks\n`ifdef FPGA_SOURCE\n    assign clk_out = clk_in;\n`else\n    // Gating mode: use enable signal to mask input clock\n    always_ff @(negedge clk_in or posedge test_mode) begin\n        if (~test_mode) begin\n            enb <= clock_en;\n        end else begin\n            enb <= 1'b1;\n        end\n    end\n\n    assign clk_out = enb & clk_in;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 4, "code": "module e203_clkgate (\n    input  logic        clk_in,      // Input clock signal\n    input  logic        test_mode,   // Test mode enable signal\n    input  logic        clock_en,    // Clock enable signal\n    output logic        clk_out      // Output clock signal\n);\n\n// Define parameters based on the FPGA_SOURCE macro\n`ifdef FPGA_SOURCE\n    // FPGA Mode: Direct connection between input clock and output clock\n    assign clk_out = clk_in;\n`else\n    // Gating Mode: Use enable signal to mask input clock\n    logic enb;  // Internal enable signal\n\n    // Evaluate clock_en and test_mode signals during clock low period\n    always_latch begin\n        if (!clk_in) begin\n            enb <= clock_en || test_mode;\n        end\n    end\n\n    // Perform AND operation between internal enable signal and input clock\n    assign clk_out = enb && clk_in;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 2, "code": "module e203_extend_csr(\n    input  logic                clk,\n    input  logic                rst_n,\n    input  logic                nice_csr_valid,\n    output logic                nice_csr_ready,\n    input  logic [31:0]         nice_csr_addr,\n    input  logic                nice_csr_wr,\n    input  logic [31:0]         nice_csr_wdata,\n    output logic [31:0]         nice_csr_rdata\n);\n\n// The module is controlled by the macro definition E203_HAS_CSR_NICE\n`ifdef E203_HAS_CSR_NICE\n    // If E203_HAS_CSR_NICE is defined, the module provides actual functionality\n    // TODO: Implement the actual functionality of the e203_extend_csr module\n    assign nice_csr_ready = 1'b1;  // Always ready\n    assign nice_csr_rdata = 32'b0;  // Read data is always 0\n`else\n    // If E203_HAS_CSR_NICE is not defined, the module only provides basic interface definitions\n    assign nice_csr_ready = 1'b1;  // Always ready\n    assign nice_csr_rdata = 32'b0;  // Read data is always 0\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 5, "code": "module e203_clkgate(\n    input  logic        clk_in,\n    input  logic        test_mode,\n    input  logic        clock_en,\n    output logic        clk_out\n);\n\n`include \"e203_defines.v\"\n\ngenerate\n    if (FPGA_SOURCE) begin\n        // FPGA mode: direct connection\n        assign clk_out = clk_in;\n    end else begin\n        // Gating mode\n        logic enb;\n\n        always_latch begin\n            if (!clk_in) begin\n                enb <= clock_en || test_mode;\n            end\n        end\n\n        assign clk_out = enb && clk_in;\n    end\nendgenerate\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 3, "code": "module e203_extend_csr(\n    input  logic                   clk,\n    input  logic                   rst_n,\n    input  logic                   nice_csr_valid,\n    output logic                   nice_csr_ready,\n    input  logic [31:0]            nice_csr_addr,\n    input  logic                   nice_csr_wr,\n    input  logic [31:0]            nice_csr_wdata,\n    output logic [31:0]            nice_csr_rdata\n);\n\n// The module is controlled by the macro definition E203_HAS_CSR_NICE\n// If E203_HAS_CSR_NICE is not defined, the module does not have any functionality\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal is always 1\n    assign nice_csr_ready = 1'b1;\n    \n    // CSR read data is always 0\n    assign nice_csr_rdata = 32'd0;\n`else\n    // If E203_HAS_CSR_NICE is not defined, the signals are assigned default values\n    assign nice_csr_ready = 1'b1;\n    assign nice_csr_rdata = 32'd0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 4, "code": "module e203_extend_csr(\n    input  logic            clk,\n    input  logic            rst_n,\n    input  logic            nice_csr_valid,\n    output logic            nice_csr_ready,\n    input  logic [31:0]     nice_csr_addr,\n    input  logic            nice_csr_wr,\n    input  logic [31:0]     nice_csr_wdata,\n    output logic [31:0]     nice_csr_rdata\n);\n\n// The module currently only provides basic interface definitions\n// without actual functional implementation.\n\n// nice_csr_ready is fixed to 1, indicating the module is always in a ready state\nassign nice_csr_ready = 1'b1;\n\n// nice_csr_rdata is fixed to 0, with all read operations returning a zero value\nassign nice_csr_rdata = 32'd0;\n\n// Other input signals are currently unused\n// nice_csr_addr, nice_csr_wr, nice_csr_wdata\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 5, "code": "module e203_extend_csr(\n    input  logic           clk,\n    input  logic           rst_n,\n    input  logic           nice_csr_valid,\n    output logic           nice_csr_ready,\n    input  logic [31:0]    nice_csr_addr,\n    input  logic           nice_csr_wr,\n    input  logic [31:0]    nice_csr_wdata,\n    output logic [31:0]    nice_csr_rdata\n);\n\n    // The module is controlled by the macro definition E203_HAS_CSR_NICE\n    // to enable or disable its functionality.\n    `ifdef E203_HAS_CSR_NICE\n        // CSR access ready signal is always 1, indicating the module is always in a ready state\n        assign nice_csr_ready = 1'b1;\n        \n        // CSR read data is always 0, with all read operations returning a zero value\n        assign nice_csr_rdata = 32'd0;\n    `else\n        // If E203_HAS_CSR_NICE is not defined, the module does not provide any functionality\n        assign nice_csr_ready = 1'b0;\n        assign nice_csr_rdata = 32'd0;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 6, "code": "module e203_extend_csr(\n    input  logic               clk,\n    input  logic               rst_n,\n    input  logic               nice_csr_valid,\n    output logic               nice_csr_ready,\n    input  logic [31:0]        nice_csr_addr,\n    input  logic               nice_csr_wr,\n    input  logic [31:0]        nice_csr_wdata,\n    output logic [31:0]        nice_csr_rdata\n);\n\n    // The module is controlled by the macro definition E203_HAS_CSR_NICE\n    // If E203_HAS_CSR_NICE is not defined, the module does not have any functionality\n    `ifdef E203_HAS_CSR_NICE\n        // CSR access ready signal is always 1\n        assign nice_csr_ready = 1'b1;\n        \n        // CSR read data is always 0\n        assign nice_csr_rdata = 32'b0;\n    `else\n        // If E203_HAS_CSR_NICE is not defined, the signals are assigned default values\n        assign nice_csr_ready = 1'b1;\n        assign nice_csr_rdata = 32'b0;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 1, "code": "```ilog\n`include \"e203_defines.v\"\n\nmodule e203_reset_ctrl(\n    input  logic        clk,            // System clock\n    input  logic        rst_n,          // Asynchronous reset signal (active low)\n    input  logic        test_mode,      // Test mode enable\n    output logic        rst_core,       // Processor core reset signal\n    output logic        rst_itcm,       // ITCM memory reset signal (conditional compilation)\n    output logic        rst_dtcm,       // DTCM memory reset signal (conditional compilation)\n    output logic        rst_aon          // Always-on module reset signal\n);\n\n// Parameter configuration\nparameter MASTER = 1;  // Reset controller mode (1 for master controller, 0 for slave controller)\nparameter RST_SYNC_LEVEL = E203_ASYNC_FF_LEVELS;  // Synchronous reset cascade depth\n\n// Internal signals\nlogic [RST_SYNC_LEVEL-1:0] rst_sync;\n\n// Reset synchronization mechanism\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        rst_sync <= {RST_SYNC_LEVEL{1'b1}};\n    end else if (test_mode) begin\n        rst_sync <= {RST_SYNC_LEVEL{1'b0}};\n    end else begin\n        rst_sync <= {1'b1, rst_sync[RST_SYNC_LEVEL-1:1]};\n    end\nend\n\n// Operating modes\nalways_comb begin\n    if (MASTER) begin\n        // Master controller mode\n        rst_core = rst_sync[0];\n        rst_itcm = rst_sync[0];\n        rst_dtcm = rst_sync[0];\n        rst_aon = rst_sync[0];\n    end else begin\n        // Slave controller mode\n        rst_core = ~rst_n;\n        rst_itcm = ~rst_n;\n        rst_dtcm = ~rst_n;\n        rst_aon = ~rst_n", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_regfile(\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output logic [E203_XLEN-1:0] read_src1_dat,\n    output logic [E203_XLEN-1:0] read_src2_dat,\n    input  logic                     wbck_dest_wen,\n    input  logic [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input  logic [E203_XLEN-1:0] wbck_dest_dat,\n    output logic [E203_XLEN-1:0] x1_r,\n    input  logic                     test_mode,\n    input  logic                     clk,\n    input  logic                     rst_n\n);\n\nlogic [E203_XLEN-1:0] regfile [E203_RFREG_NUM-1:0];\n\nalways_ff @(posedge clk) begin\n    if (~rst_n) begin\n        for (int i = 0; i < E203_RFREG_NUM; i++) begin\n            regfile[i] <= '0;\n        end\n    end else if (wbck_dest_wen && (wbck_dest_idx != 0)) begin\n        regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\nend\n\nassign read_src1_dat = (read_src1_idx == 0) ? '0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? '0 : regfile[read_src2_idx];\nassign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 7, "code": "```ilog\nmodule e203_extend_csr(\n    input  logic                clk,\n    input  logic                rst_n,\n    input  logic                nice_csr_valid,\n    output logic                nice_csr_ready,\n    input  logic [31:0]         nice_csr_addr,\n    input  logic                nice_csr_wr,\n    input  logic [31:0]         nice_csr_wdata,\n    output logic [31:0]         nice_csr_rdata\n);\n\n// The module is controlled by the macro definition E203_HAS_CSR_NICE\n// If E203_HAS_CSR_NICE is not defined, the module does not have any functionality\n`ifdef E203_HAS_CSR_NICE\n    // CSR access ready signal is always 1, indicating the module is always in a ready state\n    assign nice_csr_ready = 1'b1;\n    \n    // CSR read data is always 0, with all read operations returning a zero value\n    assign nice_csr_rdata = 32'b0;\n`else\n    // If E203_HAS_CSR_NICE is not defined, the module does not have any functionality\n    assign nice_csr_ready = 1'b1;\n    assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 1, "code": "module e203_itcm_ram #(\n    parameter DP = E203_ITCM_RAM_DP, // RAM depth\n    parameter DW = E203_ITCM_RAM_DW, // Data width\n    parameter MW = E203_ITCM_RAM_MW, // Write mask width\n    parameter AW = E203_ITCM_RAM_AW  // Address width\n) (\n    input  logic                   sd,  // Power domain shutdown enable signal\n    input  logic                   ds,  // Deep sleep mode enable signal\n    input  logic                   ls,  // Light sleep mode enable signal\n    input  logic                   cs,  // Chip select signal\n    input  logic                   we,  // Write enable signal\n    input  logic [AW-1:0]          addr, // Address input\n    input  logic [MW-1:0]          wem,  // Write mask\n    input  logic [DW-1:0]          din,  // Data input\n    input  logic                   rst_n, // Asynchronous reset signal (active low)\n    input  logic                   clk,  // System clock\n    output logic [DW-1:0]          dout  // Data output\n);\n\nlogic [DW-1:0] ram [DP-1:0]; // RAM storage\n\nalways_ff @(posedge clk) begin\n    if (!rst_n) begin\n        // Reset RAM contents\n        for (int i = 0; i < DP; i++) begin\n            ram[i] <= '0;\n        end\n    end else if (cs && we) begin\n        // Write operation\n        for (int i = 0; i < MW; i++) begin\n            if (wem[i]) begin\n                ram[addr][i*8 +: 8] <= din[i*8 +: 8];\n            end\n        end\n    end\nend\n\nalways_comb begin\n    if (cs) begin\n        // Read operation\n        dout = ram[addr];\n    end else begin\n        // Deselect, output high impedance\n        dout = 'z;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 2, "code": "`include \"e203_defines.v\"\n\nmodule e203_reset_ctrl(\n    input  logic        clk,            // System clock\n    input  logic        rst_n,          // Asynchronous reset signal (active low)\n    input  logic        test_mode,      // Test mode enable\n    output logic        rst_core,       // Processor core reset signal\n    output logic        rst_itcm,       // ITCM memory reset signal (conditional compilation)\n    output logic        rst_dtcm,       // DTCM memory reset signal (conditional compilation)\n    output logic        rst_aon          // Always-on module reset signal\n);\n\n// Synchronization register for asynchronous reset\nlogic [E203_ASYNC_FF_LEVELS-1:0] rst_sync_reg;\n\n// Master-slave reset controller mode\nlogic master_mode;\n\n// Test mode handling\nassign master_mode = (MASTER == 1) ? 1'b1 : 1'b0;\n\n// Reset synchronization mechanism\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rst_sync_reg <= {E203_ASYNC_FF_LEVELS{1'b1}};\n    end else if (test_mode) begin\n        rst_sync_reg <= {E203_ASYNC_FF_LEVELS{1'b0}};\n    end else begin\n        rst_sync_reg <= {rst_sync_reg[E203_ASYNC_FF_LEVELS-2:0], 1'b0};\n    end\nend\n\n// Operating modes\nalways_comb begin\n    if (master_mode) begin\n        // Master controller mode\n        rst_core  = rst_sync_reg[E203_ASYNC_FF_LEVELS-1];\n        rst_itcm  = rst_sync_reg[E203_ASYNC_FF_LEVELS-1];\n        rst_dtcm  = rst_sync_reg[E203_ASYNC_FF_LEVELS-1];\n        rst_aon   = rst_sync_reg[E203_ASYNC_FF_LEVELS-1];\n    end else begin\n        // Slave controller mode\n        rst_core  = rst_n;\n        rst_itcm  = rst_n;\n        rst_dtcm  = rst_n;\n        rst_aon   = rst_n;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 2, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_regfile(\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output logic [E203_XLEN-1:0] read_src1_dat,\n    output logic [E203_XLEN-1:0] read_src2_dat,\n    input  logic                     wbck_dest_wen,\n    input  logic [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input  logic [E203_XLEN-1:0] wbck_dest_dat,\n    output logic [E203_XLEN-1:0] x1_r,\n    input  logic                     test_mode,\n    input  logic                     clk,\n    input  logic                     rst_n\n);\n\n// Define the register file\nlogic [E203_XLEN-1:0] rf [E203_RFREG_NUM-1:0];\n\n// Initialize the register file\ninitial begin\n    for (int i = 0; i < E203_RFREG_NUM; i++) begin\n        rf[i] = '0;\n    end\nend\n\n// Register file write logic\nalways @(posedge clk) begin\n    if (~rst_n) begin\n        for (int i = 0; i < E203_RFREG_NUM; i++) begin\n            rf[i] <= '0;\n        end\n    end else if (wbck_dest_wen && wbck_dest_idx != '0) begin\n        rf[wbck_dest_idx] <= wbck_dest_dat;\n    end\nend\n\n// Register file read logic\nassign read_src1_dat = (read_src1_idx == '0) ? '0 : rf[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == '0) ? '0 : rf[read_src2_idx];\n\n// Output for general-purpose register 1\nassign x1_r = rf[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 3, "code": "// Import necessary definitions\n`include \"e203_defines.v\"\n\nmodule e203_exu_regfile(\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output logic [E203_XLEN-1:0]        read_src1_dat,\n    output logic [E203_XLEN-1:0]        read_src2_dat,\n    input  logic                        wbck_dest_wen,\n    input  logic [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input  logic [E203_XLEN-1:0]        wbck_dest_dat,\n    output logic [E203_XLEN-1:0]        x1_r,\n    input  logic                        test_mode,\n    input  logic                        clk,\n    input  logic                        rst_n\n);\n\n// Define the register file\nlogic [E203_XLEN-1:0] rf [E203_RFREG_NUM-1:0];\n\n// Initialize register 0 to 0\nassign rf[0] = '0;\n\n// Read logic\nalways_comb begin\n    read_src1_dat = rf[read_src1_idx];\n    read_src2_dat = rf[read_src2_idx];\nend\n\n// Write logic\nalways_ff @(posedge clk) begin\n    if (wbck_dest_wen) begin\n        if (wbck_dest_idx != 0) begin\n            rf[wbck_dest_idx] <= wbck_dest_dat;\n        end\n    end\nend\n\n// Assign x1_r\nassign x1_r = rf[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 2, "code": "module e203_itcm_ram #(\n    parameter DP = E203_ITCM_RAM_DP,\n    parameter DW = E203_ITCM_RAM_DW,\n    parameter MW = E203_ITCM_RAM_MW,\n    parameter AW = E203_ITCM_RAM_AW\n)(\n    input  logic                           sd,      // Power domain shutdown enable signal\n    input  logic                           ds,      // Deep sleep mode enable signal\n    input  logic                           ls,      // Light sleep mode enable signal\n    input  logic                           cs,      // Chip select signal\n    input  logic                           we,      // Write enable signal\n    input  logic [AW-1:0]                  addr,    // Address input\n    input  logic [MW-1:0]                  wem,     // Write mask\n    input  logic [DW-1:0]                  din,     // Data input\n    input  logic                           rst_n,   // Asynchronous reset signal (active low)\n    input  logic                           clk,     // System clock\n    output logic [DW-1:0]                  dout     // Data output\n);\n\nlogic [DW-1:0] ram [DP-1:0];\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        for (int i = 0; i < DP; i++) begin\n            ram[i] <= '0;\n        end\n    end else if (cs && we) begin\n        for (int i = 0; i < MW; i++) begin\n            if (wem[i]) begin\n                ram[addr][i*8 +: 8] <= din[i*8 +: 8];\n            end\n        end\n    end\nend\n\nalways_comb begin\n    if (cs) begin\n        dout = ram[addr];\n    end else begin\n        dout = '0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_alu_muldiv(\n    input  logic                   mdv_nob2b,\n    input  logic                   muldiv_i_valid,\n    output logic                   muldiv_i_ready,\n    input  logic [E203_XLEN-1:0]   muldiv_i_rs1,\n    input  logic [E203_XLEN-1:0]   muldiv_i_rs2,\n    input  logic [E203_XLEN-1:0]   muldiv_i_imm,\n    input  logic [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n    input  logic [E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n    output logic                   muldiv_i_longpipe,\n    input  logic                   flush_pulse,\n    output logic                   muldiv_o_valid,\n    input  logic                   muldiv_o_ready,\n    output logic [E203_XLEN-1:0]   muldiv_o_wbck_wdat,\n    output logic                   muldiv_o_wbck_err,\n    output logic [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    output logic [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    output logic                   muldiv_req_alu_add,\n    output logic                   muldiv_req_alu_sub,\n    input  logic [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output logic                   muldiv_sbf_0_ena,\n    output logic [32:0]            muldiv_sbf_0_nxt,\n    input  logic [32:0]            muldiv_sbf_0_r,\n    output logic                   muldiv_sbf_1_ena,\n    output logic [32:0]            muldiv_sbf_1_nxt,\n    input  logic [32:0]            muldiv_sbf_1_r,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n\n// ... rest of your module implementation ...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 3, "code": "module e203_itcm_ram #(\n    parameter DP = E203_ITCM_RAM_DP, // RAM depth\n    parameter DW = E203_ITCM_RAM_DW, // Data width\n    parameter MW = E203_ITCM_RAM_MW, // Write mask width\n    parameter AW = E203_ITCM_RAM_AW  // Address width\n) (\n    input  logic                  sd, // Power domain shutdown enable signal\n    input  logic                  ds, // Deep sleep mode enable signal\n    input  logic                  ls, // Light sleep mode enable signal\n    input  logic                  cs, // Chip select signal\n    input  logic                  we, // Write enable signal\n    input  logic [AW-1:0]         addr, // Address input\n    input  logic [MW-1:0]         wem, // Write mask\n    input  logic [DW-1:0]         din, // Data input\n    input  logic                  rst_n, // Asynchronous reset signal (active low)\n    input  logic                  clk, // System clock\n    output logic [DW-1:0]         dout // Data output\n);\n\nlogic [DW-1:0] ram [DP-1:0];\n\nalways_ff @(posedge clk) begin\n    if (~rst_n) begin\n        for (int i = 0; i < DP; i++) begin\n            ram[i] <= '0;\n        end\n    end else if (cs && we) begin\n        for (int i = 0; i < MW; i++) begin\n            if (wem[i]) begin\n                ram[addr][i*8 +: 8] <= din[i*8 +: 8];\n            end\n        end\n    end\nend\n\nalways_comb begin\n    if (cs) begin\n        dout = ram[addr];\n    end else begin\n        dout = '0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 1, "code": "module e203_irq_sync(\n    input  logic               clk,\n    input  logic               rst_n,\n    input  logic               ext_irq_a,\n    input  logic               sft_irq_a,\n    input  logic               tmr_irq_a,\n    input  logic               dbg_irq_a,\n    output logic               ext_irq_r,\n    output logic               sft_irq_r,\n    output logic               tmr_irq_r,\n    output logic               dbg_irq_r\n);\n\nparameter DP = 2; // Depth of the synchronizer (number of flip-flops)\nparameter DW = 1; // Data width (in bits)\n\nlogic [DP-1:0] ext_irq_sync;\nlogic [DP-1:0] sft_irq_sync;\nlogic [DP-1:0] tmr_irq_sync;\nlogic [DP-1:0] dbg_irq_sync;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        ext_irq_sync <= '0;\n        sft_irq_sync <= '0;\n        tmr_irq_sync <= '0;\n        dbg_irq_sync <= '0;\n    end else begin\n        ext_irq_sync <= {ext_irq_sync[DP-2:0], ext_irq_a};\n        sft_irq_sync <= {sft_irq_sync[DP-2:0], sft_irq_a};\n        tmr_irq_sync <= {tmr_irq_sync[DP-2:0], tmr_irq_a};\n        dbg_irq_sync <= {dbg_irq_sync[DP-2:0], dbg_irq_a};\n    end\nend\n\nassign ext_irq_r = ext_irq_sync[DP-1];\nassign sft_irq_r = sft_irq_sync[DP-1];\nassign tmr_irq_r = tmr_irq_sync[DP-1];\nassign dbg_irq_r = dbg_irq_sync[DP-1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 4, "code": "// Import necessary definitions\n`include \"e203_defines.v\"\n\nmodule e203_exu_regfile(\n    // Basic Interface\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output logic [E203_XLEN-1:0]        read_src1_dat,\n    output logic [E203_XLEN-1:0]        read_src2_dat,\n    input  logic                        wbck_dest_wen,\n    input  logic [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input  logic [E203_XLEN-1:0]        wbck_dest_dat,\n    output logic [E203_XLEN-1:0]        x1_r,\n    input  logic                        test_mode,\n    input  logic                        clk,\n    input  logic                        rst_n\n);\n\n// Define the register file\nlogic [E203_XLEN-1:0] rf [E203_RFREG_NUM-1:0];\n\n// Initialize register 0 to 0\nassign rf[0] = '0;\n\n// Write logic\nalways_ff @(posedge clk) begin\n    if (wbck_dest_wen) begin\n        if (wbck_dest_idx != 0) begin\n            rf[wbck_dest_idx] <= wbck_dest_dat;\n        end\n    end\nend\n\n// Read logic\nassign read_src1_dat = rf[read_src1_idx];\nassign read_src2_dat = rf[read_src2_idx];\n\n// Assign x1_r\nassign x1_r = rf[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 5, "code": "// e203_exu_regfile.v\n// Integer general-purpose register file as defined by the RISC-V architecture\n\n`include \"e203_defines.v\"\n\nmodule e203_exu_regfile (\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output logic [E203_XLEN-1:0]        read_src1_dat,\n    output logic [E203_XLEN-1:0]        read_src2_dat,\n    input  logic                        wbck_dest_wen,\n    input  logic [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input  logic [E203_XLEN-1:0]        wbck_dest_dat,\n    output logic [E203_XLEN-1:0]        x1_r,\n    input  logic                        test_mode,\n    input  logic                        clk,\n    input  logic                        rst_n\n);\n\n// Register file implementation\nlogic [E203_XLEN-1:0] rf [E203_RFREG_NUM-1:0];\n\n// Initialize register 0 to 0\nassign rf[0] = '0;\n\n// Read logic\nalways_comb begin\n    read_src1_dat = rf[read_src1_idx];\n    read_src2_dat = rf[read_src2_idx];\nend\n\n// Write logic\nalways_ff @(posedge clk) begin\n    if (wbck_dest_wen) begin\n        if (wbck_dest_idx != 0) begin\n            rf[wbck_dest_idx] <= wbck_dest_dat;\n        end\n    end\nend\n\n// Assign x1_r\nassign x1_r = rf[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 6, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_regfile(\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output logic [E203_XLEN-1:0] read_src1_dat,\n    output logic [E203_XLEN-1:0] read_src2_dat,\n    input  logic                     wbck_dest_wen,\n    input  logic [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input  logic [E203_XLEN-1:0] wbck_dest_dat,\n    output logic [E203_XLEN-1:0] x1_r,\n    input  logic                     test_mode,\n    input  logic                     clk,\n    input  logic                     rst_n\n);\n\nlogic [E203_XLEN-1:0] regfile [E203_RFREG_NUM-1:0];\n\nalways_ff @(posedge clk) begin\n    if (~rst_n) begin\n        for (int i = 0; i < E203_RFREG_NUM; i++) begin\n            regfile[i] <= '0;\n        end\n    end else if (wbck_dest_wen && wbck_dest_idx != 0) begin\n        regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\nend\n\nassign read_src1_dat = (read_src1_idx == 0) ? '0 : regfile[read_src1_idx];\nassign read_src2_dat = (read_src2_idx == 0) ? '0 : regfile[read_src2_idx];\nassign x1_r = regfile[1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 3, "code": "`include \"e203_defines.v\"\n\nmodule e203_reset_ctrl(\n    input  logic        clk,            // System clock\n    input  logic        rst_n,          // Asynchronous reset signal (active low)\n    input  logic        test_mode,      // Test mode enable\n    output logic        rst_core,       // Processor core reset signal\n    output logic        rst_itcm,       // ITCM memory reset signal (conditional compilation)\n    output logic        rst_dtcm,       // DTCM memory reset signal (conditional compilation)\n    output logic        rst_aon          // Always-on module reset signal\n);\n\n// Parameter configuration\nparameter MASTER = 1;                  // Reset controller mode (1 for master controller, 0 for slave controller)\nparameter RST_SYNC_LEVEL = E203_ASYNC_FF_LEVELS; // Synchronous reset cascade depth\n\n// Internal signals\nlogic [RST_SYNC_LEVEL-1:0] rst_sync;\n\n// Reset synchronization mechanism\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        rst_sync <= {RST_SYNC_LEVEL{1'b1}};\n    end else if (test_mode) begin\n        rst_sync <= {RST_SYNC_LEVEL{1'b0}};\n    end else begin\n        rst_sync <= {rst_sync[RST_SYNC_LEVEL-2:0], 1'b1};\n    end\nend\n\n// Operating modes\nalways_comb begin\n    if (MASTER) begin\n        // Master controller mode\n        rst_core = rst_sync[RST_SYNC_LEVEL-1];\n        rst_itcm = rst_sync[RST_SYNC_LEVEL-1];\n        rst_dtcm = rst_sync[RST_SYNC_LEVEL-1];\n        rst_aon = rst_sync[RST_SYNC_LEVEL-1];\n    end else begin\n        // Slave controller mode\n        rst_core = ~rst_n;\n        rst_itcm = ~rst_n;\n        rst_dtcm = ~rst_n;\n        rst_aon = ~rst_n;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 1, "code": "module e203_clk_ctrl(\n    input  logic        clk,              // System clock\n    input  logic        rst_n,            // Asynchronous reset (active low)\n    input  logic        test_mode,        // Test mode signal\n    input  logic        core_cgstop,      // Clock-gated stop signal, from the CSR register\n    input  logic        core_ifu_active,  // Instruction Fetch Unit active status\n    input  logic        core_exu_active,  // Execution unit active state\n    input  logic        core_lsu_active,  // Load storage cell active state\n    input  logic        core_biu_active,  // Bus interface unit active statedt\n    input  logic        core_wfi,         // Wait for interrupt status signal\n    output logic        clk_aon,          // Normally on clock\n    output logic        clk_core_ifu,     // IFU module clock\n    output logic        clk_core_exu,     // EXU module clock\n    output logic        clk_core_lsu,     // LSU module clock\n    output logic        clk_core_biu      // BIU module clock\n);\n\n// Clock enable control logic\nlogic ifu_clk_en;\nlogic exu_clk_en;\nlogic lsu_clk_en;\nlogic biu_clk_en;\n\n// IFU clock enablement conditions\nassign ifu_clk_en = (core_cgstop == 1'b1) || (core_ifu_active == 1'b1 && core_wfi == 1'b0);\n\n// Other core module clock enable conditions\nassign exu_clk_en = (core_cgstop == 1'b1) || (core_exu_active == 1'b1);\nassign lsu_clk_en = (core_cgstop == 1'b1) || (core_lsu_active == 1'b1);\nassign biu_clk_en = (core_cgstop == 1'b1) || (core_biu_active == 1'b1);\n\n// Clock gating\nassign clk_core_ifu = ifu_clk_en ? clk : 1'b0;\nassign clk_core_exu = exu_clk_en ? clk : 1'b0;\nassign clk_core_lsu = lsu_clk_en ? clk : 1'b0;\nassign clk_core_biu = biu_clk_en ? clk : 1'b0;\n\n// Normally on clock\nassign clk_aon = clk;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 1, "code": "module e203_dtcm_ram #(\n    parameter DP = E203_DTCM_RAM_DP, // Depth of the RAM (number of entries)\n    parameter DW = E203_DTCM_RAM_DW, // Data width (in bits)\n    parameter MW = E203_DTCM_RAM_MW, // Write mask width (in bits)\n    parameter AW = E203_DTCM_RAM_AW, // Address width (in bits)\n    parameter FORCE_X2ZERO = 1        // Forces uninitialized memory to zero\n) (\n    input  logic                        sd,      // Power domain shutdown enable signal\n    input  logic                        ds,      // Deep sleep mode enable signal\n    input  logic                        ls,      // Light sleep mode enable signal\n    input  logic                        cs,      // Chip select signal\n    input  logic                        we,      // Write enable signal\n    input  logic [AW-1:0]               addr,    // Address input\n    input  logic [MW-1:0]               wem,     // Write mask\n    input  logic [DW-1:0]               din,     // Data input\n    input  logic                        rst_n,   // Asynchronous reset signal (active low)\n    input  logic                        clk,     // System clock\n    output logic [DW-1:0]               dout     // Data output\n);\n\nlogic [DW-1:0] ram [DP-1:0];\n\nalways_ff @(posedge clk) begin\n    if (~rst_n) begin\n        for (int i = 0; i < DP; i++) begin\n            ram[i] <= '0;\n        end\n    end else if (cs && we) begin\n        for (int i = 0; i < MW; i++) begin\n            if (wem[i]) begin\n                ram[addr][i*8 +: 8] <= din[i*8 +: 8];\n            end\n        end\n    end\nend\n\nalways_comb begin\n    if (cs) begin\n        dout = ram[addr];\n    end else begin\n        dout = '0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 2, "code": "module e203_dtcm_ram #(\n    parameter DP = E203_DTCM_RAM_DP,\n    parameter DW = E203_DTCM_RAM_DW,\n    parameter FORCE_X2ZERO = 1,\n    parameter MW = E203_DTCM_RAM_MW,\n    parameter AW = E203_DTCM_RAM_AW\n) (\n    input  sd,        // Power domain shutdown enable signal\n    input  ds,        // Deep sleep mode enable signal\n    input  ls,        // Light sleep mode enable signal\n    input  cs,        // Chip select signal\n    input  we,        // Write enable signal\n    input  [AW-1:0] addr,  // Address input\n    input  [MW-1:0] wem,   // Write mask\n    input  [DW-1:0] din,   // Data input\n    input  rst_n,     // Asynchronous reset signal (active low)\n    input  clk,       // System clock\n    output [DW-1:0] dout  // Data output\n);\n\nreg [DW-1:0] ram [DP-1:0];\n\nalways @(posedge clk) begin\n    if (~rst_n) begin\n        for (int i = 0; i < DP; i++) begin\n            ram[i] <= {DW{1'b0}};\n        end\n    end else if (cs && we) begin\n        for (int i = 0; i < MW; i++) begin\n            if (wem[i]) begin\n                ram[addr][i*8 +: 8] <= din[i*8 +: 8];\n            end\n        end\n    end\nend\n\nalways @(*) begin\n    if (cs) begin\n        dout <= ram[addr];\n    end else begin\n        dout <= {DW{1'b0}};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 1, "code": "module e203_dtcm_ctrl #(\n    parameter E203_DTCM_ADDR_WIDTH = 14,\n    parameter E203_DTCM_DATA_WIDTH = 32,\n    parameter E203_DTCM_WMSK_WIDTH = 4,\n    parameter E203_HAS_DTCM_EXTITF = 1\n) (\n    input  logic                   clk,\n    input  logic                   rst_n,\n    input  logic                   test_mode,\n    input  logic                   tcm_cgstop,\n    output logic                   dtcm_active,\n\n    // LSU ICB Bus Interface\n    input  logic                   lsu2dtcm_icb_cmd_valid,\n    output logic                   lsu2dtcm_icb_cmd_ready,\n    input  logic [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input  logic                   lsu2dtcm_icb_cmd_read,\n    input  logic [E203_DTCM_DATA_WIDTH-1:0] lsu2dtcm_icb_cmd_wdata,\n    input  logic [E203_DTCM_WMSK_WIDTH-1:0] lsu2dtcm_icb_cmd_wmask,\n    output logic                   lsu2dtcm_icb_rsp_valid,\n    input  logic                   lsu2dtcm_icb_rsp_ready,\n    output logic                   lsu2dtcm_icb_rsp_err,\n    output logic [E203_DTCM_DATA_WIDTH-1:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Bus Interface (Optional)\n    input  logic                   ext2dtcm_icb_cmd_valid,\n    output logic                   ext2dtcm_icb_cmd_ready,\n    input  logic [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input  logic                   ext2dtcm_icb_cmd_read,\n    input  logic [E203_DTCM_DATA_WIDTH-1:0] ext2dtcm_icb_cmd_wdata,\n    input  logic [E203_DTCM_WMSK_WIDTH-1:0] ext2dtcm_icb_cmd_wmask,\n    output logic                   ext2dtcm_icb_rsp_valid,\n    input  logic                   ext2dtcm_icb_rsp_ready,\n    output logic                   ext2dtcm_icb_rsp_err,\n    output logic [E203_DTCM_DATA_WIDTH-1:0] ext2dtcm_icb_rsp_rdata,\n\n    // DTCM RAM Interface\n    output logic                   dtcm_ram_cs,\n    output logic                   dtcm_ram_we,\n    output logic [E203_DTCM_ADDR_WIDTH-1:0] dtcm_ram_addr,\n    output logic [E203_DTCM_WMSK_WIDTH-1:0] dtcm_ram_wem,\n    output logic [E203_DTCM_DATA_WIDTH-1:0] dtcm_ram_din,\n    input  logic [E203_DTCM_DATA_WIDTH-1:0] dtcm_ram_dout,\n    output logic                   clk_dtcm_ram\n);\n\n// ...\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 1, "code": "```ilog\nmodule e203_exu_alu_csrctrl(\n    input  logic                   csr_i_valid,\n    output logic                   csr_i_ready,\n    input  logic [E203_XLEN-1:0]   csr_i_rs1,\n    input  logic [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input  logic                   csr_i_rdwen,\n    output logic                   csr_ena,\n    output logic                   csr_wr_en,\n    output logic                   csr_rd_en,\n    output logic [11:0]            csr_idx,\n    input  logic                   csr_access_ilgl,\n    input  logic [E203_XLEN-1:0]   read_csr_dat,\n    output logic [E203_XLEN-1:0]   wbck_csr_dat,\n    output logic                   csr_o_valid,\n    input  logic                   csr_o_ready,\n    output logic [E203_XLEN-1:0]   csr_o_wbck_wdat,\n    output logic                   csr_o_wbck_err,\n    input  logic                   clk,\n    input  logic                   rst_n,\n    // NICE interface\n    input  logic                   nice_xs_off,\n    output logic                   csr_sel_nice,\n    output logic                   nice_csr_valid,\n    input  logic                   nice_csr_ready,\n    output logic [31:0]            nice_csr_addr,\n    output logic                   nice_csr_wr,\n    output logic [31:0]            nice_csr_wdata,\n    input  logic [31:0]            nice_csr_rdata\n);\n\n    // Control Signal Preparation Logic\n    always_comb begin\n        csr_i_ready = csr_o_ready;\n        csr_ena = csr_i_valid && csr_o_ready;\n        csr_wr_en = (csr_i_info[E203_DECINFO_CSR_CSRRW] || \n                     (csr_i_info[E203_DECINFO_CSR_CSRRS] && !csr_i_rs1[0]) || \n                     (csr_i_info[E203_DECINFO_CSR_CSRRC] && !csr_i_rs1[0])) && csr_i_valid;\n        csr_rd_en = (csr_i_info[E203_DECINFO_CSR_CSRRW] && csr_i_rdwen) || \n                    csr_i_info[E203_DECINFO_CSR_CSRRS] || \n                    csr_i_info[E203_DECINFO_CSR_CSRRC];\n        csr_idx = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n        csr_o_valid = csr_i_valid && nice_csr_ready;\n        csr_o_wbck_wdat = read_csr_dat;\n        csr_o_wbck_err = csr_access_ilgl;\n        wbck_csr_dat = (csr_i_info[E203_DECINFO_CSR_CSRRW]) ? csr_i_rs1 :\n                       (csr_i_info[E203_DECINFO_CSR_CSRRS]) ? (read_csr_dat | csr_i_rs1) :\n                       (csr_i_info[E203_DECINFO_CSR_CSRRC]) ? (read_csr_dat & ~csr_i_rs1) : '0;\n    end\n\n    // NICE interface logic\n    always_comb begin\n        csr_sel_nice = (csr_idx[11:8] == 4'hE) && !nice_xs_off;\n        nice_csr_valid = csr", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 1, "code": "// Import necessary files for global variables and configurations\n`include \"e203_defines.v\"\n\nmodule e203_exu_wbck(\n    input  logic                       alu_wbck_i_valid,\n    output logic                       alu_wbck_i_ready,\n    input  logic [E203_XLEN-1:0]       alu_wbck_i_wdat,\n    input  logic [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input  logic                       longp_wbck_i_valid,\n    output logic                       longp_wbck_i_ready,\n    input  logic [E203_FLEN-1:0]       longp_wbck_i_wdat,\n    input  logic [4:0]                 longp_wbck_i_flags,\n    input  logic [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input  logic                       longp_wbck_i_rdfpu,\n    output logic                       rf_wbck_o_ena,\n    output logic [E203_XLEN-1:0]       rf_wbck_o_wdat,\n    output logic [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input  logic                       clk,\n    input  logic                       rst_n\n);\n\n// Internal signals for arbitration and data selection\nlogic [E203_XLEN-1:0] wbck_i_wdat;\nlogic [E203_RFIDX_WIDTH-1:0] wbck_i_rdidx;\nlogic [4:0] wbck_i_flags;\nlogic wbck_i_rdfpu;\n\n// Arbitration logic to prioritize long-pipeline over ALU write-back\nalways_comb begin\n    if (longp_wbck_i_valid) begin\n        // Long-pipeline has higher priority, select its data and indices\n        wbck_i_wdat  = longp_wbck_i_wdat;\n        wbck_i_rdidx = longp_wbck_i_rdidx;\n        wbck_i_flags = longp_wbck_i_flags;\n        wbck_i_rdfpu = longp_wbck_i_rdfpu;\n        longp_wbck_i_ready = 1'b1; // Ready to accept long-pipeline write-back\n        alu_wbck_i_ready  = 1'b0; // Stall ALU write-back\n    end else if (alu_wbck_i_valid) begin\n        // No long-pipeline request, select ALU data and indices\n        wbck_i_wdat  = alu_wbck_i_wdat;\n        wbck_i_rdidx = alu_wbck_i_rdidx;\n        // ALU does not involve instruction flags and rdfpu\n        wbck_i_flags = 5'b0;\n        wbck_i_rdfpu = 1'b0;\n        alu_wbck_i_ready  = 1'b1; // Ready to accept ALU write-back\n        longp_wbck_i_ready = 1'b0; // No long-pipeline request\n    end else begin\n        // Neither request is valid, reset internal signals\n        wbck_i_wdat  = '0;\n        wbck_i_rdidx = '0;\n        wbck_i_flags = '0;\n        wbck_i_rdfpu = '0;\n        alu_wbck_i_ready  = 1'b0;\n        longp_wbck_i_ready = 1'b0;\n    end\nend\n\n// Forward selected write-back data to the register file\nalways_comb begin\n    if ((wbck_i_rdfpu == 1'b0) && (longp_wbck_i_valid || alu_wbck_i_valid)) begin\n        rf_wbck_o_ena = 1'b1;\n    end else begin\n        rf_wbck_o_ena = 1'b0;\n    end\n    \n    rf_wbck_o_wdat  = wbck_i_wdat;\n    rf_wbck_o_rdidx = wbck_i_rdidx;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 4, "code": "`include \"e203_defines.v\"\n\nmodule e203_reset_ctrl(\n    input  logic        clk,            // System clock\n    input  logic        rst_n,          // Asynchronous reset signal (active low)\n    input  logic        test_mode,      // Test mode enable\n    output logic        rst_core,       // Processor core reset signal\n    output logic        rst_itcm,       // ITCM memory reset signal (conditional compilation)\n    output logic        rst_dtcm,       // DTCM memory reset signal (conditional compilation)\n    output logic        rst_aon         // Always-on module reset signal\n);\n\n// Parameter configuration\nparameter MASTER = 1;                  // Reset controller mode (1 for master controller, 0 for slave controller)\nparameter RST_SYNC_LEVEL = E203_ASYNC_FF_LEVELS; // Synchronous reset cascade depth\n\n// Internal signals\nlogic [RST_SYNC_LEVEL-1:0] rst_sync;\n\n// Reset synchronization mechanism\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        rst_sync <= {RST_SYNC_LEVEL{1'b1}};\n    end else if (test_mode) begin\n        rst_sync <= {RST_SYNC_LEVEL{1'b0}};\n    end else begin\n        rst_sync <= {1'b1, rst_sync[RST_SYNC_LEVEL-1:1]};\n    end\nend\n\n// Operating modes\nalways_comb begin\n    if (MASTER) begin\n        // Master controller mode\n        rst_core = rst_sync[0];\n        rst_itcm = rst_sync[0];\n        rst_dtcm = rst_sync[0];\n        rst_aon = rst_sync[0];\n    end else begin\n        // Slave controller mode\n        rst_core = ~rst_n;\n        rst_itcm = ~rst_n;\n        rst_dtcm = ~rst_n;\n        rst_aon = ~rst_n;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 7, "code": "```ilog\n// e203_exu_regfile.v\n// Integer general-purpose register file as defined by the RISC-V architecture\n\n`include \"e203_defines.v\"\n\nmodule e203_exu_regfile(\n    // Basic Interface\n    input   logic [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input   logic [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output  logic [E203_XLEN-1:0] read_src1_dat,\n    output  logic [E203_XLEN-1:0] read_src2_dat,\n    input   logic                     wbck_dest_wen,\n    input   logic [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input   logic [E203_XLEN-1:0]     wbck_dest_dat,\n    output  logic [E203_XLEN-1:0]     x1_r,\n    input   logic                     test_mode,\n    input   logic                     clk,\n    input   logic                     rst_n\n);\n\n// Register file implementation based on E203_REGFILE_LATCH_BASED macro\n`ifdef E203_REGFILE_LATCH_BASED\n    // Latch-based implementation\n    sirv_gnrl_ltch #(\n        .DW(E203_XLEN)\n    ) u_regfile [\n        .lden(wbck_dest_wen),\n        .dnxt(wbck_dest_dat),\n        .qout(read_src1_dat)\n    ] (\n        .idx(read_src1_idx)\n    );\n\n    sirv_gnrl_ltch #(\n        .DW(E203_XLEN)\n    ) u_regfile2 [\n        .lden(wbck_dest_wen),\n        .dnxt(wbck_dest_dat),\n        .qout(read_src2_dat)\n    ] (\n        .idx(read_src2_idx)\n    );\n`else\n    // DFF-based implementation\n    sirv_gnrl_dffl #(\n        .DW(E203_XLEN)\n    ) u_regfile [\n        .lden(wbck_dest_wen),\n        .dnxt(wbck_dest_dat),\n        .qout(read_src1_dat),\n        .clk(clk)\n    ] (\n        .idx(read_src1_idx)\n    );\n\n    sirv_gnrl_dffl #(\n        .DW(E203_XLEN)\n    ) u_regfile2 [\n        .lden(wbck_dest_wen),\n        .dnxt(wbck_dest_dat),\n        .qout(read_src2_dat),\n        .clk(clk)\n    ] (\n        .idx(read_src2_idx)\n    );\n`endif\n\n// Assign x1_r to read_src1_dat\nassign x1_r = read_src1_dat;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 2, "code": "module e203_clk_ctrl(\n    input  logic            clk,            // System clock\n    input  logic            rst_n,          // Asynchronous reset (active low)\n    input  logic            test_mode,      // Test mode signal\n    input  logic            core_cgstop,    // Clock-gated stop signal, from the CSR register\n    input  logic            core_ifu_active,// Instruction Fetch Unit active status\n    input  logic            core_exu_active,// Execution unit active state\n    input  logic            core_lsu_active,// Load storage cell active state\n    input  logic            core_biu_active,// Bus interface unit active statedt\n    input  logic            core_wfi,       // Wait for interrupt status signal\n    input  logic            itcm_active,    // ITCM active status (optional)\n    input  logic            dtcm_active,    // DTCM active status (optional)\n    output logic            clk_aon,        // Normally on clock\n    output logic            clk_core_ifu,   // IFU module clock\n    output logic            clk_core_exu,   // EXU module clock\n    output logic            clk_core_lsu,   // LSU module clock\n    output logic            clk_core_biu,   // BIU module clock\n    output logic            itcm_ls,        // ITCM clock low power state (optional)\n    output logic            dtcm_ls,        // DTCM clock low power state (optional)\n    output logic            clk_itcm,       // ITCM module clock (optional)\n    output logic            clk_dtcm        // DTCM module clock (optional)\n);\n\n// Clock enable control logic\nlogic ifu_clk_en;\nlogic exu_clk_en;\nlogic lsu_clk_en;\nlogic biu_clk_en;\n\n// ITCM and DTCM clock control (optional)\nlogic itcm_clk_en;\nlogic dtcm_clk_en;\n\n// Clock gating\nassign ifu_clk_en = core_cgstop || (core_ifu_active && !core_wfi);\nassign exu_clk_en = core_cgstop || core_exu_active;\nassign lsu_clk_en = core_cgstop || core_lsu_active;\nassign biu_clk_en = core_cgstop || core_biu_active;\n\n// Optional ITCM and DTCM clock control\nassign itcm_clk_en = core_cgstop || itcm_active;\nassign dtcm_clk_en = core_cgstop || dtcm_active;\n\n// Clock generation\nassign clk_aon = clk;\nassign clk_core_ifu = ifu_clk_en ? clk : 1'b0;\nassign clk_core_exu = exu_clk_en ? clk : 1'b0;\nassign clk_core_lsu = lsu_clk_en ? clk : 1'b0;\nassign clk_core_biu = biu_clk_en ? clk : 1'b0;\n\n// Optional ITCM and DTCM clocks\nassign clk_itcm = itcm_clk_en ? clk : 1'b0;\nassign clk_dtcm = dtcm_clk_en ? clk : 1'b0;\n\n// Low power states (optional)\nassign itcm_ls = ~itcm_clk_en;\nassign dtcm_ls = ~dtcm_clk_en;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 2, "code": "```ilog\n`include \"e203_defines.v\"\n\nmodule e203_exu_wbck(\n    input  logic                   alu_wbck_i_valid,\n    output logic                   alu_wbck_i_ready,\n    input  logic [E203_XLEN-1:0]   alu_wbck_i_wdat,\n    input  logic [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input  logic                   longp_wbck_i_valid,\n    output logic                   longp_wbck_i_ready,\n    input  logic [E203_FLEN-1:0]   longp_wbck_i_wdat,\n    input  logic [4:0]             longp_wbck_i_flags,\n    input  logic [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input  logic                   longp_wbck_i_rdfpu,\n    output logic                   rf_wbck_o_ena,\n    output logic [E203_XLEN-1:0]   rf_wbck_o_wdat,\n    output logic [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n\nlogic [E203_XLEN-1:0] wbck_i_wdat;\nlogic [E203_RFIDX_WIDTH-1:0] wbck_i_rdidx;\nlogic [4:0] wbck_i_flags;\nlogic wbck_i_rdfpu;\n\nalways_comb begin\n    if (longp_wbck_i_valid) begin\n        wbck_i_wdat  = longp_wbck_i_wdat;\n        wbck_i_rdidx = longp_wbck_i_rdidx;\n        wbck_i_flags = longp_wbck_i_flags;\n        wbck_i_rdfpu = longp_wbck_i_rdfpu;\n        longp_wbck_i_ready = 1'b1;\n        alu_wbck_i_ready    = 1'b0;\n    end else if (alu_wbck_i_valid) begin\n        wbck_i_wdat  = alu_wbck_i_wdat;\n        wbck_i_rdidx = alu_wbck_i_rdidx;\n        wbck_i_flags = 5'b0;\n        wbck_i_rdfpu = 1'b0;\n        alu_wbck_i_ready    = 1'b1;\n        longp_wbck_i_ready = 1'b0;\n    end else begin\n        alu_wbck_i_ready    = 1'b0;\n        longp_wbck_i_ready = 1'b0;\n    end\nend\n\nalways_comb begin\n    if (wbck_i_rdfpu) begin\n        rf_wbck_o_ena = 1'b0;\n    end else begin\n        rf_wbck_o_ena = (alu_wbck_i_valid || longp_wbck_i_valid);\n    end\n    rf_wbck_o_wdat = wbck_i_wdat;\n    rf_wbck_o_rdidx = wbck_i_rdidx;\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 3, "code": "```ilog\n// Import necessary files for global variables and configurations\n`include \"e203_defines.v\"\n\nmodule e203_clk_ctrl (\n    input  logic                clk,           // System clock\n    input  logic                rst_n,         // Asynchronous reset (active low)\n    input  logic                test_mode,     // Test mode signal\n    input  logic                core_cgstop,   // Clock-gated stop signal, from the CSR register\n    input  logic                core_ifu_active, // Instruction Fetch Unit active status\n    input  logic                core_exu_active, // Execution unit active state\n    input  logic                core_lsu_active, // Load storage cell active state\n    input  logic                core_biu_active, // Bus interface unit active statedt\n    input  logic                core_wfi,      // Wait for interrupt status signal\n    input  logic                itcm_active,   // ITCM active status (optional)\n    input  logic                dtcm_active,   // DTCM active status (optional)\n    output logic                clk_aon,       // Normally on clock\n    output logic                clk_core_ifu,  // IFU module clock\n    output logic                clk_core_exu,  // EXU module clock\n    output logic                clk_core_lsu,  // LSU module clock\n    output logic                clk_core_biu,  // BIU module clock\n    output logic                itcm_ls,       // ITCM clock low power state (optional)\n    output logic                dtcm_ls,       // DTCM clock low power state (optional)\n    output logic                clk_itcm,      // ITCM module clock (optional)\n    output logic                clk_dtcm       // DTCM module clock (optional)\n);\n\n// Internal signals for clock control logic\nlogic ifu_clk_en;\nlogic exu_clk_en;\nlogic lsu_clk_en;\nlogic biu_clk_en;\n\n// Clock enable control logic\nassign ifu_clk_en = core_cgstop || (core_ifu_active && !core_wfi);\nassign exu_clk_en = core_cgstop || core_exu_active;\nassign lsu_clk_en = core_cgstop || core_lsu_active;\nassign biu_clk_en = core_cgstop || core_biu_active;\n\n// Clock gating for each module\nassign clk_core_ifu = ifu_clk_en ? clk : 1'b0;\nassign clk_core_exu = exu_clk_en ? clk : 1'b0;\nassign clk_core_lsu = lsu_clk_en ? clk : 1'b0;\nassign clk_core_biu = biu_clk_en ? clk : 1'b0;\n\n// Normally on clock\nassign clk_aon = clk;\n\n// Optional ITCM and DTCM clock control\ngenerate\n    if (E203_HAS_ITCM) begin\n        logic itcm_clk_en;\n        assign itcm_clk_en = core_cgstop || itcm_active;\n        assign clk_itcm = itcm_clk_en ? clk : 1'b0;\n        assign itcm_ls = !itcm_clk_en;\n    end else begin\n        assign clk_itcm = 1'b0;\n        assign itcm_ls = 1'b0;\n    end\n\n    if (E203_HAS_DTCM) begin\n        logic dtcm_clk_en;\n        assign dtcm_clk_en = core_cgstop || dtcm_active;\n        assign clk_dtcm = dtcm_clk_en ? clk : 1'b0;\n        assign dtcm_ls = !dtcm_clk_en;\n    end else begin\n        assign clk_dtcm = 1'b0;\n        assign dtcm_ls = 1'b0;\n    end\nendgenerate\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 4, "code": "// Import necessary files\n`include \"e203_defines.v\"\n\n// Define the module\nmodule e203_clk_ctrl (\n    // Basic input signals\n    input  wire        clk,            // System clock\n    input  wire        rst_n,          // Asynchronous reset (active low)\n    input  wire        test_mode,      // Test mode signal\n    input  wire        core_cgstop,    // Clock-gated stop signal\n\n    // Functional unit activity state signals\n    input  wire        core_ifu_active, // Instruction Fetch Unit active status\n    input  wire        core_exu_active, // Execution unit active state\n    input  wire        core_lsu_active, // Load storage cell active state\n    input  wire        core_biu_active, // Bus interface unit active state\n    input  wire        core_wfi,       // Wait for interrupt status signal\n\n    // Optional signals\n    input  wire        itcm_active,    // ITCM active status (if E203_HAS_ITCM is defined)\n    output wire        itcm_ls,        // ITCM clock low power state (if E203_HAS_ITCM is defined)\n    input  wire        dtcm_active,    // DTCM active status (if E203_HAS_DTCM is defined)\n    output wire        dtcm_ls,        // DTCM clock low power state (if E203_HAS_DTCM is defined)\n    output wire        clk_itcm,       // ITCM module clock (if E203_HAS_ITCM is defined)\n    output wire        clk_dtcm,       // DTCM module clock (if E203_HAS_DTCM is defined)\n\n    // Clock output signals\n    output wire        clk_aon,        // Normally on clock\n    output wire        clk_core_ifu,   // IFU module clock\n    output wire        clk_core_exu,   // EXU module clock\n    output wire        clk_core_lsu,   // LSU module clock\n    output wire        clk_core_biu    // BIU module clock\n);\n\n// Define internal signals\nwire clk_gated_ifu;\nwire clk_gated_exu;\nwire clk_gated_lsu;\nwire clk_gated_biu;\n\n// Clock enable control logic\nassign clk_gated_ifu = core_cgstop || (core_ifu_active && !core_wfi);\nassign clk_gated_exu = core_cgstop || core_exu_active;\nassign clk_gated_lsu = core_cgstop || core_lsu_active;\nassign clk_gated_biu = core_cgstop || core_biu_active;\n\n// Clock gating\ne203_clkgate u_clkgate_ifu (\n    .clk(clk),\n    .en(clk_gated_ifu),\n    .clk_out(clk_core_ifu)\n);\n\ne203_clkgate u_clkgate_exu (\n    .clk(clk),\n    .en(clk_gated_exu),\n    .clk_out(clk_core_exu)\n);\n\ne203_clkgate u_clkgate_lsu (\n    .clk(clk),\n    .en(clk_gated_lsu),\n    .clk_out(clk_core_lsu)\n);\n\ne203_clkgate u_clkgate_biu (\n    .clk(clk),\n    .en(clk_gated_biu),\n    .clk_out(clk_core_biu)\n);\n\n// Assign normally on clock\nassign clk_aon = clk;\n\n// Optional ITCM and DTCM clock control\n`ifdef E203_HAS_ITCM\n    assign clk_itcm = core_cgstop || itcm_active || itcm_active_r;\n    assign itcm_ls = !clk_itcm;\n`endif\n\n`ifdef E203_HAS_DTCM\n    assign clk_dtcm = core_cgstop || dtcm_active || dtcm_active_r;\n    assign dtcm_ls = !clk_dtcm;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 2, "code": "module e203_irq_sync(\n    input  logic        clk,            // System clock signal\n    input  logic        rst_n,          // Asynchronous reset signal (active low)\n    input  logic        ext_irq_a,      // External interrupt input signal\n    input  logic        sft_irq_a,      // Software interrupt input signal\n    input  logic        tmr_irq_a,      // Timer interrupt input signal\n    input  logic        dbg_irq_a,      // Debug interrupt input signal\n    output logic        ext_irq_r,      // Synchronized external interrupt signal\n    output logic        sft_irq_r,      // Synchronized software interrupt signal\n    output logic        tmr_irq_r,      // Synchronized timer interrupt signal\n    output logic        dbg_irq_r       // Synchronized debug interrupt signal\n);\n\n// Define parameters\nparameter DP = 2;  // Depth of the synchronizer (number of flip-flops)\nparameter DW = 1;  // Data width (in bits)\n\n// Internal signals\nlogic [DP-1:0] ext_irq_sync;\nlogic [DP-1:0] sft_irq_sync;\nlogic [DP-1:0] tmr_irq_sync;\nlogic [DP-1:0] dbg_irq_sync;\n\n// Synchronization logic for each interrupt type\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        ext_irq_sync <= '0;\n        sft_irq_sync <= '0;\n        tmr_irq_sync <= '0;\n        dbg_irq_sync <= '0;\n    end else begin\n        ext_irq_sync <= {ext_irq_sync[DP-2:0], ext_irq_a};\n        sft_irq_sync <= {sft_irq_sync[DP-2:0], sft_irq_a};\n        tmr_irq_sync <= {tmr_irq_sync[DP-2:0], tmr_irq_a};\n        dbg_irq_sync <= {dbg_irq_sync[DP-2:0], dbg_irq_a};\n    end\nend\n\n// Output assignments\nassign ext_irq_r = ext_irq_sync[DP-1];\nassign sft_irq_r = sft_irq_sync[DP-1];\nassign tmr_irq_r = tmr_irq_sync[DP-1];\nassign dbg_irq_r = dbg_irq_sync[DP-1];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 5, "code": "// Import necessary files\n`include \"e203_defines.v\"\n\n// Module definition\nmodule e203_clk_ctrl (\n    // Basic input signals\n    input  logic        clk,         // System clock\n    input  logic        rst_n,       // Asynchronous reset (active low)\n    input  logic        test_mode,   // Test mode signal\n    input  logic        core_cgstop, // Clock-gated stop signal, from the CSR register\n\n    // Functional unit activity state signals\n    input  logic        core_ifu_active, // Instruction Fetch Unit active status\n    input  logic        core_exu_active, // Execution unit active state\n    input  logic        core_lsu_active, // Load storage cell active state\n    input  logic        core_biu_active, // Bus interface unit active state\n    input  logic        core_wfi,       // Wait for interrupt status signal\n\n    // Optional signals (ITCM and DTCM)\n    input  logic        itcm_active,  // ITCM active status (if E203_HAS_ITCM is defined)\n    output logic        itcm_ls,      // ITCM clock low power state (if E203_HAS_ITCM is defined)\n    input  logic        dtcm_active,  // DTCM active status (if E203_HAS_DTCM is defined)\n    output logic        dtcm_ls,      // DTCM clock low power state (if E203_HAS_DTCM is defined)\n    output logic        clk_itcm,     // ITCM module clock (if E203_HAS_ITCM is defined)\n    output logic        clk_dtcm,     // DTCM module clock (if E203_HAS_DTCM is defined)\n\n    // Clock output signals\n    output logic        clk_aon,      // Normally on clock\n    output logic        clk_core_ifu, // IFU module clock\n    output logic        clk_core_exu, // EXU module clock\n    output logic        clk_core_lsu, // LSU module clock\n    output logic        clk_core_biu  // BIU module clock\n);\n\n// Clock enable control logic\nlogic clk_ifu_enable;\nlogic clk_exu_enable;\nlogic clk_lsu_enable;\nlogic clk_biu_enable;\n\n// Clock gating logic for each core module\nassign clk_ifu_enable = core_cgstop || (core_ifu_active && !core_wfi);\nassign clk_exu_enable = core_cgstop || core_exu_active;\nassign clk_lsu_enable = core_cgstop || core_lsu_active;\nassign clk_biu_enable = core_cgstop || core_biu_active;\n\n// Generate clock outputs based on enable signals\nassign clk_core_ifu = clk_ifu_enable ? clk : 1'b0;\nassign clk_core_exu = clk_exu_enable ? clk : 1'b0;\nassign clk_core_lsu = clk_lsu_enable ? clk : 1'b0;\nassign clk_core_biu = clk_biu_enable ? clk : 1'b0;\n\n// Normally on clock\nassign clk_aon = clk;\n\n// ITCM and DTCM clock control (if enabled)\n`ifdef E203_HAS_ITCM\n    assign clk_itcm = itcm_active || core_cgstop ? clk : 1'b0;\n    assign itcm_ls = !itcm_active && !core_cgstop;\n`endif\n\n`ifdef E203_HAS_DTCM\n    assign clk_dtcm = dtcm_active || core_cgstop ? clk : 1'b0;\n    assign dtcm_ls = !dtcm_active && !core_cgstop;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 3, "code": "module e203_exu_wbck(\n    input  logic                    alu_wbck_i_valid,\n    output logic                    alu_wbck_i_ready,\n    input  logic [E203_XLEN-1:0]    alu_wbck_i_wdat,\n    input  logic [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input  logic                    longp_wbck_i_valid,\n    output logic                    longp_wbck_i_ready,\n    input  logic [E203_FLEN-1:0]    longp_wbck_i_wdat,\n    input  logic [4:0]              longp_wbck_i_flags,\n    input  logic [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input  logic                    longp_wbck_i_rdfpu,\n    output logic                    rf_wbck_o_ena,\n    output logic [E203_XLEN-1:0]    rf_wbck_o_wdat,\n    output logic [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input  logic                    clk,\n    input  logic                    rst_n\n);\n\nlogic [E203_XLEN-1:0] wbck_i_wdat;\nlogic [E203_RFIDX_WIDTH-1:0] wbck_i_rdidx;\nlogic [4:0] wbck_i_flags;\nlogic wbck_i_rdfpu;\n\nalways_comb begin\n    if (longp_wbck_i_valid) begin\n        longp_wbck_i_ready = 1'b1;\n        alu_wbck_i_ready = 1'b0;\n        wbck_i_wdat = longp_wbck_i_wdat;\n        wbck_i_rdidx = longp_wbck_i_rdidx;\n        wbck_i_flags = longp_wbck_i_flags;\n        wbck_i_rdfpu = longp_wbck_i_rdfpu;\n    end else begin\n        longp_wbck_i_ready = 1'b0;\n        alu_wbck_i_ready = alu_wbck_i_valid;\n        wbck_i_wdat = alu_wbck_i_wdat;\n        wbck_i_rdidx = alu_wbck_i_rdidx;\n        wbck_i_flags = 5'b0;\n        wbck_i_rdfpu = 1'b0;\n    end\nend\n\nalways_comb begin\n    if (wbck_i_rdfpu) begin\n        rf_wbck_o_ena = 1'b0;\n    end else begin\n        rf_wbck_o_ena = (longp_wbck_i_valid || alu_wbck_i_valid);\n    end\n    rf_wbck_o_wdat = wbck_i_wdat;\n    rf_wbck_o_rdidx = wbck_i_rdidx;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 1, "code": "module e203_cpu #(\n    parameter E203_CFG_ADDR_SIZE_IS_16 = 1'd0,\n    parameter E203_CFG_ADDR_SIZE_IS_24 = 1'd0,\n    parameter E203_CFG_ADDR_SIZE_IS_32 = 1'd1,\n    parameter E203_CFG_DEBUG_HAS_JTAG = 1'd0,\n    parameter E203_CFG_IRQ_NEED_SYNC = 1'd0,\n    parameter E203_CFG_SUPPORT_MCYCLE_MINSTRET = 1'd0,\n    parameter E203_CFG_REGNUM_IS_32 = 1'd1,\n    parameter E203_CFG_HAS_ECC = 1'd0,\n    parameter E203_CFG_HAS_NICE = 1'd0,\n    parameter E203_CFG_SUPPORT_SHARE_MULDIV = 1'd0,\n    parameter E203_CFG_SUPPORT_AMO = 1'd0,\n    parameter E203_CFG_HAS_ITCM = 1'd0,\n    parameter E203_CFG_ITCM_ADDR_WIDTH = 16'd16,\n    parameter E203_CFG_HAS_DTCM = 1'd0,\n    parameter E203_CFG_DTCM_ADDR_WIDTH = 16'd16,\n    parameter E203_CFG_ITCM_ADDR_BASE = 32'h8000_0000,\n    parameter E203_CFG_DTCM_ADDR_BASE = 32'h9000_0000,\n    parameter E203_CFG_PPI_ADDR_BASE = 32'h1000_0000,\n    parameter E203_CFG_PPI_BASE_REGION = 16'd1,\n    parameter E203_CFG_CLINT_ADDR_BASE = 32'h0200_0000,\n    parameter E203_CFG_CLINT_BASE_REGION = 16'd2,\n    parameter E203_CFG_PLIC_ADDR_BASE = 32'h0C00_0000,\n    parameter E203_CFG_PLIC_BASE_REGION = 16'd3,\n    parameter E203_CFG_FIO_ADDR_BASE = 32'hF000_0000,\n    parameter E203_CFG_FIO_BASE_REGION = 16'd4\n)(\n    input  logic                   clk,\n    input  logic                   rst_n,\n    input  logic                   test_mode,\n    output logic                   inspect_pc,\n    output logic                   inspect_dbg_irq,\n    output logic                   inspect_mem_cmd_valid,\n    output logic                   inspect_mem_cmd_ready,\n    output logic                   inspect_mem_rsp_valid,\n    output logic                   inspect_mem_rsp_ready,\n    output logic                   inspect_core_clk,\n    output logic                   core_csr_clk,\n    output logic                   core_wfi,\n    output logic                   tm_stop,\n    input  logic [31:0]            pc_rtvec,\n    input  logic [31:0]            core_mhartid,\n    input  logic                   dbg_irq_a,\n    input  logic                   ext_irq_a,\n    input  logic                   sft_irq_a,\n    input  logic                   tmr_irq_a,\n    // ...\n);\n    // ...\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 1, "code": "module e203_ifu_litebpu #(\n    parameter E203_PC_SIZE = 32,\n    parameter E203_XLEN = 32,\n    parameter E203_RFIDX_WIDTH = 5\n) (\n    input  logic                   clk,\n    input  logic                   rst_n,\n    input  logic [E203_PC_SIZE-1:0] pc,\n    input  logic                   dec_jal,\n    input  logic                   dec_jalr,\n    input  logic                   dec_bxx,\n    input  logic [E203_XLEN-1:0]   dec_bjp_imm,\n    input  logic [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    input  logic                   oitf_empty,\n    input  logic                   ir_empty,\n    input  logic                   ir_rs1en,\n    input  logic                   jalr_rs1idx_cam_irrdidx,\n    input  logic                   dec_i_valid,\n    input  logic                   ir_valid_clr,\n    input  logic [E203_XLEN-1:0]   rf2bpu_x1,\n    input  logic [E203_XLEN-1:0]   rf2bpu_rs1,\n    output logic                   prdt_taken,\n    output logic [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n    output logic [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n    output logic                   bpu_wait,\n    output logic                   bpu2rf_rs1_ena\n);\n\nlogic [E203_RFIDX_WIDTH-1:0] rs1xn_rdrf_r;\nlogic rs1xn_rdrf_ena;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rs1xn_rdrf_r <= '0;\n    end else if (rs1xn_rdrf_ena) begin\n        rs1xn_rdrf_r <= dec_jalr_rs1idx;\n    end\nend\n\nassign prdt_taken = dec_jal | dec_jalr | (dec_bxx & ~dec_bjp_imm[E203_XLEN-1]);\n\nalways_comb begin\n    case (1'b1)\n        dec_jal: begin\n            prdt_pc_add_op1 = pc;\n            prdt_pc_add_op2 = {E203_PC_SIZE{1'b0}} + dec_bjp_imm;\n        end\n        dec_jalr: begin\n            if (dec_jalr_rs1idx == 5'd0) begin\n                prdt_pc_add_op1 = '0;\n            end else if (dec_jalr_rs1idx == 5'd1) begin\n                prdt_pc_add_op1 = rf2bpu_x1;\n            end else begin\n                prdt_pc_add_op1 = rf2bpu_rs1;\n            end\n            prdt_pc_add_op2 = dec_bjp_imm;\n        end\n        dec_bxx: begin\n            prdt_pc_add_op1 = pc;\n            prdt_pc_add_op2 = dec_bjp_imm;\n        end\n        default: begin\n            prdt_pc_add_op1 = '0;\n            prdt_pc_add_op2 = '0;\n        end\n    endcase\nend\n\nassign bpu_wait = (dec_jalr & ~oitf_empty & ~ir_empty) | (dec_jalr & jalr_rs1idx_cam_irrdidx);\n\nassign bpu2rf_rs1_ena = dec_jalr & ~rs1xn_rdrf_r;\n\nassign rs1xn_rdrf_ena = dec_jalr & ~rs1xn_rdrf_r & dec_i_valid & ~ir_valid_clr;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 1, "code": "module e203_srams #(\n    parameter E203_HAS_ITCM = 1,\n    parameter E203_HAS_DTCM = 1,\n    parameter E203_ITCM_ADDR_WIDTH = 10,\n    parameter E203_DTCM_ADDR_WIDTH = 10\n) (\n    input  logic                   itcm_ram_sd,\n    input  logic                   itcm_ram_ds,\n    input  logic                   itcm_ram_ls,\n    input  logic                   itcm_ram_cs,\n    input  logic                   itcm_ram_we,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] itcm_ram_addr,\n    input  logic [3:0]             itcm_ram_wem,\n    input  logic [31:0]            itcm_ram_din,\n    output logic [31:0]            itcm_ram_dout,\n    input  logic                   clk_itcm_ram,\n    input  logic                   rst_itcm,\n\n    input  logic                   dtcm_ram_sd,\n    input  logic                   dtcm_ram_ds,\n    input  logic                   dtcm_ram_ls,\n    input  logic                   dtcm_ram_cs,\n    input  logic                   dtcm_ram_we,\n    input  logic [E203_DTCM_ADDR_WIDTH-1:0] dtcm_ram_addr,\n    input  logic [3:0]             dtcm_ram_wem,\n    input  logic [31:0]            dtcm_ram_din,\n    output logic [31:0]            dtcm_ram_dout,\n    input  logic                   clk_dtcm_ram,\n    input  logic                   rst_dtcm\n);\n\nlogic [31:0] itcm_ram [2**E203_ITCM_ADDR_WIDTH-1:0];\nlogic [31:0] dtcm_ram [2**E203_DTCM_ADDR_WIDTH-1:0];\n\nalways_ff @(posedge clk_itcm_ram or negedge rst_itcm) begin\n    if (~rst_itcm) begin\n        itcm_ram <= '{default: '0};\n    end else if (itcm_ram_cs && itcm_ram_we) begin\n        itcm_ram[itcm_ram_addr] <= itcm_ram_din;\n    end\nend\n\nalways_ff @(posedge clk_dtcm_ram or negedge rst_dtcm) begin\n    if (~rst_dtcm) begin\n        dtcm_ram <= '{default: '0};\n    end else if (dtcm_ram_cs && dtcm_ram_we) begin\n        dtcm_ram[dtcm_ram_addr] <= dtcm_ram_din;\n    end\nend\n\nalways_comb begin\n    itcm_ram_dout = itcm_ram[itcm_ram_addr];\n    dtcm_ram_dout = dtcm_ram[dtcm_ram_addr];\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 4, "code": "module e203_itcm_ram #(\n    parameter DP = E203_ITCM_RAM_DP, // RAM depth\n    parameter DW = E203_ITCM_RAM_DW, // Data width\n    parameter MW = E203_ITCM_RAM_MW, // Write mask width\n    parameter AW = E203_ITCM_RAM_AW  // Address width\n)(\n    input  logic                        sd,      // Power domain shutdown enable signal\n    input  logic                        ds,      // Deep sleep mode enable signal\n    input  logic                        ls,      // Light sleep mode enable signal\n    input  logic                        cs,      // Chip select signal\n    input  logic                        we,      // Write enable signal\n    input  logic [AW-1:0]               addr,    // Address input\n    input  logic [MW-1:0]               wem,     // Write mask\n    input  logic [DW-1:0]               din,     // Data input\n    input  logic                        rst_n,   // Asynchronous reset signal (active low)\n    input  logic                        clk,     // System clock\n    output logic [DW-1:0]               dout     // Data output\n);\n\nlogic [DW-1:0] ram [DP-1:0]; // Register array for RAM storage\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset all memory locations to zero on asynchronous reset\n        for (int i = 0; i < DP; i++) begin\n            ram[i] <= '0;\n        end\n    end else if (cs && we) begin\n        // Write data to RAM location specified by addr, using wem as write mask\n        for (int i = 0; i < MW; i++) begin\n            if (wem[i]) begin\n                ram[addr][i*8 +: 8] <= din[i*8 +: 8];\n            end\n        end\n    end\nend\n\nalways_comb begin\n    // Read data from RAM location specified by addr\n    if (cs) begin\n        dout = ram[addr];\n    end else begin\n        dout = '0; // Return zero if chip select is low\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 1, "code": "module e203_exu_nice(\n    input  logic                   nice_i_xs_off,\n    input  logic                   nice_i_valid,\n    output logic                   nice_i_ready,\n    input  logic [E203_XLEN-1:0]   nice_i_instr,\n    input  logic [E203_XLEN-1:0]   nice_i_rs1,\n    input  logic [E203_XLEN-1:0]   nice_i_rs2,\n    input  logic [E203_ITAG_WIDTH-1:0] nice_i_itag,\n    output logic                   nice_o_longpipe,\n    output logic                   nice_o_valid,\n    input  logic                   nice_o_ready,\n    output logic                   nice_o_itag_valid,\n    input  logic                   nice_o_itag_ready,\n    output logic [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input  logic                   nice_rsp_multicyc_valid,\n    output logic                   nice_rsp_multicyc_ready,\n    output logic                   nice_req_valid,\n    input  logic                   nice_req_ready,\n    output logic [E203_XLEN-1:0]   nice_req_instr,\n    output logic [E203_XLEN-1:0]   nice_req_rs1,\n    output logic [E203_XLEN-1:0]   nice_req_rs2,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n\n// Internal signals and variables\nlogic [E203_ITAG_WIDTH-1:0] itag_fifo [3:0];\nlogic [1:0] itag_fifo_ptr;\nlogic itag_fifo_empty;\nlogic itag_fifo_full;\n\n// FIFO implementation for instruction tags\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        itag_fifo_ptr <= 2'b00;\n        itag_fifo_empty <= 1'b1;\n        itag_fifo_full <= 1'b0;\n    end else begin\n        // FIFO write logic\n        if (nice_i_valid && nice_i_ready && ~itag_fifo_full) begin\n            itag_fifo[itag_fifo_ptr] <= nice_i_itag;\n            itag_fifo_ptr <= itag_fifo_ptr + 1'b1;\n            itag_fifo_empty <= 1'b0;\n            if (itag_fifo_ptr == 2'b11) begin\n                itag_fifo_full <= 1'b1;\n            end\n        end\n        \n        // FIFO read logic\n        if (nice_rsp_multicyc_valid && nice_rsp_multicyc_ready && ~itag_fifo_empty) begin\n            itag_fifo_ptr <= itag_fifo_ptr - 1'b1;\n            itag_fifo_full <= 1'b0;\n            if (itag_fifo_ptr == 2'b00) begin\n                itag_fifo_empty <= 1'b1;\n            end\n        end\n    end\nend\n\n// Handshaking protocol implementation\nalways_comb begin\n    nice_i_ready = ~nice_i_xs_off && ~itag_fifo_full;\n    nice_o_valid = ~itag_fifo_empty;\n    nice_o_itag_valid = nice_o_valid && nice_o_itag_ready;\n    nice_rsp_multicyc_ready = ~itag_fifo_empty;\n    nice_req_valid = nice_i_valid && nice_i_ready;\n    nice_req_instr = nice_i_instr;\n    nice_req_rs1 = nice_i_rs1;\n    nice_req_rs2 = nice_i_rs2;\n    nice_o_itag = itag_fifo[0];\n    nice_o_longpipe = ~nice_i_xs_off;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 2, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n\n// ... rest of the module implementation ...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 1, "code": "module e203_ifu_minidec #(\n    parameter E203_INSTR_SIZE = 32,\n    parameter E203_RFIDX_WIDTH = 5,\n    parameter E203_XLEN = 32\n) (\n    input   [E203_INSTR_SIZE-1:0]   instr,\n    output                      dec_rs1en,\n    output                      dec_rs2en,\n    output  [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output  [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output                      dec_mulhsu,\n    output                      dec_mul,\n    output                      dec_div,\n    output                      dec_rem,\n    output                      dec_divu,\n    output                      dec_remu,\n    output                      dec_rv32,\n    output                      dec_bjp,\n    output                      dec_jal,\n    output                      dec_jalr,\n    output                      dec_bxx,\n    output  [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output  [E203_XLEN-1:0]       dec_bjp_imm\n);\n    // Instruction decoding logic\n    assign dec_rs1en = (instr[19:15] != 0);\n    assign dec_rs2en = (instr[24:20] != 0 && instr[14:12] != 3'b000);\n    assign dec_rs1idx = instr[19:15];\n    assign dec_rs2idx = instr[24:20];\n\n    assign dec_mulhsu = (instr[6:0] == 7'b0000001 && instr[14:12] == 3'b000);\n    assign dec_mul = (instr[6:0] == 7'b0000001 && instr[14:12] == 3'b001);\n    assign dec_div = (instr[6:0] == 7'b0000001 && instr[14:12] == 3'b100);\n    assign dec_rem = (instr[6:0] == 7'b0000001 && instr[14:12] == 3'b101);\n    assign dec_divu = (instr[6:0] == 7'b0000001 && instr[14:12] == 3'b110);\n    assign dec_remu = (instr[6:0] == 7'b0000001 && instr[14:12] == 3'b111);\n\n    assign dec_rv32 = (E203_INSTR_SIZE == 32);\n\n    assign dec_bjp = (instr[6:0] == 7'b1100011);\n    assign dec_jal = (instr[6:0] == 7'b1101111);\n    assign dec_jalr = (instr[6:0] == 7'b1100111);\n    assign dec_bxx = (instr[6:0] == 7'b1100011 && instr[14:12] != 3'b000);\n\n    assign dec_jalr_rs1idx = instr[19:15];\n\n    assign dec_bjp_imm = {{(E203_XLEN-12){1'b0}}, instr[31:20], instr[19:15], instr[11:8], 1'b0};\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 3, "code": "```ilog\nmodule e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n    // ... rest of the code ...\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 6, "code": "// Import necessary configuration files\n`include \"e203_defines.v\"\n\nmodule e203_clk_ctrl (\n    input  logic            clk,         // System clock\n    input  logic            rst_n,       // Asynchronous reset (active low)\n    input  logic            test_mode,   // Test mode signal\n    input  logic            core_cgstop, // Clock-gated stop signal from CSR register\n    input  logic            core_ifu_active, // Instruction Fetch Unit active status\n    input  logic            core_exu_active, // Execution unit active state\n    input  logic            core_lsu_active, // Load storage cell active state\n    input  logic            core_biu_active, // Bus interface unit active state\n    input  logic            core_wfi,    // Wait for interrupt status signal\n    output logic            clk_aon,     // Normally on clock\n    output logic            clk_core_ifu, // IFU module clock\n    output logic            clk_core_exu, // EXU module clock\n    output logic            clk_core_lsu, // LSU module clock\n    output logic            clk_core_biu, // BIU module clock\n    `ifdef E203_HAS_ITCM\n    input  logic            itcm_active, // ITCM active status\n    output logic            itcm_ls,     // ITCM clock low power state\n    output logic            clk_itcm,    // ITCM module clock\n    `endif\n    `ifdef E203_HAS_DTCM\n    input  logic            dtcm_active, // DTCM active status\n    output logic            dtcm_ls,     // DTCM clock low power state\n    output logic            clk_dtcm     // DTCM module clock\n    `endif\n);\n\n// Clock enable control logic\nlogic ifu_clk_en;\nlogic exu_clk_en;\nlogic lsu_clk_en;\nlogic biu_clk_en;\n\n// Clock gating logic for each core module\nassign ifu_clk_en = core_cgstop || (core_ifu_active && !core_wfi);\nassign exu_clk_en = core_cgstop || core_exu_active;\nassign lsu_clk_en = core_cgstop || core_lsu_active;\nassign biu_clk_en = core_cgstop || core_biu_active;\n\n// Clock output signals\nassign clk_aon = clk;\nassign clk_core_ifu = ifu_clk_en ? clk : 1'b0;\nassign clk_core_exu = exu_clk_en ? clk : 1'b0;\nassign clk_core_lsu = lsu_clk_en ? clk : 1'b0;\nassign clk_core_biu = biu_clk_en ? clk : 1'b0;\n\n// ITCM clock control (optional)\n`ifdef E203_HAS_ITCM\nlogic itcm_clk_en;\nassign itcm_clk_en = core_cgstop || itcm_active;\nassign itcm_ls = ~itcm_clk_en; // Low power state when clock is gated\nassign clk_itcm = itcm_clk_en ? clk : 1'b0;\n`endif\n\n// DTCM clock control (optional)\n`ifdef E203_HAS_DTCM\nlogic dtcm_clk_en;\nassign dtcm_clk_en = core_cgstop || dtcm_active;\nassign dtcm_ls = ~dtcm_clk_en; // Low power state when clock is gated\nassign clk_dtcm = dtcm_clk_en ? clk : 1'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 4, "code": "module e203_exu_excp(\n    // Outputs\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output excp_active,\n\n    // Inputs\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    input clk,\n    input rst_n\n);\n    // ...\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 4, "code": "// Import necessary files\n`include \"e203_defines.v\"\n\nmodule e203_exu_wbck(\n    input  logic                   alu_wbck_i_valid,\n    output logic                   alu_wbck_i_ready,\n    input  logic [E203_XLEN-1:0]   alu_wbck_i_wdat,\n    input  logic [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input  logic                   longp_wbck_i_valid,\n    output logic                   longp_wbck_i_ready,\n    input  logic [E203_FLEN-1:0]   longp_wbck_i_wdat,\n    input  logic [4:0]             longp_wbck_i_flags,\n    input  logic [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input  logic                   longp_wbck_i_rdfpu,\n    output logic                   rf_wbck_o_ena,\n    output logic [E203_XLEN-1:0]   rf_wbck_o_wdat,\n    output logic [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n\n// Internal signals\nlogic [E203_XLEN-1:0] wbck_i_wdat;\nlogic [E203_RFIDX_WIDTH-1:0] wbck_i_rdidx;\nlogic [4:0] wbck_i_flags;\nlogic wbck_i_rdfpu;\n\n// Arbitration logic\nalways_comb begin\n    if (longp_wbck_i_valid) begin\n        // Long-pipeline write-back has higher priority\n        alu_wbck_i_ready = 1'b0;\n        longp_wbck_i_ready = 1'b1;\n        wbck_i_wdat = longp_wbck_i_wdat;\n        wbck_i_rdidx = longp_wbck_i_rdidx;\n        wbck_i_flags = longp_wbck_i_flags;\n        wbck_i_rdfpu = longp_wbck_i_rdfpu;\n    end else begin\n        // ALU write-back has lower priority\n        alu_wbck_i_ready = 1'b1;\n        longp_wbck_i_ready = 1'b0;\n        wbck_i_wdat = alu_wbck_i_wdat;\n        wbck_i_rdidx = alu_wbck_i_rdidx;\n        wbck_i_flags = 5'b0; // ALU does not involve instruction flags\n        wbck_i_rdfpu = 1'b0; // ALU does not involve rdfpu\n    end\nend\n\n// Write-back to register file\nalways_comb begin\n    if (wbck_i_rdfpu) begin\n        // Write-back to FPU register, disable integer register file write\n        rf_wbck_o_ena = 1'b0;\n    end else begin\n        // Write-back to integer register file\n        rf_wbck_o_ena = 1'b1;\n    end\n    rf_wbck_o_wdat = wbck_i_wdat;\n    rf_wbck_o_rdidx = wbck_i_rdidx;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 5, "code": "```ilog\nmodule e203_exu_wbck(\n    input  logic                    alu_wbck_i_valid,\n    output logic                    alu_wbck_i_ready,\n    input  logic [E203_XLEN-1:0]    alu_wbck_i_wdat,\n    input  logic [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx,\n    input  logic                    longp_wbck_i_valid,\n    output logic                    longp_wbck_i_ready,\n    input  logic [E203_FLEN-1:0]    longp_wbck_i_wdat,\n    input  logic [4:0]              longp_wbck_i_flags,\n    input  logic [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx,\n    input  logic                    longp_wbck_i_rdfpu,\n    output logic                    rf_wbck_o_ena,\n    output logic [E203_XLEN-1:0]    rf_wbck_o_wdat,\n    output logic [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx,\n    input  logic                    clk,\n    input  logic                    rst_n\n);\n\nlogic [E203_XLEN-1:0] wbck_i_wdat;\nlogic [E203_RFIDX_WIDTH-1:0] wbck_i_rdidx;\nlogic [4:0] wbck_i_flags;\nlogic wbck_i_rdfpu;\n\nalways_comb begin\n    if (longp_wbck_i_valid) begin\n        wbck_i_wdat = longp_wbck_i_wdat;\n        wbck_i_rdidx = longp_wbck_i_rdidx;\n        wbck_i_flags = longp_wbck_i_flags;\n        wbck_i_rdfpu = longp_wbck_i_rdfpu;\n    end else if (alu_wbck_i_valid) begin\n        wbck_i_wdat = alu_wbck_i_wdat;\n        wbck_i_rdidx = alu_wbck_i_rdidx;\n        wbck_i_flags = 5'd0;\n        wbck_i_rdfpu = 1'd0;\n    end else begin\n        wbck_i_wdat = '0;\n        wbck_i_rdidx = '0;\n        wbck_i_flags = '0;\n        wbck_i_rdfpu = '0;\n    end\nend\n\nalways_comb begin\n    if (longp_wbck_i_valid) begin\n        longp_wbck_i_ready = 1'b1;\n        alu_wbck_i_ready = 1'b0;\n    end else begin\n        longp_wbck_i_ready = 1'b0;\n        alu_wbck_i_ready = alu_wbck_i_valid;\n    end\nend\n\nalways_comb begin\n    if (wbck_i_rdfpu) begin\n        rf_wbck_o_ena = 1'b0;\n    end else begin\n        rf_wbck_o_ena = (longp_wbck_i_valid || alu_wbck_i_valid);\n    end\nend\n\nalways_comb begin\n    rf_wbck_o_wdat = wbck_i_wdat;\n    rf_wbck_o_rdidx = wbck_i_rdidx;\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 5, "code": "module e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input wfi_halt_ifu_ack,\n    input wfi_halt_exu_ack,\n    input amo_wait,\n    input alu_excp_i_valid,\n    input alu_excp_i_ld,\n    input alu_excp_i_stamo,\n    input alu_excp_i_misalgn,\n    input alu_excp_i_buserr,\n    input alu_excp_i_ecall,\n    input alu_excp_i_ebreak,\n    input alu_excp_i_wfi,\n    input alu_excp_i_ifu_misalgn,\n    input alu_excp_i_ifu_buserr,\n    input alu_excp_i_ifu_ilegl,\n    input [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input alu_excp_i_pc_vld,\n    input longp_excp_i_valid,\n    input longp_excp_i_ld,\n    input longp_excp_i_st,\n    input longp_excp_i_buserr,\n    input longp_excp_i_insterr,\n    input [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input [E203_XLEN-1:0] csr_mtvec_r,\n    input cmt_dret_ena,\n    input cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input dbg_irq_r,\n    input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input ext_irq_r,\n    input sft_irq_r,\n    input tmr_irq_r,\n    input status_mie_r,\n    input mtie_r,\n    input msie_r,\n    input meie_r,\n    input dbg_mode,\n    input dbg_halt_r,\n    input dbg_step_r,\n    input dbg_ebreakm_r,\n    input oitf_empty,\n    input u_mode,\n    input s_mode,\n    input h_mode,\n    input m_mode,\n    output excp_active,\n    input clk,\n    input rst_n\n);\n// ...\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 2, "code": "module e203_cpu_top(\n    // Outputs\n    output inspect_pc,\n    output inspect_dbg_irq,\n    output inspect_mem_cmd_valid,\n    output inspect_mem_cmd_ready,\n    output inspect_mem_rsp_valid,\n    output inspect_mem_rsp_ready,\n    output inspect_core_clk,\n    output core_csr_clk,\n    output core_wfi,\n    output tm_stop,\n    output dbg_irq_r,\n\n    // Inputs\n    input pc_rtvec,\n    input ext_irq_a,\n    input sft_irq_a,\n    input tmr_irq_a,\n    input tcm_sd,\n    input tcm_ds,\n    input ext2itcm_icb_cmd_valid,\n    input ext2itcm_icb_cmd_ready,\n    input ext2itcm_icb_cmd_addr,\n    input ext2itcm_icb_cmd_read,\n    input ext2itcm_icb_cmd_wdata,\n    input ext2itcm_icb_cmd_wmask,\n    input ext2itcm_icb_rsp_valid,\n    input ext2itcm_icb_rsp_ready,\n    input ext2itcm_icb_rsp_err,\n    input ext2itcm_icb_rsp_rdata,\n    input clk,\n    input rst_n\n);\n\n// Instantiation of e203_cpu module\ne203_cpu e203_cpu_inst(\n    .inspect_pc(inspect_pc),\n    .inspect_dbg_irq(inspect_dbg_irq),\n    .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n    .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n    .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n    .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n    .inspect_core_clk(inspect_core_clk),\n    .core_csr_clk(core_csr_clk),\n    .core_wfi(core_wfi),\n    .tm_stop(tm_stop),\n    .dbg_irq_r(dbg_irq_r),\n\n    .pc_rtvec(pc_rtvec),\n    .ext_irq_a(ext_irq_a),\n    .sft_irq_a(sft_irq_a),\n    .tmr_irq_a(tmr_irq_a),\n    .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n    .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n    .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n    .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n    .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n    .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n    .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n    .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n    .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n    .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Instantiation of e203_srams module\ne203_srams e203_srams_inst(\n    .itcm_ram_sd(tcm_sd),\n    .itcm_ram_ds(tcm_ds),\n    .itcm_ram_ls(),\n    .itcm_ram_cs(),\n    .itcm_ram_we(),\n    .itcm_ram_addr(),\n    .itcm_ram_wem(),\n    .itcm_ram_din(),\n    .itcm_ram_dout(),\n    .clk_itcm_ram(clk),\n    .rst_itcm(rst_n),\n\n    .dtcm_ram_sd(tcm_sd),\n    .dtcm_ram_ds(tcm_ds),\n    .dtcm_ram_ls(),\n    .dtcm_ram_cs(),\n    .dtcm_ram_we(),\n    .dtcm_ram_addr(),\n    .dtcm_ram_wem(),\n    .dtcm_ram_din(),\n    .dtcm_ram_dout(),\n    .clk_dtcm_ram(clk),\n    .rst_dtcm(rst_n),\n\n    .test_mode()\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 1, "code": "module e203_exu_disp(\n    input  logic                    wfi_halt_exu_req,\n    output logic                    wfi_halt_exu_ack,\n    input  logic                    oitf_empty,\n    input  logic                    amo_wait,\n    input  logic                    disp_i_valid,\n    output logic                    disp_i_ready,\n    input  logic                    disp_i_rs1x0,\n    input  logic                    disp_i_rs2x0,\n    input  logic                    disp_i_rs1en,\n    input  logic                    disp_i_rs2en,\n    input  logic [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input  logic [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input  logic [E203_XLEN-1:0]     disp_i_rs1,\n    input  logic [E203_XLEN-1:0]     disp_i_rs2,\n    input  logic                    disp_i_rdwen,\n    input  logic [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input  logic [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input  logic [E203_XLEN-1:0]     disp_i_imm,\n    input  logic [E203_PC_SIZE-1:0]  disp_i_pc,\n    input  logic                    disp_i_misalgn,\n    input  logic                    disp_i_buserr,\n    input  logic                    disp_i_ilegl,\n    output logic                    disp_o_alu_valid,\n    input  logic                    disp_o_alu_ready,\n    input  logic                    disp_o_alu_longpipe,\n    output logic [E203_XLEN-1:0]     disp_o_alu_rs1,\n    output logic [E203_XLEN-1:0]     disp_o_alu_rs2,\n    output logic                    disp_o_alu_rdwen,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output logic [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output logic [E203_XLEN-1:0]     disp_o_alu_imm,\n    output logic [E203_PC_SIZE-1:0]  disp_o_alu_pc,\n    output logic [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output logic                    disp_o_alu_misalgn,\n    output logic                    disp_o_alu_buserr,\n    output logic                    disp_o_alu_ilegl,\n    input  logic                    oitfrd_match_disprs1,\n    input  logic                    oitfrd_match_disprs2,\n    input  logic                    oitfrd_match_disprs3,\n    input  logic                    oitfrd_match_disprd,\n    output logic [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output logic                    disp_oitf_ena,\n    input  logic                    disp_oitf_ready,\n    output logic                    disp_oitf_rs1fpu,\n    output logic                    disp_oitf_rs2fpu,\n    output logic                    disp_oitf_rs3fpu,\n    output logic                    disp_oitf_rdfpu,\n    output logic                    disp_oitf_rs1en,\n    output logic                    disp_oitf_rs2en,\n    output logic                    disp_oitf_rs3en,\n    output logic                    disp_oitf_rdwen,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output logic [E203_PC_SIZE-1:0]  disp_oitf_pc,\n    input  logic                    clk,\n    input  logic                    rst_n\n);\n\n// Your implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 2, "code": "// e203_srams module\nmodule e203_srams(\n    input  logic                   itcm_ram_sd,     // ITCM power off enable signal\n    input  logic                   itcm_ram_ds,     // ITCM deep sleep mode enable\n    input  logic                   itcm_ram_ls,     // ITCM light sleep mode enable\n    input  logic                   itcm_ram_cs,     // ITCM chip select signal\n    input  logic                   itcm_ram_we,     // ITCM write enable signal\n    input  logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr, // ITCM address\n    input  logic [E203_ITCM_RAM_MW-1:0] itcm_ram_wem, // ITCM write mask\n    input  logic [E203_ITCM_RAM_DW-1:0] itcm_ram_din, // ITCM write data\n    output logic [E203_ITCM_RAM_DW-1:0] itcm_ram_dout, // ITCM read data\n    input  logic                   clk_itcm_ram,    // ITCM clock signal\n    input  logic                   rst_itcm,        // ITCM reset signal\n\n    input  logic                   dtcm_ram_sd,     // DTCM power off enable signal\n    input  logic                   dtcm_ram_ds,     // DTCM deep sleep mode enable\n    input  logic                   dtcm_ram_ls,     // DTCM light sleep mode enable\n    input  logic                   dtcm_ram_cs,     // DTCM chip select signal\n    input  logic                   dtcm_ram_we,     // DTCM write enable signal\n    input  logic [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr, // DTCM address\n    input  logic [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem, // DTCM write mask\n    input  logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_din, // DTCM write data\n    output logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout  // DTCM read data\n);\n\n// ITCM RAM\nlogic [E203_ITCM_RAM_DW-1:0] itcm_ram [E203_ITCM_RAM_DP-1:0];\n\n// DTCM RAM\nlogic [E203_DTCM_RAM_DW-1:0] dtcm_ram [E203_DTCM_RAM_DP-1:0];\n\n// ITCM RAM control\nalways_ff @(posedge clk_itcm_ram or negedge rst_itcm) begin\n    if (~rst_itcm) begin\n        for (int i = 0; i < E203_ITCM_RAM_DP; i++) begin\n            itcm_ram[i] <= '0;\n        end\n    end else if (itcm_ram_cs && itcm_ram_we) begin\n        itcm_ram[itcm_ram_addr] <= itcm_ram_din;\n    end\nend\n\n// DTCM RAM control\nalways_ff @(posedge clk_itcm_ram or negedge rst_itcm) begin\n    if (~rst_itcm) begin\n        for (int i = 0; i < E203_DTCM_RAM_DP; i++) begin\n            dtcm_ram[i] <= '0;\n        end\n    end else if (dtcm_ram_cs && dtcm_ram_we) begin\n        dtcm_ram[dtcm_ram_addr] <= dtcm_ram_din;\n    end\nend\n\n// ITCM RAM output\nassign itcm_ram_dout = itcm_ram_cs ? itcm_ram[itcm_ram_addr] : '0;\n\n// DTCM RAM output\nassign dtcm_ram_dout = dtcm_ram_cs ? dtcm_ram[dtcm_ram_addr] : '0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 2, "code": "module e203_exu_disp(\n    input  logic                    wfi_halt_exu_req,\n    output logic                    wfi_halt_exu_ack,\n    input  logic                    oitf_empty,\n    input  logic                    amo_wait,\n    input  logic                    disp_i_valid,\n    output logic                    disp_i_ready,\n    input  logic                    disp_i_rs1x0,\n    input  logic                    disp_i_rs2x0,\n    input  logic                    disp_i_rs1en,\n    input  logic                    disp_i_rs2en,\n    input  logic [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input  logic [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input  logic [E203_XLEN-1:0]     disp_i_rs1,\n    input  logic [E203_XLEN-1:0]     disp_i_rs2,\n    input  logic                    disp_i_rdwen,\n    input  logic [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input  logic [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input  logic [E203_XLEN-1:0]     disp_i_imm,\n    input  logic [E203_PC_SIZE-1:0]  disp_i_pc,\n    input  logic                    disp_i_misalgn,\n    input  logic                    disp_i_buserr,\n    input  logic                    disp_i_ilegl,\n    output logic                    disp_o_alu_valid,\n    input  logic                    disp_o_alu_ready,\n    input  logic                    disp_o_alu_longpipe,\n    output logic [E203_XLEN-1:0]     disp_o_alu_rs1,\n    output logic [E203_XLEN-1:0]     disp_o_alu_rs2,\n    output logic                    disp_o_alu_rdwen,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output logic [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output logic [E203_XLEN-1:0]     disp_o_alu_imm,\n    output logic [E203_PC_SIZE-1:0]  disp_o_alu_pc,\n    output logic [E203_ITAG_WIDTH-1:0] disp_o_alu_itag,\n    output logic                    disp_o_alu_misalgn,\n    output logic                    disp_o_alu_buserr,\n    output logic                    disp_o_alu_ilegl,\n    input  logic                    oitfrd_match_disprs1,\n    input  logic                    oitfrd_match_disprs2,\n    input  logic                    oitfrd_match_disprs3,\n    input  logic                    oitfrd_match_disprd,\n    output logic [E203_ITAG_WIDTH-1:0] disp_oitf_ptr,\n    output logic                    disp_oitf_ena,\n    input  logic                    disp_oitf_ready,\n    output logic                    disp_oitf_rs1fpu,\n    output logic                    disp_oitf_rs2fpu,\n    output logic                    disp_oitf_rs3fpu,\n    output logic                    disp_oitf_rdfpu,\n    output logic                    disp_oitf_rs1en,\n    output logic                    disp_oitf_rs2en,\n    output logic                    disp_oitf_rs3en,\n    output logic                    disp_oitf_rdwen,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output logic [E203_PC_SIZE-1:0]  disp_oitf_pc,\n    input  logic                    clk,\n    input  logic                    rst_n\n);\n\n// Your logic here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 3, "code": "```ilog\nmodule e203_cpu_top #(\n    parameter E203_CFG_ADDR_SIZE_IS_32 = 1,\n    parameter E203_CFG_HAS_ITCM = 1,\n    parameter E203_CFG_ITCM_ADDR_WIDTH = 16,\n    parameter E203_CFG_HAS_DTCM = 1,\n    parameter E203_CFG_DTCM_ADDR_WIDTH = 16,\n    parameter E203_CFG_SUPPORT_MCYCLE_MINSTRET = 1,\n    parameter E203_CFG_REGNUM_IS_32 = 1,\n    parameter E203_CFG_HAS_ECC = 0,\n    parameter E203_CFG_HAS_NICE = 0,\n    parameter E203_CFG_SUPPORT_SHARE_MULDIV = 1,\n    parameter E203_CFG_SUPPORT_AMO = 1\n) (\n    input  logic                   clk,\n    input  logic                   rst_n,\n\n    // ITCM Interface\n    output logic                   itcm_ram_cs,\n    output logic                   itcm_ram_we,\n    output logic [E203_CFG_ITCM_ADDR_WIDTH-1:0] itcm_ram_addr,\n    output logic [7:0]             itcm_ram_wem,\n    output logic [63:0]            itcm_ram_din,\n    input  logic [63:0]            itcm_ram_dout,\n\n    // DTCM Interface\n    output logic                   dtcm_ram_cs,\n    output logic                   dtcm_ram_we,\n    output logic [E203_CFG_DTCM_ADDR_WIDTH-1:0] dtcm_ram_addr,\n    output logic [3:0]             dtcm_ram_wem,\n    output logic [31:0]            dtcm_ram_din,\n    input  logic [31:0]            dtcm_ram_dout,\n\n    // External Interrupts\n    input  logic                   ext_irq_a,\n    input  logic                   sft_irq_a,\n    input  logic                   tmr_irq_a,\n\n    // Debug Interface\n    output logic                   dbg_irq_r,\n    input  logic                   dbg_mode,\n    input  logic                   dbg_halt_r,\n    input  logic                   dbg_step_r,\n    input  logic                   dbg_ebreakm_r\n);\n\n    // Instantiation of e203_cpu module\n    e203_cpu #(\n        .E203_CFG_ADDR_SIZE_IS_32(E203_CFG_ADDR_SIZE_IS_32),\n        .E203_CFG_HAS_ITCM(E203_CFG_HAS_ITCM),\n        .E203_CFG_ITCM_ADDR_WIDTH(E203_CFG_ITCM_ADDR_WIDTH),\n        .E203_CFG_HAS_DTCM(E203_CFG_HAS_DTCM),\n        .E203_CFG_DTCM_ADDR_WIDTH(E203_CFG_DTCM_ADDR_WIDTH),\n        .E203_CFG_SUPPORT_MCYCLE_MINSTRET(E203_CFG_SUPPORT_MCYCLE_MINSTRET),\n        .E203_CFG_REGNUM_IS_32(E203_CFG_REGNUM_IS_32),\n        .E203_CFG_HAS_ECC(E203_CFG_HAS_ECC),\n        .E203_CFG_HAS_NICE(E203_CFG_HAS_NICE),\n        .E203_CFG_SUPPORT_SHARE_MULDIV(E203_CFG_SUPPORT_SHARE_MULDIV),\n        .E203_CFG_SUPPORT_AMO(E203_CFG_SUPPORT_AMO)\n    ) e203_cpu_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n\n        // ITCM Interface\n        .itcm_ram_cs(itcm_ram_cs),\n        .itcm_ram_we(itcm_ram_we),\n        .itcm_ram_addr(itcm_ram_addr),\n        .itcm_ram_wem(itcm_ram_wem),\n        .itcm_ram_din(itcm_ram_din),\n        .itcm_ram_dout(itcm_ram_dout),\n\n        // DTCM Interface\n        .dtcm_ram_cs(dtcm_ram_cs),\n        .dtcm_ram_we(dtcm_ram_we),\n        .dtcm_ram_addr(dtcm_ram_addr),\n        .dtcm_ram_wem(dtcm_ram_wem),\n        .dtcm_ram_din(dtcm_ram_din),\n        .dtcm_ram_dout(dtcm_ram_dout),\n\n        // External Interrupts\n        .ext_irq_a(ext_irq_a),\n        .sft_irq_a(sft_irq_a),\n        .tmr_irq_a(tmr_irq_a),\n\n        // Debug Interface\n        .dbg_irq_r(dbg_irq_r),\n        .dbg_mode(dbg_mode),\n        .dbg_halt_r(dbg_halt_r),\n        .dbg_step_r(dbg_step_r),\n        .dbg_ebreakm_r(dbg_ebreakm_r)\n    );\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 7, "code": "`include \"e203_defines.v\"\n\nmodule e203_clk_ctrl (\n    input  logic        clk,            // System clock\n    input  logic        rst_n,          // Asynchronous reset (active low)\n    input  logic        test_mode,      // Test mode signal\n    input  logic        core_cgstop,    // Clock-gated stop signal, from the CSR register\n    input  logic        core_ifu_active,// Instruction Fetch Unit active status\n    input  logic        core_exu_active,// Execution unit active state\n    input  logic        core_lsu_active,// Load storage cell active state\n    input  logic        core_biu_active,// Bus interface unit active statedt\n    input  logic        core_wfi,       // Wait for interrupt status signal\n    input  logic        itcm_active,    // ITCM active status (optional)\n    input  logic        dtcm_active,    // DTCM active status (optional)\n    output logic        clk_aon,        // Normally on clock\n    output logic        clk_core_ifu,   // IFU module clock\n    output logic        clk_core_exu,   // EXU module clock\n    output logic        clk_core_lsu,   // LSU module clock\n    output logic        clk_core_biu,   // BIU module clock\n    output logic        itcm_ls,        // ITCM clock low power state (optional)\n    output logic        dtcm_ls,        // DTCM clock low power state (optional)\n    output logic        clk_itcm,       // ITCM module clock (optional)\n    output logic        clk_dtcm        // DTCM module clock (optional)\n);\n\n// Clock enable control logic\nlogic ifu_clk_en;\nlogic exu_clk_en;\nlogic lsu_clk_en;\nlogic biu_clk_en;\n\n// ITCM and DTCM clock control (optional)\nlogic itcm_clk_en;\nlogic dtcm_clk_en;\n\n// Clock gating logic\nalways_comb begin\n    // IFU clock enablement conditions\n    ifu_clk_en = core_cgstop || (core_ifu_active && !core_wfi);\n\n    // Other core module clock enable conditions\n    exu_clk_en = core_cgstop || core_exu_active;\n    lsu_clk_en = core_cgstop || core_lsu_active;\n    biu_clk_en = core_cgstop || core_biu_active;\n\n    // ITCM clock control (optional)\n    if (`E203_HAS_ITCM) begin\n        itcm_clk_en = core_cgstop || itcm_active;\n    end else begin\n        itcm_clk_en = 1'b0;\n    end\n\n    // DTCM clock control (optional)\n    if (`E203_HAS_DTCM) begin\n        dtcm_clk_en = core_cgstop || dtcm_active;\n    end else begin\n        dtcm_clk_en = 1'b0;\n    end\nend\n\n// Clock generation\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset all clocks\n        clk_aon <= 1'b0;\n        clk_core_ifu <= 1'b0;\n        clk_core_exu <= 1'b0;\n        clk_core_lsu <= 1'b0;\n        clk_core_biu <= 1'b0;\n        itcm_ls <= 1'b1; // Default to low power state\n        dtcm_ls <= 1'b1; // Default to low power state\n        clk_itcm <= 1'b0;\n        clk_dtcm <= 1'b0;\n    end else begin\n        // Generate clocks based on enable signals\n        clk_aon <= 1'b1; // Always on clock\n        clk_core_ifu <= ifu_clk_en;\n        clk_core_exu <= exu_clk_en;\n        clk_core_lsu <= lsu_clk_en;\n        clk_core_biu <= biu_clk_en;\n        itcm_ls <= !itcm_clk_en; // Low power state when clock is disabled\n        dtcm_ls <= !dtcm_clk_en; // Low power state when clock is disabled\n        clk_itcm <= itcm_clk_en;\n        clk_dtcm <= dtcm_clk_en;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 6, "code": "// Import necessary modules and definitions\n`include \"e203_defines.v\"\n\nmodule e203_exu_wbck(\n    // Input ports\n    input  logic                   alu_wbck_i_valid,  // ALU write-back handshake valid signal\n    input  logic [E203_XLEN-1:0]   alu_wbck_i_wdat,   // ALU write-back data\n    input  logic [E203_RFIDX_WIDTH-1:0] alu_wbck_i_rdidx, // ALU write-back destination register index\n    input  logic                   longp_wbck_i_valid, // Long-pipeline write-back handshake valid signal\n    input  logic [E203_FLEN-1:0]   longp_wbck_i_wdat,  // Long-pipeline write-back data\n    input  logic [4:0]             longp_wbck_i_flags, // Long-pipeline write-back flags\n    input  logic [E203_RFIDX_WIDTH-1:0] longp_wbck_i_rdidx, // Long-pipeline write-back destination register index\n    input  logic                   longp_wbck_i_rdfpu, // Long-pipeline write-back destination is FPU register\n    input  logic                   clk,               // Clock signal\n    input  logic                   rst_n,             // Reset signal (active low)\n\n    // Output ports\n    output logic                   alu_wbck_i_ready,  // ALU write-back handshake ready signal\n    output logic                   longp_wbck_i_ready, // Long-pipeline write-back handshake ready signal\n    output logic                   rf_wbck_o_ena,     // Register file write enable signal\n    output logic [E203_XLEN-1:0]   rf_wbck_o_wdat,    // Register file write data\n    output logic [E203_RFIDX_WIDTH-1:0] rf_wbck_o_rdidx  // Register file write destination index\n);\n\n// Internal signals\nlogic [E203_XLEN-1:0] wbck_i_wdat; // Selected write-back data\nlogic [E203_RFIDX_WIDTH-1:0] wbck_i_rdidx; // Selected write-back destination register index\nlogic wbck_i_rdfpu; // Selected write-back destination is FPU register\nlogic wbck_i_valid; // Selected write-back request is valid\n\n// Arbitration logic\nalways_comb begin\n    // Long-pipeline write-back has higher priority\n    if (longp_wbck_i_valid) begin\n        wbck_i_wdat  = longp_wbck_i_wdat;\n        wbck_i_rdidx = longp_wbck_i_rdidx;\n        wbck_i_rdfpu = longp_wbck_i_rdfpu;\n        wbck_i_valid = 1'b1;\n        longp_wbck_i_ready = 1'b1;\n        alu_wbck_i_ready  = 1'b0;\n    end else if (alu_wbck_i_valid) begin\n        // ALU write-back is granted if there's no pending long-pipeline write-back\n        wbck_i_wdat  = alu_wbck_i_wdat;\n        wbck_i_rdidx = alu_wbck_i_rdidx;\n        wbck_i_rdfpu = 1'b0; // ALU does not involve FPU\n        wbck_i_valid = 1'b1;\n        alu_wbck_i_ready  = 1'b1;\n        longp_wbck_i_ready = 1'b0;\n    end else begin\n        // No write-back requests\n        wbck_i_wdat  = '0;\n        wbck_i_rdidx = '0;\n        wbck_i_rdfpu = 1'b0;\n        wbck_i_valid = 1'b0;\n        alu_wbck_i_ready  = 1'b0;\n        longp_wbck_i_ready = 1'b0;\n    end\nend\n\n// Write-back to register file\nalways_comb begin\n    rf_wbck_o_ena = wbck_i_valid && !wbck_i_rdfpu; // Enable write to register file if destination is not FPU\n    rf_wbck_o_wdat = wbck_i_wdat;\n    rf_wbck_o_rdidx = wbck_i_rdidx;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 2, "code": "module e203_ifu_litebpu #(\n    parameter E203_PC_SIZE = 32,\n    parameter E203_XLEN = 32,\n    parameter E203_RFIDX_WIDTH = 5\n) (\n    input                   clk,\n    input                   rst_n,\n    input  [E203_PC_SIZE-1:0] pc,\n    input                   dec_jal,\n    input                   dec_jalr,\n    input                   dec_bxx,\n    input  [E203_XLEN-1:0]  dec_bjp_imm,\n    input  [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    input                   oitf_empty,\n    input                   ir_empty,\n    input                   ir_rs1en,\n    input                   jalr_rs1idx_cam_irrdidx,\n    input                   dec_i_valid,\n    input                   ir_valid_clr,\n    input  [E203_XLEN-1:0]  rf2bpu_x1,\n    input  [E203_XLEN-1:0]  rf2bpu_rs1,\n    output                  prdt_taken,\n    output [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n    output [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n    output                  bpu_wait,\n    output                  bpu2rf_rs1_ena\n);\n\n// Internal signals and variables\nreg [E203_RFIDX_WIDTH-1:0] rs1xn_rdrf_r;\nreg                       rs1xn_rdrf_ena;\nreg                       rs1xn_rdrf_clr;\nreg                       jalr_rs1xn_dep;\nreg                       jalr_rs1xn_dep_ir_clr;\n\n// Static branch prediction strategy\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        rs1xn_rdrf_r <= 1'b0;\n    end else if (rs1xn_rdrf_ena) begin\n        rs1xn_rdrf_r <= 1'b1;\n    end else if (rs1xn_rdrf_clr) begin\n        rs1xn_rdrf_r <= 1'b0;\n    end\nend\n\nalways @(*) begin\n    // Predicted jump flag\n    prdt_taken = dec_jal || dec_jalr || (dec_bxx && (dec_bjp_imm[E203_XLEN-1] == 1'b1));\n    \n    // PC adder operand 1\n    if (dec_jalr && (dec_jalr_rs1idx == 5'b0)) begin\n        prdt_pc_add_op1 = {E203_PC_SIZE{1'b0}};\n    end else if (dec_jalr && (dec_jalr_rs1idx == 5'b1)) begin\n        prdt_pc_add_op1 = rf2bpu_x1;\n    end else if (dec_jalr && (dec_jalr_rs1idx != 5'b0) && (dec_jalr_rs1idx != 5'b1)) begin\n        prdt_pc_add_op1 = rf2bpu_rs1;\n    end else begin\n        prdt_pc_add_op1 = pc;\n    end\n    \n    // PC adder operand 2\n    prdt_pc_add_op2 = dec_bjp_imm[E203_PC_SIZE-1:0];\n    \n    // BPU wait flag\n    bpu_wait = (dec_jalr && (dec_jalr_rs1idx == 5'b1) && (~oitf_empty || jalr_rs1idx_cam_irrdidx)) ||\n               (dec_jalr && (dec_jalr_rs1idx != 5'b0) && (dec_jalr_rs1idx != 5'b1) && (~ir_empty || ~ir_rs1en));\n    \n    // rs1 read enable from BPU to register file\n    bpu2rf_rs1_ena = (dec_jalr && (dec_jalr_rs1idx == 5'b1) && (~oitf_empty || jalr_rs1idx_cam_irrdidx)) ||\n                     (dec_jalr && (dec_jalr_rs1idx != 5'b0) && (dec_jalr_rs1idx != 5'b1) && (~ir_empty || ~ir_rs1en));\nend\n\n// Dependency detection and pause processing\nalways @(*) begin\n    jalr_rs1xn_dep = (~oitf_empty || jalr_rs1idx_cam_irrdidx);\n    jalr_rs1xn_dep_ir_clr = ir_valid_clr;\n    \n    rs1xn_rdrf_ena = (dec_jalr && (dec_jalr_rs1idx != 5'b0) && (dec_jalr_rs1idx != 5'b1) && (~rs1xn_rdrf_r) && (~jalr_rs1xn_dep) && (~jalr_rs1xn_dep_ir_clr));\n    rs1xn_rdrf_clr = (rs1xn_rdrf_r && (dec_i_valid || ir_valid_clr));\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 3, "code": "module e203_srams #(\n    parameter E203_HAS_ITCM = 1,\n    parameter E203_HAS_DTCM = 1,\n    parameter E203_ITCM_ADDR_WIDTH = 10,\n    parameter E203_DTCM_ADDR_WIDTH = 10,\n    parameter E203_ITCM_RAM_DP = 1024,\n    parameter E203_DTCM_RAM_DP = 1024,\n    parameter E203_ITCM_RAM_AW = E203_ITCM_ADDR_WIDTH - 3,\n    parameter E203_DTCM_RAM_AW = E203_DTCM_ADDR_WIDTH - 2,\n    parameter E203_ITCM_RAM_DW = 64,\n    parameter E203_DTCM_RAM_DW = 32,\n    parameter E203_ITCM_RAM_MW = E203_ITCM_RAM_DW / 8,\n    parameter E203_DTCM_RAM_MW = E203_DTCM_RAM_DW / 8\n) (\n    input  logic                   itcm_ram_sd,\n    input  logic                   itcm_ram_ds,\n    input  logic                   itcm_ram_ls,\n    input  logic                   itcm_ram_cs,\n    input  logic                   itcm_ram_we,\n    input  logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    input  logic [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    input  logic [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    output logic [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    input  logic                   clk_itcm_ram,\n    input  logic                   rst_itcm,\n\n    input  logic                   dtcm_ram_sd,\n    input  logic                   dtcm_ram_ds,\n    input  logic                   dtcm_ram_ls,\n    input  logic                   dtcm_ram_cs,\n    input  logic                   dtcm_ram_we,\n    input  logic [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    input  logic [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    input  logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    output logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    input  logic                   clk_dtcm_ram,\n    input  logic                   rst_dtcm\n);\n\n    logic [E203_ITCM_RAM_DW-1:0] itcm_ram [E203_ITCM_RAM_DP-1:0];\n    logic [E203_DTCM_RAM_DW-1:0] dtcm_ram [E203_DTCM_RAM_DP-1:0];\n\n    always_ff @(posedge clk_itcm_ram or negedge rst_itcm) begin\n        if (!rst_itcm) begin\n            for (int i = 0; i < E203_ITCM_RAM_DP; i++) begin\n                itcm_ram[i] <= '0;\n            end\n        end else if (itcm_ram_cs && itcm_ram_we) begin\n            itcm_ram[itcm_ram_addr] <= itcm_ram_din;\n        end\n    end\n\n    always_ff @(posedge clk_dtcm_ram or negedge rst_dtcm) begin\n        if (!rst_dtcm) begin\n            for (int i = 0; i < E203_DTCM_RAM_DP; i++) begin\n                dtcm_ram[i] <= '0;\n            end\n        end else if (dtcm_ram_cs && dtcm_ram_we) begin\n            dtcm_ram[dtcm_ram_addr] <= dtcm_ram_din;\n        end\n    end\n\n    always_comb begin\n        itcm_ram_dout = itcm_ram[itcm_ram_addr];\n        dtcm_ram_dout = dtcm_ram[dtcm_ram_addr];\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 1, "code": "module itcm_controller(\n    input  logic                   clk,\n    input  logic                   rst_n,\n    input  logic                   test_mode,\n    output logic                   itcm_active,\n    input  logic                   tcm_cgstop,\n\n    // IFU Interface\n    input  logic                   ifu2itcm_icb_cmd_valid,\n    output logic                   ifu2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input  logic                   ifu2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output logic                   ifu2itcm_icb_rsp_valid,\n    input  logic                   ifu2itcm_icb_rsp_ready,\n    output logic                   ifu2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input  logic                   lsu2itcm_icb_cmd_valid,\n    output logic                   lsu2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input  logic                   lsu2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output logic                   lsu2itcm_icb_rsp_valid,\n    input  logic                   lsu2itcm_icb_rsp_ready,\n    output logic                   lsu2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // External Interface (optional)\n    input  logic                   ext2itcm_icb_cmd_valid,\n    output logic                   ext2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input  logic                   ext20:itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ext2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_WMSK_WIDTH-1:0] ext2itcm_icb_cmd_wmask,\n    output logic                   ext2itcm_icb_rsp_valid,\n    input  logic                   ext2itcm_icb_rsp_ready,\n    output logic                   ext2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] ext2itcm_icb_rsp_rdata,\n\n    // RAM Interface\n    output logic                   itcm_ram_cs,\n    output logic                   itcm_ram_we,\n    output logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    output logic [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    output logic [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    input  logic [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    output logic                   clk_itcm_ram\n);\n\n// Module implementation...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 1, "code": "```\nmodule e203_ifu (\n    // System Interface\n    input  logic                   clk,\n    input  logic                   rst_n,\n    output logic [E203_PC_SIZE-1:0] inspect_pc,\n    output logic                   ifu_active,\n    input  logic                   itcm_nohold,\n    input  logic [E203_PC_SIZE-1:0] pc_rtvec,\n\n    // IR stage to Execution Unit Interface\n    output logic [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output logic [E203_PC_SIZE-1:0] ifu_o_pc,\n    output logic                   ifu_o_pc_vld,\n    output logic                   ifu_o_misalgn,\n    output logic                   ifu_o_buserr,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output logic                   ifu_o_prdt_taken,\n    output logic                   ifu_o_muldiv_b2b,\n    output logic                   ifu_o_valid,\n    input  logic                   ifu_o_ready,\n\n    // Pipeline Control Interface\n    input  logic                   pipe_flush_req,\n    output logic                   pipe_flush_ack,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_pc,\n\n    // ITCM Interface\n    input  logic                   ifu2itcm_holdup,\n    input  logic [E203_ADDR_SIZE-1:0] itcm_region_indic,\n    output logic                   ifu2itcm_icb_cmd_valid,\n    input  logic                   ifu2itcm_icb_cmd_ready,\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input  logic                   ifu2itcm_icb_rsp_valid,\n    output logic                   ifu2itcm_icb_rsp_ready,\n    input  logic                   ifu2itcm_icb_rsp_err,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // System Memory Interface\n    output logic                   ifu2biu_icb_cmd_valid,\n    input  logic                   ifu2biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input  logic                   ifu2biu_icb_rsp_valid,\n    output logic                   ifu2biu_icb_rsp_ready,\n    input  logic                   ifu2biu_icb_rsp_err,\n    input  logic [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata,\n\n    // Halt Control Interface\n    input  logic                   ifu_halt_req,\n    output logic                   ifu_halt_ack,\n\n    // Other Input Interfaces\n    input  logic                   oitf_empty,\n    input  logic [E203_XLEN-1:0]    rf2ifu_x1,\n    input  logic [E203_XLEN-1:0]    rf2ifu_rs1,\n    input  logic                   dec2ifu_rs1en,\n    input  logic                   dec2ifu_rden,\n    input  logic [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input  logic                   dec2ifu_mulhsu,\n    input  logic                   dec2ifu_div,\n    input  logic                   dec2ifu_rem,\n    input  logic                   dec2ifu_divu,\n    input  logic                   dec2ifu_remu\n);\n\n// Sub-modules\ne203_ifu_ifetch ifu_ifetch_inst (\n    // ...\n);\n\ne203_ifu_ift2icb ift2icb_inst (\n    // ...\n);\n\n// ...\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 2, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_alu_muldiv(\n    input  logic                   mdv_nob2b,      // Indicates no back-to-back operations are allowed\n    input  logic                   muldiv_i_valid, // Handshake valid signal for MUL/DIV input\n    output logic                   muldiv_i_ready, // Handshake ready signal for MUL/DIV input\n    input  logic [E203_XLEN-1:0]   muldiv_i_rs1,   // Operand RS1 for multiplication or division\n    input  logic [E203_XLEN-1:0]   muldiv_i_rs2,   // Operand RS2 for multiplication or division\n    input  logic [E203_XLEN-1:0]   muldiv_i_imm,   // Immediate operand for multiplication or division\n    input  logic [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info, // Information bus for MUL/DIV\n    input  logic [E203_ITAG_WIDTH-1:0]           muldiv_i_itag, // Instruction tag for MUL/DIV operations\n    output logic                   muldiv_i_longpipe, // Indicates that the MUL/DIV operation is a long pipeline operation\n    input  logic                   flush_pulse,    // Flush signal to reset the MUL/DIV pipeline\n    output logic                   muldiv_o_valid,  // Handshake valid signal for MUL/DIV output\n    input  logic                   muldiv_o_ready,  // Handshake ready signal for MUL/DIV output\n    output logic [E203_XLEN-1:0]   muldiv_o_wbck_wdat, // Write-back data resulting from the MUL/DIV operation\n    output logic                   muldiv_o_wbck_err, // Write-back error signal (always 0, as there are no exceptions for MUL/DIV)\n    output logic [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1, // Operand 1 for the shared ALU datapath\n    output logic [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2, // Operand 2 for the shared ALU datapath\n    output logic                   muldiv_req_alu_add, // Indicates add operation for the shared ALU datapath\n    output logic                   muldiv_req_alu_sub, // Indicates subtract operation for the shared ALU datapath\n    input  logic [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res, // Result from the shared ALU datapath\n    output logic                   muldiv_sbf_0_ena,  // Enable signal for shared buffer 0\n    output logic [32:0]            muldiv_sbf_0_nxt,  // Next value to write to shared buffer 0\n    input  logic [32:0]            muldiv_sbf_0_r,    // Current value of shared buffer 0\n    output logic                   muldiv_sbf_1_ena,  // Enable signal for shared buffer 1\n    output logic [32:0]            muldiv_sbf_1_nxt,  // Next value to write to shared buffer 1\n    input  logic [32:0]            muldiv_sbf_1_r,    // Current value of shared buffer 1\n    input  logic                   clk,               // Clock signal for synchronous operation\n    input  logic                   rst_n               // Active-low reset signal for initializing the module\n);\n\n// Your implementation goes here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 8, "code": "```(\n    input  logic        clk,            // System clock\n    input  logic        rst_n,          // Asynchronous reset (active low)\n    input  logic        test_mode,      // Test mode signal\n    input  logic        core_cgstop,    // Clock-gated stop signal, from the CSR register\n    input  logic        core_ifu_active,// Instruction Fetch Unit active status\n    input  logic        core_exu_active,// Execution unit active state\n    input  logic        core_lsu_active,// Load storage cell active state\n    input  logic        core_biu_active,// Bus interface unit active statedt\n    input  logic        core_wfi,       // Wait for interrupt status signal\n    input  logic        itcm_active,    // ITCM active status (optional)\n    input  logic        dtcm_active,    // DTCM active status (optional)\n    output logic        clk_aon,        // Normally on clock\n    output logic        clk_core_ifu,   // IFU module clock\n    output logic        clk_core_exu,   // EXU module clock\n    output logic        clk_core_lsu,   // LSU module clock\n    output logic        clk_core_biu,   // BIU module clock\n    output logic        itcm_ls,        // ITCM clock low power state (optional)\n    output logic        dtcm_ls,        // DTCM clock low power state (optional)\n    output logic        clk_itcm,       // ITCM module clock (optional)\n    output logic        clk_dtcm        // DTCM module clock (optional)\n);\n\n// Define parameters for ITCM and DTCM\nparameter E203_HAS_ITCM = 1'b1;  // Enable ITCM\nparameter E203_HAS_DTCM = 1'b1;  // Enable DTCM\n\n// Clock enable control logic\nlogic ifu_clk_en;\nlogic exu_clk_en;\nlogic lsu_clk_en;\nlogic biu_clk_en;\n\nassign ifu_clk_en = core_cgstop || (core_ifu_active && !core_wfi);\nassign exu_clk_en = core_cgstop || core_exu_active;\nassign lsu_clk_en = core_cgstop || core_lsu_active;\nassign biu_clk_en = core_cgstop || core_biu_active;\n\n// Clock gating\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_core_ifu <= 1'b0;\n        clk_core_exu <= 1'b0;\n        clk_core_lsu <= 1'b0;\n        clk_core_biu <= 1'b0;\n    end else begin\n        clk_core_ifu <= ifu_clk_en;\n        clk_core_exu <= exu_clk_en;\n        clk_core_lsu <= lsu_clk_en;\n        clk_core_biu <= biu_clk_en;\n    end\nend\n\n// ITCM clock control (optional)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        itcm_ls <= 1'b1;  // Default to low power state\n        clk_itcm <= 1'b0;\n    end else if (E203_HAS_ITCM) begin\n        itcm_ls <= !(core_cgstop || itcm_active);\n        clk_itcm <= core_cgstop || itcm_active;\n    end\nend\n\n// DTCM clock control (optional)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        dtcm_ls <= 1'b1;  // Default to low power state\n        clk_dtcm <= 1'b0;\n    end else if (E203_HAS_DTCM) begin\n        dtcm_ls <= !(core_cgstop || dtcm_active);\n        clk_dtcm <= core_cgstop || dtcm_active;\n    end\nend\n\n// Normally on clock\nassign clk_aon = clk;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 4, "code": "module e203_cpu_top(\n    // Outputs\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n    \n    // Inputs\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire ext2itcm_icb_cmd_valid,\n    input wire ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire ext2itcm_icb_cmd_wdata,\n    input wire ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_rsp_ready,\n    input wire ext2dtcm_icb_cmd_valid,\n    input wire ext2dtcm_icb_cmd_addr,\n    input wire ext2dtcm_icb_cmd_read,\n    input wire ext2dtcm_icb_cmd_wdata,\n    input wire ext2dtcm_icb_cmd_wmask,\n    input wire ext2dtcm_icb_rsp_ready,\n    input wire clk,\n    input wire rst_n\n);\n\n// Instantiation of e203_cpu and e203_srams modules\ne203_cpu e203_cpu_inst(\n    .inspect_pc(inspect_pc),\n    .inspect_dbg_irq(inspect_dbg_irq),\n    .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n    .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n    .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n    .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n    .inspect_core_clk(inspect_core_clk),\n    .core_csr_clk(core_csr_clk),\n    .core_wfi(core_wfi),\n    .tm_stop(tm_stop),\n    .dbg_irq_r(dbg_irq_r),\n    .pc_rtvec(pc_rtvec),\n    .ext_irq_a(ext_irq_a),\n    .sft_irq_a(sft_irq_a),\n    .tmr_irq_a(tmr_irq_a),\n    .tcm_sd(tcm_sd),\n    .tcm_ds(tcm_ds),\n    .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n    .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n    .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n    .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n    .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n    .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n    .ext2dtcm_icb_cmd_valid(ext2dtcm_icb_cmd_valid),\n    .ext2dtcm_icb_cmd_addr(ext2dtcm_icb_cmd_addr),\n    .ext2dtcm_icb_cmd_read(ext2dtcm_icb_cmd_read),\n    .ext2dtcm_icb_cmd_wdata(ext2dtcm_icb_cmd_wdata),\n    .ext2dtcm_icb_cmd_wmask(ext2dtcm_icb_cmd_wmask),\n    .ext2dtcm_icb_rsp_ready(ext2dtcm_icb_rsp_ready),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\ne203_srams e203_srams_inst(\n    .itcm_ram_sd(tcm_sd),\n    .itcm_ram_ds(tcm_ds),\n    .itcm_ram_ls(),\n    .itcm_ram_cs(),\n    .itcm_ram_we(),\n    .itcm_ram_addr(),\n    .itcm_ram_wem(),\n    .itcm_ram_din(),\n    .itcm_ram_dout(),\n    .clk_itcm_ram(clk),\n    .rst_itcm(rst_n),\n    .dtcm_ram_sd(tcm_sd),\n    .dtcm_ram_ds(tcm_ds),\n    .dtcm_ram_ls(),\n    .dtcm_ram_cs(),\n    .dtcm_ram_we(),\n    .dtcm_ram_addr(),\n    .dtcm_ram_wem(),\n    .dtcm_ram_din(),\n    .dtcm_ram_dout(),\n    .clk_dtcm_ram(clk),\n    .rst_dtcm(rst_n),\n    .test_mode()\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 2, "code": "module e203_exu_alu_csrctrl(\n    input   logic                           csr_i_valid,\n    output  logic                           csr_i_ready,\n    input   logic [E203_XLEN-1:0]           csr_i_rs1,\n    input   logic [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input   logic                           csr_i_rdwen,\n    output  logic                           csr_ena,\n    output  logic                           csr_wr_en,\n    output  logic                           csr_rd_en,\n    output  logic [11:0]                    csr_idx,\n    input   logic                           csr_access_ilgl,\n    input   logic [E203_XLEN-1:0]           read_csr_dat,\n    output  logic [E203_XLEN-1:0]           wbck_csr_dat,\n    output  logic                           csr_o_valid,\n    input   logic                           csr_o_ready,\n    output  logic [E203_XLEN-1:0]           csr_o_wbck_wdat,\n    output  logic                           csr_o_wbck_err,\n    input   logic                           clk,\n    input   logic                           rst_n,\n    // NICE interface\n    input   logic                           nice_xs_off,\n    output  logic                           csr_sel_nice,\n    output  logic                           nice_csr_valid,\n    input   logic                           nice_csr_ready,\n    output  logic [31:0]                    nice_csr_addr,\n    output  logic                           nice_csr_wr,\n    output  logic [31:0]                    nice_csr_wdata,\n    input   logic [31:0]                    nice_csr_rdata\n);\n\n// Internal signals\nlogic csr_op1;\nlogic [E203_XLEN-1:0] csr_op1_ext;\n\n// Control signal preparation logic\nassign csr_i_ready = csr_o_ready;\n\n// Prepare the correct source operand based on instruction information\nalways_comb begin\n    if (csr_i_info[E203_DECINFO_CSR_RS1IMM]) begin\n        // Extend the immediate value as an unsigned number\n        csr_op1_ext = {{(E203_XLEN-5){1'b0}}, csr_i_info[E203_DECINFO_CSR_ZIMMM]};\n    end else begin\n        // Use the value from csr_i_rs1 as operand 1\n        csr_op1_ext = csr_i_rs1;\n    end\nend\n\nassign csr_op1 = csr_op1_ext;\n\n// Generate indicator signals based on instruction information\nassign csr_rd_en = (csr_i_info[E203_DECINFO_CSR_CSRRW] && csr_i_rdwen) ||\n                   csr_i_info[E203_DECINFO_CSR_CSRRS] ||\n                   csr_i_info[E203_DECINFO_CSR_CSRRC];\n\nassign csr_wr_en = csr_i_info[E203_DECINFO_CSR_CSRRW] ||\n                   (csr_i_info[E203_DECINFO_CSR_CSRRS] || csr_i_info[E203_DECINFO_CSR_CSRRC]) &&\n                   !csr_i_info[E203_DECINFO_CSR_RS1IS0];\n\nassign csr_idx = csr_i_info[E203_DECINFO_CSR_CSRIDX];\n\nassign csr_ena = csr_i_valid && csr_o_ready;\n\n// Prepare data for CSR write operations\nalways_comb begin\n    if (csr_i_info[E203_DECINFO_CSR_CSRRW]) begin\n        // For CSRRW, the data written to the CSR is directly the operand 1\n        wbck_csr_dat = csr_op1;\n    end else if (csr_i_info[E203_DECINFO_CSR_CSRRS]) begin\n        // For CSRRS, the data written to the CSR is a bitwise OR between the operand 1 and the current CSR value\n        wbck_csr_dat = read_csr_dat | csr_op1;\n    end else if (csr_i_info[E203_DECINFO_CSR_CSRRC]) begin\n        // For CSRRC, the data written to the CSR is a bitwise AND between the negated operand 1 and the current CSR value\n        wbck_csr_dat = read_csr_dat & ~csr_op1;\n    end\nend\n\n// Error handling\nassign csr_o_wbck_err = csr_access_ilgl;\n\nassign csr_o_wbck_wdat = read_csr_dat;\n\n// NICE interface\nassign csr_sel_nice = (csr_idx[11:8] == 4'hE) && !nice_xs_off;\n\nassign nice_csr_valid = csr_i_valid && csr_o_ready;\n\nassign nice_csr_addr = {22'b0, csr_idx};\n\nassign nice_csr_wr = csr_wr_en;\n\nassign nice_csr_wdata = wbck_csr_dat;\n\n// Output valid signal\nassign csr_o_valid = csr_i_valid && nice_csr_ready;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 1, "code": "module e203_exu_alu_rglr(\n    input  logic                    alu_i_valid,\n    output logic                    alu_i_ready,\n    input  logic [E203_XLEN-1:0]    alu_i_rs1,\n    input  logic [E203_XLEN-1:0]    alu_i_rs2,\n    input  logic [E203_XLEN-1:0]    alu_i_imm,\n    input  logic [E203_PC_SIZE-1:0] alu_i_pc,\n    input  logic [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output logic                    alu_o_valid,\n    input  logic                    alu_o_ready,\n    output logic [E203_XLEN-1:0]    alu_o_wbck_wdat,\n    output logic                    alu_o_wbck_err,\n    output logic                    alu_o_cmt_ecall,\n    output logic                    alu_o_cmt_ebreak,\n    output logic                    alu_o_cmt_wfi,\n    output logic                    alu_req_alu_add,\n    output logic                    alu_req_alu_sub,\n    output logic                    alu_req_alu_xor,\n    output logic                    alu_req_alu_sll,\n    output logic                    alu_req_alu_srl,\n    output logic                    alu_req_alu_sra,\n    output logic                    alu_req_alu_or,\n    output logic                    alu_req_alu_and,\n    output logic                    alu_req_alu_slt,\n    output logic                    alu_req_alu_sltu,\n    output logic                    alu_req_alu_lui,\n    output logic [E203_XLEN-1:0]    alu_req_alu_op1,\n    output logic [E203_XLEN-1:0]    alu_req_alu_op2,\n    output logic [E203_XLEN-1:0]    alu_req_alu_res,\n    input  logic                    clk,\n    input  logic                    rst_n\n);\n\n    // valid-ready handshake\n    assign alu_i_ready = alu_o_ready;\n    assign alu_o_valid = alu_i_valid;\n\n    // operation type generation\n    assign alu_req_alu_add  = alu_i_info[E203_DECINFO_ALU_ADD];\n    assign alu_req_alu_sub  = alu_i_info[E203_DECINFO_ALU_SUB];\n    assign alu_req_alu_xor  = alu_i_info[E203_DECINFO_ALU_XOR];\n    assign alu_req_alu_sll  = alu_i_info[E203_DECINFO_ALU_SLL];\n    assign alu_req_alu_srl  = alu_i_info[E203_DECINFO_ALU_SRL];\n    assign alu_req_alu_sra  = alu_i_info[E203_DECINFO_ALU_SRA];\n    assign alu_req_alu_or   = alu_i_info[E203_DECINFO_ALU_OR];\n    assign alu_req_alu_and  = alu_i_info[E203_DECINFO_ALU_AND];\n    assign alu_req_alu_slt  = alu_i_info[E203_DECINFO_ALU_SLT];\n    assign alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n    assign alu_req_alu_lui  = alu_i_info[E203_DECINFO_ALU_LUI];\n\n    // operand selection\n    assign alu_req_alu_op1 = (alu_i_info[E203_DECINFO_ALU_OP1PC]) ? alu_i_pc : alu_i_rs1;\n    assign alu_req_alu_op2 = (alu_i_info[E203_DECINFO_ALU_OP2IMM]) ? alu_i_imm : alu_i_rs2;\n\n    // result\n    assign alu_o_wbck_wdat = alu_req_alu_res;\n\n    // special instructions\n    assign alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n    assign alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n    assign alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n\n    // error handling\n    assign alu_o_wbck_err = (alu_i_info[E203_DECINFO_ALU_ECAL] || alu_i_info[E203_DECINFO_ALU_EBRK] || alu_i_info[E203_DECINFO_ALU_WFI]);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_oitf (\n    output dis_ready,\n    input dis_ena,\n    input ret_ena,\n    output [E203_ITAG_WIDTH-1:0] dis_ptr,\n    output [E203_ITAG_WIDTH-1:0] ret_ptr,\n    output [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n    output ret_rdwen,\n    output ret_rdfpu,\n    output [E203_PC_SIZE-1:0] ret_pc,\n    input disp_i_rs1en,\n    input disp_i_rs2en,\n    input disp_i_rs3en,\n    input disp_i_rdwen,\n    input disp_i_rs1fpu,\n    input disp_i_rs2fpu,\n    input disp_i_rs3fpu,\n    input disp_i_rdfpu,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input [E203_PC_SIZE-1:0] disp_i_pc,\n    output oitfrd_match_disprs1,\n    output oitfrd_match_disprs2,\n    output oitfrd_match_disprs3,\n    output oitfrd_match_disprd,\n    output oitf_empty,\n    input clk,\n    input rst_n\n);\n\nreg [E203_ITAG_WIDTH-1:0] dis_ptr_reg;\nreg [E203_ITAG_WIDTH-1:0] ret_ptr_reg;\nreg [E203_RFIDX_WIDTH-1:0] ret_rdidx_reg;\nreg ret_rdwen_reg;\nreg ret_rdfpu_reg;\nreg [E203_PC_SIZE-1:0] ret_pc_reg;\nreg [E203_OITF_DEPTH-1:0] oitf_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        dis_ptr_reg <= '0;\n        ret_ptr_reg <= '0;\n        ret_rdidx_reg <= '0;\n        ret_rdwen_reg <= '0;\n        ret_rdfpu_reg <= '0;\n        ret_pc_reg <= '0;\n        oitf_reg <= '0;\n    end else begin\n        if (dis_ena) begin\n            oitf_reg[dis_ptr_reg] <= 1'b1;\n            dis_ptr_reg <= dis_ptr_reg + 1'b1;\n            if (dis_ptr_reg == E203_OITF_DEPTH - 1) begin\n                dis_ptr_reg <= '0;\n            end\n        end\n        if (ret_ena) begin\n            oitf_reg[ret_ptr_reg] <= 1'b0;\n            ret_ptr_reg <= ret_ptr_reg + 1'b1;\n            if (ret_ptr_reg == E203_OITF_DEPTH - 1) begin\n                ret_ptr_reg <= '0;\n            end\n        end\n    end\nend\n\nassign dis_ready = (dis_ptr_reg != ret_ptr_reg) || (~oitf_reg[dis_ptr_reg]);\nassign ret_rdidx = ret_rdidx_reg;\nassign ret_rdwen = ret_rdwen_reg;\nassign ret_rdfpu = ret_rdfpu_reg;\nassign ret_pc = ret_pc_reg;\n\nalways @(*) begin\n    ret_rdidx_reg = '0;\n    ret_rdwen_reg = '0;\n    ret_rdfpu_reg = '0;\n    ret_pc_reg = '0;\n    for (int i = 0; i < E203_OITF_DEPTH; i++) begin\n        if (oitf_reg[i]) begin\n            ret_rdidx_reg = disp_i_rdidx;\n            ret_rdwen_reg = disp_i_rdwen;\n            ret_rdfpu_reg = disp_i_rdfpu;\n            ret_pc_reg = disp_i_pc;\n        end\n    end\nend\n\nassign oitfrd_match_disprs1 = (oitf_reg[disp_i_rs1idx] && disp_i_rs1en);\nassign oitfrd_match_disprs2 = (oitf_reg[disp_i_rs2idx] && disp_i_rs2en);\nassign oitfrd_match_disprs3 = (oitf_reg[disp_i_rs3idx] && disp_i_rs3en);\nassign oitfrd_match_disprd = (oitf_reg[disp_i_rdidx] && disp_i_rdwen);\n\nassign oitf_empty = (~|oitf_reg);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 4, "code": "module e203_srams #(\n    parameter E203_HAS_ITCM = 1,\n    parameter E203_HAS_DTCM = 1,\n    parameter E203_ITCM_ADDR_WIDTH = 10,\n    parameter E203_DTCM_ADDR_WIDTH = 10,\n    parameter E203_ITCM_RAM_DP = 1024,\n    parameter E203_DTCM_RAM_DP = 1024,\n    parameter E203_ITCM_RAM_AW = E203_ITCM_ADDR_WIDTH - 3,\n    parameter E203_DTCM_RAM_AW = E203_DTCM_ADDR_WIDTH - 2,\n    parameter E203_ITCM_RAM_DW = 64,\n    parameter E203_DTCM_RAM_DW = 32,\n    parameter E203_ITCM_RAM_MW = E203_ITCM_RAM_DW / 8,\n    parameter E203_DTCM_RAM_MW = E203_DTCM_RAM_DW / 8\n) (\n    input  logic                   itcm_ram_sd,\n    input  logic                   itcm_ram_ds,\n    input  logic                   itcm_ram_ls,\n    input  logic                   itcm_ram_cs,\n    input  logic                   itcm_ram_we,\n    input  logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    input  logic [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    input  logic [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    output logic [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    input  logic                   clk_itcm_ram,\n    input  logic                   rst_itcm,\n\n    input  logic                   dtcm_ram_sd,\n    input  logic                   dtcm_ram_ds,\n    input  logic                   dtcm_ram_ls,\n    input  logic                   dtcm_ram_cs,\n    input  logic                   dtcm_ram_we,\n    input  logic [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    input  logic [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    input  logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    output logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    input  logic                   clk_dtcm_ram,\n    input  logic                   rst_dtcm\n);\n\n    // ITCM RAM\n    logic [E203_ITCM_RAM_DW-1:0] itcm_ram [E203_ITCM_RAM_DP-1:0];\n\n    always_ff @(posedge clk_itcm_ram or negedge rst_itcm) begin\n        if (~rst_itcm) begin\n            for (int i = 0; i < E203_ITCM_RAM_DP; i++) begin\n                itcm_ram[i] <= '0;\n            end\n        end else if (itcm_ram_cs && itcm_ram_we) begin\n            for (int i = 0; i < E203_ITCM_RAM_MW; i++) begin\n                if (itcm_ram_wem[i]) begin\n                    itcm_ram[itcm_ram_addr][i*8 +: 8] <= itcm_ram_din[i*8 +: 8];\n                end\n            end\n        end\n    end\n\n    assign itcm_ram_dout = itcm_ram[itcm_ram_addr];\n\n    // DTCM RAM\n    logic [E203_DTCM_RAM_DW-1:0] dtcm_ram [E203_DTCM_RAM_DP-1:0];\n\n    always_ff @(posedge clk_dtcm_ram or negedge rst_dtcm) begin\n        if (~rst_dtcm) begin\n            for (int i = 0; i < E203_DTCM_RAM_DP; i++) begin\n                dtcm_ram[i] <= '0;\n            end\n        end else if (dtcm_ram_cs && dtcm_ram_we) begin\n            for (int i = 0; i < E203_DTCM_RAM_MW; i++) begin\n                if (dtcm_ram_wem[i]) begin\n                    dtcm_ram[dtcm_ram_addr][i*8 +: 8] <= dtcm_ram_din[i*8 +: 8];\n                end\n            end\n        end\n    end\n\n    assign dtcm_ram_dout = dtcm_ram[dtcm_ram_addr];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 1, "code": "module e203_exu_alu_bjp(\n    input  logic                   bjp_i_valid,\n    output logic                   bjp_i_ready,\n    input  logic [E203_XLEN-1:0]   bjp_i_rs1,\n    input  logic [E203_XLEN-1:0]   bjp_i_rs2,\n    input  logic [E203_XLEN-1:0]   bjp_i_imm,\n    input  logic [E203_PC_SIZE-1:0]bjp_i_pc,\n    input  logic [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output logic                   bjp_o_valid,\n    input  logic                   bjp_o_ready,\n    output logic [E203_XLEN-1:0]   bjp_o_wbck_wdat,\n    output logic                   bjp_o_wbck_err,\n    output logic                   bjp_o_cmt_bjp,\n    output logic                   bjp_o_cmt_mret,\n    output logic                   bjp_o_cmt_dret,\n    output logic                   bjp_o_cmt_fencei,\n    output logic                   bjp_o_cmt_prdt,\n    output logic                   bjp_o_cmt_rslv,\n    output logic [E203_XLEN-1:0]   bjp_req_alu_op1,\n    output logic [E203_XLEN-1:0]   bjp_req_alu_op2,\n    output logic                   bjp_req_alu_cmp_eq,\n    output logic                   bjp_req_alu_cmp_ne,\n    output logic                   bjp_req_alu_cmp_lt,\n    output logic                   bjp_req_alu_cmp_gt,\n    output logic                   bjp_req_alu_cmp_ltu,\n    output logic                   bjp_req_alu_cmp_gtu,\n    output logic                   bjp_req_alu_add,\n    input  logic                   bjp_req_alu_cmp_res,\n    input  logic [E203_XLEN-1:0]   bjp_req_alu_add_res,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n\n    // Handshake logic\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Operand selection\n    assign bjp_req_alu_op1 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? {E203_XLEN-1'{1'b0}} : bjp_i_rs2;\n\n    // ALU request generation\n    assign bjp_req_alu_cmp_eq = bjp_i_info[E203_DECINFO_BJP_BEQ];\n    assign bjp_req_alu_cmp_ne = bjp_i_info[E203_DECINFO_BJP_BNE];\n    assign bjp_req_alu_cmp_lt = bjp_i_info[E203_DECINFO_BJP_BLT];\n    assign bjp_req_alu_cmp_gt = bjp_i_info[E203_DECINFO_BJP_BGT];\n    assign bjp_req_alu_cmp_ltu = bjp_i_info[E203_DECINFO_BJP_BLTU];\n    assign bjp_req_alu_cmp_gtu = bjp_i_info[E203_DECINFO_BJP_BGTU];\n    assign bjp_req_alu_add = bjp_i_info[E203_DECINFO_BJP_JUMP];\n\n    // Commit signal generation\n    assign bjp_o_cmt_bjp = bjp_i_info[E203_DECINFO_BJP_BXX];\n    assign bjp_o_cmt_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n    assign bjp_o_cmt_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n    assign bjp_o_cmt_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n\n    // Predicted and resolved result generation\n    assign bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    assign bjp_o_cmt_rslv = (bjp_i_info[E203_DECINFO_BJP_JUMP]) ? 1'b1 : bjp_req_alu_cmp_res;\n\n    // Write-back data generation\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n    assign bjp_o_wbck_err = 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 5, "code": "```\nmodule e203_cpu_top #(\n    parameter E203_CFG_ADDR_SIZE_IS_32 = 1,\n    parameter E203_CFG_HAS_ITCM = 1,\n    parameter E203_CFG_HAS_DTCM = 1,\n    parameter E203_CFG_SUPPORT_SHARE_MULDIV = 1,\n    parameter E203_CFG_HAS_NICE = 1,\n    parameter E203_CFG_SUPPORT_AMO = 1,\n    parameter E203_CFG_DEBUG_HAS_JTAG = 1,\n    parameter E203_CFG_IRQ_NEED_SYNC = 1\n)(\n    // Output ports\n    output wire [E203_PC_SIZE-1:0] inspect_pc,\n    output wire inspect_dbg_irq,\n    output wire inspect_mem_cmd_valid,\n    output wire inspect_mem_cmd_ready,\n    output wire inspect_mem_rsp_valid,\n    output wire inspect_mem_rsp_ready,\n    output wire inspect_core_clk,\n    output wire core_csr_clk,\n    output wire core_wfi,\n    output wire tm_stop,\n    output wire dbg_irq_r,\n\n    // Input ports\n    input wire [E203_PC_SIZE-1:0] pc_rtvec,\n    input wire ext_irq_a,\n    input wire sft_irq_a,\n    input wire tmr_irq_a,\n    input wire tcm_sd,\n    input wire tcm_ds,\n    input wire ext2itcm_icb_cmd_valid,\n    input wire ext2itcm_icb_cmd_ready,\n    input wire [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input wire ext2itcm_icb_cmd_read,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input wire [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    input wire ext2itcm_icb_rsp_valid,\n    input wire ext2itcm_icb_rsp_ready,\n    input wire ext2itcm_icb_rsp_err,\n    input wire [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n\n    // Clock and reset\n    input wire clk,\n    input wire rst_n\n);\n\n// Internal wires and registers\nwire [E203_XLEN-1:0] itcm_ram_dout;\nwire [E203_XLEN-1:0] dtcm_ram_dout;\n\n// Instantiate e203_cpu module\ne203_cpu #(\n    .E203_CFG_ADDR_SIZE_IS_32(E203_CFG_ADDR_SIZE_IS_32),\n    .E203_CFG_HAS_ITCM(E203_CFG_HAS_ITCM),\n    .E203_CFG_HAS_DTCM(E203_CFG_HAS_DTCM),\n    .E203_CFG_SUPPORT_SHARE_MULDIV(E203_CFG_SUPPORT_SHARE_MULDIV),\n    .E203_CFG_HAS_NICE(E203_CFG_HAS_NICE),\n    .E203_CFG_SUPPORT_AMO(E203_CFG_SUPPORT_AMO)\n) e203_cpu_inst (\n    .inspect_pc(inspect_pc),\n    .inspect_dbg_irq(inspect_dbg_irq),\n    .inspect_mem_cmd_valid(inspect_mem_cmd_valid),\n    .inspect_mem_cmd_ready(inspect_mem_cmd_ready),\n    .inspect_mem_rsp_valid(inspect_mem_rsp_valid),\n    .inspect_mem_rsp_ready(inspect_mem_rsp_ready),\n    .inspect_core_clk(inspect_core_clk),\n    .core_csr_clk(core_csr_clk),\n    .core_wfi(core_wfi),\n    .tm_stop(tm_stop),\n    .dbg_irq_r(dbg_irq_r),\n\n    .pc_rtvec(pc_rtvec),\n    .ext_irq_a(ext_irq_a),\n    .sft_irq_a(sft_irq_a),\n    .tmr_irq_a(tmr_irq_a),\n\n    .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n    .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n    .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n    .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n    .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n    .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n    .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n    .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n    .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n    .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata),\n\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Instantiate e203_srams module\ne203_srams #(\n    .E203_CFG_HAS_ITCM(E203_CFG_HAS_ITCM),\n    .E203_CFG_HAS_DTCM(E203_CFG_HAS_DTCM)\n) e203_srams_inst (\n    .itcm_ram_sd(tcm_sd),\n    .itcm_ram_ds(tcm_ds),\n    .itcm_ram_ls(),\n    .itcm_ram_cs(),\n    .itcm_ram_we(),\n    .itcm_ram_addr(),\n    .itcm_ram_wem(),\n    .itcm_ram_din(),\n    .itcm_ram_dout(itcm_ram_dout),\n    .clk_itcm_ram(clk),\n\n    .dtcm_ram_sd(tcm_sd),\n    .dtcm_ram_ds(tcm_ds),\n    .dtcm_ram_ls(),\n    .dtcm_ram_cs(),\n    .dtcm_ram_we(),\n    .dtcm_ram_addr(),\n    .dtcm_ram_wem(),\n    .dtcm_ram_din(),\n    .dtcm_ram_dout(dtcm_ram_dout),\n    .clk_dtcm_ram(clk),\n\n    .rst_itcm(rst_n),\n    .rst_dtcm(rst_n)\n);\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 2, "code": "```ilog\n// Import necessary files\n`include \"e203_defines.v\"\n\nmodule e203_exu_nice(\n    // Input ports\n    input  logic                   nice_i_xs_off,  // NICE accelerator disable signal\n    input  logic                   nice_i_valid,   // Input instruction valid signal\n    output logic                   nice_o_ready,   // Ready signal to accept input instruction\n    input  logic [E203_XLEN-1:0]   nice_i_instr,   // Input instruction to be executed by NICE\n    input  logic [E203_XLEN-1:0]   nice_i_rs1,     // Input source register 1 value\n    input  logic [E203_XLEN-1:0]   nice_i_rs2,     // Input source register 2 value\n    input  logic [E203_ITAG_WIDTH-1:0] nice_i_itag, // Input instruction tag for tracking\n    output logic                   nice_o_longpipe,// Indicates if instruction needs long pipeline handling\n    output logic                   nice_o_valid,   // Valid signal for commit interface\n    input  logic                   nice_o_ready,   // Ready signal from commit interface\n    output logic                   nice_o_itag_valid,// Valid signal for instruction tag writeback\n    input  logic                   nice_o_itag_ready,// Ready signal for instruction tag writeback\n    output logic [E203_ITAG_WIDTH-1:0] nice_o_itag, // Instruction tag for writeback\n    input  logic                   nice_rsp_multicyc_valid, // Multi-cycle operation completion signal\n    output logic                   nice_rsp_multicyc_ready, // Ready signal for multi-cycle operation completion\n    output logic                   nice_req_valid,  // Valid signal for request to custom accelerator\n    input  logic                   nice_req_ready,  // Ready signal from custom accelerator\n    output logic [E203_XLEN-1:0]   nice_req_instr,  // Instruction forwarded to custom accelerator\n    output logic [E203_XLEN-1:0]   nice_req_rs1,    // Source register 1 forwarded to custom accelerator\n    output logic [E203_XLEN-1:0]   nice_req_rs2,    // Source register 2 forwarded to custom accelerator\n    input  logic                   clk,             // System clock\n    input  logic                   rst_n            // Active low reset signal\n);\n\n// Internal signals and variables\nlogic [E203_ITAG_WIDTH-1:0] itag_fifo [3:0]; // Instruction tag FIFO\nlogic [1:0] itag_fifo_ptr; // Instruction tag FIFO pointer\nlogic itag_fifo_empty; // Instruction tag FIFO empty signal\nlogic itag_fifo_full; // Instruction tag FIFO full signal\n\n// Instruction tag FIFO implementation\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        itag_fifo_ptr <= 2'b00;\n        itag_fifo_empty <= 1'b1;\n        itag_fifo_full <= 1'b0;\n    end else begin\n        if (nice_i_valid && ~itag_fifo_full) begin\n            itag_fifo[itag_fifo_ptr] <= nice_i_itag;\n            itag_fifo_ptr <= itag_fifo_ptr + 1'b1;\n            itag_fifo_empty <= 1'b0;\n            if (itag_fifo_ptr == 2'b11) begin\n                itag_fifo_full <= 1'b1;\n            end\n        end else if (nice_rsp_multicyc_valid && ~itag_fifo_empty) begin\n            itag_fifo_ptr <= itag_fifo_ptr - 1'b1;\n            itag_fifo_empty <= 1'b1;\n            if (itag_fifo_ptr == 2'b00) begin\n                itag_fifo_full <= 1'b0;\n            end\n        end\n    end\nend\n\n// Handshaking protocol implementation\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        nice_o_ready <= 1'b0;\n        nice_o_valid <= 1'b0;\n        nice_o_itag_valid <= 1'b0;\n        nice_rsp_multicyc_ready <= 1'b0;\n        nice_req_valid <= 1'b0;\n    end else begin\n        if (nice_i_valid && ~nice_i_xs_off && ~itag_fifo_full) begin\n            nice_o_ready <= 1'b1;\n            nice_req_valid <= 1'b1;\n            nice_req_instr <= nice_i_instr;\n            nice_req_rs1 <= nice_i_rs1;\n            nice_req_rs2 <= nice_i_rs2;\n        end else begin\n            nice_o_ready <= 1'b0;\n            nice_req_valid <= 1'b0;\n        end\n        \n        if (nice_o_ready && nice_o_valid && nice_o_ready) begin\n            nice_o_valid <= 1'b1;\n        end else begin\n            nice_o_valid <= 1'b0;\n        end\n        \n        if (nice_rsp_multicyc_valid && ~itag_fifo_empty) begin\n            nice_o_itag_valid <= 1'b1;\n            nice_o_itag <= itag_fifo[itag_fifo_ptr];\n            nice_rsp_multicyc_ready <= 1'b1;\n        end else begin\n            nice_o_itag_valid <= 1'b0;\n            nice_rsp_multicyc_ready <= 1'b0;\n        end\n    end\nend\n\n// Long pipeline handling implementation\nassign nice_o_longpipe = nice_i_xs_off ? 1'b0 : 1'b1;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 3, "code": "module e203_ifu_litebpu(\n    input   logic                   clk,\n    input   logic                   rst_n,\n    input   logic [E203_PC_SIZE-1:0] pc,\n    input   logic                   dec_jal,\n    input   logic                   dec_jalr,\n    input   logic                   dec_bxx,\n    input   logic [E203_XLEN-1:0]   dec_bjp_imm,\n    input   logic [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    input   logic                   oitf_empty,\n    input   logic                   ir_empty,\n    input   logic                   ir_rs1en,\n    input   logic                   jalr_rs1idx_cam_irrdidx,\n    input   logic                   dec_i_valid,\n    input   logic                   ir_valid_clr,\n    input   logic [E203_XLEN-1:0]   rf2bpu_x1,\n    input   logic [E203_XLEN-1:0]   rf2bpu_rs1,\n    output  logic                   prdt_taken,\n    output  logic [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n    output  logic [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n    output  logic                   bpu_wait,\n    output  logic                   bpu2rf_rs1_ena\n);\n\n// Internal signals and variables\nlogic [E203_XLEN-1:0] jalr_target_addr;\nlogic [E203_XLEN-1:0] bxx_target_addr;\nlogic jalr_rs1xn_dep;\nlogic jalr_rs1xn_dep_ir_clr;\n\n// JALR instruction target address calculation\nalways_comb begin\n    if (dec_jalr_rs1idx == 5'd0) begin // rs1 = x0\n        jalr_target_addr = dec_bjp_imm;\n    end else if (dec_jalr_rs1idx == 5'd1) begin // rs1 = x1\n        jalr_target_addr = rf2bpu_x1 + dec_bjp_imm;\n    end else begin // rs1 = xn\n        jalr_target_addr = rf2bpu_rs1 + dec_bjp_imm;\n    end\nend\n\n// BXX instruction target address calculation\nalways_comb begin\n    bxx_target_addr = pc + dec_bjp_imm;\nend\n\n// Dependency detection for JALR instruction\nalways_comb begin\n    if (dec_jalr_rs1idx == 5'd1) begin // rs1 = x1\n        jalr_rs1xn_dep = ~oitf_empty || jalr_rs1idx_cam_irrdidx;\n    end else if (dec_j0:alr_rs1idx != 5'd0) begin // rs1 = xn\n        jalr_rs1xn_dep = ~oitf_empty || ~ir_empty || ir_rs1en;\n    end else begin\n        jalr_rs1xn_dep = 1'b0;\n    end\nend\n\n// Dependency clearance for JALR instruction\nalways_comb begin\n    if (ir_valid_clr) begin\n        jalr_rs1xn_dep_ir_clr = 1'b1;\n    end else begin\n        jalr_rs1xn_dep_ir_clr = 1'b0;\n    end\nend\n\n// Predicted taken signal generation\nalways_comb begin\n    if (dec_jal || dec_jalr) begin\n        prdt_taken = 1'b1;\n    end else if (dec_bxx && dec_bjp_imm[E203_XLEN-1]) begin // backward jump\n        prdt_taken = 1'b1;\n    end else begin\n        prdt_taken = 1'b0;\n    end\nend\n\n// PC adder operand 1 generation\nalways_comb begin\n    if (dec_jalr && dec_jalr_rs1idx == 5'd0) begin\n        prdt_pc_add_op1 = 'd0;\n    end else if (dec_jalr && dec_jalr_rs1idx == 5'd1) begin\n        prdt_pc_add_op1 = rf2bpu_x1;\n    end else if (dec_jalr && dec_jalr_rs1idx != 5'd0 && dec_jalr_rs1idx != 5'd1) begin\n        prdt_pc_add_op1 = rf2bpu_rs1;\n    end else begin\n        prdt_pc_add_op1 = pc;\n    end\nend\n\n// PC adder operand 2 generation\nalways_comb begin\n    prdt_pc_add_op2 = dec_bjp_imm[E203_PC_SIZE-1:0];\nend\n\n// BPU wait signal generation\nalways_comb begin\n    if (jalr_rs1xn_dep && ~jalr_rs1xn_dep_ir_clr) begin\n        bpu_wait = 1'b1;\n    end else begin\n        bpu_wait = 1'b0;\n    end\nend\n\n// BPU to RF rs1 enable signal generation\nalways_comb begin\n    if (dec_jalr && dec_jalr_rs1idx != 5'd0 && dec_jalr_rs1idx != 5'd1) begin\n        bpu2rf_rs1_ena = 1'b1;\n    end else begin\n        bpu2rf_rs1_ena = 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 1, "code": "module e203_exu_longpwbck(\n    input               clk,\n    input               rst_n,\n    // LSU Interface\n    input               lsu_wbck_i_valid,\n    output              lsu_wbck_i_ready,\n    input       [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input       [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input               lsu_wbck_i_err,\n    input               lsu_cmt_i_buserr,\n    input       [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input               lsu_cmt_i_ld,\n    input               lsu_cmt_i_st,\n    // Long-Pipeline Write-Back Interface\n    output              longp_wbck_o_valid,\n    input               longp_wbck_o_ready,\n    output      [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output      [4:0] longp_wbck_o_flags,\n    output      [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output              longp_wbck_o_rdfpu,\n    // Exception Interface\n    output              longp_excp_o_valid,\n    input               longp_excp_o_ready,\n    output              longp_excp_o_insterr,\n    output              longp_excp_o_ld,\n    output              longp_excp_o_st,\n    output              longp_excp_o_buserr,\n    output      [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output      [E203_PC_SIZE-1:0] longp_excp_o_pc,\n    // OITF Interface\n    input               oitf_empty,\n    input       [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input       [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input       [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input               oitf_ret_rdwen,\n    input               oitf_ret_rdfpu,\n    output              oitf_ret_ena,\n    // NICE Interface (Optional)\n    `ifdef E203_HAS_NICE\n    input               nice_longp_wbck_i_valid,\n    output              nice_longp_wbck_i_ready,\n    input       [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input       [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input               nice_longp_wbck_i_err,\n    `endif\n);\n\n// Internal signals and variables\nreg [E203_XLEN-1:0] wdat;\nreg [E203_ITAG_WIDTH-1:0] itag;\nreg err;\nreg buserr;\nreg [E203_ADDR_SIZE-1:0] badaddr;\nreg ld;\nreg st;\nreg wbck_need;\nreg excp_need;\nreg [E203_RFIDX_WIDTH-1:0] rdidx;\nreg rdfpu;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        lsu_wbck_i_ready <= 1'b0;\n        longp_wbck_o_valid <= 1'b0;\n        longp_excp_o_valid <= 1'b0;\n        oitf_ret_ena <= 1'b0;\n        `ifdef E203_HAS_NICE\n        nice_longp_wbck_i_ready <= 1'b0;\n        `endif\n    end else begin\n        // Write-Back Needs\n        wbck_need <= (lsu_wbck_i_valid && !lsu_wbck_i_err && oitf_ret_rdwen) ||\n                     (lsu_wbck_i_valid && !lsu_wbck_i_err && oitf_ret_rdfpu);\n        \n        // Exception Needs\n        excp_need <= lsu_wbck_i_err || lsu_cmt_i_buserr;\n        \n        // OITF Control Logic\n        oitf_ret_ena <= (wbck_need || excp_need) && longp_wbck_o_ready && longp_excp_o_ready;\n        \n        // LSU Interface\n        lsu_wbck_i_ready <= (wbck_need && longp_wbck_o_ready) || (excp_need && longp_excp_o_ready);\n        \n        // Long-Pipeline Write-Back Interface\n        longp_wbck_o_valid <= wbck_need && lsu_wbck_i_valid;\n        longp_wbck_o_wdat <= lsu_wbck_i_wdat;\n        longp_wbck_o_flags <= {lsu_cmt_i_ld, lsu_cmt_i_st, lsu_wbck_i_err, 2'b0};\n        longp_wbck_o_rdidx <= oitf_ret_rdidx;\n        longp_wbck_o_rdfpu <= oitf_ret_rdfpu;\n        \n        // Exception Interface\n        longp_excp_o_valid <= excp_need && lsu_wbck_i_valid;\n        longp_excp_o_insterr <= lsu_wbck_i_err;\n        longp_excp_o_ld <= lsu_cmt_i_ld;\n        longp_excp_o_st <= lsu_cmt_i_st;\n        longp_excp_o_buserr <= lsu_cmt_i_buserr;\n        longp_excp_o_badaddr <= lsu_cmt_i_badaddr;\n        longp_excp_o_pc <= oitf_ret_pc;\n        \n        // NICE Interface (Optional)\n        `ifdef E203_HAS_NICE\n        nice_longp_wbck_i_ready <= (wbck_need && longp_wbck_o_ready) || (excp_need && longp_excp_o_ready);\n        `endif\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 2, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_oitf(\n    output dis_ready,\n    input dis_ena,\n    input ret_ena,\n    output [E203_ITAG_WIDTH-1:0] dis_ptr,\n    output [E203_ITAG_WIDTH-1:0] ret_ptr,\n    output [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n    output ret_rdwen,\n    output ret_rdfpu,\n    output [E203_PC_SIZE-1:0] ret_pc,\n    input disp_i_rs1en,\n    input disp_i_rs2en,\n    input disp_i_rs3en,\n    input disp_i_rdwen,\n    input disp_i_rs1fpu,\n    input disp_i_rs2fpu,\n    input disp_i_rs3fpu,\n    input disp_i_rdfpu,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input [E203_PC_SIZE-1:0] disp_i_pc,\n    output oitfrd_match_disprs1,\n    output oitfrd_match_disprs2,\n    output oitfrd_match_disprs3,\n    output oitfrd_match_disprd,\n    output oitf_empty,\n    input clk,\n    input rst_n\n);\n\nreg [E203_ITAG_WIDTH-1:0] dis_ptr_reg;\nreg [E203_ITAG_WIDTH-1:0] ret_ptr_reg;\nreg [E203_OITF_DEPTH-1:0] oitf_reg [E203_RFIDX_WIDTH-1:0];\nreg [E203_PC_SIZE-1:0] oitf_pc_reg [E203_OITF_DEPTH-1:0];\nreg oitf_rdwen_reg [E203_OITF_DEPTH-1:0];\nreg oitf_rdfpu_reg [E203_OITF_DEPTH-1:0];\n\nassign dis_ready = (dis_ptr_reg != ret_ptr_reg) || (oitf_empty == 1'b1);\nassign ret_rdidx = oitf_reg[ret_ptr_reg][E203_RFIDX_WIDTH-1:0];\nassign ret_pc = oitf_pc_reg[ret_ptr_reg];\nassign ret_rdwen = oitf_rdwen_reg[ret_ptr_reg];\nassign ret_rdfpu = oitf_rdfpu_reg[ret_ptr_reg];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        dis_ptr_reg <= '0;\n        ret_ptr_reg <= '0;\n        oitf_reg <= '0;\n        oitf_pc_reg <= '0;\n        oitf_rdwen_reg <= '0;\n        oitf_rdfpu_reg <= '0;\n    end else begin\n        if (dis_ena) begin\n            oitf_reg[dis_ptr_reg] <= {disp_i_rdidx, disp_i_rdfpu, disp_i_pc};\n            oitf_pc_reg[dis_ptr_reg] <= disp_i_pc;\n            oitf_rdwen_reg[dis_ptr_reg] <= disp_i_rdwen;\n            oitf_rdfpu_reg[dis_ptr_reg] <= disp_i_rdfpu;\n            dis_ptr_reg <= dis_ptr_reg + 1;\n            if (dis_ptr_reg == E203_OITF_DEPTH - 1) begin\n                dis_ptr_reg <= '0;\n            end\n        end\n\n        if (ret_ena) begin\n            ret_ptr_reg <= ret_ptr_reg + 1;\n            if (ret_ptr_reg == E203_OITF_DEPTH - 1) begin\n                ret_ptr_reg <= '0;\n            end\n        end\n    end\nend\n\nalways @(*) begin\n    oitfrd_match_disprs1 = 1'b0;\n    oitfrd_match_disprs2 = 1'b0;\n    oitfrd_match_disprs3 = 1'b0;\n    oitfrd_match_disprd = 1'b0;\n    for (int i = 0; i < E203_OITF_DEPTH; i++) begin\n        if (oitf_rdwen_reg[i] && oitf_reg[i][E203_RFIDX_WIDTH-1:0] == disp_i_rs1idx && oitf_rdfpu_reg[i] == disp_i_rs1fpu) begin\n            oitfrd_match_disprs1 = 1'b1;\n        end\n        if (oitf_rdwen_reg[i] && oitf_reg[i][E203_RFIDX_WIDTH-1:0] == disp_i_rs2idx && oitf_rdfpu_reg[i] == disp_i_rs2fpu) begin\n            oitfrd_match_disprs2 = 1'b1;\n        end\n        if (oitf_rdwen_reg[i] && oitf_reg[i][E203_RFIDX_WIDTH-1:0] == disp_i_rs3idx && oitf_rdfpu_reg[i] == disp_i_rs3fpu) begin\n            oitfrd_match_disprs3 = 1'b1;\n        end\n        if (oitf_rdwen_reg[i] && oitf_reg[i][E203_RFIDX_WIDTH-1:0] == disp_i_rdidx && oitf_rdfpu_reg[i] == disp_i_rdfpu) begin\n            oitfrd_match_disprd = 1'b1;\n        end\n    end\nend\n\nassign oitf_empty = (dis_ptr_reg == ret_ptr_reg);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 3, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_oitf (\n    output dis_ready,\n    input  dis_ena,\n    input  ret_ena,\n    output [E203_ITAG_WIDTH-1:0] dis_ptr,\n    output [E203_ITAG_WIDTH-1:0] ret_ptr,\n    output [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n    output ret_rdwen,\n    output ret_rdfpu,\n    output [E203_PC_SIZE-1:0] ret_pc,\n    input  disp_i_rs1en,\n    input  disp_i_rs2en,\n    input  disp_i_rs3en,\n    input  disp_i_rdwen,\n    input  disp_i_rs1fpu,\n    input  disp_i_rs2fpu,\n    input  disp_i_rs3fpu,\n    input  disp_i_rdfpu,\n    input  [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input  [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input  [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n    input  [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input  [E203_PC_SIZE-1:0] disp_i_pc,\n    output oitfrd_match_disprs1,\n    output oitfrd_match_disprs2,\n    output oitfrd_match_disprs3,\n    output oitfrd_match_disprd,\n    output oitf_empty,\n    input  clk,\n    input  rst_n\n);\n\nreg [E203_ITAG_WIDTH-1:0] dis_ptr_reg;\nreg [E203_ITAG_WIDTH-1:0] ret_ptr_reg;\nreg [E203_OITF_DEPTH-1:0] oitf_reg [E203_RFIDX_WIDTH-1:0];\nreg [E203_OITF_DEPTH-1:0] oitf_valid;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        dis_ptr_reg <= '0;\n        ret_ptr_reg <= '0;\n        oitf_reg <= '{default: '0};\n        oitf_valid <= '0;\n    end else begin\n        if (dis_ena) begin\n            oitf_reg[dis_ptr_reg] <= {disp_i_rdwen, disp_i_rdfpu, disp_i_rdidx, disp_i_pc};\n            oitf_valid[dis_ptr_reg] <= 1'b1;\n            dis_ptr_reg <= dis_ptr_reg + 1;\n            if (dis_ptr_reg == E203_OITF_DEPTH - 1) begin\n                dis_ptr_reg <= '0;\n            end\n        end\n\n        if (ret_ena) begin\n            oitf_valid[ret_ptr_reg] <= 1'b0;\n            ret_ptr_reg <= ret_ptr_reg + 1;\n            if (ret_ptr_reg == E203_OITF_DEPTH - 1) begin\n                ret_ptr_reg <= '0;\n            end\n        end\n    end\nend\n\nassign dis_ready = ~(dis_ptr_reg == ret_ptr_reg && oitf_valid[dis_ptr_reg]);\nassign ret_rdidx = oitf_reg[ret_ptr_reg][E203_RFIDX_WIDTH-1:0];\nassign ret_rdwen = oitf_reg[ret_ptr_reg][E203_RFIDX_WIDTH];\nassign ret_rdfpu = oitf_reg[ret_ptr_reg][E203_RFIDX_WIDTH+1];\nassign ret_pc = oitf_reg[ret_ptr_reg][E203_PC_SIZE+E203_RFIDX_WIDTH+1:E203_RFIDX_WIDTH+2];\nassign oitfrd_match_disprs1 = (oitf_valid[0:dis_ptr_reg] && oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH-1:0] == disp_i_rs1idx && disp_i_rs1en && oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH] && !disp_i_rs1fpu && !oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH+1]);\nassign oitfrd_match_disprs2 = (oitf_valid[dis_ptr_reg] && oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH-1:0] == disp_i_rs2idx && disp_i_rs2en && oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH] && !disp_i_rs2fpu && !oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH+1]);\nassign oitfrd_match_disprs3 = (oitf_valid[dis_ptr_reg] && oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH-1:0] == disp_i_rs3idx && disp_i_rs3en && oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH] && !disp_i_rs3fpu && !oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH+1]);\nassign oitfrd_match_disprd = (oitf_valid[dis_ptr_reg] && oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH-1:0] == disp_i_rdidx && disp_i_rdwen && oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH] && !disp_i_rdfpu && !oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH+1]);\nassign oitf_empty = ~(|oitf_valid);\n\nassign dis_ptr = dis_ptr_reg;\nassign ret_ptr = ret_ptr_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 9, "code": "// Import necessary configuration files\n`include \"e203_defines.v\"\n\nmodule e203_clk_ctrl(\n    // Basic input signals\n    input  clk,            // System clock\n    input  rst_n,          // Asynchronous reset (active low)\n    input  test_mode,      // Test mode signal\n    input  core_cgstop,    // Clock-gated stop signal from CSR register\n\n    // Functional unit activity state signals\n    input  core_ifu_active, // Instruction Fetch Unit active status\n    input  core_exu_active, // Execution unit active state\n    input  core_lsu_active, // Load storage cell active state\n    input  core_biu_active, // Bus interface unit active state\n    input  core_wfi,       // Wait for interrupt status signal\n\n    // Optional signals for ITCM and DTCM (if enabled)\n    input  itcm_active,    // ITCM active status (if E203_HAS_ITCM is defined)\n    output itcm_ls,        // ITCM clock low power state (if E203_HAS_ITCM is defined)\n    input  dtcm_active,    // DTCM active status (if E203_HAS_DTCM is defined)\n    output dtcm_ls,        // DTCM clock low power state (if E203_HAS_DTCM is defined)\n\n    // Clock output signals\n    output clk_aon,        // Normally on clock\n    output clk_core_ifu,   // IFU module clock\n    output clk_core_exu,   // EXU module clock\n    output clk_core_lsu,   // LSU module clock\n    output clk_core_biu,   // BIU module clock\n    output clk_itcm,       // ITCM module clock (if E203_HAS_ITCM is defined)\n    output clk_dtcm        // DTCM module clock (if E203_HAS_DTCM is defined)\n);\n\n// Internal wires and registers\nwire clk_enable_ifu;\nwire clk_enable_exu;\nwire clk_enable_lsu;\nwire clk_enable_biu;\nwire clk_enable_itcm;\nwire clk_enable_dtcm;\n\n// Clock enable control logic\nassign clk_enable_ifu = core_cgstop || (core_ifu_active && !core_wfi);\nassign clk_enable_exu = core_cgstop || core_exu_active;\nassign clk_enable_lsu = core_cgstop || core_lsu_active;\nassign clk_enable_biu = core_cgstop || core_biu_active;\n\n// ITCM and DTCM clock control (if enabled)\n`ifdef E203_HAS_ITCM\n    assign clk_enable_itcm = core_cgstop || itcm_active;\n    assign itcm_ls = ~clk_enable_itcm; // Low power state when clock is gated\n`endif\n\n`ifdef E203_HAS_DTCM\n    assign clk_enable_dtcm = core_cgstop || dtcm_active;\n    assign dtcm_ls = ~clk_enable_dtcm; // Low power state when clock is gated\n`endif\n\n// Clock gating logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        clk_aon <= 1'b0;\n        clk_core_ifu <= 1'b0;\n        clk_core_exu <= 1'b0;\n        clk_core_lsu <= 1'b0;\n        clk_core_biu <= 1'b0;\n        `ifdef0: E203_HAS_ITCM\n            clk_itcm <= 1'b0;\n        `endif\n        `ifdef E203_HAS_DTCM\n            clk_dtcm <= 1'b0;\n        `endif\n    end else begin\n        clk_aon <= 1'b1; // Normally on clock\n        clk_core_ifu <= clk_enable_ifu ? clk : 1'b0;\n        clk_core_exu <= clk_enable_exu ? clk : 1'b0;\n        clk_core_lsu <= clk_enable_lsu ? clk : 1'b0;\n        clk_core_biu <= clk_enable_biu ? clk : 1'b0;\n        `ifdef E203_HAS_ITCM\n            clk_itcm <= clk_enable_itcm ? clk : 1'b0;\n        `endif\n        `ifdef E203_HAS_DTCM\n            clk_dtcm <= clk_enable_dtcm ? clk : 1'b0;\n        `endif\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 3, "code": "module e203_exu_nice(\n    input  logic             nice_i_xs_off,    // NICE accelerator disable signal\n    input  logic             nice_i_valid,     // Input instruction valid signal\n    output logic             nice_o_ready,     // Ready signal to accept input instruction\n    input  logic [E203_XLEN-1:0] nice_i_instr,  // Input instruction to be executed by NICE\n    input  logic [E203_XLEN-1:0] nice_i_rs1,    // Input source register 1 value\n    input  logic [E203_XLEN-1:0] nice_i_rs2,    // Input source register 2 value\n    input  logic [E203_ITAG_WIDTH-1:0] nice_i_itag, // Input instruction tag for tracking\n    output logic             nice_o_longpipe,  // Indicates if instruction needs long pipeline handling\n    output logic             nice_o_valid,     // Valid signal for commit interface\n    input  logic             nice_o_ready,     // Ready signal from commit interface\n    output logic             nice_o_itag_valid,// Valid signal for instruction tag writeback\n    input  logic             nice_o_itag_ready,// Ready signal for instruction tag writeback\n    output logic [E203_ITAG_WIDTH-1:0] nice_o_itag, // Instruction tag for writeback\n    input  logic             nice_rsp_multicyc_valid, // Multi-cycle operation completion signal\n    output logic             nice_rsp_multicyc_ready, // Ready signal for multi-cycle operation completion\n    output logic             nice_req_valid,   // Valid signal for request to custom accelerator\n    input  logic             nice_req_ready,   // Ready signal from custom accelerator\n    output logic [E203_XLEN-1:0] nice_req_instr, // Instruction forwarded to custom accelerator\n    output logic [E203_XLEN-1:0] nice_req_rs1,   // Source register 1 forwarded to custom accelerator\n    output logic [E203_XLEN-1:0] nice_req_rs2,   // Source register 2 forwarded to custom accelerator\n    input  logic             clk,              // System clock\n    input  logic             rst_n             // Active low reset signal\n);\n\n// Internal signals and variables\nlogic [E203_ITAG_WIDTH-1:0] itag_fifo [3:0]; // Instruction tag FIFO\nlogic [2:0] itag_fifo_ptr; // Instruction tag FIFO pointer\nlogic itag_fifo_full; // Instruction tag FIFO full flag\nlogic itag_fifo_empty; // Instruction tag FIFO empty flag\n\n// Handshaking protocol logic\nassign nice_o_ready = ~nice_i_xs_off && ~itag_fifo_full;\nassign nice_req_valid = nice_i_valid && nice_o_ready;\nassign nice_rsp_multicyc_ready = nice_req_valid && nice_req_ready;\n\n// Instruction forwarding logic\nassign nice_req_instr = nice_i_instr;\nassign nice_req_rs1 = nice_i_rs1;\nassign nice_req_rs2 = nice_i_rs2;\n\n// Instruction tag handling logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        itag_fifo_ptr <= 0;\n        itag_fifo_full <= 0;\n        itag_fifo_empty <= 1;\n    end else begin\n        if (nice_i_valid && nice_o_ready) begin\n            // Push instruction tag into FIFO\n            itag_fifo[itag_fifo_ptr] <= nice_i_itag;\n            itag_fifo_ptr <= itag_fifo_ptr + 1;\n            if (itag_fifo_ptr == 4'd3) begin\n                itag_fifo_full <= 1;\n            end\n        end\n        if (nice_rsp_multicyc_valid && nice_rsp_multicyc_ready) begin\n            // Pop instruction tag from FIFO\n            itag_fifo_ptr <= itag_fifo_ptr - 1;\n            if (itag_fifo_ptr == 0) begin\n                itag_fifo_empty <= 1;\n            end\n        end\n    end\nend\n\n// Instruction tag writeback logic\nassign nice_o_itag_valid = ~itag_fifo_empty;\nassign nice_o_itag = itag_fifo[0];\n\n// Long pipeline handling logic\nassign nice_o_longpipe = nice_i_xs_off;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 1, "code": "module e203_exu_alu_lsuagu (\n    input  logic                   agu_i_valid,\n    output logic                   agu_i_ready,\n    input  logic [E203_XLEN-1:0]   agu_i_rs1,\n    input  logic [E203_XLEN-1:0]   agu_i_rs2,\n    input  logic [E203_XLEN-1:0]   agu_i_imm,\n    input  logic [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input  logic [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output logic                   agu_i_longpipe,\n    input  logic                   flush_req,\n    input  logic                   flush_pulse,\n    output logic                   amo_wait,\n    input  logic                   oitf_empty,\n    output logic                   agu_o_valid,\n    input  logic                   agu_o_ready,\n    output logic [E203_XLEN-1:0]   agu_o_wbck_wdat,\n    output logic                   agu_o_wbck_err,\n    output logic                   agu_o_cmt_misalgn,\n    output logic                   agu_o_cmt_ld,\n    output logic                   agu_o_cmt_stamo,\n    output logic                   agu_o_cmt_buserr,\n    output logic [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output logic                   agu_icb_cmd_valid,\n    input  logic                   agu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output logic                   agu_icb_cmd_read,\n    output logic [E203_XLEN-1:0]   agu_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output logic                   agu_icb_cmd_back2agu,\n    output logic                   agu_icb_cmd_lock,\n    output logic                   agu_icb_cmd_excl,\n    output logic [1:0]             agu_icb_cmd_size,\n    output logic [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output logic                   agu_icb_cmd_usign,\n    input  logic                   agu_icb_rsp_valid,\n    output logic                   agu_icb_rsp_ready,\n    input  logic                   agu_icb_rsp_err,\n    input  logic                   agu_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0]   agu_icb_rsp_rdata,\n    output logic [E203_XLEN-1:0]   agu_req_alu_op1,\n    output logic [E203_XLEN-1:0]   agu_req_alu_op2,\n    output logic                   agu_req_alu_swap,\n    output logic                   agu_req_alu_add,\n    output logic                   agu_req_alu_and,\n    output logic                   agu_req_alu_or,\n    output logic                   agu_req_alu_xor,\n    output logic                   agu_req_alu_max,\n    output logic                   agu_req_alu_min,\n    output logic                   agu_req_alu_maxu,\n    output logic                   agu_req_alu_minu,\n    input  logic [E203_XLEN-1:0]   agu_req_alu_res,\n    output logic                   agu_sbf_0_ena,\n    output logic [E203_XLEN-1:0]   agu_sbf_0_nxt,\n    input  logic [E203_XLEN-1:0]   agu_sbf_0_r,\n    output logic                   agu_sbf_1_ena,\n    output logic [E203_XLEN-1:0]   agu_sbf_1_nxt,\n    input  logic [E203_XLEN-1:0]   agu_sbf_1_r,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n// ...\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 5, "code": "module e203_srams #(\n    parameter E203_HAS_ITCM = 1,\n    parameter E203_HAS_DTCM = 1,\n    parameter E203_ITCM_RAM_AW = 10,\n    parameter E203_ITCM_RAM_DW = 32,\n    parameter E203_DTCM_RAM_AW = 10,\n    parameter E203_DTCM_RAM_DW = 32\n) (\n    input  logic                        itcm_ram_sd,\n    input  logic                        itcm_ram_ds,\n    input  logic                        itcm_ram_ls,\n    input  logic                        itcm_ram_cs,\n    input  logic                        itcm_ram_we,\n    input  logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    input  logic [E203_ITCM_RAM_DW/8-1:0] itcm_ram_wem,\n    input  logic [E203_ITCM_RAM_DW-1:0]  itcm_ram_din,\n    output logic [E203_ITCM_RAM_DW-1:0]  itcm_ram_dout,\n    input  logic                        clk_itcm_ram,\n    input  logic                        rst_itcm,\n\n    input  logic                        dtcm_ram_sd,\n    input  logic                        dtcm_ram_ds,\n    input  logic                        dtcm_ram_ls,\n    input  logic                        dtcm_ram_cs,\n    input  logic                        dtcm_ram_we,\n    input  logic [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    input  logic [E203_DTCM_RAM_DW/8-1:0] dtcm_ram_wem,\n    input  logic [E203_DTCM_RAM_DW-1:0]  dtcm_ram_din,\n    output logic [E203_DTCM_RAM_DW-1:0]  dtcm_ram_dout,\n    input  logic                        clk_dtcm_ram,\n    input  logic                        rst_dtcm\n);\n\n    logic [E203_ITCM_RAM_DW-1:0] itcm_ram [2**E203_ITCM_RAM_AW-1:0];\n    logic [E203_DTCM_RAM_DW-1:0] dtcm_ram [2**E203_DTCM_RAM_AW-1:0];\n\n    always_ff @(posedge clk_itcm_ram or posedge rst_itcm) begin\n        if (rst_itcm) begin\n            for (int i = 0; i < 2**E203_ITCM_RAM_AW; i++) begin\n                itcm_ram[i] <= '0;\n            end\n        end else if (itcm_ram_cs && itcm_ram_we) begin\n            for (int i = 0; i < E203_ITCM_RAM_DW/8; i++) begin\n                if (itcm_ram_wem[i]) begin\n                    itcm_ram[itcm_ram_addr][i*8 +: 8] <= itcm_ram_din[i*8 +: 8];\n                end\n            end\n        end\n    end\n\n    always_ff @(posedge clk_dtcm_ram or posedge rst_dtcm) begin\n        if (rst_dtcm) begin\n            for (int i = 0; i < 2**E203_DTCM_RAM_AW; i++) begin\n                dtcm_ram[i] <= '0;\n            end\n        end else if (dtcm_ram_cs && dtcm_ram_we) begin\n            for (int i = 0; i < E203_DTCM_RAM_DW/8; i++) begin\n                if (dtcm_ram_wem[i]) begin\n                    dtcm_ram[dtcm_ram_addr][i*8 +: 8] <= dtcm_ram_din[i*8 +: 8];\n                end\n            end\n        end\n    end\n\n    always_comb begin\n        itcm_ram_dout = itcm_ram[itcm_ram_addr];\n        dtcm_ram_dout = dtcm_ram[dtcm_ram_addr];\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 2, "code": "module e203_exu_alu_rglr (\n    input  logic                    alu_i_valid,\n    output logic                    alu_i_ready,\n    input  logic [E203_XLEN-1:0]    alu_i_rs1,\n    input  logic [E203_XLEN-1:0]    alu_i_rs2,\n    input  logic [E203_XLEN-1:0]    alu_i_imm,\n    input  logic [E203_PC_SIZE-1:0] alu_i_pc,\n    input  logic [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    output logic                    alu_o_valid,\n    input  logic                    alu_o_ready,\n    output logic [E203_XLEN-1:0]    alu_o_wbck_wdat,\n    output logic                    alu_o_wbck_err,\n    output logic                    alu_o_cmt_ecall,\n    output logic                    alu_o_cmt_ebreak,\n    output logic                    alu_o_cmt_wfi,\n    output logic                    alu_req_alu_add,\n    output logic                    alu_req_alu_sub,\n    output logic                    alu_req_alu_xor,\n    output logic                    alu_req_alu_sll,\n    output logic                    alu_req_alu_srl,\n    output logic                    alu_req_alu_sra,\n    output logic                    alu_req_alu_or,\n    output logic                    alu_req_alu_and,\n    output logic                    alu_req_alu_slt,\n    output logic                    alu_req_alu_sltu,\n    output logic                    alu_req_alu_lui,\n    output logic [E203_XLEN-1:0]    alu_req_alu_op1,\n    output logic [E203_XLEN-1:0]    alu_req_alu_op2,\n    output logic [E203_XLEN-1:0]    alu_req_alu_res,\n    input  logic                    clk,\n    input  logic                    rst_n\n);\n\n    // valid-ready handshake\n    assign alu_i_ready = alu_o_ready;\n    assign alu_o_valid = alu_i_valid;\n\n    // operation type\n    assign alu_req_alu_add  = alu_i_info[E203_DECINFO_ALU_ADD];\n    assign alu_req_alu_sub  = alu_i_info[E203_DECINFO_ALU_SUB];\n    assign alu_req_alu_xor  = alu_i_info[E203_DECINFO_ALU_XOR];\n    assign alu_req_alu_sll  = alu_i_info[E203_DECINFO_ALU_SLL];\n    assign alu_req_alu_srl  = alu_i_info[E203_DECINFO_ALU_SRL];\n    assign alu_req_alu_sra  = alu_i_info[E203_DECINFO_ALU_SRA];\n    assign alu_req_alu_or   = alu_i_info[E203_DECINFO_ALU_OR];\n    assign alu_req_alu_and  = alu_i_info[E203_DECINFO_ALU_AND];\n    assign alu_req_alu_slt  = alu_i_info[E203_DECINFO_ALU_SLT];\n    assign alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n    assign alu_req_alu_lui  = alu_i_info[E203_DECINFO_ALU_LUI];\n\n    // source operand\n    assign alu_req_alu_op1 = (alu_i_info[E203_DECINFO_ALU_OP1PC]) ? alu_i_pc : alu_i_rs1;\n    assign alu_req_alu_op2 = (alu_i_info[E203_DECINFO_ALU_OP2IMM]) ? alu_i_imm : alu_i_rs2;\n\n    // result\n    assign alu_o_wbck_wdat = alu_req_alu_res;\n\n    // special instructions\n    assign alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n    assign alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n    assign alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n\n    // error\n    assign alu_o_wbck_err = (alu_o_cmt_ecall || alu_o_cmt_ebreak || alu_o_cmt_wfi);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 1, "code": "module e203_exu_branchslv(\n    input  logic                   cmt_i_valid,\n    output logic                   cmt_i_ready,\n    input  logic                   cmt_i_rv32,\n    input  logic                   cmt_i_dret,\n    input  logic                   cmt_i_mret,\n    input  logic                   cmt_i_fencei,\n    input  logic                   cmt_i_bjp,\n    input  logic                   cmt_i_bjp_prdt,\n    input  logic                   cmt_i_bjp_rslv,\n    input  logic [E203_PC_SIZE-1:0] cmt_i_pc,\n    input  logic [E203_XLEN-1:0]   cmt_i_imm,\n    input  logic [E203_PC_SIZE-1:0] csr_epc_r,\n    input  logic [E203_PC_SIZE-1:0] csr_dpc_r,\n    input  logic                   nonalu_excpirq_flush_req_raw,\n    input  logic                   brchmis_flush_ack,\n    output logic                   brchmis_flush_req,\n    output logic [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output logic [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output logic [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output logic                   cmt_mret_ena,\n    output logic                   cmt_dret_ena,\n    output logic                   cmt_fencei_ena,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n\n// Flush need generation\nlogic flush_need;\nassign flush_need = (cmt_i_bjp && cmt_i_bjp_prdt != cmt_i_bjp_rslv) || cmt_i_fencei || cmt_i_mret || cmt_i_dret;\n\n// Flush target calculation\nalways_comb begin\n    case (1'b1)\n        cmt_i_dret: brchmis_flush_pc = csr_dpc_r;\n        cmt_i_mret: brchmis_flush_pc = csr_epc_r;\n        cmt_i_bjp && cmt_i_bjp_prdt && !cmt_i_bjp_rslv: brchmis_flush_pc = cmt_i_pc + (cmt_i_rv32 ? 4 : 2);\n        cmt_i_bjp && !cmt_i_bjp_prdt && cmt_i_bjp_rslv: brchmis_flush_pc = cmt_i_pc + cmt_i_imm;\n        default: brchmis_flush_pc = csr_epc_r;\n    endcase\nend\n\n// Pipeline flush control\nassign brchmis_flush_req = flush_need && cmt_i_valid && !nonalu_excpirq_flush_req_raw;\n\n// Prioritizing flush sources\nassign cmt_i_ready = !(cmt_i_bjp || cmt_i_fencei || cmt_i_mret || cmt_i_dret) || (!nonalu_excpirq_flush_req_raw && !flush_need) || (!nonalu_excpirq_flush_req_raw && brchmis_flush_ack);\n\n// Special signal commit\nassign cmt_mret_ena = cmt_i_mret && brchmis_flush_req && brchmis_flush_ack;\nassign cmt_dret_ena = cmt_i_dret && brchmis_flush_req && brchmis_flush_ack;\nassign cmt_fencei_ena = cmt_i_fencei && brchmis_flush_req && brchmis_flush_ack;\n\n// Detailed brchmis_flush_pc calculation logic\nalways_comb begin\n    if (E203_TIMING_BOOST) begin\n        case (1'b1)\n            cmt_i_fencei || (cmt_i_bjp && cmt_i_bjp_prdt && !cmt_i_bjp_rslv): brchmis_flush_pc = cmt_i_pc + (cmt_i_rv32 ? 4 : 2);\n            cmt_i_bjp && !cmt_i_bjp_prdt && cmt_i_bjp_rslv: brchmis_flush_pc = cmt_i_pc + cmt_i_imm;\n            cmt_i_dret: brchmis_flush_pc = csr_dpc_r;\n            default: brchmis_flush_pc = csr_epc_r;\n        endcase\n    end else begin\n        // default case\n        brchmis_flush_pc = csr_epc_r;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 4, "code": "module e203_ifu_litebpu(\n    input  logic                   clk,\n    input  logic                   rst_n,\n    input  logic [E203_PC_SIZE-1:0] pc,\n    input  logic                   dec_jal,\n    input  logic                   dec_jalr,\n    input  logic                   dec_bxx,\n    input  logic [E203_XLEN-1:0]   dec_bjp_imm,\n    input  logic [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    input  logic                   oitf_empty,\n    input  logic                   ir_empty,\n    input  logic                   ir_rs1en,\n    input  logic                   jalr_rs1idx_cam_irrdidx,\n    input  logic                   dec_i_valid,\n    input  logic                   ir_valid_clr,\n    input  logic [E203_XLEN-1:0]   rf2bpu_x1,\n    input  logic [E203_XLEN-1:0]   rf2bpu_rs1,\n    output logic                   prdt_taken,\n    output logic [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n    output logic [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n    output logic                   bpu_wait,\n    output logic                   bpu2rf_rs1_ena\n);\n\nlogic [E203_PC_SIZE-1:0] pc_add_op1;\nlogic [E203_PC_SIZE-1:0] pc_add_op2;\nlogic rs1xn_rdrf_r;\nlogic rs1xn_rdrf_nxt;\nlogic jalr_rs1xn_dep;\nlogic jalr_rs1xn_dep_ir_clr;\n\n// Static branch prediction strategy\nalways_comb begin\n    prdt_taken = 1'b0;\n    pc_add_op1 = '0;\n    pc_add_op2 = '0;\n    bpu_wait = 1'b0;\n    bpu2rf_rs1_ena = 1'b0;\n\n    if (dec_jal || dec_jalr) begin\n        prdt_taken = 1'b1;\n    end else if (dec_bxx && dec_bjp_imm[E203_XLEN-1] == 1'b0) begin\n        prdt_taken = 1'b1;\n    end\n\n    if (dec_jal || dec_bxx) begin\n        pc_add_op1 = pc;\n    end else if (dec_jalr) begin\n        if (dec_jalr_rs1idx == '0) begin\n            pc_add_op1 = '0;\n        end else if (dec_jalr_rs1idx == 5'd1) begin\n            pc_add_op1 = rf2bpu_x1;\n        end else begin\n            pc_add_op1 = rf2bpu_rs1;\n        end\n    end\n\n    pc_add_op2 = dec_bjp_imm[E203_PC_SIZE-1:0];\n\n    if (dec_jalr && dec_jalr_rs1idx != '0 && dec_jalr_rs1idx != 5'd1) begin\n        if (!oitf_empty || !ir_empty || jalr_rs1idx_cam_irrdidx) begin\n            bpu_wait = 1'b1;\n        end\n        bpu2rf_rs1_ena = 1'b1;\n    end\nend\n\n// rs1xn_rdrf state machine\nalways_comb begin\n    rs1xn_rdrf_nxt = rs1xn_rdrf_r;\n    if (dec_jalr && dec_jalr_rs1idx != '0 && dec_jalr_rs1idx != 5'd1 && !rs1xn_rdrf_r && dec_i_valid && !ir_valid_clr) begin\n        rs1xn_rdrf_nxt = 1'b1;\n    end else if (rs1xn_rdrf_r && (ir_valid_clr || !dec_i_valid)) begin\n        rs1xn_rdrf_nxt = 1'b0;\n    end\nend\n\nsirv_gnrl_dfflr #(\n    .DW(E203_XLEN)\n) u_rs1xn_rdrf_dff(\n    .clk(clk),\n    .rst_n(rst_n),\n    .lden(1'b1),\n    .dnxt(rs1xn_rdrf_nxt),\n    .qout(rs1xn_rdrf_r)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 5, "code": "module e203_ifu_litebpu #(\n    parameter E203_PC_SIZE = 32,\n    parameter E203_XLEN = 32,\n    parameter E203_RFIDX_WIDTH = 5\n) (\n    input  logic                   clk,\n    input  logic                   rst_n,\n    input  logic [E203_PC_SIZE-1:0] pc,\n    input  logic                   dec_jal,\n    input  logic                   dec_jalr,\n    input  logic                   dec_bxx,\n    input  logic [E203_XLEN-1:0]   dec_bjp_imm,\n    input  logic [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    input  logic                   oitf_empty,\n    input  logic                   ir_empty,\n    input  logic                   ir_rs1en,\n    input  logic                   jalr_rs1idx_cam_irrdidx,\n    input  logic                   dec_i_valid,\n    input  logic                   ir_valid_clr,\n    input  logic [E203_XLEN-1:0]   rf2bpu_x1,\n    input  logic [E203_XLEN-1:0]   rf2bpu_rs1,\n    output logic                   prdt_taken,\n    output logic [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n    output logic [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n    output logic                   bpu_wait,\n    output logic                   bpu2rf_rs1_ena\n);\n\nlogic [E203_RFIDX_WIDTH-1:0] rs1xn_rdrf_r;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        rs1xn_rdrf_r <= '0;\n    end else begin\n        rs1xn_rdrf_r <= rs1xn_rdrf_nxt;\n    end\nend\n\nlogic rs1xn_rdrf_nxt;\nlogic rs1xn_rdrf_set;\nlogic rs1xn_rdrf_clr;\n\nassign rs1xn_rdrf_nxt = rs1xn_rdrf_set | (~rs1xn_rdrf_clr);\n\nassign rs1xn_rdrf_set = (~rs1xn_rdrf_r) & dec_i_valid & dec_jalr & (~dec_jalr_rs1idx_cam_irrdidx) & (~ir_valid_clr) & (|dec_jalr_rs1idx);\n\nassign rs1xn_rdrf_clr = rs1xn_rdrf_r & (oitf_empty | ir_empty | ir_rs1en | jalr_rs1idx_cam_irrdidx | ir_valid_clr);\n\nassign prdt_taken = dec_jal | dec_jalr | (dec_bxx & dec_bjp_imm[E203_XLEN-1]);\n\nalways_comb begin\n    case ({dec_jal, dec_jalr, dec_bxx})\n        3'b100: begin\n            prdt_pc_add_op1 = pc;\n            prdt_pc_add_op2 = {E203_PC_SIZE{1'b0}};\n        end\n        3'b010: begin\n            if (dec_jalr_rs1idx == 5'd0) begin\n                prdt_pc_add_op1 = '0;\n            end else if (dec_jalr_rs1idx == 5'd1) begin\n                prdt_pc_add_op1 = rf2bpu_x1;\n            end else begin\n                prdt_pc_add_op1 = rf2bpu_rs1;\n            end\n            prdt_pc_add_op2 = dec_bjp_imm;\n        end\n        3'b001: begin\n            prdt_pc_add_op1 = pc;\n            prdt_pc_add_op2 = dec_bjp_imm;\n        end\n        default: begin\n            prdt_pc_add_op1 = '0;\n            prdt_pc_add_op2 = '0;\n        end\n    endcase\nend\n\nassign bpu_wait = rs1xn_rdrf_r;\n\nassign bpu2rf_rs1_ena = rs1xn_rdrf_set;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 6, "code": "// Import necessary files\n`include \"e203_defines.v\"\n\n// Module declaration\nmodule e203_srams(\n    // ITCM RAM Interface\n    input  logic                       itcm_ram_sd,      // ITCM power off enable signal\n    input  logic                       itcm_ram_ds,      // ITCM deep sleep mode enable\n    input  logic                       itcm_ram_ls,      // ITCM light sleep mode enable\n    input  logic                       itcm_ram_cs,      // ITCM chip select signal\n    input  logic                       itcm_ram_we,      // ITCM write enable signal\n    input  logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,   // ITCM address\n    input  logic [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,    // ITCM write mask\n    input  logic [E203_ITCM_RAM_DW-1:0] itcm_ram_din,    // ITCM write data\n    output logic [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,   // ITCM read data\n    input  logic                       clk_itcm_ram,     // ITCM clock signal\n    input  logic                       rst_itcm,         // ITCM reset signal\n\n    // DTCM RAM Interface (similar to ITCM, with signal name prefix changed to dtcm)\n    input  logic                       dtcm_ram_sd,      // DTCM power off enable signal\n    input  logic                       dtcm_ram_ds,      // DTCM deep sleep mode enable\n    input  logic                       dtcm_ram_ls,      // DTCM light sleep mode enable\n    input  logic                       dtcm_ram_cs,      // DTCM chip select signal\n    input  logic                       dtcm_ram_we,      // DTCM write enable signal\n    input  logic [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,   // DTCM address\n    input  logic [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,    // DTCM write mask\n    input  logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,    // DTCM write data\n    output logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout    // DTCM read data\n);\n\n// ITCM RAM implementation\nlogic [E203_ITCM_RAM_DW-1:0] itcm_ram_reg [E203_ITCM_RAM_DP-1:0];\n\nalways_ff @(posedge clk_itcm_ram or negedge rst_itcm) begin\n    if (~rst_itcm) begin\n        for (int i = 0; i < E203_ITCM_RAM_DP; i++) begin\n            itcm_ram_reg[i] <= '0;\n        end\n    end else if (itcm_ram_cs && itcm_ram_we) begin\n        itcm_ram_reg[itcm_ram_addr] <= itcm_ram_din;\n    end\nend\n\nassign itcm_ram_dout = itcm_ram_reg[itcm_ram_addr];\n\n// DTCM RAM implementation\nlogic [E203_DTCM_RAM_DW-1:0] dtcm_ram_reg [E203_DTCM_RAM_DP-1:0];\n\nalways_ff @(posedge clk_dtcm_ram or negedge rst_dtcm) begin\n    if (~rst_dtcm) begin\n        for (int i = 0; i < E203_DTCM_RAM_DP; i++) begin\n            dtcm_ram_reg[i] <= '0;\n        end\n    end else if (dtcm_ram_cs && dtcm_ram_we) begin\n        dtcm_ram_reg[dtcm_ram_addr] <= dtcm_ram_din;\n    end\nend\n\nassign dtcm_ram_dout = dtcm_ram_reg[dtcm_ram_addr];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 3, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_alu_rglr(\n    input  logic                               alu_i_valid,\n    output logic                               alu_i_ready,\n    input  logic [E203_XLEN-1:0]               alu_i_rs1,\n    input  logic [E203_XLEN-1:0]               alu_i_rs2,\n    input  logic [E203_XLEN-1:0]               alu_i_imm,\n    input  logic [E203_PC_SIZE-1:0]            alu_i_pc,\n    input  logic [E203_DECINFO_ALU_WIDTH-1:0]  alu_i_info,\n    output logic                               alu_o_valid,\n    input  logic                               alu_o_ready,\n    output logic [E203_XLEN-1:0]               alu_o_wbck_wdat,\n    output logic                               alu_o_wbck_err,\n    output logic                               alu_o_cmt_ecall,\n    output logic                               alu_o_cmt_ebreak,\n    output logic                               alu_o_cmt_wfi,\n    output logic                               alu_req_alu_add,\n    output logic                               alu_req_alu_sub,\n    output logic                               alu_req_alu_xor,\n    output logic                               alu_req_alu_sll,\n    output logic                               alu_req_alu_srl,\n    output logic                               alu_req_alu_sra,\n    output logic                               alu_req_alu_or,\n    output logic                               alu_req_alu_and,\n    output logic                               alu_req_alu_slt,\n    output logic                               alu_req_alu_sltu,\n    output logic                               alu_req_alu_lui,\n    output logic [E203_XLEN-1:0]               alu_req_alu_op1,\n    output logic [E203_XLEN-1:0]               alu_req_alu_op2,\n    output logic [E203_XLEN-1:0]               alu_req_alu_res,\n    input  logic                               clk,\n    input  logic                               rst_n\n);\n\n    // valid-ready handshake\n    assign alu_i_ready = alu_o_ready;\n    assign alu_o_valid = alu_i_valid;\n\n    // operation type\n    assign alu_req_alu_add  = alu_i_info[E203_DECINFO_ALU_ADD];\n    assign alu_req_alu_sub  = alu_i_info[E203_DECINFO_ALU_SUB];\n    assign alu_req_alu_xor  = alu_i_info[E203_DECINFO_ALU_XOR];\n    assign alu_req_alu_sll  = alu_i_info[E203_DECINFO_ALU_SLL];\n    assign alu_req_alu_srl  = alu_i_info[E203_DECINFO_ALU_SRL];\n    assign alu_req_alu_sra  = alu_i_info[E203_DECINFO_ALU_SRA];\n    assign alu_req_alu_or   = alu_i_info[E203_DECINFO_ALU_OR];\n    assign alu_req_alu_and  = alu_i_info[E203_DECINFO_ALU_AND];\n    assign alu_req_alu_slt  = alu_i_info[E203_DECINFO_ALU_SLT];\n    assign alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n    assign alu_req_alu_lui  = alu_i_info[E203_DECINFO_ALU_LUI];\n\n    // source operand\n    assign alu_req_alu_op1 = (alu_i_info[E203_DECINFO_ALU_OP1PC]) ? alu_i_pc : alu_i_rs1;\n    assign alu_req_alu_op2 = (alu_i_info[E203_DECINFO_ALU_OP2IMM]) ? alu_i_imm : alu_i_rs2;\n\n    // result\n    assign alu_o_wbck_wdat = alu_req_alu_res;\n\n    // special instructions\n    assign alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n    assign alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n    assign alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n\n    // error handling\n    assign alu_o_wbck_err = (alu_o_cmt_ecall || alu_o_cmt_ebreak || alu_o_cmt_wfi);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 6, "code": "module e203_cpu_top(\n    // Outputs\n    output inspect_pc,\n    output inspect_dbg_irq,\n    output inspect_mem_cmd_valid,\n    output inspect_mem_cmd_ready,\n    output inspect_mem_rsp_valid,\n    output inspect_mem_rsp_ready,\n    output inspect_core_clk,\n    output core_csr_clk,\n    output core_wfi,\n    output tm_stop,\n    output dbg_irq_r,\n\n    // Inputs\n    input pc_rtvec,\n    input ext_irq_a,\n    input sft_irq_a,\n    input tmr_irq_a,\n    input tcm_sd,\n    input tcm_ds,\n    input ext2itcm_icb_cmd_valid,\n    input ext2itcm_icb_cmd_ready,\n    input ext2itcm_icb_cmd_addr,\n    input ext2itcm_icb_cmd_read,\n    input ext2itcm_icb_cmd_wdata,\n    input ext2itcm_icb_cmd_wmask,\n    input ext2itcm_icb_rsp_valid,\n    input ext2itcm_icb_rsp_ready,\n    input ext2itcm_icb_rsp_err,\n    input ext2itcm_icb_rsp_rdata,\n    input clk,\n    input rst_n\n);\n\n// Internal signals and variables\nwire e203_cpu_inspect_pc;\nwire e203_cpu_inspect_dbg_irq;\nwire e203_cpu_inspect_mem_cmd_valid;\nwire e203_cpu_inspect_mem_cmd_ready;\nwire e203_cpu_inspect_mem_rsp_valid;\nwire e203_cpu_inspect_mem_rsp_ready;\nwire e203_cpu_core_clk;\nwire e203_cpu_core_csr_clk;\nwire e203_cpu_core_wfi;\nwire e203_cpu_tm_stop;\nwire e203_cpu_dbg_irq_r;\n\n// Instantiate the e203_cpu module\ne203_cpu e203_cpu_inst(\n    .inspect_pc(e203_cpu_inspect_pc),\n    .inspect_dbg_irq(e203_cpu_inspect_dbg_irq),\n    .inspect_mem_cmd_valid(e203_cpu_inspect_mem_cmd_valid),\n    .inspect_mem_cmd_ready(e203_cpu_inspect_mem_cmd_ready),\n    .inspect_mem_rsp_valid(e203_cpu_inspect_mem_rsp_valid),\n    .inspect_mem_rsp_ready(e203_cpu_inspect_mem_rsp_ready),\n    .core_clk(e203_cpu_core_clk),\n    .core_csr_clk(e203_cpu_core_csr_clk),\n    .core_wfi(e203_cpu_core_wfi),\n    .tm_stop(e203_cpu_tm_stop),\n    .dbg_irq_r(e203_cpu_dbg_irq_r),\n\n    .pc_rtvec(pc_rtvec),\n    .ext_irq_a(ext_irq_a),\n    .sft_irq_a(sft_irq_a),\n    .tmr_irq_a(tmr_irq_a),\n    .tcm_sd(tcm_sd),\n    .tcm_ds(tcm_ds),\n    .ext2itcm_icb_cmd_valid(ext2itcm_icb_cmd_valid),\n    .ext2itcm_icb_cmd_ready(ext2itcm_icb_cmd_ready),\n    .ext2itcm_icb_cmd_addr(ext2itcm_icb_cmd_addr),\n    .ext2itcm_icb_cmd_read(ext2itcm_icb_cmd_read),\n    .ext2itcm_icb_cmd_wdata(ext2itcm_icb_cmd_wdata),\n    .ext2itcm_icb_cmd_wmask(ext2itcm_icb_cmd_wmask),\n    .ext2itcm_icb_rsp_valid(ext2itcm_icb_rsp_valid),\n    .ext2itcm_icb_rsp_ready(ext2itcm_icb_rsp_ready),\n    .ext2itcm_icb_rsp_err(ext2itcm_icb_rsp_err),\n    .ext2itcm_icb_rsp_rdata(ext2itcm_icb_rsp_rdata),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Assign internal signals to output ports\nassign inspect_pc = e203_cpu_inspect_pc;\nassign inspect_dbg_irq = e203_cpu_inspect_dbg_irq;\nassign inspect_mem_cmd_valid = e203_cpu_inspect_mem_cmd_valid;\nassign inspect_mem_cmd_ready = e203_cpu_inspect_mem_cmd_ready;\nassign inspect_mem_rsp_valid = e203_cpu_inspect_mem_rsp_valid;\nassign inspect_mem_rsp_ready = e203_cpu_inspect_mem_rsp_ready;\nassign inspect_core_clk = e203_cpu_core_clk;\nassign core_csr_clk = e203_cpu_core_csr_clk;\nassign core_wfi = e203_cpu_core_wfi;\nassign tm_stop = e203_cpu_tm_stop;\nassign dbg_irq_r = e203_cpu_dbg_irq_r;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 4, "code": "module e203_exu_nice(\n    input  logic                               nice_i_xs_off,\n    input  logic                               nice_i_valid,\n    output logic                               nice_i_ready,\n    input  logic [E203_XLEN-1:0]               nice_i_instr,\n    input  logic [E203_XLEN-1:0]               nice_i_rs1,\n    input  logic [E203_XLEN-1:0]               nice_i_rs2,\n    input  logic [E203_ITAG_WIDTH-1:0]         nice_i_itag,\n    output logic                               nice_o_longpipe,\n    output logic                               nice_o_valid,\n    input  logic                               nice_o_ready,\n    output logic                               nice_o_itag_valid,\n    input  logic                               nice_o_itag_ready,\n    output logic [E203_ITAG_WIDTH-1:0]         nice_o_itag,\n    input  logic                               nice_rsp_multicyc_valid,\n    output logic                               nice_rsp_multicyc_ready,\n    output logic                               nice_req_valid,\n    input  logic                               nice_req_ready,\n    output logic [E203_XLEN-1:0]               nice_req_instr,\n    output logic [E203_XLEN-1:0]               nice_req_rs1,\n    output logic [E203_XLEN-1:0]               nice_req_rs2,\n    input  logic                               clk,\n    input  logic                               rst_n\n);\n\n// Internal signals and variables\nlogic [E203_ITAG_WIDTH-1:0] itag_fifo [3:0];\nlogic [2:0] itag_fifo_ptr;\nlogic itag_fifo_full;\nlogic itag_fifo_empty;\n\n// Instruction forwarding and handshaking protocol\nalways @(posedge clk) begin\n    if (~rst_n) begin\n        nice_i_ready <= 1'b0;\n        nice_req_valid <= 1'b0;\n    end else begin\n        if (nice_i_valid && ~nice_i_xs_off) begin\n            nice_i_ready <= nice_req_ready;\n            if (nice_req_ready) begin\n                nice_req_valid <= 1'b1;\n                nice_req_instr <= nice_i_instr;\n                nice_req_rs1 <= nice_i_rs1;\n                nice_req_rs2 <= nice_i_rs2;\n            end\n        end else begin\n            nice_i_ready <= 1'b0;\n            nice_req_valid <= 1'b0;\n        end\n    end\nend\n\n// Multi-cycle operation support and instruction tag handling\nalways @(posedge clk) begin\n    if (~rst_n) begin\n        itag_fifo_ptr <= 3'b0;\n        itag_fifo_full <= 1'b0;\n        itag_fifo_empty <= 1'b1;\n    end else begin\n        if (nice_rsp_multicyc_valid && ~itag_fifo_empty) begin\n            itag_fifo_ptr <= itag_fifo_ptr - 1'b1;\n            itag_fifo_full <= 1'b0;\n            itag_fifo_empty <= (itag_fifo_ptr == 3'b0);\n        end else if (nice_i_valid && ~nice_i_xs_off && ~itag_fifo_full) begin\n            itag_fifo[itag_fifo_ptr] <= nice_i_itag;\n            itag_fifo_ptr <= itag_fifo_ptr + 1'b1;\n            itag_fifo_full <= (itag_fifo_ptr == 3'b111);\n            itag_fifo_empty <= 1'b0;\n        end\n    end\nend\n\n// Long pipeline handling\nassign nice_o_longpipe = ~nice_i_xs_off;\n\n// Commit interface and instruction tag writeback\nalways @(posedge clk) begin\n    if (~rst_n) begin\n        nice_o_valid <= 1'b0;\n        nice_o_itag_valid <= 1'b0;\n    end else begin\n        if (nice_o_ready && ~nice_i_xs_off) begin\n            nice_o_valid <= 1'b1;\n            if (~itag_fifo_empty) begin\n                nice_o_itag_valid <= 1'b1;\n                nice_o_itag <= itag_fifo[0];\n            end\n        end else begin\n            nice_o_valid <= 1'b0;\n            nice_o_itag_valid <= 1'b0;\n        end\n    end\nend\n\n// FIFO control signals\nassign nice_rsp_multicyc_ready = ~itag_fifo_empty;\nassign nice_o_itag_ready = ~itag_fifo_full;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 7, "code": "module e203_cpu_top #(\n    parameter E203_CFG_ADDR_SIZE_IS_32 = 1,\n    parameter E203_CFG_HAS_ITCM = 1,\n    parameter E203_CFG_HAS_DTCM = 1,\n    parameter E203_CFG_HAS_NICE = 1,\n    parameter E203_CFG_SUPPORT_SHARE_MULDIV = 1,\n    parameter E203_CFG_SUPPORT_AMO = 1,\n    parameter E203_CFG_DEBUG_HAS_JTAG = 1,\n    parameter E203_CFG_IRQ_NEED_SYNC = 1\n) (\n    input  logic                        clk,\n    input  logic                        rst_n,\n\n    // ITCM Interface\n    output logic                        itcm_ram_cs,\n    output logic                        itcm_ram_we,\n    output logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    output logic [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    output logic [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    input  logic [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n\n    // DTCM Interface\n    output logic                        dtcm_ram_cs,\n    output logic                        dtcm_ram_we,\n    output logic [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output logic [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input  logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n\n    // External Interrupts\n    input  logic                        ext_irq_a,\n    input  logic                        sft_irq_a,\n    input  logic                        tmr_irq_a,\n\n    // Debug Interface\n    output logic                        dbg_irq_r,\n    input  logic                        dbg_mode,\n    input  logic                        dbg_halt_r,\n    input  logic                        dbg_step_r,\n    input  logic                        dbg_ebreakm_r,\n    input  logic                        dbg_stopcycle\n);\n\n    // Internal Signals\n    logic [E203_PC_SIZE-1:0]            pc;\n    logic                               core_wfi;\n    logic                               tm_stop;\n\n    // Instantiate e203_cpu Module\n    e203_cpu #(\n        .E203_CFG_ADDR_SIZE_IS_32      (E203_CFG_ADDR_SIZE_IS_32),\n        .E203_CFG_HAS_ITCM             (E203_CFG_HAS_ITCM),\n        .E203_CFG_HAS_DTCM             (E203_CFG_HAS_DTCM),\n        .E203_CFG_HAS_NICE             (E203_CFG_HAS_NICE),\n        .E203_CFG_SUPPORT_SHARE_MULDIV (E203_CFG_SUPPORT_SHARE_MULDIV),\n        .E203_CFG_SUPPORT_AMO          (E203_CFG_SUPPORT_AMO)\n    ) u_e203_cpu (\n        .clk                           (clk),\n        .rst_n                         (rst_n),\n\n        .itcm_ram_cs                   (itcm_ram_cs),\n        .itcm_ram_we                   (itcm_ram_we),\n        .itcm_ram_addr                 (itcm_ram_addr),\n        .itcm_ram_wem                  (itcm_ram_wem),\n        .itcm_ram_din                  (itcm_ram_din),\n        .itcm_ram_dout                 (itcm_ram_dout),\n\n        .dtcm_ram_cs                   (dtcm_ram_cs),\n        .dtcm_ram_we                   (dtcm_ram_we),\n        .dtcm_ram_addr                 (dtcm_ram_addr),\n        .dtcm_ram_wem                  (dtcm_ram_wem),\n        .dtcm_ram_din                  (dtcm_ram_din),\n        .dtcm_ram_dout                 (dtcm_ram_dout),\n\n        .ext_irq_a                     (ext_irq_a),\n        .sft_irq_a                     (sft_irq_a),\n        .tmr_irq_a                     (tmr_irq_a),\n\n        .dbg_irq_r                     (dbg_irq_r),\n        .dbg_mode                      (dbg_mode),\n        .dbg_halt_r                    (dbg_halt_r),\n        .dbg_step_r                    (dbg_step_r),\n        .dbg_ebreakm_r                 (dbg_ebreakm_r),\n        .dbg_stopcycle                 (dbg_stopcycle),\n\n        .pc                            (pc),\n        .core_wfi                      (core_wfi),\n        .tm_stop                       (tm_stop)\n    );\n\n    // Assign Outputs\n    assign inspect_pc          = pc;\n    assign inspect_dbg_irq     = dbg_irq_r;\n    assign inspect_core_clk    = clk;\n    assign core_csr_clk        = clk;\n    assign core_wfi            = core_wfi;\n    assign tm_stop             = tm_stop;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 7, "code": "module e203_srams #(\n    parameter E203_HAS_ITCM = 1,\n    parameter E203_HAS_DTCM = 1,\n    parameter E203_ITCM_RAM_AW = 10,\n    parameter E203_ITCM_RAM_DW = 32,\n    parameter E203_DTCM_RAM_AW = 10,\n    parameter E203_DTCM_RAM_DW = 32\n) (\n    input  logic                        itcm_ram_sd,\n    input  logic                        itcm_ram_ds,\n    input  logic                        itcm_ram_ls,\n    input  logic                        itcm_ram_cs,\n    input  logic                        itcm_ram_we,\n    input  logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    input  logic [E203_ITCM_RAM_DW/8-1:0] itcm_ram_wem,\n    input  logic [E203_ITCM_RAM_DW-1:0]  itcm_ram_din,\n    output logic [E203_ITCM_RAM_DW-1:0]  itcm_ram_dout,\n    input  logic                        clk_itcm_ram,\n    input  logic                        rst_itcm,\n\n    input  logic                        dtcm_ram_sd,\n    input  logic                        dtcm_ram_ds,\n    input  logic                        dtcm_ram_ls,\n    input  logic                        dtcm_ram_cs,\n    input  logic                        dtcm_ram_we,\n    input  logic [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    input  logic [E203_DTCM_RAM_DW/8-1:0] dtcm_ram_wem,\n    input  logic [E203_DTCM_RAM_DW-1:0]  dtcm_ram_din,\n    output logic [E203_DTCM_RAM_DW-1:0]  dtcm_ram_dout,\n    input  logic                        clk_dtcm_ram,\n    input  logic                        rst_dtcm\n);\n\n    // ITCM RAM\n    logic [E203_ITCM_RAM_DW-1:0] itcm_ram [2**E203_ITCM_RAM_AW];\n\n    always_ff @(posedge clk_itcm_ram or negedge rst_itcm) begin\n        if (!rst_itcm) begin\n            for (int i = 0; i < 2**E203_ITCM_RAM_AW; i++) begin\n                itcm_ram[i] <= '0;\n            end\n        end else if (itcm_ram_cs && itcm_ram_we) begin\n            for (int i = 0; i < E203_ITCM_RAM_DW/8; i++) begin\n                if (itcm_ram_wem[i]) begin\n                    itcm_ram[itcm_ram_addr][i*8 +: 8] <= itcm_ram_din[i*8 +: 8];\n                end\n            end\n        end\n    end\n\n    assign itcm_ram_dout = itcm_ram[itcm_ram_addr];\n\n    // DTCM RAM\n    logic [E203_DTCM_RAM_DW-1:0] dtcm_ram [2**E203_DTCM_RAM_AW];\n\n    always_ff @(posedge clk_dtcm_ram or negedge rst_dtcm) begin\n        if (!rst_dtcm) begin\n            for (int i = 0; i < 2**E203_DTCM_RAM_AW; i++) begin\n                dtcm_ram[i] <= '0;\n            end\n        end else if (dtcm_ram_cs && dtcm_ram_we) begin\n            for (int i = 0; i < E203_DTCM_RAM_DW/8; i++) begin\n                if (dtcm_ram_wem[i]) begin\n                    dtcm_ram[dtcm_ram_addr][i*8 +: 8] <= dtcm_ram_din[i*8 +: 8];\n                end\n            end\n        end\n    end\n\n    assign dtcm_ram_dout = dtcm_ram[dtcm_ram_addr];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 3, "code": "module e203_exu_disp(\n    input  logic                        wfi_halt_exu_req,\n    output logic                        wfi_halt_exu_ack,\n    input  logic                        oitf_empty,\n    input  logic                        amo_wait,\n    input  logic                        disp_i_valid,\n    output logic                        disp_i_ready,\n    input  logic                        disp_i_rs1x0,\n    input  logic                        disp_i_rs2x0,\n    input  logic                        disp_i_rs1en,\n    input  logic                        disp_i_rs2en,\n    input  logic [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input  logic [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input  logic [E203_XLEN-1:0]        disp_i_rs1,\n    input  logic [E203_XLEN-1:0]        disp_i_rs2,\n    input  logic                        disp_i_rdwen,\n    input  logic [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input  logic [E203_DECINFO_WIDTH-1:0] disp_i_info,\n    input  logic [E203_XLEN-1:0]        disp_i_imm,\n    input  logic [E203_PC_SIZE-1:0]     disp_i_pc,\n    input  logic                        disp_i_misalgn,\n    input  logic                        disp_i_buserr,\n    input  logic                        disp_i_ilegl,\n    output logic                        disp_o_alu_valid,\n    input  logic                        disp_o_alu_ready,\n    input  logic                        disp_o_alu_longpipe,\n    output logic [E203_XLEN-1:0]        disp_o_alu_rs1,\n    output logic [E203_XLEN-1:0]        disp_o_alu_rs2,\n    output logic                        disp_o_alu_rdwen,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx,\n    output logic [E203_DECINFO_WIDTH-1:0] disp_o_alu_info,\n    output logic [E203_XLEN-1:0]        disp_o_alu_imm,\n    output logic [E203_PC_SIZE-1:0]     disp_o_alu_pc,\n    output logic [E203_ITAG_WIDTH-1:0]  disp_o_alu_itag,\n    output logic                        disp_o_alu_misalgn,\n    output logic                        disp_o_alu_buserr,\n    output logic                        disp_o_alu_ilegl,\n    input  logic                        oitfrd_match_disprs1,\n    input  logic                        oitfrd_match_disprs2,\n    input  logic                        oitfrd_match_disprs3,\n    input  logic                        oitfrd_match_disprd,\n    output logic [E203_ITAG_WIDTH-1:0]  disp_oitf_ptr,\n    output logic                        disp_oitf_ena,\n    input  logic                        disp_oitf_ready,\n    output logic                        disp_oitf_rs1fpu,\n    output logic                        disp_oitf_rs2fpu,\n    output logic                        disp_oitf_rs3fpu,\n    output logic                        disp_oitf_rdfpu,\n    output logic                        disp_oitf_rs1en,\n    output logic                        disp_oitf_rs2en,\n    output logic                        disp_oitf_rs3en,\n    output logic                        disp_oitf_rdwen,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx,\n    output logic [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx,\n    output logic [E203_PC_SIZE-1:0]     disp_oitf_pc,\n    input  logic                        clk,\n    input  logic                        rst_n\n);\n\n// Your implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 5, "code": "module e203_exu_nice(\n    input  logic                        nice_i_xs_off,  // NICE accelerator disable signal\n    input  logic                        nice_i_valid,   // Input instruction valid signal\n    output logic                        nice_i_ready,   // Ready signal to accept input instruction\n    input  logic [E203_XLEN-1:0]        nice_i_instr,   // Input instruction to be executed by NICE\n    input  logic [E203_XLEN-1:0]        nice_i_rs1,     // Input source register 1 value\n    input  logic [E203_XLEN-1:0]        nice_i_rs2,     // Input source register 2 value\n    input  logic [E203_ITAG_WIDTH-1:0]  nice_i_itag,    // Input instruction tag for tracking\n    output logic                        nice_o_longpipe,// Indicates if instruction needs long pipeline handling\n    output logic                        nice_o_valid,   // Valid signal for commit interface\n    input  logic                        nice_o_ready,   // Ready signal from commit interface\n    output logic                        nice_o_itag_valid,// Valid signal for instruction tag writeback\n    input  logic                        nice_o_itag_ready,// Ready signal for instruction tag writeback\n    output logic [E203_ITAG_WIDTH-1:0]  nice_o_itag,    // Instruction tag for writeback\n    input  logic                        nice_rsp_multicyc_valid,// Multi-cycle operation completion signal\n    output logic                        nice_rsp_multicyc_ready,// Ready signal for multi-cycle operation completion\n    output logic                        nice_req_valid, // Valid signal for request to custom accelerator\n    input  logic                        nice_req_ready, // Ready signal from custom accelerator\n    output logic [E203_XLEN-1:0]        nice_req_instr, // Instruction forwarded to custom accelerator\n    output logic [E203_XLEN-1:0]        nice_req_rs1,   // Source register 1 forwarded to custom accelerator\n    output logic [E203_XLEN-1:0]        nice_req_rs2,   // Source register 2 forwarded to custom accelerator\n    input  logic                        clk,            // System clock\n    input  logic                        rst_n           // Active low reset signal\n);\n\n// Internal signals and variables\nlogic [E203_ITAG_WIDTH-1:0] itag_fifo [3:0]; // Instruction tag FIFO\nlogic [2:0] itag_fifo_ptr; // Instruction tag FIFO pointer\nlogic itag_fifo_empty; // Instruction tag FIFO empty signal\nlogic itag_fifo_full; // Instruction tag FIFO full signal\n\n// Instruction forwarding logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        nice_i_ready <= 1'b0;\n        nice_req_valid <= 1'b0;\n        nice_req_instr <= '0;\n        nice_req_rs1 <= '0;\n        nice_req_rs2 <= '0;\n    end else begin\n        if (nice_i_valid && ~nice_i_xs_off) begin\n            nice_i_ready <= 1'b1;\n            nice_req_valid <= 1'b1;\n            nice_req_instr <= nice_i_instr;\n            nice_req_rs1 <= nice_i_rs1;\n            nice_req_rs2 <= nice_i_rs2;\n        end else begin\n            nice_i_ready <= 1'b0;\n            nice_req_valid <= 1'b0;\n        end\n    end\nend\n\n// Handshaking protocol logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        nice_o_valid <= 1'b0;\n        nice_o_itag_valid <= 1'b0;\n        nice_o_itag <= '0;\n    end else begin\n        if (nice_i_valid && nice_o_ready) begin\n            nice_o_valid <= 1'b1;\n            if (itag_fifo_empty) begin\n                nice_o_itag_valid <= 1'b0;\n            end else begin\n                nice_o_itag_valid <= 1'b1;\n                nice_o_itag <= itag_fifo[0];\n            end\n        end else begin\n            nice_o_valid <= 1'b0;\n            nice_o_itag_valid <= 1'b0;\n        end\n    end\nend\n\n// Multi-cycle operation support logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        itag_fifo_ptr <= '0;\n        itag_fifo_empty <= 1'b1;\n        itag_fifo_full <= 1'b0;\n    end else begin\n        if (nice_rsp_multicyc_valid) begin\n            if (~itag_fifo_empty) begin\n                itag_fifo_ptr <= itag_fifo_ptr - 1;\n                if (itag_fifo_ptr == '0) begin\n                    itag_fifo_empty <= 1'b1;\n                end\n            end\n        end else if (nice_i_valid && ~nice_i_xs_off) begin\n            if (~itag_fifo_full) begin\n                itag_fifo[itag_fifo_ptr] <= nice_i_itag;\n                itag_fifo_ptr <= itag_fifo_ptr + 1;\n                if (itag_fifo_ptr == 4) begin\n                    itag_fifo_full <= 1'b1;\n                end\n            end\n        end\n    end\nend\n\n// Long pipeline handling logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        nice_o_longpipe <= 1'b0;\n    end else begin\n        if (nice_i_valid && ~nice_i_xs_off) begin\n            nice_o_longpipe <= 1'b1;\n        end else begin\n            nice_o_longpipe <= 1'b0;\n        end\n    end\nend\n\n// FIFO logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        itag_fifo <= '0;\n    end else begin\n        // FIFO implementation\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 6, "code": "```ilog\nmodule e203_exu_nice(\n    input  logic            nice_i_xs_off,    // NICE accelerator disable signal\n    input  logic            nice_i_valid,     // Input instruction valid signal\n    output logic            nice_i_ready,     // Ready signal to accept input instruction\n    input  logic [E203_XLEN-1:0] nice_i_instr, // Input instruction to be executed by NICE\n    input  logic [E203_XLEN-1:0] nice_i_rs1,   // Input source register 1 value\n    input  logic [E203_XLEN-1:0] nice_i_rs2,   // Input source register 2 value\n    input  logic [E203_ITAG_WIDTH-1:0] nice_i_itag, // Input instruction tag for tracking\n    output logic            nice_o_longpipe, // Indicates if instruction needs long pipeline handling\n    output logic            nice_o_valid,     // Valid signal for commit interface\n    input  logic            nice_o_ready,     // Ready signal from commit interface\n    output logic            nice_o_itag_valid, // Valid signal for instruction tag writeback\n    input  logic            nice_o_itag_ready, // Ready signal for instruction tag writeback\n    output logic [E203_ITAG_WIDTH-1:0] nice_o_itag, // Instruction tag for writeback\n    input  logic            nice_rsp_multicyc_valid, // Multi-cycle operation completion signal\n    output logic            nice_rsp_multicyc_ready, // Ready signal for multi-cycle operation completion\n    output logic            nice_req_valid,   // Valid signal for request to custom accelerator\n    input  logic            nice_req_ready,   // Ready signal from custom accelerator\n    output logic [E203_XLEN-1:0] nice_req_instr, // Instruction forwarded to custom accelerator\n    output logic [E203_XLEN-1:0] nice_req_rs1,   // Source register 1 forwarded to custom accelerator\n    output logic [E203_XLEN-1:0] nice_req_rs2,   // Source register 2 forwarded to custom accelerator\n    input  logic            clk,              // System clock\n    input  logic            rst_n             // Active low reset signal\n);\n\n// Internal signals and variables\nlogic [E203_ITAG_WIDTH-1:0] itag_fifo [3:0]; // Instruction tag FIFO\nlogic [1:0] itag_fifo_ptr; // Instruction tag FIFO pointer\nlogic itag_fifo_empty; // Instruction tag FIFO empty flag\nlogic itag_fifo_full; // Instruction tag FIFO full flag\n\n// Instruction forwarding logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        nice_i_ready <= 1'b0;\n        nice_req_valid <= 1'b0;\n    end else begin\n        if (nice_i_valid && ~nice_i_xs_off) begin\n            nice_i_ready <= 1'b1;\n            nice_req_valid <= 1'b1;\n            nice_req_instr <= nice_i_instr;\n            nice_req_rs1 <= nice_i_rs1;\n            nice_req_rs2 <= nice_i_rs2;\n        end else begin\n            nice_i_ready <= 1'b0;\n            nice_req_valid <= 1'b0;\n        end\n    end\nend\n\n// Handshaking protocol logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        nice_o_valid <= 1'b0;\n        nice_o_itag_valid <= 1'b0;\n    end else begin\n        if (nice_i_valid && nice_i_ready && nice_o_ready) begin\n            nice_o_valid <= 1'b1;\n            if (itag_fifo_full) begin\n                nice_o_itag_valid <= 1'b1;\n                nice_o_itag <= itag_fifo[0];\n            end\n        end else begin\n            nice_o_valid <= 1'b0;\n            nice_o_itag_valid <= 1'b0;\n        end\n    end\nend\n\n// Instruction tag FIFO logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        itag_fifo_ptr <= 2'b00;\n        itag_fifo_empty <= 1'b1;\n        itag_fifo_full <= 1'b0;\n    end else begin\n        if (nice_i_valid && ~nice_i_xs_off) begin\n            if (~itag_fifo_full) begin\n                itag_fifo[itag_fifo_ptr] <= nice_i_itag;\n                itag_fifo_ptr <= itag_fifo_ptr + 1'b1;\n                if (itag_fifo_ptr == 4'b1000) begin\n                    itag_fifo_full <= 1'b1;\n                end\n            end\n        end else if (nice_o_itag_valid && nice_o_itag_ready) begin\n            if (itag_fifo_full) begin\n                itag_fifo_ptr <= itag_fifo_ptr - 1'b1;\n                if (itag_fifo_ptr == 4'b0000) begin\n                    itag_fifo_empty <= 1'b1;\n                    itag_fifo_full <= 1'b0;\n                end\n            end\n        end\n    end\nend\n\n// Multi-cycle operation support logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        nice_rsp_multicyc_ready <= 1'b0;\n    end else begin\n        if (nice_rsp_multicyc_valid && ~itag_fifo_empty) begin\n            nice_rsp_multicyc_ready <= 1'b1;\n        end else begin\n            nice_rsp_multicyc_ready <= 1'b0;\n        end\n    end\nend\n\n// Long pipeline handling logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        nice_o_longpipe <= 1'b0;\n    end else begin\n        if (nice_i_valid && ~nice_i_xs_off) begin\n            nice_o_longpipe <= 1'b1;\n        end else begin\n            nice_o_longpipe <= 1'b0;\n        end\n    end\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 1, "code": "module e203_exu_alu (\n    // ... list all ports here\n    input  logic                   i_valid,\n    output logic                   i_ready,\n    input  logic                   i_longpipe,\n    output logic                   nice_csr_valid,\n    input  logic                   nice_csr_ready,\n    output logic [31:0]            nice_csr_addr,\n    output logic                   nice_csr_wr,\n    output logic [31:0]            nice_csr_wdata,\n    input  logic [31:0]            nice_csr_rdata,\n    input  logic                   nice_xs_off,\n    output logic                   amo_wait,\n    input  logic                   oitf_empty,\n    input  logic [E203_ITAG_WIDTH-1:0] i_itag,\n    input  logic [E203_XLEN-1:0]   i_rs1,\n    input  logic [E203_XLEN-1:0]   i_rs2,\n    input  logic [E203_XLEN-1:0]   i_imm,\n    input  logic [E203_DECINFO_WIDTH-1:0] i_info,\n    input  logic [E203_PC_SIZE-1:0] i_pc,\n    input  logic [E203_INSTR_SIZE-1:0] i_instr,\n    input  logic                   i_pc_vld,\n    input  logic [E203_RFIDX_WIDTH-1:0] i_rdidx,\n    input  logic                   i_rdwen,\n    input  logic                   i_ilegl,\n    input  logic                   i_buserr,\n    input  logic                   i_misalgn,\n    input  logic                   flush_req,\n    input  logic                   flush_pulse,\n    output logic                   cmt_o_valid,\n    input  logic                   cmt_o_ready,\n    output logic                   cmt_o_pc_vld,\n    output logic [E203_PC_SIZE-1:0] cmt_o_pc,\n    output logic [E203_INSTR_SIZE-1:0] cmt_o_instr,\n    output logic [E203_XLEN-1:0]   cmt_o_imm,\n    output logic                   cmt_o_rv32,\n    output logic                   cmt_o_bjp,\n    output logic                   cmt_o_mret,\n    output logic                   cmt_o_dret,\n    output logic                   cmt_o_ecall,\n    output logic                   cmt_o_ebreak,\n    output logic                   cmt_o_fencei,\n    output logic                   cmt_o_wfi,\n    output logic                   cmt_o_ifu_misalgn,\n    output logic                   cmt_o_ifu_buserr,\n    output logic                   cmt_o_ifu_ilegl,\n    output logic                   cmt_o_bjp_prdt,\n    output logic                   cmt_o_bjp_rslv,\n    output logic                   cmt_o_misalgn,\n    output logic                   cmt_o_ld,\n    output logic                   cmt_o_stamo,\n    output logic                   cmt_o_buserr,\n    output logic [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n    output logic                   wbck_o_valid,\n    input  logic                   wbck_o_ready,\n    output logic [E203_XLEN-1:0]   wbck_o_wdat,\n    output logic [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n    input  logic                   mdv_nob2b,\n    output logic                   csr_ena,\n    output logic                   csr_wr_en,\n    output logic                   csr_rd_en,\n    output logic [11:0]            csr_idx,\n    input  logic                   nonflush_cmt_ena,\n    input  logic                   csr_access_ilgl,\n    input  logic [E203_XLEN-1:0]   read_csr_dat,\n    output logic [E203_XLEN-1:0]   wbck_csr_dat,\n    output logic                   agu_icb_cmd_valid,\n    input  logic                   agu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output logic                   agu_icb_cmd_read,\n    output logic [E203_XLEN-1:0]   agu_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output logic                   agu_icb_cmd_lock,\n    output logic                   agu_icb_cmd_excl,\n    output logic [1:0]             agu_icb_cmd_size,\n    output logic                   agu_icb_cmd_back2agu,\n    output logic                   agu_icb_cmd_usign,\n    output logic [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    input  logic                   agu_icb_rsp_valid,\n    output logic                   agu_icb_rsp_ready,\n    input  logic                   agu_icb_rsp_err,\n    input  logic                   agu_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0]   agu_icb_rsp_rdata,\n    output logic                   nice_req_valid,\n    input  logic                   nice_req_ready,\n    output logic [E203_XLEN-1:0]   nice_req_instr,\n    output logic [E203_XLEN-1:0]   nice_req_rs1,\n    output logic [E203_XLEN-1:0]   nice_req_rs2,\n    input  logic                   nice_rsp_multicyc_valid,\n    output logic                   nice_rsp_multicyc_ready,\n    output logic                   nice_longp_wbck_valid,\n    input  logic                   nice_longp_wbck_ready,\n    output logic [E203_ITAG_WIDTH-1:0] nice_o_itag,\n    input  logic                   i_nice_cmt_off_ilgl,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n\n// ... rest of the module implementation\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 4, "code": "// Import necessary files\n`include \"e203_defines.v\"\n\nmodule e203_exu_oitf (\n    // Output ports\n    output dis_ready,\n    output [E203_ITAG_WIDTH-1:0] dis_ptr,\n    output [E203_ITAG_WIDTH-1:0] ret_ptr,\n    output [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n    output ret_rdwen,\n    output ret_rdfpu,\n    output [E203_PC_SIZE-1:0] ret_pc,\n    output oitfrd_match_disprs1,\n    output oitfrd_match_disprs2,\n    output oitfrd_match_disprs3,\n    output oitfrd_match_disprd,\n    output oitf_empty,\n\n    // Input ports\n    input dis_ena,\n    input ret_ena,\n    input disp_i_rs1en,\n    input disp_i_rs2en,\n    input disp_i_rs3en,\n    input disp_i_rdwen,\n    input disp_i_rs1fpu,\n    input disp_i_rs2fpu,\n    input disp_i_rs3fpu,\n    input disp_i_rdfpu,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input [E203_PC_SIZE-1:0] disp_i_pc,\n    input clk,\n    input rst_n\n);\n\n// Internal signals and variables\nreg [E203_ITAG_WIDTH-1:0] dis_ptr_reg;\nreg [E203_ITAG_WIDTH-1:0] ret_ptr_reg;\nreg [E203_RFIDX_WIDTH-1:0] ret_rdidx_reg;\nreg ret_rdwen_reg;\nreg ret_rdfpu_reg;\nreg [E203_PC_SIZE-1:0] ret_pc_reg;\nreg oitfrd_match_disprs1_reg;\nreg oitfrd_match_disprs2_reg;\nreg oitfrd_match_disprs3_reg;\nreg oitfrd_match_disprd_reg;\nreg oitf_empty_reg;\n\n// FIFO implementation\nreg [E203_OITF_DEPTH-1:0][E203_RFIDX_WIDTH-1:0] oitf_rdidx;\nreg [E203_OITF_DEPTH-1:0][E203_PC_SIZE-1:0] oitf_pc;\nreg [E203_OITF_DEPTH-1:0] oitf_rdwen;\nreg [E203_OITF_DEPTH-1:0] oitf_rdfpu;\n\n// Dispatch logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        dis_ptr_reg <= '0;\n    end else if (dis_ena) begin\n        dis_ptr_reg <= dis_ptr_reg + 1;\n        if (dis_ptr_reg == E203_OITF_DEPTH - 1) begin\n            dis_ptr_reg <= '0;\n        end\n    end\nend\n\n// Retirement logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        ret_ptr_reg <= '0;\n    end else if (ret_ena) begin\n        ret_ptr_reg <= ret_ptr_reg + 1;\n        if (ret_ptr_reg == E203_OITF_DEPTH - 1) begin\n            ret_ptr_reg <= '0;\n        end\n    end\nend\n\n// Dependency checking\nalways @(*) begin\n    oitfrd_match_disprs1_reg = 1'b0;\n    oitfrd_match_disprs2_reg = 1'b0;\n    oitfrd_match_disprs3_reg = 1'b0;\n    oitfrd_match_disprd_reg = 1'b0;\n    for (int i = 0; i < E203_OITF_DEPTH; i++) begin\n        if (oitf_rdwen[i] && (oitf_rdidx[i] == disp_i_rs1idx) && (oitf_rdfpu[i] == disp_i_rs1fpu)) begin\n            oitfrd_match_disprs1_reg = 1'b1;\n        end\n        if (oitf_rdwen[i] && (oitf_rdidx[i] == disp_i_rs2idx) && (oitf_rdfpu[i] == disp_i_rs2fpu)) begin\n            oitfrd_match_disprs2_reg = 1'b1;\n        end\n        if (oitf_rdwen[i] && (oitf_rdidx[i] == disp_i_rs3idx) && (oitf_rdfpu[i] == disp_i_rs3fpu)) begin\n            oitfrd_match_disprs3_reg = 1'b1;\n        end\n        if (oitf_rdwen[i] && (oitf_rdidx[i] == disp_i_rdidx) && (oitf_rdfpu[i] == disp_i_rdfpu)) begin\n            oitfrd_match_disprd_reg = 1'b1;\n        end\n    end\nend\n\n// Full and empty conditions\nalways @(*) begin\n    oitf_empty_reg = (dis_ptr_reg == ret_ptr_reg);\nend\n\n// Output assignments\nassign dis_ready = ~oitf_empty_reg;\nassign dis_ptr = dis_ptr_reg;\nassign ret_ptr = ret_ptr_reg;\nassign ret_rdidx = ret_rdidx_reg;\nassign ret_rdwen = ret_rdwen_reg;\nassign ret_rdfpu = ret_rdfpu_reg;\nassign ret_pc = ret_pc_reg;\nassign oitfrd_match_disprs1 = oitfrd_match_disprs1_reg;\nassign oitfrd_match_disprs2 = oitfrd_match_disprs2_reg;\nassign oitfrd_match_disprs3 = oitfrd_match_disprs3_reg;\nassign oitfrd_match_disprd = oitfrd_match_disprd_reg;\nassign oitf_empty = oitf_empty_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 1, "code": "module e203_ifu_ift2icb (\n    input  logic                   itcm_nohold,\n    input  logic                   ifu_req_valid,\n    input  logic [E203_PC_SIZE-1:0] ifu_req_pc,\n    input  logic                   ifu_req_seq,\n    input  logic                   ifu_req_seq_rv32,\n    input  logic [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input  logic                   ifu_rsp_ready,\n    input  logic                   clk,\n    input  logic                   rst_n,\n\n    output logic                   ifu_req_ready,\n    output logic                   ifu_rsp_valid,\n    output logic                   ifu_rsp_err,\n    output logic [31:0]            ifu_rsp_instr,\n\n    // ITCM Interface\n    output logic                   ifu2itcm_icb_cmd_valid,\n    input  logic                   ifu2itcm_icb_cmd_ready,\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input  logic                   ifu2itcm_icb_rsp_valid,\n    output logic                   ifu2itcm_icb_rsp_ready,\n    input  logic                   ifu2itcm_icb_rsp_err,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // System Memory Interface\n    output logic                   ifu2biu_icb_cmd_valid,\n    input  logic                   ifu2biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input  logic                   ifu2biu_icb_rsp_valid,\n    output logic                   ifu2biu_icb_rsp_ready,\n    input  logic                   ifu2biu_icb_rsp_err,\n    input  logic [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n// State Machine Implementation\nlogic [1:0] icb_state;\nlogic icb_state_ena;\nlogic [1:0] icb_state_nxt;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        icb_state <= 2'b00;\n    end else if (icb_state_ena) begin\n        icb_state <= icb_state_nxt;\n    end\nend\n\n// Bypass Buffer Implementation\nlogic ifu_rsp_bypbuf_i_vld;\nlogic ifu_rsp_bypbuf_o_rdy;\nlogic [32:0] ifu_rsp_bypbuf_i_data;\nlogic ifu_rsp_bypbuf_o_vld;\nlogic ifu_rsp_bypbuf_i_rdy;\nlogic [32:0] ifu_rsp_bypbuf_o_data;\n\nsirv_gnrl_bypbuf #(\n    .DP(1),\n    .DW(33)\n) ifu_rsp_bypbuf_inst (\n    .i_vld(ifu_rsp_bypbuf_i_vld),\n    .i_rdy(ifu_rsp_bypbuf_i_rdy),\n    .i_dat(ifu_rsp_bypbuf_i_data),\n    .o_vld(ifu_rsp_bypbuf_o_vld),\n    .o_rdy(ifu_rsp_bypbuf_o_rdy),\n    .o_dat(ifu_rsp_bypbuf_o_data),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Lane Operation Implementation\nlogic ifu_req_lane_cross;\nlogic ifu_req_lane_begin;\nlogic ifu_req_lane_same;\nlogic ifu_req_lane_holdup;\n\n// Request Feature Registering\nlogic req_same_cross_holdup_r;\nlogic req_need_2uop_r;\nlogic req_need_0uop_r;\nlogic icb_cmd2itcm_r;\nlogic icb_cmd2biu_r;\n\n// Leftover Buffer Implementation\nlogic holdup2leftover_ena;\nlogic uop1st2leftover_ena;\nlogic [15:0] leftover_nxt;\nlogic leftover_err_nxt;\n\n// Response Generation Implementation\nlogic rsp_instr_sel_leftover;\nlogic [31:0] rsp_instr;\nlogic i_ifu_rsp_valid;\nlogic i_ifu_rsp_err;\n\n// ICB Command Generation Implementation\nlogic ifu_icb_cmd_valid;\nlogic [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr;\nlogic ifu_icb_cmd2itcm;\nlogic ifu_icb_cmd2biu;\n\n// Handshake Control Implementation\nlogic ifu_req_ready_condi;\nlogic ifu_icb_rsp_ready_condi;\n\n// Data Alignment Implementation\nlogic [15:0] ifu_icb_rsp_rdata_lsb16;\n\n// ICB Response Merge Implementation\nlogic ifu_icb_rsp_err;\nlogic ifu_icb_rsp_valid;\n\n// ICB Request Distribution Implementation\nlogic ifu2biu_icb_cmd_valid_pre;\nlogic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr_pre;\n\n// System Memory Interface Implementation\nlogic ifu2biu_icb_cmd_valid;\nlogic ifu2biu_icb_cmd_ready_pre;\nlogic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr;\nlogic ifu2biu_icb_rsp_valid;\nlogic ifu2biu_icb_rsp_ready;\nlogic ifu2biu_icb_rsp_err;\nlogic [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata;\n\nassign ifu_req_ready = ifu_icb_cmd_ready & ifu_req_ready_condi;\nassign ifu_rsp_valid = i_ifu_rsp_valid;\nassign ifu_rsp_err = i_ifu_rsp_err;\nassign ifu_rsp_instr = rsp_instr;\n\nassign ifu2itcm_icb_cmd_valid = ifu_icb_cmd_valid & ifu_icb_cmd2itcm;\nassign ifu2itcm_icb_cmd_addr = ifu_icb_cmd_addr;\nassign ifu2itcm_icb_rsp_ready = ifu_icb_rsp_ready;\n\nassign ifu2biu_icb_cmd_valid = ifu2biu_icb_cmd_valid_pre;\nassign ifu2biu_icb_cmd_addr = ifu2biu_icb_cmd_addr_pre;\nassign ifu2biu_icb_rsp_ready = ifu2biu_icb_rsp_ready;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 6, "code": "module e203_ifu_litebpu #(\n    parameter E203_PC_SIZE = 32,\n    parameter E203_XLEN = 32,\n    parameter E203_RFIDX_WIDTH = 5\n) (\n    input  logic                   clk,\n    input  logic                   rst_n,\n    input  logic [E203_PC_SIZE-1:0] pc,\n    input  logic                   dec_jal,\n    input  logic                   dec_jalr,\n    input  logic                   dec_bxx,\n    input  logic [E203_XLEN-1:0]   dec_bjp_imm,\n    input  logic [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    input  logic                   oitf_empty,\n    input  logic                   ir_empty,\n    input  logic                   ir_rs1en,\n    input  logic                   jalr_rs1idx_cam_irrdidx,\n    input  logic                   dec_i_valid,\n    input  logic                   ir_valid_clr,\n    input  logic [E203_XLEN-1:0]   rf2bpu_x1,\n    input  logic [E203_XLEN-1:0]   rf2bpu_rs1,\n    output logic                   prdt_taken,\n    output logic [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n    output logic [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n    output logic                   bpu_wait,\n    output logic                   bpu2rf_rs1_ena\n);\n\nlogic [E203_RFIDX_WIDTH-1:0] rs1xn_rdrf_r;\nlogic [E203_RFIDX_WIDTH-1:0] rs1xn_rdrf_nxt;\nlogic                           rs1xn_rdrf_ena;\nlogic                           rs1xn_rdrf_clr;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        rs1xn_rdrf_r <= '0;\n    end else if (rs1xn_rdrf_ena) begin\n        rs1xn_rdrf_r <= rs1xn_rdrf_nxt;\n    end else if (rs1xn_rdrf_clr) begin\n        rs1xn_rdrf_r <= '0;\n    end\nend\n\nalways_comb begin\n    rs1xn_rdrf_nxt = rs1xn_rdrf_r;\n    rs1xn_rdrf_ena = 1'b0;\n    rs1xn_rdrf_clr = 1'b0;\n\n    if (dec_jalr && dec_jalr_rs1idx != 5'd0 && dec_jalr_rs1idx != 5'd1 && !oitf_empty && !ir_empty && ir_rs1en && !jalr_rs1idx_cam_irrdidx) begin\n        rs1xn_rdrf_nxt = dec_jalr_rs1idx;\n        rs1xn_rdrf_ena = 1'b1;\n    end\n\n    if (ir_valid_clr) begin\n        rs1xn_rdrf_clr = 1'b1;\n    end\nend\n\nalways_comb begin\n    prdt_taken = 1'b0;\n    prdt_pc_add_op1 = '0;\n    prdt_pc_add_op2 = '0;\n    bpu_wait = 1'b0;\n    bpu2rf_rs1_ena = 1'b0;\n\n    if (dec_jal) begin\n        prdt_taken = 1'b1;\n        prdt_pc_add_op1 = pc;\n        prdt_pc_add_op2 = { {E203_PC_SIZE-1{1'b0}}, dec_bjp_imm[E203_PC_SIZE-1:0] };\n    end else if (dec_jalr) begin\n        prdt_taken = 1'b1;\n        if (dec_jalr_rs1idx == 5'd0) begin\n            prdt_pc_add_op1 = '0;\n        end else if (dec_jalr_rs1idx == 5'd1) begin\n            prdt_pc_add_op1 = rf2bpu_x1[E203_PC_SIZE-1:0];\n        end else begin\n            prdt_pc_add_op1 = rf2bpu_rs1[E203_PC_SIZE-1:0];\n        end\n        prdt_pc_add_op2 = { {E203_PC_SIZE-1{1'b0}}, dec_bjp_imm[E203_PC_SIZE-1:0] };\n        if (rs1xn_rdrf_r == dec_jalr_rs1idx) begin\n            bpu_wait = 1'b1;\n        end\n        if (dec_jalr_rs1idx != 5'd0 && dec_jalr_rs1idx != 5'd1) begin\n            bpu2rf_rs1_ena = 1'b1;\n        end\n    end else if (dec_bxx) begin\n        if (dec_bjp_imm[E203_XLEN-1] == 1'b1) begin\n            prdt_taken = 1'b1;\n        end\n        prdt_pc_add_op1 = pc;\n        prdt_pc_add_op2 = { {E203_PC_SIZE-1{1'b0}}, dec_bjp_imm[E203_PC_SIZE-1:0] };\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 7, "code": "module e203_ifu_litebpu #(\n    parameter E203_PC_SIZE = 32,\n    parameter E203_XLEN = 32,\n    parameter E203_RFIDX_WIDTH = 5\n) (\n    input  logic                   clk,\n    input  logic                   rst_n,\n    input  logic [E203_PC_SIZE-1:0] pc,\n    input  logic                   dec_jal,\n    input  logic                   dec_jalr,\n    input  logic                   dec_bxx,\n    input  logic [E203_XLEN-1:0]   dec_bjp_imm,\n    input  logic [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    input  logic                   oitf_empty,\n    input  logic                   ir_empty,\n    input  logic                   ir_rs1en,\n    input  logic                   jalr_rs1idx_cam_irrdidx,\n    input  logic                   dec_i_valid,\n    input  logic                   ir_valid_clr,\n    input  logic [E203_XLEN-1:0]   rf2bpu_x1,\n    input  logic [E203_XLEN-1:0]   rf2bpu_rs1,\n    output logic                   prdt_taken,\n    output logic [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n    output logic [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n    output logic                   bpu_wait,\n    output logic                   bpu2rf_rs1_ena\n);\n\nlogic [E203_RFIDX_WIDTH-1:0] rs1xn_rdrf_r;\n\nsirv_gnrl_dfflr #(\n    .DW(1)\n) u_rs1xn_rdrf (\n    .lden(rs1xn_rdrf_ena),\n    .dnxt(1'b1),\n    .qout(rs1xn_rdrf_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        rs1xn_rdrf_r <= 1'b0;\n    end else if (rs1xn_rdrf_ena) begin\n        rs1xn_rdrf_r <= 1'b1;\n    end else begin\n        rs1xn_rdrf_r <= 1'b0;\n    end\nend\n\nalways @(*) begin\n    if (dec_jal || dec_jalr) begin\n        prdt_taken = 1'b1;\n    end else if (dec_bxx && dec_bjp_imm[E203_XLEN-1]) begin\n        prdt_taken = 1'b1;\n    end else begin\n        prdt_taken = 1'b0;\n    end\nend\n\nalways @(*) begin\n    if (dec_jal || dec_bxx) begin\n        prdt_pc_add_op1 = pc;\n    end else if (dec_jalr && dec_jalr_rs1idx == 5'd0) begin\n        prdt_pc_add_op1 = 32'd0;\n    end else if (dec_jalr && dec_jalr_rs1idx == 5'd1) begin\n        prdt_pc_add_op1 = rf2bpu_x1;\n    end else if (dec_jalr && dec_jalr_rs1idx != 5'd0 && dec_jalr_rs1idx != 5'd1) begin\n        prdt_pc_add_op1 = rf2bpu_rs1;\n    end\nend\n\nalways @(*) begin\n    prdt_pc_add_op2 = dec_bjp_imm[E203_PC_SIZE-1:0];\nend\n\nalways @(*) begin\n    if (dec_jalr && dec_jalr_rs1idx == 5'd1 && !oitf_empty && !ir_empty) begin\n        bpu_wait = 1'b1;\n    end else if (dec_jalr && dec_jalr_rs1idx != 5'd0 && dec_jalr_rs1idx != 5'd1 && !oitf_empty && !ir_empty) begin\n        bpu_wait = 1'b1;\n    end else begin\n        bpu_wait = 1'b0;\n    end\nend\n\nalways @(*) begin\n    if (dec_jalr && dec_jalr_rs1idx != 5'd0 && dec_jalr_rs1idx != 5'd1) begin\n        bpu2rf_rs1_ena = 1'b1;\n    end else begin\n        bpu2rf_rs1_ena = 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 5, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_oitf (\n    output dis_ready,\n    input dis_ena,\n    input ret_ena,\n    output [E203_ITAG_WIDTH-1:0] dis_ptr,\n    output [E203_ITAG_WIDTH-1:0] ret_ptr,\n    output [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n    output ret_rdwen,\n    output ret_rdfpu,\n    output [E203_PC_SIZE-1:0] ret_pc,\n    input disp_i_rs1en,\n    input disp_i_rs2en,\n    input disp_i_rs3en,\n    input disp_i_rdwen,\n    input disp_i_rs1fpu,\n    input disp_i_rs2fpu,\n    input disp_i_rs3fpu,\n    input disp_i_rdfpu,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input [E203_PC_SIZE-1:0] disp_i_pc,\n    output oitfrd_match_disprs1,\n    output oitfrd_match_disprs2,\n    output oitfrd_match_disprs3,\n    output oitfrd_match_disprd,\n    output oitf_empty,\n    input clk,\n    input rst_n\n);\n\nreg [E203_ITAG_WIDTH-1:0] dis_ptr_reg;\nreg [E203_ITAG_WIDTH-1:0] ret_ptr_reg;\nreg [E203_OITF_DEPTH-1:0] oitf_reg [E203_RFIDX_WIDTH-1:0];\nreg [E203_RFIDX_WIDTH-1:0] ret_rdidx_reg;\nreg ret_rdwen_reg;\nreg ret_rdfpu_reg;\nreg [E203_PC_SIZE-1:0] ret_pc_reg;\n\ninteger i;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        dis_ptr_reg <= 'd0;\n        ret_ptr_reg <= 'd0;\n        for (i = 0; i < E203_OITF_DEPTH; i++) begin\n            oitf_reg[i] <= 'd0;\n        end\n        ret_rdidx_reg <= 'd0;\n        ret_rdwen_reg <= 'd0;\n        ret_rdfpu_reg <= 'd0;\n        ret_pc_reg <= 'd0;\n    end else begin\n        if (dis_ena) begin\n            oitf_reg[dis_ptr_reg] <= {disp_i_rdidx, disp_i_rdwen, disp_i_rdfpu, disp_i_pc};\n            dis_ptr_reg <= (dis_ptr_reg + 1) % E203_OITF_DEPTH;\n        end\n        if (ret_ena) begin\n            ret_rdidx_reg <= oitf_reg[ret_ptr_reg][E203_RFIDX_WIDTH-1:0];\n            ret_rdwen_reg <= oitf_reg[ret_ptr_reg][E203_RFIDX_WIDTH];\n            ret_rdfpu_reg <= oitf_reg[ret_ptr_reg][E203_RFIDX_WIDTH+1];\n            ret_pc_reg <= oitf_reg[ret_ptr_reg][E203_PC_SIZE+E203_RFIDX_WIDTH+1:E203_RFIDX_WIDTH+2];\n            ret_ptr_reg <= (ret_ptr_reg + 1) % E203_OITF_DEPTH;\n        end\n    end\nend\n\nassign dis_ready = (dis_ptr_reg != ret_ptr_reg) || (oitf_empty == 1'b1);\nassign ret_rdidx = ret_rdidx_reg;\nassign ret_rdwen = ret_rdwen_reg;\nassign ret_rdfpu = ret_rdfpu_reg;\nassign ret_pc = ret_pc_reg;\n\nassign oitfrd_match_disprs1 = (oitf_reg[disp_i_rs1idx][E203_RFIDX_WIDTH-1:0] == disp_i_rdidx) && oitf_reg[disp_i_rs1idx][E203_RFIDX_WIDTH];\nassign oitfrd_match_disprs2 = (oitf_reg[disp_i_rs2idx][E203_RFIDX_WIDTH-1:0] == disp_i_rdidx) && oitf_reg[disp_i_rs2idx][E203_RFIDX_WIDTH];\nassign oitfrd_match_disprs3 = (oitf_reg[disp_i_rs3idx][E203_RFIDX_WIDTH-1:0] == disp_i_rdidx) && oitf_reg[disp_i_rs3idx][E203_RFIDX_WIDTH];\nassign oitfrd_match_disprd = (oitf_reg[disp_i_rdidx][E203_RFIDX_WIDTH-1:0] == disp_i_rdidx) && oitf_reg[disp_i_rdidx][E203_RFIDX_WIDTH];\n\nassign oitf_empty = (dis_ptr_reg == ret_ptr_reg) && (oitf_reg[dis_ptr_reg] == 'd0);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 8, "code": "module e203_ifu_litebpu(\n    input               clk,\n    input               rst_n,\n    input  [E203_PC_SIZE-1:0] pc,\n    input               dec_jal,\n    input               dec_jalr,\n    input               dec_bxx,\n    input  [E203_XLEN-1:0] dec_bjp_imm,\n    input  [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    input               oitf_empty,\n    input               ir_empty,\n    input               ir_rs1en,\n    input               jalr_rs1idx_cam_irrdidx,\n    input               dec_i_valid,\n    input               ir_valid_clr,\n    input  [E203_XLEN-1:0] rf2bpu_x1,\n    input  [E203_XLEN-1:0] rf2bpu_rs1,\n    output              prdt_taken,\n    output [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n    output [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n    output              bpu_wait,\n    output              bpu2rf_rs1_ena\n);\n\n// Static branch prediction strategy implementation\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        prdt_taken <= 1'b0;\n        prdt_pc_add_op1 <= '0;\n        prdt_pc_add_op2 <= '0;\n        bpu_wait <= 1'b0;\n        bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n        // JAL instruction prediction\n        if (dec_jal) begin\n            prdt_taken <= 1'b1;\n            prdt_pc_add_op1 <= pc;\n            prdt_pc_add_op2 <= {E203_PC_SIZE{1'b0}} + dec_bjp_imm;\n        end\n        \n        // JALR instruction prediction\n        else if (dec_jalr) begin\n            prdt_taken <= 1'b1;\n            if (dec_jalr_rs1idx == 5'd0) begin // rs1 = x0\n                prdt_pc_add_op1 <= '0;\n                prdt_pc_add_op2 <= dec_bjp_imm;\n            end else if (dec_jalr_rs1idx == 5'd1) begin // rs1 = x1\n                prdt_pc_add_op1 <= rf2bpu_x1;\n                prdt_pc_add_op2 <= dec_bjp_imm;\n            end else begin // rs1 = xn\n                prdt_pc_add_op1 <= rf2bpu_rs1;\n                prdt_pc_add_op2 <= dec_bjp_imm;\n            end\n        end\n        \n        // Conditional branch instruction prediction\n        else if (dec_bxx) begin\n            if (dec_bjp_imm[E203_XLEN-1] == 1'b1) begin // backward jump\n                prdt_taken <= 1'b1;\n                prdt_pc_add_op1 <= pc;\n                prdt_pc_add_op2 <= dec_bjp_imm;\n            end else begin // forward jump\n                prdt_taken <= 1'b0;\n                prdt_pc_add_op1 <= pc;\n                prdt_pc_add_op2 <= '0;\n            end\n        end\n        \n        // Dependency processing for JALR instruction\n        if (dec_jalr && dec_jalr_rs1idx != 5'd0 && dec_jalr_rs1idx != 5'd1) begin\n            if (~oitf_empty || ~ir_empty || jalr_rs1idx_cam_irrdidx) begin\n                bpu_wait <= 1'b1;\n            end else begin\n                bpu_wait <= 1'b0;\n            end\n        end\n        \n        // Register read status management\n        if (dec_jalr && dec_jalr_rs1idx != 5'd0 && dec_jalr_rs1idx != 5'd1) begin\n            bpu2rf_rs1_ena <= 1'b1;\n        end else begin\n            bpu2rf_rs1_ena <= 1'b0;\n        end\n    end\nend\n\n// sirv_gnrl_dfflr module instantiation\nsirv_gnrl_dfflr #(\n    .DW(1)\n) u_sirv_gnrl_dfflr(\n    .lden(bpu2rf_rs1_ena),\n    .dnxt(1'b1),\n    .qout(),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 6, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_oitf(\n    output dis_ready,\n    input dis_ena,\n    input ret_ena,\n    output [E203_ITAG_WIDTH-1:0] dis_ptr,\n    output [E203_ITAG_WIDTH-1:0] ret_ptr,\n    output [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n    output ret_rdwen,\n    output ret_rdfpu,\n    output [E203_PC_SIZE-1:0] ret_pc,\n    input disp_i_rs1en,\n    input disp_i_rs2en,\n    input disp_i_rs3en,\n    input disp_i_rdwen,\n    input disp_i_rs1fpu,\n    input disp_i_rs2fpu,\n    input disp_i_rs3fpu,\n    input disp_i_rdfpu,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input [E203_PC_SIZE-1:0] disp_i_pc,\n    output oitfrd_match_disprs1,\n    output oitfrd_match_disprs2,\n    output oitfrd_match_disprs3,\n    output oitfrd_match_disprd,\n    output oitf_empty,\n    input clk,\n    input rst_n\n);\n\nreg [E203_ITAG_WIDTH-1:0] dis_ptr_reg;\nreg [E203_ITAG_WIDTH-1:0] ret_ptr_reg;\nreg [E203_RFIDX_WIDTH-1:0] ret_rdidx_reg;\nreg ret_rdwen_reg;\nreg ret_rdfpu_reg;\nreg [E203_PC_SIZE-1:0] ret_pc_reg;\nreg [E203_OITF_DEPTH-1:0] oitf_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        dis_ptr_reg <= 'd0;\n        ret_ptr_reg <= 'd0;\n        ret_rdidx_reg <= 'd0;\n        ret_rdwen_reg <= 'd0;\n        ret_rdfpu_reg <= 'd0;\n        ret_pc_reg <= 'd0;\n        oitf_reg <= 'd0;\n    end else begin\n        if (dis_ena) begin\n            dis_ptr_reg <= dis_ptr_reg + 1;\n            if (dis_ptr_reg == E203_OITF_DEPTH - 1) begin\n                dis_ptr_reg <= 'd0;\n            end\n        end\n\n        if (ret_ena) begin\n            ret_ptr_reg <= ret_ptr_reg + 1;\n            if (ret_ptr_reg == E203_OITF_DEPTH - 1) begin\n                ret_ptr_reg <= 'd0;\n            end\n        end\n\n        if (dis_ena) begin\n            oitf_reg[dis_ptr_reg] <= {disp_i_rdidx, disp_i_rdwen, disp_i_rdfpu, disp_i_pc};\n        end\n\n        if (ret_ena) begin\n            ret_rdidx_reg <= oitf_reg[ret_ptr_reg][E203_RFIDX_WIDTH-1:0];\n            ret_rdwen_reg <= oitf_reg[ret_ptr_reg][E203_RFIDX_WIDTH];\n            ret_rdfpu_reg <= oitf_reg[ret_ptr_reg][E203_RFIDX_WIDTH+1];\n            ret_pc_reg <= oitf_reg[ret_ptr_reg][E203_RFIDX_WIDTH+2+E203_PC_SIZE-1:E203_RFIDX_WIDTH+2];\n        end\n    end\nend\n\nassign dis_ready = (dis_ptr_reg != ret_ptr_reg) || (oitf_reg[dis_ptr_reg] == 'd0);\nassign dis_ptr = dis_ptr_reg;\nassign ret_ptr = ret_ptr_reg;\nassign ret_rdidx = ret_rdidx_reg;\nassign ret_rdwen = ret_rdwen_reg;\nassign ret_rdfpu = ret_rdfpu_reg;\nassign ret_pc = ret_pc_reg;\n\nassign oitfrd_match_disprs1 = (oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH-1:0] == disp_i_rs1idx) && oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH];\nassign oitfrd_match_disprs2 = (oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH-1:0] == disp_i_rs2idx) && oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH];\nassign oitfrd_match_disprs3 = (oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH-1:0] == disp_i_rs3idx) && oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH];\nassign oitfrd_match_disprd = (oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH-1:0] == disp_i_rdidx) && oitf_reg[dis_ptr_reg][E203_RFIDX_WIDTH];\n\nassign oitf_empty = (dis_ptr_reg == ret_ptr_reg) && (oitf_reg[dis_ptr_reg] == 'd0);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 7, "code": "```ilog\nmodule e203_exu_nice(\n    input               nice_i_xs_off,    // NICE accelerator disable signal\n    input               nice_i_valid,     // Input instruction valid signal\n    output              nice_i_ready,     // Ready signal to accept input instruction\n    input  [E203_XLEN-1:0] nice_i_instr,  // Input instruction to be executed by NICE\n    input  [E203_XLEN-1:0] nice_i_rs1,    // Input source register 1 value\n    input  [E203_XLEN-1:0] nice_i_rs2,    // Input source register 2 value\n    input  [E203_ITAG_WIDTH-1:0] nice_i_itag, // Input instruction tag for tracking\n    output              nice_o_longpipe, // Indicates if instruction needs long pipeline handling\n    output              nice_o_valid,    // Valid signal for commit interface\n    input               nice_o_ready,    // Ready signal from commit interface\n    output              nice_o_itag_valid,// Valid signal for instruction tag writeback\n    input               nice_o_itag_ready,// Ready signal for instruction tag writeback\n    output [E203_ITAG_WIDTH-1:0] nice_o_itag, // Instruction tag for writeback\n    input               nice_rsp_multicyc_valid, // Multi-cycle operation completion signal\n    output              nice_rsp_multicyc_ready, // Ready signal for multi-cycle operation completion\n    output              nice_req_valid,  // Valid signal for request to custom accelerator\n    input               nice_req_ready,  // Ready signal from custom accelerator\n    output [E203_XLEN-1:0] nice_req_instr, // Instruction forwarded to custom accelerator\n    output [E203_XLEN-1:0] nice_req_rs1,  // Source register 1 forwarded to custom accelerator\n    output [E203_XLEN-1:0] nice_req_rs2,  // Source register 2 forwarded to custom accelerator\n    input               clk,             // System clock\n    input               rst_n            // Active low reset signal\n);\n\n// Internal signals and variables\nreg [E203_ITAG_WIDTH-1:0] itag_fifo [3:0]; // Instruction tag FIFO\nreg [2:0] itag_fifo_ptr; // Pointer for instruction tag FIFO\nreg nice_req_valid_reg; // Registered valid signal for request to custom accelerator\nreg [E203_XLEN-1:0] nice_req_instr_reg; // Registered instruction for custom accelerator\nreg [E203_XLEN-1:0] nice_req_rs1_reg; // Registered source register 1 for custom accelerator\nreg [E203_XLEN-1:0] nice_req_rs2_reg; // Registered source register 2 for custom accelerator\n\n// Handshaking protocol logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        nice_i_ready <= 1'b0;\n        nice_o_valid <= 1'b0;\n        nice_o_itag_valid <= 1'b0;\n        nice_rsp_multicyc_ready <= 1'b0;\n        nice_req_valid_reg <= 1'b0;\n    end else begin\n        // Accept input instruction when both co-unit and commit interface are ready\n        if (nice_i_valid && nice_o_ready && ~nice_i_xs_off) begin\n            nice_i_ready <= 1'b1;\n            // Forward instruction to custom accelerator\n            nice_req_valid_reg <= 1'b1;\n            nice_req_instr_reg <= nice_i_instr;\n            nice_req_rs1_reg <= nice_i_rs1;\n            nice_req_rs2_reg <= nice_i_rs2;\n        end else begin\n            nice_i_ready <= 1'b0;\n            nice_req_valid_reg <= 1'b0;\n        end\n\n        // Commit instruction when it is valid and co-unit has accepted it\n        if (nice_i_valid && nice_i_ready) begin\n            nice_o_valid <= 1'b1;\n        end else begin\n            nice_o_valid <= 1'b0;\n        end\n\n        // Write back instruction tag when multi-cycle operation completes\n        if (nice_rsp_multicyc_valid && nice_o_itag_ready) begin\n            nice_o_itag_valid <= 1'b1;\n            nice_o_itag <= itag_fifo[itag_fifo_ptr];\n            itag_fifo_ptr <= itag_fifo_ptr + 1'b1;\n        end else begin\n            nice_o_itag_valid <= 1'b0;\n        end\n\n        // Ready signal for multi-cycle operation completion\n        if (nice_rsp_multicyc_valid) begin\n            nice_rsp_multicyc_ready <= 1'b1;\n        end else begin\n            nice_rsp_multicyc_ready <= 1'b0;\n        end\n    end\nend\n\n// FIFO logic for instruction tags\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        itag_fifo <= '0;\n        itag_fifo_ptr <= '0;\n    end else begin\n        // Push instruction tag into FIFO when instruction is dispatched\n        if (nice_i_valid && nice_i_ready) begin\n            itag_fifo[0] <= nice_i_itag;\n            itag_fifo_ptr <= itag_fifo_ptr + 1'b1;\n        end\n    end\nend\n\n// Output logic\nassign nice_o_longpipe = ~nice_i_xs_off; // Set long pipeline handling when NICE is enabled\nassign nice_req_valid = nice_req_valid_reg;\nassign nice_req_instr = nice_req_instr_reg;\nassign nice_req_rs1 = nice_req_rs1_reg;\nassign nice_req_rs2 = nice_req_rs2_reg;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 2, "code": "module e203_ifu_ift2icb #(\n    parameter PC_SIZE = 32,\n    parameter ITCM_ADDR_WIDTH = 10,\n    parameter SYSMEM_DATA_WIDTH = 32\n) (\n    input  logic                        itcm_nohold,\n    input  logic                        ifu_req_valid,\n    input  logic [PC_SIZE-1:0]          ifu_req_pc,\n    input  logic                        ifu_req_seq,\n    input  logic                        ifu_req_seq_rv32,\n    input  logic [PC_SIZE-1:0]          ifu_req_last_pc,\n    input  logic                        ifu_rsp_ready,\n    input  logic                        clk,\n    input  logic                        rst_n,\n\n    output logic                        ifu_req_ready,\n    output logic                        ifu_rsp_valid,\n    output logic                        ifu_rsp_err,\n    output logic [31:0]                 ifu_rsp_instr,\n\n    output logic                        ifu2itcm_icb_cmd_valid,\n    input  logic                        ifu2itcm_icb_cmd_ready,\n    output logic [ITCM_ADDR_WIDTH-1:0]  ifu2itcm_icb_cmd_addr,\n    input  logic                        ifu2itcm_icb_rsp_valid,\n    output logic                        ifu2itcm_icb_rsp_ready,\n    input  logic                        ifu2itcm_icb_rsp_err,\n    input  logic [SYSMEM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    output logic                        ifu2biu_icb_cmd_valid,\n    input  logic                        ifu2biu_icb_cmd_ready,\n    output logic [PC_SIZE-1:0]          ifu2biu_icb_cmd_addr,\n    input  logic                        ifu2biu_icb_rsp_valid,\n    output logic                        ifu2biu_icb_rsp_ready,\n    input  logic                        ifu2biu_icb_rsp_err,\n    input  logic [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n// State Machine Implementation\nenum logic [1:0] {\n    ICB_STATE_IDLE,\n    ICB_STATE_1ST,\n    ICB_STATE_WAIT2ND,\n    ICB_STATE_2ND\n} icb_state, icb_state_nxt;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        icb_state <= ICB_STATE_IDLE;\n    end else begin\n        icb_state <= icb_state_nxt;\n    end\nend\n\nalways_comb begin\n    case (icb_state)\n        ICB_STATE_IDLE: begin\n            if (ifu_req_valid) begin\n                icb_state_nxt = ICB_STATE_1ST;\n            end else begin\n                icb_state_nxt = ICB_STATE_IDLE;\n            end\n        end\n        ICB_STATE_1ST: begin\n            if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid) begin\n                if (ifu_req_seq && !itcm_nohold) begin\n                    icb_state_nxt = ICB_STATE_WAIT2ND;\n                end else begin\n                    icb_state_nxt = ICB_STATE_1ST;\n                end\n            end else begin\n                icb_state_nxt = ICB_STATE_1ST;\n            end\n        end\n        ICB_STATE_WAIT2ND: begin\n            if (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready) begin\n                icb_state_nxt = ICB_STATE_2ND;\n            end else begin\n                icb_state_nxt = ICB_STATE_WAIT2ND;\n            end\n        end\n        ICB_STATE_2ND: begin\n            if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid) begin\n                icb_state_nxt = ICB_STATE_IDLE;\n            end else begin\n                icb_state_nxt = ICB_STATE_2ND;\n            end\n        end\n        default: begin\n            icb_state_nxt = ICB_STATE_IDLE;\n        end\n    endcase\nend\n\n// ICB Command Generation\nassign ifu2itcm_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && ifu_req_valid;\nassign ifu2itcm_icb_cmd_addr = ifu_req_pc[ITCM_ADDR_WIDTH-1:0];\nassign ifu2biu_icb_cmd_valid = (icb_state == ICB_STATE_1ST) && !ifu_req_valid;\nassign ifu2biu_icb_cmd_addr = ifu_req_pc;\n\n// ICB Response Handling\nassign ifu_rsp_valid = (icb_state == ICB_STATE_1ST) && (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid);\nassign ifu_rsp_err = ifu2itcm_icb_rsp_err || ifu2biu_icb_rsp_err;\nassign ifu_rsp_instr = ifu2itcm_icb_rsp_rdata || ifu2biu_icb_rsp_rdata;\n\n// Handshake Control\nassign ifu_req_ready = (icb_state == ICB_STATE_IDLE) && ifu2itcm_icb_cmd_ready;\nassign ifu2itcm_icb_rsp_ready = (icb_state == ICB_STATE_1ST) && ifu_rsp_ready;\nassign ifu2biu_icb_rsp_ready = (icb_state == ICB_STATE_1ST) && ifu_rsp_ready;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 2, "code": "module e203_exu_branchslv(\n    input  logic                   cmt_i_valid,\n    output logic                   cmt_i_ready,\n    input  logic                   cmt_i_rv32,\n    input  logic                   cmt_i_dret,\n    input  logic                   cmt_i_mret,\n    input  logic                   cmt_i_fencei,\n    input  logic                   cmt_i_bjp,\n    input  logic                   cmt_i_bjp_prdt,\n    input  logic                   cmt_i_bjp_rslv,\n    input  logic [E203_PC_SIZE-1:0] cmt_i_pc,\n    input  logic [E203_XLEN-1:0]   cmt_i_imm,\n    input  logic [E203_PC_SIZE-1:0] csr_epc_r,\n    input  logic [E203_PC_SIZE-1:0] csr_dpc_r,\n    input  logic                   nonalu_excpirq_flush_req_raw,\n    input  logic                   brchmis_flush_ack,\n    output logic                   brchmis_flush_req,\n    output logic [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output logic [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output logic [E203_PC_SIZE-1:0] brchmis_flush_pc,\n    output logic                   cmt_mret_ena,\n    output logic                   cmt_dret_ena,\n    output logic                   cmt_fencei_ena,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n\n    // Flush Need Generation\n    logic flush_need;\n    assign flush_need = (cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv)) | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n\n    // Flush Target Calculation\n    always_comb begin\n        if (cmt_i_dret) begin\n            brchmis_flush_add_op1 = csr_dpc_r;\n            brchmis_flush_add_op2 = '0;\n        end else if (cmt_i_mret) begin\n            brchmis_flush_add_op1 = csr_epc_r;\n            brchmis_flush_add_op2 = '0;\n        end else if (cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv)) begin\n            if (cmt_i_bjp_prdt & ~cmt_i_bjp_rslv) begin // Predicted taken but actually not taken\n                if (cmt_i_rv32) begin\n                    brchmis_flush_add_op1 = cmt_i_pc + 32'd4;\n                    brchmis_flush_add_op2 = '0;\n                end else begin\n                    brchmis_flush_add_op1 = cmt_i_pc + 32'd2;\n                    brchmis_flush_add_op2 = '0;\n                end\n            end else begin // Predicted not taken but actually taken\n                brchmis_flush_add_op1 = cmt_i_pc;\n                brchmis_flush_add_op2 = cmt_i_imm;\n            end\n        end else begin\n            brchmis_flush_add_op1 = '0;\n            brchmis_flush_add_op2 = '0;\n        end\n    end\n\n    // Pipeline Flush Control\n    assign brchmis_flush_req = flush_need & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n\n    // Prioritizing Flush Sources\n    // Branch misprediction flushes are masked by non-ALU exception/interrupt flushes\n\n    // Controls the ready signal for the instruction\n    assign cmt_i_ready = ~(cmt_i_bjp | cmt_i_fencei | cmt_i_mret | cmt_i_dret) | (~nonalu_excpirq_flush_req_raw & (~flush_need | brchmis_flush_ack));\n\n    // Special Signal Commit\n    assign cmt_mret_ena = cmt_i_mret & cmt_i_valid & (~nonalu_excpirq_flush_req_raw) & (~flush_need | brchmis_flush_ack);\n    assign cmt_dret_ena = cmt_i_dret & cmt_i_valid & (~nonalu_excpirq_flush_req_raw) & (~flush_need | brchmis_flush_ack);\n    assign cmt_fencei_ena = cmt_i_fencei & cmt_i_valid & (~nonalu_excpirq_flush_req_raw) & (~flush_need | brchmis_flush_ack);\n\n    // Detailed brchmis_flush_pc Calculation Logic\n    generate\n        if (E203_TIMING_BOOST) begin\n            always_comb begin\n                if (cmt_i_fencei | (cmt_i_bjp & cmt_i_bjp_prdt)) begin\n                    // Next sequential instruction address\n                    if (cmt_i_rv32) begin\n                        brchmis_flush_pc = cmt_i_pc + 32'd4;\n                    end else begin\n                        brchmis_flush_pc = cmt_i_pc + 32'd2;\n                    end\n                end else if (cmt_i_bjp & (~cmt_i_bjp_prdt)) begin\n                    // Branch target address\n                    brchmis_flush_pc = cmt_i_pc + cmt_i_imm;\n                end else if (cmt_i_dret) begin\n                    // Debug Program Counter (DPC) register value\n                    brchmis_flush_pc = csr_dpc_r;\n                end else begin\n                    // Exception Program Counter (EPC) register value\n                    brchmis_flush_pc = csr_epc_r;\n                end\n            end\n        end else begin\n            assign brchmis_flush_pc = '0;\n        end\n    endgenerate\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 10, "code": "```    input  logic        clk,            // System clock\n    input  logic        rst_n,          // Asynchronous reset (active low)\n    input  logic        test_mode,      // Test mode signal\n    input  logic        core_cgstop,    // Clock-gated stop signal, from the CSR register\n    input  logic        core_ifu_active,// Instruction Fetch Unit active status\n    input  logic        core_exu_active,// Execution unit active state\n    input  logic        core_lsu_active,// Load storage cell active state\n    input  logic        core_biu_active,// Bus interface unit active statedt\n    input  logic        core_wfi,       // Wait for interrupt status signal\n    input  logic        itcm_active,    // ITCM active status (if E203_HAS_ITCM is defined)\n    input  logic        dtcm_active,    // DTCM active status (if E203_HAS_DTCM is defined)\n    output logic        clk_aon,        // Normally on clock\n    output logic        clk_core_ifu,   // IFU module clock\n    output logic        clk_core_exu,   // EXU module clock\n    output logic        clk_core_lsu,   // LSU module clock\n    output logic        clk_core_biu,   // BIU module clock\n    output logic        itcm_ls,        // ITCM clock low power state (if E203_HAS_ITCM is defined)\n    output logic        dtcm_ls,        // DTCM clock low power state (if E203_HAS_DTCM is defined)\n    output logic        clk_itcm,       // ITCM module clock (if E203_HAS_ITCM is defined)\n    output logic        clk_dtcm        // DTCM module clock (if E203_HAS_DTCM is defined)\n);\n\n// Define parameters for clock gating\nparameter  CG_IFU_ENABLE  = 1'b1;  // Enable clock gating for IFU\nparameter  CG_EXU_ENABLE  = 1'b1;  // Enable clock gating for EXU\nparameter  CG_LSU_ENABLE  = 1'b1;  // Enable clock gating for LSU\nparameter  CG_BIU_ENABLE  = 1'b1;  // Enable clock gating for BIU\n\n// Define parameters for ITCM and DTCM (if enabled)\n`ifdef E203_HAS_ITCM\nparameter  ITCM_ENABLE  = 1'b1;  // Enable ITCM\n`endif\n`ifdef E203_HAS_DTCM\nparameter  DTCM_ENABLE  = 1'b1;  // Enable DTCM\n`endif\n\n// Clock gating logic for each module\nlogic        clk_ifu_gate;\nlogic        clk_exu_gate;\nlogic        clk_lsu_gate;\nlogic        clk_biu_gate;\n\n// Clock enable logic for ITCM and DTCM (if enabled)\n`ifdef E203_HAS_ITCM\nlogic        itcm_clk_enable;\n`endif\n`ifdef E203_HAS_DTCM\nlogic        dtcm_clk_enable;\n`endif\n\n// Assign clock outputs based on clock gating and enable signals\nassign      clk_core_ifu  = (CG_IFU_ENABLE && clk_ifu_gate) ? clk : 1'b0;\nassign      clk_core_exu  = (CG_EXU_ENABLE && clk_exu_gate) ? clk : 1'b0;\nassign      clk_core_lsu  = (CG_LSU_ENABLE && clk_lsu_gate) ? clk : 1'b0;\nassign      clk_core_biu  = (CG_BIU_ENABLE && clk_biu_gate) ? clk : 1'b0;\n\n`ifdef E203_HAS_ITCM\nassign      clk_itcm      = (ITCM_ENABLE && itcm_clk_enable) ? clk : 1'b0;\n`endif\n`ifdef E203_HAS_DTCM\nassign      clk_dtcm      = (DTCM_ENABLE && dtcm_clk_enable) ? clk : 1'b0;\n`endif\n\n// Clock gating logic implementation\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        clk_ifu_gate  <= 1'b0;\n        clk_exu_gate  <= 1'b0;\n        clk_lsu_gate  <= 1'b0;\n        clk_biu_gate  <= 1'b0;\n        \n        `ifdef E203_HAS_ITCM\n        itcm_clk_enable <= 1'b0;\n        `endif\n        `ifdef E203_HAS_DTCM\n        dtcm_clk_enable <= 1'b0;\n        `endif\n    end else begin\n        // IFU clock gating\n        if (core_cgstop || (core_ifu_active && ~core_wfi)) begin\n            clk_ifu_gate  <= 1'b1;\n        end else begin\n            clk_ifu_gate  <= 1'b0;\n        end\n        \n        // EXU clock gating\n        if (core_cgstop || core_exu_active) begin\n            clk_exu_gate  <= 1'b1;\n        end else begin\n            clk_exu_gate  <= 1'b0;\n        end\n        \n        // LSU clock gating\n        if (core_cgstop || core_lsu_active) begin\n            clk_lsu_gate  <= 1'b1;\n        end else begin\n            clk_lsu_gate  <= 1'b0;\n        end\n        \n        // BIU clock gating\n        if (core_cgstop || core_biu_active) begin\n            clk_biu_gate  <= 1'b1;\n        end else begin\n            clk_biu_gate  <= 1'b0;\n        end\n        \n        // ITCM clock enable (if enabled)\n        `ifdef E203_HAS_ITCM\n        if (core_cgstop || itcm_active) begin\n            itcm_clk_enable <= 1'b1;\n        end else begin\n            itcm_clk_enable <= 1'b0;\n        end\n        `endif\n        \n        // DTCM clock enable (if enabled)\n        `ifdef E203_HAS_DTCM\n        if (core_cgstop || dtcm_active) begin\n            dtcm_clk_enable <= 1'b1;\n        end else begin\n            dtcm_clk_enable <= 1'b0;\n        end\n        `endif\n    end\nend\n\n// Low power state signals for ITCM and DTCM (if enabled)\n`ifdef E203_HAS_ITCM\nassign      itcm_ls       = ~itcm_clk_enable;\n`endif\n`ifdef E203_HAS_DTCM\nassign      dtcm_ls       = ~dtcm_clk_enable;\n`endif\n\n// Normally on clock\nassign      clk_aon       = clk;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 3, "code": "module e203_ifu_ift2icb (\n    input  logic                    itcm_nohold,\n    input  logic                    ifu_req_valid,\n    input  logic [E203_PC_SIZE-1:0] ifu_req_pc,\n    input  logic                    ifu_req_seq,\n    input  logic                    ifu_req_seq_rv32,\n    input  logic [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input  logic                    ifu_rsp_ready,\n    input  logic                    clk,\n    input  logic                    rst_n,\n\n    output logic                    ifu_req_ready,\n    output logic                    ifu_rsp_valid,\n    output logic                    ifu_rsp_err,\n    output logic [31:0]             ifu_rsp_instr,\n\n    // ITCM Interface\n    output logic                    ifu2itcm_icb_cmd_valid,\n    input  logic                    ifu2itcm_icb_cmd_ready,\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input  logic                    ifu2itcm_icb_rsp_valid,\n    output logic                    ifu2itcm_icb_rsp_ready,\n    input  logic                    ifu2itcm_icb_rsp_err,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // System Memory Interface\n    output logic                    ifu2biu_icb_cmd_valid,\n    input  logic                    ifu2biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input  logic                    ifu2biu_icb_rsp_valid,\n    output logic                    ifu2biu_icb_rsp_ready,\n    input  logic                    ifu2biu_icb_rsp_err,\n    input  logic [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n// State Machine Implementation\nlogic [1:0] icb_state;\nlogic icb_state_ena;\nlogic [1:0] icb_state_nxt;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        icb_state <= 2'b00;\n    end else if (icb_state_ena) begin\n        icb_state <= icb_state_nxt;\n    end\nend\n\n// Bypass Buffer Implementation\nlogic ifu_rsp_bypbuf_i_vld;\nlogic ifu_rsp_bypbuf_i_rdy;\nlogic [32:0] ifu_rsp_bypbuf_i_data;\nlogic ifu_rsp_bypbuf_o_vld;\nlogic ifu_rsp_bypbuf_o_rdy;\nlogic [32:0] ifu_rsp_bypbuf_o_data;\n\nsirv_gnrl_bypbuf #(\n    .DP(1),\n    .DW(33)\n) ifu_rsp_bypbuf_inst (\n    .i_vld(ifu_rsp_bypbuf_i_vld),\n    .i_rdy(ifu_rsp_bypbuf_i_rdy),\n    .i_dat(ifu_rsp_bypbuf_i_data),\n    .o_vld(ifu_rsp_bypbuf_o_vld),\n    .o_rdy(ifu_rsp_bypbuf_o_rdy),\n    .o_dat(ifu_rsp_bypbuf_o_data),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Lane Operation Implementation\nlogic ifu_req_lane_cross;\nlogic ifu_req_lane_begin;\nlogic ifu_req_lane_same;\nlogic ifu_req_lane_holdup;\n\n// Request Feature Registering\nlogic req_same_cross_holdup_r;\nlogic req_need_2uop_r;\nlogic req_need_0uop_r;\n\n// Leftover Buffer Implementation\nlogic holdup2leftover_ena;\nlogic uop1st2leftover_ena;\nlogic [15:0] leftover_nxt;\nlogic leftover_err_nxt;\n\n// Response Generation Implementation\nlogic rsp_instr_sel_leftover;\nlogic [31:0] rsp_instr;\nlogic i_ifu_rsp_valid;\nlogic i_ifu_rsp_err;\n\n// ICB Command Generation Implementation\nlogic ifu_icb_cmd_valid;\nlogic [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr;\n\n// ICB Response Merge Implementation\nlogic ifu_icb_rsp_err;\nlogic ifu_icb_rsp_valid;\n\n// ICB Request Distribution Implementation\nlogic ifu_icb_cmd2biu;\nlogic ifu2biu_icb_cmd_valid;\nlogic ifu2biu_icb_cmd_addr;\n\n// System Memory Interface Implementation\nlogic ifu2biu_icb_cmd_valid_pre;\nlogic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr_pre;\n\n// Handshake Control Implementation\nlogic ifu_req_ready_condi;\nlogic ifu_icb_rsp_ready;\n\n// Data Alignment Implementation\nlogic [15:0] ifu_icb_rsp_rdata_lsb16;\n\n// Assign output signals\nassign ifu_req_ready = ifu_icb_cmd_ready & ifu_req_ready_condi;\nassign ifu_rsp_valid = i_ifu_rsp_valid;\nassign ifu_rsp_err = i_ifu_rsp_err;\nassign ifu_rsp_instr = rsp_instr;\n\n// ITCM Interface\nassign ifu2itcm_icb_cmd_valid = ifu_icb_cmd_valid & ifu_icb_cmd2itcm;\nassign ifu2itcm_icb_cmd_addr = ifu_icb_cmd_addr;\nassign ifu2itcm_icb_rsp_ready = ifu_icb_rsp_ready;\n\n// System Memory Interface\nassign ifu2biu_icb_cmd_valid = ifu2biu_icb_cmd_valid_pre;\nassign ifu2biu_icb_cmd_addr = ifu2biu_icb_cmd_addr_pre;\nassign ifu2biu_icb_rsp_ready = ifu_icb_rsp_ready;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 2, "code": "// Define parameters\nparameter E203_XLEN = 32;\nparameter E203_ADDR_SIZE = 32;\nparameter E203_ITAG_WIDTH = 2;\nparameter E203_DECINFO_AGU_WIDTH = 14;\n\n// Define module\nmodule e203_exu_alu_lsuagu (\n    input  logic                   agu_i_valid,\n    output logic                   agu_i_ready,\n    input  logic [E203_XLEN-1:0]   agu_i_rs1,\n    input  logic [E203_XLEN-1:0]   agu_i_rs2,\n    input  logic [E203_XLEN-1:0]   agu_i_imm,\n    input  logic [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input  logic [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output logic                   agu_i_longpipe,\n    input  logic                   flush_req,\n    input  logic                   flush_pulse,\n    output logic                   amo_wait,\n    input  logic                   oitf_empty,\n    output logic                   agu_o_valid,\n    input  logic                   agu_o_ready,\n    output logic [E203_XLEN-1:0]   agu_o_wbck_wdat,\n    output logic                   agu_o_wbck_err,\n    output logic                   agu_o_cmt_misalgn,\n    output logic                   agu_o_cmt_ld,\n    output logic                   agu_o_cmt_stamo,\n    output logic                   agu_o_cmt_buserr,\n    output logic [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output logic                   agu_icb_cmd_valid,\n    input  logic                   agu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output logic                   agu_icb_cmd_read,\n    output logic [E203_XLEN-1:0]   agu_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    output logic                   agu_icb_cmd_back2agu,\n    output logic                   agu_icb_cmd_lock,\n    output logic                   agu_icb_cmd_excl,\n    output logic [1:0]             agu_icb_cmd_size,\n    output logic [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output logic                   agu_icb_cmd_usign,\n    input  logic                   agu_icb_rsp_valid,\n    output logic                   agu_icb_rsp_ready,\n    input  logic                   agu_icb_rsp_err,\n    input  logic                   agu_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0]   agu_icb_rsp_rdata,\n    output logic [E203_XLEN-1:0]   agu_req_alu_op1,\n    output logic [E203_XLEN-1:0]   agu_req_alu_op2,\n    output logic                   agu_req_alu_swap,\n    output logic                   agu_req_alu_add,\n    output logic                   agu_req_alu_and,\n    output logic                   agu_req_alu_or,\n    output logic                   agu_req_alu_xor,\n    output logic                   agu_req_alu_max,\n    output logic                   agu_req_alu_min,\n    output logic                   agu_req_alu_maxu,\n    output logic                   agu_req_alu_minu,\n    input  logic [E203_XLEN-1:0]   agu_req_alu_res,\n    output logic                   agu_sbf_0_ena,\n    output logic [E203_XLEN-1:0]   agu_sbf_0_nxt,\n    input  logic [E203_XLEN-1:0]   agu_sbf_0_r,\n    output logic                   agu_sbf_1_ena,\n    output logic [E203_XLEN-1:0]   agu_sbf_1_nxt,\n    input  logic [E203_XLEN-1:0]   agu_sbf_1_r,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n\n// Implement AGU logic\nalways @(posedge clk) begin\n    if (~rst_n) begin\n        // Reset logic\n        agu_i_ready <= 1'b0;\n        agu_o_valid <= 1'b0;\n        // ...\n    end else begin\n        // Normal operation logic\n        if (agu_i_valid) begin\n            // Perform address calculation\n            agu_icb_cmd_addr <= agu_i_rs1 + agu_i_imm;\n            // ...\n        end\n        // ...\n    end\nend\n\n// Implement state machine\nalways @(posedge clk) begin\n    if (~rst_n) begin\n        // Reset state machine\n        state <= IDLE;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (agu_i_valid) begin\n                    state <= ICB_STATE_1ST;\n                end\n            end\n            ICB_STATE_1ST: begin\n                if (agu_icb_rsp_valid) begin\n                    state <= ICB_STATE_AMOALU;\n                end\n            end\n            // ...\n        endcase\n    end\nend\n\n// Implement combinational logic\nassign agu_i_longpipe = (state == ICB_STATE_AMOALU);\nassign amo_wait = (state == ICB_STATE_AMOALU);\nassign agu_o_wbck_wdat = agu_req_alu_res;\n// ...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 2, "code": "// Import necessary definitions\n`include \"e203_defines.v\"\n\nmodule e203_exu_longpwbck(\n    // LSU Interface\n    input  logic                           lsu_wbck_i_valid,\n    output logic                           lsu_wbck_i_ready,\n    input  logic [E203_XLEN-1:0]           lsu_wbck_i_wdat,\n    input  logic [E203_ITAG_WIDTH-1:0]     lsu_wbck_i_itag,\n    input  logic                           lsu_wbck_i_err,\n    input  logic                           lsu_cmt_i_buserr,\n    input  logic [E203_ADDR_SIZE-1:0]      lsu_cmt_i_badaddr,\n    input  logic                           lsu_cmt_i_ld,\n    input  logic                           lsu_cmt_i_st,\n\n    // NICE Interface (if E203_HAS_NICE is defined)\n    `ifdef E203_HAS_NICE\n    input  logic                           nice_longp_wbck_i_valid,\n    output logic                           nice_longp_wbck_i_ready,\n    input  logic [E203_XLEN-1:0]           nice_longp_wbck_i_wdat,\n    input  logic [E203_ITAG_WIDTH-1:0]     nice_longp_wbck_i_itag,\n    input  logic                           nice_longp_wbck_i_err,\n    `endif\n\n    // Write-Back Interface\n    output logic                           longp_wbck_o_valid,\n    input  logic                           longp_wbck_o_ready,\n    output logic [E203_FLEN-1:0]           longp_wbck_o_wdat,\n    output logic [4:0]                     longp_wbck_o_flags,\n    output logic [E203_RFIDX_WIDTH-1:0]    longp_wbck_o_rdidx,\n    output logic                           longp_wbck_o_rdfpu,\n\n    // Exception Interface\n    output logic                           longp_excp_o_valid,\n    input  logic                           longp_excp_o_ready,\n    output logic                           longp_excp_o_insterr,\n    output logic                           longp_excp_o_ld,\n    output logic                           longp_excp_o_st,\n    output logic                           longp_excp_o_buserr,\n    output logic [E203_ADDR_SIZE-1:0]      longp_excp_o_badaddr,\n    output logic [E203_PC_SIZE-1:0]        longp_excp_o_pc,\n\n    // OITF Interface\n    input  logic                           oitf_empty,\n    input  logic [E203_ITAG_WIDTH-1:0]     oitf_ret_ptr,\n    input  logic [E203_RFIDX_WIDTH-1:0]    oitf_ret_rdidx,\n    input  logic [E203_PC_SIZE-1:0]        oitf_ret_pc,\n    input  logic                           oitf_ret_rdwen,\n    input  logic                           oitf_ret_rdfpu,\n    output logic                           oitf_ret_ena,\n\n    // Clock and Reset\n    input  logic                           clk,\n    input  logic                           rst_n\n);\n\n// Internal signals\nlogic lsu_wbck_need;\nlogic lsu_excp_need;\nlogic nice_wbck_need;\nlogic nice_excp_need;\nlogic wbck_i_ready;\nlogic wbck_i_valid;\nlogic [E203_XLEN-1:0] wbck_i_wdat;\nlogic [E203_ITAG_WIDTH-1:0] wbck_i_itag;\n\n// LSU Write-Back Need and Exception Need\nassign lsu_wbck_need = lsu_wbck_i_valid & ~lsu_wbck_i_err & oitf_ret_rdwen;\nassign lsu_excp_need = lsu_wbck_i_valid & (lsu_wbck_i_err | lsu_cmt_i_buserr);\n\n// NICE Write-Back Need and Exception Need (if E203_HAS_NICE is defined)\n`ifdef E203_HAS_NICE\nassign nice_wbck_need = nice_longp_wbck_i_valid & ~nice_longp_wbck_i_err;\nassign nice_excp_need = nice_longp_wbck_i_valid & nice_longp_wbck_i_err;\n`endif\n\n// Write-Back Ready Signal\nassign wbck_i_ready = (lsu_wbck_need | nice_wbck_need) ? longp_wbck_o_ready : 1'b1;\nassign lsu_wbck_i_ready = wbck_i_ready & ~lsu_excp_need & ~nice_excp_need;\n`ifdef E203_HAS_NICE\nassign nice_longp_wbck_i_ready = wbck_i_ready & ~lsu_excp_need & ~nice_excp_need;\n`endif\n\n// Write-Back Valid Signal\nassign wbck_i_valid = lsu_wbck_i_valid | `ifdef E203_HAS_NICE nice_longp_wbck_i_valid `endif;\nassign longp_wbck_o_valid = wbck_i_valid & (lsu_wbck_need | nice_wbck_need);\n\n// Write-Back Data and Flags\nassign wbck_i_wdat = lsu_wbck_i_wdat;\nassign longp_wbck_o_wdat = wbck_i_wdat;\nassign longp_wbck_o_flags = {lsu_cmt_i_ld, lsu_cmt_i_st, lsu_wbck_i_err, lsu_cmt_i_buserr, 1'b0};\n\n// Exception Valid Signal\nassign longp_excp_o_valid = (lsu_excp_need | nice_excp_need) & wbck_i_valid;\n\n// Exception Signals\nassign longp_excp_o_insterr = lsu_wbck_i_err;\nassign longp_excp_o_ld = lsu_cmt_i_ld;\nassign longp_excp_o_st = lsu_cmt_i_st;\nassign longp_excp_o_buserr = lsu_cmt_i_buserr;\nassign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\nassign longp_excp_o_pc = oitf_ret_pc;\n\n// OITF Retire Enable\nassign oitf_ret_ena = wbck_i_ready & wbck_i_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 4, "code": "// Import necessary files\n`include \"e203_defines.v\"\n\nmodule e203_ifu_ift2icb (\n    // Input signals\n    input  logic                   itcm_nohold,\n    input  logic                   ifu_req_valid,\n    input  logic [E203_PC_SIZE-1:0] ifu_req_pc,\n    input  logic                   ifu_req_seq,\n    input  logic                   ifu_req_seq_rv32,\n    input  logic [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input  logic                   ifu_rsp_ready,\n    input  logic                   clk,\n    input  logic                   rst_n,\n\n    // Output signals\n    output logic                   ifu_req_ready,\n    output logic                   ifu_rsp_valid,\n    output logic                   ifu_rsp_err,\n    output logic [31:0]            ifu_rsp_instr,\n\n    // ITCM interface\n    output logic                   ifu2itcm_icb_cmd_valid,\n    input  logic                   ifu2itcm_icb_cmd_ready,\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input  logic                   ifu2itcm_icb_rsp_valid,\n    output logic                   ifu2itcm_icb_rsp_ready,\n    input  logic                   ifu2itcm_icb_rsp_err,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // System memory interface\n    output logic                   ifu2biu_icb_cmd_valid,\n    input  logic                   ifu2biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input  logic                   ifu2biu_icb_rsp_valid,\n    output logic                   ifu2biu_icb_rsp_ready,\n    input  logic                   ifu2biu_icb_rsp_err,\n    input  logic [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n// State machine implementation\nlogic [1:0] icb_state;\nlogic icb_state_ena;\nlogic [1:0] icb_state_nxt;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        icb_state <= 2'b00;\n    end else if (icb_state_ena) begin\n        icb_state <= icb_state_nxt;\n    end\nend\n\n// Bypass buffer implementation\nlogic ifu_rsp_bypbuf_i_vld;\nlogic ifu_rsp_bypbuf_i_rdy;\nlogic [32:0] ifu_rsp_bypbuf_i_dat;\nlogic ifu_rsp_bypbuf_o_vld;\nlogic ifu_rsp_bypbuf_o_rdy;\nlogic [32:0] ifu_rsp_bypbuf_o_dat;\n\nsirv_gnrl_bypbuf #(\n    .DP(1),\n    .DW(33)\n) ifu_rsp_bypbuf_inst (\n    .i_vld(ifu_rsp_bypbuf_i_vld),\n    .i_rdy(ifu_rsp_bypbuf_i_rdy),\n    .i_dat(ifu_rsp_bypbuf_i_dat),\n    .o_vld(ifu_rsp_bypbuf_o_vld),\n    .o_rdy(ifu_rsp_bypbuf_o_rdy),\n    .o_dat(ifu_rsp_bypbuf_o_dat),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Lane operation implementation\nlogic ifu_req_lane_cross;\nlogic ifu_req_lane_begin;\nlogic ifu_req_lane_same;\nlogic ifu_req_lane_holdup;\n\n// Request feature registering\nlogic req_same_cross_holdup_r;\nlogic req_need_2uop_r;\nlogic req_need_0uop_r;\nlogic icb_cmd2itcm_r;\nlogic icb_cmd2biu_r;\n\n// Leftover buffer implementation\nlogic holdup2leftover_ena;\nlogic uop1st2leftover_ena;\nlogic [15:0] leftover_nxt;\nlogic leftover_err_nxt;\n\n// Response generation implementation\nlogic rsp_instr_sel_leftover;\nlogic [31:0] rsp_instr;\nlogic i_ifu_rsp_valid;\nlogic i_ifu_rsp_err;\n\n// ICB command generation implementation\nlogic ifu_icb_cmd_valid;\nlogic [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr;\nlogic ifu_icb_cmd2itcm;\nlogic ifu_icb_cmd2biu;\n\n// Handshake control implementation\nlogic ifu_req_ready_int;\nlogic ifu_icb_rsp_ready_int;\n\n// Data alignment implementation\nlogic [15:0] ifu_icb_rsp_rdata_lsb16;\n\n// ICB response merge implementation\nlogic ifu_icb_rsp_err;\nlogic ifu_icb_rsp_valid;\n\n// ICB request distribution implementation\nlogic ifu2biu_icb_cmd_valid_pre;\nlogic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr_pre;\n\n// Assign output signals\nassign ifu_req_ready = ifu_req_ready_int;\nassign ifu_rsp_valid = ifu_rsp_bypbuf_o_vld;\nassign ifu_rsp_err = ifu_rsp_bypbuf_o_dat[32];\nassign ifu_rsp_instr = ifu_rsp_bypbuf_o_dat[31:0];\n\nassign ifu2itcm_icb_cmd_valid = ifu_icb_cmd_valid && ifu_icb_cmd2itcm;\nassign ifu2itcm_icb_cmd_addr = ifu_icb_cmd_addr;\nassign ifu2itcm_icb_rsp_ready = ifu_icb_rsp_ready_int;\n\nassign ifu2biu_icb_cmd_valid = ifu2biu_icb_cmd_valid_pre;\nassign ifu2biu_icb_cmd_addr = ifu2biu_icb_cmd_addr_pre;\nassign ifu2biu_icb_rsp_ready = ifu_icb_rsp_ready_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_alu_dpath(\n    input  logic                            alu_req_alu,\n    input  logic                            alu_req_alu_add,\n    input  logic                            alu_req_alu_sub,\n    input  logic                            alu_req_alu_xor,\n    input  logic                            alu_req_alu_sll,\n    input  logic                            alu_req_alu_srl,\n    input  logic                            alu_req_alu_sra,\n    input  logic                            alu_req_alu_or,\n    input  logic                            alu_req_alu_and,\n    input  logic [E203_XLEN-1:0]            alu_req_alu_op1,\n    input  logic [E203_XLEN-1:0]            alu_req_alu_op2,\n    input  logic                            bjp_req_alu,\n    input  logic [E203_XLEN-1:0]            bjp_req_alu_op1,\n    input  logic [E203_XLEN-1:0]            bjp_req_alu_op2,\n    input  logic                            agu_req_alu,\n    input  logic [E203_XLEN-1:0]            agu_req_alu_op1,\n    input  logic [E203_XLEN-1:0]            agu_req_alu_op2,\n    input  logic                            muldiv_req_alu,\n    input  logic [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input  logic [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input  logic                            muldiv_req_alu_add,\n    input  logic                            muldiv_req_alu_sub,\n    input  logic                            muldiv_sbf_0_ena,\n    input  logic [32:0]                     muldiv_sbf_0_nxt,\n    input  logic                            muldiv_sbf_1_ena,\n    input  logic [32:0]                     muldiv_sbf_1_nxt,\n    input  logic                            clk,\n    input  logic                            rst_n,\n    output logic [E203_XLEN-1:0]            alu_req_alu_res,\n    output logic [E203_XLEN-1:0]            bjp_req_alu_add_res,\n    output logic                            bjp_req_alu_cmp_res,\n    output logic [E203_XLEN-1:0]            agu_req_alu_res,\n    output logic [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output logic [32:0]                     muldiv_sbf_0_r,\n    output logic [32:0]                     muldiv_sbf_1_r\n);\n\n// Shared buffer 0\nsirv_gnrl_dffl #(\n    .DW(33)\n) sbf_0_dffl(\n    .lden(muldiv_sbf_0_ena),\n    .dnxt(muldiv_sbf_0_nxt),\n    .qout(muldiv_sbf_0_r),\n    .clk(clk)\n);\n\n// Shared buffer 1\nsirv_gnrl_dffl #(\n    .DW(33)\n) sbf_1_dffl(\n    .lden(muldiv_sbf_1_ena),\n    .dnxt(muldiv_sbf_1_nxt),\n    .qout(muldiv_sbf_1_r),\n    .clk(clk)\n);\n\n// ALU operations\nalways @(posedge clk) begin\n    if (alu_req_alu) begin\n        if (alu_req_alu_add) begin\n            alu_req_alu_res <= alu_req_alu_op1 + alu_req_alu_op2;\n        end else if (alu_req_alu_sub) begin\n            alu_req_alu_res <= alu_req_alu_op1 - alu_req_alu_op2;\n        end else if (alu_req_alu_xor) begin\n            alu_req_alu_res <= alu_req_alu_op1 ^ alu_req_alu_op2;\n        end else if (alu_req_alu_sll) begin\n            alu_req_alu_res <= alu_req_alu_op1 << alu_req_alu_op2;\n        end else if (alu_req_alu_srl) begin\n            alu_req_alu_res <= alu_req_alu_op1 >> alu_req_alu_op2;\n        end else if (alu_req_alu_sra) begin\n            alu_req_alu_res <= alu_req_alu_op1 >>> alu_req_alu_op2;\n        end else if (alu_req_alu_or) begin\n            alu_req_alu_res <= alu_req_alu_op1 | alu_req_alu_op2;\n        end else if (alu_req_alu_and) begin\n            alu_req_alu_res <= alu_req_alu_op1 & alu_req_alu_op2;\n        end\n    end\nend\n\n// BJP operations\nalways @(posedge clk) begin\n    if (bjp_req_alu) begin\n        if (bjp_req_alu_add_res) begin\n            bjp_req_alu_add_res <= bjp_req_alu_op1 + bjp_req_alu_op2;\n        end\n        bjp_req_alu_cmp_res <= (bjp_req_alu_op1 == bjp_req_alu_op2);\n    end\nend\n\n// AGU operations\nalways @(posedge clk) begin\n    if (agu_req_alu) begin\n        agu_req_alu_res <= agu_req_alu_op1 + agu_req_alu_op2;\n    end\nend\n\n// MULDIV operations\nalways @(posedge clk) begin\n    if (muldiv_req_alu) begin\n        if (muldiv_req_alu_add) begin\n            muldiv_req_alu_res <= muldiv_req_alu_op1 + muldiv_req_alu_op2;\n        end else if (muldiv_req_alu_sub) begin\n            muldiv_req_alu_res <= muldiv_req_alu_op1 - muldiv_req_alu_op2;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 1, "code": "module e203_lsu_ctrl(\n    input  logic commit_mret,\n    input  logic commit_trap,\n    output logic lsu_ctrl_active,\n    // LSU Write-back Interface\n    output logic lsu_o_valid,\n    input  logic lsu_o_ready,\n    output logic [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output logic [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output logic lsu_o_wbck_err,\n    output logic lsu_o_cmt_buserr,\n    output logic [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output logic lsu_o_cmt_ld,\n    output logic lsu_o_cmt_st,\n    // AGU-ICB Interface\n    input  logic agu_icb_cmd_valid,\n    output logic agu_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input  logic agu_icb_cmd_read,\n    input  logic [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    input  logic agu_icb_cmd_lock,\n    input  logic agu_icb_cmd_excl,\n    input  logic [1:0] agu_icb_cmd_size,\n    input  logic agu_icb_cmd_back2agu,\n    input  logic agu_icb_cmd_usign,\n    input  logic [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output logic agu_icb_rsp_valid,\n    input  logic agu_icb_rsp_ready,\n    output logic agu_icb_rsp_err,\n    output logic agu_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    // NICE Interface (Optional Configuration)\n    input  logic nice_mem_holdup,\n    input  logic nice_icb_cmd_valid,\n    output logic nice_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input  logic nice_icb_cmd_read,\n    input  logic [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] nice_icb_cmd_wmask,\n    output logic nice_icb_rsp_valid,\n    input  logic nice_icb_rsp_ready,\n    output logic nice_icb_rsp_err,\n    output logic [E203_XLEN-1:0] nice_icb_rsp_rdata,\n    // Memory Interfaces\n    output logic dcache_icb_cmd_valid,\n    input  logic dcache_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output logic dcache_icb_cmd_read,\n    output logic [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] dcache_icb_cmd_wmask,\n    output logic dcache_icb_cmd_lock,\n    output logic dcache_icb_cmd_excl,\n    output logic [1:0] dcache_icb_cmd_size,\n    input  logic dcache_icb_rsp_valid,\n    output logic dcache_icb_rsp_ready,\n    input  logic dcache_icb_rsp_err,\n    input  logic dcache_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n    output logic dtcm_icb_cmd_valid,\n    input  logic dtcm_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] dtcm_icb_cmd_addr,\n    output logic dtcm_icb_cmd_read,\n    output logic [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] dtcm_icb_cmd_wmask,\n    output logic dtcm_icb_cmd_lock,\n    output logic dtcm_icb_cmd_excl,\n    output logic [1:0] dtcm_icb_cmd_size,\n    input  logic dtcm_icb_rsp_valid,\n    output logic dtcm_icb_rsp_ready,\n    input  logic dtcm_icb_rsp_err,\n    input  logic dtcm_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input  logic [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n    output logic itcm_icb_cmd_valid,\n    input  logic itcm_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] itcm_icb_cmd_addr,\n    output logic itcm_icb_cmd_read,\n    output logic [E203_XLEN-1:0] itcm_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] itcm_icb_cmd_wmask,\n    output logic itcm_icb_cmd_lock,\n    output logic itcm_icb_cmd_excl,\n    output logic [1:0] itcm_icb_cmd_size,\n    input  logic itcm_icb_rsp_valid,\n    output logic itcm_icb_rsp_ready,\n    input  logic itcm_icb_rsp_err,\n    input  logic itcm_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] itcm_icb_rsp_rdata,\n    input  logic [E203_ADDR_SIZE-1:0] itcm_region_indic,\n    output logic biu_icb_cmd_valid,\n    input  logic biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output logic biu_icb_cmd_read,\n    output logic [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] biu_icb_cmd_wmask,\n    output logic biu_icb_cmd_lock,\n    output logic biu_icb_cmd_excl,\n    output logic [1:0] biu_icb_cmd_size,\n    input  logic biu_icb_rsp_valid,\n    output logic biu_icb_rsp_ready,\n    input  logic biu_icb_rsp_err,\n    input  logic biu_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n\n// ... rest of the module implementation ...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 2, "code": "module e203_exu_alu_bjp(\n    input  logic                   bjp_i_valid,\n    output logic                   bjp_i_ready,\n    input  logic [E203_XLEN-1:0]   bjp_i_rs1,\n    input  logic [E203_XLEN-1:0]   bjp_i_rs2,\n    input  logic [E203_XLEN-1:0]   bjp_i_imm,\n    input  logic [E203_PC_SIZE-1:0]bjp_i_pc,\n    input  logic [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output logic                   bjp_o_valid,\n    input  logic                   bjp_o_ready,\n    output logic [E203_XLEN-1:0]   bjp_o_wbck_wdat,\n    output logic                   bjp_o_wbck_err,\n    output logic                   bjp_o_cmt_bjp,\n    output logic                   bjp_o_cmt_mret,\n    output logic                   bjp_o_cmt_dret,\n    output logic                   bjp_o_cmt_fencei,\n    output logic                   bjp_o_cmt_prdt,\n    output logic                   bjp_o_cmt_rslv,\n    output logic [E203_XLEN-1:0]   bjp_req_alu_op1,\n    output logic [E203_XLEN-1:0]   bjp_req_alu_op2,\n    output logic                   bjp_req_alu_cmp_eq,\n    output logic                   bjp_req_alu_cmp_ne,\n    output logic                   bjp_req_alu_cmp_lt,\n    output logic                   bjp_req_alu_cmp_gt,\n    output logic                   bjp_req_alu_cmp_ltu,\n    output logic                   bjp_req_alu_cmp_gtu,\n    output logic                   bjp_req_alu_add,\n    input  logic                   bjp_req_alu_cmp_res,\n    input  logic [E203_XLEN-1:0]   bjp_req_alu_add_res,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n\n// Valid-Ready Handshake\nassign bjp_o_valid = bjp_i_valid;\nassign bjp_i_ready = bjp_o_ready;\n\n// Operand Selection\nalways_comb begin\n    if (bjp_i_info[E203_DECINFO_BJP_JUMP]) begin\n        bjp_req_alu_op1 = bjp_i_pc;\n    end else begin\n        bjp_req_alu_op1 = bjp_i_rs1;\n    end\n    \n    if (bjp_i_info[E203_DECINFO_BJP_JUMP]) begin\n        bjp_req_alu_op2 = (E203_CFG_ADDR_SIZE_IS_32) ? 32'd4 : 32'd2;\n    end else begin\n        bjp_req_alu_op2 = bjp_i_rs2;\n    end\nend\n\n// Generating ALU Requests\nalways_comb begin\n    bjp_req_alu_cmp_eq = 1'b0;\n    bjp_req_alu_cmp_ne = 1'b0;\n    bjp_req_alu_cmp_lt = 1'b0;\n    bjp_req_alu_cmp_gt = 1'b0;\n    bjp_req_alu_cmp_ltu = 1'b0;\n    bjp_req_alu_cmp_gtu = 1'b0;\n    bjp_req_alu_add = 1'b0;\n    \n    if (bjp_i_info[E203_DECINFO_BJP_BEQ]) begin\n        bjp_req_alu_cmp_eq = 1'b1;\n    end else if (bjp_i_info[E203_DECINFO_BJP_BNE]) begin\n        bjp_req_alu_cmp_ne = 1'b1;\n    end else if (bjp_i_info[E203_DECINFO_BJP_BLT]) begin\n        bjp_req_alu_cmp_lt = 1'b1;\n    end else if (bjp_i_info[E203_DECINFO_BJP_BGT]) begin\n        bjp_req_alu_cmp_gt = 1'b1;\n    end else if (bjp_i_info[E203_DECINFO_BJP_BLTU]) begin\n        bjp_req_alu_cmp_ltu = 1'b1;\n    end else if (bjp_i_info[E203_DECINFO_BJP_BGTU]) begin\n        bjp_req_alu_cmp_gtu = 1'b1;\n    end else if (bjp_i_info[E203_DECINFO_BJP_JUMP]) begin\n        bjp_req_alu_add = 1'b1;\n    end\nend\n\n// Retrieving Results from the ALU\nalways_comb begin\n    bjp_o_cmt_rslv = 1'b0;\n    if (bjp_i_info[E203_DECINFO_BJP_BEQ] && bjp_req_alu_cmp_res) begin\n        bjp_o_cmt_rslv = 1'b1;\n    end else if (bjp_i_info[E203_DECINFO_BJP_BNE] && ~bjp_req_alu_cmp_res) begin\n        bjp_o_cmt_rslv = 1'b1;\n    end else if (bjp_i_info[E203_DECINFO_BJP_BLT] && bjp_req_alu_cmp_res) begin\n        bjp_o_cmt_rslv = 1'b1;\n    end else if (bjp_i_info[E203_DECINFO_BJP_BGT] && ~bjp_req_alu_cmp_res) begin\n        bjp_o_cmt_rslv = 1'b1;\n    end else if (bjp_i_info[E203_DECINFO_BJP_BLTU] && bjp_req_alu_cmp_res) begin\n        bjp_o_cmt_rslv = 1'b1;\n    end else if (bjp_i_info[E203_DECINFO_BJP_BGTU] && ~bjp_req_alu_cmp_res) begin\n        bjp_o_cmt_rslv = 1'b1;\n    end else if (bjp_i_info[E203_DECINFO_BJP_JUMP]) begin\n        bjp_o_cmt_rslv = 1'b1;\n    end\nend\n\n// Communication with Commit Module\nalways_comb begin\n    bjp_o_cmt_bjp = bjp_i_info[E203_DECINFO_BJP_BJP];\n    bjp_o_cmt_mret = bjp_i_info[E203_DECINFO_BJP_MRET];\n    bjp_o_cmt_dret = bjp_i_info[E203_DECINFO_BJP_DRET];\n    bjp_o_cmt_fencei = bjp_i_info[E203_DECINFO_BJP_FENCEI];\n    bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\nend\n\n// Write Back Data Transfer\nassign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n\n// Write Back Error Generation\nassign bjp_o_wbck_err = 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 2, "code": "module itcm_controller (\n    input  logic                   clk,\n    input  logic                   rst_n,\n\n    // IFU Interface\n    input  logic                   ifu2itcm_icb_cmd_valid,\n    output logic                   ifu2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input  logic                   ifu2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_DATA_WIDTH/8-1:0] ifu2itcm_icb_cmd_wmask,\n    output logic                   ifu2itcm_icb_rsp_valid,\n    input  logic                   ifu2itcm_icb_rsp_ready,\n    output logic                   ifu2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input  logic                   lsu2itcm_icb_cmd_valid,\n    output logic                   lsu2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input  logic                   lsu2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_DATA_WIDTH/8-1:0] lsu2itcm_icb_cmd_wmask,\n    output logic                   lsu2itcm_icb_rsp_valid,\n    input  logic                   lsu2itcm_icb_rsp_ready,\n    output logic                   lsu2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // External Interface (if enabled)\n    input  logic                   ext2itcm_icb_cmd_valid,\n    output logic                   ext2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input  logic                   ext2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ext2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_DATA_WIDTH/8-1:0] ext2itcm_icb_cmd_wmask,\n    output logic                   ext2itcm_icb_rsp_valid,\n    input  logic                   ext2itcm_icb_rsp_ready,\n    output logic                   ext2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] ext2itcm_icb_rsp_rdata,\n\n    // RAM Interface\n    output logic                   itcm_ram_cs,\n    output logic                   itcm_ram_we,\n    output logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    output logic [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    output logic [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    input  logic [E203_ITCM_RAM_DW-1:0] itcm_ram_dout\n);\n\n// Internal signals and variables\nlogic [E203_ITCM_ADDR_WIDTH-1:0] addr;\nlogic [E203_ITCM_DATA_WIDTH-1:0] wdata;\nlogic [E203_ITCM_DATA_WIDTH/8-1:0] wmask;\nlogic read;\nlogic cmd_valid;\nlogic cmd_ready;\nlogic rsp_valid;\nlogic rsp_ready;\nlogic rsp_err;\nlogic [E203_ITCM_DATA_WIDTH-1:0] rsp_rdata;\n\n// Arbitration logic\nalways_comb begin\n    if (ifu2itcm_icb_cmd_valid) begin\n        cmd_valid = 1'b1;\n        addr = ifu2itcm_icb_cmd_addr;\n        wdata = ifu2itcm_icb_cmd_wdata;\n        wmask = ifu2itcm_icb_cmd_wmask;\n        read = ifu2itcm_icb_cmd_read;\n    end else if (lsu2itcm_icb_cmd_valid) begin\n        cmd_valid = 1'b1;\n        addr = lsu2itcm_icb_cmd_addr;\n        wdata = lsu2itcm_icb_cmd_wdata;\n        wmask = lsu2itcm_icb_cmd_wmask;\n        read = lsu2itcm_icb_cmd_read;\n    end else if (E203_HAS_ITCM_EXTITF && ext2itcm_icb_cmd_valid) begin\n        cmd_valid = 1'b1;\n        addr = ext2itcm_icb_cmd_addr;\n        wdata = ext2itcm_icb_cmd_wdata;\n        wmask = ext2itcm_icb_cmd_wmask;\n        read = ext2itcm_icb_cmd_read;\n    end else begin\n        cmd_valid = 1'b0;\n        addr = '0;\n        wdata = '0;\n        wmask = '0;\n        read = 1'b0;\n    end\nend\n\n// Command ready logic\nassign ifu2itcm_icb_cmd_ready = (ifu2itcm_icb_cmd_valid && !cmd_valid) ? 1'b1 : 1'b0;\nassign lsu2itcm_icb_cmd_ready = (lsu2itcm_icb_cmd_valid && !cmd_valid) ? 1'b1 : 1'b0;\nassign ext2itcm_icb_cmd_ready = (ext2itcm_icb_cmd_valid && !cmd_valid && E203_HAS_ITCM_EXTITF) ? 1'b1 : 1'b0;\n\n// Response logic\nalways_comb begin\n    if (ifu2itcm_icb_rsp_ready) begin\n        rsp_valid = 1'b1;\n        rsp_rdata = itcm_ram_dout;\n        rsp_err = 1'b0;\n    end else if (lsu2itcm_icb_rsp_ready) begin\n        rsp_valid = 1'b1;\n        rsp_rdata = itcm_ram_dout;\n        rsp_err = 1'b0;\n    end else if (E203_HAS_ITCM_EXTITF && ext2itcm_icb_rsp_ready) begin\n        rsp_valid = 1'b1;\n        rsp_rdata = itcm_ram_dout;\n        rsp_err = 1'b0;\n    end else begin\n        rsp_valid = 1'b0;\n        rsp_rdata = '0;\n        rsp_err = 1'b0;\n    end\nend\n\n// Response ready logic\nassign ifu2itcm_icb_rsp_valid = rsp_valid;\nassign lsu2itcm_icb_rsp_valid = rsp_valid;\nassign ext2itcm_icb_rsp_valid = rsp_valid;\n\n// RAM control signals\nassign itcm_ram_cs = cmd_valid;\nassign itcm_ram_we = ~read;\nassign itcm_ram_addr = addr;\nassign itcm_ram_wem = wmask;\nassign itcm_ram_din = wdata;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 3, "code": "module e203_exu_alu_bjp(\n    input  logic                    bjp_i_valid,\n    output logic                    bjp_i_ready,\n    input  logic [E203_XLEN-1:0]    bjp_i_rs1,\n    input  logic [E203_XLEN-1:0]    bjp_i_rs2,\n    input  logic [E203_XLEN-1:0]    bjp_i_imm,\n    input  logic [E203_PC_SIZE-1:0] bjp_i_pc,\n    input  logic [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output logic                    bjp_o_valid,\n    input  logic                    bjp_o_ready,\n    output logic [E203_XLEN-1:0]    bjp_o_wbck_wdat,\n    output logic                    bjp_o_wbck_err,\n    output logic                    bjp_o_cmt_bjp,\n    output logic                    bjp_o_cmt_mret,\n    output logic                    bjp_o_cmt_dret,\n    output logic                    bjp_o_cmt_fencei,\n    output logic                    bjp_o_cmt_prdt,\n    output logic                    bjp_o_cmt_rslv,\n    output logic [E203_XLEN-1:0]    bjp_req_alu_op1,\n    output logic [E203_XLEN-1:0]    bjp_req_alu_op2,\n    output logic                    bjp_req_alu_cmp_eq,\n    output logic                    bjp_req_alu_cmp_ne,\n    output logic                    bjp_req_alu_cmp_lt,\n    output logic                    bjp_req_alu_cmp_gt,\n    output logic                    bjp_req_alu_cmp_ltu,\n    output logic                    bjp_req_alu_cmp_gtu,\n    output logic                    bjp_req_alu_add,\n    input  logic                    bjp_req_alu_cmp_res,\n    input  logic [E203_XLEN-1:0]    bjp_req_alu_add_res,\n    input  logic                    clk,\n    input  logic                    rst_n\n);\n\n// Valid-Ready Handshake\nassign bjp_i_ready = bjp_o_ready;\nassign bjp_o_valid = bjp_i_valid;\n\n// Generating ALU Requests\nalways_comb begin\n    bjp_req_alu_op1 = '0;\n    bjp_req_alu_op2 = '0;\n    bjp_req_alu_cmp_eq = 1'b0;\n    bjp_req_alu_cmp_ne = 1'b0;\n    bjp_req_alu_cmp_lt = 1'b0;\n    bjp_req_alu_cmp_gt = 1'b0;\n    bjp_req_alu_cmp_ltu =0: 1'b0;\n    bjp_req_alu_cmp_gtu = 1'b0;\n    bjp_req_alu_add = 1'b0;\n\n    case (bjp_i_info)\n        E203_DECINFO_BJP_BEQ: begin\n            bjp_req_alu_op1 = bjp_i_rs1;\n            bjp_req_alu_op2 = bjp_i_rs2;\n            bjp_req_alu_cmp_eq = 1'b1;\n        end\n        E203_DECINFO_BJP_BNE: begin\n            bjp_req_alu_op1 = bjp_i_rs1;\n            bjp_req_alu_op2 = bjp_i_rs2;\n            bjp_req_alu_cmp_ne = 1'b1;\n        end\n        E203_DECINFO_BJP_BLT: begin\n            bjp_req_alu_op1 = bjp_i_rs1;\n            bjp_req_alu_op2 = bjp_i_rs2;\n            bjp_req_alu_cmp_lt = 1'b1;\n        end\n        E203_DECINFO_BJP_BGT: begin\n            bjp_req_alu_op1 = bjp_i_rs1;\n            bjp_req_alu_op2 = bjp_i_rs2;\n            bjp_req_alu_cmp_gt = 1'b1;\n        end\n        E203_DECINFO_BJP_BLTU: begin\n            bjp_req_alu_op1 = bjp_i_rs1;\n            bjp_req_alu_op2 = bjp_i_rs2;\n            bjp_req_alu_cmp_ltu = 1'b1;\n        end\n        E203_DECINFO_BJP_BGTU: begin\n            bjp_req_alu_op1 = bjp_i_rs1;\n            bjp_req_alu_op2 = bjp_i_rs2;\n            bjp_req_alu_cmp_gtu = 1'b1;\n        end\n        E203_DECINFO_BJP_JUMP: begin\n            bjp_req_alu_op1 = bjp_i_pc;\n            bjp_req_alu_op2 = bjp_i_imm;\n            bjp_req_alu_add = 1'b1;\n        end\n        default: begin\n            // No operation\n        end\n    endcase\nend\n\n// Operand Selection\nalways_comb begin\n    if (bjp_i_info == E203_DECINFO_BJP_JUMP) begin\n        bjp_req_alu_op1 = bjp_i_pc;\n    end else begin\n        bjp_req_alu_op1 = bjp_i_rs1;\n    end\n\n    if (bjp_i_info == E203_DECINFO_BJP_JUMP) begin\n        bjp_req_alu_op2 = bjp_i_imm;\n    end else begin\n        bjp_req_alu_op2 = bjp_i0:_rs2;\n    end\nend\n\n// Retrieving Results from the ALU\nalways_comb begin\n    bjp_o_wbck_wdat = bjp_req_alu_add_res;\n    bjp_o_wbck_err = 1'b0; // Always set to 0 in this design\nend\n\n// Communication with Commit Module\nalways_comb begin\n    bjp_o_cmt_bjp = (bjp_i_info == E203_DECINFO_BJP_BEQ) || (bjp_i_info == E203_DECINFO_BJP_BNE) || (bjp_i_info == E203_DECINFO_BJP_BLT) || (bjp_i_info == E203_DECINFO_BJP_BGT) || (bjp_i_info == E203_DECINFO_BJP_BLTU) || (bjp_i_info == E203_DECINFO_BJP_BGTU);\n    bjp_o_cmt_mret = (bjp_i_info == E203_DECINFO_BJP_MRET);\n    bjp_o_cmt_dret = (bjp_i_info == E203_DECINFO_BJP_DRET);\n    bjp_o_cmt_fencei = (bjp_i_info == E203_DECINFO_BJP_FENCEI);\n    bjp_o_cmt_prdt = bjp_i_info[E203_DECINFO_BJP_BPRDT];\n    bjp_o_cmt_rslv = bjp_req_alu_cmp_res;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 1, "code": "module e203_lsu_ctrl (\n    input  logic                        commit_mret,\n    input  logic                        commit_trap,\n    output logic                        lsu_ctrl_active,\n\n    // LSU Write-back Interface\n    output logic                        lsu_o_valid,\n    input  logic                        lsu_o_ready,\n    output logic [E203_XLEN-1:0]        lsu_o_wbck_wdat,\n    output logic [E203_ITAG_WIDTH-1:0]  lsu_o_wbck_itag,\n    output logic                        lsu_o_wbck_err,\n    output logic                        lsu_o_cmt_buserr,\n    output logic [E203_ADDR_SIZE-1:0]   lsu_o_cmt_badaddr,\n    output logic                        lsu_o_cmt_ld,\n    output logic                        lsu_o_cmt_st,\n\n    // AGU-ICB Interface\n    input  logic                        agu_icb_cmd_valid,\n    output logic                        agu_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0]   agu_icb_cmd_addr,\n    input  logic                        agu_icb_cmd_read,\n    input  logic [E203_XLEN-1:0]        agu_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0]      agu_icb_cmd_wmask,\n    input  logic                        agu_icb_cmd_lock,\n    input  logic                        agu_icb_cmd_excl,\n    input  logic [1:0]                  agu_icb_cmd_size,\n    input  logic                        agu_icb_cmd_back2agu,\n    input  logic                        agu_icb_cmd_usign,\n    input  logic [E203_ITAG_WIDTH-1:0]  agu_icb_cmd_itag,\n\n    // AGU-ICB Response Interface\n    output logic                        agu_icb_rsp_valid,\n    input  logic                        agu_icb_rsp_ready,\n    output logic                        agu_icb_rsp_err,\n    output logic                        agu_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0]        agu_icb_rsp_rdata,\n\n    // NICE Interface (Optional Configuration)\n    input  logic                        nice_mem_holdup,\n    input  logic                        nice_icb_cmd_valid,\n    output logic                        nice_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0]   nice_icb_cmd_addr,\n    input  logic                        nice_icb_cmd_read,\n    input  logic [E203_XLEN-1:0]        nice_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0]      nice_icb_cmd_wmask,\n    output logic                        nice_icb_rsp_valid,\n    input  logic                        nice_icb_rsp_ready,\n    output logic                        nice_icb_rsp_err,\n    output logic [E203_XLEN-1:0]        nice_icb_rsp_rdata,\n\n    // Memory Interfaces\n    output logic                        dcache_icb_cmd_valid,\n    input  logic                        dcache_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0]   dcache_icb_cmd_addr,\n    output logic                        dcache_icb_cmd_read,\n    output logic [E203_XLEN-1:0]        dcache_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0]      dcache_icb_cmd_wmask,\n    output logic                        dcache_icb_cmd_lock,\n    output logic                        dcache_icb_cmd_excl,\n    output logic [1:0]                  dcache_icb_cmd_size,\n    input  logic                        dcache_icb_rsp_valid,\n    output logic                        dcache_icb_rsp_ready,\n    input  logic                        dcache_icb_rsp_err,\n    input  logic                        dcache_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0]        dcache_icb_rsp_rdata,\n\n    output logic                        dtcm_icb_cmd_valid,\n    input  logic                        dtcm_icb_cmd_ready,\n    output logic [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output logic                        dtcm_icb_cmd_read,\n    output logic [E203_XLEN-1:0]        dtcm_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0]      dtcm_icb_cmd_wmask,\n    output logic                        dtcm_icb_cmd_lock,\n    output logic                        dtcm_icb_cmd_excl,\n    output logic [1:0]                  dtcm_icb_cmd_size,\n    input  logic                        dtcm_icb_rsp_valid,\n    output logic                        dtcm_icb_rsp_ready,\n    input  logic                        dtcm_icb_rsp_err,\n    input  logic                        dtcm_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0]        dtcm_icb_rsp_rdata,\n\n    output logic                        itcm_icb_cmd_valid,\n    input  logic                        itcm_icb_cmd_ready,\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] itcm_icb_cmd_addr,\n    output logic                        itcm_icb_cmd_read,\n    output logic [E203_XLEN-1:0]        itcm_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0]      itcm_icb_cmd_wmask,\n    output logic                        itcm_icb_cmd_lock,\n    output logic                        itcm_icb_cmd_excl,\n    output logic [1:0]                  itcm_icb_cmd_size,\n    input  logic                        itcm_icb_rsp_valid,\n    output logic                        itcm_icb_rsp_ready,\n    input  logic                        itcm_icb_rsp_err,\n    input  logic                        itcm_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0]        itcm_icb_rsp_rdata,\n\n    output logic                        biu_icb_cmd_valid,\n    input  logic                        biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0]   biu_icb_cmd_addr,\n    output logic                        biu_icb_cmd_read,\n    output logic [E203_XLEN-1:0]        biu_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0]      biu_icb_cmd_wmask,\n    output logic                        biu_icb_cmd_lock,\n    output logic                        biu_icb_cmd_excl,\n    output logic [1:0]                  biu_icb_cmd_size,\n    input  logic                        biu_icb_rsp_valid,\n    output logic                        biu_icb_rsp_ready,\n    input  logic                        biu_icb_rsp_err,\n    input  logic                        biu_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0]        biu_icb_rsp_rdata\n);\n\n// Your implementation here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 3, "code": "```ilog\n// e203_exu_longpwbck.v\n\n`include \"e203_defines.v\"\n\nmodule e203_exu_longpwbck (\n    // LSU Write-Back Interface\n    input  logic                       lsu_wbck_i_valid,\n    output logic                       lsu_wbck_i_ready,\n    input  logic [E203_XLEN-1:0]       lsu_wbck_i_wdat,\n    input  logic [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input  logic                       lsu_wbck_i_err,\n    input  logic                       lsu_cmt_i_buserr,\n    input  logic [E203_ADDR_SIZE-1:0]  lsu_cmt_i_badaddr,\n    input  logic                       lsu_cmt_i_ld,\n    input  logic                       lsu_cmt_i_st,\n\n    // Long-Pipeline Write-Back Interface\n    output logic                       longp_wbck_o_valid,\n    input  logic                       longp_wbck_o_ready,\n    output logic [E203_FLEN-1:0]       longp_wbck_o_wdat,\n    output logic [4:0]                 longp_wbck_o_flags,\n    output logic [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output logic                       longp_wbck_o_rdfpu,\n    output logic                       longp_excp_o_valid,\n    input  logic                       longp_excp_o_ready,\n    output logic                       longp_excp_o_insterr,\n    output logic                       longp_excp_o_ld,\n    output logic                       longp_excp_o_st,\n    output logic                       longp_excp_o_buserr,\n    output logic [E203_ADDR_SIZE-1:0]  longp_excp_o_badaddr,\n    output logic [E203_PC_SIZE-1:0]    longp_excp_o_pc,\n\n    // OITF Interface\n    input  logic                       oitf_empty,\n    input  logic [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input  logic [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input  logic [E203_PC_SIZE-1:0]    oitf_ret_pc,\n    input  logic                       oitf_ret_rdwen,\n    input  logic                       oitf_ret_rdfpu,\n    output logic                       oitf_ret_ena,\n\n    // Clock and Reset\n    input  logic                       clk,\n    input  logic                       rst_n\n);\n\n// Internal Signals\nlogic lsu_wbck_need;\nlogic lsu_excp_need;\nlogic nice_wbck_need;\nlogic nice_excp_need;\nlogic wbck_i_valid;\nlogic wbck_i_ready;\n\n// LSU Write-Back Need and Exception Need\nassign lsu_wbck_need = lsu_wbck_i_valid & ~lsu_wbck_i_err & oitf_ret_rdwen;\nassign lsu_excp_need = lsu_wbck_i_valid & (lsu_wbck_i_err | lsu_cmt_i_buserr);\n\n// NICE Write-Back Need and Exception Need (if E203_HAS_NICE is defined)\n`ifdef E203_HAS_NICE\n    input  logic                       nice_longp_wbck_i_valid;\n    output logic                       nice_longp_wbck_i_ready;\n    input  logic [E203_XLEN-1:0]       nice_longp_wbck_i_wdat;\n    input  logic [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag;\n    input  logic                       nice_longp_wbck_i_err;\n\n    assign nice_wbck_need = nice_longp_wbck_i_valid & ~nice_longp_wbck_i_err & oitf_ret_rdwen;\n    assign nice_excp_need = nice_longp_wbck_i_valid & nice_longp_wbck_i_err;\n`endif\n\n// Write-Back Valid and Ready\nassign wbck_i_valid = (lsu_wbck_i_valid & (lsu_wbck_i_itag == oitf_ret_ptr)) | \n                      (`ifdef E203_HAS_NICE\n                           (nice_longp_wbck_i_valid & (nice_longp_wbck_i_itag == oitf_ret_ptr))\n                       `endif);\n\nassign wbck_i_ready = (lsu_wbck_need | lsu_excp_need | \n                       (`ifdef E203_HAS_NICE\n                            (nice_wbck_need | nice_excp_need)\n                        `endif)) & \n                      (longp_wbck_o_ready | longp_excp_o_ready);\n\n// LSU Write-Back Ready\nassign lsu_wbck_i_ready = wbck_i_ready & lsu_wbck_i_valid;\n\n// NICE Write-Back Ready (if E203_HAS_NICE is defined)\n`ifdef E203_HAS_NICE\n    assign nice_longp_wbck_i_ready = wbck_i_ready & nice_longp_wbck_i_valid;\n`endif\n\n// Long-Pipeline Write-Back Valid\nassign longp_wbck_o_valid = wbck_i_valid & wbck_i_ready & \n                            ~(lsu_excp_need | \n                              (`ifdef E203_HAS_NICE\n                                   nice_excp_need\n                               `endif)) & \n                            longp_wbck_o_ready;\n\n// Long-Pipeline Write-Back Data and Flags\nassign longp_wbck_o_wdat = lsu_wbck_i_wdat;\nassign longp_wbck_o_flags = {lsu_cmt_i_ld, lsu_cmt_i_st, lsu_wbck_i_err, 2'b00};\nassign longp_wbck_o_rdidx = oitf_ret_rdidx;\nassign longp_wbck_o_rdfpu = oitf_ret_rdfpu;\n\n// Exception Valid\nassign longp_excp_o_valid = wbck_i_valid & wbck_i_ready & \n                            (lsu_excp_need | \n                             (`ifdef E203_HAS_NICE\n                                  nice_excp_need\n                             `endif)) & \n                            longp_excp_o_ready;\n\n// Exception Signals\nassign longp_excp_o_insterr = lsu_wbck_i_err;\nassign longp_excp_o_ld = lsu_cmt_i_ld;\nassign longp_excp_o_st = lsu_cmt_i_st;\nassign longp_excp_o_buserr = lsu_cmt_i_buserr;\nassign longp_excp_o_badaddr = lsu_cmt_i_badaddr;\nassign longp_excp_o_pc = oitf_ret_pc;\n\n// OITF Retire Enable\nassign oitf_ret_ena = wbck_i_valid & wbck_i_ready;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 1, "code": "module e203_ifu_ifetch(\n    // System Interface\n    input  logic                   clk,\n    input  logic                   rst_n,\n\n    // Fetch Interface\n    output logic                   ifu_req_valid,\n    input  logic                   ifu_req_ready,\n    output logic [E203_PC_SIZE-1:0] ifu_req_pc,\n    output logic                   ifu_req_seq,\n    output logic                   ifu_req_seq_rv32,\n    output logic [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input  logic                   ifu_rsp_valid,\n    output logic                   ifu_rsp_ready,\n    input  logic                   ifu_rsp_err,\n    input  logic [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n\n    // Pipeline Control Interface\n    input  logic                   pipe_flush_req,\n    output logic                   pipe_flush_ack,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_pc,\n\n    // Execution Unit Interface\n    output logic [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output logic [E203_PC_SIZE-1:0] ifu_o_pc,\n    output logic                   ifu_o_pc_vld,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output logic                   ifu_o_prdt_taken,\n    output logic                   ifu_o_misalgn,\n    output logic                   ifu_o_buserr,\n    output logic                   ifu_o_muldiv_b2b,\n    output logic                   ifu_o_valid,\n    input  logic                   ifu_o_ready,\n\n    // Halt Control Interface\n    input  logic                   ifu_halt_req,\n    output logic                   ifu_halt_ack,\n\n    // Other Input Signals\n    input  logic                   oitf_empty,\n    input  logic [E203_XLEN-1:0]   rf2ifu_x1,\n    input  logic [E203_XLEN-1:0]   rf2ifu_rs1,\n    input  logic                   dec2ifu_rs1en,\n    input  logic                   dec2ifu_rden,\n    input  logic [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input  logic                   dec2ifu_mulhsu,\n    input  logic                   dec2ifu_div,\n    input  logic                   dec2ifu_rem,\n    input  logic                   dec2ifu_divu,\n    input  logic                   dec2ifu_remu\n);\n\n// Internal Signals and Variables\nlogic [E203_PC_SIZE-1:0] pc_r;\nlogic [E203_PC_SIZE-1:0] pc_nxt;\nlogic ifu_req_valid_pre;\nlogic ifu_req_valid_r;\nlogic ifu_rsp_ready_r;\nlogic [E203_INSTR_SIZE-1:0] ifu_ir_r;\nlogic [E203_PC_SIZE-1:0] ifu_pc_r;\nlogic ifu_o_pc_vld_r;\nlogic [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx_r;\nlogic [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx_r;\nlogic ifu_o_prdt_taken_r;\nlogic ifu_o_misalgn_r;\nlogic ifu_o_buserr_r;\nlogic ifu_o_muldiv_b2b_r;\nlogic ifu_o_valid_r;\nlogic out_flag_r;\n\n// Module Logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset Logic\n        pc_r <= '0;\n        ifu_req_valid_r <= '0;\n        ifu_rsp_ready_r <= '0;\n        ifu_ir_r <= '0;\n        ifu_pc_r <= '0;\n        ifu_o_pc_vld_r <= '0;\n        ifu_o_rs1idx_r <= '0;\n        ifu_o_rs2idx_r <= '0;\n        ifu_o_prdt_taken_r <= '0;\n        ifu_o_misalgn_r <= '0;\n        ifu_o_buserr_r <= '0;\n        ifu_o_muldiv_b2b_r <= '0;\n        ifu_o_valid_r <= '0;\n        out_flag_r <= '0;\n    end else begin\n        // Sequential Logic\n        if (ifu_req_valid_r && ifu_req_ready) begin\n            pc_r <= pc_nxt;\n        end\n\n        ifu_req_valid_r <= ifu_req_valid_pre;\n        ifu_rsp_ready_r <= ifu_rsp_valid && ~ifu_rsp_err;\n        ifu_ir_r <= ifu_rsp_instr;\n        ifu_pc_r <= ifu_req_pc;\n        ifu_o_pc_vld_r <= ifu_o_pc_vld;\n        ifu_o_rs1idx_r <= ifu_o_rs1idx;\n        ifu_o_rs2idx_r <= ifu_o_rs2idx;\n        ifu_o_prdt_taken_r <= ifu_o_prdt_taken;\n        ifu_o_misalgn_r <= ifu_o_misalgn;\n        ifu_o_buserr_r <= ifu_o_buserr;\n        ifu_o_muldiv_b2b_r <= ifu_o_muldiv_b2b;\n        ifu_o_valid_r <= ifu_o_valid;\n        out_flag_r <= ifu_req_valid_r && ifu_req_ready;\n    end\nend\n\nalways_comb begin\n    // Combinational Logic\n    ifu_req_valid_pre = ifu_req_valid_r || (ifu_halt_req && ~ifu_halt_ack);\n    pc_nxt = pc_r + 4;\n    ifu_o_pc_vld = ifu_o_pc_vld_r;\n    ifu_o_rs1idx = ifu_o_rs1idx_r;\n    ifu_o_rs2idx = ifu_o_rs2idx_r;\n    ifu_o_prdt_taken = ifu_o_prdt_taken_r;\n    ifu_o_misalgn = ifu_o_misalgn_r;\n    ifu_o_buserr = ifu_o_buserr_r;\n    ifu_o_muldiv_b2b = ifu_o_muldiv_b2b_r;\n    ifu_o_valid = ifu_o_valid_r;\nend\n\nassign ifu_req_valid = ifu_req_valid_r;\nassign ifu_req_pc = pc_r;\nassign ifu_req_seq = ifu_req_valid_r && ~ifu_halt_req;\nassign ifu_req_seq_rv32 = ifu_req_seq && (ifu_ir_r[1:0] == 2'b11); // RV32 instruction\nassign ifu_req_last_pc = pc_r;\nassign ifu_rsp_ready = ifu_rsp_ready_r;\nassign ifu_o_ir = ifu_ir_r;\nassign ifu_o_pc = ifu_pc_r;\nassign ifu_o_rs1idx = ifu_o_rs1idx_r;\nassign ifu_o_rs2idx = ifu_o_rs2idx_r;\nassign ifu_halt_ack = ifu_halt_req && ~ifu_halt_ack;\nassign pipe_flush_ack = pipe_flush_req && ~ifu_halt_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 2, "code": "module e203_exu_alu_dpath(\n    input  logic                   alu_req_alu,\n    input  logic                   alu_req_alu_add,\n    input  logic                   alu_req_alu_sub,\n    input  logic                   alu_req_alu_xor,\n    input  logic                   alu_req_alu_sll,\n    input  logic                   alu_req_alu_srl,\n    input  logic                   alu_req_alu_sra,\n    input  logic                   alu_req_alu_or,\n    input  logic                   alu_req_alu_and,\n    input  logic [E203_XLEN-1:0]   alu_req_alu_op1,\n    input  logic [E203_XLEN-1:0]   alu_req_alu_op2,\n    input  logic                   bjp_req_alu,\n    input  logic [E203_XLEN-1:0]   bjp_req_alu_op1,\n    input  logic [E203_XLEN-1:0]   bjp_req_alu_op2,\n    input  logic                   agu_req_alu,\n    input  logic [E203_XLEN-1:0]   agu_req_alu_op1,\n    input  logic [E203_XLEN-1:0]   agu_req_alu_op2,\n    input  logic                   muldiv_req_alu,\n    input  logic [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input  logic [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input  logic                   muldiv_req_alu_add,\n    input  logic                   muldiv_req_alu_sub,\n    input  logic                   muldiv_sbf_0_ena,\n    input  logic [32:0]            muldiv_sbf_0_nxt,\n    input  logic                   muldiv_sbf_1_ena,\n    input  logic [32:0]            muldiv_sbf_1_nxt,\n    input  logic                   clk,\n    input  logic                   rst_n,\n    output logic [E203_XLEN-1:0]   alu_req_alu_res,\n    output logic [E203_XLEN-1:0]   bjp_req_alu_add_res,\n    output logic                   bjp_req_alu_cmp_res,\n    output logic [E203_XLEN-1:0]   agu_req_alu_res,\n    output logic [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output logic [32:0]            muldiv_sbf_0_r,\n    output logic [32:0]            muldiv_sbf_1_r\n);\n\n// Internal signal declarations\nlogic [E203_XLEN-1:0] alu_res;\nlogic [E203_XLEN-1:0] bjp_add_res;\nlogic bjp_cmp_res;\nlogic [E203_XLEN-1:0] agu_res;\nlogic [E203_ALU_ADDER_WIDTH-1:0] muldiv_res;\nlogic [32:0] sbf_0_r;\nlogic [32:0] sbf_1_r;\n\n// ALU operations\nalways_comb begin\n    case ({alu_req_alu_add, alu_req_alu_sub, alu_req_alu_xor, alu_req_alu_sll, alu_req_alu_srl, alu_req_alu_sra, alu_req_alu_or, alu_req_alu_and})\n        8'b00000001: alu_res = alu_req_alu_op1 + alu_req_alu_op2; // ADD\n        8'b00000010: alu_res = alu_req_alu_op1 - alu_req_alu_op2; // SUB\n        8'b00000100: alu_res = alu_req_alu_op1 ^ alu_req_alu_op2; // XOR\n        8'b00001000: alu_res = alu_req_alu_op1 << alu_req_alu_op2; // SLL\n        8'b00010000: alu_res = alu_req_alu_op1 >> alu_req_alu_op2; // SRL\n        8'b00100000: alu_res = alu_req_alu_op1 >>> alu_req_alu_op2; // SRA\n        8'b01000000: alu_res = alu_req_alu_op1 | alu_req_alu_op2; // OR\n        8'b10000000: alu_res = alu_req_alu_op1 & alu_req_alu_op2; // AND\n        default: alu_res = '0;\n    endcase\nend\n\n// BJP operations\nalways_comb begin\n    case ({bjp_req_alu})\n        1'b1: begin\n            bjp_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n            bjp_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n        end\n        default: begin\n            bjp_add_res = '0;\n            bjp_cmp_res = '0;\n        end\n    endcase\nend\n\n// AGU operations\nalways_comb begin\n    case ({agu_req_alu})\n        1'b1: agu_res = agu_req_alu_op1 + agu_req_alu_op2;\n        default: agu_res = '0;\n    endcase\nend\n\n// MULDIV operations\nalways_comb begin\n    case ({muldiv_req_alu_add, muldiv_req_alu_sub})\n        2'b01: muldiv_res = muldiv_req_alu_op1 + muldiv_req_alu_op2; // ADD\n        2'b10: muldiv_res = muldiv_req_alu_op1 - muldiv_req_alu_op2; // SUB\n        default: muldiv_res = '0;\n    endcase\nend\n\n// Shared buffer 0\nsirv_gnrl_dffl #(.DW(33)) sbf_0_dffl(\n    .lden(muldiv_sbf_0_ena),\n    .dnxt(muldiv_sbf_0_nxt),\n    .qout(sbf_0_r),\n    .clk(clk)\n);\n\n// Shared buffer 1\nsirv_gnrl_dffl #(.DW(33)) sbf_1_dffl(\n    .lden(muldiv_sbf_1_ena),\n    .dnxt(muldiv_sbf_1_nxt),\n    .qout(sbf_1_r),\n    .clk(clk)\n);\n\n// Output assignments\nassign alu_req_alu_res = alu_res;\nassign bjp_req_alu_add_res = bjp_add_res;\nassign bjp_req_alu_cmp_res = bjp_cmp_res;\nassign agu_req_alu_res = agu_res;\nassign muldiv_req_alu_res = muldiv_res;\nassign muldiv_sbf_0_r = sbf_0_r;\nassign muldiv_sbf_1_r = sbf_1_r;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 7, "code": "// Import necessary configuration files\n`include \"e203_defines.v\"\n\nmodule e203_exu_oitf(\n    // Output ports\n    output dis_ready,\n    output [E203_ITAG_WIDTH-1:0] dis_ptr,\n    output [E203_ITAG_WIDTH-1:0] ret_ptr,\n    output [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n    output ret_rdwen,\n    output ret_rdfpu,\n    output [E203_PC_SIZE-1:0] ret_pc,\n    output oitfrd_match_disprs1,\n    output oitfrd_match_disprs2,\n    output oitfrd_match_disprs3,\n    output oitfrd_match_disprd,\n    output oitf_empty,\n\n    // Input ports\n    input dis_ena,\n    input ret_ena,\n    input disp_i_rs1en,\n    input disp_i_rs2en,\n    input disp_i_rs3en,\n    input disp_i_rdwen,\n    input disp_i_rs1fpu,\n    input disp_i_rs2fpu,\n    input disp_i_rs3fpu,\n    input disp_i_rdfpu,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n    input [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input [E203_PC_SIZE-1:0] disp_i_pc,\n    input clk,\n    input rst_n\n);\n\n// Internal signals and variables\nreg [E203_ITAG_WIDTH-1:0] dis_ptr_reg;\nreg [E203_ITAG_WIDTH-1:0] ret_ptr_reg;\nreg [E203_RFIDX_WIDTH-1:0] ret_rdidx_reg;\nreg ret_rdwen_reg;\nreg ret_rdfpu_reg;\nreg [E203_PC_SIZE-1:0] ret_pc_reg;\nreg oitfrd_match_disprs1_reg;\nreg oitfrd_match_disprs2_reg;\nreg oitfrd_match_disprs3_reg;\nreg oitfrd_match_disprd_reg;\nreg oitf_empty_reg;\n\n// FIFO implementation\nreg [E203_OITF_DEPTH-1:0][E203_RFIDX_WIDTH-1:0] oitf_rdidx;\nreg [E203_OITF_DEPTH-1:0][E203_PC_SIZE-1:0] oitf_pc;\nreg [E203_OITF_DEPTH-1:0] oitf_rdwen;\nreg [E203_OITF_DEPTH-1:0] oitf_rdfpu;\n\n// Dispatch logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        dis_ptr_reg <= 0;\n    end else if (dis_ena) begin\n        dis_ptr_reg <= dis_ptr_reg + 1;\n        if (dis_ptr_reg == E203_OITF_DEPTH - 1) begin\n            dis_ptr_reg <= 0;\n        end\n    end\nend\n\n// Retirement logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        ret_ptr_reg <= 0;\n    end else if (ret_ena) begin\n        ret_ptr_reg <= ret_ptr_reg + 1;\n        if (ret_ptr_reg == E203_OITF_DEPTH - 1) begin\n            ret_ptr_reg <= 0;\n        end\n    end\nend\n\n// Dependency checking\nalways @(posedge clk) begin\n    oitfrd_match_disprs1_reg <= 0;\n    oitfrd_match_disprs2_reg <= 0;\n    oitfrd_match_disprs3_reg <= 0;\n    oitfrd_match_disprd_reg <= 0;\n    for (int i = 0; i < E203_OITF_DEPTH; i++) begin\n        if (oitf_rdwen[i] && (oitf_rdidx[i] == disp_i_rs1idx) && (oitf_rdfpu[i] == disp_i_rs1fpu)) begin\n            oitfrd_match_disprs1_reg <= 1;\n        end\n        if (oitf_rdwen[i] && (oitf_rdidx[i] == disp_i_rs2idx) && (oitf_rdfpu[i] == disp_i_rs2fpu)) begin\n            oitfrd_match_disprs2_reg <= 1;\n        end\n        if (oitf_rdwen[i] && (oitf_rdidx[i] == disp_i_rs3idx) && (oitf_rdfpu[i] == disp_i_rs3fpu)) begin\n            oitfrd_match_disprs3_reg <= 1;\n        end\n        if (oitf_rdwen[i] && (oitf_rdidx[i] == disp_i_rdidx) && (oitf_rdfpu[i] == disp_i_rdfpu)) begin\n            oitfrd_match_disprd_reg <= 1;\n        end\n    end\nend\n\n// FIFO update\nalways @(posedge clk) begin\n    if (dis_ena) begin\n        oitf_rdidx[dis_ptr_reg] <= disp_i_rdidx;\n        oitf_pc[dis_ptr_reg] <= disp_i_pc;\n        oitf_rdwen[dis_ptr_reg] <= disp_i_rdwen;\n        oitf_rdfpu[dis_ptr_reg] <= disp_i_rdfpu;\n    end\n    if (ret_ena) begin\n        oitf_rdidx[ret_ptr_reg] <= 0;\n        oitf_pc[ret_ptr_reg] <= 0;\n        oitf_rdwen[ret_ptr_reg] <= 0;\n        oitf_rdfpu[ret_ptr_reg] <= 0;\n    end\nend\n\n// Output assignments\nassign dis_ready = (dis_ptr_reg != ret_ptr_reg) || oitf_empty_reg;\nassign dis_ptr = dis_ptr_reg;\nassign ret_ptr = ret_ptr_reg;\nassign ret_rdidx = ret_rdidx_reg;\nassign ret_rdwen = ret_rdwen_reg;\nassign ret_rdfpu = ret_rdfpu_reg;\nassign ret_pc = ret_pc_reg;\nassign oitfrd_match_disprs1 = oitfrd_match_disprs1_reg;\nassign oitfrd_match_disprs2 = oitfrd_match_disprs2_reg;\nassign oitfrd_match_disprs3 = oitfrd_match_disprs3_reg;\nassign oitfrd_match_disprd = oitfrd_match_disprd_reg;\nassign oitf_empty = oitf_empty_reg;\n\n// Empty check\nalways @(posedge clk) begin\n    oitf_empty_reg <= 1;\n    for (int i = 0; i < E203_OITF_DEPTH; i++) begin\n        if (oitf_rdwen[i]) begin\n            oitf_empty_reg <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 1, "code": "module e203_exu_csr #(\n    parameter E203_XLEN = 32,\n    parameter E203_HART_ID_W = 1,\n    parameter E203_ADDR_SIZE = 32,\n    parameter E203_PC_SIZE = 32\n) (\n    input   logic                   nonflush_cmt_ena,\n    input   logic                   csr_ena,\n    input   logic                   csr_wr_en,\n    input   logic                   csr_rd_en,\n    input   logic   [11:0]          csr_idx,\n    output  logic                   csr_access_ilgl,\n    output  logic                   tm_stop,\n    output  logic                   core_cgstop,\n    output  logic                   tcm_cgstop,\n    output  logic                   itcm_nohold,\n    output  logic                   mdv_nob2b,\n    output  logic   [E203_XLEN-1:0] read_csr_dat,\n    input   logic   [E203_XLEN-1:0] wbck_csr_dat,\n    input   logic   [E203_HART_ID_W-1:0] core_mhartid,\n    input   logic                   ext_irq_r,\n    input   logic                   sft_irq_r,\n    input   logic                   tmr_irq_r,\n    output  logic                   status_mie_r,\n    output  logic                   mtie_r,\n    output  logic                   msie_r,\n    output  logic                   meie_r,\n    output  logic                   wr_dcsr_ena,\n    output  logic                   wr_dpc_ena,\n    output  logic                   wr_dscratch_ena,\n    input   logic   [E203_XLEN-1:0] dcsr_r,\n    input   logic   [E203_PC_SIZE-1:0] dpc_r,\n    input   logic   [E203_XLEN-1:0] dscratch_r,\n    output  logic                   u_mode,\n    output  logic                   s_mode,\n    output  logic                   h_mode,\n    output  logic                   m_mode,\n    input   logic   [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input   logic                   cmt_badaddr_ena,\n    input   logic   [E203_PC_SIZE-1:0] cmt_epc,\n    input   logic                   cmt_epc_ena,\n    input   logic   [E203_XLEN-1:0] cmt_cause,\n    input   logic                   cmt_cause_ena,\n    input   logic                   cmt_status_ena,\n    input   logic                   cmt_instret_ena,\n    input   logic                   cmt_mret_ena,\n    output  logic   [E203_PC_SIZE-1:0] csr_epc_r,\n    output  logic   [E203_PC_SIZE-1:0] csr_dpc_r,\n    output  logic   [E203_XLEN-1:0] csr_mtvec_r,\n    input   logic                   clk_aon,\n    input   logic                   clk,\n    input   logic                   rst_n\n);\n\nlogic [E203_XLEN-1:0] mstatus;\nlogic [E203_XLEN-1:0] mie;\nlogic [E203_XLEN-1:0] mip;\nlogic [E203_XLEN-1:0] mtvec;\nlogic [E203_XLEN-1:0] mscratch;\nlogic [E203_PC_SIZE-1:0] mepc;\nlogic [E203_XLEN-1:0] mcause;\nlogic [E203_XLEN-1:0] mtval;\nlogic [E203_XLEN-1:0] mcounterstop;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        mstatus <= '0;\n        mie <= '0;\n        mip <= '0;\n        mtvec <= '0;\n        mscratch <= '0;\n        mepc <= '0;\n        mcause <= '0;\n        mtval <= '0;\n        mcounterstop <= '0;\n    end else if (csr_ena && csr_wr_en) begin\n        case (csr_idx)\n            12'h300: mstatus <= wbck_csr_dat;\n            12'h304: mie <= wbck_csr_dat;\n            12'h305: mtvec <= wbck_csr_dat;\n            12'h340: mscratch <= wbck_csr_dat;\n            12'h341: mepc <= {wbck_csr_dat[E203_PC_SIZE-1:1], 1'b0};\n            12'h342: mcause <= {wbck_csr_dat[E203_XLEN-1:31], 31'b0} | (wbck_csr_dat[30:0] << 1);\n            12'h343: mtval <= {wbck_csr_dat[E203_XLEN-1:E203_ADDR_SIZE], {E203_ADDR_SIZE{1'b0}}};\n            12'hBFF: mcounterstop <= wbck_csr_dat;\n            default: ;\n        endcase\n    end else if (cmt_status_ena) begin\n        mstatus[3] <= mie;\n    end else if (cmt_mret_ena) begin\n        mstatus[3] <= mstatus[7];\n    end\nend\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        mip <= '0;\n    end else if (csr_ena && csr_wr_en) begin\n        case (csr_idx)\n            12'h344: mip <= wbck_csr_dat;\n            default: ;\n        endcase\n    end else if (ext_irq_r || sft_irq_r || tmr_irq_r) begin\n        mip <= {29'b0, ext_irq_r, sft_irq_r, tmr_irq_r};\n    end\nend\n\nalways_comb begin\n    case (csr_idx)\n        12'h300: read_csr_dat = mstatus;\n        12'h304: read_csr_dat = mie;\n        12'h305: read_csr_dat = mtvec;\n        12'h340: read_csr_dat = mscratch;\n        12'h341: read_csr_dat = { {(E203_XLEN-E203_PC_SIZE){1'b0}}, mepc };\n        12'h342: read_csr_dat = mcause;\n        12'h343: read_csr_dat = mtval;\n        12'hBFF: read_csr_dat = mcounterstop;\n        default: read_csr_dat = '0;\n    endcase\nend\n\nassign csr_access_ilgl = 1'b0;\nassign tm_stop = mcounterstop[E203_XLEN-1];\nassign core_cgstop = mcounterstop[E203_XLEN-2];\nassign tcm_cgstop = mcounterstop[E203_XLEN-3];\nassign itcm_nohold = mcounterstop[E203_XLEN-4];\nassign mdv_nob2b = mcounterstop[E203_XLEN-5];\nassign status_mie_r = mstatus[3];\nassign mtie_r = mie[7];\nassign msie_r = mie[3];\nassign meie_r = mie[11];\nassign wr_dcsr_ena = csr_ena && csr_wr_en && (csr_idx == 12'h7b0);\nassign wr_dpc_ena = csr_ena && csr_wr_en && (csr_idx == 12'h7b1);\nassign wr_dscratch_ena = csr_ena && csr_wr_en && (csr_idx == 12'h7b2);\nassign u_mode = 1'b0;\nassign s_mode = 1'b0;\nassign h_mode = 1'b0;\nassign m_mode = 1'b1;\nassign csr_epc_r = mepc;\nassign csr_dpc_r = dpc_r;\nassign csr_mtvec_r = mtvec;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 2, "code": "// Import necessary configuration files\n`include \"e203_defines.v\"\n\nmodule e203_lsu_ctrl(\n    // Control Signals\n    input  logic commit_mret,       // Machine mode return signal\n    input  logic commit_trap,       // Exception trap signal\n    input  logic excp_active,       // Exception active signal\n    output logic lsu_active,        // LSU working status signal\n\n    // LSU Write-Back Interface\n    output logic lsu_o_valid,       // Write-back handshake valid signal\n    input  logic lsu_o_ready,       // Write-back handshake ready signal\n    output logic [E203_XLEN-1:0] lsu_o_wbck_wdat,  // Write-back data\n    output logic [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,  // Instruction tag\n    output logic lsu_o_wbck_err,     // Write-back error flag\n    output logic lsu_o_cmt_ld,       // Load instruction commit flag\n    output logic lsu_o_cmt_st,       // Store instruction commit flag\n    output logic [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,  // Error address\n    output logic lsu_o_cmt_buserr,   // Bus error exception flag\n\n    // AGU-ICB Interface\n    input  logic agu_icb_cmd_valid,  // Command valid\n    output logic agu_icb_cmd_ready,  // Command ready\n    input  logic [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,  // Access address\n    input  logic agu_icb_cmd_read,   // Read/Write flag\n    input  logic [E203_XLEN-1:0] agu_icb_cmd_wdata,  // Write data\n    input  logic [E203_XLEN/8-1:0] agu_icb_cmd_wmask,  // Write mask\n    input  logic agu_icb_cmd_lock,   // Lock flag\n    input  logic agu_icb_cmd_excl,   // Exclusive access flag\n    input  logic [1:0] agu_icb_cmd_size,  // Access size\n    input  logic agu_icb_cmd_back2agu,  // Response back to AGU flag\n    input  logic agu_icb_cmd_usign,   // Unsigned flag\n    input  logic [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,  // Instruction tag\n    output logic agu_icb_rsp_valid,  // Response valid\n    input  logic agu_icb_rsp_ready,  // Response ready\n    output logic agu_icb_rsp_err,    // Response error\n    output logic agu_icb_rsp_excl_ok,  // Exclusive access success\n    output logic [E203_XLEN-1:0] agu_icb_rsp_rdata,  // Read data\n\n    // NICE Interface (Optional Configuration)\n    input  logic nice_mem_holdup,    // Memory access hold-up\n\n    // Other ICB Interfaces (ITCM/DTCM/DCache/BIU)\n    output logic biu_icb_cmd_valid,  // Command valid\n    input  logic biu_icb_cmd_ready,  // Command ready\n    output logic [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,  // Access address\n    output logic biu_icb_cmd_read,   // Read/Write flag\n    output logic [E203_XLEN-1:0] biu_icb_cmd_wdata,  // Write data\n    output logic [E203_XLEN/8-1:0] biu_icb_cmd_wmask,  // Write mask\n    output logic biu_icb_cmd_lock,   // Lock flag\n    output logic biu_icb_cmd_excl,   // Exclusive access flag\n    output logic [1:0] biu_icb_cmd_size,  // Access size\n    input  logic biu_icb_rsp_valid,  // Response valid\n    output logic biu_icb_rsp_ready,  // Response ready\n    input  logic biu_icb_rsp_err,    // Response error\n    input  logic biu_icb_rsp_excl_ok,  // Exclusive access success\n    input  logic [E203_XLEN-1:0] biu_icb_rsp_rdata  // Read data\n);\n\n// Internal signals and variables\nlogic [E203_XLEN-1:0] internal_wb_data;\nlogic [E203_ITAG_WIDTH-1:0] internal_wb_itag;\nlogic internal_wb_err;\nlogic internal_cmt_ld;\nlogic internal_cmt_st;\nlogic [E203_ADDR_SIZE-1:0] internal_cmt_badaddr;\nlogic internal_cmt_buserr;\n\n// LSU control logic\nalways @(posedge clk) begin\n    // Clear internal signals\n    internal_wb_data <= '0;\n    internal_wb_itag <= '0;\n    internal_wb_err <= '0;\n    internal_cmt_ld <= '0;\n    internal_cmt_st <= '0;\n    internal_cmt_badaddr <= '0;\n    internal_cmt_buserr <= '0;\n\n    // Handle LSU write-back\n    if (lsu_o_valid && lsu_o_ready) begin\n        internal_wb_data <= lsu_o_wbck_wdat;\n        internal_wb_itag <= lsu_o_wbck_itag;\n        internal_wb_err <= lsu_o_wbck_err;\n    end\n\n    // Handle LSU commit\n    if (commit_mret || commit_trap) begin\n        internal_cmt_ld <= lsu_o_cmt_ld;\n        internal_cmt_st <= lsu_o_cmt_st;\n        internal_cmt_badaddr <= lsu_o_cmt_badaddr;\n        internal_cmt_buserr <= lsu_o_cmt_buserr;\n    end\n\n    // Handle AGU-ICB command\n    if (agu_icb_cmd_valid && agu_icb_cmd_ready) begin\n        // Process AGU command\n    end\n\n    // Handle BIU response\n    if (biu_icb_rsp_valid && biu_icb_rsp_ready) begin\n        // Process BIU response\n    end\nend\n\n// Assign outputs\nassign lsu_o_wbck_wdat = internal_wb_data;\nassign lsu_o_wbck_itag = internal_wb_itag;\nassign lsu_o_wbck_err = internal_wb_err;\nassign lsu_o_cmt_ld = internal_cmt_ld;\nassign lsu_o_cmt_st = internal_cmt_st;\nassign lsu_o_cmt_badaddr = internal_cmt_badaddr;\nassign lsu_o_cmt_buserr = internal_cmt_buserr;\n\n// Assign AGU-ICB interface signals\nassign agu_icb_cmd_ready = 1'b1;  // Always ready\nassign agu_icb_rsp_valid = 1'b0;  // Default response valid\nassign agu_icb_rsp_err = 1'b0;    // Default response error\nassign agu_icb_rsp_excl_ok = 1'b0;  // Default exclusive access success\nassign agu_icb_rsp_rdata = '0;    // Default read data\n\n// Assign BIU interface signals\nassign biu_icb_cmd_valid = 1'b0;  // Default command valid\nassign biu_icb_cmd_addr = '0;     // Default access address\nassign biu_icb_cmd_read = 1'b0;   // Default read/write flag\nassign biu_icb_cmd_wdata = '0;    // Default write data\nassign biu_icb_cmd_wmask = '0;    // Default write mask\nassign biu_icb_cmd_lock = 1'b0;   // Default lock flag\nassign biu_icb_cmd_excl = 1'b0;   // Default exclusive access flag\nassign biu_icb_cmd_size = '0;     // Default access size\nassign biu_icb_rsp_ready = 1'b1;  // Always ready\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 1, "code": "module e203_biu #(\n    parameter E203_ADDR_SIZE = 32,\n    parameter E203_XLEN      = 32,\n    parameter E203_BIU_OUTS_NUM = 1\n) (\n    input  logic                   clk,\n    input  logic                   rst_n,\n\n    // Control Signals\n    output logic                   biu_active,\n\n    // ICB Interface for LSU\n    input  logic                   lsu_icb_cmd_valid,\n    output logic                   lsu_icb_cmd_ready,\n    input  logic                   lsu_icb_cmd_read,\n    input  logic [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input  logic [E203_XLEN-1:0]   lsu_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] lsu_icb_cmd_wmask,\n    output logic                   lsu_icb_rsp_valid,\n    input  logic                   lsu_icb_rsp_ready,\n    output logic                   lsu_icb_rsp_err,\n    output logic                   lsu_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0]   lsu_icb_rsp_rdata,\n\n    // ICB Interface for IFU\n    input  logic                   ifu_icb_cmd_valid,\n    output logic                   ifu_icb_cmd_ready,\n    input  logic                   ifu_icb_cmd_read,\n    input  logic [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input  logic [E203_XLEN-1:0]   ifu_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] ifu_icb_cmd_wmask,\n    output logic                   ifu_icb_rsp_valid,\n    input  logic                   ifu_icb_rsp_ready,\n    output logic                   ifu_icb_rsp_err,\n    output logic                   ifu_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0]   ifu_icb_rsp_rdata,\n\n    // ICB Interface for PPI\n    input  logic                   ppi_icb_cmd_valid,\n    output logic                   ppi_icb_cmd_ready,\n    input  logic                   ppi_icb_cmd_read,\n    input  logic [E203_ADDR_SIZE-1:0] ppi_icb_cmd_addr,\n    input  logic [E203_XLEN-1:0]   ppi_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] ppi_icb_cmd_wmask,\n    output logic                   ppi_icb_rsp_valid,\n    input  logic                   ppi_icb_rsp_ready,\n    output logic                   ppi_icb_rsp_err,\n    output logic                   ppi_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0]   ppi_icb_rsp_rdata,\n\n    // ICB Interface for CLINT\n    input  logic                   clint_icb_cmd_valid,\n    output logic                   clint_icb_cmd_ready,\n    input  logic                   clint_icb_cmd_read,\n    input  logic [E203_ADDR_SIZE-1:0] clint_icb_cmd_addr,\n    input  logic [E203_XLEN-1:0]   clint_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] clint_icb_cmd_wmask,\n    output logic                   clint_icb_rsp_valid,\n    input  logic                   clint_icb_rsp_ready,\n    output logic                   clint_icb_rsp_err,\n    output logic                   clint_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0]   clint_icb_rsp_rdata,\n\n    // ICB Interface for PLIC\n    input  logic                   plic_icb_cmd_valid,\n    output logic                   plic_icb_cmd_ready,\n    input  logic                   plic_icb_cmd_read,\n    input  logic [E203_ADDR_SIZE-1:0] plic_icb_cmd_addr,\n    input  logic [E203_XLEN-1:0]   plic_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] plic_icb_cmd_wmask,\n    output logic                   plic_icb_rsp_valid,\n    input  logic                   plic_icb_rsp_ready,\n    output logic                   plic_icb_rsp_err,\n    output logic                   plic_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0]   plic_icb_rsp_rdata,\n\n    // ICB Interface for FIO\n    input  logic                   fio_icb_cmd_valid,\n    output logic                   fio_icb_cmd_ready,\n    input  logic                   fio_icb_cmd_read,\n    input  logic [E203_ADDR_SIZE-1:0] fio_icb_cmd_addr,\n    input  logic [E203_XLEN-1:0]   fio_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] fio_icb_cmd_wmask,\n    output logic                   fio_icb_rsp_valid,\n    input  logic                   fio_icb_rsp_ready,\n    output logic                   fio_icb_rsp_err,\n    output logic                   fio_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0]   fio_icb_rsp_rdata\n);\n\n// Internal signals\nlogic [E203_BIU_OUTS_NUM-1:0] cmd_valid;\nlogic [E203_BIU_OUTS_NUM-1:0] cmd_ready;\nlogic [E203_BIU_OUTS_NUM-1:0] cmd_read;\nlogic [E203_BIU_OUTS_NUM-1:0][E203_ADDR_SIZE-1:0] cmd_addr;\nlogic [E203_BIU_OUTS_NUM-1:0][E203_XLEN-1:0] cmd_wdata;\nlogic [E203_BIU_OUTS_NUM-1:0][E203_XLEN/8-1:0] cmd_wmask;\nlogic [E203_BIU_OUTS_NUM-1:0] rsp_valid;\nlogic [E203_BIU_OUTS_NUM-1:0] rsp_ready;\nlogic [E203_BIU_OUTS_NUM-1:0] rsp_err;\nlogic [E203_BIU_OUTS_NUM-1:0] rsp_excl_ok;\nlogic [E203_BIU_OUTS_NUM-1:0][E203_XLEN-1:0] rsp_rdata;\n\n// Arbitration logic\nalways_comb begin\n    cmd_valid[0] = lsu_icb_cmd_valid;\n    cmd_ready[0] = lsu_icb_cmd_ready;\n    cmd_read[0] = lsu_icb_cmd_read;\n    cmd_addr[0] = lsu_icb_cmd_addr;\n    cmd_wdata[0] = lsu_icb_cmd_wdata;\n    cmd_wmask[0] = lsu_icb_cmd_wmask;\n\n    cmd_valid[1] = ifu_icb_cmd_valid;\n    cmd_ready[1] = ifu_icb_cmd_ready;\n    cmd_read[1] = ifu_icb_cmd_read;\n    cmd_addr[1] = ifu_icb_cmd_addr;\n    cmd_wdata[1] = ifu_icb_cmd_wdata;\n    cmd_wmask[1] = ifu_icb_cmd_wmask;\nend\n\n// Buffer logic\nalways_comb begin\n    lsu_icb_rsp_valid = rsp_valid[0];\n    lsu_icb_rsp_ready = rsp_ready[0];\n    lsu_icb_rsp_err = rsp_err[0];\n    lsu_icb_rsp_excl_ok = rsp_excl_ok[0];\n    lsu_icb_rsp_rdata = rsp_rdata[0];\n\n    ifu_icb_rsp_valid = rsp_valid[1];\n    ifu_icb_rsp_ready = rsp_ready[1];\n    ifu_icb_rsp_err = rsp_err[1];\n    ifu_icb_rsp_excl_ok = rsp_excl_ok[1];\n    ifu_icb_rsp_rdata = rsp_rdata[1];\nend\n\n// Splitter logic\nalways_comb begin\n    ppi_icb_cmd_valid = cmd_valid[0];\n    ppi_icb_cmd_ready = cmd_ready[0];\n    ppi_icb_cmd_read = cmd_read[0];\n    ppi_icb_cmd_addr = cmd_addr[0];\n    ppi_icb_cmd_wdata = cmd_wdata[0];\n    ppi_icb_cmd_wmask = cmd_wmask[0];\n\n    clint_icb_cmd_valid = cmd_valid[1];\n    clint_icb_cmd_ready = cmd_ready[1];\n    clint_icb_cmd_read = cmd_read[1];\n    clint_icb_cmd_addr = cmd_addr[1];\n    clint_icb_cmd_wdata = cmd_wdata[1];\n    clint_icb_cmd_wmask = cmd_wmask[1];\n\n    plic_icb_cmd_valid = cmd_valid[2];\n    plic_icb_cmd_ready = cmd_ready[2];\n    plic_icb_cmd_read = cmd_read[2];\n    plic_icb_cmd_addr = cmd_addr[2];\n    plic_icb_cmd_wdata = cmd_wdata[2];\n    plic_icb_cmd_wmask = cmd_wmask[2];\n\n    fio_icb_cmd_valid = cmd_valid[3];\n    fio_icb_cmd_ready = cmd_ready[3];\n    fio_icb_cmd_read = cmd_read[3];\n    fio_icb_cmd_addr = cmd_addr[3];\n    fio_icb_cmd_wdata = cmd_wdata[3];\n    fio_icb_cmd_wmask = cmd_wmask[3];\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 2, "code": "module e203_dtcm_ctrl (\n    input  logic                clk,\n    input  logic                rst_n,\n    input  logic                test_mode,\n    input  logic                tcm_cgstop,\n    output logic                dtcm_active,\n    // LSU ICB Bus Interface\n    input  logic                lsu2dtcm_icb_cmd_valid,\n    output logic                lsu2dtcm_icb_cmd_ready,\n    input  logic [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input  logic                lsu2dtcm_icb_cmd_read,\n    input  logic [31:0]         lsu2dtcm_icb_cmd_wdata,\n    input  logic [3:0]          lsu2dtcm_icb_cmd_wmask,\n    output logic                lsu2dtcm_icb_rsp_valid,\n    input  logic                lsu2dtcm_icb_rsp_ready,\n    output logic                lsu2dtcm_icb_rsp_err,\n    output logic [31:0]         lsu2dtcm_icb_rsp_rdata,\n    // External ICB Bus Interface (Optional)\n    input  logic                ext2dtcm_icb_cmd_valid,\n    output logic                ext2dtcm_icb_cmd_ready,\n    input  logic [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input  logic                ext2dtcm_icb_cmd_read,\n    input  logic [31:0]         ext2dtcm_icb_cmd_wdata,\n    input  logic [3:0]          ext2dtcm_icb_cmd_wmask,\n    output logic                ext2dtcm_icb_rsp_valid,\n    input  logic                ext2dtcm_icb_rsp_ready,\n    output logic                ext2dtcm_icb_rsp_err,\n    output logic [31:0]         ext2dtcm_icb_rsp_rdata,\n    // DTCM RAM Interface\n    output logic                dtcm_ram_cs,\n    output logic                dtcm_ram_we,\n    output logic [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output logic [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input  logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output logic                clk_dtcm_ram\n);\n\n// Internal signals and variables\nlogic [E203_DTCM_ADDR_WIDTH-1:0] addr;\nlogic cmd_read;\nlogic [3:0] wmask;\nlogic [31:0] wdata;\nlogic [31:0] rdata;\nlogic cmd_valid, cmd_ready, rsp_valid, rsp_ready, rsp_err;\n\n// Bus arbiter\nsirv_gnrl_icb_arbt #(\n    .ARBT_SCHEME            (0),\n    .ALLOW_0CYCL_RSP        (0),\n    .FIFO_OUTS_NUM          (E203_DTCM_OUTS_NUM),\n    .FIFO_CUT_READY         (0),\n    .USR_W                  (1),\n    .ARBT_NUM               (DTCM_ARBT_I_NUM),\n    .AW                     (E203_DTCM_ADDR_WIDTH),\n    .DW                     (E203_DTCM_DATA_WIDTH),\n    .ARBT_PTR_W             (DTCM_ARBT_I_PTR_W)\n) u_arbiter (\n    .o_icb_cmd_valid        (cmd_valid),\n    .o_icb_cmd_ready        (cmd_ready),\n    .o_icb_cmd_read         (cmd_read),\n    .o_icb_cmd_addr         (addr),\n    .o_icb_cmd_wdata        (wdata),\n    .o_icb_cmd_wmask        (wmask),\n    .o_icb_cmd_burst        (),\n    .o_icb_cmd_beat         (),\n    .o_icb_cmd_lock         (),\n    .o_icb_cmd_excl         (),\n    .o_icb_cmd_size         (),\n    .o_icb_cmd_usr          (),\n    .o_icb_rsp_valid        (rsp_valid),\n    .o_icb_rsp_ready        (rsp_ready),\n    .o_icb_rsp_err          (rsp_err),\n    .o_icb_rsp_excl_ok      (),\n    .o_icb_rsp_rdata        (rdata),\n    .o_icb_rsp_usr          (),\n    .i_bus_icb_cmd_ready    ({ext2dtcm_icb_cmd_ready, lsu2dtcm_icb_cmd_ready}),\n    .i_bus_icb_cmd_valid    ({ext2dtcm_icb_cmd_valid, lsu2dtcm_icb_cmd_valid}),\n    .i_bus_icb_cmd_read     ({ext2dtcm_icb_cmd_read, lsu2dtcm_icb_cmd_read}),\n    .i_bus_icb_cmd_addr     ({ext2dtcm_icb_cmd_addr, lsu2dtcm_icb_cmd_addr}),\n    .i_bus_icb_cmd_wdata    ({ext2dtcm_icb_cmd_wdata, lsu2dtcm_icb_cmd_wdata}),\n    .i_bus_icb_cmd_wmask    ({ext2dtcm_icb_cmd_wmask, lsu2dtcm_icb_cmd_wmask}),\n    .i_bus_icb_cmd_burst    ({2'b00, 2'b00}),\n    .i_bus_icb_cmd_beat     ({2'b00, 2'b00}),\n    .i_bus_icb_cmd_lock     ({1'b0, 1'b0}),\n    .i_bus_icb_cmd_excl     ({1'b0, 1'b0}),\n    .i_bus_icb_cmd_size     ({2'b00, 2'b00}),\n    .i_bus_icb_cmd_usr      ({1'b0, 1'b0}),\n    .i_bus_icb_rsp_valid    ({ext2dtcm_icb_rsp_valid, lsu2dtcm_icb_rsp_valid}),\n    .i_bus_icb_rsp_ready    ({ext2dtcm_icb_rsp_ready, lsu2dtcm_icb_rsp_ready}),\n    .i_bus_icb_rsp_err      ({ext2dtcm_icb_rsp_err, lsu2dtcm_icb_rsp_err}),\n    .i_bus_icb_rsp_excl_ok  ({1'b0, 1'b0}),\n    .i_bus_icb_rsp_rdata    ({ext2dtcm_icb_rsp_rdata, lsu2dtcm_icb_rsp_rdata}),\n    .i_bus_icb_rsp_usr      ({1'b0, 1'b0}),\n    .clk                   (clk),\n    .rst_n                 (rst_n)\n);\n\n// SRAM controller\nsirv_sram_icb_ctrl #(\n    .DW                     (E203_DTCM_DATA_WIDTH),\n    .AW                     (E203_DTCM_ADDR_WIDTH),\n    .MW                     (E203_DTCM_WMSK_WIDTH),\n    .AW_LSB                 (2),\n    .USR_W                  (1)\n) u_sram_ctrl (\n    .sram_ctrl_active       (dtcm_active),\n    .tcm_cgstop             (tcm_cgstop),\n    .i_icb_cmd_valid        (cmd_valid),\n    .i_icb_cmd_ready        (cmd_ready),\n    .i_icb_cmd_read         (cmd_read),\n    .i_icb_cmd_addr         (addr),\n    .i_icb_cmd_wdata        (wdata),\n    .i_icb_cmd_wmask        (wmask),\n    .i_icb_cmd_usr          (1'b0),\n    .i_icb_rsp_valid        (rsp_valid),\n    .i_icb_rsp_ready        (rsp_ready),\n    .i_icb_rsp_rdata        (rdata),\n    .i_icb_rsp_usr          (1'b0),\n    .ram_cs                 (dtcm_ram_cs),\n    .ram_we                 (dtcm_ram_we),\n    .ram_addr               (dtcm_ram_addr),\n    .ram_wem                (dtcm_ram_wem),\n    .ram_din                (dtcm_ram_din),\n    .ram_dout               (dtcm_ram_dout),\n    .clk_ram                (clk_dtcm_ram),\n    .test_mode              (test_mode),\n    .clk                    (clk),\n    .rst_n                  (rst_n)\n);\n\nassign lsu2dtcm_icb_cmd_ready = cmd_ready;\nassign lsu2dtcm_icb_rsp_valid = rsp_valid;\nassign lsu2dtcm_icb_rsp_err = rsp_err;\nassign lsu2dtcm_icb_rsp_rdata = rdata;\n\nassign ext2dtcm_icb_cmd_ready = cmd_ready;\nassign ext2dtcm_icb_rsp_valid = rsp_valid;\nassign ext2dtcm_icb_rsp_err = rsp_err;\nassign ext2dtcm_icb_rsp_rdata = rdata;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 4, "code": "module e203_exu_longpwbck(\n    input             clk,\n    input             rst_n,\n\n    // LSU Interface\n    input             lsu_wbck_i_valid,\n    output            lsu_wbck_i_ready,\n    input      [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input      [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input             lsu_wbck_i_err,\n    input             lsu_cmt_i_buserr,\n    input      [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input             lsu_cmt_i_ld,\n    input             lsu_cmt_i_st,\n\n    // NICE Interface (if E203_HAS_NICE is defined)\n    `ifdef E203_HAS_NICE\n    input             nice_longp_wbck_i_valid,\n    output            nice_longp_wbck_i_ready,\n    input      [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input      [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input             nice_longp_wbck_i_err,\n    `endif\n\n    // Long-Pipeline Write-Back Interface\n    output            longp_wbck_o_valid,\n    input             longp_wbck_o_ready,\n    output     [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output     [4:0] longp_wbck_o_flags,\n    output     [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output            longp_wbck_o_rdfpu,\n\n    // Exception Interface\n    output            longp_excp_o_valid,\n    input             longp_excp_o_ready,\n    output            longp_excp_o_insterr,\n    output            longp_excp_o_ld,\n    output            longp_excp_o_st,\n    output            longp_excp_o_buserr,\n    output     [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output     [E203_PC_SIZE-1:0] longp_excp_o_pc,\n\n    // OITF Interface\n    input             oitf_empty,\n    input      [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input      [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input      [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input             oitf_ret_rdwen,\n    input             oitf_ret_rdfpu,\n    output            oitf_ret_ena\n);\n\n// Internal signals and variables\nreg [E203_ITAG_WIDTH-1:0] curr_itag;\nreg [E203_RFIDX_WIDTH-1:0] curr_rdidx;\nreg curr_rdwen;\nreg curr_rdfpu;\nreg [E203_XLEN-1:0] curr_wdat;\nreg curr_err;\nreg curr_buserr;\nreg [E203_ADDR_SIZE-1:0] curr_badaddr;\nreg curr_ld;\nreg curr_st;\n\n// Write-Back Needs\nwire wb_needs = (oitf_ret_rdwen && !curr_err) || (curr_err && longp_excp_o_ready);\n\n// Exception Needs\nwire excp_needs = curr_err && !oitf_ret_rdwen;\n\n// LSU Write-Back Request\nwire lsu_wbck_req = lsu_wbck_i_valid && (oitf_ret_ptr == lsu_wbck_i_itag);\n\n// NICE Write-Back Request (if E203_HAS_NICE is defined)\n`ifdef E203_HAS_NICE\nwire nice_wbck_req = nice_longp_wbck_i_valid && (oitf_ret_ptr == nice_longp_wbck_i_itag);\n`endif\n\n// Long-Pipeline Write-Back Valid\nassign longp_wbck_o_valid = (wb_needs && lsu_wbck_req && longp_wbck_o_ready) ||\n                            `ifdef E203_HAS_NICE\n                            (wb_needs && nice_wbck_req && longp_wbck_o_ready);\n`endif\n\n// Long-Pipeline Write-Back Data\nassign longp_wbck_o_wdat = curr_wdat;\n\n// Long-Pipeline Write-Back Flags\nassign longp_wbck_o_flags = {curr_ld, curr_st, curr_err, curr_buserr, 1'b0};\n\n// Long-Pipeline Write-Back Register Index\nassign longp_wbck_o_rdidx = curr_rdidx;\n\n// Long-Pipeline Write-Back FPU\nassign longp_wbck_o_rdfpu = curr_rdfpu;\n\n// Exception Valid\nassign longp_excp_o_valid = (excp_needs && lsu_wbck_req && longp_excp_o_ready) ||\n                            `ifdef E203_HAS_NICE\n                            (excp_needs && nice_wbck_req && longp_excp_o_ready);\n`endif\n\n// Exception Signals\nassign longp_excp_o_insterr = curr_err;\nassign longp_excp_o_ld = curr_ld;\nassign longp_excp_o_st = curr_st;\nassign longp_excp_o_buserr = curr_buserr;\nassign longp_excp_o_badaddr = curr_badaddr;\nassign longp_excp_o_pc = oitf_ret_pc;\n\n// OITF Retire Enable\nassign oitf_ret_ena = (wb_needs || excp_needs) && (lsu_wbck_req || `ifdef E203_HAS_NICE\n                                                    nice_wbck_req);\n`endif\n\n// LSU Write-Back Ready\nassign lsu_wbck_i_ready = (wb_needs && lsu_wbck_req && longp_wbck_o_ready) ||\n                          `ifdef E203_HAS_NICE\n                          (wb_needs && nice_wbck_req && longp_wbck_o_ready);\n`endif\n\n// NICE Write-Back Ready (if E203_HAS_NICE is defined)\n`ifdef E203_HAS_NICE\nassign nice_longp_wbck_i_ready = (wb_needs && nice_wbck_req && longp_wbck_o_ready);\n`endif\n\n// Internal signal assignments\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        curr_itag <= '0;\n        curr_rdidx <= '0;\n        curr_rdwen <= 1'b0;\n        curr_rdfpu <= 1'b0;\n        curr_wdat <= '0;\n        curr_err <= 1'b0;\n        curr_buserr <= 1'b0;\n        curr_badaddr <= '0;\n        curr_ld <= 1'b0;\n        curr_st <= 1'b0;\n    end else begin\n        if (lsu_wbck_req) begin\n            curr_itag <= lsu_wbck_i_itag;\n            curr_rdidx <= oitf_ret_rdidx;\n            curr_rdwen <= oitf_ret_rdwen;\n            curr_rdfpu <= oitf_ret_rdfpu;\n            curr_wdat <= lsu_wbck_i_wdat;\n            curr_err <= lsu_wbck_i_err;\n            curr_buserr <= lsu_cmt_i_buserr;\n            curr_badaddr <= lsu_cmt_i_badaddr;\n            curr_ld <= lsu_cmt_i_ld;\n            curr_st <= lsu_cmt_i_st;\n        end else `ifdef E203_HAS_NICE\n            if (nice_wbck_req) begin\n                curr_itag <= nice_longp_wbck_i_itag;\n                curr_rdidx <= oitf_ret_rdidx;\n                curr_rdwen <= oitf_ret_rdwen;\n                curr_rdfpu <= oitf_ret_rdfpu;\n                curr_wdat <= nice_longp_wbck_i_wdat;\n                curr_err <= nice_longp_wbck_i_err;\n                curr_buserr <= 1'b0;\n                curr_badaddr <= '0;\n                curr_ld <= 1'b0;\n                curr_st <= 1'b0;\n            end\n`endif\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 3, "code": "// Define the module and its ports\nmodule e203_exu_alu_muldiv(\n    input  mdv_nob2b,          // Indicates no back-to-back operations are allowed\n    input  muldiv_i_valid,     // Handshake valid signal for MUL/DIV input\n    output muldiv_i_ready,     // Handshake ready signal for MUL/DIV input\n    input  [E203_XLEN-1:0] muldiv_i_rs1,  // Operand RS1 for multiplication or division\n    input  [E203_XLEN-1:0] muldiv_i_rs2,  // Operand RS2 for multiplication or division\n    input  [E203_XLEN-1:0] muldiv_i_imm,  // Immediate operand for multiplication or division\n    input  [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,  // Information bus for MUL/DIV\n    input  [E203_ITAG_WIDTH-1:0] muldiv_i_itag,  // Instruction tag for MUL/DIV operations\n    output muldiv_i_longpipe,  // Indicates that the MUL/DIV operation is a long pipeline operation\n    input  flush_pulse,        // Flush signal to reset the MUL/DIV pipeline\n    output muldiv_o_valid,     // Handshake valid signal for MUL/DIV output\n    input  muldiv_o_ready,     // Handshake ready signal for MUL/DIV output\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat,  // Write-back data resulting from the MUL/DIV operation\n    output muldiv_o_wbck_err,  // Write-back error signal (always 0, as there are no exceptions for MUL/DIV)\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,  // Operand 1 for the shared ALU datapath\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,  // Operand 2 for the shared ALU datapath\n    output muldiv_req_alu_add,  // Indicates add operation for the shared ALU datapath\n    output muldiv_req_alu_sub,  // Indicates subtract operation for the shared ALU datapath\n    input  [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,  // Result from the shared ALU datapath\n    output muldiv_sbf_0_ena,    // Enable signal for shared buffer 0\n    output [32:0] muldiv_sbf_0_nxt,  // Next value to write to shared buffer 0\n    input  [32:0] muldiv_sbf_0_r,    // Current value of shared buffer 0\n    output muldiv_sbf_1_ena,    // Enable signal for shared buffer 1\n    output [32:0] muldiv_sbf_1_nxt,  // Next value to write to shared buffer 1\n    input  [32:0] muldiv_sbf_1_r,    // Current value of shared buffer 1\n    input  clk,                  // Clock signal for synchronous operation\n    input  rst_n                 // Active-low reset signal for initializing the module\n);\n\n// Define the internal signals and variables\nreg [E203_XLEN-1:0] rs1_reg;\nreg [E203_XLEN-1:0] rs2_reg;\nreg [E203_XLEN-1:0] imm_reg;\nreg [E203_DECINFO_MULDIV_WIDTH-1:0] info_reg;\nreg [E203_ITAG_WIDTH-1:0] itag_reg;\nreg muldiv_i_longpipe_reg;\nreg [E203_MULDIV_ADDER_WIDTH-1:0] alu_op1_reg;\nreg [E203_MULDIV_ADDER_WIDTH-1:0] alu_op2_reg;\nreg alu_add_reg;\nreg alu_sub_reg;\nreg [32:0] sbf_0_nxt_reg;\nreg [32:0] sbf_1_nxt_reg;\n\n// Define the state machine\nreg [2:0] state_reg;\nreg [2:0] next_state_reg;\n\n// Define the combinational logic\nalways @(*) begin\n    // Handle the input handshake\n    if (muldiv_i_valid && !mdv_nob2b) begin\n        muldiv_i_ready = 1'b1;\n    end else begin\n        muldiv_i_ready = 1'b0;\n    end\n\n    // Handle the output handshake\n    if (muldiv_o_valid && muldiv_o_ready) begin\n        muldiv_o_valid = 1'b0;\n    end\n\n    // Handle the state machine transitions\n    case (state_reg)\n        3'b000: begin  // Initial state\n            if (muldiv_i_valid) begin\n                next_state_reg = 3'b001;\n            end else begin\n                next_state_reg = 3'b000;\n            end\n        end\n        3'b001: begin  // Execution state\n            if (muldiv_i_longpipe) begin\n                next_state_reg = 3'b010;\n            end else begin\n                next_state_reg = 3'b000;\n            end\n        end\n        3'b010: begin  // Long pipeline state\n            if (muldiv_o_ready) begin\n                next_state_reg = 3'b000;\n            end else begin\n                next_state_reg = 3'b010;\n            end\n        end\n        default: begin\n            next_state_reg = 3'b000;\n        end\n    endcase\n\n    // Handle the multiplication and division operations\n    case (info_reg)\n        E203_DECINFO_MULDIV_MUL: begin\n            // Multiplication operation\n            alu_op1_reg = rs1_reg;\n            alu_op2_reg = rs2_reg;\n            alu_add_reg = 1'b1;\n            alu_sub_reg = 1'b0;\n        end\n        E203_DECINFO_MULDIV_DIV: begin\n            // Division operation\n            alu_op1_reg = rs1_reg;\n            alu_op2_reg = rs2_reg;\n            alu_add_reg = 1'b0;\n            alu_sub_reg = 1'b1;\n        end\n        default: begin\n            alu_op1_reg = 'b0;\n            alu_op2_reg = 'b0;\n            alu_add_reg = 1'b0;\n            alu_sub_reg = 1'b0;\n        end\n    endcase\n\n    // Handle the shared buffer operations\n    if (muldiv_sbf_0_ena) begin\n        sbf_0_nxt_reg = {32{1'b0}};\n    end\n\n    if (muldiv_sbf_1_ena) begin\n        sbf_1_nxt_reg = {32{1'b0}};\n    end\nend\n\n// Define the sequential logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state_reg <= 3'b000;\n        rs1_reg <= 'b0;\n        rs2_reg <= 'b0;\n        imm_reg <= 'b0;\n        info_reg <= 'b0;\n        itag_reg <= 'b0;\n        muldiv_i_longpipe_reg <= 1'b0;\n        alu_op1_reg <= 'b0;\n        alu_op2_reg <= 'b0;\n        alu_add_reg <= 1'b0;\n        alu_sub_reg <= 1'b0;\n        sbf_0_nxt_reg <= 'b0;\n        sbf_1_nxt_reg <= 'b0;\n    end else begin\n        state_reg <= next_state_reg;\n        rs1_reg <= muldiv_i_rs1;\n        rs2_reg <= muldiv_i_rs2;\n        imm_reg <= muldiv_i_imm;\n        info_reg <= muldiv_i_info;\n        itag_reg <= muldiv_i_itag;\n        muldiv_i_longpipe_reg <= muldiv_i_longpipe;\n        alu_op1_reg <= muldiv_req_alu_op1;\n        alu_op2_reg <= muldiv_req_alu_op2;\n        alu_add_reg <= muldiv_req_alu_add;\n        alu_sub_reg <= muldiv_req_alu_sub;\n        sbf_0_nxt_reg <= muldiv_sbf_0_nxt;\n        sbf_1_nxt_reg <= muldiv_sbf_1_nxt;\n    end\nend\n\n// Assign the outputs\nassign muldiv_i_ready = muldiv_i_ready;\nassign muldiv_o_valid = (state_reg == 3'b010);\nassign muldiv_o_wbck_wdat = (alu_add_reg) ? alu_op1_reg + alu_op2_reg : alu_op1_reg - alu_op2_reg;\nassign muldiv_o_wbck_err = 1'b0;\nassign muldiv_req_alu_op1 = alu_op1_reg;\nassign muldiv_req_alu_op2 = alu_op2_reg;\nassign muldiv_req_alu_add = alu_add_reg;\nassign muldiv_req_alu_sub = alu_sub_reg;\nassign muldiv_sbf_0_ena = (state_reg == 3'b001);\nassign muldiv_sbf_0_nxt = sbf_0_nxt_reg;\nassign muldiv_sbf_1_ena = (state_reg == 3'b001);\nassign muldiv_sbf_1_nxt = sbf_1_nxt_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 2, "code": "module e203_lsu_ctrl (\n    // Control Interface\n    input  logic commit_mret,\n    input  logic commit_trap,\n    output logic lsu_ctrl_active,\n\n    // LSU Write-back Interface\n    output logic lsu_o_valid,\n    input  logic lsu_o_ready,\n    output logic [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output logic [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output logic lsu_o_wbck_err,\n    output logic lsu_o_cmt_buserr,\n    output logic [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output logic lsu_o_cmt_ld,\n    output logic lsu_o_cmt_st,\n\n    // AGU-ICB Interface\n    input  logic agu_icb_cmd_valid,\n    output logic agu_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input  logic agu_icb_cmd_read,\n    input  logic [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    input  logic agu_icb_cmd_lock,\n    input  logic agu_icb_cmd_excl,\n    input  logic [1:0] agu_icb_cmd_size,\n    input  logic agu_icb_cmd_back2agu,\n    input  logic agu_icb_cmd_usign,\n    input  logic [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    // AGU-ICB Response Interface\n    output logic agu_icb_rsp_valid,\n    input  logic agu_icb_rsp_ready,\n    output logic agu_icb_rsp_err,\n    output logic agu_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    // NICE Interface (Optional Configuration)\n    input  logic nice_mem_holdup,\n    input  logic nice_icb_cmd_valid,\n    output logic nice_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input  logic nice_icb_cmd_read,\n    input  logic [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] nice_icb_cmd_wmask,\n    output logic nice_icb_rsp_valid,\n    input  logic nice_icb_rsp_ready,\n    output logic nice_icb_rsp_err,\n    output logic [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    // Memory Interfaces\n    // DCache Interface (Optional Configuration)\n    output logic dcache_icb_cmd_valid,\n    input  logic dcache_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output logic dcache_icb_cmd_read,\n    output logic [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] dcache_icb_cmd_wmask,\n    output logic dcache_icb_cmd_lock,\n    output logic dcache_icb_cmd_excl,\n    output logic [1:0] dcache_icb_cmd_size,\n    input  logic dcache_icb_rsp_valid,\n    output logic dcache_icb_rsp_ready,\n    input  logic dcache_icb_rsp_err,\n    input  logic dcache_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    // DTCM Interface (Optional Configuration)\n    output logic dtcm_icb_cmd_valid,\n    input  logic dtcm_icb_cmd_ready,\n    output logic [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output logic dtcm_icb_cmd_read,\n    output logic [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] dtcm_icb_cmd_wmask,\n    output logic dtcm_icb_cmd_lock,\n    output logic dtcm_icb_cmd_excl,\n    output logic [1:0] dtcm_icb_cmd_size,\n    input  logic dtcm_icb_rsp_valid,\n    output logic dtcm_icb_rsp_ready,\n    input  logic dtcm_icb_rsp_err,\n    input  logic dtcm_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    input  logic [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n\n    // ITCM Interface (Optional Configuration)\n    output logic itcm_icb_cmd_valid,\n    input  logic itcm_icb_cmd_ready,\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] itcm_icb_cmd_addr,\n    output logic itcm_icb_cmd_read,\n    output logic [E203_XLEN-1:0] itcm_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] itcm_icb_cmd_wmask,\n    output logic itcm_icb_cmd_lock,\n    output logic itcm_icb_cmd_excl,\n    output logic [1:0] itcm_icb_cmd_size,\n    input  logic itcm_icb_rsp_valid,\n    output logic itcm_icb_rsp_ready,\n    input  logic itcm_icb_rsp_err,\n    input  logic itcm_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] itcm_icb_rsp_rdata,\n    input  logic [E203_ADDR_SIZE-1:0] itcm_region_indic,\n\n    // BIU Interface\n    output logic biu_icb_cmd_valid,\n    input  logic biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output logic biu_icb_cmd_read,\n    output logic [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] biu_icb_cmd_wmask,\n    output logic biu_icb_cmd_lock,\n    output logic biu_icb_cmd_excl,\n    output logic [1:0] biu_icb_cmd_size,\n    input  logic biu_icb_rsp_valid,\n    output logic biu_icb_rsp_ready,\n    input  logic biu_icb_rsp_err,\n    input  logic biu_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] biu_icb_rsp_rdata,\n\n    // Clock and Reset\n    input  logic clk,\n    input  logic rst_n\n);", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 3, "code": "module e203_lsu_ctrl (\n    input  logic                               commit_mret,\n    input  logic                               commit_trap,\n    output logic                               lsu_ctrl_active,\n\n    // LSU Write-back Interface\n    output logic                               lsu_o_valid,\n    input  logic                               lsu_o_ready,\n    output logic [E203_XLEN-1:0]               lsu_o_wbck_wdat,\n    output logic [E203_ITAG_WIDTH-1:0]         lsu_o_wbck_itag,\n    output logic                               lsu_o_wbck_err,\n    output logic                               lsu_o_cmt_buserr,\n    output logic [E203_ADDR_SIZE-1:0]          lsu_o_cmt_badaddr,\n    output logic                               lsu_o_cmt_ld,\n    output logic                               lsu_o_cmt_st,\n\n    // AGU-ICB Interface\n    input  logic                               agu_icb_cmd_valid,\n    output logic                               agu_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0]          agu_icb_cmd_addr,\n    input  logic                               agu_icb_cmd_read,\n    input  logic [E203_XLEN-1:0]               agu_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0]             agu_icb_cmd_wmask,\n    input  logic                               agu_icb_cmd_lock,\n    input  logic                               agu_icb_cmd_excl,\n    input  logic [1:0]                         agu_icb_cmd_size,\n    input  logic                               agu_icb_cmd_back2agu,\n    input  logic                               agu_icb_cmd_usign,\n    input  logic [E203_ITAG_WIDTH-1:0]         agu_icb_cmd_itag,\n\n    // AGU-ICB Response Interface\n    output logic                               agu_icb_rsp_valid,\n    input  logic                               agu_icb_rsp_ready,\n    output logic                               agu_icb_rsp_err,\n    output logic                               agu_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0]               agu_icb_rsp_rdata,\n\n    // NICE Interface (Optional Configuration)\n    input  logic                               nice_mem_holdup,\n    input  logic                               nice_icb_cmd_valid,\n    output logic                               nice_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0]          nice_icb_cmd_addr,\n    input  logic                               nice_icb_cmd_read,\n    input  logic [E203_XLEN-1:0]               nice_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0]             nice_icb_cmd_wmask,\n    output logic                               nice_icb_rsp_valid,\n    input  logic                               nice_icb_rsp_ready,\n    output logic                               nice_icb_rsp_err,\n    output logic [E203_XLEN-1:0]               nice_icb_rsp_rdata,\n\n    // Memory Interfaces\n    output logic                               dcache_icb_cmd_valid,\n    input  logic                               dcache_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0]          dcache_icb_cmd_addr,\n    output logic                               dcache_icb_cmd_read,\n    output logic [E203_XLEN-1:0]               dcache_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0]             dcache_icb_cmd_wmask,\n    output logic                               dcache_icb_cmd_lock,\n    output logic                               dcache_icb_cmd_excl,\n    output logic [1:0]                         dcache_icb_cmd_size,\n    input  logic                               dcache_icb_rsp_valid,\n    output logic                               dcache_icb_rsp_ready,\n    input  logic                               dcache_icb_rsp_err,\n    input  logic                               dcache_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0]               dcache_icb_rsp_rdata,\n\n    output logic                               dtcm_icb_cmd_valid,\n    input  logic                               dtcm_icb_cmd_ready,\n    output logic [E203_DTCM_ADDR_WIDTH-1:0]    dtcm_icb_cmd_addr,\n    output logic                               dtcm_icb_cmd_read,\n    output logic [E203_XLEN-1:0]               dtcm_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0]             dtcm_icb_cmd_wmask,\n    output logic                               dtcm_icb_cmd_lock,\n    output logic                               dtcm_icb_cmd_excl,\n    output logic [1:0]                         dtcm_icb_cmd_size,\n    input  logic                               dtcm_icb_rsp_valid,\n    output logic                               dtcm_icb_rsp_ready,\n    input  logic                               dtcm_icb_rsp_err,\n    input  logic                               dtcm_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0]               dtcm_icb_rsp_rdata,\n\n    output logic                               itcm_icb_cmd_valid,\n    input  logic                               itcm_icb_cmd_ready,\n    output logic [E203_ITCM_ADDR_WIDTH-1:0]    itcm_icb_cmd_addr,\n    output logic                               itcm_icb_cmd_read,\n    output logic [E203_XLEN-1:0]               itcm_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0]             itcm_icb_cmd_wmask,\n    output logic                               itcm_icb_cmd_lock,\n    output logic                               itcm_icb_cmd_excl,\n    output logic [1:0]                         itcm_icb_cmd_size,\n    input  logic                               itcm_icb_rsp_valid,\n    output logic                               itcm_icb_rsp_ready,\n    input  logic                               itcm_icb_rsp_err,\n    input  logic                               itcm_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0]               itcm_icb_rsp_rdata,\n\n    output logic                               biu_icb_cmd_valid,\n    input  logic                               biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0]          biu_icb_cmd_addr,\n    output logic                               biu_icb_cmd_read,\n    output logic [E203_XLEN-1:0]               biu_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0]             biu_icb_cmd_wmask,\n    output logic                               biu_icb_cmd_lock,\n    output logic                               biu_icb_cmd_excl,\n    output logic [1:0]                         biu_icb_cmd_size,\n    input  logic                               biu_icb_rsp_valid,\n    output logic                               biu_icb_rsp_ready,\n    input  logic                               biu_icb_rsp_err,\n    input  logic                               biu_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0]               biu_icb_rsp_rdata\n);\n\n// Rest of the module implementation...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 5, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_longpwbck(\n    input                   clk,\n    input                   rst_n,\n\n    // LSU Interface\n    input                   lsu_wbck_i_valid,\n    output                  lsu_wbck_i_ready,\n    input   [E203_XLEN-1:0] lsu_wbck_i_wdat,\n    input   [E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input                   lsu_wbck_i_err,\n    input                   lsu_cmt_i_buserr,\n    input   [E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input                   lsu_cmt_i_ld,\n    input                   lsu_cmt_i_st,\n\n    // Long-Pipeline Write-Back Interface\n    output                  longp_wbck_o_valid,\n    input                   longp_wbck_o_ready,\n    output  [E203_FLEN-1:0] longp_wbck_o_wdat,\n    output  [4:0]           longp_wbck_o_flags,\n    output  [E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output                  longp_wbck_o_rdfpu,\n    // Exception Interface\n    output                  longp_excp_o_valid,\n    input                   longp_excp_o_ready,\n    output                  longp_excp_o_insterr,\n    output                  longp_excp_o_ld,\n    output                  longp_excp_o_st,\n    output                  longp_excp_o_buserr,\n    output  [E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output  [E203_PC_SIZE-1:0] longp_excp_o_pc,\n\n    // OITF Interface\n    input                   oitf_empty,\n    input   [E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input   [E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input   [E203_PC_SIZE-1:0] oitf_ret_pc,\n    input                   oitf_ret_rdwen,\n    input                   oitf_ret_rdfpu,\n    output                  oitf_ret_ena,\n\n    // NICE Interface (optional)\n    `ifdef E203_HAS_NICE\n    input                   nice_longp_wbck_i_valid,\n    output                  nice_longp_wbck_i_ready,\n    input   [E203_XLEN-1:0] nice_longp_wbck_i_wdat,\n    input   [E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input                   nice_longp_wbck_i_err,\n    `endif\n);\n\n// Internal signals\nreg [E203_ITAG_WIDTH-1:0] curr_itag;\nreg [E203_RFIDX_WIDTH-1:0] curr_rdidx;\nreg curr_rdwen;\nreg curr_rdfpu;\nreg [E203_PC_SIZE-1:0] curr_pc;\nreg wb_need;\nreg excp_need;\nreg lsu_wbck_i_ready_int;\nreg longp_wbck_o_valid_int;\nreg longp_excp_o_valid_int;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        lsu_wbck_i_ready_int <= 1'b0;\n        longp_wbck_o_valid_int <= 1'b0;\n        longp_excp_o_valid_int <= 1'b0;\n    end else begin\n        // LSU write-back ready signal\n        lsu_wbck_i_ready_int <= (wb_need && longp_wbck_o_ready) || (excp_need && longp_excp_o_ready);\n\n        // Long-pipeline write-back valid signal\n        longp_wbck_o_valid_int <= wb_need && lsu_wbck_i_valid;\n\n        // Exception valid signal\n        longp_excp_o_valid_int <= excp_need && lsu_wbck_i_valid;\n    end\nend\n\nalways @(*) begin\n    // Write-back need\n    wb_need = oitf_ret_rdwen && !oitf_empty;\n\n    // Exception need\n    excp_need = lsu_wbck_i_err || lsu_cmt_i_buserr;\n\n    // Current instruction tag\n    curr_itag = oitf_ret_ptr;\n\n    // Current register index\n    curr_rdidx = oitf_ret_rdidx;\n\n    // Current register write enable\n    curr_rdwen = oitf_ret_rdwen;\n\n    // Current register is FPU\n    curr_rdfpu = oitf_ret_rdfpu;\n\n    // Current program counter\n    curr_pc = oitf_ret_pc;\n\n    // LSU write-back ready signal\n    lsu_wbck_i_ready = lsu_wbck_i_ready_int;\n\n    // Long-pipeline write-back valid signal\n    longp_wbck_o_valid = longp_wbck_o_valid_int;\n\n    // Exception valid signal\n    longp_excp_o_valid = longp_excp_o_valid_int;\n\n    // OITF retire enable signal\n    oitf_ret_ena = lsu_wbck_i_ready_int && lsu_wbck_i_valid;\n\n    // Long-pipeline write-back data\n    longp_wbck_o_wdat = lsu_wbck_i_wdat;\n\n    // Long-pipeline write-back flags\n    longp_wbck_o_flags = {lsu_cmt_i_ld, lsu_cmt_i_st, lsu_wbck_i_err, lsu_cmt_i_buserr, 1'b0};\n\n    // Long-pipeline write-back register index\n    longp_wbck_o_rdidx = curr_rdidx;\n\n    // Long-pipeline write-back register is FPU\n    longp_wbck_o_rdfpu = curr_rdfpu;\n\n    // Exception instruction error\n    longp_excp_o_insterr = lsu_wbck_i_err;\n\n    // Exception load\n    longp_excp_o_ld = lsu_cmt_i_ld;\n\n    // Exception store\n    longp_excp_o_st = lsu_cmt_i_st;\n\n    // Exception bus error\n    longp_excp_o_buserr = lsu_cmt_i_buserr;\n\n    // Exception bad address\n    longp_excp_o_badaddr = lsu_cmt_i_badaddr;\n\n    // Exception program counter\n    longp_excp_o_pc = curr_pc;\nend\n\n`ifdef E203_HAS_NICE\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        nice_longp_wbck_i_ready <= 1'b0;\n    end else begin\n        nice_longp_wbck_i_ready <= (wb_need && longp_wbck_o_ready) || (excp_need && longp_excp_o_ready);\n    end\nend\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 8, "code": "module e203_srams #(\n    parameter E203_HAS_ITCM = 1,\n    parameter E203_HAS_DTCM = 1,\n    parameter E203_ITCM_ADDR_WIDTH = 10,\n    parameter E203_DTCM_ADDR_WIDTH = 10,\n    parameter E203_ITCM_RAM_DP = 1024,\n    parameter E203_DTCM_RAM_DP = 1024,\n    parameter E203_ITCM_RAM_AW = E203_ITCM_ADDR_WIDTH - 3,\n    parameter E203_DTCM_RAM_AW = E203_DTCM_ADDR_WIDTH - 2,\n    parameter E203_ITCM_RAM_DW = 64,\n    parameter E203_DTCM_RAM_DW = 32,\n    parameter E203_ITCM_RAM_MW = E203_ITCM_RAM_DW / 8,\n    parameter E203_DTCM_RAM_MW = E203_DTCM_RAM_DW / 8\n) (\n    input  logic                   clk_itcm_ram,\n    input  logic                   rst_itcm,\n    input  logic                   itcm_ram_sd,\n    input  logic                   itcm_ram_ds,\n    input  logic                   itcm_ram_ls,\n    input  logic                   itcm_ram_cs,\n    input  logic                   itcm_ram_we,\n    input  logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    input  logic [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    input  logic [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    output logic [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n\n    input  logic                   clk_dtcm_ram,\n    input  logic                   rst_dtcm,\n    input  logic                   dtcm_ram_sd,\n    input  logic                   dtcm_ram_ds,\n    input  logic                   dtcm_ram_ls,\n    input  logic                   dtcm_ram_cs,\n    input  logic                   dtcm_ram_we,\n    input  logic [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    input  logic [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    input  logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    output logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout\n);\n\ngenerate\n    if (E203_HAS_ITCM) begin\n        itcm_ram u_itcm_ram (\n            .clk(clk_itcm_ram),\n            .rst(rst_itcm),\n            .sd(itcm_ram_sd),\n            .ds(itcm_ram_ds),\n            .ls(itcm_ram_ls),\n            .cs(itcm_ram_cs),\n            .we(itcm_ram_we),\n            .addr(itcm_ram_addr),\n            .wem(itcm_ram_wem),\n            .din(itcm_ram_din),\n            .dout(itcm_ram_dout)\n        );\n    end else begin\n        assign itcm_ram_dout = '0;\n    end\nendgenerate\n\ngenerate\n    if (E203_HAS_DTCM) begin\n        dtcm_ram u_dtcm_ram (\n            .clk(clk_dtcm_ram),\n            .rst(rst_dtcm),\n            .sd(dtcm_ram_sd),\n            .ds(dtcm_ram_ds),\n            .ls(dtcm_ram_ls),\n            .cs(dtcm_ram_cs),\n            .we(dtcm_ram_we),\n            .addr(dtcm_ram_addr),\n            .wem(dtcm_ram_wem),\n            .din(dtcm_ram_din),\n            .dout(dtcm_ram_dout)\n        );\n    end else begin\n        assign dtcm_ram_dout = '0;\n    end\nendgenerate\n\nendmodule\n\nmodule itcm_ram #(\n    parameter AW = 10,\n    parameter DW = 64,\n    parameter MW = DW / 8,\n    parameter DP = 1024\n) (\n    input  logic                   clk,\n    input  logic                   rst,\n    input  logic                   sd,\n    input  logic                   ds,\n    input  logic                   ls,\n    input  logic                   cs,\n    input  logic                   we,\n    input  logic [AW-1:0]          addr,\n    input  logic [MW-1:0]          wem,\n    input  logic [DW-1:0]          din,\n    output logic [DW-1:0]          dout\n);\n\nlogic [DW-1:0] ram [DP-1:0];\n\nalways_ff @(posedge clk) begin\n    if (rst) begin\n        for (int i = 0; i < DP; i++) begin\n            ram[i] <= '0;\n        end\n    end else if (cs && we) begin\n        for (int i = 0; i < MW; i++) begin\n            if (wem[i]) begin\n                ram[addr][i*8 +: 8] <= din[i*8 +: 8];\n            end\n        end\n    end\nend\n\nalways_comb begin\n    if (cs) begin\n        dout = ram[addr];\n    end else begin\n        dout = '0;\n    end\nend\n\nendmodule\n\nmodule dtcm_ram #(\n    parameter AW = 10,\n    parameter DW = 32,\n    parameter MW = DW / 8,\n    parameter DP = 1024\n) (\n    input  logic                   clk,\n    input  logic                   rst,\n    input  logic                   sd,\n    input  logic                   ds,\n    input  logic                   ls,\n    input  logic                   cs,\n    input  logic                   we,\n    input  logic [AW-1:0]          addr,\n    input  logic [MW-1:0]          wem,\n    input  logic [DW-1:0]          din,\n    output logic [DW-1:0]          dout\n);\n\nlogic [DW-1:0] ram [DP-1:0];\n\nalways_ff @(posedge clk) begin\n    if (rst) begin\n        for (int i = 0; i < DP; i++) begin\n            ram[i] <= '0;\n        end\n    end else if (cs && we) begin\n        for (int i = 0; i < MW; i++) begin\n            if (wem[i]) begin\n                ram[addr][i*8 +: 8] <= din[i*8 +: 8];\n            end\n        end\n    end\nend\n\nalways_comb begin\n    if (cs) begin\n        dout = ram[addr];\n    end else begin\n        dout = '0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 4, "code": "// Import necessary definitions\n`include \"e203_defines.v\"\n\nmodule e203_exu_alu_rglr(\n    // Input ports\n    input  logic                           alu_i_valid,\n    output logic                           alu_i_ready,\n    input  logic [E203_XLEN-1:0]           alu_i_rs1,\n    input  logic [E203_XLEN-1:0]           alu_i_rs2,\n    input  logic [E203_XLEN-1:0]           alu_i_imm,\n    input  logic [E203_PC_SIZE-1:0]        alu_i_pc,\n    input  logic [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    // Output ports\n    output logic                           alu_o_valid,\n    input  logic                           alu_o_ready,\n    output logic [E203_XLEN-1:0]           alu_o_wbck_wdat,\n    output logic                           alu_o_wbck_err,\n    output logic                           alu_o_cmt_ecall,\n    output logic                           alu_o_cmt_ebreak,\n    output logic                           alu_o_cmt_wfi,\n    // ALU request signals\n    output logic                           alu_req_alu_add,\n    output logic                           alu_req_alu_sub,\n    output logic                           alu_req_alu_xor,\n    output logic                           alu_req_alu_sll,\n    output logic                           alu_req_alu_srl,\n    output logic                           alu_req_alu_sra,\n    output logic                           alu_req_alu_or,\n    output logic                           alu_req_alu_and,\n    output logic                           alu_req_alu_slt,\n    output logic                           alu_req_alu_sltu,\n    output logic                           alu_req_alu_lui,\n    output logic [E203_XLEN-1:0]           alu_req_alu_op1,\n    output logic [E203_XLEN-1:0]           alu_req_alu_op2,\n    output logic [E203_XLEN-1:0]           alu_req_alu_res,\n    // Clock and reset signals\n    input  logic                           clk,\n    input  logic                           rst_n\n);\n\n// Internal signals\nlogic [E203_XLEN-1:0] op1, op2;\nlogic [E203_DECINFO_ALU_WIDTH-1:0] info;\n\n// Assign op1 and op2 based on the instruction information\nalways_comb begin\n    op1 = alu_i_rs1;\n    op2 = alu_i_rs2;\n    if (alu_i_info[E203_DECINFO_ALU_OP2IMM]) begin\n        op2 = alu_i_imm;\n    end\n    if (alu_i_info[E203_DECINFO_ALU_OP1PC]) begin\n        op1 = alu_i_pc;\n    end\nend\n\n// Generate ALU request signals\nalways_comb begin\n    alu_req_alu_add  = alu_i_info[E203_DECINFO_ALU_ADD]  && !alu_i_info[E203_DECINFO_ALU_NOP];\n    alu_req_alu_sub  = alu_i_info[E203_DECINFO_ALU_SUB];\n    alu_req_alu_xor  = alu_i_info[E203_DECINFO_ALU_XOR];\n    alu_req_alu_sll  = alu_i_info[E203_DECINFO_ALU_SLL];\n    alu_req_alu_srl  = alu_i_info[E203_DECINFO_ALU_SRL];\n    alu_req_alu_sra  = alu_i_info[E203_DECINFO_ALU_SRA];\n    alu_req_alu_or   = alu_i_info[E203_DECINFO_ALU_OR];\n    alu_req_alu_and  = alu_i_info[E203_DECINFO_ALU_AND];\n    alu_req_alu_slt  = alu_i_info[E203_DECINFO_ALU_SLT];\n    alu_req_alu_sltu = alu_i_info[E203_DECINFO_ALU_SLTU];\n    alu_req_alu_lui  = alu_i_info[E203_DECINFO_ALU_LUI];\nend\n\n// Assign alu_req_alu_op1, alu_req_alu_op2, and alu_req_alu_res\nalways_comb begin\n    alu_req_alu_op1 = op1;\n    alu_req_alu_op2 = op2;\n    alu_req_alu_res = op1 + op2; // Default operation\n    if (alu_i_info[E203_DECINFO_ALU_SUB]) begin\n        alu_req_alu_res = op1 - op2;\n    end\n    if (alu_i_info[E203_DECINFO_ALU_XOR]) begin\n        alu_req_alu_res = op1 ^ op2;\n    end\n    if (alu_i_info[E203_DECINFO_ALU_SLL]) begin\n        alu_req_alu_res = op1 << op2;\n    end\n    if (alu_i_info[E203_DECINFO_ALU_SRL]) begin\n        alu_req_alu_res = op1 >> op2;\n    end\n    if (alu_i_info[E203_DECINFO_ALU_SRA]) begin\n        alu_req_alu_res = $signed(op1) >>> op2;\n    end\n    if (alu_i_info[E203_DECINFO_ALU_OR]) begin\n        alu_req_alu_res = op1 | op2;\n    end\n    if (alu_i_info[E203_DECINFO_ALU_AND]) begin\n        alu_req_alu_res = op1 & op2;\n    end\n    if (alu_i_info[E203_DECINFO_ALU_SLT]) begin\n        alu_req_alu_res = $signed(op1) < $signed(op2);\n    end\n    if (alu_i_info[E203_DECINFO_ALU_SLTU]) begin\n        alu_req_alu_res = op1 < op2;\n    end\n    if (alu_i_info[E203_DECINFO_ALU_LUI]) begin\n        alu_req_alu_res = {op2, {E203_XLEN/2{1'b0}}};\n    end\nend\n\n// Valid-ready handshake\nalways_comb begin\n    alu_i_ready = alu_o_ready;\n    alu_o_valid = alu_i_valid;\nend\n\n// Assign alu_o_wbck_wdat, alu_o_wbck_err, alu_o_cmt_ecall, alu_o_cmt_ebreak, and alu_o_cmt_wfi\nalways_comb begin\n    alu_o_wbck_wdat = alu_req_alu_res;\n    alu_o_wbck_err = 1'b0;\n    alu_o_cmt_ecall = alu_i_info[E203_DECINFO_ALU_ECAL];\n    alu_o_cmt_ebreak = alu_i_info[E203_DECINFO_ALU_EBRK];\n    alu_o_cmt_wfi = alu_i_info[E203_DECINFO_ALU_WFI];\n    if (alu_i_info[E203_DECINFO_ALU_ECAL] || alu_i_info[E203_DECINFO_ALU_EBRK] || alu_i_info[E203_DECINFO_ALU_WFI]) begin\n        alu_o_wbck_err = 1'b1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 4, "code": "// Import necessary files\n`include \"e203_defines.v\"\n\n// Define the module\nmodule e203_lsu_ctrl (\n    // Control Interface\n    input  logic commit_mret,\n    input  logic commit_trap,\n    output logic lsu_ctrl_active,\n\n    // LSU Write-back Interface\n    output logic lsu_o_valid,\n    input  logic lsu_o_ready,\n    output logic [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output logic [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output logic lsu_o_wbck_err,\n    output logic lsu_o_cmt_buserr,\n    output logic [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output logic lsu_o_cmt_ld,\n    output logic lsu_o_cmt_st,\n\n    // AGU-ICB Interface\n    input  logic agu_icb_cmd_valid,\n    output logic agu_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input  logic agu_icb_cmd_read,\n    input  logic [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    input  logic agu_icb_cmd_lock,\n    input  logic agu_icb_cmd_excl,\n    input  logic [1:0] agu_icb_cmd_size,\n    input  logic agu_icb_cmd_back2agu,\n    input  logic agu_icb_cmd_usign,\n    input  logic [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    // AGU-ICB Response Interface\n    output logic agu_icb_rsp_valid,\n    input  logic agu_icb_rsp_ready,\n    output logic agu_icb_rsp_err,\n    output logic agu_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    // NICE Interface (Optional Configuration)\n    input  logic nice_mem_holdup,\n    input  logic nice_icb_cmd_valid,\n    output logic nice_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input  logic nice_icb_cmd_read,\n    input  logic [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] nice_icb_cmd_wmask,\n    output logic nice_icb_rsp_valid,\n    input  logic nice_icb_rsp_ready,\n    output logic nice_icb_rsp_err,\n    output logic [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    // Memory Interfaces\n    // DCache Interface (Optional Configuration)\n    output logic dcache_icb_cmd_valid,\n    input  logic dcache_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output logic dcache_icb_cmd_read,\n    output logic [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] dcache_icb_cmd_wmask,\n    output logic dcache_icb_cmd_lock,\n    output logic dcache_icb_cmd_excl,\n    output logic [1:0] dcache_icb_cmd_size,\n    input  logic dcache_icb_rsp_valid,\n    output logic dcache_icb_rsp_ready,\n    input  logic dcache_icb_rsp_err,\n    input  logic dcache_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    // DTCM Interface (Optional Configuration)\n    output logic dtcm_icb_cmd_valid,\n    input  logic dtcm_icb_cmd_ready,\n    output logic [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output logic dtcm_icb_cmd_read,\n    output logic [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] dtcm_icb_cmd_wmask,\n    output logic dtcm_icb_cmd_lock,\n    output logic dtcm_icb_cmd_excl,\n    output logic [1:0] dtcm_icb_cmd_size,\n    input  logic dtcm_icb_rsp_valid,\n    output logic dtcm_icb_rsp_ready,\n    input  logic dtcm_icb_rsp_err,\n    input  logic dtcm_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n\n    // ITCM Interface (Optional Configuration)\n    output logic itcm_icb_cmd_valid,\n    input  logic itcm_icb_cmd_ready,\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] itcm_icb_cmd_addr,\n    output logic itcm_icb_cmd_read,\n    output logic [E203_XLEN-1:0] itcm_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] itcm_icb_cmd_wmask,\n    output logic itcm_icb_cmd_lock,\n    output logic itcm_icb_cmd_excl,\n    output logic [1:0] itcm_icb_cmd_size,\n    input  logic itcm_icb_rsp_valid,\n    output logic itcm_icb_rsp_ready,\n    input  logic itcm_icb_rsp_err,\n    input  logic itcm_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] itcm_icb_rsp_rdata,\n\n    // BIU Interface\n    output logic biu_icb_cmd_valid,\n    input  logic biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output logic biu_icb_cmd_read,\n    output logic [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] biu_icb_cmd_wmask,\n    output logic biu_icb_cmd_lock,\n    output logic biu_icb_cmd_excl,\n    output logic [1:0] biu_icb_cmd_size,\n    input  logic biu_icb_rsp_valid,\n    output logic biu_icb_rsp_ready,\n    input  logic biu_icb_rsp_err,\n    input  logic biu_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n\n// Rest of the module definition...\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 9, "code": "module e203_ifu_litebpu(\n    input                   clk,\n    input                   rst_n,\n    input  [E203_PC_SIZE-1:0] pc,\n    input                   dec_jal,\n    input                   dec_jalr,\n    input                   dec_bxx,\n    input  [E203_XLEN-1:0]  dec_bjp_imm,\n    input  [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    input                   oitf_empty,\n    input                   ir_empty,\n    input                   ir_rs1en,\n    input                   jalr_rs1idx_cam_irrdidx,\n    input                   dec_i_valid,\n    input                   ir_valid_clr,\n    input  [E203_XLEN-1:0]  rf2bpu_x1,\n    input  [E203_XLEN-1:0]  rf2bpu_rs1,\n    output                  prdt_taken,\n    output [E203_PC_SIZE-1:0] prdt_pc_add_op1,\n    output [E203_PC_SIZE-1:0] prdt_pc_add_op2,\n    output                  bpu_wait,\n    output                  bpu2rf_rs1_ena\n);\n\n// Static branch prediction strategy\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        prdt_taken <= 1'b0;\n        prdt_pc_add_op1 <= '0;\n        prdt_pc_add_op2 <= '0;\n        bpu_wait <= 1'b0;\n        bpu2rf_rs1_ena <= 1'b0;\n    end else begin\n        // JAL instruction\n        if (dec_jal) begin\n            prdt_taken <= 1'b1;\n            prdt_pc_add_op1 <= pc;\n            prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n            bpu_wait <= 1'b0;\n            bpu2rf_rs1_ena <= 1'b0;\n        // JALR instruction\n        end else if (dec_jalr) begin\n            prdt_taken <= 1'b1;\n            if (dec_jalr_rs1idx == 5'd0) begin // rs1 = x0\n                prdt_pc_add_op1 <= '0;\n                prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n            end else if (dec_jalr_rs1idx == 5'd1) begin // rs1 = x1\n                prdt_pc_add_op1 <= rf2bpu_x1[E203_PC_SIZE-1:0];\n                prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n                if (~oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n                    bpu_wait <= 1'b1;\n                end else begin\n                    bpu_wait <= 1'b0;\n                end\n                bpu2rf_rs1_ena <= 1'b1;\n            end else begin // rs1 = xn\n                prdt_pc_add_op1 <= rf2bpu_rs1[E203_PC_SIZE-1:0];\n                prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n                if (~oitf_empty || ~ir_empty || ~ir_rs1en) begin\n                    bpu_wait <= 1'b1;\n                end else begin\n                    bpu_wait <= 1'b0;\n                end\n                bpu2rf_rs1_ena <= 1'b1;\n            end\n        // Conditional branch instruction\n        end else if (dec_bxx) begin\n            if (dec_bjp_imm[E203_PC_SIZE-1] == 1'b1) begin // backward jump\n                prdt_taken <= 1'b1;\n            end else begin // forward jump\n                prdt_taken <= 1'b0;\n            end\n            prdt_pc_add_op1 <= pc;\n            prdt_pc_add_op2 <= dec_bjp_imm[E203_PC_SIZE-1:0];\n            bpu_wait <= 1'b0;\n            bpu2rf_rs1_ena <= 1'b0;\n        end else begin\n            prdt_taken <= 1'b0;\n            prdt_pc_add_op1 <= '0;\n            prdt_pc_add_op2 <= '0;\n            bpu_wait <= 1'b0;\n            bpu2rf_rs1_ena <= 1'b0;\n        end\n    end\nend\n\n// Data dependency processing mechanism\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Initialize signals\n    end else begin\n        // Dependency processing for JALR (rs1 = x1)\n        if (dec_jalr && dec_jalr_rs1idx == 5'd1) begin\n            if (~oitf_empty || jalr_rs1idx_cam_irrdidx) begin\n                bpu_wait <= 1'b1;\n            end else begin\n                bpu_wait <= 1'b0;\n            end\n        end\n        // Dependency processing for JALR (rs1 = xn)\n        if (dec_jalr && dec_jalr_rs1idx != 5'd0 && dec_jalr_rs1idx != 5'd1) begin\n            if (~oitf_empty || ~ir_empty || ~ir_rs1en) begin\n                bpu_wait <= 1'b1;\n            end else begin\n                bpu_wait <= 1'b0;\n            end\n        end\n    end\nend\n\n// Register read status management\nreg [E203_RFIDX_WIDTH-1:0] rs1xn_rdrf_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        rs1xn_rdrf_r <= '0;\n    end else begin\n        // Set state (read request)\n        if (dec_jalr && dec_jalr_rs1idx != 5'd0 && dec_jalr_rs1idx != 5'd1 && ~rs1xn_rdrf_r && dec_i_valid && ~jalr_rs1idx_cam_irrdidx) begin\n            rs1xn_rdrf_r <= dec_jalr_rs1idx;\n            bpu2rf_rs1_ena <= 1'b1;\n        end\n        // Clear state (read completed)\n        if (rs1xn_rdrf_r && ir_valid_clr) begin\n            rs1xn_rdrf_r <= '0;\n            bpu2rf_rs1_ena <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 2, "code": "// Define the module e203_ifu\nmodule e203_ifu (\n    // System Interface\n    input  logic                   clk,            // System clock\n    input  logic                   rst_n,          // Active low reset signal\n    output logic [E203_PC_SIZE-1:0] inspect_pc,    // Current PC value for inspection\n    output logic                   ifu_active,     // IFU activity indicator\n    input  logic                   itcm_nohold,    // ITCM hold control signal\n    input  logic [E203_PC_SIZE-1:0] pc_rtvec,      // Reset vector address\n\n    // IR stage to Execution Unit Interface\n    output logic [E203_INSTR_SIZE-1:0] ifu_o_ir,   // Instruction register data\n    output logic [E203_PC_SIZE-1:0]   ifu_o_pc,    // PC value of the current instruction\n    output logic                   ifu_o_pc_vld,  // Indication signal for valid PC value\n    output logic                   ifu_o_misalgn, // Instruction misalignment indication\n    output logic                   ifu_o_buserr,  // Bus error indication\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx, // Index of the first source operand register\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx, // Index of the second source operand register\n    output logic                   ifu_o_prdt_taken, // Indication for branch prediction taken\n    output logic                   ifu_o_muldiv_b2b, // Indication for consecutive multiplication and division instructions\n    output logic                   ifu_o_valid,    // Output data valid signal\n    input  logic                   ifu_o_ready,    // Signal indicating that the downstream module is ready to receive data\n\n    // Pipeline Control Interface\n    input  logic                   pipe_flush_req, // Pipeline flush request\n    output logic                   pipe_flush_ack, // Pipeline flush acknowledgment\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op1, // First operand for PC calculation during pipeline flush\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op2, // Second operand for PC calculation during pipeline flush\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_pc,    // Flush PC value used when enabling timing boost\n\n    // ITCM Interface (if E203_HAS_ITCM is defined)\n    input  logic                   ifu2itcm_holdup, // The IFU to ITCM holdup signal\n    input  logic [E203_ADDR_SIZE-1:0] itcm_region_indic, // The ITCM address region indication signal\n    output logic                   ifu2itcm_icb_cmd_valid, // ITCM command valid signal\n    input  logic                   ifu2itcm_icb_cmd_ready, // ITCM ready to receive command signal\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr, // ITCM access address\n    input  logic                   ifu2itcm_icb_rsp_valid, // ITCM response valid signal\n    output logic                   ifu2itcm_icb_rsp_ready, // IFU ready to receive response signal\n    input  logic                   ifu2itcm_icb_rsp_err,  // ITCM access error indication\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata, // ITCM read data\n\n    // System Memory Interface (if E203_HAS_MEM_ITF is defined)\n    output logic                   ifu2biu_icb_cmd_valid, // BIU command valid signal\n    input  logic                   ifu2biu_icb_cmd_ready, // BIU ready to receive command signal\n    output logic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr, // BIU access address\n    input  logic                   ifu2biu_icb_rsp_valid, // BIU response valid signal\n    output logic                   ifu2biu_icb_rsp_ready, // IFU ready to receive response signal\n    input  logic                   ifu2biu_icb_rsp_err,  // BIU access error indication\n    input  logic [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata, // BIU read data\n\n    // Halt Control Interface\n    input  logic                   ifu_halt_req, // Instruction fetch halt request\n    output logic                   ifu_halt_ack, // Instruction fetch halt acknowledgment\n\n    // Other Input Interfaces\n    input  logic                   oitf_empty, // Instruction buffer empty signal\n    input  logic [E203_XLEN-1:0]   rf2ifu_x1, // Value of register x1\n    input  logic [E203_XLEN-1:0]   rf2ifu_rs1, // Value of register rs1\n    input  logic                   dec2ifu_rden, // Enable signal for destination register\n    input  logic                   dec2ifu_rs1en, // Enable signal for register rs1\n    input  logic [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx, // Index of destination register\n    input  logic                   dec2ifu_mulhsu, // Identification of MULHSU instruction\n    input  logic                   dec2ifu_div, // Identification of DIV instruction\n    input  logic                   dec2ifu_rem, // Identification of REM instruction\n    input  logic                   dec2ifu_divu, // Identification of DIVU instruction\n    input  logic                   dec2ifu_remu // Identification of REMU instruction\n);\n\n// Instantiate sub-modules\ne203_ifu_ifetch ifu_ifetch_inst (\n    // System Interface\n    .clk(clk),\n    .rst_n(rst_n),\n    .pc_rtvec(pc_rtvec),\n    .ifu_o_ready(ifu_o_ready),\n    .pipe_flush_req(pipe_flush_req),\n    .pipe_flush_add_op1(pipe_flush_add_op1),\n    .pipe_flush_add_op2(pipe_flush_add_op2),\n    .pipe_flush_pc(pipe_flush_pc),\n    .ifu_halt_req(ifu_halt_req),\n    .oitf_empty(oitf_empty),\n    .rf2ifu_x1(rf2ifu_x1),\n    .rf2ifu_rs1(rf2ifu_rs1),\n    .dec2ifu_rden(dec2ifu_rden),\n    .dec2ifu_rs1en(dec2ifu_rs1en),\n    .dec2ifu_rdidx(dec2ifu_rdidx),\n    .dec2ifu_mulhsu(dec2ifu_mulhsu),\n    .dec2ifu_div(dec2ifu_div),\n    .dec2ifu_rem(dec2ifu_rem),\n    .dec2ifu_divu(dec2ifu_divu),\n    .dec2ifu_remu(dec2ifu_remu),\n\n    // Output Signals\n    .inspect_pc(inspect_pc),\n    .ifu_req_valid(ifu_req_valid),\n    .ifu_req_pc(ifu_req_pc),\n    .ifu_req_seq(ifu_req_seq),\n    .ifu_req_seq_rv32(ifu_req_seq_rv32),\n    .ifu_req_last_pc(ifu_req_last_pc),\n    .pipe_flush_ack(pipe_flush_ack),\n    .ifu_halt_ack(ifu_halt_ack),\n    .ifu_o_ir(ifu_o_ir),\n    .ifu_o_pc(ifu_o_pc),\n    .ifu_o_pc_vld(ifu_o_pc_vld),\n    .ifu_o_misalgn(ifu_o_misalgn),\n    .ifu_o_buserr(ifu_o_buserr),\n    .ifu_o_rs1idx(ifu_o_rs1idx),\n    .ifu_o_rs2idx(ifu_o_rs2idx),\n    .ifu_o_prdt_taken(ifu_o_prdt_taken),\n    .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n    .ifu_o_valid(ifu_o_valid)\n);\n\ne203_ifu_ift2icb ift2icb_inst (\n    // Input Signals\n    .clk(clk),\n    .rst_n(rst_n),\n    .ifu_req_valid(ifu_req_valid),\n    .ifu_req_pc(ifu_req_pc),\n    .ifu_req_seq(ifu_req_seq),\n    .ifu_req_seq_rv32(ifu_req_seq_rv32),\n    .ifu_req_last_pc(ifu_req_last_pc),\n    .ifu_rsp_ready(ifu_rsp_ready),\n    .itcm_nohold(itcm_nohold),\n    .itcm_region_indic(itcm_region_indic),\n    .ifu2itcm_icb_cmd_ready(ifu2itcm_icb_cmd_ready),\n    .ifu2itcm_icb_rsp_valid(ifu2itcm_icb_rsp_valid),\n    .ifu2itcm_icb_rsp_err(ifu2itcm_icb_rsp_err),\n    .ifu2itcm_icb_rsp_rdata(ifu2itcm_icb_rsp_rdata),\n    .ifu2biu_icb_cmd_ready(ifu2biu_icb_cmd_ready),\n    .ifu2biu_icb_rsp_valid(ifu2biu_icb_rsp_valid),\n    .ifu2biu_icb_rsp_err(ifu2biu_icb_rsp_err),\n    .ifu2biu_icb_rsp_rdata(ifu2biu_icb_rsp_rdata),\n\n    // Output Signals\n    .ifu_req_ready(ifu_req_ready),\n    .ifu_rsp_valid(ifu_rsp_valid),\n    .ifu_rsp_err(ifu_rsp_err),\n    .ifu_rsp_instr(ifu_rsp_instr),\n    .ifu2itcm_icb_cmd_valid(ifu2itcm_icb_cmd_valid),\n    .ifu2itcm_icb_cmd_addr(ifu2itcm_icb_cmd_addr),\n    .ifu2itcm_icb_rsp_ready(ifu2itcm_icb_rsp_ready),\n    .ifu2biu_icb_cmd_valid(ifu2biu_icb_cmd_valid),\n    .ifu2biu_icb_cmd_addr(ifu2biu_icb_cmd_addr),\n    .ifu2biu_icb_rsp_ready(ifu2biu_icb_rsp_ready)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 2, "code": "module e203_exu_csr(\n    input   logic                   nonflush_cmt_ena,\n    input   logic                   csr_ena,\n    input   logic                   csr_wr_en,\n    input   logic                   csr_rd_en,\n    input   logic   [11:0]          csr_idx,\n    output  logic                   csr_access_ilgl,\n    output  logic                   tm_stop,\n    output  logic                   core_cgstop,\n    output  logic                   tcm_cgstop,\n    output  logic                   itcm_nohold,\n    output  logic                   mdv_nob2b,\n    output  logic   [E203_XLEN-1:0] read_csr_dat,\n    input   logic   [E203_XLEN-1:0] wbck_csr_dat,\n    input   logic   [E203_HART_ID_W-1:0] core_mhartid,\n    input   logic                   ext_irq_r,\n    input   logic                   sft_irq_r,\n    input   logic                   tmr_irq_r,\n    output  logic                   status_mie_r,\n    output  logic                   mtie_r,\n    output  logic                   msie_r,\n    output  logic                   meie_r,\n    output  logic                   wr_dcsr_ena,\n    output  logic                   wr_dpc_ena,\n    output  logic                   wr_dscratch_ena,\n    input   logic   [E203_XLEN-1:0] dcsr_r,\n    input   logic   [E203_PC_SIZE-1:0] dpc_r,\n    input   logic   [E203_XLEN-1:0] dscratch_r,\n    output  logic                   u_mode,\n    output  logic                   s_mode,\n    output  logic                   h_mode,\n    output  logic                   m_mode,\n    input   logic   [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input   logic                   cmt_badaddr_ena,\n    input   logic   [E203_PC_SIZE-1:0] cmt_epc,\n    input   logic                   cmt_epc_ena,\n    input   logic   [E203_XLEN-1:0] cmt_cause,\n    input   logic                   cmt_cause_ena,\n    input   logic                   cmt_status_ena,\n    input   logic                   cmt_instret_ena,\n    input   logic                   cmt_mret_ena,\n    output  logic   [E203_PC_SIZE-1:0] csr_epc_r,\n    output  logic   [E203_PC_SIZE-1:0] csr_dpc_r,\n    output  logic   [E203_XLEN-1:0] csr_mtvec_r,\n    input   logic                   clk_aon,\n    input   logic                   clk,\n    input   logic                   rst_n\n);\n\n// internal signal declaration\nlogic [E203_XLEN-1:0] mstatus_r;\nlogic [E203_XLEN-1:0] mie_r;\nlogic [E203_XLEN-1:0] mip_r;\nlogic [E203_XLEN-1:0] mtvec_r;\nlogic [E203_XLEN-1:0] mscratch_r;\nlogic [E203_PC_SIZE-1:0] mepc_r;\nlogic [E203_XLEN-1:0] mcause_r;\nlogic [E203_XLEN-1:0] mtval_r;\nlogic [E203_XLEN-1:0] mcycle_r;\nlogic [E203_XLEN-1:0] minstret_r;\nlogic [E203_XLEN-1:0] mcounterstop_r;\nlogic [E203_XLEN-1:0] mcgstop_r;\nlogic [E203_XLEN-1:0] itcmnohold_r;\nlogic [E203_XLEN-1:0] mdv_nob2b_r;\n\n// CSR registers initialization\ninitial begin\n    mstatus_r = '0;\n    mie_r = '0;\n    mip_r = '0;\n    mtvec_r = E203_MTVEC_TRAP_BASE;\n    mscratch_r = '0;\n    mepc_r = '0;\n    mcause_r = '0;\n    mtval_r = '0;\n    mcycle_r = '0;\n    minstret_r = '0;\n    mcounterstop_r = '0;\n    mcgstop_r = '0;\n    itcmnohold_r = '0;\n    mdv_nob2b_r = '0;\nend\n\n// CSR registers update\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // reset\n        mstatus_r <= '0;\n        mie_r <= '0;\n        mip_r <= '0;\n        mtvec_r <= E203_MTVEC_TRAP_BASE;\n        mscratch_r <= '0;\n        mepc_r <= '0;\n        mcause_r <= '0;\n        mtval_r <= '0;\n        mcycle_r <= '0;\n        minstret_r <= '0;\n        mcounterstop_r <= '0;\n        mcgstop_r <= '0;\n        itcmnohold_r <= '0;\n        mdv_nob2b_r <= '0;\n    end else begin\n        // update\n        if (cmt_status_ena) begin\n            mstatus_r[3] <= mie_r;\n        end\n        if (cmt_mret_ena) begin\n            mstatus_r[3] <= mstatus_r[7];\n        end\n        if (csr_ena && csr_wr_en) begin\n            case (csr_idx)\n                12'h300: mstatus_r <= wbck_csr_dat;\n                12'h304: mie_r <= wbck_csr_dat;\n                12'h305: mtvec_r <= wbck_csr_dat;\n                12'h340: mscratch_r <= wbck_csr_dat;\n                12'h341: mepc_r <= {wbck_csr_dat[E203_XLEN-1:E203_PC_SIZE], {E203_PC_SIZE{1'b0}}};\n                12'h342: mcause_r <= {wbck_csr_dat[E203_XLEN-1:31], 31'b0};\n                default: ;\n            endcase\n        end\n        if (cmt_cause_ena) begin\n            mcause_r <= {cmt_cause[E203_XLEN-1:31], 31'b0};\n        end\n        if (cmt_epc_ena) begin\n            mepc_r <= {cmt_epc[E203_PC_SIZE-1:0], {E203_PC_SIZE{1'b0}}};\n        end\n        if (cmt_badaddr_ena) begin\n            mtval_r <= {cmt_badaddr[E203_XLEN-1:0], {E203_ADDR_SIZE{1'b0}}};\n        end\n    end\nend\n\n// output assignments\nassign csr_access_ilgl = 1'b0;\nassign tm_stop = mcounterstop_r[E203_XLEN-1];\nassign core_cgstop = mcgstop_r[E203_XLEN-1];\nassign tcm_cgstop = mcounterstop_r[E203_XLEN-2];\nassign itcm_nohold = itcmnohold_r[E203_XLEN-1];\nassign mdv_nob2b = mdv_nob2b_r[E203_XLEN-1];\nassign read_csr_dat = (csr_idx == 12'h300) ? mstatus_r :\n                      (csr_idx == 12'h304) ? mie_r :\n                      (csr_idx == 12'h305) ? mtvec_r :\n                      (csr_idx == 12'h340) ? mscratch_r :\n                      (csr_idx == 12'h341) ? {mepc_r, {E203_PC_SIZE{1'b0}}} :\n                      (csr_idx == 12'h342) ? {mcause_r, 31'b0} :\n                      (csr_idx == 12'h343) ? {mtval_r, {E203_ADDR_SIZE{1'b0}}} :\n                      (csr_idx == 12'h300) ? mstatus_r :\n                      32'b0;\nassign status_mie_r = mstatus_r[3];\nassign mtie_r = mie_r[7];\nassign msie_r = mie_r[3];\nassign meie_r = mie_r[11];\nassign wr_dcsr_ena = (csr_idx == 12'h7b0) && csr_ena && csr_wr_en;\nassign wr_dpc_ena = (csr_idx == 12'h7b1) && csr_ena && csr_wr_en;\nassign wr_dscratch_ena = (csr_idx == 12'h7b2) && csr_ena && csr_wr_en;\nassign u_mode = 1'b0;\nassign s_mode = 1'b0;\nassign h_mode = 1'b0;\nassign m_mode = 1'b1;\nassign csr_epc_r = mepc_r;\nassign csr_dpc_r = dpc_r;\nassign csr_mtvec_r = mtvec_r;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 3, "code": "module e203_lsu_ctrl(\n    input commit_mret,\n    input commit_trap,\n    output lsu_ctrl_active,\n    // LSU Write-back Interface\n    output lsu_o_valid,\n    input lsu_o_ready,\n    output [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output lsu_o_wbck_err,\n    output lsu_o_cmt_buserr,\n    output [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output lsu_o_cmt_ld,\n    output lsu_o_cmt_st,\n    // AGU-ICB Interface\n    input agu_icb_cmd_valid,\n    output agu_icb_cmd_ready,\n    input [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input agu_icb_cmd_read,\n    input [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    input agu_icb_cmd_lock,\n    input agu_icb_cmd_excl,\n    input [1:0] agu_icb_cmd_size,\n    input agu_icb_cmd_back2agu,\n    input agu_icb_cmd_usign,\n    input [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output agu_icb_rsp_valid,\n    input agu_icb_rsp_ready,\n    output agu_icb_rsp_err,\n    output agu_icb_rsp_excl_ok,\n    output [E203_XLEN-1:0] agu_icb_rsp_rdata,\n    // NICE Interface (Optional Configuration)\n    input nice_mem_holdup,\n    input nice_icb_cmd_valid,\n    output nice_icb_cmd_ready,\n    input [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input nice_icb_cmd_read,\n    input [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input [E203_XLEN/8-1:0] nice_icb_cmd_wmask,\n    output nice_icb_rsp_valid,\n    input nice_icb_rsp_ready,\n    output nice_icb_rsp_err,\n    output [E203_XLEN-1:0] nice_icb_rsp_rdata,\n    // Memory Interfaces\n    output dcache_icb_cmd_valid,\n    input dcache_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output dcache_icb_cmd_read,\n    output [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] dcache_icb_cmd_wmask,\n    output dcache_icb_cmd_lock,\n    output dcache_icb_cmd_excl,\n    output [1:0] dcache_icb_cmd_size,\n    input dcache_icb_rsp_valid,\n    output dcache_icb_rsp_ready,\n    input dcache_icb_rsp_err,\n    input dcache_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n    output dtcm_icb_cmd_valid,\n    input dtcm_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] dtcm_icb_cmd_addr,\n    output dtcm_icb_cmd_read,\n    output [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] dtcm_icb_cmd_wmask,\n    output dtcm_icb_cmd_lock,\n    output dtcm_icb_cmd_excl,\n    output [1:0] dtcm_icb_cmd_size,\n    input dtcm_icb_rsp_valid,\n    output dtcm_icb_rsp_ready,\n    input dtcm_icb_rsp_err,\n    input dtcm_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    output itcm_icb_cmd_valid,\n    input itcm_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] itcm_icb_cmd_addr,\n    output itcm_icb_cmd_read,\n    output [E203_XLEN-1:0] itcm_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] itcm_icb_cmd_wmask,\n    output itcm_icb_cmd_lock,\n    output itcm_icb_cmd_excl,\n    output [1:0] itcm_icb_cmd_size,\n    input itcm_icb_rsp_valid,\n    output itcm_icb_rsp_ready,\n    input itcm_icb_rsp_err,\n    input itcm_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] itcm_icb_rsp_rdata,\n    output biu_icb_cmd_valid,\n    input biu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output biu_icb_cmd_read,\n    output [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] biu_icb_cmd_wmask,\n    output biu_icb_cmd_lock,\n    output biu_icb_cmd_excl,\n    output [1:0] biu_icb_cmd_size,\n    input biu_icb_rsp_valid,\n    output biu_icb_rsp_ready,\n    input biu_icb_rsp_err,\n    input biu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n\n// Main control logic implementation\nalways @(posedge clk) begin\n    // LSU Write-back Interface\n    lsu_o_valid <= 1'b0;\n    lsu_o_wbck_wdat <= {E203_XLEN{1'b0}};\n    lsu_o_wbck_itag <= {E203_ITAG_WIDTH{1'b0}};\n    lsu_o_wbck_err <= 1'b0;\n    lsu_o_cmt_buserr <= 1'b0;\n    lsu_o_cmt_badaddr <= {E203_ADDR_SIZE{1'b0}};\n    lsu_o_cmt_ld <= 1'b0;\n    lsu_o_cmt_st <= 1'b0;\n\n    // AGU-ICB Interface\n    agu_icb_cmd_ready <= 1'b0;\n    agu_icb_rsp_valid <= 1'b0;\n    agu_icb_rsp_err <= 1'b0;\n    agu_icb_rsp_excl_ok <= 1'b0;\n    agu_icb_rsp_rdata <= {E203_XLEN{1'b0}};\n\n    // NICE Interface (Optional Configuration)\n    nice_icb_cmd_ready <= 1'b0;\n    nice_icb_rsp_valid <= 1'b0;\n    nice_icb_rsp_err <= 1'b0;\n    nice_icb_rsp_rdata <= {E203_XLEN{1'b0}};\n\n    // Memory Interfaces\n    dcache_icb_cmd_valid <= 1'b0;\n    dcache_icb_cmd_addr <= {E203_ADDR_SIZE{1'b0}};\n    dcache_icb_cmd_read <= 1'b0;\n    dcache_icb_cmd_wdata <= {E203_XLEN{1'b0}};\n    dcache_icb_cmd_wmask <= {E203_XLEN/8{1'b0}};\n    dcache_icb_cmd_lock <= 1'b0;\n    dcache_icb_cmd_excl <= 1'b0;\n    dcache_icb_cmd_size <= 2'b00;\n    dcache_icb_rsp_ready <= 1'b0;\n\n    dtcm_icb_cmd_valid <= 1'b0;\n    dtcm_icb_cmd_addr <= {E203_ADDR_SIZE{1'b0}};\n    dtcm_icb_cmd_read <= 1'b0;\n    dtcm_icb_cmd_wdata <= {E203_XLEN{1'b0}};\n    dtcm_icb_cmd_wmask <= {E203_XLEN/8{1'b0}};\n    dtcm_icb_cmd_lock <= 1'b0;\n    dtcm_icb_cmd_excl <= 1'b0;\n    dtcm_icb_cmd_size <= 2'b00;\n    dtcm_icb_rsp_ready <= 1'b0;\n\n    itcm_icb_cmd_valid <= 1'b0;\n    itcm_icb_cmd_addr <= {E203_ADDR_SIZE{1'b0}};\n    itcm_icb_cmd_read <= 1'b0;\n    itcm_icb_cmd_wdata <= {E203_XLEN{1'b0}};\n    itcm_icb_cmd_wmask <= {E203_XLEN/8{1'b0}};\n    itcm_icb_cmd_lock <= 1'b0;\n    itcm_icb_cmd_excl <= 1'b0;\n    itcm_icb_cmd_size <= 2'b00;\n    itcm_icb_rsp_ready <= 1'b0;\n\n    biu_icb_cmd_valid <= 1'b0;\n    biu_icb_cmd_addr <= {E203_ADDR_SIZE{1'b0}};\n    biu_icb_cmd_read <= 1'b0;\n    biu_icb_cmd_wdata <= {E203_XLEN{1'b0}};\n    biu_icb_cmd_wmask <= {E203_XLEN/8{1'b0}};\n    biu_icb_cmd_lock <= 1'b0;\n    biu_icb_cmd_excl <= 1'b0;\n    biu_icb_cmd_size <= 2'b00;\n    biu_icb_rsp_ready <= 1'b0;\n\n    // LSU control active status\n    lsu_ctrl_active <= 1'b0;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 3, "code": "module e203_exu_csr(\n    input  logic                   nonflush_cmt_ena,\n    input  logic                   csr_ena,\n    input  logic                   csr_wr_en,\n    input  logic                   csr_rd_en,\n    input  logic [11:0]            csr_idx,\n    output logic                   csr_access_ilgl,\n    output logic                   tm_stop,\n    output logic                   core_cgstop,\n    output logic                   tcm_cgstop,\n    output logic                   itcm_nohold,\n    output logic                   mdv_nob2b,\n    output logic [E203_XLEN-1:0]   read_csr_dat,\n    input  logic [E203_XLEN-1:0]   wbck_csr_dat,\n    input  logic [E203_HART_ID_W-1:0] core_mhartid,\n    input  logic                   ext_irq_r,\n    input  logic                   sft_irq_r,\n    input  logic                   tmr_irq_r,\n    output logic                   status_mie_r,\n    output logic                   mtie_r,\n    output logic                   msie_r,\n    output logic                   meie_r,\n    output logic                   wr_dcsr_ena,\n    output logic                   wr_dpc_ena,\n    output logic                   wr_dscratch_ena,\n    input  logic [E203_XLEN-1:0]   dcsr_r,\n    input  logic [E203_PC_SIZE-1:0] dpc_r,\n    input  logic [E203_XLEN-1:0]   dscratch_r,\n    output logic                   u_mode,\n    output logic                   s_mode,\n    output logic                   h_mode,\n    output logic                   m_mode,\n    input  logic [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input  logic                   cmt_badaddr_ena,\n    input  logic [E203_PC_SIZE-1:0] cmt_epc,\n    input  logic                   cmt_epc_ena,\n    input  logic [E203_XLEN-1:0]   cmt_cause,\n    input  logic                   cmt_cause_ena,\n    input  logic                   cmt_status_ena,\n    input  logic                   cmt_instret_ena,\n    input  logic                   cmt_mret_ena,\n    output logic [E203_PC_SIZE-1:0] csr_epc_r,\n    output logic [E203_PC_SIZE-1:0] csr_dpc_r,\n    output logic [E203_XLEN-1:0]   csr_mtvec_r,\n    input  logic                   clk_aon,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n\n// CSR registers\nlogic [E203_XLEN-1:0] mstatus;\nlogic [E203_XLEN-1:0] mie;\nlogic [E203_XLEN-1:0] mip;\nlogic [E203_XLEN-1:0] mtvec;\nlogic [E203_XLEN-1:0] mscratch;\nlogic [E203_PC_SIZE-1:0] mepc;\nlogic [E203_XLEN-1:0] mcause;\nlogic [E203_XLEN-1:0] mtval;\nlogic [E203_XLEN-1:0] mcycle;\nlogic [E203_XLEN-1:0] minstret;\nlogic [E203_XLEN-1:0] mvendorid;\nlogic [E203_XLEN-1:0] marchid;\nlogic [E203_XLEN-1:0] mimpid;\nlogic [E203_XLEN-1:0] mhartid;\nlogic [E203_XLEN-1:0] mtime;\nlogic [E203_XLEN-1:0] mtimecmp;\nlogic [E203_XLEN-1:0] msip;\n\n// Custom registers\nlogic [E203_XLEN-1:0] counterstop;\nlogic                   mcgstop;\nlogic                   itcmnohold;\nlogic                   mdvnob2b;\n\n// Debug registers\nlogic [E203_XLEN-1:0] dcsr;\nlogic [E203_PC_SIZE-1:0] dpc;\nlogic [E203_XLEN-1:0] dscratch;\n\n// Mode signals\nassign u_mode = 1'b0;\nassign s_mode = 1'b0;\nassign h_mode = 1'b0;\nassign m_mode = 1'b1;\n\n// Update CSR registers\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Initialize CSR registers\n        mstatus <= '0;\n        mie <= '0;\n        mip <= '0;\n        mtvec <= '0;\n        mscratch <= '0;\n        mepc <= '0;\n        mcause <= '0;\n        mtval <= '0;\n        mcycle <= '0;\n        minstret <= '0;\n        mvendorid <= 32'd536;\n        marchid <= 32'd0;\n        mimpid <= 32'd1;\n        mhartid <= core_mhartid;\n        mtime <= '0;\n        mtimecmp <= '0;\n        msip <= '0;\n        \n        counterstop <= '0;\n        mcgstop <= 1'b0;\n        itcmnohold <= 1'b0;\n        mdvnob2b <= 1'b0;\n        \n        dcsr <= '0;\n        dpc <= '0;\n        dscratch <= '0;\n    end else begin\n        // Update CSR registers\n        if (csr_ena && csr_wr_en) begin\n            case (csr_idx)\n                12'h300: mstatus <= wbck_csr_dat;\n                12'h304: mie <= wbck_csr_dat;\n                12'h305: mtvec <= wbck_csr_dat;\n                12'h340: mscratch <= wbck_csr_dat;\n                12'h341: mepc <= {wbck_csr_dat[E203_PC_SIZE-1:1], 1'b0};\n                12'h342: mcause <= {wbck_csr_dat[E203_XLEN-1:32], 32'd0};\n                12'h7b0: dcsr <= wbck_csr_dat;\n                12'h7b1: dpc <= wbck_csr_dat[E203_PC_SIZE-1:0];\n                12'h7b2: dscratch <= wbck_csr_dat;\n                default: ;\n            endcase\n        end\n        \n        if (cmt_status_ena) begin\n            mstatus[3] <= mie;\n        end\n        \n        if (cmt_mret_ena) begin\n            mstatus[3] <= mstatus[7];\n        end\n        \n        if (cmt_epc_ena) begin\n            mepc <= {cmt_epc[E203_PC_SIZE-1:1], 1'b0};\n        end\n        \n        if (cmt_cause_ena) begin\n            mcause <= {cmt_cause[E203_XLEN-1:32], 32'd0};\n        end\n    end\nend\n\n// CSR read logic\nalways @(*) begin\n    case (csr_idx)\n        12'h300: read_csr_dat = mstatus;\n        12'h304: read_csr_dat = mie;\n        12'h305: read_csr_dat = mtvec;\n        12'h340: read_csr_dat = mscratch;\n        12'h341: read_csr_dat = {mepc, {E203_XLEN-E203_PC_SIZE{1'b0}}};\n        12'h342: read_csr_dat = mcause;\n        12'h7b0: read_csr_dat = dcsr;\n        12'h7b1: read_csr_dat = {dpc, {E203_XLEN-E203_PC_SIZE{1'b0}}};\n        12'h7b2: read_csr_dat = dscratch;\n        default: read_csr_dat = '0;\n    endcase\nend\n\n// Other output logic\nassign csr_access_ilgl = 1'b0;\nassign tm_stop = counterstop[E203_XLEN-1];\nassign core_cgstop = mcgstop;\nassign tcm_cgstop = itcmnohold;\nassign itcm_nohold = itcmnohold;\nassign mdv_nob2b = mdvnob2b;\nassign status_mie_r = mstatus[3];\nassign mtie_r = mie[7];\nassign msie_r = mie[3];\nassign meie_r = mie[11];\nassign wr_dcsr_ena = csr_ena && csr_wr_en && (csr_idx == 12'h7b0);\nassign wr_dpc_ena = csr_ena && csr_wr_en && (csr_idx == 12'h7b1);\nassign wr_dscratch_ena = csr_ena && csr_wr_en && (csr_idx == 12'h7b2);\nassign csr_epc_r = mepc;\nassign csr_dpc_r = dpc;\nassign csr_mtvec_r = mtvec;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 3, "code": "```\nmodule e203_ifu (\n    input  logic                   clk,\n    input  logic                   rst_n,\n\n    // System Interface\n    output logic [E203_PC_SIZE-1:0] inspect_pc,\n    output logic                   ifu_active,\n    input  logic                   itcm_nohold,\n    input  logic [E203_PC_SIZE-1:0] pc_rtvec,\n\n    // IR stage to Execution Unit Interface\n    output logic [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output logic [E203_PC_SIZE-1:0] ifu_o_pc,\n    output logic                   ifu_o_pc_vld,\n    output logic                   ifu_o_misalgn,\n    output logic                   ifu_o_buserr,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output logic                   ifu_o_prdt_taken,\n    output logic                   ifu_o_muldiv_b2b,\n    output logic                   ifu_o_valid,\n    input  logic                   ifu_o_ready,\n\n    // Pipeline Control Interface\n    input  logic                   pipe_flush_req,\n    output logic                   pipe_flush_ack,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_pc,\n\n    // ITCM Interface\n    input  logic                   ifu2itcm_holdup,\n    input  logic [E203_ADDR_SIZE-1:0] itcm_region_indic,\n    output logic                   ifu2itcm_icb_cmd_valid,\n    input  logic                   ifu2itcm_icb_cmd_ready,\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input  logic                   ifu2itcm_icb_rsp_valid,\n    output logic                   ifu2itcm_icb_rsp_ready,\n    input  logic                   ifu2itcm_icb_rsp_err,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // System Memory Interface\n    output logic                   ifu2biu_icb_cmd_valid,\n    input  logic                   ifu2biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input  logic                   ifu2biu_icb_rsp_valid,\n    output logic                   ifu2biu_icb_rsp_ready,\n    input  logic                   ifu2biu_icb_rsp_err,\n    input  logic [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata,\n\n    // Halt Control Interface\n    input  logic                   ifu_halt_req,\n    output logic                   ifu_halt_ack,\n\n    // Other Input Interfaces\n    input  logic                   oitf_empty,\n    input  logic [E203_XLEN-1:0]    rf2ifu_x1,\n    input  logic [E203_XLEN-1:0]    rf2ifu_rs1,\n    input  logic                   dec2ifu_rs1en,\n    input  logic                   dec2ifu_rden,\n    input  logic [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input  logic                   dec2ifu_mulhsu,\n    input  logic                   dec2ifu_div,\n    input  logic                   dec2ifu_rem,\n    input  logic                   dec2ifu_divu,\n    input  logic                   dec2ifu_remu\n);\n\n// Instantiate e203_ifu_ifetch and e203_ifu_ift2icb modules\ne203_ifu_ifetch ifu_ifetch_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n\n    // System Interface\n    .inspect_pc(inspect_pc),\n    .ifu_active(ifu_active),\n    .itcm_nohold(itcm_nohold),\n    .pc_rtvec(pc_rtvec),\n\n    // IR stage to Execution Unit Interface\n    .ifu_o_ir(ifu_o_ir),\n    .ifu_o_pc(ifu_o_pc),\n    .ifu_o_pc_vld(ifu_o_pc_vld),\n    .ifu_o_misalgn(ifu_o_misalgn),\n    .ifu_o_buserr(ifu_o_buserr),\n    .ifu_o_rs1idx(ifu_o_rs1idx),\n    .ifu_o_rs2idx(ifu_o_rs2idx),\n    .ifu_o_prdt_taken(ifu_o_prdt_taken),\n    .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n    .ifu_o_valid(ifu_o_valid),\n    .ifu_o_ready(ifu_o_ready),\n\n    // Pipeline Control Interface\n    .pipe_flush_req(pipe_flush_req),\n    .pipe_flush_ack(pipe_flush_ack),\n    .pipe_flush_add_op1(pipe_flush_add_op1),\n    .pipe_flush_add_op2(pipe_flush_add_op2),\n    .pipe_flush_pc(pipe_flush_pc),\n\n    // Other Input Interfaces\n    .oitf_empty(oitf_empty),\n    .rf2ifu_x1(rf2ifu_x1),\n    .rf2ifu_rs1(rf2ifu_rs1),\n    .dec2ifu_rs1en(dec2ifu_rs1en),\n    .dec2ifu_rden(dec2ifu_rden),\n    .dec2ifu_rdidx(dec2ifu_rdidx),\n    .dec2ifu_mulhsu(dec2ifu_mulhsu),\n    .dec2ifu_div(dec2ifu_div),\n    .dec2ifu_rem(dec2ifu_rem),\n    .dec2ifu_divu(dec2ifu_divu),\n    .dec2ifu_remu(dec2ifu_remu)\n);\n\ne203_ifu_ift2icb ift2icb_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n\n    // ITCM Interface\n    .ifu2itcm_holdup(ifu2itcm_holdup),\n    .itcm_region_indic(itcm_region_indic),\n    .ifu2itcm_icb_cmd_valid(ifu2itcm_icb_cmd_valid),\n    .ifu2itcm_icb_cmd_ready(ifu2itcm_icb_cmd_ready),\n    .ifu2itcm_icb_cmd_addr(ifu2itcm_icb_cmd_addr),\n    .ifu2itcm_icb_rsp_valid(ifu2itcm_icb_rsp_valid),\n    .ifu2itcm_icb_rsp_ready(ifu2itcm_icb_rsp_ready),\n    .ifu2itcm_icb_rsp_err(ifu2itcm_icb_rsp_err),\n    .ifu2itcm_icb_rsp_rdata(ifu2itcm_icb_rsp_rdata),\n\n    // System Memory Interface\n    .ifu2biu_icb_cmd_valid(ifu2biu_icb_cmd_valid),\n    .ifu2biu_icb_cmd_ready(ifu2biu_icb_cmd_ready),\n    .ifu2biu_icb_cmd_addr(ifu2biu_icb_cmd_addr),\n    .ifu2biu_icb_rsp_valid(ifu2biu_icb_rsp_valid),\n    .ifu2biu_icb_rsp_ready(ifu2biu_icb_rsp_ready),\n    .ifu2biu_icb_rsp_err(ifu2biu_icb_rsp_err),\n    .ifu2biu_icb_rsp_rdata(ifu2biu_icb_rsp_rdata)\n);\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 4, "code": "module e203_ifu(\n    input  logic                   clk,\n    input  logic                   rst_n,\n    output logic [E203_PC_SIZE-1:0] inspect_pc,\n    output logic                   ifu_active,\n    input  logic                   itcm_nohold,\n    input  logic [E203_PC_SIZE-1:0] pc_rtvec,\n\n    // IR stage to Execution Unit Interface\n    output logic [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output logic [E203_PC_SIZE-1:0] ifu_o_pc,\n    output logic                   ifu_o_pc_vld,\n    output logic                   ifu_o_misalgn,\n    output logic                   ifu_o_buserr,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output logic                   ifu_o_prdt_taken,\n    output logic                   ifu_o_muldiv_b2b,\n    output logic                   ifu_o_valid,\n    input  logic                   ifu_o_ready,\n\n    // Pipeline Control Interface\n    input  logic                   pipe_flush_req,\n    output logic                   pipe_flush_ack,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_pc,\n\n    // ITCM Interface\n    input  logic                   ifu2itcm_holdup,\n    input  logic [E203_ADDR_SIZE-1:0] itcm_region_indic,\n    output logic                   ifu2itcm_icb_cmd_valid,\n    input  logic                   ifu2itcm_icb_cmd_ready,\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input  logic                   ifu2itcm_icb_rsp_valid,\n    output logic                   ifu2itcm_icb_rsp_ready,\n    input  logic                   ifu2itcm_icb_rsp_err,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // System Memory Interface\n    output logic                   ifu2biu_icb_cmd_valid,\n    input  logic                   ifu2biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input  logic                   ifu2biu_icb_rsp_valid,\n    output logic                   ifu2biu_icb_rsp_ready,\n    input  logic                   ifu2biu_icb_rsp_err,\n    input  logic [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata,\n\n    // Halt Control Interface\n    input  logic                   ifu_halt_req,\n    output logic                   ifu_halt_ack,\n\n    // Other Input Interfaces\n    input  logic                   oitf_empty,\n    input  logic [E203_XLEN-1:0]    rf2ifu_x1,\n    input  logic [E203_XLEN-1:0]    rf2ifu_rs1,\n    input  logic                   dec2ifu_rs1en,\n    input  logic                   dec2ifu_rden,\n    input  logic [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input  logic                   dec2ifu_mulhsu,\n    input  logic                   dec2ifu_div,\n    input  logic                   dec2ifu_rem,\n    input  logic                   dec2ifu_divu,\n    input  logic                   dec2ifu_remu\n);\n\ne203_ifu_ifetch ifu_ifetch_inst(\n    .clk(clk),\n    .rst_n(rst_n),\n    .pc_rtvec(pc_rtvec),\n    .ifu_o_ready(ifu_o_ready),\n    .pipe_flush_req(pipe_flush_req),\n    .pipe_flush_add_op1(pipe_flush_add_op1),\n    .pipe_flush_add_op2(pipe_flush_add_op2),\n    .pipe_flush_pc(pipe_flush_pc),\n    .ifu_halt_req(ifu_halt_req),\n    .oitf_empty(oitf_empty),\n    .rf2ifu_x1(rf2ifu_x1),\n    .rf2ifu_rs1(rf2ifu_rs1),\n    .dec2ifu_rden(dec2ifu_rden),\n    .dec2ifu_rs1en(dec2ifu_rs1en),\n    .dec2ifu_rdidx(dec2ifu_rdidx),\n    .dec2ifu_mulhsu(dec2ifu_mulhsu),\n    .dec2ifu_div(dec2ifu_div),\n    .dec2ifu_rem(dec2ifu_rem),\n    .dec2ifu_divu(dec2ifu_divu),\n    .dec2ifu_remu(dec2ifu_remu),\n    .inspect_pc(inspect_pc),\n    .ifu_req_valid(ifu2itcm_icb_cmd_valid),\n    .ifu_req_pc(ifu2itcm_icb_cmd_addr),\n    .ifu_req_seq(),\n    .ifu_req_seq_rv32(),\n    .ifu_req_last_pc(),\n    .pipe_flush_ack(pipe_flush_ack),\n    .ifu_halt_ack(ifu_halt_ack),\n    .ifu_o_ir(ifu_o_ir),\n    .ifu_o_pc(ifu_o_pc),\n    .ifu_o_pc_vld(ifu_o_pc_vld),\n    .ifu_o_misalgn(ifu_o_misalgn),\n    .ifu_o_buserr(ifu_o_buserr),\n    .ifu_o_rs10:idx(ifu_o_rs1idx),\n    .ifu_o_rs2idx(ifu_o_rs2idx),\n    .ifu_o_prdt_taken(ifu_o_prdt_taken),\n    .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n    .ifu_o_valid(ifu_o_valid)\n);\n\ne203_ifu_ift2icb ift2icb_inst(\n    .clk(clk),\n    .rst_n(rst_n),\n    .ifu_req_valid(ifu2itcm_icb_cmd_valid),\n    .ifu_req_pc(ifu2itcm_icb_cmd_addr),\n    .ifu_req_seq(),\n    .ifu_req_seq_rv32(),\n    .ifu_req_last_pc(),\n    .ifu_rsp_ready(ifu2itcm_icb_rsp_ready),\n    .itcm_nohold(itcm_nohold),\n    .itcm_region_indic(itcm_region_indic),\n    .ifu2itcm_icb_cmd_ready(ifu2itcm_icb_cmd_ready),\n    .ifu2itcm_icb_rsp_valid(ifu2itcm_icb_rsp_valid),\n    .ifu2itcm_icb_rsp_err(ifu2itcm_icb_rsp_err),\n    .ifu2itcm_icb_rsp_rdata(ifu2itcm_icb_rsp_rdata),\n    .ifu2biu_icb_cmd_ready(ifu2biu_icb_cmd_ready),\n    .ifu2biu_icb_rsp_valid(ifu2biu_icb_rsp_valid),\n    .ifu2biu_icb_rsp_err(ifu2biu_icb_rsp_err),\n    .ifu2biu_icb_rsp_rdata(ifu2biu_icb_rsp_rdata),\n    .ifu_req_ready(),\n    .ifu_rsp_valid(),\n    .ifu_rsp_err(),\n    .ifu_rsp_instr(),\n    .ifu2itcm_icb_cmd_valid(ifu2itcm_icb_cmd_valid),\n    .ifu2itcm_icb_cmd_addr(ifu2itcm_icb_cmd_addr),\n    .ifu2biu_icb_cmd_valid(ifu2biu_icb_cmd_valid),\n    .ifu2biu_icb_cmd_addr(ifu2biu_icb_cmd_addr)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 4, "code": "// Import necessary files\n`include \"e203_defines.v\"\n\nmodule e203_exu_alu_muldiv(\n    // Input ports\n    input               mdv_nob2b,      // Indicates no back-to-back operations are allowed\n    input               muldiv_i_valid, // Handshake valid signal for MUL/DIV input\n    output              muldiv_i_ready, // Handshake ready signal for MUL/DIV input\n    input  [E203_XLEN-1:0] muldiv_i_rs1,  // Operand RS1 for multiplication or division\n    input  [E203_XLEN-1:0] muldiv_i_rs2,  // Operand RS2 for multiplication or division\n    input  [E203_XLEN-1:0] muldiv_i_imm,  // Immediate operand for multiplication or division\n    input  [E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info, // Information bus for MUL/DIV\n    input  [E203_ITAG_WIDTH-1:0] muldiv_i_itag, // Instruction tag for MUL/DIV operations\n    output              muldiv_i_longpipe, // Indicates that the MUL/DIV operation is a long pipeline operation\n    input               flush_pulse,      // Flush signal to reset the MUL/DIV pipeline\n    // Output ports\n    output              muldiv_o_valid,  // Handshake valid signal for MUL/DIV output\n    input               muldiv_o_ready,  // Handshake ready signal for MUL/DIV output\n    output [E203_XLEN-1:0] muldiv_o_wbck_wdat, // Write-back data resulting from the MUL/DIV operation\n    output              muldiv_o_wbck_err, // Write-back error signal (always 0, as there are no exceptions for MUL/DIV)\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1, // Operand 1 for the shared ALU datapath\n    output [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2, // Operand 2 for the shared ALU datapath\n    output              muldiv_req_alu_add, // Indicates add operation for the shared ALU datapath\n    output              muldiv_req_alu_sub, // Indicates subtract operation for the shared ALU datapath\n    input  [E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res, // Result from the shared ALU datapath\n    output              muldiv_sbf_0_ena,  // Enable signal for shared buffer 0\n    output [32:0]        muldiv_sbf_0_nxt, // Next value to write to shared buffer 0\n    input  [32:0]        muldiv_sbf_0_r,   // Current value of shared buffer 0\n    output              muldiv_sbf_1_ena,  // Enable signal for shared buffer 1\n    output [32:0]        muldiv_sbf_1_nxt, // Next value to write to shared buffer 1\n    input  [32:0]        muldiv_sbf_1_r,   // Current value of shared buffer 1\n    // Clock and reset signals\n    input               clk,              // Clock signal for synchronous operation\n    input               rst_n              // Active-low reset signal for initializing the module\n);\n\n// Internal signals and variables\nreg [E203_XLEN-1:0] rs1_reg;\nreg [E203_XLEN-1:0] rs2_reg;\nreg [E203_XLEN-1:0] imm_reg;\nreg [E203_DECINFO_MULDIV_WIDTH-1:0] info_reg;\nreg [E203_ITAG_WIDTH-1:0] itag_reg;\nreg muldiv_i_longpipe_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset logic\n        rs1_reg <= '0;\n        rs2_reg <= '0;\n        imm_reg <= '0;\n        info_reg <= '0;\n        itag_reg <= '0;\n        muldiv_i_longpipe_reg <= '0;\n    end else begin\n        // Normal operation\n        if (muldiv_i_valid && muldiv_i_ready) begin\n            rs1_reg <= muldiv_i_rs1;\n            rs2_reg <= muldiv_i_rs2;\n            imm_reg <= muldiv_i_imm;\n            info_reg <= muldiv_i_info;\n            itag_reg <= muldiv_i_itag;\n            muldiv_i_longpipe_reg <= muldiv_i_longpipe;\n        end\n    end\nend\n\n// Combinational logic for MUL/DIV operations\nalways @(*) begin\n    // Default values\n    muldiv_o_valid = 1'b0;\n    muldiv_o_wbck_wdat = '0;\n    muldiv_o_wbck_err = 1'b0;\n    muldiv_req_alu_op1 = '0;\n    muldiv_req_alu_op2 = '0;\n    muldiv_req_alu_add = 1'b0;\n    muldiv_req_alu_sub = 1'b0;\n    muldiv_sbf_0_ena = 1'b0;\n    muldiv_sbf_0_nxt = '0;\n    muldiv_sbf_1_ena = 1'b0;\n    muldiv_sbf_1_nxt = '0;\n    \n    // MUL operation\n    if (info_reg[E203_DECINFO_MULDIV_WIDTH-1] == 1'b1) begin\n        // Multiply operation\n        muldiv_o_wbck_wdat = rs1_reg * rs2_reg;\n        muldiv_req_alu_op1 = rs1_reg;\n        muldiv_req_alu_op2 = rs2_reg;\n        muldiv_req_alu_add = 1'b1;\n    end else begin\n        // DIV operation\n        muldiv_o_wbck_wdat = rs1_reg / rs2_reg;\n        muldiv_req_alu_op1 = rs1_reg;\n        muldiv_req_alu_op2 = rs2_reg;\n        muldiv_req_alu_sub = 1'b1;\n    end\n    \n    // Shared buffer control\n    if (muldiv_i_longpipe_reg == 1'b1) begin\n        muldiv_sbf_0_ena = 1'b1;\n        muldiv_sbf_0_nxt = muldiv_req_alu_res;\n        muldiv_sbf_1_ena = 1'b1;\n        muldiv_sbf_1_nxt = muldiv_o_wbck_wdat;\n    end\nend\n\n// Handshake logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset logic\n        muldiv_i_ready <= 1'b0;\n        muldiv_o_valid <= 1'b0;\n    end else begin\n        // Normal operation\n        if (muldiv_i_valid && ~muldiv_i_ready) begin\n            muldiv_i_ready <= 1'b1;\n        end else if (~muldiv_i_valid && muldiv_i_ready) begin\n            muldiv_i_ready <= 1'b0;\n        end\n        \n        if (muldiv_o_ready && ~muldiv_o_valid) begin\n            muldiv_o_valid <= 1'b1;\n        end else if (~muldiv_o_ready && muldiv_o_valid) begin\n            muldiv_o_valid <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 2, "code": "module e203_ifu_minidec #(\n    parameter E203_INSTR_SIZE = 32,\n    parameter E203_RFIDX_WIDTH = 5,\n    parameter E203_XLEN = 32\n) (\n    input  logic [E203_INSTR_SIZE-1:0] instr,\n    output logic                     dec_rs1en,\n    output logic                     dec_rs2en,\n    output logic [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output logic                     dec_mulhsu,\n    output logic                     dec_mul,\n    output logic                     dec_div,\n    output logic                     dec_rem,\n    output logic                     dec_divu,\n    output logic                     dec_remu,\n    output logic                     dec_rv32,\n    output logic                     dec_bjp,\n    output logic                     dec_jal,\n    output logic                     dec_jalr,\n    output logic                     dec_bxx,\n    output logic [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output logic [E203_XLEN-1:0]      dec_bjp_imm\n);\n\n    // Instruction decoding logic\n    always_comb begin\n        // Default values\n        dec_rs1en = 1'b0;\n        dec_rs2en = 1'b0;\n        dec_rs1idx = '0;\n        dec_rs2idx = '0;\n        dec_mulhsu = 1'b0;\n        dec_mul = 1'b0;\n        dec_div = 1'b0;\n        dec_rem = 1'b0;\n        dec_divu = 1'b0;\n        dec_remu = 1'b0;\n        dec_rv32 = 1'b0;\n        dec_bjp = 1'b0;\n        dec_jal = 1'b0;\n        dec_jalr = 1'b0;\n        dec_bxx = 1'b0;\n        dec_jalr_rs1idx = '0;\n        dec_bjp_imm = '0;\n\n        // Decode instruction\n        case (instr[6:0])\n            7'b0000011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_bjp = 1'b1;\n                dec_bjp_imm = {{E203_XLEN-12{instr[31]}}, instr[30:20], instr[19:15], 1'b0, 3'b0};\n            end\n            7'b0000111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_bjp = 1'b1;\n                dec_bjp_imm = {{E203_XLEN-12{instr[31]}}, instr[30:20], instr[19:15], 1'b0, 3'b0};\n            end\n            7'b0001011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_bjp = 1'b1;\n                dec_bjp_imm = {{E203_XLEN-12{instr[31]}}, instr[30:20], instr[19:15], 1'b0, 3'b0};\n            end\n            7'b0001111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_bjp = 1'b1;\n                dec_bjp_imm = {{E203_XLEN-12{instr[31]}}, instr[30:20], instr[19:15], 1'b0, 3'b0};\n            end\n            7'b0010011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_mul = 1'b1;\n            end\n            7'b0010111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_mulhsu = 1'b1;\n            end\n            7'b0011011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_div = 1'b1;\n            end\n            7'b0011111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_rem = 1'b1;\n            end\n            7'b0100011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_divu = 1'b1;\n            end\n            7'b0100111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_remu = 1'b1;\n            end\n            7'b0101011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_jal = 1'b1;\n                dec_bjp_imm = {{E203_XLEN-21{instr[31]}}, instr[30:21], 1'b0, 3'b0};\n            end\n            7'b1100011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_jalr = 1'b1;\n                dec_jalr_rs1idx = instr[19:15];\n            end\n            default: begin\n                dec_rs1en = 1'b0;\n                dec_rs2en = 1'b0;\n                dec_rs1idx = '0;\n                dec_rs2idx = '0;\n                dec_mulhsu = 1'b0;\n                dec_mul = 1'b0;\n                dec_div = 1'b0;\n                dec_rem = 1'b0;\n                dec_divu = 1'b0;\n                dec_remu = 1'b0;\n                dec_rv32 = 1'b0;\n                dec_bjp = 1'b0;\n                dec_jal = 1'b0;\n                dec_jalr = 1'b0;\n                dec_bxx = 1'b0;\n                dec_jalr_rs1idx = '0;\n                dec_bjp_imm = '0;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 4, "code": "module e203_lsu_ctrl (\n    // Control Signals\n    input  logic commit_mret,\n    input  logic commit_trap,\n    output logic lsu_active,\n\n    // LSU Write-Back Interface\n    output logic lsu_o_valid,\n    input  logic lsu_o_ready,\n    output logic [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output logic [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output logic lsu_o_wbck_err,\n    output logic lsu_o_cmt_ld,\n    output logic lsu_o_cmt_st,\n    output logic [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output logic lsu_o_cmt_buserr,\n\n    // AGU-ICB Interface\n    input  logic agu_icb_cmd_valid,\n    output logic agu_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input  logic agu_icb_cmd_read,\n    input  logic [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    input  logic agu_icb_cmd_lock,\n    input  logic agu_icb_cmd_excl,\n    input  logic [1:0] agu_icb_cmd_size,\n    input  logic agu_icb_cmd_back2agu,\n    input  logic agu_icb_cmd_usign,\n    input  logic [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output logic agu_icb_rsp_valid,\n    input  logic agu_icb_rsp_ready,\n    output logic agu_icb_rsp_err,\n    output logic agu_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    // NICE Interface (Optional Configuration)\n    input  logic nice_mem_holdup,\n    input  logic nice_icb_cmd_valid,\n    output logic nice_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input  logic nice_icb_cmd_read,\n    input  logic [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] nice_icb_cmd_wmask,\n    output logic nice_icb_rsp_valid,\n    input  logic nice_icb_rsp_ready,\n    output logic nice_icb_rsp_err,\n    output logic [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    // Memory Interfaces\n    output logic dcache_icb_cmd_valid,\n    input  logic dcache_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output logic dcache_icb_cmd_read,\n    output logic [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] dcache_icb_cmd_wmask,\n    output logic dcache_icb_cmd_lock,\n    output logic dcache_icb_cmd_excl,\n    output logic [1:0] dcache_icb_cmd_size,\n    input  logic dcache_icb_rsp_valid,\n    output logic dcache_icb_rsp_ready,\n    input  logic dcache_icb_rsp_err,\n    input  logic dcache_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    output logic dtcm_icb_cmd_valid,\n    input  logic dtcm_icb_cmd_ready,\n    output logic [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n    output logic dtcm_icb_cmd_read,\n    output logic [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] dtcm_icb_cmd_wmask,\n    output logic dtcm_icb_cmd_lock,\n    output logic dtcm_icb_cmd_excl,\n    output logic [1:0] dtcm_icb_cmd_size,\n    input  logic dtcm_icb_rsp_valid,\n    output logic dtcm_icb_rsp_ready,\n    input  logic dtcm_icb_rsp_err,\n    input  logic dtcm_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n\n    input  logic [E203_ADDR_SIZE-1:0] itcm_region_indic,\n\n    output logic biu_icb_cmd_valid,\n    input  logic biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output logic biu_icb_cmd_read,\n    output logic [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] biu_icb_cmd_wmask,\n    output logic biu_icb_cmd_lock,\n    output logic biu_icb_cmd_excl,\n    output logic [1:0] biu_icb_cmd_size,\n    input  logic biu_icb_rsp_valid,\n    output logic biu_icb_rsp_ready,\n    input  logic biu_icb_rsp_err,\n    input  logic biu_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n\n// Main control logic implementation\nalways_comb begin\n    // LSU active status\n    lsu_active = 1'b1; // Always active in this example\n\n    // Write-back interface\n    lsu_o_valid = 1'b0; // Default to invalid\n    lsu_o_wbck_wdat = '0; // Default data\n    lsu_o_wbck_itag = '0; // Default tag\n    lsu_o_wbck_err = 1'b0; // Default no error\n    lsu_o_cmt_ld = 1'b0; // Default no load commit\n    lsu_o_cmt_st = 1'b0; // Default no store commit\n    lsu_o_cmt_badaddr = '0; // Default bad address\n    lsu_o_cmt_buserr = 1'b0; // Default no bus error\n\n    // AGU-ICB interface\n    agu_icb_cmd_ready = 1'b1; // Always ready\n    agu_icb_rsp_valid = 1'b0; // Default to invalid\n    agu_icb_rsp_err = 1'b0; // Default no error\n    agu_icb_rsp_excl_ok = 1'b0; // Default exclusive access not OK\n    agu_icb_rsp_rdata = '0; // Default read data\n\n    // NICE interface (if enabled)\n    if (E203_HAS_NICE) begin\n        nice_icb_cmd_ready = 1'b1; // Always ready\n        nice_icb_rsp_valid = 1'b0; // Default to invalid\n        nice_icb_rsp_err = 1'b0; // Default no error\n        nice_icb_rsp_rdata = '0; // Default read data\n    end\n\n    // Memory interfaces\n    dcache_icb_cmd_valid = 1'b0; // Default to invalid\n    dcache_icb_cmd_addr = '0; // Default address\n    dcache_icb_cmd_read = 1'b0; // Default to write\n    dcache_icb_cmd_wdata = '0; // Default write data\n    dcache_icb_cmd_wmask = '0; // Default write mask\n    dcache_icb_cmd_lock = 1'b0; // Default no lock\n    dcache_icb_cmd_excl = 1'b0; // Default no exclusive access\n    dcache_icb_cmd_size = 2'b00; // Default byte access\n    dcache_icb_rsp_ready = 1'b1; // Always ready\n\n    dtcm_icb_cmd_valid = 1'b0; // Default to invalid\n    dtcm_icb_cmd_addr = '0; // Default address\n    dtcm_icb_cmd_read = 1'b0; // Default to write\n    dtcm_icb_cmd_wdata = '0; // Default write data\n    dtcm_icb_cmd_wmask = '0; // Default write mask\n    dtcm_icb_cmd_lock = 1'b0; // Default no lock\n    dtcm_icb_cmd_excl = 1'b0; // Default no exclusive access\n    dtcm_icb_cmd_size = 2'b00; // Default byte access\n    dtcm_icb_rsp_ready = 1'b1; // Always ready\n\n    biu_icb_cmd_valid = 1'b0; // Default to invalid\n    biu_icb_cmd_addr = '0; // Default address\n    biu_icb_cmd_read = 1'b0; // Default to write\n    biu_icb_cmd_wdata = '0; // Default write data\n    biu_icb_cmd_wmask = '0; // Default write mask\n    biu_icb_cmd_lock = 1'b0; // Default no lock\n    biu_icb_cmd_excl = 1'b0; // Default no exclusive access\n    biu_icb_cmd_size = 2'b00; // Default byte access\n    biu_icb_rsp_ready = 1'b1; // Always ready\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 5, "code": "module e203_ifu (\n    input  logic                   clk,\n    input  logic                   rst_n,\n    output logic [E203_PC_SIZE-1:0] inspect_pc,\n    output logic                   ifu_active,\n    input  logic                   itcm_nohold,\n    input  logic [E203_PC_SIZE-1:0] pc_rtvec,\n\n    // IR stage to Execution Unit Interface\n    output logic [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output logic [E203_PC_SIZE-1:0] ifu_o_pc,\n    output logic                   ifu_o_pc_vld,\n    output logic                   ifu_o_misalgn,\n    output logic                   ifu_o_buserr,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output logic                   ifu_o_prdt_taken,\n    output logic                   ifu_o_muldiv_b2b,\n    output logic                   ifu_o_valid,\n    input  logic                   ifu_o_ready,\n\n    // Pipeline Control Interface\n    input  logic                   pipe_flush_req,\n    output logic                   pipe_flush_ack,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_pc,\n\n    // ITCM Interface\n    input  logic                   ifu2itcm_holdup,\n    input  logic [E203_ADDR_SIZE-1:0] itcm_region_indic,\n    output logic                   ifu2itcm_icb_cmd_valid,\n    input  logic                   ifu2itcm_icb_cmd_ready,\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input  logic                   ifu2itcm_icb_rsp_valid,\n    output logic                   ifu2itcm_icb_rsp_ready,\n    input  logic                   ifu2itcm_icb_rsp_err,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // System Memory Interface\n    output logic                   ifu2biu_icb_cmd_valid,\n    input  logic                   ifu2biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input  logic                   ifu2biu_icb_rsp_valid,\n    output logic                   ifu2biu_icb_rsp_ready,\n    input  logic                   ifu2biu_icb_rsp_err,\n    input  logic [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata,\n\n    // Halt Control Interface\n    input  logic                   ifu_halt_req,\n    output logic                   ifu_halt_ack,\n\n    // Other Input Interfaces\n    input  logic                   oitf_empty,\n    input  logic [E203_XLEN-1:0]    rf2ifu_x1,\n    input  logic [E203_XLEN-1:0]    rf2ifu_rs1,\n    input  logic                   dec2ifu_rs1en,\n    input  logic                   dec2ifu_rden,\n    input  logic [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input  logic                   dec2ifu_mulhsu,\n    input  logic                   dec2ifu_div,\n    input  logic                   dec2ifu_rem,\n    input  logic                   dec2ifu_divu,\n    input  logic                   dec2ifu_remu\n);\n\ne203_ifu_ifetch ifu_ifetch_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .pc_rtvec(pc_rtvec),\n    .ifu_o_ready(ifu_o_ready),\n    .pipe_flush_req(pipe_flush_req),\n    .pipe_flush_add_op1(pipe_flush_add_op1),\n    .pipe_flush_add_op2(pipe_flush_add_op2),\n    .pipe_flush_pc(pipe_flush_pc),\n    .ifu_halt_req(ifu_halt_req),\n    .oitf_empty(oitf_empty),\n    .rf2ifu_x1(rf2ifu_x1),\n    .rf2ifu_rs1(rf2ifu_rs1),\n    .dec2ifu_rden(dec2ifu_rden),\n    .dec2ifu_rs1en(dec2ifu_rs1en),\n    .dec2ifu_rdidx(dec2ifu_rdidx),\n    .dec2ifu_mulhsu(dec2ifu_mulhsu),\n    .dec2ifu_div(dec2ifu_div),\n    .dec2ifu_rem(dec2ifu_rem),\n    .dec2ifu_divu(dec2ifu_divu),\n    .dec2ifu_remu(dec2ifu_remu),\n    .inspect_pc(inspect_pc),\n    .ifu_req_valid(ifu2itcm_icb_cmd_valid),\n    .ifu_req_pc(ifu2itcm_icb_cmd_addr),\n    .ifu_req_seq(),\n    .ifu_req_seq_rv32(),\n    .ifu_req_last_pc(),\n    .pipe_flush_ack(pipe_flush_ack),\n    .ifu_halt_ack(ifu_halt_ack),\n    .ifu_o_ir(ifu_o_ir),\n    .ifu_o_pc(ifu_o_pc),\n    .ifu_o_pc_vld(ifu_o_pc_vld),\n    .ifu_o_misalgn(ifu_o_misalgn),\n    .ifu_o_buserr(ifu_o_buserr),\n    .ifu_o_rs1idx(ifu_o_rs1idx),\n    .ifu_o_rs2idx(ifu_o_rs2idx),\n    .ifu_o_prdt_taken(ifu_o_prdt_taken),\n    .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n    .ifu_o_valid(ifu_o_valid)\n);\n\ne203_ifu_ift2icb ift2icb_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .ifu_req_valid(ifu2itcm_icb_cmd_valid),\n    .ifu_req_pc(ifu2itcm_icb_cmd_addr),\n    .ifu_req_seq(),\n    .ifu_req_seq_rv32(),\n    .ifu_req_last_pc(),\n    .ifu_rsp_ready(ifu2itcm_icb_rsp_ready),\n    .itcm_nohold(itcm_nohold),\n    .itcm_region_indic(itcm_region_indic),\n    .ifu2itcm_icb_cmd_ready(ifu2itcm_icb_cmd_ready),\n    .ifu2itcm_icb_rsp_valid(ifu2itcm_icb_rsp_valid),\n    .ifu2itcm_icb_rsp_err(ifu2itcm_icb_rsp_err),\n    .ifu2itcm_icb_rsp_rdata(ifu2itcm_icb_rsp_rdata),\n    .ifu2biu_icb_cmd_ready(ifu2biu_icb_cmd_ready),\n    .ifu2biu_icb_rsp_valid(ifu2biu_icb_rsp_valid),\n    .ifu2biu_icb_rsp_err(ifu2biu_icb_rsp_err),\n    .ifu2biu_icb_rsp_rdata(ifu2biu_icb_rsp_rdata),\n    .ifu_req_ready(),\n    .ifu_rsp_valid(),\n    .ifu_rsp_err(),\n    .ifu_rsp_instr(),\n    .ifu2itcm_icb_cmd_valid(ifu2itcm_icb_cmd_valid),\n    .ifu2itcm_icb_cmd_addr(ifu2itcm_icb_cmd_addr),\n    .ifu2biu_icb_cmd_valid(ifu2biu_icb_cmd_valid),\n    .ifu2biu_icb_cmd_addr(ifu2biu_icb_cmd_addr)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 3, "code": "module e203_ifu_minidec #(\n    parameter E203_INSTR_SIZE = 32,\n    parameter E203_RFIDX_WIDTH = 5,\n    parameter E203_XLEN = 32\n) (\n    input  logic [E203_INSTR_SIZE-1:0] instr,\n    output logic                       dec_rs1en,\n    output logic                       dec_rs2en,\n    output logic [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output logic                       dec_mulhsu,\n    output logic                       dec_mul,\n    output logic                       dec_div,\n    output logic                       dec_rem,\n    output logic                       dec_divu,\n    output logic                       dec_remu,\n    output logic                       dec_rv32,\n    output logic                       dec_bjp,\n    output logic                       dec_jal,\n    output logic                       dec_jalr,\n    output logic                       dec_bxx,\n    output logic [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output logic [E203_XLEN-1:0]       dec_bjp_imm\n);\n\n    // Internal signals\n    logic [6:0] opcode;\n    logic [4:0] rd;\n    logic [4:0] rs1;\n    logic [4:0] rs2;\n    logic [2:0] funct3;\n    logic [6:0] funct7;\n\n    // Instruction decode\n    assign opcode = instr[6:0];\n    assign rd     = instr[11:7];\n    assign rs1    = instr[19:15];\n    assign rs2    = instr[24:20];\n    assign funct3 = instr[14:12];\n    assign funct7 = instr[31:25];\n\n    // Register access information\n    always @(posedge opcode) begin\n        case (opcode)\n            7'b0000011: begin // I-type\n                dec_rs1en <= 1'b1;\n                dec_rs2en <= 1'b0;\n                dec_rs1idx <= rs1;\n                dec_rs2idx <= 5'b0;\n            end\n            7'b0000111: begin // I-type\n                dec_rs1en <= 1'b1;\n                dec_rs2en <= 1'b0;\n                dec_rs1idx <= rs1;\n                dec_rs2idx <= 5'b0;\n            end\n            7'b0001011: begin // S-type\n                dec_rs1en <= 1'b1;\n                dec_rs2en <= 1'b1;\n                dec_rs1idx <= rs1;\n                dec_rs2idx <= rs2;\n            end\n            7'b0001111: begin // SB-type\n                dec_rs1en <= 1'b1;\n                dec_rs2en <= 1'b1;\n                dec_rs1idx <= rs1;\n                dec_rs2idx <= rs2;\n            end\n            7'b0010011: begin // I-type\n                dec_rs1en <= 1'b1;\n                dec_rs2en <= 1'b0;\n                dec_rs1idx <= rs1;\n                dec_rs2idx <= 5'b0;\n            end\n            7'b0010111: begin // I-type\n                dec_rs1en <= 1'b1;\n                dec_rs2en <= 1'b0;\n                dec_rs1idx <= rs1;\n                dec_rs2idx <= 5'b0;\n            end\n            7'b0011011: begin // I-type\n                dec_rs1en <= 1'b1;\n                dec_rs2en <= 1'b0;\n                dec_rs1idx <= rs1;\n                dec_rs2idx <= 5'b0;\n            end\n            7'b0110011: begin // R-type\n                dec_rs1en <= 1'b1;\n                dec_rs2en <= 1'b1;\n                dec_rs1idx <= rs1;\n                dec_rs2idx <= rs2;\n            end\n            7'b0110111: begin // R-type\n                dec_rs1en <= 1'b1;\n                dec_rs2en <= 1'b1;\n                dec_rs1idx <= rs1;\n                dec_rs2idx <= rs2;\n            end\n            default: begin\n                dec_rs1en <= 1'b0;\n                dec_rs2en <= 1'b0;\n                dec_rs1idx <= 5'b0;\n                dec_rs2idx <= 5'b0;\n            end\n        endcase\n    end\n\n    // Multiplication and division operations\n    always @(posedge opcode) begin\n        case (opcode)\n            7'b0110011: begin // R-type\n                case (funct3)\n                    3'b000: begin // MUL\n                        dec_mul <= 1'b1;\n                        dec_mulhsu <= 1'b0;\n                        dec_div <= 1'b0;\n                        dec_rem <= 1'b0;\n                        dec_divu <= 1'b0;\n                        dec_remu <= 1'b0;\n                    end\n                    3'b001: begin // MULH\n                        dec_mul <= 1'b0;\n                        dec_mulhsu <= 1'b0;\n                        dec_div <= 1'b0;\n                        dec_rem <= 1'b0;\n                        dec_divu <= 1'b0;\n                        dec_remu <= 1'b0;\n                    end\n                    3'b010: begin // MULHSU\n                        dec_mul <= 1'b0;\n                        dec_mulhsu <= 1'b1;\n                        dec_div <= 1'b0;\n                        dec_rem <= 1'b0;\n                        dec_divu <= 1'b0;\n                        dec_remu <= 1'b0;\n                    end\n                    3'b011: begin // MULHU\n                        dec_mul <= 1'b0;\n                        dec_mulhsu <= 1'b0;\n                        dec_div <= 1'b0;\n                        dec_rem <= 1'b0;\n                        dec_divu <= 1'b0;\n                        dec_remu <= 1'b0;\n                    end\n                    3'b100: begin // DIV\n                        dec_mul <= 1'b0;\n                        dec_mulhsu <= 1'b0;\n                        dec_div <= 1'b1;\n                        dec_rem <= 1'b0;\n                        dec_divu <= 1'b0;\n                        dec_remu <= 1'b0;\n                    end\n                    3'b101: begin // DIVU\n                        dec_mul <= 1'b0;\n                        dec_mulhsu <= 1'b0;\n                        dec_div <= 1'b0;\n                        dec_rem <= 1'b0;\n                        dec_divu <= 1'b1;\n                        dec_remu <= 1'b0;\n                    end\n                    3'b110: begin // REM\n                        dec_mul <= 1'b0;\n                        dec_mulhsu <= 1'b0;\n                        dec_div <= 1'b0;\n                        dec_rem <= 1'b1;\n                        dec_divu <= 1'b0;\n                        dec_remu <= 1'b0;\n                    end\n                    3'b111: begin // REMU\n                        dec_mul <= 1'b0;\n                        dec_mulhsu <= 1'b0;\n                        dec_div <= 1'b0;\n                        dec_rem <= 1'b0;\n                        dec_divu <= 1'b0;\n                        dec_remu <= 1'b1;\n                    end\n                    default: begin\n                        dec_mul <= 1'b0;\n                        dec_mulhsu <= 1'b0;\n                        dec_div <= 1'b0;\n                        dec_rem <= 1'b0;\n                        dec_divu <= 1'b0;\n                        dec_remu <= 1'b0;\n                    end\n                endcase\n            end\n            default: begin\n                dec_mul <= 1'b0;\n                dec_mulhsu <= 1'b0;\n                dec_div <= 1'b0;\n                dec_rem <= 1'b0;\n                dec_divu <= 1'b0;\n                dec_remu <= 1'b0;\n            end\n        endcase\n    end\n\n    // Branch and jump instructions\n    always @(posedge opcode) begin\n        case (opcode)\n            7'b1100011: begin // JAL\n                dec_bjp <= 1'b1;\n                dec_jal <= 1'b1;\n                dec_jalr <= 1'b0;\n                dec_bxx <= 1'b0;\n            end\n            7'b1100111: begin // JALR\n                dec_bjp <= 1'b1;\n                dec_jal <= 1'b0;\n                dec_jalr <= 1'b1;\n                dec_bxx <= 1'b0;\n            end\n            7'b1101011: begin // BRANCH\n                dec_bjp <= 1'b1;\n                dec_jal <= 1'b0;\n                dec_jalr <= 1'b0;\n                dec_bxx <= 1'b1;\n            end\n            default: begin\n                dec_bjp <= 1'b0;\n                dec_jal <= 1'b0;\n                dec_jalr <= 1'b0;\n                dec_bxx <= 1'b0;\n            end\n        endcase\n    end\n\n    // JALR RS1 index\n    always @(posedge opcode) begin\n        case (opcode)\n            7'b1100111: begin // JALR\n                dec_jalr_rs1idx <= rs1;\n            end\n            default: begin\n                dec_jalr_rs1idx <= 5'b0;\n            end\n        endcase\n    end\n\n    // Branch/jump immediate\n    always @(posedge opcode) begin\n        case (opcode)\n            7'b1100011: begin // JAL\n                dec_bjp_imm <= {instr[31], instr[19:12], instr[20], instr[30:21], 1'b0};\n            end\n            7'b1100111: begin // JALR\n                dec_bjp_imm <= {instr[31:20]};\n            end\n            7'b1101011: begin // BRANCH\n                dec_bjp_imm <= {instr[31], instr[7], instr[30:25], instr[11:8], instr[12], 1'b0};\n            end\n            default: begin\n                dec_bjp_imm <= 32'b0;\n            end\n        endcase\n    end\n\n    // RV32 instruction set flag\n    assign dec_rv32 = (E203_XLEN == 32) ? 1'b1 : 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 6, "code": "// Import necessary files\n`include \"e203_defines.v\"\n\nmodule e203_ifu (\n    // System Interface\n    input  logic                   clk,\n    input  logic                   rst_n,\n    output logic [E203_PC_SIZE-1:0] inspect_pc,\n    output logic                   ifu_active,\n    input  logic                   itcm_nohold,\n    input  logic [E203_PC_SIZE-1:0] pc_rtvec,\n\n    // IR stage to Execution Unit Interface\n    output logic [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output logic [E203_PC_SIZE-1:0]    ifu_o_pc,\n    output logic                   ifu_o_pc_vld,\n    output logic                   ifu_o_misalgn,\n    output logic                   ifu_o_buserr,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output logic                   ifu_o_prdt_taken,\n    output logic                   ifu_o_muldiv_b2b,\n    output logic                   ifu_o_valid,\n    input  logic                   ifu_o_ready,\n\n    // Pipeline Control Interface\n    input  logic                   pipe_flush_req,\n    output logic                   pipe_flush_ack,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_pc,\n\n    // ITCM Interface (if E203_HAS_ITCM is defined)\n    output logic                   ifu2itcm_icb_cmd_valid,\n    input  logic                   ifu2itcm_icb_cmd_ready,\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input  logic                   ifu2itcm_icb_rsp_valid,\n    output logic                   ifu2itcm_icb_rsp_ready,\n    input  logic                   ifu2itcm_icb_rsp_err,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // System Memory Interface (if E203_HAS_MEM_ITF is defined)\n    output logic                   ifu2biu_icb_cmd_valid,\n    input  logic                   ifu2biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input  logic                   ifu2biu_icb_rsp_valid,\n    output logic                   ifu2biu_icb_rsp_ready,\n    input  logic                   ifu2biu_icb_rsp_err,\n    input  logic [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata,\n\n    // Halt Control Interface\n    input  logic                   ifu_halt_req,\n    output logic                   ifu_halt_ack,\n\n    // Other Input Interfaces\n    input  logic                   oitf_empty,\n    input  logic [E203_XLEN-1:0]    rf2ifu_x1,\n    input  logic [E203_XLEN-1:0]    rf2ifu_rs1,\n    input  logic                   dec2ifu_rs1en,\n    input  logic                   dec2ifu_rden,\n    input  logic [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input  logic                   dec2ifu_mulhsu,\n    input  logic                   dec2ifu_div,\n    input  logic                   dec2ifu_rem,\n    input  logic                   dec2ifu_divu,\n    input  logic                   dec2ifu_remu\n);\n\n// Instantiate e203_ifu_ifetch and e203_ifu_ift2icb modules\ne203_ifu_ifetch ifu_ifetch_inst (\n    // Input ports\n    .clk(clk),\n    .rst_n(rst_n),\n    .pc_rtvec(pc_rtvec),\n    .ifu_o_ready(ifu_o_ready),\n    .pipe_flush_req(pipe_flush_req),\n    .pipe_flush_add_op1(pipe_flush_add_op1),\n    .pipe_flush_add_op2(pipe_flush_add_op2),\n    .pipe_flush_pc(pipe_flush_pc),\n    .ifu_halt_req(ifu_halt_req),\n    .oitf_empty(oitf_empty),\n    .rf2ifu_x1(rf2ifu_x1),\n    .rf2ifu_rs1(rf2ifu_rs1),\n    .dec2ifu_rden(dec2ifu_rden),\n    .dec2ifu_rs1en(dec2ifu_rs1en),\n    .dec2ifu_rdidx(dec2ifu_rdidx),\n    .dec2ifu_mulhsu(dec2ifu_mulhsu),\n    .dec2ifu_div(dec2ifu_div),\n    .dec2ifu_rem(dec2ifu_rem),\n    .dec2ifu_divu(dec2ifu_divu),\n    .dec2ifu_remu(dec2ifu_remu),\n\n    // Output ports\n    .inspect_pc(inspect_pc),\n    .ifu_req_valid(),\n    .ifu_req_pc(),\n    .ifu_req_seq(),\n    .ifu_req_seq_rv32(),\n    .ifu_req_last_pc(),\n    .pipe_flush_ack(pipe_flush_ack),\n    .ifu_halt_ack(ifu_halt_ack),\n    .ifu_o_ir(ifu_o_ir),\n    .ifu_o_pc(ifu_o_pc),\n    .ifu_o_pc_vld(ifu_o_pc_vld),\n    .ifu_o_misalgn(ifu_o_misalgn),\n    .ifu_o_buserr(ifu_o_buserr),\n    .ifu_o_rs1idx(ifu_o_rs1idx),\n    .ifu_o_rs2idx(ifu_o_rs2idx),\n    .ifu_o_prdt_taken(ifu_o_prdt_taken),\n    .ifu_o_muldiv_b2b(ifu_o_muldiv_b2b),\n    .ifu_o_valid(ifu_o_valid)\n);\n\ne203_ifu_ift2icb ift2icb_inst (\n    // Input ports\n    .clk(clk),\n    .rst_n(rst_n),\n    .ifu_req_valid(),\n    .ifu_req_pc(),\n    .ifu_req_seq(),\n    .ifu_req_seq_rv32(),\n    .ifu_req_last_pc(),\n    .ifu_rsp_ready(),\n    .itcm_nohold(itcm_nohold),\n    .itcm_region_indic(),\n    .ifu2itcm_icb_cmd_ready(ifu2itcm_icb_cmd_ready),\n    .ifu2itcm_icb_rsp_valid(ifu2itcm_icb_rsp_valid),\n    .ifu2itcm_icb_rsp_err(ifu2itcm_icb_rsp_err),\n    .ifu2itcm_icb_rsp_rdata(ifu2itcm_icb_rsp_rdata),\n    .ifu2biu_icb_cmd_ready(ifu2biu_icb_cmd_ready),\n    .ifu2biu_icb_rsp_valid(ifu2biu_icb_rsp_valid),\n    .ifu2biu_icb_rsp_err(ifu2biu_icb_rsp_err),\n    .ifu2biu_icb_rsp_rdata(ifu2biu_icb_rsp_rdata),\n\n    // Output ports\n    .ifu_req_ready(),\n    .ifu_rsp_valid(),\n    .ifu_rsp_err(),\n    .ifu_rsp_instr(),\n    .ifu2itcm_icb_cmd_valid(ifu2itcm_icb_cmd_valid),\n    .ifu2itcm_icb_cmd_addr(ifu2itcm_icb_cmd_addr),\n    .ifu2itcm_icb_rsp_ready(ifu2itcm_icb_rsp_ready),\n    .ifu2biu_icb_cmd_valid(ifu2biu_icb_cmd_valid),\n    .ifu2biu_icb_cmd_addr(ifu2biu_icb_cmd_addr),\n    .ifu2biu_icb_rsp_ready(ifu2biu_icb_rsp_ready)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 4, "code": "module e203_exu_alu_bjp(\n    input  logic                   bjp_i_valid,\n    output logic                   bjp_i_ready,\n    input  logic [E203_XLEN-1:0]   bjp_i_rs1,\n    input  logic [E203_XLEN-1:0]   bjp_i_rs2,\n    input  logic [E203_XLEN-1:0]   bjp_i_imm,\n    input  logic [E203_PC_SIZE-1:0]bjp_i_pc,\n    input  logic [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output logic                   bjp_o_valid,\n    input  logic                   bjp_o_ready,\n    output logic [E203_XLEN-1:0]   bjp_o_wbck_wdat,\n    output logic                   bjp_o_wbck_err,\n    output logic                   bjp_o_cmt_bjp,\n    output logic                   bjp_o_cmt_mret,\n    output logic                   bjp_o_cmt_dret,\n    output logic                   bjp_o_cmt_fencei,\n    output logic                   bjp_o_cmt_prdt,\n    output logic                   bjp_o_cmt_rslv,\n    output logic [E203_XLEN-1:0]   bjp_req_alu_op1,\n    output logic [E203_XLEN-1:0]   bjp_req_alu_op2,\n    output logic                   bjp_req_alu_cmp_eq,\n    output logic                   bjp_req_alu_cmp_ne,\n    output logic                   bjp_req_alu_cmp_lt,\n    output logic                   bjp_req_alu_cmp_gt,\n    output logic                   bjp_req_alu_cmp_ltu,\n    output logic                   bjp_req_alu_cmp_gtu,\n    output logic                   bjp_req_alu_add,\n    input  logic                   bjp_req_alu_cmp_res,\n    input  logic [E203_XLEN-1:0]   bjp_req_alu_add_res,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n\n// valid ready handshake\nassign bjp_i_ready = bjp_o_ready;\nassign bjp_o_valid = bjp_i_valid;\n\n// write back error\nassign bjp_o_wbck_err = 1'b0;\n\n// alu request\nalways @(posedge clk) begin\n    if (~rst_n) begin\n        bjp_req_alu_op1 <= '0;\n        bjp_req_alu_op2 <= '0;\n        bjp_req_alu_cmp_eq <= 1'b0;\n        bjp_req_alu_cmp_ne <= 1'b0;\n        bjp_req_alu_cmp_lt <= 1'b0;\n        bjp_req_alu_cmp_gt <= 1'b0;\n        bjp_req_alu_cmp_ltu <= 1'b0;\n        bjp_req_alu_cmp_gtu <= 1'b0;\n        bjp_req_alu_add <= 1'b0;\n    end else if (bjp_i_valid && bjp_o_ready) begin\n        case (bjp_i_info)\n            E203_DECINFO_BJP_BEQ: begin\n                bjp_req_alu_op1 <= bjp_i_rs1;\n                bjp_req_alu_op2 <= bjp_i_rs2;\n                bjp_req_alu_cmp_eq <= 1'b1;\n            end\n            E203_DECINFO_BJP_BNE: begin\n                bjp_req_alu_op1 <= bjp_i_rs1;\n                bjp_req_alu_op2 <= bjp_i_rs2;\n                bjp_req_alu_cmp_ne <= 1'b1;\n            end\n            E203_DECINFO_BJP_BLT: begin\n                bjp_req_alu_op1 <= bjp_i_rs1;\n                bjp_req_alu_op2 <= bjp_i_rs2;\n                bjp_req_alu_cmp_lt <= 1'b1;\n            end\n            E203_DECINFO_BJP_BGT: begin\n                bjp_req_alu_op1 <= bjp_i_rs1;\n                bjp_req_alu_op2 <= bjp_i_rs2;\n                bjp_req_alu_cmp_gt <= 1'b1;\n            end\n            E203_DECINFO_BJP_BLTU: begin\n                bjp_req_alu_op1 <= bjp_i_rs1;\n                bjp_req_alu_op2 <= bjp_i_rs2;\n                bjp_req_alu_cmp_ltu <= 1'b1;\n            end\n            E203_DECINFO_BJP_BGTU: begin\n                bjp_req_alu_op1 <= bjp_i_rs1;\n                bjp_req_alu_op2 <= bjp_i_rs2;\n                bjp_req_alu_cmp_gtu <= 1'b1;\n            end\n            E203_DECINFO_BJP_JUMP: begin\n                bjp_req_alu_op1 <= bjp_i_pc;\n                bjp_req_alu_op2 <= '0;\n                bjp_req_alu_add <= 1'b1;\n            end\n            default: begin\n                bjp_req_alu_op1 <= '0;\n                bjp_req_alu_op2 <= '0;\n                bjp_req_alu_cmp_eq <= 1'b0;\n                bjp_req_alu_cmp_ne <= 1'b0;\n                bjp_req_alu_cmp_lt <= 1'b0;\n                bjp_req_alu_cmp_gt <= 1'b0;\n                bjp_req_alu_cmp_ltu <= 1'b0;\n                bjp_req_alu_cmp_gtu <= 1'b0;\n                bjp_req_alu_add <= 1'b0;\n            end\n        endcase\n    end else begin\n        bjp_req_alu_op1 <= '0;\n        bjp_req_alu_op2 <= '0;\n        bjp_req_alu_cmp_eq <= 1'b0;\n        bjp_req_alu_cmp_ne <= 1'b0;\n        bjp_req_alu_cmp_lt <= 1'b0;\n        bjp_req_alu_cmp_gt <= 1'b0;\n        bjp_req_alu_cmp_ltu <= 1'b0;\n        bjp_req_alu_cmp_gtu <= 1'b0;\n        bjp_req_alu_add <= 1'b0;\n    end\nend\n\n// commit signals\nalways @(posedge clk) begin\n    if (~rst_n) begin\n        bjp_o_cmt_bjp <= 1'b0;\n        bjp_o_cmt_mret <= 1'b0;\n        bjp_o_cmt_dret <= 1'b0;\n        bjp_o_cmt_fencei <= 1'b0;\n        bjp_o_cmt_prdt <= 1'b0;\n        bjp_o_cmt_rslv <= 1'b0;\n    end else if (bjp_i_valid && bjp_o_ready) begin\n        case (bjp_i_info)\n            E203_DECINFO_BJP_BEQ, \n            E203_DECINFO_BJP_BNE, \n            E203_DECINFO_BJP_BLT, \n            E203_DECINFO_BJP_BGT, \n            E203_DECINFO_BJP_BLTU, \n            E203_DECINFO_BJP_BGTU: begin\n                bjp_o_cmt_bjp <= 1'b1;\n                bjp_o_cmt_mret <= 1'b0;\n                bjp_o_cmt_dret <= 1'b0;\n                bjp_o_cmt_fencei <= 1'b0;\n                bjp_o_cmt_prdt <= bjp_i_info[E203_DECINFO_BJP_BPRDT];\n                bjp_o_cmt_rslv <= bjp_req_alu_cmp_res;\n            end\n            E203_DECINFO_BJP_MRET: begin\n                bjp_o_cmt_bjp <= 1'b0;\n                bjp_o_cmt_mret <= 1'b1;\n                bjp_o_cmt_dret <= 1'b0;\n                bjp_o_cmt_fencei <= 1'b0;\n                bjp_o_cmt_prdt <= 1'b0;\n                bjp_o_cmt_rslv <= 1'b0;\n            end\n            E203_DECINFO_BJP_DRET: begin\n                bjp_o_cmt_bjp <= 1'b0;\n                bjp_o_cmt_mret <= 1'b0;\n                bjp_o_cmt_dret <= 1'b1;\n                bjp_o_cmt_fencei <= 1'b0;\n                bjp_o_cmt_prdt <= 1'b0;\n                bjp_o_cmt_rslv <= 1'b0;\n            end\n            E203_DECINFO_BJP_FENCEI: begin\n                bjp_o_cmt_bjp <= 1'b0;\n                bjp_o_cmt_mret <= 1'b0;\n                bjp_o_cmt_dret <= 1'b0;\n                bjp_o_cmt_fencei <= 1'b1;\n                bjp_o_cmt_prdt <= 1'b0;\n                bjp_o_cmt_rslv <= 1'b0;\n            end\n            default: begin\n                bjp_o_cmt_bjp <= 1'b0;\n                bjp_o_cmt_mret <= 1'b0;\n                bjp_o_cmt_dret <= 1'b0;\n                bjp_o_cmt_fencei <= 1'b0;\n                bjp_o_cmt_prdt <= 1'b0;\n                bjp_o_cmt_rslv <= 1'b0;\n            end\n        endcase\n    end else begin\n        bjp_o_cmt_bjp <= 1'b0;\n        bjp_o_cmt_mret <= 1'b0;\n        bjp_o_cmt_dret <= 1'b0;\n        bjp_o_cmt_fencei <= 1'b0;\n        bjp_o_cmt_prdt <= 1'b0;\n        bjp_o_cmt_rslv <= 1'b0;\n    end\nend\n\n// write back data\nalways @(posedge clk) begin\n    if (~rst_n) begin\n        bjp_o_wbck_wdat <= '0;\n    end else if (bjp_i_valid && bjp_o_ready) begin\n        case (bjp_i_info)\n            E203_DECINFO_BJP_JUMP: begin\n                bjp_o_wbck_wdat <= bjp_req_alu_add_res;\n            end\n            default: begin\n                bjp_o_wbck_wdat <= '0;\n            end\n        endcase\n    end else begin\n        bjp_o_wbck_wdat <= '0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 3, "code": "module itcm_controller (\n    input  logic                   clk,\n    input  logic                   rst_n,\n    input  logic                   test_mode,\n    output logic                   itcm_active,\n    input  logic                   tcm_cgstop,\n\n    // IFU Interface\n    input  logic                   ifu2itcm_icb_cmd_valid,\n    output logic                   ifu2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input  logic                   ifu2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output logic                   ifu2itcm_icb_rsp_valid,\n    input  logic                   ifu2itcm_icb_rsp_ready,\n    output logic                   ifu2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU Interface\n    input  logic                   lsu2itcm_icb_cmd_valid,\n    output logic                   lsu2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input  logic                   lsu2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output logic                   lsu2itcm_icb_rsp_valid,\n    input  logic                   lsu2itcm_icb_rsp_ready,\n    output logic                   lsu2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // External Interface (optional)\n    input  logic                   ext2itcm_icb_cmd_valid,\n    output logic                   ext2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input  logic                   ext2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ext2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_WMSK_WIDTH-1:0] ext2itcm_icb_cmd_wmask,\n    output logic                   ext2itcm_icb_rsp_valid,\n    input  logic                   ext2itcm_icb_rsp_ready,\n    output logic                   ext2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] ext2itcm_icb_rsp_rdata,\n\n    // RAM Interface\n    output logic                   itcm_ram_cs,\n    output logic                   itcm_ram_we,\n    output logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    output logic [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    output logic [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    input  logic [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    output logic                   clk_itcm_ram\n);\n\n// Internal signals and variables\nlogic [E203_ITCM_ADDR_WIDTH-1:0] addr;\nlogic [E203_ITCM_DATA_WIDTH-1:0] wdata;\nlogic [E203_ITCM_WMSK_WIDTH-1:0] wmask;\nlogic [E203_ITCM_DATA_WIDTH-1:0] rdata;\nlogic cmd_valid, cmd_ready, cmd_read;\nlogic rsp_valid, rsp_ready, rsp_err;\n\n// Data width conversion module instance (for LSU and external interfaces)\nsirv_gnrl_icb_n2w #(\n    .AW(E203_ITCM_ADDR_WIDTH),\n    .USR_W(1),\n    .FIFO_OUTS_NUM(E203_ITCM_OUTS_NUM),\n    .FIFO_CUT_READY(0),\n    .X_W(32),\n    .Y_W(E203_ITCM_DATA_WIDTH)\n) u_itcm_icb_lsu2itcm_n2w (\n    .clk(clk),\n    .rst_n(rst_n),\n    .i_icb_cmd_valid(lsu2itcm_icb_cmd_valid),\n    .i_icb_cmd_ready(lsu2itcm_icb_cmd_ready),\n    .i_icb_cmd_read(lsu2itcm_icb_cmd_read),\n    .i_icb_cmd_addr(lsu2itcm_icb_cmd_addr),\n    .i_icb_cmd_wdata(lsu2itcm_icb_cmd_wdata),\n    .i_icb_cmd_wmask(lsu2itcm_icb_cmd_wmask),\n    .i_icb_cmd_lock(1'b0),\n    .i_icb_cmd_excl(1'b0),\n    .i_icb_cmd_size(2'b10),\n    .i_icb_cmd_burst(2'b00),\n    .i_icb_cmd_beat(2'b01),\n    .i_icb_cmd_usr(1'b0),\n    .i_icb_rsp_valid(lsu2itcm_icb_rsp_valid),\n    .i_icb_rsp_ready(lsu2itcm_icb_rsp_ready),\n    .i_icb_rsp_err(lsu2itcm_icb_rsp_err),\n    .i_icb_rsp_excl_ok(1'b0),\n    .i_icb_rsp_rdata(lsu2itcm_icb_rsp_rdata),\n    .i_icb_rsp_usr(1'b0),\n    .o_icb_cmd_valid(cmd_valid),\n    .o_icb_cmd_ready(cmd_ready),\n    .o_icb_cmd_read(cmd_read),\n    .o_icb_cmd_addr(addr),\n    .o_icb_cmd_wdata(wdata),\n    .o_icb_cmd_wmask(wmask),\n    .o_icb_cmd_lock(),\n    .o_icb_cmd_excl(),\n    .o_icb_cmd_size(),\n    .o_icb_cmd_burst(),\n    .o_icb_cmd_beat(),\n    .o_icb_cmd_usr(),\n    .o_icb_rsp_valid(rsp_valid),\n    .o_icb_rsp_ready(rsp_ready),\n    .o_icb_rsp_err(rsp_err),\n    .o_icb_rsp_excl_ok(),\n    .o_icb_rsp_rdata(rdata),\n    .o_icb_rsp_usr()\n);\n\n// Bus arbiter module instance\nsirv_gnrl_icb_arbt #(\n    .AW(E203_ITCM_ADDR_WIDTH),\n    .DW(E203_ITCM_DATA_WIDTH),\n    .USR_W(1),\n    .ARBT_SCHEME(0),\n    .FIFO_OUTS_NUM(E203_ITCM_OUTS_NUM),\n    .FIFO_CUT_READY(0),\n    .ARBT_NUM(4),\n    .ALLOW_0CYCL_RSP(1),\n    .ARBT_PTR_W(2)\n) u_itcm_arb (\n    .clk(clk),\n    .rst_n(rst_n),\n    .o_icb_cmd_valid(cmd_valid),\n    .o_icb_cmd_ready(cmd_ready),\n    .o_icb_cmd_read(cmd_read),\n    .o_icb_cmd_addr(addr),\n    .o_icb_cmd_wdata(wdata),\n    .o_icb_cmd_wmask(wmask),\n    .o_icb_cmd_burst(2'b00),\n    .o_icb_cmd_beat(2'b01),\n    .o_icb_cmd_lock(1'b0),\n    .o_icb_cmd_excl(1'b0),\n    .o_icb_cmd_size(2'b10),\n    .o_icb_cmd_usr(1'b0),\n    .o_icb_rsp_valid(rsp_valid),\n    .o_icb_rsp_ready(rsp_ready),\n    .o_icb_rsp_err(rsp_err),\n    .o_icb_rsp_excl_ok(1'b0),\n    .o_icb_rsp_rdata(rdata),\n    .o_icb_rsp_usr(1'b0),\n    .i_bus_icb_cmd_ready(ifu2itcm_icb_cmd_ready),\n    .i_bus_icb_cmd_valid(ifu2itcm_icb_cmd_valid),\n    .i_bus_icb_cmd_read(ifu2itcm_icb_cmd_read),\n    .i_bus_icb_cmd_addr(ifu2itcm_icb_cmd_addr),\n    .i_bus_icb_cmd_wdata(ifu2itcm_icb_cmd_wdata),\n    .i_bus_icb_cmd_wmask(ifu2itcm_icb_cmd_wmask),\n    .i_bus_icb_cmd_burst(2'b00),\n    .i_bus_icb_cmd_beat(2'b01),\n    .i_bus_icb_cmd_lock(1'b0),\n    .i_bus_icb_cmd_excl(1'b0),\n    .i_bus_icb_cmd_size(2'b10),\n    .i_bus_icb_cmd_usr(1'b0),\n    .i_bus_icb_rsp_valid(ifu2itcm_icb_rsp_valid),\n    .i_bus_icb_rsp_ready(ifu2itcm_icb_rsp_ready),\n    .i_bus_icb_rsp_err(ifu2itcm_icb_rsp_err),\n    .i_bus_icb_rsp_excl_ok(1'b0),\n    .i_bus_icb_rsp_rdata(ifu2itcm_icb_rsp_rdata),\n    .i_bus_icb_rsp_usr(1'b0)\n);\n\n// SRAM controller module instance\nsirv_sram_icb_ctrl #(\n    .DW(E203_ITCM_DATA_WIDTH),\n    .MW(E203_ITCM_WMSK_WIDTH),\n    .AW(E203_ITCM_RAM_AW),\n    .AW_LSB(3),\n    .USR_W(1)\n) u_itcm_sram_ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .i_icb_cmd_valid(cmd_valid),\n    .i_icb_cmd_ready(cmd_ready),\n    .i_icb_cmd_read(cmd_read),\n    .i_icb_cmd_addr(addr),\n    .i_icb_cmd_wdata(wdata),\n    .i_icb_cmd_wmask(wmask),\n    .i_icb_cmd_usr(1'b0),\n    .i_icb_rsp_valid(rsp_valid),\n    .i_icb_rsp_ready(rsp_ready),\n    .i_icb_rsp_rdata(rdata),\n    .i_icb_rsp_usr(1'b0),\n    .ram_cs(itcm_ram_cs),\n    .ram_we(itcm_ram_we),\n    .ram_addr(itcm_ram_addr),\n    .ram_wem(itcm_ram_wem),\n    .ram_din(itcm_ram_din),\n    .ram_dout(itcm_ram_dout),\n    .clk_ram(clk_itcm_ram),\n    .sram_ctrl_active(itcm_active),\n    .tcm_cgstop(tcm_cgstop),\n    .test_mode(test_mode)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 2, "code": "module e203_biu #(\n    parameter E203_ADDR_SIZE = 32,\n    parameter E203_XLEN      = 32,\n    parameter E203_BIU_OUTS_NUM = 1\n) (\n    output  biu_active,\n    input   clk,\n    input   rst_n,\n\n    // ICB interface for LSU\n    input   lsu_icb_cmd_valid,\n    output  lsu_icb_cmd_ready,\n    input   [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input   lsu_icb_cmd_read,\n    input   [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input   [E203_XLEN/8-1:0] lsu_icb_cmd_wmask,\n    input   [1:0] lsu_icb_cmd_burst,\n    input   [1:0] lsu_icb_cmd_beat,\n    input   lsu_icb_cmd_lock,\n    input   lsu_icb_cmd_excl,\n    input   [1:0] lsu_icb_cmd_size,\n    output  lsu_icb_rsp_valid,\n    input   lsu_icb_rsp_ready,\n    output  lsu_icb_rsp_err,\n    output  lsu_icb_rsp_excl_ok,\n    output  [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // ICB interface for IFU\n    input   ifu_icb_cmd_valid,\n    output  ifu_icb_cmd_ready,\n    input   [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input   ifu_icb_cmd_read,\n    input   [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input   [E203_XLEN/8-1:0] ifu_icb_cmd_wmask,\n    input   [1:0] ifu_icb_cmd_burst,\n    input   [1:0] ifu_icb_cmd_beat,\n    input   ifu_icb_cmd_lock,\n    input   ifu_icb_cmd_excl,\n    input   [1:0] ifu_icb_cmd_size,\n    output  ifu_icb_rsp_valid,\n    input   ifu_icb_rsp_ready,\n    output  ifu_icb_rsp_err,\n    output  ifu_icb_rsp_excl_ok,\n    output  [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n\n    // ICB interface for PPI\n    input   ppi_icb_cmd_valid,\n    output  ppi_icb_cmd_ready,\n    input   [E203_ADDR_SIZE-1:0] ppi_icb_cmd_addr,\n    input   ppi_icb_cmd_read,\n    input   [E203_XLEN-1:0] ppi_icb_cmd_wdata,\n    input   [E203_XLEN/8-1:0] ppi_icb_cmd_wmask,\n    input   [1:0] ppi_icb_cmd_burst,\n    input   [1:0] ppi_icb_cmd_beat,\n    input   ppi_icb_cmd_lock,\n    input   ppi_icb_cmd_excl,\n    input   [1:0] ppi_icb_cmd_size,\n    output  ppi_icb_rsp_valid,\n    input   ppi_icb_rsp_ready,\n    output  ppi_icb_rsp_err,\n    output  ppi_icb_rsp_excl_ok,\n    output  [E203_XLEN-1:0] ppi_icb_rsp_rdata,\n\n    // ICB interface for CLINT\n    input   clint_icb_cmd_valid,\n    output  clint_icb_cmd_ready,\n    input   [E203_ADDR_SIZE-1:0] clint_icb_cmd_addr,\n    input   clint_icb_cmd_read,\n    input   [E203_XLEN-1:0] clint_icb_cmd_wdata,\n    input   [E203_XLEN/8-1:0] clint_icb_cmd_wmask,\n    input   [1:0] clint_icb_cmd_burst,\n    input   [1:0] clint_icb_cmd_beat,\n    input   clint_icb_cmd_lock,\n    input   clint_icb_cmd_excl,\n    input   [1:0] clint_icb_cmd_size,\n    output  clint_icb_rsp_valid,\n    input   clint_icb_rsp_ready,\n    output  clint_icb_rsp_err,\n    output  clint_icb_rsp_excl_ok,\n    output  [E203_XLEN-1:0] clint_icb_rsp_rdata,\n\n    // ICB interface for PLIC\n    input   plic_icb_cmd_valid,\n    output  plic_icb_cmd_ready,\n    input   [E203_ADDR_SIZE-1:0] plic_icb_cmd_addr,\n    input   plic_icb_cmd_read,\n    input   [E203_XLEN-1:0] plic_icb_cmd_wdata,\n    input   [E203_XLEN/8-1:0] plic_icb_cmd_wmask,\n    input   [1:0] plic_icb_cmd_burst,\n    input   [1:0] plic_icb_cmd_beat,\n    input   plic_icb_cmd_lock,\n    input   plic_icb_cmd_excl,\n    input   [1:0] plic_icb_cmd_size,\n    output  plic_icb_rsp_valid,\n    input   plic_icb_rsp_ready,\n    output  plic_icb_rsp_err,\n    output  plic_icb_rsp_excl_ok,\n    output  [E203_XLEN-1:0] plic_icb_rsp_rdata,\n\n    // ICB interface for FIO\n    input   fio_icb_cmd_valid,\n    output  fio_icb_cmd_ready,\n    input   [E203_ADDR_SIZE-1:0] fio_icb_cmd_addr,\n    input   fio_icb_cmd_read,\n    input   [E203_XLEN-1:0] fio_icb_cmd_wdata,\n    input   [E203_XLEN/8-1:0] fio_icb_cmd_wmask,\n    input   [1:0] fio_icb_cmd_burst,\n    input   [1:0] fio_icb_cmd_beat,\n    input   fio_icb_cmd_lock,\n    input   fio_icb_cmd_excl,\n    input   [1:0] fio_icb_cmd_size,\n    output  fio_icb_rsp_valid,\n    input   fio_icb_rsp_ready,\n    output  fio_icb_rsp_err,\n    output  fio_icb_rsp_excl_ok,\n    output  [E203_XLEN-1:0] fio_icb_rsp_rdata\n);\n\n// Internal signals and variables\nreg [E203_ADDR_SIZE-1:0] addr;\nreg [E203_XLEN-1:0] wdata;\nreg [E203_XLEN/8-1:0] wmask;\nreg read;\nreg [1:0] burst;\nreg [1:0] beat;\nreg lock;\nreg excl;\nreg [1:0] size;\nreg cmd_valid;\nreg cmd_ready;\nreg rsp_valid;\nreg rsp_ready;\nreg rsp_err;\nreg rsp_excl_ok;\nreg [E203_XLEN-1:0] rsp_rdata;\n\n// ICB arbiter\nsirv_gnrl_icb_arbt #(\n    .AW(E203_ADDR_SIZE),\n    .DW(E203_XLEN),\n    .ARBT_NUM(2),\n    .ARBT_PTR_W(1),\n    .USR_W(1),\n    .ARBT_SCHEME(0),\n    .ALLOW_0CYCL_RSP(0),\n    .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n    .FIFO_CUT_READY(1)\n) icb_arbiter (\n    .o_icb_cmd_valid(cmd_valid),\n    .o_icb_cmd_ready(cmd_ready),\n    .o_icb_cmd_read(read),\n    .o_icb_cmd_addr(addr),\n    .o_icb_cmd_wdata(wdata),\n    .o_icb_cmd_wmask(wmask),\n    .o_icb_rsp_valid(rsp_valid),\n    .o_icb_rsp_ready(rsp_ready),\n    .i_bus_icb_cmd_valid({lsu_icb_cmd_valid, ifu_icb_cmd_valid}),\n    .i_bus_icb_cmd_ready({lsu_icb_cmd_ready, ifu_icb_cmd_ready}),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// ICB buffer\nsirv_gnrl_icb_buffer #(\n    .AW(E203_ADDR_SIZE),\n    .DW(E203_XLEN),\n    .USR_W(1),\n    .OUTS_CNT_W($clog2(E203_BIU_OUTS_NUM)),\n    .CMD_DP(1),\n    .RSP_DP(1),\n    .CMD_CUT_READY(1),\n    .RSP_CUT_READY(1)\n) icb_buffer (\n    .icb_buffer_active(biu_active),\n    .i_icb_cmd_valid(cmd_valid),\n    .i_icb_cmd_ready(cmd_ready),\n    .i_icb_cmd_read(read),\n    .i_icb_cmd_addr(addr),\n    .i_icb_cmd_wdata(wdata),\n    .i_icb_cmd_wmask(wmask),\n    .i_icb_rsp_valid(rsp_valid),\n    .i_icb_rsp_ready(rsp_ready),\n    .o_icb_cmd_valid(),\n    .o_icb_cmd_ready(),\n    .o_icb_rsp_valid(),\n    .o_icb_rsp_ready(),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// ICB splitter\nsirv_gnrl_icb_splt #(\n    .FIFO_CUT_READY(1),\n    .SPLT_PTR_W(4),\n    .USR_W(1),\n    .AW(E203_ADDR_SIZE),\n    .DW(E203_XLEN),\n    .ALLOW_DIFF(0),\n    .ALLOW_0CYCL_RSP(1),\n    .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n    .SPLT_NUM(4),\n    .SPLT_PTR_1HOT(1)\n) icb_splitter (\n    .i_icb_splt_indic(),\n    .i_icb_cmd_valid(cmd_valid),\n    .i_icb_cmd_ready(cmd_ready),\n    .i_icb_cmd_read(read),\n    .i_icb_cmd_addr(addr),\n    .i_icb_cmd_wdata(wdata),\n    .i_icb_cmd_wmask(wmask),\n    .i_icb_rsp_valid(rsp_valid),\n    .i_icb_rsp_ready(rsp_ready),\n    .o_bus_icb_cmd_valid({ppi_icb_cmd_valid, clint_icb_cmd_valid, plic_icb_cmd_valid, fio_icb_cmd_valid}),\n    .o_bus_icb_cmd_ready({ppi_icb_cmd_ready, clint_icb_cmd_ready, plic_icb_cmd_ready, fio_icb_cmd_ready}),\n    .o_bus_icb_rsp_valid({ppi_icb_rsp_valid, clint_icb_rsp_valid, plic_icb_rsp_valid, fio_icb_rsp_valid}),\n    .o_bus_icb_rsp_ready({ppi_icb_rsp_ready, clint_icb_rsp_ready, plic_icb_rsp_ready, fio_icb_rsp_ready}),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 5, "code": "// Import necessary files\n`include \"e203_defines.v\"\n\nmodule e203_ifu_ift2icb (\n    // Input signals\n    input  logic                   itcm_nohold,        // ITCM no-hold signal\n    input  logic                   ifu_req_valid,      // Instruction fetch request valid\n    input  logic [E203_PC_SIZE-1:0] ifu_req_pc,         // Program counter address of the request\n    input  logic                   ifu_req_seq,        // Flag for sequential instruction fetch request\n    input  logic                   ifu_req_seq_rv32,   // RV32 incremental fetch flag\n    input  logic [E203_PC_SIZE-1:0] ifu_req_last_pc,    // The PC address of the previous access\n    input  logic                   ifu_rsp_ready,      // Instruction fetch response ready\n    input  logic                   clk,                // Clock signal\n    input  logic                   rst_n,              // Reset signal (active low)\n\n    // Output signals\n    output logic                   ifu_req_ready,      // Instruction fetch request ready\n    output logic                   ifu_rsp_valid,      // Instruction fetch response valid\n    output logic                   ifu_rsp_err,        // Instruction fetch response error\n    output logic [31:0]            ifu_rsp_instr,      // Response instruction data\n\n    // ITCM interface\n    output logic                   ifu2itcm_icb_cmd_valid, // ITCM command valid\n    input  logic                   ifu2itcm_icb_cmd_ready, // ITCM command ready\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr, // ITCM access address\n    input  logic                   ifu2itcm_icb_rsp_valid, // ITCM response valid\n    output logic                   ifu2itcm_icb_rsp_ready, // ITCM response ready\n    input  logic                   ifu2itcm_icb_rsp_err,  // ITCM response error\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata, // ITCM read data\n\n    // System memory interface\n    output logic                   ifu2biu_icb_cmd_valid, // BIU command valid\n    input  logic                   ifu2biu_icb_cmd_ready, // BIU command ready\n    output logic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr, // BIU access address\n    input  logic                   ifu2biu_icb_rsp_valid, // BIU response valid\n    output logic                   ifu2biu_icb_rsp_ready, // BIU response ready\n    input  logic                   ifu2biu_icb_rsp_err,  // BIU response error\n    input  logic [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata // BIU read data\n);\n\n// Internal signals and variables\nlogic [1:0] icb_state; // State machine state\nlogic icb_state_ena; // State update enable\nlogic [1:0] icb_state_nxt; // Next state\nlogic req_same_cross_holdup_r; // Request same, cross lanes, and hold\nlogic req_need_2uop_r; // Request needs 2uops\nlogic req_need_0uop_r; // Request needs 0uops\nlogic icb_cmd2itcm_r; // ICB command to ITCM\nlogic icb_cmd2biu_r; // ICB command to system memory\nlogic [E203_ITCM_ADDR_WIDTH-1:0] icb_cmd_addr_2_1_r; // ICB command address alignment\nlogic leftover_err_nxt; // Leftover error next\nlogic [15:0] leftover_nxt; // Leftover next\nlogic holdup2leftover_ena; // Holdup to leftover enable\nlogic uop1st2leftover_ena; // UOP1st to leftover enable\nlogic ifu_req_hsked; // Instruction fetch request handshake\nlogic ifu_icb_cmd_hsked; // ICB command handshake\nlogic ifu_icb_rsp_hsked; // ICB response handshake\nlogic i_ifu_rsp_hsked; // Internal response handshake\nlogic ifu_icb_rsp2leftover; // ICB response to leftover\nlogic ifu_icb_rsp2ir; // ICB response to instruction response\nlogic rsp_instr_sel_leftover; // Response instruction select leftover\nlogic rsp_instr_sel_icb_rsp; // Response instruction select ICB response\nlogic [31:0] ifu_icb_rsp_rdata_lsb16; // ICB response data lowest 16 bits\nlogic i_ifu_rsp_err; // Internal response error\nlogic i_ifu_rsp_valid; // Internal response valid\nlogic ifu_req_ready_condi; // Instruction fetch request ready condition\nlogic ifu_icb_cmd_valid_condi; // ICB command valid condition\nlogic ifu_icb_rsp_ready_condi; // ICB response ready condition\nlogic [E203_ADDR_SIZE-1:0] icb_cmd_addr; // ICB command address\nlogic icb_cmd2biu; // ICB command to system memory\nlogic ifu2biu_icb_cmd_valid_pre; // BIU command valid pre\nlogic ifu2biu_icb_cmd_addr_pre; // BIU command address pre\nlogic ifu2biu_icb_cmd_ready_pre; // BIU command ready pre\n\n// State machine implementation\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        icb_state <= 2'b00; // Reset to IDLE state\n    end else if (icb_state_ena) begin\n        icb_state <= icb_state_nxt;\n    end\nend\n\n// State transition logic\nalways @(*) begin\n    case (icb_state)\n        2'b00: begin // IDLE state\n            if (ifu_req_valid) begin\n                icb_state_nxt = 2'b01; // Transition to 1ST state\n            end else begin\n                icb_state_nxt = 2'b00; // Stay in IDLE state\n            end\n        end\n        2'b01: begin // 1ST state\n            if (ifu_icb_rsp_valid) begin\n                if (req_need_2uop_r) begin\n                    icb_state_nxt = 2'b10; // Transition to WAIT2ND state\n                end else begin\n                    icb_state_nxt = 2'b00; // Transition to IDLE state\n                end\n            end else begin\n                icb_state_nxt = 2'b01; // Stay in 1ST state\n            end\n        end\n        2'b10: begin // WAIT2ND state\n            if (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready) begin\n                icb_state_nxt = 2'b11; // Transition to 2ND state\n            end else begin\n                icb_state_nxt = 2'b10; // Stay in WAIT2ND state\n            end\n        end\n        2'b11: begin // 2ND state\n            if (ifu_icb_rsp_valid) begin\n                icb_state_nxt = 2'b00; // Transition to IDLE state\n            end else begin\n                icb_state_nxt = 2'b11; // Stay in 2ND state\n            end\n        end\n        default: begin\n            icb_state_nxt = 2'b00; // Default to IDLE state\n        end\n    endcase\nend\n\n// Request feature registering\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        req_same_cross_holdup_r <= 1'b0;\n        req_need_2uop_r <= 1'b0;\n        req_need_0uop_r <= 1'b0;\n    end else if (ifu_req_hsked) begin\n        req_same_cross_holdup_r <= ifu_req_same && ifu_req_cross && ifu_req_hold;\n        req_need_2uop_r <= ifu_req_need_2uop;\n        req_need_0uop_r <= ifu_req_need_0uop;\n    end\nend\n\n// Leftover buffer implementation\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        leftover_err_nxt <= 1'b0;\n        leftover_nxt <= 16'b0;\n    end else if (holdup2leftover_ena) begin\n        leftover_err_nxt <= ifu2itcm_icb_rsp_err;\n        leftover_nxt <= ifu2itcm_icb_rsp_rdata[31:16];\n    end else if (uop1st2leftover_ena) begin\n        leftover_err_nxt <= ifu2itcm_icb_rsp_err;\n        leftover_nxt <= ifu2itcm_icb_rsp_rdata[31:16];\n    end\nend\n\n// Response generation implementation\nalways @(*) begin\n    if (rsp_instr_sel_leftover) begin\n        ifu_rsp_instr <= {ifu_icb_rsp_rdata_lsb16, leftover_nxt};\n    end else if (rsp_instr_sel_icb_rsp) begin\n        ifu_rsp_instr <= ifu_icb_rsp_rdata;\n    end else begin\n        ifu_rsp_instr <= 32'b0;\n    end\nend\n\n// ICB command generation implementation\nalways @(*) begin\n    if (icb_cmd2itcm_r) begin\n        ifu2itcm_icb_cmd_addr <= icb_cmd_addr;\n    end else if (icb_cmd2biu_r) begin\n        ifu2biu_icb_cmd_addr <= icb_cmd_addr;\n    end else begin\n        ifu2itcm_icb_cmd_addr <= E203_ITCM_ADDR_WIDTH'b0;\n        ifu2biu_icb_cmd_addr <= E203_ADDR_SIZE'b0;\n    end\nend\n\n// Handshake control implementation\nalways @(*) begin\n    ifu_req_ready <= ifu_icb_cmd_ready && ifu_req_ready_condi;\n    ifu2itcm_icb_cmd_valid <= ifu_icb_cmd_valid && icb_cmd2itcm_r;\n    ifu2biu_icb_cmd_valid <= ifu_icb_cmd_valid && icb_cmd2biu_r;\n    ifu2itcm_icb_rsp_ready <= ifu_icb_rsp_ready && icb_cmd2itcm_r;\n    ifu2biu_icb_rsp_ready <= ifu_icb_rsp_ready && icb_cmd2biu_r;\nend\n\n// Data alignment implementation\nalways @(*) begin\n    ifu_icb_rsp_rdata_lsb16 <= ifu2itcm_icb_rsp_rdata[15:0];\nend\n\n// ICB response merge implementation\nalways @(*) begin\n    ifu_icb_rsp_err <= ifu2itcm_icb_rsp_err || ifu2biu_icb_rsp_err;\n    ifu_icb_rsp_valid <= ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid;\nend\n\n// ICB request distribution implementation\nalways @(*) begin\n    icb_cmd2biu <= ~icb_cmd2itcm_r;\n    ifu2biu_icb_cmd_valid_pre <= ifu_icb_cmd_valid && icb_cmd2biu;\n    ifu2biu_icb_cmd_addr_pre <= icb_cmd_addr;\n    ifu2biu_icb_cmd_ready_pre <= ifu2biu_icb_cmd_ready;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 2, "code": "// Define the module for the E203 CPU\nmodule e203_cpu (\n    // Input signals\n    input clk, // System clock\n    input rst_n, // Asynchronous reset (active low)\n    input test_mode, // Test mode signal\n    input pc_rtvec, // Reset vector address\n    input core_mhartid, // Hardware thread identifier\n    input dbg_irq_a, // Asynchronous debug interrupt\n    input ext_irq_a, // Asynchronous external interrupt\n    input sft_irq_a, // Asynchronous software interrupt\n    input tmr_irq_a, // Asynchronous timer interrupt\n    // Output signals\n    output inspect_pc, // Current instruction address\n    output inspect_dbg_irq, // Debug interrupt signal\n    output inspect_mem_cmd_valid, // Memory command valid signal\n    output inspect_mem_cmd_ready, // Memory command ready signal\n    output inspect_mem_rsp_valid, // Memory response valid signal\n    output inspect_mem_rsp_ready, // Memory response ready signal\n    output inspect_core_clk, // Core clock signal\n    output core_csr_clk, // Clock signal for CSR registers\n    output core_wfi, // Core work completion signal (waiting for interrupt)\n    output tm_stop // Timer stop signal\n);\n\n// Instantiate the reset control module\ne203_reset_ctrl reset_ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .test_mode(test_mode),\n    .rst_core(rst_core),\n    .rst_itcm(rst_itcm),\n    .rst_dtcm(rst_dtcm),\n    .rst_aon(rst_aon)\n);\n\n// Instantiate the clock control module\ne203_clk_ctrl clk_ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .test_mode(test_mode),\n    .core_cgstop(core_cgstop),\n    .core_ifu_active(core_ifu_active),\n    .core_exu_active(core_exu_active),\n    .core_lsu_active(core_lsu_active),\n    .core_biu_active(core_biu_active),\n    .core_wfi(core_wfi),\n    .clk_aon(clk_aon),\n    .clk_core_ifu(clk_core_ifu),\n    .clk_core_exu(clk_core_exu),\n    .clk_core_lsu(clk_core_lsu),\n    .clk_core_biu(clk_core_biu),\n    .clk_itcm(clk_itcm),\n    .clk_dtcm(clk_dtcm)\n);\n\n// Instantiate the interrupt synchronization module\ne203_irq_sync irq_sync (\n    .clk(clk),\n    .rst_n(rst_n),\n    .dbg_irq_a(dbg_irq_a),\n    .ext_irq_a(ext_irq_a),\n    .sft_irq_a(sft_irq_a),\n    .tmr_irq_a(tmr_irq_a),\n    .dbg_irq_r(dbg_irq_r),\n    .ext_irq_r(ext_irq_r),\n    .sft_irq_r(sft_irq_r),\n    .tmr_irq_r(tmr_irq_r)\n);\n\n// Instantiate the core module\ne203_core core (\n    .clk(clk),\n    .rst_n(rst_n),\n    .pc_rtvec(pc_rtvec),\n    .core_mhartid(core_mhartid),\n    .dbg_irq_r(dbg_irq_r),\n    .ext_irq_r(ext_irq_r),\n    .sft_irq_r(sft_irq_r),\n    .tmr_irq_r(tmr_irq_r),\n    .inspect_pc(inspect_pc),\n    .core_wfi(core_wfi),\n    .tm_stop(tm_stop),\n    .core_cgstop(core_cgstop),\n    .dbg_mode(dbg_mode),\n    .dbg_halt_r(dbg_halt_r),\n    .dbg_step_r(dbg_step_r),\n    .dbg_ebreakm_r(dbg_ebreakm_r),\n    .dbg_stopcycle(dbg_stopcycle)\n);\n\n// Instantiate the ITCM control module (if enabled)\ngenerate\nif (E203_HAS_ITCM) begin\n    e203_itcm_ctrl itcm_ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .test_mode(test_mode),\n        .itcm_active(itcm_active),\n        .tcm_cgstop(tcm_cgstop),\n        .ifu2itcm_icb_cmd_valid(ifu2itcm_icb_cmd_valid),\n        .ifu2itcm_icb_cmd_ready(ifu2itcm_icb_cmd_ready),\n        .ifu2itcm_icb_cmd_addr(ifu2itcm_icb_cmd_addr),\n        .ifu2itcm_icb_cmd_read(ifu2itcm_icb_cmd_read),\n        .ifu2itcm_icb_cmd_wdata(ifu2itcm_icb_cmd_wdata),\n        .ifu2itcm_icb_cmd_wmask(ifu2itcm_icb_cmd_wmask),\n        .ifu2itcm_icb_rsp_valid(ifu2itcm_icb_rsp_valid),\n        .ifu2itcm_icb_rsp_ready(ifu2itcm_icb_rsp_ready),\n        .ifu2itcm_icb_rsp_err(ifu2itcm_icb_rsp_err),\n        .ifu2itcm_icb_rsp_rdata(ifu2itcm_icb_rsp_rdata),\n        .lsu2itcm_icb_cmd_valid(lsu2itcm_icb_cmd_valid),\n        .lsu2itcm_icb_cmd_ready(lsu2itcm_icb_cmd_ready),\n        .lsu2itcm_icb_cmd_addr(lsu2itcm_icb_cmd_addr),\n        .lsu2itcm_icb_cmd_read(lsu2itcm_icb_cmd_read),\n        .lsu2itcm_icb_cmd_wdata(lsu2itcm_icb_cmd_wdata),\n        .lsu2itcm_icb_cmd_wmask(lsu2itcm_icb_cmd_wmask),\n        .lsu2itcm_icb_rsp_valid(lsu2itcm_icb_rsp_valid),\n        .lsu2itcm_icb_rsp_ready(lsu2itcm_icb_rsp_ready),\n        .lsu2itcm_icb_rsp_err(lsu2itcm_icb_rsp_err),\n        .lsu2itcm_icb_rsp_rdata(lsu2itcm_icb_rsp_rdata),\n        .itcm_ram_cs(itcm_ram_cs),\n        .itcm_ram_we(itcm_ram_we),\n        .itcm_ram_addr(itcm_ram_addr),\n        .itcm_ram_wem(itcm_ram_wem),\n        .itcm_ram_din(itcm_ram_din),\n        .itcm_ram_dout(itcm_ram_dout),\n        .clk_itcm_ram(clk_itcm_ram)\n    );\nend\nendgenerate\n\n// Instantiate the DTCM control module (if enabled)\ngenerate\nif (E203_HAS_DTCM) begin\n    e203_dtcm_ctrl dtcm_ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .test_mode(test_mode),\n        .dtcm_active(dtcm_active),\n        .tcm_cgstop(tcm_cgstop),\n        .lsu2dtcm_icb_cmd_valid(lsu2dtcm_icb_cmd_valid),\n        .lsu2dtcm_icb_cmd_ready(lsu2dtcm_icb_cmd_ready),\n        .lsu2dtcm_icb_cmd_addr(lsu2dtcm_icb_cmd_addr),\n        .lsu2dtcm_icb_cmd_read(lsu2dtcm_icb_cmd_read),\n        .lsu2dtcm_icb_cmd_wdata(lsu2dtcm_icb_cmd_wdata),\n        .lsu2dtcm_icb_cmd_wmask(lsu2dtcm_icb_cmd_wmask),\n        .lsu2dtcm_icb_rsp_valid(lsu2dtcm_icb_rsp_valid),\n        .lsu2dtcm_icb_rsp_ready(lsu2dtcm_icb_rsp_ready),\n        .lsu2dtcm_icb_rsp_err(lsu2dtcm_icb_rsp_err),\n        .lsu2dtcm_icb_rsp_rdata(lsu2dtcm_icb_rsp_rdata),\n        .dtcm_ram_cs(dtcm_ram_cs),\n        .dtcm_ram_we(dtcm_ram_we),\n        .dtcm_ram_addr(dtcm_ram_addr),\n        .dtcm_ram_wem(dtcm_ram_wem),\n        .dtcm_ram_din(dtcm_ram_din),\n        .dtcm_ram_dout(dtcm_ram_dout),\n        .clk_dtcm_ram(clk_dtcm_ram)\n    );\nend\nendgenerate\n\n// Instantiate the NICE core module (if enabled)\ngenerate\nif (E203_HAS_NICE) begin\n    e203_subsys_nice_core nice_core (\n        .nice_clk(clk),\n        .nice_rst_n(rst_n),\n        .nice_active(nice_active),\n        .nice_mem_holdup(nice_mem_holdup),\n        .nice_req_valid(nice_req_valid),\n        .nice_req_ready(nice_req_ready),\n        .nice_req_inst(nice_req_inst),\n        .nice_req_rs1(nice_req_rs1),\n        .nice_req_rs2(nice_req_rs2),\n        .nice_rsp_valid(nice_rsp_valid),\n        .nice_rsp_ready(nice_rsp_ready),\n        .nice_rsp_rdat(nice_rsp_rdat),\n        .nice_rsp_err(nice_rsp_err),\n        .nice_icb_cmd_valid(nice_icb_cmd_valid),\n        .nice_icb_cmd_ready(nice_icb_cmd_ready),\n        .nice_icb_cmd_addr(nice_icb_cmd_addr),\n        .nice_icb_cmd_read(nice_icb_cmd_read),\n        .nice_icb_cmd_wdata(nice_icb_cmd_wdata),\n        .nice_icb_cmd_size(nice_icb_cmd_size),\n        .nice_icb_rsp_valid(nice_icb_rsp_valid),\n        .nice_icb_rsp_ready(nice_icb_rsp_ready),\n        .nice_icb_rsp_rdata(nice_icb_rsp_rdata),\n        .nice_icb_rsp_err(nice_icb_rsp_err)\n    );\nend\nendgenerate\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 3, "code": "module e203_exu_alu_lsuagu(\n    input  logic                    agu_i_valid,\n    output logic                    agu_i_ready,\n    input  logic [E203_XLEN-1:0]    agu_i_rs1,\n    input  logic [E203_XLEN-1:0]    agu_i_rs2,\n    input  logic [E203_XLEN-1:0]    agu_i_imm,\n    input  logic [E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input  logic [E203_ITAG_WIDTH-1:0] agu_i_itag,\n    output logic                    agu_i_longpipe,\n    input  logic                    flush_req,\n    input  logic                    flush_pulse,\n    output logic                    amo_wait,\n    input  logic                    oitf_empty,\n    output logic                    agu_o_valid,\n    input  logic                    agu_o_ready,\n    output logic [E203_XLEN-1:0]    agu_o_wbck_wdat,\n    output logic                    agu_o_wbck_err,\n    output logic                    agu_o_cmt_misalgn,\n    output logic                    agu_o_cmt_ld,\n    output logic                    agu_o_cmt_stamo,\n    output logic                    agu_o_cmt_buserr,\n    output logic [E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output logic                    agu_icb_cmd_valid,\n    input  logic                    agu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    output logic                    agu_icb_cmd_read,\n    output logic [E203_XLEN-1:0]    agu_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0]  agu_icb_cmd_wmask,\n    output logic                    agu_icb_cmd_back2agu,\n    output logic                    agu_icb_cmd_lock,\n    output logic                    agu_icb_cmd_excl,\n    output logic [1:0]              agu_icb_cmd_size,\n    output logic [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n    output logic                    agu_icb_cmd_usign,\n    input  logic                    agu_icb_rsp_valid,\n    output logic                    agu_icb_rsp_ready,\n    input  logic                    agu_icb_rsp_err,\n    input  logic                    agu_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0]    agu_icb_rsp_rdata,\n    output logic [E203_XLEN-1:0]    agu_req_alu_op1,\n    output logic [E203_XLEN-1:0]    agu_req_alu_op2,\n    output logic                    agu_req_alu_swap,\n    output logic                    agu_req_alu_add,\n    output logic                    agu_req_alu_and,\n    output logic                    agu_req_alu_or,\n    output logic                    agu_req_alu_xor,\n    output logic                    agu_req_alu_max,\n    output logic                    agu_req_alu_min,\n    output logic                    agu_req_alu_maxu,\n    output logic                    agu_req_alu_minu,\n    input  logic [E203_XLEN-1:0]    agu_req_alu_res,\n    output logic                    agu_sbf_0_ena,\n    output logic [E203_XLEN-1:0]    agu_sbf_0_nxt,\n    input  logic [E203_XLEN-1:0]    agu_sbf_0_r,\n    output logic                    agu_sbf_1_ena,\n    output logic [E203_XLEN-1:0]    agu_sbf_1_nxt,\n    input  logic [E203_XLEN-1:0]    agu_sbf_1_r,\n    input  logic                    clk,\n    input  logic                    rst_n\n);\n\n// State machine implementation\nlogic [3:0] icb_state;\nlogic icb_state_idle, icb_state_1st, icb_state_amoalu, icb_state_amordy, icb_state_wait2nd, icb_state_2nd, icb_state_wbck;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        icb_state <= 4'd0; // Reset to IDLE state\n    end else begin\n        case (icb_state)\n            4'd0: begin // IDLE state\n                if (agu_i_valid && oitf_empty && ~flush_pulse) begin\n                    icb_state <= 4'd1; // Transition to 1ST state\n                end\n            end\n            4'd1: begin // 1ST state\n                if (agu_icb_rsp_valid || flush_pulse) begin\n                    icb_state <= 4'd4; // Transition to AMOALU state\n                end\n            end\n            4'd4: begin // AMOALU state\n                if (1'b1 || flush_pulse) begin\n                    icb_state <= 4'd5; // Transition to AMORDY state\n                end\n            end\n            4'd5: begin // AMORDY state\n                if (1'b1 || flush_pulse) begin\n                    icb_state <= 4'd2; // Transition to WAIT2ND state\n                end\n            end\n            4'd2: begin // WAIT2ND state\n                if (agu_icb_cmd_ready || flush_pulse) begin\n                    icb_state <= 4'd3; // Transition to 2ND state\n                end\n            end\n            4'd3: begin // 2ND state\n                if (agu_icb_rsp_valid || flush_pulse) begin\n                    icb_state <= 4'd6; // Transition to WBCK state\n                end\n            end\n            4'd6: begin // WBCK state\n                if (agu_o_ready || flush_pulse) begin\n                    icb_state <= 4'd0; // Transition back to IDLE state\n                end\n            end\n            default: begin\n                icb_state <= 4'd0; // Default to IDLE state\n            end\n        endcase\n    end\nend\n\nassign icb_state_idle = (icb_state == 4'd0);\nassign icb_state_1st = (icb_state == 4'd1);\nassign icb_state_amoalu = (icb_state == 4'd4);\nassign icb_state_amordy = (icb_state == 4'd5);\nassign icb_state_wait2nd = (icb_state == 4'd2);\nassign icb_state_2nd = (icb_state == 4'd3);\nassign icb_state_wbck = (icb_state == 4'd6);\n\n// Output assignments\nassign agu_i_ready = ~icb_state_idle;\nassign agu_i_longpipe = icb_state_1st || icb_state_amoalu || icb_state_amordy || icb_state_wait2nd || icb_state_2nd;\nassign amo_wait = icb_state_amoalu || icb_state_amordy;\nassign agu_o_valid = icb_state_wbck;\nassign agu_o_wbck_wdat = agu_req_alu_res;\nassign agu_o_wbck_err = agu_icb_rsp_err;\nassign agu_o_cmt_misalgn = agu_i_info[E203_DECINFO_AGU_WIDTH-1];\nassign agu_o_cmt_ld = agu_i_info[E203_DECINFO_AGU_WIDTH-2];\nassign agu_o_cmt_stamo = agu_i_info[E203_DECINFO_AGU_WIDTH-3];\nassign agu_o_cmt_buserr = agu_icb_rsp_err;\nassign agu_o_cmt_badaddr = agu_icb_cmd_addr;\nassign agu_icb_cmd_valid = icb_state_1st || icb_state_2nd;\nassign agu_icb_cmd_addr = agu_i_rs1 + agu_i_imm;\nassign agu_icb_cmd_read = icb_state_1st;\nassign agu_icb_cmd_wdata = agu_i_rs2;\nassign agu_icb_cmd_wmask = {E203_XLEN/8{1'b1}};\nassign agu_icb_cmd_back2agu = 1'b1;\nassign agu_icb_cmd_lock = 1'b0;\nassign agu_icb_cmd_excl = agu_i_info[E203_DECINFO_AGU_WIDTH-4];\nassign agu_icb_cmd_size = 2'd2; // Word size\nassign agu_icb_cmd_itag = agu_i_itag;\nassign agu_icb_cmd_usign = agu_i_info[E203_DECINFO_AGU_WIDTH-5];\nassign agu_icb_rsp_ready = 1'b1;\nassign agu_req_alu_op1 = agu_i_rs1;\nassign agu_req_alu_op2 = agu_i_rs2;\nassign agu_req_alu_swap = agu_i_info[E203_DECINFO_AGU_WIDTH-6];\nassign agu_req_alu_add = agu_i_info[E203_DECINFO_AGU_WIDTH-7];\nassign agu_req_alu_and = agu_i_info[E203_DECINFO_AGU_WIDTH-8];\nassign agu_req_alu_or = agu_i_info[E203_DECINFO_AGU_WIDTH-9];\nassign agu_req_alu_xor = agu_i_info[E203_DECINFO_AGU_WIDTH-10];\nassign agu_req_alu_max = agu_i_info[E203_DECINFO_AGU_WIDTH-11];\nassign agu_req_alu_min = agu_i_info[E203_DECINFO_AGU_WIDTH-12];\nassign agu_req_alu_maxu = agu_i_info[E203_DECINFO_AGU_WIDTH-13];\nassign agu_req_alu_minu = agu_i_info[E203_DECINFO_AGU_WIDTH-14];\nassign agu_sbf_0_ena = icb_state_amoalu;\nassign agu_sbf_0_nxt = agu_req_alu_res;\nassign agu_sbf_1_ena = icb_state_amordy;\nassign agu_sbf_1_nxt = agu_req_alu_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 5, "code": "// Define the module and its ports\nmodule e203_lsu_ctrl (\n    input  logic                            commit_mret,    // MRET commit instruction signal\n    input  logic                            commit_trap,    // Trap commit signal\n    output logic                            lsu_ctrl_active, // Indication of the active state of the LSU control module\n\n    // LSU Write-back Interface\n    output logic                            lsu_o_valid,    // Write-back data valid signal\n    input  logic                            lsu_o_ready,    // Write-back interface ready signal\n    output logic [E203_XLEN-1:0]            lsu_o_wbck_wdat, // Write-back data\n    output logic [E203_ITAG_WIDTH-1:0]      lsu_o_wbck_itag, // Instruction tag\n    output logic                            lsu_o_wbck_err,  // Error indication signal\n    output logic                            lsu_o_cmt_buserr, // Bus error exception indication\n    output logic [E203_ADDR_SIZE-1:0]       lsu_o_cmt_badaddr, // Error address\n    output logic                            lsu_o_cmt_ld,    // Load instruction commit indication\n    output logic                            lsu_o_cmt_st,    // Store instruction commit indication\n\n    // AGU-ICB Interface\n    input  logic                            agu_icb_cmd_valid, // Command valid signal\n    output logic                            agu_icb_cmd_ready, // Command ready signal\n    input  logic [E203_ADDR_SIZE-1:0]       agu_icb_cmd_addr,  // Access address\n    input  logic                            agu_icb_cmd_read,  // Read/write control (1: read, 0: write)\n    input  logic [E203_XLEN-1:0]            agu_icb_cmd_wdata, // Write data\n    input  logic [E203_XLEN/8-1:0]          agu_icb_cmd_wmask, // Byte write enable\n    input  logic                            agu_icb_cmd_lock,  // Lock signal\n    input  logic                            agu_icb_cmd_excl,  // Exclusive access signal\n    input  logic [1:0]                      agu_icb_cmd_size,  // Access size (00: byte, 01: half, 10: word)\n    input  logic                            agu_icb_cmd_back2agu, // Indication that the response needs to be returned to the AGU\n    input  logic                            agu_icb_cmd_usign,  // Unsigned load indication\n    input  logic [E203_ITAG_WIDTH-1:0]      agu_icb_cmd_itag,  // Instruction tag\n\n    // AGU-ICB Response Interface\n    output logic                            agu_icb_rsp_valid, // Response valid signal\n    input  logic                            agu_icb_rsp_ready, // Response receive ready signal\n    output logic                            agu_icb_rsp_err,   // Error response indication\n    output logic                            agu_icb_rsp_excl_ok, // Exclusive access success indication\n    output logic [E203_XLEN-1:0]            agu_icb_rsp_rdata,  // Read data\n\n    // NICE Interface (Optional Configuration)\n    input  logic                            nice_mem_holdup, // Memory access hold signal\n    input  logic                            nice_icb_cmd_valid, // Command valid signal\n    output logic                            nice_icb_cmd_ready, // Command ready signal\n    input  logic [E203_ADDR_SIZE-1:0]       nice_icb_cmd_addr,  // Access address\n    input  logic                            nice_icb_cmd_read,  // Read/write control\n    input  logic [E203_XLEN-1:0]            nice_icb_cmd_wdata, // Write data\n    input  logic [E203_XLEN/8-1:0]          nice_icb_cmd_wmask, // Write mask\n    output logic                            nice_icb_rsp_valid, // Response valid signal\n    input  logic                            nice_icb_rsp_ready, // Response ready signal\n    output logic                            nice_icb_rsp_err,   // Error indication\n    output logic [E203_XLEN-1:0]            nice_icb_rsp_rdata, // Read data\n\n    // Memory Interfaces\n    output logic                            dcache_icb_cmd_valid, // Command valid signal\n    input  logic                            dcache_icb_cmd_ready, // Command ready signal\n    output logic [E203_ADDR_SIZE-1:0]       dcache_icb_cmd_addr,  // Memory access address\n    output logic                            dcache_icb_cmd_read,  // Read/write control signal\n    output logic [E203_XLEN-1:0]            dcache_icb_cmd_wdata, // Write data\n    output logic [E203_XLEN/8-1:0]          dcache_icb_cmd_wmask, // Write mask\n    output logic                            dcache_icb_cmd_lock,  // Lock signal\n    output logic                            dcache_icb_cmd_excl,  // Exclusive access signal\n    output logic [1:0]                      dcache_icb_cmd_size,  // Access size\n    input  logic                            dcache_icb_rsp_valid, // Response valid signal\n    output logic                            dcache_icb_rsp_ready, // Response ready signal\n    input  logic                            dcache_icb_rsp_err,   // Error signal\n    input  logic                            dcache_icb_rsp_excl_ok, // Exclusive access success signal\n    input  logic [E203_XLEN-1:0]            dcache_icb_rsp_rdata, // Read data\n\n    output logic                            dtcm_icb_cmd_valid, // Command valid signal\n    input  logic                            dtcm_icb_cmd_ready, // Command ready signal\n    output logic [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,  // Memory access address\n    output logic                            dtcm_icb_cmd_read,  // Read/write control signal\n    output logic [E203_XLEN-1:0]            dtcm_icb_cmd_wdata, // Write data\n    output logic [E203_XLEN/8-1:0]          dtcm_icb_cmd_wmask, // Write mask\n    output logic                            dtcm_icb_cmd_lock,  // Lock signal\n    output logic                            dtcm_icb_cmd_excl,  // Exclusive access signal\n    output logic [1:0]                      dtcm_icb_cmd_size,  // Access size\n    input  logic                            dtcm_icb_rsp_valid, // Response valid signal\n    output logic                            dtcm_icb_rsp_ready, // Response ready signal\n    input  logic                            dtcm_icb_rsp_err,   // Error signal\n    input  logic                            dtcm_icb_rsp_excl_ok, // Exclusive access success signal\n    input  logic [E203_XLEN-1:0]            dtcm_icb_rsp_rdata, // Read data\n\n    output logic                            itcm_icb_cmd_valid, // Command valid signal\n    input  logic                            itcm_icb_cmd_ready, // Command ready signal\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] itcm_icb_cmd_addr,  // Memory access address\n    output logic                            itcm_icb_cmd_read,  // Read/write control signal\n    output logic [E203_XLEN-1:0]            itcm_icb_cmd_wdata, // Write data\n    output logic [E203_XLEN/8-1:0]          itcm_icb_cmd_wmask, // Write mask\n    output logic                            itcm_icb_cmd_lock,  // Lock signal\n    output logic                            itcm_icb_cmd_excl,  // Exclusive access signal\n    output logic [1:0]                      itcm_icb_cmd_size,  // Access size\n    input  logic                            itcm_icb_rsp_valid, // Response valid signal\n    output logic                            itcm_icb_rsp_ready, // Response ready signal\n    input  logic                            itcm_icb_rsp_err,   // Error signal\n    input  logic                            itcm_icb_rsp_excl_ok, // Exclusive access success signal\n    input  logic [E203_XLEN-1:0]            itcm_icb_rsp_rdata, // Read data\n\n    output logic                            biu_icb_cmd_valid, // Command valid signal\n    input  logic                            biu_icb_cmd_ready, // Command ready signal\n    output logic [E203_ADDR_SIZE-1:0]       biu_icb_cmd_addr,  // Memory access address\n    output logic                            biu_icb_cmd_read,  // Read/write control signal\n    output logic [E203_XLEN-1:0]            biu_icb_cmd_wdata, // Write data\n    output logic [E203_XLEN/8-1:0]          biu_icb_cmd_wmask, // Write mask\n    output logic                            biu_icb_cmd_lock,  // Lock signal\n    output logic                            biu_icb_cmd_excl,  // Exclusive access signal\n    output logic [1:0]                      biu_icb_cmd_size,  // Access size\n    input  logic                            biu_icb_rsp_valid, // Response valid signal\n    output logic                            biu_icb_rsp_ready, // Response ready signal\n    input  logic                            biu_icb_rsp_err,   // Error signal\n    input  logic                            biu_icb_rsp_excl_ok, // Exclusive access success signal\n    input  logic [E203_XLEN-1:0]            biu_icb_rsp_rdata   // Read data\n);\n\n// Your implementation goes here...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 4, "code": "module e203_ifu_minidec #(\n    parameter E203_INSTR_SIZE = 32,\n    parameter E203_RFIDX_WIDTH = 5,\n    parameter E203_XLEN = 32\n) (\n    input  logic [E203_INSTR_SIZE-1:0] instr,\n    output logic                     dec_rs1en,\n    output logic                     dec_rs2en,\n    output logic [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output logic                     dec_mulhsu,\n    output logic                     dec_mul,\n    output logic                     dec_div,\n    output logic                     dec_rem,\n    output logic                     dec_divu,\n    output logic                     dec_remu,\n    output logic                     dec_rv32,\n    output logic                     dec_bjp,\n    output logic                     dec_jal,\n    output logic                     dec_jalr,\n    output logic                     dec_bxx,\n    output logic [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output logic [E203_XLEN-1:0]      dec_bjp_imm\n);\n\n    // Instruction decode logic\n    always_comb begin\n        dec_rs1en = 1'b0;\n        dec_rs2en = 1'b0;\n        dec_rs1idx = '0;\n        dec_rs2idx = '0;\n        dec_mulhsu = 1'b0;\n        dec_mul = 1'b0;\n        dec_div = 1'b0;\n        dec_rem = 1'b0;\n        dec_divu = 1'b0;\n        dec_remu = 1'b0;\n        dec_rv32 = 1'b0;\n        dec_bjp = 1'b0;\n        dec_jal = 1'b0;\n        dec_jalr = 1'b0;\n        dec_bxx = 1'b0;\n        dec_jalr_rs1idx = '0;\n        dec_bjp_imm = '0;\n\n        case (instr[6:0])\n            7'b0000011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_bjp = 1'b1;\n                dec_bjp_imm = {{E203_XLEN-12{instr[31]}}, instr[30:20], instr[19:15], 1'b0, instr[11:7]};\n            end\n            7'b0000111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_bjp = 1'b1;\n                dec_bjp_imm = {{E203_XLEN-12{instr[31]}}, instr[30:20], instr[19:15], 1'b0, instr[11:7]};\n            end\n            7'b0001011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_bjp = 1'b1;\n                dec_bjp_imm = {{E203_XLEN-12{instr[31]}}, instr[30:20], instr[19:15], 1'b0, instr[11:7]};\n            end\n            7'b0001111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_bjp = 1'b1;\n                dec_bjp_imm = {{E203_XLEN-12{instr[31]}}, instr[30:20], instr[19:15], 1'b0, instr[11:7]};\n            end\n            7'b0010011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_mulhsu = 1'b1;\n            end\n            7'b0010111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_mul = 1'b1;\n            end\n            7'b0011011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_div = 1'b1;\n            end\n            7'b0011111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_rem = 1'b1;\n            end\n            7'b0100011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_divu = 1'b1;\n            end\n            7'b0100111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_remu = 1'b1;\n            end\n            7'b0101011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_rv32 = 1'b1;\n            end\n            7'b0110011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_bjp = 1'b1;\n                dec_bjp_imm = {{E203_XLEN-12{instr[31]}}, instr[30:20], instr[19:15], 1'b0, instr[11:7]};\n            end\n            7'b0110111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_bjp = 1'b1;\n                dec_bjp_imm = {{E203_XLEN-12{instr[31]}}, instr[30:20], instr[19:15], 1'b0, instr[11:7]};\n            end\n            7'b0111011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_bjp = 1'b1;\n                dec_bjp_imm = {{E203_XLEN-12{instr[31]}}, instr[30:20], instr[19:15], 1'b0, instr[11:7]};\n            end\n            7'b0111111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_rs2en = 1'b1;\n                dec_rs2idx = instr[24:20];\n                dec_bjp = 1'b1;\n                dec_bjp_imm = {{E203_XLEN-12{instr[31]}}, instr[30:20], instr[19:15], 1'b0, instr[11:7]};\n            end\n            7'b1000011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_jal = 1'b1;\n            end\n            7'b1000111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_jalr = 1'b1;\n                dec_jalr_rs1idx = instr[19:15];\n            end\n            7'b1001011: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_bxx = 1'b1;\n            end\n            7'b1001111: begin // I-type\n                dec_rs1en = 1'b1;\n                dec_rs1idx = instr[19:15];\n                dec_bxx = 1'b1;\n            end\n            default: begin\n                dec_rs1en = 1'b0;\n                dec_rs2en = 1'b0;\n                dec_rs1idx = '0;\n                dec_rs2idx = '0;\n                dec_mulhsu = 1'b0;\n                dec_mul = 1'b0;\n                dec_div = 1'b0;\n                dec_rem = 1'b0;\n                dec_divu = 1'b0;\n                dec_remu = 1'b0;\n                dec_rv32 = 1'b0;\n                dec_bjp = 1'b0;\n                dec_jal = 1'b0;\n                dec_jalr = 1'b0;\n                dec_bxx = 1'b0;\n                dec_jalr_rs1idx = '0;\n                dec_bjp_imm = '0;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 3, "code": "module e203_exu_alu_dpath(\n    input  logic                        alu_req_alu,\n    input  logic                        alu_req_alu_add,\n    input  logic                        alu_req_alu_sub,\n    input  logic                        alu_req_alu_xor,\n    input  logic                        alu_req_alu_sll,\n    input  logic                        alu_req_alu_srl,\n    input  logic                        alu_req_alu_sra,\n    input  logic                        alu_req_alu_or,\n    input  logic                        alu_req_alu_and,\n    input  logic [E203_XLEN-1:0]        alu_req_alu_op1,\n    input  logic0: [E203_XLEN-1:0]        alu_req_alu_op2,\n    input  logic                        bjp_req_alu,\n    input  logic [E203_XLEN-1:0]        bjp_req_alu_op1,\n    input  logic [E203_XLEN-1:0]        bjp_req_alu_op2,\n    input  logic                        agu_req_alu,\n    input  logic [E203_XLEN-1:0]        agu_req_alu_op1,\n    input  logic [E203_XLEN-1:0]        agu_req_alu_op2,\n    input  logic                        muldiv_req_alu,\n    input  logic [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input  logic [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input  logic                        muldiv_req_alu_add,\n    input  logic                        muldiv_req_alu_sub,\n    input  logic                        muldiv_sbf_0_ena,\n    input  logic [32:0]                 muldiv_sbf_0_nxt,\n    input  logic                        muldiv_sbf_1_ena,\n    input  logic [32:0]                 muldiv_sbf_1_nxt,\n    input  logic                        clk,\n    input  logic                        rst_n,\n    output logic [E203_XLEN-1:0]        alu_req_alu_res,\n    output logic [E203_XLEN-1:0]        bjp_req_alu_add_res,\n    output logic                        bjp_req_alu_cmp_res,\n    output logic [E203_XLEN-1:0]        agu_req_alu_res,\n    output logic [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n    output logic [32:0]                 muldiv_sbf_0_r,\n    output logic [32:0]                 muldiv_sbf_1_r\n);\n\n// Internal signals and variables\nlogic [E203_XLEN-1:0] alu_op1, alu_op2;\nlogic [E203_ALU_ADDER_WIDTH-1:0] muldiv_op1, muldiv_op2;\n\n// ALU operations\nalways @(posedge clk) begin\n    if (alu_req_alu) begin\n        case ({alu_req_alu_add, alu_req_alu_sub, alu_req_alu_xor, alu_req_alu_sll, alu_req_alu_srl, alu_req_alu_sra, alu_req_alu_or, alu_req_alu_and})\n            {1'b1, 4'b0000}: alu_req_alu_res <= alu_op1 + alu_op2;\n            {1'b0, 1'b1, 3'b000}: alu_req_alu_res <= alu_op1 - alu_op2;\n            {2'b00, 1'b1, 2'b00}: alu_req_alu_res <= alu_op1 ^ alu_op2;\n            {3'b000, 1'b1, 1'b0}: alu_req_alu_res <= alu_op1 << alu_op2;\n            {3'b000, 1'b0, 1'b1}: alu_req_alu_res <= alu_op1 >> alu_op2;\n            {3'b000, 2'b00, 1'b1}: alu_req_alu_res <= $signed(alu_op1) >>> alu_op2;\n            {4'b0000, 1'b1}: alu_req_alu_res <= alu_op1 | alu_op2;\n            {4'b0000, 1'b0}: alu_req_alu_res <= alu_op1 & alu_op2;\n            default: alu_req_alu_res <= '0;\n        endcase\n    end\nend\n\n// BJP operations\nalways @(posedge clk) begin\n    if (bjp_req_alu) begin\n        case ({alu_req_alu_add, alu_req_alu_sub, alu_req_alu_xor, alu_req_alu_sll, alu_req_alu_srl, alu_req_alu_sra, alu_req_alu_or, alu_req_alu_and})\n            {1'b1, 4'b0000}: bjp_req_alu_add_res <= bjp_req_alu_op1 + bjp_req_alu_op2;\n            {1'b0, 1'b1, 3'b000}: bjp_req_alu_add_res <= bjp_req_alu_op1 - bjp_req_alu_op2;\n            {2'b00, 1'b1, 2'b00}: bjp_req_alu_add_res <= bjp_req_alu_op1 ^ bjp_req_alu_op2;\n            {3'b000, 1'b1, 1'b0}: bjp_req_alu_add_res <= bjp_req_alu_op1 << bjp_req_alu_op2;\n            {3'b000, 1'b0, 1'b1}: bjp_req_alu_add_res <= bjp_req_alu_op1 >> bjp_req_alu_op2;\n            {3'b000, 2'b00, 1'b1}: bjp_req_alu_add_res <= $signed(bjp_req_alu_op1) >>> bjp_req_alu_op2;\n            {4'b0000, 1'b1}: bjp_req_alu_add_res <= bjp_req_alu_op1 | bjp_req_alu_op2;\n            {4'b0000, 1'b0}: bjp_req_alu_add_res <= bjp_req_alu_op1 & bjp_req_alu_op2;\n            default: bjp_req_alu_add_res <= '0;\n        endcase\n        bjp_req_alu_cmp_res <= (bjp_req_alu_op1 == bjp_req_alu_op2);\n    end\nend\n\n// AGU operations\nalways @(posedge clk) begin\n    if (agu_req_alu) begin\n        case ({alu_req_alu_add, alu_req_alu_sub, alu_req_alu_xor, alu_req_alu_sll, alu_req_alu_srl, alu_req_alu_sra, alu_req_alu_or, alu_req_alu_and})\n            {1'b1, 4'b0000}: agu_req_alu_res <= agu_req_alu_op1 + agu_req_alu_op2;\n            {1'b0, 1'b1, 3'b000}: agu_req_alu_res <= agu_req_alu_op1 - agu_req_alu_op2;\n            {2'b00, 1'b1, 2'b00}: agu_req_alu_res <= agu_req_alu_op1 ^ agu_req_alu_op2;\n            {3'b000, 1'b1, 1'b0}: agu_req_alu_res <= agu_req_alu_op1 << agu_req_alu_op2;\n            {3'b000, 1'b0, 1'b1}: agu_req_alu_res <= agu_req_alu_op1 >> agu_req_alu_op2;\n            {3'b000, 2'b00, 1'b1}: agu_req_alu_res <= $signed(agu_req_alu_op1) >>> agu_req_alu_op2;\n            {4'b0000, 1'b1}: agu_req_alu_res <= agu_req_alu_op1 | agu_req_alu_op2;\n            {4'b0000, 1'b0}: agu_req_alu_res <= agu_req_alu_op1 & agu_req_alu_op2;\n            default: agu_req_alu_res <= '0;\n        endcase\n    end\nend\n\n// MULDIV operations\nalways @(posedge clk) begin\n    if (muldiv_req_alu) begin\n        case ({muldiv_req_alu_add, muldiv_req_alu_sub})\n            {1'b1}: muldiv_req_alu_res <= muldiv_op1 + muldiv_op2;\n            {1'b0}: muldiv_req_alu_res <= muldiv_op1 - muldiv_op2;\n            default: muldiv_req_alu_res <= '0;\n        endcase\n    end\nend\n\n// Shared buffers\nsirv_gnrl_dffl #(.DW(33)) sbf_0_dffl(\n    .clk(clk),\n    .rst_n(rst_n),\n    .lden(muldiv_sbf_0_ena),\n    .dnxt(muldiv_sbf_0_nxt),\n    .qout(muldiv_sbf_0_r)\n);\n\nsirv_gnrl_dffl #(.DW(33)) sbf_1_dffl(\n    .clk(clk),\n    .rst_n(rst_n),\n    .lden(muldiv_sbf_1_ena),\n    .dnxt(muldiv_sbf_1_nxt),\n    .qout(muldiv_sbf_1_r)\n);\n\n// Assignments\nassign alu_op1 = alu_req_alu_op1;\nassign alu_op2 = alu_req_alu_op2;\nassign muldiv_op1 = muldiv_req_alu_op1;\nassign muldiv_op2 = muldiv_req_alu_op2;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 4, "code": "module itcm_controller (\n    input  logic                clk,\n    input  logic                rst_n,\n    input  logic                test_mode,\n    output logic                itcm_active,\n    input  logic                tcm_cgstop,\n\n    // IFU interface\n    input  logic                ifu2itcm_icb_cmd_valid,\n    output logic                ifu2itcm_icb_cmd_ready,\n    input  logic [31:0]         ifu2itcm_icb_cmd_addr,\n    input  logic                ifu2itcm_icb_cmd_read,\n    input  logic [31:0]         ifu2itcm_icb_cmd_wdata,\n    input  logic [3:0]          ifu2itcm_icb_cmd_wmask,\n    output logic                ifu2itcm_icb_rsp_valid,\n    input  logic                ifu2itcm_icb_rsp_ready,\n    output logic                ifu2itcm_icb_rsp_err,\n    output logic [31:0]         ifu2itcm_icb_rsp_rdata,\n\n    // LSU interface\n    input  logic                lsu2itcm_icb_cmd_valid,\n    output logic                lsu2itcm_icb_cmd_ready,\n    input  logic [31:0]         lsu2itcm_icb_cmd_addr,\n    input  logic                lsu2itcm_icb_cmd_read,\n    input  logic [31:0]         lsu2itcm_icb_cmd_wdata,\n    input  logic [3:0]          lsu2itcm_icb_cmd_wmask,\n    output logic                lsu2itcm_icb_rsp_valid,\n    input  logic                lsu2itcm_icb_rsp_ready,\n    output logic                lsu2itcm_icb_rsp_err,\n    output logic [31:0]         lsu2itcm_icb_rsp_rdata,\n\n    // External interface (optional)\n    input  logic                ext2itcm_icb_cmd_valid,\n    output logic                ext2itcm_icb_cmd_ready,\n    input  logic [31:0]         ext2itcm_icb_cmd_addr,\n    input  logic                ext2itcm_icb_cmd_read,\n    input  logic [31:0]         ext2itcm_icb_cmd_wdata,\n    input  logic [3:0]          ext2itcm_icb_cmd_wmask,\n    output logic                ext2itcm_icb_rsp_valid,\n    input  logic                ext2itcm_icb_rsp_ready,\n    output logic                ext2itcm_icb_rsp_err,\n    output logic [31:0]         ext2itcm_icb_rsp_rdata,\n\n    // RAM interface\n    output logic                itcm_ram_cs,\n    output logic                itcm_ram_we,\n    output logic [15:0]         itcm_ram_addr,\n    output logic [7:0]          itcm_ram_wem,\n    output logic [63:0]         itcm_ram_din,\n    input  logic [63:0]         itcm_ram_dout,\n    output logic                clk_itcm_ram\n);\n\n// Instantiate data width conversion module for LSU\nsirv_gnrl_icb_n2w #(\n    .AW(E203_ITCM_ADDR_WIDTH),\n    .USR_W(1),\n    .FIFO_OUTS_NUM(E203_ITCM_OUTS_NUM),\n    .FIFO_CUT_READY(0),\n    .X_W(32),\n    .Y_W(E203_ITCM_DATA_WIDTH)\n) u_itcm_icb_lsu2itcm_n2w (\n    .i_icb_cmd_valid(lsu2itcm_icb_cmd_valid),\n    .i_icb_cmd_ready(lsu2itcm_icb_cmd_ready),\n    .i_icb_cmd_read(lsu2itcm_icb_cmd_read),\n    .i_icb_cmd_addr(lsu2itcm_icb_cmd_addr),\n    .i_icb_cmd_wdata(lsu2itcm_icb_cmd_wdata),\n    .i_icb_cmd_wmask(lsu2itcm_icb_cmd_wmask),\n    .i_icb_cmd_lock(1'b0),\n    .i_icb_cmd_excl(1'b0),\n    .i_icb_cmd_size(2'b10),\n    .i_icb_cmd_burst(2'b00),\n    .i_icb_cmd_beat(2'b01),\n    .i_icb_cmd_usr(1'b0),\n    .i_icb_rsp_valid(lsu2itcm_icb_rsp_valid),\n    .i_icb_rsp_ready(lsu2itcm_icb_rsp_ready),\n    .i_icb_rsp_err(lsu2itcm_icb_rsp_err),\n    .i_icb_rsp_excl_ok(1'b0),\n    .i_icb_rsp_rdata(lsu2itcm_icb_rsp_rdata),\n    .i_icb_rsp_usr(1'b0),\n    .o_icb_cmd_valid(),\n    .o_icb_cmd_ready(),\n    .o_icb_cmd_read(),\n    .o_icb_cmd_addr(),\n    .o_icb_cmd_wdata(),\n    .o_icb_cmd_wmask(),\n    .o_icb_cmd_lock(),\n    .o_icb_cmd_excl(),\n    .o_icb_cmd_size(),\n    .o_icb_cmd_burst(),\n    .o_icb_cmd_beat(),\n    .o_icb_cmd_usr(),\n    .o_icb_rsp_valid(),\n    .o_icb_rsp_ready(),\n    .o_icb_rsp_err(),\n    .o_icb_rsp_excl_ok(),\n    .o_icb_rsp_rdata(),\n    .o_icb_rsp_usr(),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Instantiate bus arbiter module\nsirv_gnrl_icb_arbt #(\n    .AW(E203_ITCM_ADDR_WIDTH),\n    .DW(E203_ITCM_DATA_WIDTH),\n    .USR_W(1),\n    .ARBT_SCHEME(0),\n    .FIFO_OUTS_NUM(E203_ITCM_OUTS_NUM),\n    .FIFO_CUT_READY(0),\n    .ARBT_NUM(3),\n    .ALLOW_0CYCL_RSP(1),\n    .ARBT_PTR_W(2)\n) u_itcm_arb (\n    .o_icb_cmd_valid(),\n    .o_icb_cmd_ready(),\n    .o_icb_cmd_read(),\n    .o_icb_cmd_addr(),\n    .o_icb_cmd_wdata(),\n    .o_icb_cmd_wmask(),\n    .o_icb_cmd_burst(),\n    .o_icb_cmd_beat(),\n    .o_icb_cmd_lock(),\n    .o_icb_cmd_excl(),\n    .o_icb_cmd_size(),\n    .o_icb_cmd_usr(),\n    .o_icb_rsp_valid(),\n    .o_icb_rsp_ready(),\n    .o_icb_rsp_err(),\n    .o_icb_rsp_excl_ok(),\n    .o_icb_rsp_rdata(),\n    .o_icb_rsp_usr(),\n    .i_bus_icb_cmd_ready({ifu2itcm_icb_cmd_ready, lsu2itcm_icb_cmd_ready, ext2itcm_icb_cmd_ready}),\n    .i_bus_icb_cmd_valid({ifu2itcm_icb_cmd_valid, lsu2itcm_icb_cmd_valid, ext2itcm_icb_cmd_valid}),\n    .i_bus_icb_cmd_read({ifu2itcm_icb_cmd_read, lsu2itcm_icb_cmd_read, ext2itcm_icb_cmd_read}),\n    .i_bus_icb_cmd_addr({ifu2itcm_icb_cmd_addr, lsu2itcm_icb_cmd_addr, ext2itcm_icb_cmd_addr}),\n    .i_bus_icb_cmd_wdata({ifu2itcm_icb_cmd_wdata, lsu2itcm_icb_cmd_wdata, ext2itcm_icb_cmd_wdata}),\n    .i_bus_icb_cmd_wmask({ifu2itcm_icb_cmd_wmask, lsu2itcm_icb_cmd_wmask, ext2itcm_icb_cmd_wmask}),\n    .i_bus_icb_cmd_burst({2'b00, 2'b00, 2'b00}),\n    .i_bus_icb_cmd_beat({2'b01, 2'b01, 2'b01}),\n    .i_bus_icb_cmd_lock({1'b0, 1'b0, 1'b0}),\n    .i_bus_icb_cmd_excl({1'b0, 1'b0, 1'b0}),\n    .i_bus_icb_cmd_size({2'b10, 2'b10, 2'b10}),\n    .i_bus_icb_cmd_usr({1'b0, 1'b0, 1'b0}),\n    .i_bus_icb_rsp_valid({ifu2itcm_icb_rsp_valid, lsu2itcm_icb_rsp_valid, ext2itcm_icb_rsp_valid}),\n    .i_bus_icb_rsp_ready({ifu2itcm_icb_rsp_ready, lsu2itcm_icb_rsp_ready, ext2itcm_icb_rsp_ready}),\n    .i_bus_icb_rsp_err({ifu2itcm_icb_rsp_err, lsu2itcm_icb_rsp_err, ext2itcm_icb_rsp_err}),\n    .i_bus_icb_rsp_excl_ok({1'b0, 1'b0, 1'b0}),\n    .i_bus_icb_rsp_rdata({ifu2itcm_icb_rsp_rdata, lsu2itcm_icb_rsp_rdata, ext2itcm_icb_rsp_rdata}),\n    .i_bus_icb_rsp_usr({1'b0, 1'b0, 1'b0}),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Instantiate SRAM controller module\nsirv_sram_icb_ctrl #(\n    .DW(E203_ITCM_DATA_WIDTH),\n    .MW(E203_ITCM_WMSK_WIDTH),\n    .AW(E203_ITCM_ADDR_WIDTH),\n    .AW_LSB(3),\n    .USR_W(1)\n) u_itcm_sram_ctrl (\n    .i_icb_cmd_valid(u_itcm_arb.o_icb_cmd_valid),\n    .i_icb_cmd_ready(u_itcm_arb.o_icb_cmd_ready),\n    .i_icb_cmd_read(u_itcm_arb.o_icb_cmd_read),\n    .i_icb_cmd_addr(u_itcm_arb.o_icb_cmd_addr),\n    .i_icb_cmd_wdata(u_itcm_arb.o_icb_cmd_wdata),\n    .i_icb_cmd_wmask(u_itcm_arb.o_icb_cmd_wmask),\n    .i_icb_cmd_usr(u_itcm_arb.o_icb_cmd_usr),\n    .i_icb_rsp_valid(u_itcm_arb.o_icb_rsp_valid),\n    .i_icb_rsp_ready(u_itcm_arb.o_icb_rsp_ready),\n    .i_icb_rsp_rdata(u_itcm_arb.o_icb_rsp_rdata),\n    .i_icb_rsp_usr(u_itcm_arb.o_icb_rsp_usr),\n    .ram_cs(itcm_ram_cs),\n    .ram_we(itcm_ram_we),\n    .ram_addr(itcm_ram_addr),\n    .ram_wem(itcm_ram_wem),\n    .ram_din(itcm_ram_din),\n    .ram_dout(itcm_ram_dout),\n    .clk_ram(clk_itcm_ram),\n    .sram_ctrl_active(itcm_active),\n    .tcm_cgstop(tcm_cgstop),\n    .test_mode(test_mode),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 5, "code": "module e203_lsu_ctrl(\n    // Control Signals\n    input  logic commit_mret,\n    input  logic commit_trap,\n    output logic lsu_active,\n\n    // LSU Write-Back Interface\n    output logic lsu_o_valid,\n    input  logic lsu_o_ready,\n    output logic [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output logic [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output logic lsu_o_wbck_err,\n    output logic lsu_o_cmt_buserr,\n    output logic [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output logic lsu_o_cmt_ld,\n    output logic lsu_o_cmt_st,\n\n    // AGU-ICB Interface\n    input  logic agu_icb_cmd_valid,\n    output logic agu_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input  logic agu_icb_cmd_read,\n    input  logic [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    input  logic agu_icb_cmd_lock,\n    input  logic agu_icb_cmd_excl,\n    input  logic [1:0] agu_icb_cmd_size,\n    input  logic agu_icb_cmd_back2agu,\n    input  logic agu_icb_cmd_usign,\n    input  logic [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output logic agu_icb_rsp_valid,\n    input  logic agu_icb_rsp_ready,\n    output logic agu_icb_rsp_err,\n    output logic agu_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    // NICE Interface (Optional Configuration)\n    input  logic nice_mem_holdup,\n    input  logic nice_icb_cmd_valid,\n    output logic nice_icb_cmd_ready,\n    input  logic [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input  logic nice_icb_cmd_read,\n    input  logic [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] nice_icb_cmd_wmask,\n    output logic nice_icb_rsp_valid,\n    input  logic nice_icb_rsp_ready,\n    output logic nice_icb_rsp_err,\n    output logic [E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n    // ITCM Interface (Optional Configuration)\n    input  logic [E203_ADDR_SIZE-1:0] itcm_region_indic,\n    output logic itcm_icb_cmd_valid,\n    input  logic itcm_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] itcm_icb_cmd_addr,\n    output logic itcm_icb_cmd_read,\n    output logic [E203_XLEN-1:0] itcm_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] itcm_icb_cmd_wmask,\n    output logic itcm_icb_cmd_lock,\n    output logic itcm_icb_cmd_excl,\n    output logic [1:0] itcm_icb_cmd_size,\n    input  logic itcm_icb_rsp_valid,\n    output logic itcm_icb_rsp_ready,\n    input  logic itcm_icb_rsp_err,\n    input  logic itcm_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] itcm_icb_rsp_rdata,\n\n    // DTCM Interface (Optional Configuration)\n    input  logic [E203_ADDR_SIZE-1:0] dtcm_region_indic,\n    output logic dtcm_icb_cmd_valid,\n    input  logic dtcm_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] dtcm_icb_cmd_addr,\n    output logic dtcm_icb_cmd_read,\n    output logic [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] dtcm_icb_cmd_wmask,\n    output logic dtcm_icb_cmd_lock,\n    output logic dtcm_icb_cmd_excl,\n    output logic [1:0] dtcm_icb_cmd_size,\n    input  logic dtcm_icb_rsp_valid,\n    output logic dtcm_icb_rsp_ready,\n    input  logic dtcm_icb_rsp_err,\n    input  logic dtcm_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n\n    // DCache Interface (Optional Configuration)\n    output logic dcache_icb_cmd_valid,\n    input  logic dcache_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n    output logic dcache_icb_cmd_read,\n    output logic [E203_XLEN-1:0] dcache_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] dcache_icb_cmd_wmask,\n    output logic dcache_icb_cmd_lock,\n    output logic dcache_icb_cmd_excl,\n    output logic [1:0] dcache_icb_cmd_size,\n    input  logic dcache_icb_rsp_valid,\n    output logic dcache_icb_rsp_ready,\n    input  logic dcache_icb_rsp_err,\n    input  logic dcache_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n    // BIU Interface\n    output logic biu_icb_cmd_valid,\n    input  logic biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output logic biu_icb_cmd_read,\n    output logic [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output logic [E203_XLEN/8-1:0] biu_icb_cmd_wmask,\n    output logic biu_icb_cmd_lock,\n    output logic biu_icb_cmd_excl,\n    output logic [1:0] biu_icb_cmd_size,\n    input  logic biu_icb_rsp_valid,\n    output logic biu_icb_rsp_ready,\n    input  logic biu_icb_rsp_err,\n    input  logic biu_icb_rsp_excl_ok,\n    input  logic [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n\n// Internal Signals and Variables\nlogic [E203_XLEN-1:0] internal_wbck_wdat;\nlogic [E203_ITAG_WIDTH-1:0] internal_wbck_itag;\nlogic internal_wbck_err;\nlogic internal_cmt_buserr;\nlogic [E203_ADDR_SIZE-1:0] internal_cmt_badaddr;\nlogic internal_cmt_ld;\nlogic internal_cmt_st;\n\n// LSU Active State Management\nalways_ff @(posedge clk) begin\n    if (commit_mret || commit_trap) begin\n        lsu_active <= 1'b0;\n    end else if (agu_icb_cmd_valid || nice_icb_cmd_valid) begin\n        lsu_active <= 1'b1;\n    end\nend\n\n// LSU Write-Back Logic\nalways_comb begin\n    lsu_o_valid = internal_wbck_wdat != 0;\n    lsu_o_wbck_wdat = internal_wbck_wdat;\n    lsu_o_wbck_itag = internal_wbck_itag;\n    lsu_o_wbck_err = internal_wbck_err;\n    lsu_o_cmt_buserr = internal_cmt_buserr;\n    lsu_o_cmt_badaddr = internal_cmt_badaddr;\n    lsu_o_cmt_ld = internal_cmt_ld;\n    lsu_o_cmt_st = internal_cmt_st;\nend\n\n// AGU-ICB Command Handling\nalways_comb begin\n    agu_icb_cmd_ready = ~lsu_o_valid || lsu_o_ready;\nend\n\n// NICE Command Handling\nalways_comb begin\n    nice_icb_cmd_ready = ~lsu_o_valid || lsu_o_ready;\nend\n\n// ITCM Command Generation\nalways_comb0: begin\n    itcm_icb_cmd_valid = agu_icb_cmd_valid && (agu_icb_cmd_addr >= itcm_region_indic);\n    itcm_icb_cmd_addr = agu_icb_cmd_addr;\n    itcm_icb_cmd_read = agu_icb_cmd_read;\n    itcm_icb_cmd_wdata = agu_icb_cmd_wdata;\n    itcm_icb_cmd_wmask = agu_icb_cmd_wmask;\n    itcm_icb_cmd_lock = agu_icb_cmd_lock;\n    itcm_icb_cmd_excl = agu_icb_cmd_excl;\n    itcm_icb_cmd_size = agu_icb_cmd_size;\nend\n\n// DTCM Command Generation\nalways_comb begin\n    dtcm_icb_cmd_valid = agu_icb_cmd_valid && (agu_icb_cmd_addr >= dtcm_region_indic);\n    dtcm_icb_cmd_addr = agu_icb_cmd_addr;\n    dtcm_icb_cmd_read = agu_icb_cmd_read;\n    dtcm_icb_cmd_wdata = agu_icb_cmd_wdata;\n    dtcm_icb_cmd_wmask = agu_icb_cmd_wmask;\n    dtcm_icb_cmd_lock = agu_icb_cmd_lock;\n    dtcm_icb_cmd_excl = agu_icb_cmd_excl;\n    dtcm_icb_cmd_size = agu_icb_cmd_size;\nend\n\n// DCache Command Generation\nalways_comb begin\n    dcache_icb_cmd_valid = agu_icb_cmd_valid;\n    dcache_icb_cmd_addr = agu_icb_cmd_addr;\n    dcache_icb_cmd_read = agu_icb_cmd_read;\n    dcache_icb_cmd_wdata = agu_icb_cmd_wdata;\n    dcache_icb_cmd_wmask = agu_icb_cmd_wmask;\n    dcache_icb_cmd_lock = agu_icb_cmd_lock;\n    dcache_icb_cmd_excl = agu_icb_cmd_excl;\n    dcache_icb_cmd_size = agu_icb_cmd_size;\nend\n\n// BIU Command Generation\nalways_comb begin\n    biu_icb_cmd_valid = agu_icb_cmd_valid;\n    biu_icb_cmd_addr = agu_icb_cmd_addr;\n    biu_icb_cmd_read = agu_icb_cmd_read;\n    biu_icb_cmd_wdata = agu_icb_cmd_wdata;\n    biu_icb_cmd_wmask = agu_icb_cmd_wmask;\n    biu_icb_cmd_lock = agu_icb_cmd_lock;\n    biu_icb_cmd_excl = agu_icb_cmd_excl;\n    biu_icb_cmd_size = agu_icb_cmd_size;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 3, "code": "// Define the module and its ports\nmodule e203_dtcm_ctrl (\n    input  logic                   clk,            // System clock\n    input  logic                   rst_n,          // Asynchronous reset, active low\n    input  logic                   test_mode,      // Test mode signal\n    input  logic                   tcm_cgstop,     // Clock gating stop signal\n    output logic                   dtcm_active,    // DTCM activity state indicator\n\n    // LSU ICB Bus Interface\n    input  logic                   lsu2dtcm_icb_cmd_valid,  // Indicates that the LSU has a valid command for the DTCM\n    output logic                   lsu2dtcm_icb_cmd_ready,  // Indicates that the DTCM is ready to accept the command from the LSU\n    input  logic [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,  // Specifies the starting address of the bus transaction\n    input  logic                   lsu2dtcm_icb_cmd_read,   // Specifies whether the transaction is a read (1) or write (0)\n    input  logic [31:0]            lsu2dtcm_icb_cmd_wdata,  // Contains the write data when performing a write transaction\n    input  logic [3:0]             lsu2dtcm_icb_cmd_wmask,  // Specifies the write mask for the write transaction\n    output logic                   lsu2dtcm_icb_rsp_valid,  // Indicates that the DTCM has a valid response for the LSU\n    input  logic                   lsu2dtcm_icb_rsp_ready,  // Indicates that the LSU is ready to accept the response from the DTCM\n    output logic                   lsu2dtcm_icb_rsp_err,    // Indicates whether there was an error in the transaction\n    output logic [31:0]            lsu2dtcm_icb_rsp_rdata,  // Contains the read data when performing a read transaction\n\n    // External ICB Bus Interface (Optional)\n    input  logic                   ext2dtcm_icb_cmd_valid,  // Indicates that the external agent has a valid command for the DTCM\n    output logic                   ext2dtcm_icb_cmd_ready,  // Indicates that the DTCM is ready to accept the command from the external agent\n    input  logic [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,  // Specifies the starting address of the bus transaction\n    input  logic                   ext2dtcm_icb_cmd_read,   // Specifies whether the transaction is a read (1) or write (0)\n    input  logic [31:0]            ext2dtcm_icb_cmd_wdata,  // Contains the write data when performing a write transaction\n    input  logic [3:0]             ext2dtcm_icb_cmd_wmask,  // Specifies the write mask for the write transaction\n    output logic                   ext2dtcm_icb_rsp_valid,  // Indicates that the DTCM has a valid response for the external agent\n    input  logic                   ext2dtcm_icb_rsp_ready,  // Indicates that the external agent is ready to accept the response from the DTCM\n    output logic                   ext2dtcm_icb_rsp_err,    // Indicates whether there was an error in the transaction\n    output logic [31:0]            ext2dtcm_icb_rsp_rdata,  // Contains the read data when performing a read transaction\n\n    // DTCM RAM Interface\n    output logic                   dtcm_ram_cs,            // RAM chip select signal\n    output logic                   dtcm_ram_we,            // RAM write enable signal\n    output logic [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,      // RAM address\n    output logic [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,      // RAM write mask\n    output logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,      // RAM write data\n    input  logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,     // RAM read data\n    output logic                   clk_dtcm_ram            // RAM clock signal\n);\n\n// Instantiate the bus arbiter and SRAM controller modules\nsirv_gnrl_icb_arbt #(\n    .ARBT_SCHEME(0),              // Priority-based arbitration scheme\n    .ALLOW_0CYCL_RSP(0),          // Disables 0-cycle response\n    .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),  // Output FIFO depth\n    .FIFO_CUT_READY(0),           // Disables FIFO ready cut-off\n    .USR_W(1),                    // User data width\n    .ARBT_NUM(DTCM_ARBT_I_NUM),   // Number of arbitration input interfaces\n    .AW(E203_DTCM_ADDR_WIDTH),    // Address bus width\n    .DW(E203_DTCM_DATA_WIDTH),    // Data bus width\n    .ARBT_PTR_W(DTCM_ARBT_I_PTR_W) // Width of the arbitration pointer\n) u_arbiter (\n    .o_icb_cmd_valid(),           // Command valid to slave\n    .o_icb_cmd_ready(),           // Command ready from slave\n    .o_icb_cmd_read(),            // Read/write indicator (1=read)\n    .o_icb_cmd_addr(),            // Command address\n    .o_icb_cmd_wdata(),           // Write data\n    .o_icb_cmd_wmask(),           // Write mask\n    .o_icb_cmd_burst(),           // Burst type\n    .o_icb_cmd_beat(),            // Beat type\n    .o_icb_cmd_lock(),            // Lock signal\n    .o_icb_cmd_excl(),            // Exclusive access\n    .o_icb_cmd_size(),            // Transfer size\n    .o_icb_cmd_usr(),             // User-defined signal\n    .o_icb_rsp_valid(),           // Response valid from slave\n    .o_icb_rsp_ready(),           // Response ready to slave\n    .o_icb_rsp_err(),             // Response error\n    .o_icb_rsp_excl_ok(),         // Exclusive access ok\n    .o_icb_rsp_rdata(),           // Read data\n    .o_icb_rsp_usr(),             // User-defined response signal\n    .i_bus_icb_cmd_ready(),       // Command ready to masters\n    .i_bus_icb_cmd_valid(),       // Command valid from masters\n    .i_bus_icb_cmd_read(),        // Read/write indicators\n    .i_bus_icb_cmd_addr(),        // Command addresses\n    .i_bus_icb_cmd_wdata(),       // Write data\n    .i_bus_icb_cmd_wmask(),       // Write masks\n    .i_bus_icb_cmd_burst(),       // Burst types\n    .i_bus_icb_cmd_beat(),        // Beat types\n    .i_bus_icb_cmd_lock(),        // Lock signals\n    .i_bus_icb_cmd_excl(),        // Exclusive access\n    .i_bus_icb_cmd_size(),        // Transfer sizes\n    .i_bus_icb_cmd_usr(),         // User-defined signals\n    .i_bus_icb_rsp_valid(),       // Response valid to masters\n    .i_bus_icb_rsp_ready(),       // Response ready from masters\n    .i_bus_icb_rsp_err(),         // Response errors\n    .i_bus_icb_rsp_excl_ok(),     // Exclusive access ok\n    .i_bus_icb_rsp_rdata(),       // Read data to masters\n    .i_bus_icb_rsp_usr(),         // User-defined signals\n    .clk(clk),                    // Clock\n    .rst_n(rst_n)                 // Reset (active low)\n);\n\nsirv_sram_icb_ctrl #(\n    .DW(E203_DTCM_DATA_WIDTH),    // DTCM data width\n    .AW(E203_DTCM_ADDR_WIDTH),    // DTCM address width\n    .MW(E203_DTCM_WMSK_WIDTH),    // Write mask width\n    .AW_LSB(2),                   // 32-bit data alignment setting\n    .USR_W(1)                     // User data width configuration\n) u_sram_ctrl (\n    .sram_ctrl_active(),          // Active status indicator for clock gating control\n    .tcm_cgstop(tcm_cgstop),      // Clock gating stop signal from CSR (for debugging)\n    .i_icb_cmd_valid(),           // ICB command valid signal\n    .i_icb_cmd_ready(),           // ICB command ready signal\n    .i_icb_cmd_read(),            // Read/write indicator (1 = read)\n    .i_icb_cmd_addr(),            // Command address\n    .i_icb_cmd_wdata(),           // Write data\n    .i_icb_cmd_wmask(),           // Write mask\n    .i_icb_cmd_usr(),             // User-defined command signals\n    .i_icb_rsp_valid(),           // ICB response valid signal\n    .i_icb_rsp_ready(),           // ICB response ready signal\n    .i_icb_rsp_rdata(),           // Read data response\n    .i_icb_rsp_usr(),             // User-defined response signals\n    .ram_cs(dtcm_ram_cs),         // RAM chip select\n    .ram_we(dtcm_ram_we),         // RAM write enable\n    .ram_addr(dtcm_ram_addr),     // RAM address\n    .ram_wem(dtcm_ram_wem),       // RAM write mask\n    .ram_din(dtcm_ram_din),       // RAM write data\n    .ram_dout(dtcm_ram_dout),     // RAM read data\n    .clk_ram(clk_dtcm_ram),       // RAM clock signal\n    .test_mode(test_mode),        // Test mode enable\n    .clk(clk),                    // System clock\n    .rst_n(rst_n)                 // Reset signal (active low)\n);\n\n// Assign signals to the LSU ICB bus interface\nassign lsu2dtcm_icb_cmd_valid = u_arbiter.i_bus_icb_cmd_valid[0];\nassign lsu2dtcm_icb_cmd_ready = u_arbiter.o_icb_cmd_ready;\nassign lsu2dtcm_icb_cmd_addr = u_arbiter.o_icb_cmd_addr;\nassign lsu2dtcm_icb_cmd_read = u_arbiter.o_icb_cmd_read;\nassign lsu2dtcm_icb_cmd_wdata = u_arbiter.o_icb_cmd_wdata;\nassign lsu2dtcm_icb_cmd_wmask = u_arbiter.o_icb_cmd_wmask;\nassign lsu2dtcm_icb_rsp_valid = u_arbiter.o_icb_rsp_valid;\nassign lsu2dtcm_icb_rsp_ready = u_arbiter.i_bus_icb_rsp_ready[0];\nassign lsu2dtcm_icb_rsp_err = u_arbiter.o_icb_rsp_err;\nassign lsu2dtcm_icb_rsp_rdata = u_arbiter.o_icb_rsp_rdata;\n\n// Assign signals to the external ICB bus interface (if enabled)\n`ifdef E203_HAS_DTCM_EXTITF\nassign ext2dtcm_icb_cmd_valid = u_arbiter.i_bus_icb_cmd_valid[1];\nassign ext2dtcm_icb_cmd_ready = u_arbiter.o_icb_cmd_ready;\nassign ext2dtcm_icb_cmd_addr = u_arbiter.o_icb_cmd_addr;\nassign ext2dtcm_icb_cmd_read = u_arbiter.o_icb_cmd_read;\nassign ext2dtcm_icb_cmd_wdata = u_arbiter.o_icb_cmd_wdata;\nassign ext2dtcm_icb_cmd_wmask = u_arbiter.o_icb_cmd_wmask;\nassign ext2dtcm_icb_rsp_valid = u_arbiter.o_icb_rsp_valid;\nassign ext2dtcm_icb_rsp_ready = u_arbiter.i_bus_icb_rsp_ready[1];\nassign ext2dtcm_icb_rsp_err = u_arbiter.o_icb_rsp_err;\nassign ext2dtcm_icb_rsp_rdata = u_arbiter.o_icb_rsp_rdata;\n`endif\n\n// Assign signals to the DTCM RAM interface\nassign dtcm_ram_cs = u_sram_ctrl.ram_cs;\nassign dtcm_ram_we = u_sram_ctrl.ram_we;\nassign dtcm_ram_addr = u_sram_ctrl.ram_addr;\nassign dtcm_ram_wem = u_sram_ctrl.ram_wem;\nassign dtcm_ram_din = u_sram_ctrl.ram_din;\nassign dtcm_ram_dout = u_sram_ctrl.ram_dout;\nassign clk_dtcm_ram = u_sram_ctrl.clk_ram;\n\n// Assign the dtcm_active signal\nassign dtcm_active = u_sram_ctrl.sram_ctrl_active;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 5, "code": "module e203_exu_alu_bjp(\n    input  logic                   bjp_i_valid,\n    output logic                   bjp_i_ready,\n    input  logic [E203_XLEN-1:0]   bjp_i_rs1,\n    input  logic [E203_XLEN-1:0]   bjp_i_rs2,\n    input  logic [E203_XLEN-1:0]   bjp_i_imm,\n    input  logic [E203_PC_SIZE-1:0]bjp_i_pc,\n    input  logic [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    output logic                   bjp_o_valid,\n    input  logic                   bjp_o_ready,\n    output logic [E203_XLEN-1:0]   bjp_o_wbck_wdat,\n    output logic                   bjp_o_wbck_err,\n    output logic                   bjp_o_cmt_bjp,\n    output logic                   bjp_o_cmt_mret,\n    output logic                   bjp_o_cmt_dret,\n    output logic                   bjp_o_cmt_fencei,\n    output logic                   bjp_o_cmt_prdt,\n    output logic                   bjp_o_cmt_rslv,\n    output logic [E203_XLEN-1:0]   bjp_req_alu_op1,\n    output logic [E203_XLEN-1:0]   bjp_req_alu_op2,\n    output logic                   bjp_req_alu_cmp_eq,\n    output logic                   bjp_req_alu_cmp_ne,\n    output logic                   bjp_req_alu_cmp_lt,\n    output logic                   bjp_req_alu_cmp_gt,\n    output logic                   bjp_req_alu_cmp_ltu,\n    output logic                   bjp_req_alu_cmp_gtu,\n    output logic                   bjp_req_alu_add,\n    input  logic                   bjp_req_alu_cmp_res,\n    input  logic [E203_XLEN-1:0]   bjp_req_alu_add_res,\n    input  logic                   clk,\n    input  logic                   rst_n\n);\n\n    // Valid-Ready Handshake\n    assign bjp_i_ready = bjp_o_ready;\n    assign bjp_o_valid = bjp_i_valid;\n\n    // Generating ALU Requests\n    always @(bjp_i_info) begin\n        case (bjp_i_info)\n            E203_DECINFO_BJP_BEQ: begin\n                bjp_req_alu_cmp_eq <= 1'b1;\n                bjp_req_alu_cmp_ne <= 1'b0;\n                bjp_req_alu_cmp_lt <= 1'b0;\n                bjp_req_alu_cmp_gt <= 1'b0;\n                bjp_req_alu_cmp_ltu <= 1'b0;\n                bjp_req_alu_cmp_gtu <= 1'b0;\n                bjp_req_alu_add     <= 1'b0;\n            end\n            E203_DECINFO_BJP_BNE: begin\n                bjp_req_alu_cmp_eq <= 1'b0;\n                bjp_req_alu_cmp_ne <= 1'b1;\n                bjp_req_alu_cmp_lt <= 1'b0;\n                bjp_req_alu_cmp_gt <= 1'b0;\n                bjp_req_alu_cmp_ltu <= 1'b0;\n                bjp_req_alu_cmp_gtu <= 1'b0;\n                bjp_req_alu_add     <= 1'b0;\n            end\n            E203_DECINFO_BJP_BLT: begin\n                bjp_req_alu_cmp_eq <= 1'b0;\n                bjp_req_alu_cmp_ne <= 1'b0;\n                bjp_req_alu_cmp_lt <= 1'b1;\n                bjp_req_alu_cmp_gt <= 1'b0;\n                bjp_req_alu_cmp_ltu <= 1'b0;\n                bjp_req_alu_cmp_gtu <= 1'b0;\n                bjp_req_alu_add     <= 1'b0;\n            end\n            E203_DECINFO_BJP_BGT: begin\n                bjp_req_alu_cmp_eq <= 1'b0;\n                bjp_req_alu_cmp_ne <= 1'b0;\n                bjp_req_alu_cmp_lt <= 1'b0;\n                bjp_req_alu_cmp_gt <= 1'b1;\n                bjp_req_alu_cmp_ltu <= 1'b0;\n                bjp_req_alu_cmp_gtu <= 1'b0;\n                bjp_req_alu_add     <= 1'b0;\n            end\n            E203_DECINFO_BJP_BLTU: begin\n                bjp_req_alu_cmp_eq <= 1'b0;\n                bjp_req_alu_cmp_ne <= 1'b0;\n                bjp_req_alu_cmp_lt <= 1'b0;\n                bjp_req_alu_cmp_gt <= 1'b0;\n                bjp_req_alu_cmp_ltu <= 1'b1;\n                bjp_req_alu_cmp_gtu <= 1'b0;\n                bjp_req_alu_add     <= 1'b0;\n            end\n            E203_DECINFO_BJP_BGTU: begin\n                bjp_req_alu_cmp_eq <= 1'b0;\n                bjp_req_alu_cmp_ne <= 1'b0;\n                bjp_req_alu_cmp_lt <= 1'b0;\n                bjp_req_alu_cmp_gt <= 1'b0;\n                bjp_req_alu_cmp_ltu <= 1'b0;\n                bjp_req_alu_cmp_gtu <= 1'b1;\n                bjp_req_alu_add     <= 1'b0;\n            end\n            E203_DECINFO_BJP_JUMP: begin\n                bjp_req_alu_cmp_eq <= 1'b0;\n                bjp_req_alu_cmp_ne <= 1'b0;\n                bjp_req_alu_cmp_lt <= 1'b0;\n                bjp_req_alu_cmp_gt <= 1'b0;\n                bjp_req_alu_cmp_ltu <= 1'b0;\n                bjp_req_alu_cmp_gtu <= 1'b0;\n                bjp_req_alu_add     <= 1'b1;\n            end\n            default: begin\n                bjp_req_alu_cmp_eq <= 1'b0;\n                bjp_req_alu_cmp_ne <= 1'b0;\n                bjp_req_alu_cmp_lt <= 1'b0;\n                bjp_req_alu_cmp_gt <= 1'b0;\n                bjp_req_alu_cmp_ltu <= 1'b0;\n                bjp_req_alu_cmp_gtu <= 1'b0;\n                bjp_req_alu_add     <= 1'b0;\n            end\n        endcase\n    end\n\n    // Operand Selection\n    always @(bjp_i_info, bjp_i_pc, bjp_i_rs1, bjp_i_rs2, bjp_i_imm) begin\n        case (bjp_i_info)\n            E203_DECINFO_BJP_JUMP: begin\n                bjp_req_alu_op1 <= bjp_i_pc;\n                bjp_req_alu_op2 <= bjp_i_imm;\n            end\n            default: begin\n                bjp_req_alu_op1 <= bjp_i_rs1;\n                bjp_req_alu_op2 <= bjp_i_rs2;\n            end\n        endcase\n    end\n\n    // Retrieving Results from the ALU\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n\n    // Communication with Commit Module\n    always @(bjp_i_info, bjp_req_alu_cmp_res) begin\n        case (bjp_i_info)\n            E203_DECINFO_BJP_BEQ: begin\n                bjp_o_cmt_bjp  <= bjp_req_alu_cmp_res;\n                bjp_o_cmt_mret <= 1'b0;\n                bjp_o_cmt_dret <= 1'b0;\n                bjp_o_cmt_fencei <= 1'b0;\n                bjp_o_cmt_prdt  <= 1'b1;\n                bjp_o_cmt_rslv  <= bjp_req_alu_cmp_res;\n            end\n            E203_DECINFO_BJP_BNE: begin\n                bjp_o_cmt_bjp  <= bjp_req_alu_cmp_res;\n                bjp_o_cmt_mret <= 1'b0;\n                bjp_o_cmt_dret <= 1'b0;\n                bjp_o_cmt_fencei <= 1'b0;\n                bjp_o_cmt_prdt  <= 1'b0;\n                bjp_o_cmt_rslv  <= ~bjp_req_alu_cmp_res;\n            end\n            E203_DECINFO_BJP_BLT: begin\n                bjp_o_cmt_bjp  <= bjp_req_alu_cmp_res;\n                bjp_o_cmt_mret <= 1'b0;\n                bjp_o_cmt_dret <= 1'b0;\n                bjp_o_cmt_fencei <= 1'b0;\n                bjp_o_cmt_prdt  <= 1'b1;\n                bjp_o_cmt_rslv  <= bjp_req_alu_cmp_res;\n            end\n            E203_DECINFO_BJP_BGT: begin\n                bjp_o_cmt_bjp  <= bjp_req_alu_cmp_res;\n                bjp_o_cmt_mret <= 1'b0;\n                bjp_o_cmt_dret <= 1'b0;\n                bjp_o_cmt_fencei <= 1'b0;\n                bjp_o_cmt_prdt  <= 1'b0;\n                bjp_o_cmt_rslv  <= ~bjp_req_alu_cmp_res;\n            end\n            E203_DECINFO_BJP_BLTU: begin\n                bjp_o_cmt_bjp  <= bjp_req_alu_cmp_res;\n                bjp_o_cmt_mret <= 1'b0;\n                bjp_o_cmt_dret <= 1'b0;\n                bjp_o_cmt_fencei <= 1'b0;\n                bjp_o_cmt_prdt  <= 1'b1;\n                bjp_o_cmt_rslv  <= bjp_req_alu_cmp_res;\n            end\n            E203_DECINFO_BJP_BGTU: begin\n                bjp_o_cmt_bjp  <= bjp_req_alu_cmp_res;\n                bjp_o_cmt_mret <= 1'b0;\n                bjp_o_cmt_dret <= 1'b0;\n                bjp_o_cmt_fencei <= 1'b0;\n                bjp_o_cmt_prdt  <= 1'b0;\n                bjp_o_cmt_rslv  <= ~bjp_req_alu_cmp_res;\n            end\n            E203_DECINFO_BJP_JUMP: begin\n                bjp_o_cmt_bjp  <= 1'b1;\n                bjp_o_cmt_mret <= 1'b0;\n                bjp_o_cmt_dret <= 1'b0;\n                bjp_o_cmt_fencei <= 1'b0;\n                bjp_o_cmt_prdt  <= 1'b1;\n                bjp_o_cmt_rslv  <= 1'b1;\n            end\n            default: begin\n                bjp_o_cmt_bjp  <= 1'b0;\n                bjp_o_cmt_mret <= 1'b0;\n                bjp_o_cmt_dret <= 1'b0;\n                bjp_o_cmt_fencei <= 1'b0;\n                bjp_o_cmt_prdt  <= 1'b0;\n                bjp_o_cmt_rslv  <= 1'b0;\n            end\n        endcase\n    end\n\n    // Write Back Err Generation\n    assign bjp_o_wbck_err = 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 3, "code": "module e203_biu #(\n    parameter E203_ADDR_SIZE = 32,\n    parameter E203_XLEN      = 32,\n    parameter E203_BIU_OUTS_NUM = 1,\n    parameter E203_BIU_OUTS_CNT_W = 1,\n    parameter E203_BIU_CMD_DP     = 1,\n    parameter E203_BIU_RSP_DP     = 1,\n    parameter E203_BIU_CMD_CUT_READY = 1,\n    parameter E203_BIU_RSP_CUT_READY = 1\n) (\n    input  logic                   clk,\n    input  logic                   rst_n,\n\n    // Control Signals\n    output logic                   biu_active,\n\n    // ICB Interface for LSU\n    input  logic                   lsu_icb_cmd_valid,\n    output logic                   lsu_icb_cmd_ready,\n    input  logic                   lsu_icb_cmd_read,\n    input  logic [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input  logic [E203_XLEN-1:0]   lsu_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] lsu_icb_cmd_wmask,\n    output logic                   lsu_icb_rsp_valid,\n    input  logic                   lsu_icb_rsp_ready,\n    output logic                   lsu_icb_rsp_err,\n    output logic                   lsu_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0]   lsu_icb_rsp_rdata,\n\n    // ICB Interface for IFU\n    input  logic                   ifu_icb_cmd_valid,\n    output logic                   ifu_icb_cmd_ready,\n    input  logic                   ifu_icb_cmd_read,\n    input  logic [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input  logic [E203_XLEN-1:0]   ifu_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] ifu_icb_cmd_wmask,\n    output logic                   ifu_icb_rsp_valid,\n    input  logic                   ifu_icb_rsp_ready,\n    output logic                   ifu_icb_rsp_err,\n    output logic                   ifu_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0]   ifu_icb_rsp_rdata,\n\n    // ICB Interface for PPI\n    input  logic                   ppi_icb_cmd_valid,\n    output logic                   ppi_icb_cmd_ready,\n    input  logic                   ppi_icb_cmd_read,\n    input  logic [E203_ADDR_SIZE-1:0] ppi_icb_cmd_addr,\n    input  logic [E203_XLEN-1:0]   ppi_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] ppi_icb_cmd_wmask,\n    output logic                   ppi_icb_rsp_valid,\n    input  logic                   ppi_icb_rsp_ready,\n    output logic                   ppi_icb_rsp_err,\n    output logic                   ppi_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0]   ppi_icb_rsp_rdata,\n\n    // ICB Interface for CLINT\n    input  logic                   clint_icb_cmd_valid,\n    output logic                   clint_icb_cmd_ready,\n    input  logic                   clint_icb_cmd_read,\n    input  logic [E203_ADDR_SIZE-1:0] clint_icb_cmd_addr,\n    input  logic [E203_XLEN-1:0]   clint_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] clint_icb_cmd_wmask,\n    output logic                   clint_icb_rsp_valid,\n    input  logic                   clint_icb_rsp_ready,\n    output logic                   clint_icb_rsp_err,\n    output logic                   clint_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0]   clint_icb_rsp_rdata,\n\n    // ICB Interface for PLIC\n    input  logic                   plic_icb_cmd_valid,\n    output logic                   plic_icb_cmd_ready,\n    input  logic                   plic_icb_cmd_read,\n    input  logic [E203_ADDR_SIZE-1:0] plic_icb_cmd_addr,\n    input  logic [E203_XLEN-1:0]   plic_icb_cmd_wdata,\n    input  logic [E203_XLEN/8-1:0] plic_icb_cmd_wmask,\n    output logic                   plic_icb_rsp_valid,\n    input  logic                   plic_icb_rsp_ready,\n    output logic                   plic_icb_rsp_err,\n    output logic                   plic_icb_rsp_excl_ok,\n    output logic [E203_XLEN-1:0]   plic_icb_rsp_rdata\n);\n\n// ICB Arbiter Instantiation\nsirv_gnrl_icb_arbt #(\n    .AW(E203_ADDR_SIZE),\n    .DW(E203_XLEN),\n    .ARBT_NUM(2),\n    .ARBT_PTR_W(1),\n    .USR_W(1),\n    .ARBT_SCHEME(0),\n    .ALLOW_0CYCL_RSP(0),\n    .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n    .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n) icb_arbiter (\n    .o_icb_cmd_valid(arbiter_icb_cmd_valid),\n    .o_icb_cmd_ready(arbiter_icb_cmd_ready),\n    .o_icb_cmd_read(arbiter_icb_cmd_read),\n    .o_icb_cmd_addr(arbiter_icb_cmd_addr),\n    .o_icb_cmd_wdata(arbiter_icb_cmd_wdata),\n    .o_icb_cmd_wmask(arbiter_icb_cmd_wmask),\n    .o_icb_rsp_valid(arbiter_icb_rsp_valid),\n    .o_icb_rsp_ready(arbiter_icb_rsp_ready),\n    .i_bus_icb_cmd_valid({ifu_icb_cmd_valid, lsu_icb_cmd_valid}),\n    .i_bus_icb_cmd_ready({ifu_icb_cmd_ready, lsu_icb_cmd_ready}),\n    .i_bus_icb_cmd_addr({ifu_icb_cmd_addr, lsu_icb_cmd_addr}),\n    .i_bus_icb_cmd_read({ifu_icb_cmd_read, lsu_icb_cmd_read}),\n    .i_bus_icb_cmd_wdata({ifu_icb_cmd_wdata, lsu_icb_cmd_wdata}),\n    .i_bus_icb_cmd_wmask({ifu_icb_cmd_wmask, lsu_icb_cmd_wmask}),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// ICB Buffer Instantiation\nsirv_gnrl_icb_buffer #(\n    .AW(E203_ADDR_SIZE),\n    .DW(E203_XLEN),\n    .USR_W(1),\n    .OUTS_CNT_W(E203_BIU_OUTS_CNT_W),\n    .CMD_DP(E203_BIU_CMD_DP),\n    .RSP_DP(E203_BIU_RSP_DP),\n    .CMD_CUT_READY(E203_BIU_CMD_CUT_READY),\n    .RSP_CUT_READY(E203_BIU_RSP_CUT_READY)\n) icb_buffer (\n    .icb_buffer_active(biu_active),\n    .i_icb_cmd_valid(arbiter_icb_cmd_valid),\n    .i_icb_cmd_ready(arbiter_icb_cmd_ready),\n    .i_icb_cmd_read(arbiter_icb_cmd_read),\n    .i_icb_cmd_addr(arbiter_icb_cmd_addr),\n    .i_icb_cmd_wdata(arbiter_icb_cmd_wdata),\n    .i_icb_cmd_wmask(arbiter_icb_cmd_wmask),\n    .i_icb_rsp_valid(arbiter_icb_rsp_valid),\n    .i_icb_rsp_ready(arbiter_icb_rsp_ready),\n    .o_icb_cmd_valid(buffer_icb_cmd_valid),\n    .o_icb_cmd_ready(buffer_icb_cmd_ready),\n    .o_icb_rsp_valid(buffer_icb_rsp_valid),\n    .o_icb_rsp_ready(buffer_icb_rsp_ready),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// ICB Splitter Instantiation\nsirv_gnrl_icb_splt #(\n    .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY),\n    .SPLT_PTR_W(4),\n    .USR_W(1),\n    .AW(E203_ADDR_SIZE),\n    .DW(E203_XLEN),\n    .ALLOW_DIFF(0),\n    .ALLOW_0CYCL_RSP(1),\n    .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n    .SPLT_NUM(4),\n    .SPLT_PTR_1HOT(1)\n) icb_splitter (\n    .i_icb_splt_indic({ppi_region_indic, clint_region_indic, plic_region_indic, fio_region_indic}),\n    .i_icb_cmd_valid(buffer_icb_cmd_valid),\n    .i_icb_cmd_ready(buffer_icb_cmd_ready),\n    .i_icb_cmd_read(buffer_icb_cmd_read),\n    .i_icb_cmd_addr(buffer_icb_cmd_addr),\n    .i_icb_cmd_wdata(buffer_icb_cmd_wdata),\n    .i_icb_cmd_wmask(buffer_icb_cmd_wmask),\n    .i_icb_rsp_valid(buffer_icb_rsp_valid),\n    .i_icb_rsp_ready(buffer_icb_rsp_ready),\n    .o_bus_icb_cmd_valid({ppi_icb_cmd_valid, clint_icb_cmd_valid, plic_icb_cmd_valid, fio_icb_cmd_valid}),\n    .o_bus_icb_cmd_ready({ppi_icb_cmd_ready, clint_icb_cmd_ready, plic_icb_cmd_ready, fio_icb_cmd_ready}),\n    .o_bus_icb_rsp_valid({ppi_icb_rsp_valid, clint_icb_rsp_valid, plic_icb_rsp_valid, fio_icb_rsp_valid}),\n    .o_bus_icb_rsp_ready({ppi_icb_rsp_ready, clint_icb_rsp_ready, plic_icb_rsp_ready, fio_icb_rsp_ready}),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nassign ppi_region_indic = ppi_icb_cmd_addr[E203_ADDR_SIZE-1:E203_ADDR_SIZE-16] == E203_PPI_BASE_REGION;\nassign clint_region_indic = clint_icb_cmd_addr[E203_ADDR_SIZE-1:E203_ADDR_SIZE-16] == E203_CLINT_BASE_REGION;\nassign plic_region_indic = plic_icb_cmd_addr[E203_ADDR_SIZE-1:E203_ADDR_SIZE-8] == E203_PLIC_BASE_REGION;\nassign fio_region_indic = fio_icb_cmd_addr[E203_ADDR_SIZE-1:E203_ADDR_SIZE-16] == E203_FIO_BASE_REGION;\n\nassign ifu_icb_cmd_ready = ifu_icb_cmd_valid ? 1'b0 : 1'b1;\nassign lsu_icb_cmd_ready = lsu_icb_cmd_valid ? 1'b0 : 1'b1;\n\nassign ifu_icb_rsp_valid = 1'b0;\nassign ifu_icb_rsp_err = 1'b0;\nassign ifu_icb_rsp_excl_ok = 1'b0;\nassign ifu_icb_rsp_rdata = '0;\n\nassign lsu_icb_rsp_valid = 1'b0;\nassign lsu_icb_rsp_err = 1'b0;\nassign lsu_icb_rsp_excl_ok = 1'b0;\nassign lsu_icb_rsp_rdata = '0;\n\nassign ppi_icb_cmd_ready = ppi_icb_cmd_valid ? 1'b0 : 1'b1;\nassign clint_icb_cmd_ready = clint_icb_cmd_valid ? 1'b0 : 1'b1;\nassign plic_icb_cmd_ready = plic_icb_cmd_valid ? 1'b0 : 1'b1;\nassign fio_icb_cmd_ready = fio_icb_cmd_valid ? 1'b0 : 1'b1;\n\nassign ppi_icb_rsp_valid = 1'b0;\nassign ppi_icb_rsp_err = 1'b0;\nassign ppi_icb_rsp_excl_ok = 1'b0;\nassign ppi_icb_rsp_rdata = '0;\n\nassign clint_icb_rsp_valid = 1'b0;\nassign clint_icb_rsp_err = 1'b0;\nassign clint_icb_rsp_excl_ok = 1'b0;\nassign clint_icb_rsp_rdata = '0;\n\nassign plic_icb_rsp_valid = 1'b0;\nassign plic_icb_rsp_err = 1'b0;\nassign plic_icb_rsp_excl_ok = 1'b0;\nassign plic_icb_rsp_rdata = '0;\n\nassign fio_icb_rsp_valid = 1'b0;\nassign fio_icb_rsp_err = 1'b0;\nassign fio_icb_rsp_excl_ok = 1'b0;\nassign fio_icb_rsp_rdata = '0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 5, "code": "module itcm_controller(\n    input  logic                   clk,\n    input  logic                   rst_n,\n    input  logic                   test_mode,\n    output logic                   itcm_active,\n    input  logic                   tcm_cgstop,\n\n    // IFU interface\n    input  logic                   ifu2itcm_icb_cmd_valid,\n    output logic                   ifu2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input  logic                   ifu2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output logic                   ifu2itcm_icb_rsp_valid,\n    input  logic                   ifu2itcm_icb_rsp_ready,\n    output logic                   ifu2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU interface\n    input  logic                   lsu2itcm_icb_cmd_valid,\n    output logic                   lsu2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input  logic                   lsu2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output logic                   lsu2itcm_icb_rsp_valid,\n    input  logic                   lsu2itcm_icb_rsp_ready,\n    output logic                   lsu2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // External interface (optional)\n    input  logic                   ext2itcm_icb_cmd_valid,\n    output logic                   ext2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input  logic                   ext2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ext2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_WMSK_WIDTH-1:0] ext2itcm_icb_cmd_wmask,\n    output logic                   ext2itcm_icb_rsp_valid,\n    input  logic                   ext2itcm_icb_rsp_ready,\n    output logic                   ext2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] ext2itcm_icb_rsp_rdata,\n\n    // RAM interface\n    output logic                   itcm_ram_cs,\n    output logic                   itcm_ram_we,\n    output logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    output logic [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    output logic [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    input  logic [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    output logic                   clk_itcm_ram\n);\n\n// Data width conversion module instances\nsirv_gnrl_icb_n2w #(\n    .AW(E203_ITCM_ADDR_WIDTH),\n    .USR_W(1),\n    .FIFO_OUTS_NUM(E203_ITCM_OUTS_NUM),\n    .FIFO_CUT_READY(0),\n    .X_W(32),\n    .Y_W(E203_ITCM_DATA_WIDTH)\n) u_itcm_icb_lsu2itcm_n2w (\n    .clk(clk),\n    .rst_n(rst_n),\n    .i_icb_cmd_valid(lsu2itcm_icb_cmd_valid),\n    .i_icb_cmd_ready(lsu2itcm_icb_cmd_ready),\n    .i_icb_cmd_read(lsu2itcm_icb_cmd_read),\n    .i_icb_cmd_addr(lsu2itcm_icb_cmd_addr),\n    .i_icb_cmd_wdata(lsu2itcm_icb_cmd_wdata),\n    .i_icb_cmd_wmask(lsu2itcm_icb_cmd_wmask),\n    .i_icb_cmd_lock(1'b0),\n    .i_icb_cmd_excl(1'b0),\n    .i_icb_cmd_size(2'b00),\n    .i_icb_cmd_burst(2'b00),\n    .i_icb_cmd_beat(2'b00),\n    .i_icb_cmd_usr(1'b0),\n    .i_icb_rsp_valid(lsu2itcm_icb_rsp_valid),\n    .i_icb_rsp_ready(lsu2itcm_icb_rsp_ready),\n    .i_icb_rsp_err(lsu2itcm_icb_rsp_err),\n    .i_icb_rsp_excl_ok(1'b0),\n    .i_icb_rsp_rdata(lsu2itcm_icb_rsp_rdata),\n    .i_icb_rsp_usr(1'b0),\n    .o_icb_cmd_valid(),\n    .0:o_icb_cmd_ready(),\n    .o_icb_cmd_read(),\n    .o_icb_cmd_addr(),\n    .o_icb_cmd_wdata(),\n    .o_icb_cmd_wmask(),\n    .o_icb_cmd_lock(),\n    .o_icb_cmd_excl(),\n    .o_icb_cmd_size(),\n    .o_icb_cmd_burst(),\n    .o_icb_cmd_beat(),\n    .o_icb_cmd_usr(),\n    .o_icb_rsp_valid(),\n    .o_icb_rsp_ready(),\n    .o_icb_rsp_err(),\n    .o_icb_rsp_excl_ok(),\n    .o_icb_rsp_rdata(),\n    .o_icb_rsp_usr()\n);\n\n// Bus arbiter module instance\nsirv_gnrl_icb_arbt #(\n    .AW(E203_ITCM_ADDR_WIDTH),\n    .DW(E203_ITCM_DATA_WIDTH),\n    .USR_W(1),\n    .ARBT_SCHEME(0),\n    .FIFO_OUTS_NUM(E203_ITCM_OUTS_NUM),\n    .FIFO_CUT_READY(0),\n    .ARBT_NUM(3),\n    .ALLOW_0CYCL_RSP(1),\n    .ARBT_PTR_W(2)\n) u_itcm_arb (\n    .clk(clk),\n    .rst_n(rst_n),\n    .i_bus_icb_cmd_valid({ifu2itcm_icb_cmd_valid, lsu2itcm_icb_cmd_valid, ext2itcm_icb_cmd_valid}),\n    .i_bus_icb_cmd_ready({ifu2itcm_icb_cmd_ready, lsu2itcm_icb_cmd_ready, ext2itcm_icb_cmd_ready}),\n    .i_bus_icb_cmd_read({ifu2itcm_icb_cmd_read, lsu2itcm_icb_cmd_read, ext2itcm_icb_cmd_read}),\n    .i_bus_icb_cmd_addr({ifu2itcm_icb_cmd_addr, lsu2itcm_icb_cmd_addr, ext2itcm_icb_cmd_addr}),\n    .i_bus_icb_cmd_wdata({ifu2itcm_icb_cmd_wdata, lsu2itcm_icb_cmd_wdata, ext2itcm_icb_cmd_wdata}),\n    .i_bus_icb_cmd_wmask({ifu2itcm_icb_cmd_wmask, lsu2itcm_icb_cmd_wmask, ext2itcm_icb_cmd_wmask}),\n    .i_bus_icb_cmd_burst({2'b00, 2'b00, 2'b00}),\n    .i_bus_icb_cmd_beat({2'b00, 2'b00, 2'b00}),\n    .i_bus_icb_cmd_lock({1'b0, 1'b0, 1'b0}),\n    .i_bus_icb_cmd_excl({1'b0, 1'b0, 1'b0}),\n    .i_bus_icb_cmd_size({2'b00, 2'b00, 2'b00}),\n    .i_bus_icb_cmd_usr({1'b0, 1'b0, 1'b0}),\n    .i_bus_icb_rsp_valid({ifu2itcm_icb_rsp_valid, lsu2itcm_icb_rsp_valid, ext2itcm_icb_rsp_valid}),\n    .i_bus_icb_rsp_ready({ifu2itcm_icb_rsp_ready, lsu2itcm_icb_rsp_ready, ext2itcm_icb_rsp_ready}),\n    .i_bus_icb_rsp_err({ifu2itcm_icb_rsp_err, lsu2itcm_icb_rsp_err, ext2itcm_icb_rsp_err}),\n    .i_bus_icb_rsp_excl_ok({1'b0, 1'b0, 1'b0}),\n    .i_bus_icb_rsp_rdata({ifu2itcm_icb_rsp_rdata, lsu2itcm_icb_rsp_rdata, ext2itcm_icb_rsp_rdata}),\n    .i_bus_icb_rsp_usr({1'b0, 1'b0, 1'b0}),\n    .o_icb_cmd_valid(o_icb_cmd_valid),\n    .o_icb_cmd_ready(o_icb_cmd_ready),\n    .o_icb_cmd_read(o_icb_cmd_read),\n    .o_icb_cmd_addr(o_icb_cmd_addr),\n    .o_icb_cmd_wdata(o_icb_cmd_wdata),\n    .o_icb_cmd_wmask(o_icb_cmd_wmask),\n    .o_icb_cmd_burst(o_icb_cmd_burst),\n    .o_icb_cmd_beat(o_icb_cmd_beat),\n    .o_icb_cmd_lock(o_icb_cmd_lock),\n    .o_icb_cmd_excl(o_icb_cmd_excl),\n    .o_icb_cmd_size(o_icb_cmd_size),\n    .o_icb_cmd_usr(o_icb_cmd_usr),\n    .o_icb_rsp_valid(o_icb_rsp_valid),\n    .o_icb_rsp_ready(o_icb_rsp_ready),\n    .o_icb_rsp_err(o_icb_rsp_err),\n    .o_icb_rsp_excl_ok(o_icb_rsp_excl_ok),\n    .o_icb_rsp_rdata(o_icb_rsp_rdata),\n    .o_icb_rsp_usr(o_icb_rsp_usr)\n);\n\n// SRAM controller module instance\nsirv_sram_icb_ctrl #(\n    .DW(E203_ITCM_DATA_WIDTH),\n    .MW(E203_ITCM_WMSK_WIDTH),\n    .AW(E203_ITCM_RAM_AW),\n    .AW_LSB(3),\n    .USR_W(1)\n) u_itcm_ram_ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .i_icb_cmd_valid(o_icb_cmd_valid),\n    .i_icb_cmd_ready(o_icb_cmd_ready),\n    .i_icb_cmd_read(o_icb_cmd_read),\n    .i_icb_cmd_addr(o_icb_cmd_addr),\n    .i_icb_cmd_wdata(o_icb_cmd_wdata),\n    .i_icb_cmd_wmask(o_icb_cmd_wmask),\n    .i_icb_cmd_usr(o_icb_cmd_usr),\n    .i_icb_rsp_valid(o_icb_rsp_valid),\n    .i_icb_rsp_ready(o_icb_rsp_ready),\n    .i_icb_rsp_rdata(o_icb_rsp_rdata),\n    .i_icb_rsp_usr(o_icb_rsp_usr),\n    .ram_cs(itcm_ram_cs),\n    .ram_we(itcm_ram_we),\n    .ram_addr(itcm_ram_addr),\n    .ram_wem(itcm_ram_wem),\n    .ram_din(itcm_ram_din),\n    .ram_dout(itcm_ram_dout),\n    .clk_ram(clk_itcm_ram),\n    .tcm_cgstop(tcm_cgstop),\n    .test_mode(test_mode)\n);\n\n// Assignments\nassign itcm_active = 1'b1; // ITCM is always active in this implementation\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 6, "code": "module itcm_controller (\n    input  logic                   clk,\n    input  logic                   rst_n,\n    input  logic                   test_mode,\n    output logic                   itcm_active,\n    input  logic                   tcm_cgstop,\n\n    // IFU interface\n    input  logic                   ifu2itcm_icb_cmd_valid,\n    output logic                   ifu2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input  logic                   ifu2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_WMSK_WIDTH-1:0] ifu2itcm_icb_cmd_wmask,\n    output logic                   ifu2itcm_icb_rsp_valid,\n    input  logic                   ifu2itcm_icb_rsp_ready,\n    output logic                   ifu2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // LSU interface\n    input  logic                   lsu2itcm_icb_cmd_valid,\n    output logic                   lsu2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] lsu2itcm_icb_cmd_addr,\n    input  logic                   lsu2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] lsu2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_WMSK_WIDTH-1:0] lsu2itcm_icb_cmd_wmask,\n    output logic                   lsu2itcm_icb_rsp_valid,\n    input  logic                   lsu2itcm_icb_rsp_ready,\n    output logic                   lsu2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] lsu2itcm_icb_rsp_rdata,\n\n    // External interface (if enabled)\n    input  logic                   ext2itcm_icb_cmd_valid,\n    output logic                   ext2itcm_icb_cmd_ready,\n    input  logic [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input  logic                   ext2itcm_icb_cmd_read,\n    input  logic [E203_ITCM_DATA_WIDTH-1:0] ext2itcm_icb_cmd_wdata,\n    input  logic [E203_ITCM_WMSK_WIDTH-1:0] ext2itcm_icb_cmd_wmask,\n    output logic                   ext2itcm_icb_rsp_valid,\n    input  logic                   ext2itcm_icb_rsp_ready,\n    output logic                   ext2itcm_icb_rsp_err,\n    output logic [E203_ITCM_DATA_WIDTH-1:0] ext2itcm_icb_rsp_rdata,\n\n    // RAM interface\n    output logic                   itcm_ram_cs,\n    output logic                   itcm_ram_we,\n    output logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    output logic [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    output logic [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    input  logic [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    output logic                   clk_itcm_ram\n);\n\n// Internal signals and variables\nlogic [E203_ITCM_DATA_WIDTH-1:0] ram_data;\nlogic [E203_ITCM_WMSK_WIDTH-1:0] ram_wmask;\n\n// Data width conversion for LSU and external interfaces (if needed)\nsirv_gnrl_icb_n2w #(\n    .AW(E203_ITCM_ADDR_WIDTH),\n    .USR_W(1),\n    .FIFO_OUTS_NUM(E203_ITCM_OUTS_NUM),\n    .FIFO_CUT_READY(0),\n    .X_W(32),\n    .Y_W(E203_ITCM_DATA_WIDTH)\n) u_itcm_icb_lsu2itcm_n2w (\n    .clk(clk),\n    .rst_n(rst_n),\n    .i_icb_cmd_valid(lsu2itcm_icb_cmd_valid),\n    .i_icb_cmd_ready(lsu2itcm_icb_cmd_ready),\n    .i_icb_cmd_read(lsu2itcm_icb_cmd_read),\n    .i_icb_cmd_addr(lsu2itcm_icb_cmd_addr),\n    .i_icb_cmd_wdata(lsu2itcm_icb_cmd_wdata),\n    .i_icb_cmd_wmask(lsu2itcm_icb_cmd_wmask),\n    .i_icb_cmd_lock(1'b0),\n    .i_icb_cmd_excl(1'b0),\n    .i_icb_cmd_size(2'b10),\n    .i_icb_cmd_burst(2'b00),\n    .i_icb_cmd_beat(2'b01),\n    .i_icb_cmd_usr(1'b0),\n    .i_icb_rsp_valid(lsu2itcm_icb_rsp_valid),\n    .i_icb_rsp_ready(lsu2itcm_icb_rsp_ready),\n    .i_icb_rsp_err(lsu2itcm_icb_rsp_err),\n    .i_icb_rsp_excl_ok(1'b0),\n    .i_icb_rsp_rdata(lsu2itcm_icb_rsp_rdata),\n    .i_icb_rsp_usr(1'b0),\n    .o_icb_cmd_valid(),\n    .o_icb_cmd_ready(),\n    .o_icb_cmd_read(),\n    .o_icb_cmd_addr(),\n    .o_icb_cmd_wdata(),\n    .o_icb_cmd_wmask(),\n    .o_icb_cmd_lock(),\n    .o_icb_cmd_excl(),\n    .o_icb_cmd_size(),\n    .o_icb_cmd_burst(),\n    .o_icb_cmd_beat(),\n    .o_icb_cmd_usr(),\n    .o_icb_rsp_valid(),\n    .o_icb_rsp_ready(),\n    .o_icb_rsp_err(),\n    .o_icb_rsp_excl_ok(),\n    .o_icb_rsp_rdata(),\n    .o_icb_rsp_usr()\n);\n\n// Bus arbiter for multiple interfaces\nsirv_gnrl_icb_arbt #(\n    .AW(E203_ITCM_ADDR_WIDTH),\n    .DW(E203_ITCM_DATA_WIDTH),\n    .USR_W(1),\n    .ARBT_SCHEME(0),\n    .FIFO_OUTS_NUM(E203_ITCM_OUTS_NUM),\n    .FIFO_CUT_READY(0),\n    .ARBT_NUM(3), // IFU, LSU, and external interface\n    .ALLOW_0CYCL_RSP(1),\n    .ARBT_PTR_W(2)\n) u_itcm_arb (\n    .clk(clk),\n    .rst_n(rst_n),\n    .o_icb_cmd_valid(),\n    .o_icb_cmd_ready(),\n    .o_icb_cmd_read(),\n    .o_icb_cmd_addr(),\n    .o_icb_cmd_wdata(),\n    .o_icb_cmd_wmask(),\n    .o_ic0:b_cmd_burst(),\n    .o_icb_cmd_beat(),\n    .o_icb_cmd_lock(),\n    .o_icb_cmd_excl(),\n    .o_icb_cmd_size(),\n    .o_icb_cmd_usr(),\n    .o_icb_rsp_valid(),\n    .o_icb_rsp_ready(),\n    .o_icb_rsp_err(),\n    .o_icb_rsp_excl_ok(),\n    .o_icb_rsp_rdata(),\n    .o_icb_rsp_usr(),\n    .i_bus_icb_cmd_ready({ifu2itcm_icb_cmd_ready, lsu2itcm_icb_cmd_ready, ext2itcm_icb_cmd_ready}),\n    .i_bus_icb_cmd_valid({ifu2itcm_icb_cmd_valid, lsu2itcm_icb_cmd_valid, ext2itcm_icb_cmd_valid}),\n    .i_bus_icb_cmd_read({ifu2itcm_icb_cmd_read, lsu2itcm_icb_cmd_read, ext2itcm_icb_cmd_read}),\n    .i_bus_icb_cmd_addr({ifu2itcm_icb_cmd_addr, lsu2itcm_icb_cmd_addr, ext2itcm_icb_cmd_addr}),\n    .i_bus_icb_cmd_wdata({ifu2itcm_icb_cmd_wdata, lsu2itcm_icb_cmd_wdata, ext2itcm_icb_cmd_wdata}),\n    .i_bus_icb_cmd_wmask({ifu2itcm_icb_cmd_wmask, lsu2itcm_icb_cmd_wmask, ext2itcm_icb_cmd_wmask}),\n    .i_bus_icb_cmd_burst({2'b00, 2'b00, 2'b00}),\n    .i_bus_icb_cmd_beat({2'b01, 2'b01, 2'b01}),\n    .i_bus_icb_cmd_lock({1'b0, 1'b0, 1'b0}),\n    .i_bus_icb_cmd_excl({1'b0, 1'b0, 1'b0}),\n    .i_bus_icb_cmd_size({2'b10, 2'b10, 2'b10}),\n    .i_bus_icb_cmd_usr({1'b0, 1'b0, 1'b0}),\n    .i_bus_icb_rsp_valid({ifu2itcm_icb_rsp_valid, lsu2itcm_icb_rsp_valid, ext2itcm_icb_rsp_valid}),\n    .i_bus_icb_rsp_ready({ifu2itcm_icb_rsp_ready, lsu2itcm_icb_rsp_ready, ext2itcm_icb_rsp_ready}),\n    .i_bus_icb_rsp_err({ifu2itcm_icb_rsp_err, lsu2itcm_icb_rsp_err, ext2itcm_icb_rsp_err}),\n    .i_bus_icb_rsp_excl_ok({1'b0, 1'b0, 1'b0}),\n    .i_bus_icb_rsp_rdata({ifu2itcm_icb_rsp_rdata, lsu2itcm_icb_rsp_rdata, ext2itcm_icb_rsp_rdata}),\n    .i_bus_icb_rsp_usr({1'b0, 1'b0, 1'b0})\n);\n\n// SRAM controller for ITCM access\nsirv_sram_icb_ctrl #(\n    .DW(E203_ITCM_DATA_WIDTH),\n    .MW(E203_ITCM_WMSK_WIDTH),\n    .AW(E203_ITCM_RAM_AW),\n    .AW_LSB(3),\n    .USR_W(1)\n) u_itcm_sram_ctrl (\n    .clk(clk),\n    .rst_n(rst_n),\n    .i_icb_cmd_valid(u_itcm_arb.o_icb_cmd_valid),\n    .i_icb_cmd_ready(u_itcm_arb.o_icb_cmd_ready),\n    .i_icb_cmd_read(u_itcm_arb.o_icb_cmd_read),\n    .i_icb_cmd_addr(u_itcm_arb.o_icb_cmd_addr),\n    .i_icb_cmd_wdata(u_itcm_arb.o_icb_cmd_wdata),\n    .i_icb_cmd_wmask(u_itcm_arb.o_icb_cmd_wmask),\n    .i_icb_cmd_usr(u_itcm_arb.o_icb_cmd_usr),\n    .i_icb_rsp_valid(u_itcm_arb.o_icb_rsp_valid),\n    .i_icb_rsp_ready(u_itcm_arb.o_icb_rsp_ready),\n    .i_icb_rsp_rdata(u_itcm_arb.o_icb_rsp_rdata),\n    .i_icb_rsp_usr(u_itcm_arb.o_icb_rsp_usr),\n    .ram_cs(itcm_ram_cs),\n    .ram_we(itcm_ram_we),\n    .ram_addr(itcm_ram_addr),\n    .ram_wem(itcm_ram_wem),\n    .ram_din(itcm_ram_din),\n    .ram_dout(itcm_ram_dout),\n    .clk_ram(clk_itcm_ram),\n    .sram_ctrl_active(itcm_active),\n    .tcm_cgstop(tcm_cgstop),\n    .test_mode(test_mode)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 3, "code": "```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 8, "code": "```u_regfile(\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output logic [E203_XLEN-1:0] read_src1_dat,\n    output logic [E203_XLEN-1:0] read_src2_dat,\n    input  logic                     wbck_dest_wen,\n    input  logic [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input  logic [E203_XLEN-1:0] wbck_dest_dat,\n    output logic [E203_XLEN-1:0] x1_r,\n    input  logic                     test_mode,\n    input  logic                     clk,\n    input  logic                     rst_n\n);\n\n// Define the register file\nlogic [E203_XLEN-1:0] rf [E203_RFREG_NUM-1:0];\n\n// Initialize register 0 to 0\nassign rf[0] = '0;\n\n// Read operations\nalways_comb begin\n    read_src1_dat = rf[read_src1_idx];\n    read_src2_dat = rf[read_src2_idx];\nend\n\n// Write operation\nalways_ff @(posedge clk) begin\n    if (wbck_dest_wen) begin\n        if (wbck_dest_idx != 0) begin\n            rf[wbck_dest_idx] <= wbck_dest_dat;\n        end\n    end\nend\n\n// Output for general-purpose register 1\nassign x1_r = rf[1];\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 2, "code": "```ver Interface\n    input  logic                   clk,\n    input  logic                   rst_n,\n\n    // Fetch Interface\n    output logic                   ifu_req_valid,\n    input  logic                   ifu_req_ready,\n    output logic [E203_PC_SIZE-1:0] ifu_req_pc,\n    output logic                   ifu_req_seq,\n    output logic                   ifu_req_seq_rv32,\n    output logic [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input  logic                   ifu_rsp_valid,\n    output logic                   ifu_rsp_ready,\n    input  logic                   ifu_rsp_err,\n    input  logic [E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n\n    // Pipeline Control Interface\n    input  logic                   pipe_flush_req,\n    output logic                   pipe_flush_ack,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n    input  logic [E203_PC_SIZE-1:0] pipe_flush_pc,\n\n    // Execution Unit Interface\n    output logic [E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output logic [E203_PC_SIZE-1:0] ifu_o_pc,\n    output logic                   ifu_o_pc_vld,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output logic                   ifu_o_prdt_taken,\n    output logic                   ifu_o_misalgn,\n    output logic                   ifu_o_buserr,\n    output logic                   ifu_o_muldiv_b2b,\n    output logic                   ifu_o_valid,\n    input  logic                   ifu_o_ready,\n\n    // Halt Control Interface\n    input  logic                   ifu_halt_req,\n    output logic                   ifu_halt_ack,\n\n    // Other Input Signals\n    input  logic                   oitf_empty,\n    input  logic [E203_XLEN-1:0]   rf2ifu_x1,\n    input  logic [E203_XLEN-1:0]   rf2ifu_rs1,\n    input  logic                   dec2ifu_rs1en,\n    input  logic                   dec2ifu_rden,\n    input  logic [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input  logic                   dec2ifu_mulhsu,\n    input  logic                   dec2ifu_div,\n    input  logic                   dec2ifu_rem,\n    input  logic                   dec2ifu_divu,\n    input  logic                   dec2ifu_remu\n);\n\n// Implementation of the e203_ifu_ifetch module\n// ...\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 6, "code": "module e203_clkgate(\n    input  logic clk_in,\n    input  logic test_mode,\n    input  logic clock_en,\n    output logic clk_out\n);\n\n`ifdef FPGA_SOURCE\n    // FPGA Mode: Direct connection without gating\n    assign clk_out = clk_in;\n`else\n    // Gating Mode: Use clock enable signal to gate clock\n    logic enb;\n\n    always_latch begin\n        if (~clk_in) begin\n            enb <= clock_en || test_mode;\n        end\n    end\n\n    assign clk_out = enb && clk_in;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 3, "code": "`include \"e203_defines.v\"\n\nmodule e203_dtcm_ram(\n    input  logic sd,          // Power domain shutdown signal\n    input  logic ds,          // Deep sleep enable signal\n    input  logic ls,          // Light sleep enable signal\n    input  logic cs,          // Chip select signal\n    input  logic we,          // Write enable signal\n    input  logic [E203_DTCM_RAM_AW-1:0] addr, // Address input\n    input  logic [E203_DTCM_RAM_MW-1:0] wem,  // Write mask (byte enable)\n    input  logic [E203_DTCM_RAM_DW-1:0] din,  // Data input (write data)\n    input  logic rst_n,       // Asynchronous reset (active low)\n    input  logic clk,         // System clock\n    output logic [E203_DTCM_RAM_DW-1:0] dout  // Data output (read data)\n);\n\n// Instantiate the general-purpose RAM module\nsirv_gnrl_ram #(\n    .DP(E203_DTCM_RAM_DP),\n    .DW(E203_DTCM_RAM_DW),\n    .FORCE_X2ZERO(1),  // Force uninitialized memory to zero\n    .MW(E203_DTCM_RAM_MW),\n    .AW(E203_DTCM_RAM_AW)\n) u_203_dtcm_gnrl_ram (\n    .sd(sd),\n    .ds(ds),\n    .ls(ls),\n    .rst_n(rst_n),\n    .clk(clk),\n    .cs(cs),\n    .we(we),\n    .addr(addr),\n    .din(din),\n    .wem(wem),\n    .dout(dout)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 3, "code": "module e203_exu_alu_csrctrl(\n    input logic csr_i_valid,\n    output logic csr_i_ready,\n    input logic [E203_XLEN-1:0] csr_i_rs1,\n    input logic [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info,\n    input logic csr_i_rdwen,\n    output logic csr_ena,\n    output logic csr_wr_en,\n    output logic csr_rd_en,\n    output logic [11:0] csr_idx,\n    input logic csr_access_ilgl,\n    input logic [E203_XLEN-1:0] read_csr_dat,\n    output logic [E203_XLEN-1:0] wbck_csr_dat,\n    output logic csr_o_valid,\n    input logic csr_o_ready,\n    output logic [E203_XLEN-1:0] csr_o_wbck_wdat,\n    output logic csr_o_wbck_err,\n    input logic clk,\n    input logic rst_n\n);\n\n// CSR control signal preparation logic\nalways_comb begin\n    csr_i_ready = 1'b1; // Always ready for input\n    csr_ena = csr_o_valid && csr_o_ready;\n    csr_wr_en = (csr_i_valid && (csr_i_info[E203_DECINFO_CSR_CSRRW] || (csr_i_info[E203_DECINFO_CSR_CSRRS] && !csr_i_rs1[0]) || (csr_i_info[E203_DECINFO_CSR_CSRRC] && !csr_i_rs1[0]))) && csr_i_rdwen;\n    csr_rd_en = csr_i_valid && (csr_i_info[E203_DECINFO_CSR_CSRRW] || csr_i_info[E203_DECINFO_CSR_CSRRS] || csr_i_info[E203_DECINFO_CSR_CSRRC]) && csr_i_rdwen;\n    csr_idx = csr_i_info[E203_DECINFO_CSR_CSRIDX_MSB:E203_DECINFO_CSR_CSRIDX_LSB];\n    \n    // Prepare write data for CSR\n    if (csr_i_info[E203_DECINFO_CSR_CSRRW]) begin\n        wbck_csr_dat = csr_i_rs1;\n    end else if (csr_i_info[E203_DECINFO_CSR_CSRRS]) begin\n        wbck_csr_dat = read_csr_dat | csr_i_rs1;\n    end else if (csr_i_info[E203_DECINFO_CSR_CSRRC]) begin\n        wbck_csr_dat = read_csr_dat & ~csr_i_rs1;\n    end else begin\n        wbck_csr_dat = '0;\n    end\n    \n    csr_o_valid = csr_i_valid;\n    csr_o_wbck_wdat = read_csr_dat;\n    csr_o_wbck_err = csr_access_ilgl;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 11, "code": "`include \"e203_defines.v\"\n\nmodule e203_clk_ctrl(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic test_mode,\n    input  logic core_cgstop,\n    \n    // Functional Unit Activity State Signals\n    input  logic core_ifu_active,\n    input  logic core_exu_active,\n    input  logic core_lsu_active,\n    input  logic core_biu_active,\n    input  logic core_wfi,\n    \n    // Optional ITCM signals (if E203_HAS_ITCM is defined)\n    `ifdef E203_HAS_ITCM\n    input  logic itcm_active,\n    output logic itcm_ls,\n    output logic clk_itcm,\n    `endif\n    \n    // Optional DTCM signals (if E203_HAS_DTCM is defined)\n    `ifdef E203_HAS_DTCM\n    input  logic dtcm_active,\n    output logic dtcm_ls,\n    output logic clk_dtcm,\n    `endif\n    \n    // Clock Output Signals\n    output logic clk_aon,\n    output logic clk_core_ifu,\n    output logic clk_core_exu,\n    output logic clk_core_lsu,\n    output logic clk_core_biu\n);\n\n// Always-on clock (normally on)\nassign clk_aon = clk;\n\n// Clock gating control logic\nassign clk_core_ifu = core_cgstop || (core_ifu_active && !core_wfi);\nassign clk_core_exu = core_cgstop || core_exu_active;\nassign clk_core_lsu = core_cgstop || core_lsu_active;\nassign clk_core_biu = core_cgstop || core_biu_active;\n\n// Optional ITCM clock control (if enabled)\n`ifdef E203_HAS_ITCM\nlogic itcm_active_r;\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        itcm_active_r <= 1'b0;\n    end else begin\n        itcm_active_r <= itcm_active;\n    end\nend\nassign clk_itcm = core_cgstop || itcm_active || itcm_active_r;\nassign itcm_ls = ~(core_cgstop || itcm_active || itcm_active_r);\n`endif\n\n// Optional DTCM clock control (if enabled)\n`ifdef E203_HAS_DTCM\nlogic dtcm_active_r;\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        dtcm_active_r <= 1'b0;\n    end else begin\n        dtcm_active_r <= dtcm_active;\n    end\nend\nassign clk_dtcm = core_cgstop || dtcm_active || dtcm_active_r;\nassign dtcm_ls = ~(core_cgstop || dtcm_active || dtcm_active_r);\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 5, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 12, "code": "`ifdef E203_HAS_ITCM\n`define E203_ITCM_CLK_ENABLE (core_cgstop | itcm_active | itcm_active_r)\n`else\n`define E203_ITCM_CLK_ENABLE 1'b0\n`endif\n\n`ifdef E203_HAS_DTCM\n`define E203_DTCM_CLK_ENABLE (core_cgstop | dtcm_active | dtcm_active_r)\n`else\n`define E203_DTCM_CLK_ENABLE 1'b0\n`endif\n\nmodule e203_clk_ctrl(\n    input   clk,\n    input   rst_n,\n    input   test_mode,\n    input   core_cgstop,\n    input   core_ifu_active,\n    input   core_exu_active,\n    input   core_lsu_active,\n    input   core_biu_active,\n    input   core_wfi,\n    input   itcm_active,\n    input   dtcm_active,\n    output  clk_aon,\n    output  clk_core_ifu,\n    output  clk_core_exu,\n    output  clk_core_lsu,\n    output  clk_core_biu,\n    output  clk_itcm,\n    output  clk_dtcm,\n    output  itcm_ls,\n    output  dtcm_ls\n);\n\nwire clk_core_ifu_enable = core_cgstop | (core_ifu_active & ~core_wfi);\nwire clk_core_exu_enable = core_cgstop | core_exu_active;\nwire clk_core_lsu_enable = core_cgstop | core_lsu_active;\nwire clk_core_biu_enable = core_cgstop | core_biu_active;\n\ne203_clkgate u_ifu_clk_gate(\n    .clk(clk),\n    .rst_n(rst_n),\n    .test_mode(test_mode),\n    .clk_enable(clk_core_ifu_enable),\n    .clk_out(clk_core_ifu)\n);\n\ne203_clkgate u_exu_clk_gate(\n    .clk(clk),\n    .rst_n(rst_n),\n    .test_mode(test_mode),\n    .clk_enable(clk_core_exu_enable),\n    .clk_out(clk_core_exu)\n);\n\ne203_clkgate u_lsu_clk_gate(\n    .clk(clk),\n    .rst_n(rst_n),\n    .test_mode(test_mode),\n    .clk_enable(clk_core_lsu_enable),\n    .clk_out(clk_core_lsu)\n);\n\ne203_clkgate u_biu_clk_gate(\n    .clk(clk),\n    .rst_n(rst_n),\n    .test_mode(test_mode),\n    .clk_enable(clk_core_biu_enable),\n    .clk_out(clk_core_biu)\n);\n\nassign clk_aon = clk;\n\n`ifdef E203_HAS_ITCM\n    e203_clkgate u_itcm_clk_gate(\n        .clk(clk),\n        .rst_n(rst_n),\n        .test_mode(test_mode),\n        .clk_enable(`E203_ITCM_CLK_ENABLE),\n        .clk_out(clk_itcm)\n    );\n    assign itcm_ls = ~`E203_ITCM_CLK_ENABLE;\n`else\n    assign clk_itcm = 1'b0;\n    assign itcm_ls = 1'b0;\n`endif\n\n`ifdef E203_HAS_DTCM\n    e203_clkgate u_dtcm_clk_gate(\n        .clk(clk),\n        .rst_n(rst_n),\n        .test_mode(test_mode),\n        .clk_enable(`E203_DTCM_CLK_ENABLE),\n        .clk_out(clk_dtcm)\n    );\n    assign dtcm_ls = ~`E203_DTCM_CLK_ENABLE;\n`else\n    assign clk_dtcm = 1'b0;\n    assign dtcm_ls = 1'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 13, "code": "// e203_clk_ctrl.v - Clock control module for E203 processor\n// Based on the provided design document\n\n`include \"e203_defines.v\"\n\nmodule e203_clk_ctrl (\n    input  logic clk,           // System clock\n    input  logic rst_n,         // Asynchronous reset (active low)\n    input  logic test_mode,     // Test mode signal\n    input  logic core_cgstop,   // Clock-gated stop signal from CSR\n    input  logic core_ifu_active, // IFU active status\n    input  logic core_exu_active, // EXU active status\n    input  logic core_lsu_active, // LSU active status\n    input  logic core_biu_active, // BIU active status\n    input  logic core_wfi,      // Wait for interrupt status signal\n    input  logic itcm_active,   // ITCM active status (optional)\n    input  logic dtcm_active,   // DTCM active status (optional)\n    output logic clk_aon,       // Normally on clock\n    output logic clk_core_ifu,  // IFU module clock\n    output logic clk_core_exu,  // EXU module clock\n    output logic clk_core_lsu,  // LSU module clock\n    output logic clk_core_biu,  // BIU module clock\n    output logic clk_itcm,      // ITCM module clock (optional)\n    output logic clk_dtcm       // DTCM module clock (optional)\n);\n\n// Clock enable generation\nlogic clk_en_ifu;\nlogic clk_en_exu;\nlogic clk_en_lsu;\nlogic clk_en_biu;\nlogic clk_en_itcm;\nlogic clk_en_dtcm;\n\n// Clock enables are ORed with core_cgstop\nassign clk_en_ifu = core_cgstop || (core_ifu_active && !core_wfi);\nassign clk_en_exu = core_cgstop || core_exu_active;\nassign clk_en_lsu = core_cgstop || core_lsu_active;\nassign clk_en_biu = core_cgstop || core_biu_active;\n\n// Optional ITCM clock control\n`ifdef E203_HAS_ITCM\n    logic itcm_active_r; // Registered ITCM active status\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            itcm_active_r <= 1'b0;\n        end else begin\n            itcm_active_r <= itcm_active;\n        end\n    end\n    assign clk_en_itcm = core_cgstop || itcm_active || itcm_active_r;\n`else\n    assign clk_en_itcm = 1'b0;\n`endif\n\n// Optional DTCM clock control\n`ifdef E203_HAS_DTCM\n    logic dtcm_active_r; // Registered DTCM active status\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            dtcm_active_r <= 1'b0;\n        end else begin\n            dtcm_active_r <= dtcm_active;\n        end\n    end\n    assign clk_en_dtcm = core_cgstop || dtcm_active || dtcm_active_r;\n`else\n    assign clk_en_dtcm = 1'b0;\n`endif\n\n// Clock gating logic\nassign clk_core_ifu = clk_en_ifu ? clk : 1'b0;\nassign clk_core_exu = clk_en_exu ? clk : 1'b0;\nassign clk_core_lsu = clk_en_lsu ? clk : 1'b0;\nassign clk_core_biu = clk_en_biu ? clk : 1'b0;\nassign clk_itcm = clk_en_itcm ? clk : 1'b0;\nassign clk_dtcm = clk_en_dtcm ? clk : 1'b0;\n\n// Always-on clock (not clock-gated)\nassign clk_aon = clk;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_core (\n    // System Interface\n    output [E203_PC_SIZE-1:0]   inspect_pc,\n    output                       core_wfi,\n    output                       tm_stop,\n    output                       core_cgstop,\n    output                       tcm_cgstop,\n    input  [E203_PC_SIZE-1:0]   pc_rtvec,\n    input  [E203_HART_ID_W-1:0] core_mhartid,\n    input                        dbg_irq_r,\n    input  [E203_LIRQ_NUM-1:0]  lcl_irq_r,\n    input  [E203_EVT_NUM-1:0]   evt_r,\n    input                        ext_irq_r,\n    input                        sft_irq_r,\n    input                        tmr_irq_r,\n    output                       wr_dcsr_ena,\n    output                       wr_dpc_ena,\n    output                       wr_dscratch_ena,\n    output [31:0]                wr_csr_nxt,\n    input  [31:0]                dcsr_r,\n    input  [E203_PC_SIZE-1:0]   dpc_r,\n    input  [31:0]                dscratch_r,\n    output [E203_PC_SIZE-1:0]   cmt_dpc,\n    output                       cmt_dpc_ena,\n    output [2:0]                 cmt_dcause,\n    output                       cmt_dcause_ena,\n    input                        dbg_mode,\n    input                        dbg_halt_r,\n    input                        dbg_step_r,\n    input                        dbg_ebreakm_r,\n    input                        dbg_stopcycle,\n\n    // ICB Interfaces (PPI, CLINT, PLIC, FIO, etc.)\n    // Example: PPI Interface\n    input                        ppi_region_indic,\n    input                        ppi_icb_enable,\n    output                       ppi_icb_cmd_valid,\n    input                        ppi_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] ppi_icb_cmd_addr,\n    output                       ppi_icb_cmd_read,\n    output [E203_XLEN-1:0]      ppi_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0]    ppi_icb_cmd_wmask,\n    output                       ppi_icb_cmd_lock,\n    output                       ppi_icb_cmd_excl,\n    output [1:0]                 ppi_icb_cmd_size,\n    input                        ppi_icb_rsp_valid,\n    output                       ppi_icb_rsp_ready,\n    input                        ppi_icb_rsp_err,\n    input                        ppi_icb_rsp_excl_ok,\n    input  [E203_XLEN-1:0]      ppi_icb_rsp_rdata,\n\n    // ... (Other ICB interfaces for CLINT, PLIC, FIO, etc.)\n\n    // Clock and Reset\n    input                        clk,\n    input                        rst_n\n);\n\n// Instantiate submodules (IFU, EXU, LSU, BIU)\ne203_ifu   ifu_inst (\n    // ... (IFU signals)\n);\n\ne203_exu   exu_inst (\n    // ... (EXU signals)\n);\n\ne203_lsu   lsu_inst (\n    // ... (LSU signals)\n);\n\ne203_biu   biu_inst (\n    // ... (BIU signals)\n);\n\n// ... (Other submodule instantiations)\n\n// Top-level logic for connecting modules and handling system signals\nalways_comb begin\n    // ... (System signal assignments and module connections)\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 8, "code": "module example_module(\n    input   logic       clk,\n    input   logic       rst_n,\n    input   logic [7:0] data_in,\n    output  logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 1, "code": "// Example Verilog Module\nmodule example_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Always block for sequential logic (register)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0;  // Reset value\n    end else begin\n        reg_data <= data_in;  // Capture input data on rising clock edge\n    end\nend\n\n// Continuous assignment for output\nassign data_out = reg_data;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 14, "code": "// e203_clk_ctrl module implementation based on provided specifications\n\nmodule e203_clk_ctrl(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic test_mode,\n    input  logic core_cgstop,\n    input  logic core_ifu_active,\n    input  logic core_exu_active,\n    input  logic core_lsu_active,\n    input  logic core_biu_active,\n    input  logic core_wfi,\n    output logic clk_aon,\n    output logic clk_core_ifu,\n    output logic clk_core_exu,\n    output logic clk_core_lsu,\n    output logic clk_core_biu,\n    `ifdef E203_HAS_ITCM\n    input  logic itcm_active,\n    output logic itcm_ls,\n    output logic clk_itcm,\n    `endif\n    `ifdef E203_HAS_DTCM\n    input  logic dtcm_active,\n    output logic dtcm_ls,\n    output logic clk_dtcm,\n    `endif\n);\n\n// Always-on clock assignment\nassign clk_aon = clk;\n\n// Clock enable logic for core modules\nlogic clk_en_ifu;\nlogic clk_en_exu;\nlogic clk_en_lsu;\nlogic clk_en_biu;\n\n// IFU clock enable\nassign clk_en_ifu = (core_cgstop == 1'b1) || (core_ifu_active == 1'b1 && core_wfi == 1'b0);\n\n// Other core module clock enables\nassign clk_en_exu = (core_cgstop == 1'b1) || (core_exu_active == 1'b1);\nassign clk_en_lsu = (core_cgstop == 1'b1) || (core_lsu_active == 1'b1);\nassign clk_en_biu = (core_cgstop == 1'b1) || (core_biu_active == 1'b1);\n\n// Clock gate instantiation for each core module (e.g., using e203_clkgate module)\ne203_clkgate ifu_clk_gate(\n    .clk(clk),\n    .clk_en(clk_en_ifu),\n    .clk_out(clk_core_ifu)\n);\n\ne203_clkgate exu_clk_gate(\n    .clk(clk),\n    .clk_en(clk_en_exu),\n    .clk_out(clk_core_exu)\n);\n\ne203_clkgate lsu_clk_gate(\n    .clk(clk),\n    .clk_en(clk_en_lsu),\n    .clk_out(clk_core_lsu)\n);\n\ne203_clkgate biu_clk_gate(\n    .clk(clk),\n    .clk_en(clk_en_biu),\n    .clk_out(clk_core_biu)\n);\n\n// ITCM clock control (optional)\n`ifdef E203_HAS_ITCM\nlogic itcm_active_r; // Register to record last cycle activity\n\nsirv_gnrl_dffr #(.DW(1)) clk_itcm_reg(\n    .dnxt(itcm_active),\n    .qout(itcm_active_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nassign clk_itcm = (core_cgstop == 1'b1) || (itcm_active == 1'b1) || (itcm_active_r == 1'b1);\nassign itcm_ls = ~(itcm_active || itcm_active_r); // Light sleep signal\n`endif\n\n// DTCM clock control (optional)\n`ifdef E203_HAS_DTCM\nlogic dtcm_active_r; // Register to record last cycle activity\n\nsirv_gnrl_dffr #(.DW(1)) clk_dtcm_reg(\n    .dnxt(dtcm_active),\n    .qout(dtcm_active_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nassign clk_dtcm = (core_cgstop == 1'b1) || (dtcm_active == 1'b1) || (dtcm_active_r == 1'b1);\nassign dtcm_ls = ~(dtcm_active || dtcm_active_r); // Light sleep signal\n`endif\n\nendmodule\n\n// sirv_gnrl_dffr module implementation (from specifications)\nmodule sirv_gnrl_dffr #(\n    parameter DW = 32\n)(\n    input  logic [DW-1:0] dnxt,\n    output logic [DW-1:0] qout,\n    input  logic clk,\n    input  logic rst_n\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        qout <= '0;\n    end else begin\n        qout <= dnxt;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 4, "code": "`ifndef E203_DEFS\n`define E203_DEFS\n\n// Core configuration parameters\n`define E203_HART_NUM          1          // Number of HARTs (Hardware Threads)\n`define E203_HART_ID_W         1          // Width of Hardware Thread ID\n`define E203_LIRQ_NUM          1          // Number of local interrupt sources\n`define E203_EVT_NUM           0          // Number of external event triggers\n`define E203_XLEN             32         // Data width (32-bit)\n`define E203_XLEN_MW          4          // Number of bytes in a data word\n`define E203_PC_SIZE          32         // Program Counter width\n`define E203_ADDR_SIZE        32         // Address width\n`define E203_HAS_FIO          1          // Enable Fast I/O interface\n`define E203_HAS_PPI          1          // Enable Private Peripheral Interface\n`define E203_HAS_CLINT        1          // Enable Core-Local Interrupt Controller\n`define E203_HAS_PLIC         1          // Enable Platform-Level Interrupt Controller\n\n//Register file configuration\n`define E203_RFREG_NUM        32         // Number of registers in the register file\n\n// Instruction TCM configuration\n`define E203_HAS_ITCM         1          // Enable Instruction TCM\n`define E203_ITCM_ADDR_WIDTH  16         // ITCM address width (16 bits -> 64KB)\n`define E203_ITCM_RAM_AW      13         // ITCM RAM address width (2^13 = 8192 words)\n`define E203_ITCM_RAM_DW      64         // ITCM RAM data width (64 bits)\n`define E203_ITCM_RAM_MW      8          // ITCM RAM write mask width (8 bits)\n`define E203_ITCM_RAM_DP      8192       // ITCM RAM depth (8192 words)\n`define E203_ITCM_DATA_WIDTH  64         // ITCM data width (64 bits)\n`define E203_ITCM_WMSK_WIDTH  8          // ITCM write mask width (8 bits)\n`define E203_ITCM_OUTS_NUM    1          // ITCM allows 1 outstanding transaction\n`define E203_ITCM_BASE_REGION 32'h8000   // ITCM base region\n\n// Data TCM configuration\n`define E203_HAS_DTCM         1          // Enable Data TCM\n`define E203_DTCM_ADDR_WIDTH  16         // DTCM address width (16 bits -> 64KB)\n`define E203_DTCM_RAM_AW      14         // DTCM RAM address width (2^14 = 16384 words)\n`define E203_DTCM_RAM_DW      32         // DTCM RAM data width (32 bits)\n`define E203_DTCM_RAM_MW      4          // DTCM RAM write mask width (4 bits)\n`define E203_DTCM_RAM_DP      16384      // DTCM RAM depth (16384 words)\n`define E203_DTCM_DATA_WIDTH  32         // DTCM data width (32 bits)\n`define E203_DTCM_WMSK_WIDTH  4          // DTCM write mask width (4 bits)\n`define E203_DTCM_OUTS_NUM    1          // DTCM allows 1 outstanding transaction\n`define E203_DTCM_BASE_REGION 32'h9000   // DTCM base region\n\n// Peripheral base addresses\n`define E203_PPI_ADDR_BASE    32'h1000_0000 // PPI base address\n`define E203_PPI_BASE_REGION  16'h1000     // PPI region indicator\n`define E203_CLINT_ADDR_BASE  32'h0200_0000 // CLINT base address\n`define E203_CLINT_BASE_REGION 16'h0200     // CLINT region indicator\n`define E203_PLIC_ADDR_BASE   32'h0C00_0000 // PLIC base address\n`define E203_PLIC_BASE_REGION 16'h0C00     // PLIC region indicator\n`define E203_FIO_ADDR_BASE    32'hF000_0000 // FIO base address\n`define E203_FIO_BASE_REGION  16'hF000     // FIO region indicator\n\n// CSR related configuration\n`define E203_SUPPORT_MSCRATCH // Support MSCRATCH register\n`define E203_SUPPORT_MTVEC    // Support MTVEC register\n`define E203_SUPPORT_MCYCLE_MINSTRET // Support MCYCLE/MINSTRET counters\n\n// LSU configuration\n`define E203_LSU_OUTS_NUM    1          // LSU supports 1 outstanding transaction\n`define E203_BIU_OUTS_NUM    1          // BIU supports 1 outstanding transaction\n\n`endif // E203_DEFS", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 5, "code": "`include \"e203_defines.v\"\n\nmodule e203_itcm_ram #(\n    parameter FORCE_X2ZERO = 0,\n    parameter DP           = E203_ITCM_RAM_DP,\n    parameter DW           = E203_ITCM_RAM_DW,\n    parameter MW           = E203_ITCM_RAM_MW,\n    parameter AW           = E203_ITCM_RAM_AW\n)(\n    input  logic             sd,    // Power domain shutdown enable signal\n    input  logic             ds,    // Deep sleep mode enable, controlling complete power area shutdown\n    input  logic             ls,    // Light sleep mode enable, reducing power without full shutdown\n    input  logic             cs,    // Chip select signal, controlling RAM selection\n    input  logic             we,    // Write enable signal, controlling write operation\n    input  logic [AW-1:0]    addr,  // Address input, specifying read/write location\n    input  logic [MW-1:0]    wem,   // Write mask, controlling specific byte writing\n    input  logic [DW-1:0]    din,   // Data input to be written\n    input  logic             rst_n, // Asynchronous reset signal (active low)\n    input  logic             clk,   // System clock\n    output logic [DW-1:0]    dout   // Data output, read data\n);\n\nlogic [DW-1:0] ram [DP-1:0];\n\n// Internal wire for output data\nlogic [DW-1:0] dout_int;\n\n// Register array implementation\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset to zero if FORCE_X2ZERO is enabled or ECC is not present\n        if (FORCE_X2ZERO == 0 || !E203_HAS_ECC) begin\n            for (int i = 0; i < DP; i++) begin\n                ram[i] <= '0;\n            end\n        end\n    end else if (cs && we) begin\n        // Write operation with byte-level granularity\n        for (int i = 0; i < MW; i++) begin\n            if (wem[i]) begin\n                ram[addr][i*8 +: 8] <= din[i*8 +: 8];\n            end\n        end\n    end\nend\n\n// Read operation\nalways_comb begin\n    if (cs) begin\n        dout_int = ram[addr];\n    end else begin\n        dout_int = '0;\n    end\nend\n\n// Output assignment\nassign dout = dout_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 4, "code": "// e203_dtcm_ram module implementation\nmodule e203_dtcm_ram(\n    input sd,      // Power domain shutdown enable signal\n    input ds,      // Deep sleep mode enable\n    input ls,      // Light sleep mode enable\n    input cs,      // Chip select signal\n    input we,      // Write enable signal\n    input [E203_DTCM_RAM_AW-1:0] addr, // Address input\n    input [E203_DTCM_RAM_MW-1:0] wem,  // Write mask\n    input [E203_DTCM_RAM_DW-1:0] din,  // Data input\n    input rst_n,   // Asynchronous reset (active low)\n    input clk,     // System clock\n    output [E203_DTCM_RAM_DW-1:0] dout // Data output\n);\n\n// Define parameters from configuration (assuming they are defined in e203_defines.v)\nparameter DP = E203_DTCM_RAM_DP; // Depth of the RAM (number of entries)\nparameter DW = E203_DTCM_RAM_DW; // Data width (in bits)\nparameter MW = E203_DTCM_RAM_MW; // Write mask width (in bits)\nparameter AW = E203_DTCM_RAM_AW; // Address width (in bits)\n\n// Internal RAM declaration (using registers)\nreg [DW-1:0] ram [DP-1:0];\n\n// Write logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Initialize RAM to zero on reset (optional, based on FORCE_X2ZERO parameter)\n        for (int i = 0; i < DP; i++) begin\n            ram[i] <= {DW{1'b0}};\n        end\n    end else if (cs && we) begin\n        // Write operation with byte mask\n        for (int i = 0; i < MW; i++) begin\n            if (wem[i]) begin\n                ram[addr][i*8 +: 8] <= din[i*8 +: 8];\n            end\n        end\n    end\nend\n\n// Read logic (combinatorial)\nalways_comb begin\n    if (cs) begin\n        dout = ram[addr];\n    end else begin\n        dout = {DW{1'bz}}; // Tri-state or zero for invalid state\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 5, "code": "`ifdef E203_HAS_NICE\n    `define E203_DECINFO_NICE_WIDTH 27\n`else\n    `define E203_DECINFO_NICE_WIDTH 0\n`endif\n\n`define E203_DECINFO_WIDTH (E203_DECINFO_GRP_WIDTH + E203_DECINFO_RV32_WIDTH + E203_DECINFO_SUBDECINFO_LSB + E203_DECINFO_NICE_WIDTH + 1)\n\nmodule e203_ifu_minidec(\n    input  logic [E203_INSTR_SIZE-1:0]               instr,\n    output logic                                    dec_rs1en,\n    output logic                                    dec_rs2en,\n    output logic [E203_RFIDX_WIDTH-1:0]             dec_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0]             dec_rs2idx,\n    output logic                                    dec_mulhsu,\n    output logic                                    dec_mul,\n    output logic                                    dec_div,\n    output logic                                    dec_rem,\n    output logic                                    dec_divu,\n    output logic                                    dec_remu,\n    output logic                                    dec_rv32,\n    output logic                                    dec_bjp,\n    output logic                                    dec_jal,\n    output logic                                    dec_jalr,\n    output logic                                    dec_bxx,\n    output logic [E203_RFIDX_WIDTH-1:0]             dec_jalr_rs1idx,\n    output logic [E203_XLEN-1:0]                    dec_bjp_imm\n);\n\ne203_exu_decode u_e203_exu_decode(\n    .i_instr          (instr),\n    .i_pc             ('0),\n    .i_prdt_taken     ('0),\n    .i_muldiv_b2b     ('0),\n    .i_misalgn        ('0),\n    .i_buserr         ('0),\n    .dbg_mode         ('0),\n    .dec_rs1en        (dec_rs1en),\n    .dec_rs2en        (dec_rs2en),\n    .dec_rs1idx       (dec_rs1idx),\n    .dec_rs2idx       (dec_rs2idx),\n    .dec_mulhsu       (dec_mulhsu),\n    .dec_mul          (dec_mul),\n    .dec_div          (dec_div),\n    .dec_rem          (dec_rem),\n    .dec_divu         (dec_divu),\n    .dec_remu         (dec_remu),\n    .dec_rv32         (dec_rv32),\n    .dec_bjp          (dec_bjp),\n    .dec_jal          (dec_jal),\n    .dec_jalr         (dec_jalr),\n    .dec_bxx          (dec_bxx),\n    .dec_jalr_rs1idx  (dec_jalr_rs1idx),\n    .dec_bjp_imm      (dec_bjp_imm),\n    .dec_misalgn      (),\n    .dec_buserr       (),\n    .dec_ilegl        (),\n    .dec_rs1x0        (),\n    .dec_rs2x0        (),\n    .dec_rdwen        (),\n    .dec_rdidx        (),\n    .dec_info         (),\n    .dec_imm          (),\n    .dec_pc           (),\n    .dec_nice         (),\n    .nice_xs_off      ('0),\n    .nice_cmt_off_ilgl_o()\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 9, "code": "// e203_exu_regfile.v - RISC-V Integer General-Purpose Register File\n// Copyright (C) 2023-2024 Nuclei System Technology\n// Licensed under Apache 2.0 (https://www.apache.org/licenses/LICENSE-2.0)\n\n`include \"e203_defines.v\"\n\nmodule e203_exu_regfile(\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src1_idx,\n    input  logic [E203_RFIDX_WIDTH-1:0] read_src2_idx,\n    output logic [E203_XLEN-1:0]        read_src1_dat,\n    output logic [E203_XLEN-1:0]        read_src2_dat,\n    input  logic                        wbck_dest_wen,\n    input  logic [E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n    input  logic [E203_XLEN-1:0]        wbck_dest_dat,\n    output logic [E203_XLEN-1:0]        x1_r,\n    input  logic                        test_mode,\n    input  logic                        clk,\n    input  logic                        rst_n\n);\n\n// Register file storage (using behavioral array)\nlogic [E203_XLEN-1:0] regfile [0:E203_RFREG_NUM-1];\n\n// Zero register (hardcoded)\nassign x1_r = '0;\n\n// Read logic (two read ports)\nalways_comb begin\n    read_src1_dat = (read_src1_idx == 0) ? '0 : regfile[read_src1_idx];\n    read_src2_dat = (read_src2_idx == 0) ? '0 : regfile[read_src2_idx];\nend\n\n// Write logic (one write port)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        for (int i = 0; i < E203_RFREG_NUM; i++) begin\n            regfile[i] <= '0;\n        end\n    end else if (wbck_dest_wen && wbck_dest_idx != 0) begin\n        regfile[wbck_dest_idx] <= wbck_dest_dat;\n    end\nend\n\nendmodule : e203_exu_regfile\n\n// Alternative implementation using latch-based design (if E203_REGFILE_LATCH_BASED is defined)\n`ifdef E203_REGFILE_LATCH_BASED\n    // Latch-based register file implementation\n    // (not shown in this code snippet for brevity)\n`endif", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic reset_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 2, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 5, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 4, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 3, "code": "`ifdef E203_CFG_HAS_FPU\n    // Floating-point unit configuration\n    `define E203_HAS_FPU 1\n    `ifdef E203_CFG_FPU_DOUBLE\n        // Double-precision floating-point support\n        `define E203_FPU_DOUBLE 1\n        `define E203_FLEN 64\n    `else\n        // Single-precision floating-point support\n        `define E203_FLEN 32\n    `endif\n`endif", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] reg_data;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 5, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 5, "code": "module example_module(\n    input  logic clk,\n    input  logic reset_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 4, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 1, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic reset_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 3, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 4, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [3:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= {data_out[6:0], data_in[0]};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 4, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 8, "code": "module e203_exu_oitf #(\n    parameter E203_OITF_DEPTH = 4,\n    parameter E203_ITAG_WIDTH = $clog2(E203_OITF_DEPTH),\n    parameter E203_RFIDX_WIDTH = 5,\n    parameter E203_PC_SIZE = 32\n) (\n    output logic dis_ready,\n    input logic dis_ena,\n    input logic ret_ena,\n    output logic [E203_ITAG_WIDTH-1:0] dis_ptr,\n    output logic [E203_ITAG_WIDTH-1:0] ret_ptr,\n    output logic [E203_RFIDX_WIDTH-1:0] ret_rdidx,\n    output logic ret_rdwen,\n    output logic ret_rdfpu,\n    output logic [E203_PC_SIZE-1:0] ret_pc,\n    input logic disp_i_rs1en,\n    input logic disp_i_rs2en,\n    input logic disp_i_rs3en,\n    input logic disp_i_rdwen,\n    input logic disp_i_rs1fpu,\n    input logic disp_i_rs2fpu,\n    input logic disp_i_rs3fpu,\n    input logic disp_i_rdfpu,\n    input logic [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx,\n    input logic [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx,\n    input logic [E203_RFIDX_WIDTH-1:0] disp_i_rs3idx,\n    input logic [E203_RFIDX_WIDTH-1:0] disp_i_rdidx,\n    input logic [E203_PC_SIZE-1:0] disp_i_pc,\n    output logic oitfrd_match_disprs1,\n    output logic oitfrd_match_disprs2,\n    output logic oitfrd_match_disprs3,\n    output logic oitfrd_match_disprd,\n    output logic oitf_empty,\n    input logic clk,\n    input logic rst_n\n);\n\n// FIFO internal storage\nlogic [E203_OITF_DEPTH-1:0][E203_RFIDX_WIDTH + E203_PC_SIZE + 1 + 1] oitf_mem;\n\n// Wrap-around flags for FIFO\nlogic dis_wrap, ret_wrap;\n\n// Full and empty conditions\nassign dis_ready = ~((dis_ptr == ret_ptr) && (dis_wrap != ret_wrap));\nassign oitf_empty = (dis_ptr == ret_ptr) && (dis_wrap == ret_wrap);\n\n// Retirement output signals\nassign ret_rdidx = oitf_mem[ret_ptr][E203_RFIDX_WIDTH + E203_PC_SIZE + 1 + 1 - 1 -: E203_RFIDX_WIDTH];\nassign ret_rdwen = oitf_mem[ret_ptr][E203_RFIDX_WIDTH + E203_PC_SIZE + 1];\nassign ret_rdfpu = oitf_mem[ret_ptr][E203_RFIDX_WIDTH + E203_PC_SIZE];\nassign ret_pc = oitf_mem[ret_ptr][E203_RFIDX_WIDTH + E203_PC_SIZE - 1 -: E203_PC_SIZE];\n\n// Dependency checking logic\nalways_comb begin\n    oitfrd_match_disprs1 = 1'b0;\n    oitfrd_match_disprs2 = 1'b0;\n    oitfrd_match_disprs3 = 1'b0;\n    oitfrd_match_disprd = 1'b0;\n\n    for (int i = 0; i < E203_OITF_DEPTH; i++) begin\n        if (oitf_mem[i][E203_RFIDX_WIDTH + E203_PC_SIZE + 1]) begin // rdwen == 1\n            if (oitf_mem[i][E203_RFIDX_WIDTH + E203_PC_SIZE] && disp_i_rs1fpu && (oitf_mem[i][E203_RFIDX_WIDTH - 1 -: E203_RFIDX_WIDTH] == disp_i_rs1idx)) begin\n                oitfrd_match_disprs1 = 1'b1;\n            end\n            if (oitf_mem[i][E203_RFIDX_WIDTH + E203_PC_SIZE] && disp_i_rs2fpu && (oitf_mem[i][E203_RFIDX_WIDTH - 1 -: E203_RFIDX_WIDTH] == disp_i_rs2idx)) begin\n                oitfrd_match_disprs2 = 1'b1;\n            end\n            if (oitf_mem[i][E203_RFIDX_WIDTH + E203_PC_SIZE] && disp_i_rs3fpu && (oitf_mem[i][E203_RFIDX_WIDTH - 1 -: E203_RFIDX_WIDTH] == disp_i_rs3idx)) begin\n                oitfrd_match_disprs3 = 1'b1;\n            end\n            if (oitf_mem[i][E203_RFIDX_WIDTH + E203_PC_SIZE] && disp_i_rdfpu && (oitf_mem[i][E203_RFIDX_WIDTH - 1 -: E203_RFIDX_WIDTH] == disp_i_rdidx)) begin\n                oitfrd_match_disprd = 1'b1;\n            end\n            if (!oitf_mem[i][E203_RFIDX_WIDTH + E203_PC_SIZE] && !disp_i_rs1fpu && (oitf_mem[i][E203_RFIDX_WIDTH - 1 -: E203_RFIDX_WIDTH] == disp_i_rs1idx)) begin\n                oitfrd_match_disprs1 = 1'b1;\n            end\n            if (!oitf_mem[i][E203_RFIDX_WIDTH + E203_PC_SIZE] && !disp_i_rs2fpu && (oitf_mem[i][E203_RFIDX_WIDTH - 1 -: E203_RFIDX_WIDTH] == disp_i_rs2idx)) begin\n                oitfrd_match_disprs2 = 1'b1;\n            end\n            if (!oitf_mem[i][E203_RFIDX_WIDTH + E203_PC_SIZE] && !disp_i_rs3fpu && (oitf_mem[i][E203_RFIDX_WIDTH - 1 -: E203_RFIDX_WIDTH] == disp_i_rs3idx)) begin\n                oitfrd_match_disprs3 = 1'b1;\n            end\n            if (!oitf_mem[i][E203_RFIDX_WIDTH + E203_PC_SIZE] && !disp_i_rdfpu && (oitf_mem[i][E203_RFIDX_WIDTH - 1 -: E203_RFIDX_WIDTH] == disp_i_rdidx)) begin\n                oitfrd_match_disprd = 1'b1;\n            end\n        end\n    end\nend\n\n// Sequential logic for FIFO operations\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        dis_ptr <= '0;\n        ret_ptr <= '0;\n        dis_wrap <= 1'b0;\n        ret_wrap <= 1'b0;\n        oitf_mem <= '{default: '0};\n    end else begin\n        if (dis_ena) begin\n            if (dis_ptr == E203_OITF_DEPTH - 1) begin\n                dis_ptr <= '0;\n                dis_wrap <= ~dis_wrap;\n            end else begin\n                dis_ptr <= dis_ptr + 1;\n            end\n            oitf_mem[dis_ptr] <= {disp_i_rdidx, disp_i_pc, disp_i_rdwen, disp_i_rdfpu};\n        end\n        \n        if (ret_ena) begin\n            if (ret_ptr == E203_OITF_DEPTH - 1) begin\n                ret_ptr <= '0;\n                ret_wrap <= ~ret_wrap;\n            end else begin\n                ret_ptr <= ret_ptr + 1;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 4, "code": "module dff(\n    input   clk,\n    input   rst_n,\n    input   d,\n    output  q\n);\n\nreg q_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        q_reg <= 1'b0;\n    end else begin\n        q_reg <= d;\n    end\nend\n\nassign q = q_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 5, "code": "// e203_biu.v\n`include \"e203_defines.v\"\n\nmodule e203_biu(\n    // Control signals\n    output biu_active,\n    input  clk,\n    input  rst_n,\n\n    // ICB interface for LSU\n    input  lsu_icb_cmd_valid,\n    output lsu_icb_cmd_ready,\n    input  [E203_ADDR_SIZE-1:0] lsu_icb_cmd_addr,\n    input  lsu_icb_cmd_read,\n    input  [E203_XLEN-1:0] lsu_icb_cmd_wdata,\n    input  [E203_XLEN/8-1:0] lsu_icb_cmd_wmask,\n    input  [1:0] lsu_icb_cmd_burst,\n    input  [1:0] lsu_icb_cmd_beat,\n    input  lsu_icb_cmd_lock,\n    input  lsu_icb_cmd_excl,\n    input  [1:0] lsu_icb_cmd_size,\n    output lsu_icb_rsp_valid,\n    input  lsu_icb_rsp_ready,\n    output lsu_icb_rsp_err,\n    output lsu_icb_rsp_excl_ok,\n    output [E203_XLEN-1:0] lsu_icb_rsp_rdata,\n\n    // ICB interface for IFU (if E203_HAS_MEM_ITF is defined)\n    `ifdef E203_HAS_MEM_ITF\n    input  ifu_icb_cmd_valid,\n    output ifu_icb_cmd_ready,\n    input  [E203_ADDR_SIZE-1:0] ifu_icb_cmd_addr,\n    input  ifu_icb_cmd_read,\n    input  [E203_XLEN-1:0] ifu_icb_cmd_wdata,\n    input  [E203_XLEN/8-1:0] ifu_icb_cmd_wmask,\n    input  [1:0] ifu_icb_cmd_burst,\n    input  [1:0] ifu_icb_cmd_beat,\n    input  ifu_icb_cmd_lock,\n    input  ifu_icb_cmd_excl,\n    input  [1:0] ifu_icb_cmd_size,\n    output ifu_icb_rsp_valid,\n    input  ifu_icb_rsp_ready,\n    output ifu_icb_rsp_err,\n    output ifu_icb_rsp_excl_ok,\n    output [E203_XLEN-1:0] ifu_icb_rsp_rdata,\n    `endif\n\n    // PPI interface\n    input [E203_ADDR_SIZE-1:0] ppi_region_indic,\n    input ppi_icb_enable,\n\n    // CLINT interface\n    input [E203_ADDR_SIZE-1:0] clint_region_indic,\n    input clint_icb_enable,\n\n    // PLIC interface\n    input [E203_ADDR_SIZE-1:0] plic_region_indic,\n    input plic_icb_enable,\n\n    // FIO interface (if E203_HAS_FIO is defined)\n    `ifdef E203_HAS_FIO\n    input [E203_ADDR_SIZE-1:0] fio_region_indic,\n    input fio_icb_enable,\n    `endif\n\n    // MEM interface (if E203_HAS_MEM_ITF is defined)\n    `ifdef E203_HAS_MEM_ITF\n    input mem_icb_enable,\n    `endif\n    // Other signals...\n);\n\n    // Local parameters\n    localparam BIU_ARBT_I_NUM = `E203_HAS_MEM_ITF ? 2 : 1;\n    localparam BIU_SPLT_I_NUM = `E203_HAS_FIO || `E203_HAS_MEM_ITF ? \n                               (`E203_HAS_FIO && `E203_HAS_MEM_ITF ? 6 : 5) : 4;\n\n    // Instantiate ICB Arbiter\n    sirv_gnrl_icb_arbt #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ARBT_NUM(BIU_ARBT_I_NUM),\n        .ARBT_PTR_W(1),\n        .USR_W(1),\n        .ARBT_SCHEME(0),\n        .ALLOW_0CYCL_RSP(0),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY)\n    ) icb_arbiter (\n        .o_icb_cmd_valid(),\n        .o_icb_cmd_ready(),\n        .o_icb_cmd_read(),\n        .o_icb_cmd_addr(),\n        .o_icb_cmd_wdata(),\n        .o_icb_cmd_wmask(),\n        .o_icb_rsp_valid(),\n        .o_icb_rsp_ready(),\n        .i_bus_icb_cmd_valid({`E203_HAS_MEM_ITF ? ifu_icb_cmd_valid : 1'b0, lsu_icb_cmd_valid}),\n        .i_bus_icb_cmd_ready({`E203_HAS_MEM_ITF ? ifu_icb_cmd_ready : 1'b0, lsu_icb_cmd_ready}),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Instantiate ICB Buffer\n    sirv_gnrl_icb_buffer #(\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .USR_W(1),\n        .OUTS_CNT_W(E203_BIU_OUTS_CNT_W),\n        .CMD_DP(E203_BIU_CMD_DP),\n        .RSP_DP(E203_BIU_RSP_DP),\n        .CMD_CUT_READY(E203_BIU_CMD_CUT_READY),\n        .RSP_CUT_READY(E203_BIU_RSP_CUT_READY)\n    ) icb_buffer (\n        .icb_buffer_active(),\n        .i_icb_cmd_valid(),\n        .i_icb_cmd_ready(),\n        .i_icb_cmd_read(),\n        .i_icb_cmd_addr(),\n        .i_icb_cmd_wdata(),\n        .i_icb_cmd_wmask(),\n        .i_icb_rsp_valid(),\n        .i_icb_rsp_ready(),\n        .o_icb_cmd_valid(),\n        .o_icb_cmd_ready(),\n        .o_icb_rsp_valid(),\n        .o_icb_rsp_ready(),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Instantiate ICB Splitter\n    sirv_gnrl_icb_splt #(\n        .FIFO_CUT_READY(E203_BIU_CMD_CUT_READY),\n        .SPLT_PTR_W(BIU_SPLT_I_NUM),\n        .USR_W(1),\n        .AW(E203_ADDR_SIZE),\n        .DW(E203_XLEN),\n        .ALLOW_DIFF(0),\n        .ALLOW_0CYCL_RSP(1),\n        .FIFO_OUTS_NUM(E203_BIU_OUTS_NUM),\n        .SPLT_NUM(BIU_SPLT_I_NUM),\n        .SPLT_PTR_1HOT(1)\n    ) icb_splitter (\n        .i_icb_splt_indic({ppi_region_indic, clint_region_indic, plic_region_indic, `E203_HAS_FIO ? fio_region_indic : {E203_ADDR_SIZE{1'b0}}}),\n        .i_icb_cmd_valid(),\n        .i_icb_cmd_ready(),\n        .i_icb_cmd_read(),\n        .i_icb_cmd_addr(),\n        .i_icb_cmd_wdata(),\n        .i_icb_cmd_wmask(),\n        .i_icb_rsp_valid(),\n        .i_icb_rsp_ready(),\n        .o_bus_icb_cmd_valid(),\n        .o_bus_icb_cmd_ready(),\n        .o_bus_icb_rsp_valid(),\n        .o_bus_icb_rsp_ready(),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // Active status\n    assign biu_active = (lsu_icb_cmd_valid || `E203_HAS_MEM_ITF ? ifu_icb_cmd_valid : 1'b0);\n\n    // LSU connections\n    assign lsu_icb_cmd_ready = icb_arbiter.i_bus_icb_cmd_ready[0];\n    assign icb_arbiter.i_bus_icb_cmd_valid[0] = lsu_icb_cmd_valid;\n    assign icb_arbiter.i_bus_icb_cmd_addr[0] = lsu_icb_cmd_addr;\n    assign icb_arbiter.i_bus_icb_cmd_read[0] = lsu_icb_cmd_read;\n    assign icb_arbiter.i_bus_icb_cmd_wdata[0] = lsu_icb_cmd_wdata;\n    assign icb_arbiter.i_bus_icb_cmd_wmask[0] = lsu_icb_cmd_wmask;\n    assign icb_arbiter.i_bus_icb_cmd_burst[0] = lsu_icb_cmd_burst;\n    assign icb_arbiter.i_bus_icb_cmd_beat[0] = lsu_icb_cmd_beat;\n    assign icb_arbiter.i_bus_icb_cmd_lock[0] = lsu_icb_cmd_lock;\n    assign icb_arbiter.i_bus_icb_cmd_excl[0] = lsu_icb_cmd_excl;\n    assign icb_arbiter.i_bus_icb_cmd_size[0] = lsu_icb_cmd_size;\n    assign lsu_icb_rsp_valid = icb_arbiter.o_icb_rsp_valid[0];\n    assign icb_arbiter.o_icb_rsp_ready[0] = lsu_icb_rsp_ready;\n    assign lsu_icb_rsp_err = icb_arbiter.o_icb_rsp_err[0];\n    assign lsu_icb_rsp_excl_ok = icb_arbiter.o_icb_rsp_excl_ok[0];\n    assign lsu_icb_rsp_rdata = icb_arbiter.o_icb_rsp_rdata[0];\n\n    // IFU connections (if enabled)\n    `ifdef E203_HAS_MEM_ITF\n    assign ifu_icb_cmd_ready = icb_arbiter.i_bus_icb_cmd_ready[1];\n    assign icb_arbiter.i_bus_icb_cmd_valid[1] = ifu_icb_cmd_valid;\n    assign icb_arbiter.i_bus_icb_cmd_addr[1] = ifu_icb_cmd_addr;\n    assign icb_arbiter.i_bus_icb_cmd_read[1] = ifu_icb_cmd_read;\n    assign icb_arbiter.i_bus_icb_cmd_wdata[1] = ifu_icb_cmd_wdata;\n    assign icb_arbiter.i_bus_icb_cmd_wmask[1] = ifu_icb_cmd_wmask;\n    assign icb_arbiter.i_bus_icb_cmd_burst[1] = ifu_icb_cmd_burst;\n    assign icb_arbiter.i_bus_icb_cmd_beat[1] = ifu_icb_cmd_beat;\n    assign icb_arbiter.i_bus_icb_cmd_lock[1] = ifu_icb_cmd_lock;\n    assign icb_arbiter.i_bus_icb_cmd_excl[1] = ifu_icb_cmd_excl;\n    assign icb_arbiter.i_bus_icb_cmd_size[1] = ifu_icb_cmd_size;\n    assign ifu_icb_rsp_valid = icb_arbiter.o_icb_rsp_valid[1];\n    assign icb_arbiter.o_icb_rsp_ready[1] = ifu_icb_rsp_ready;\n    assign ifu_icb_rsp_err = icb_arbiter.o_icb_rsp_err[1];\n    assign ifu_icb_rsp_excl_ok = icb_arbiter.o_icb_rsp_excl_ok[1];\n    assign ifu_icb_rsp_rdata = icb_arbiter.o_icb_rsp_rdata[1];\n    `endif\n\n    // Other connections to peripherals...\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 7, "code": "`ifndef E203_DEFS_SV\n`define E203_DEFS_SV\n\n// Global parameter definitions for E203 processor\n\n// Processor core parameters\n`define E203_CORE_NAME \"e203\"\n`define E203_HART_NUM 1\n`define E203_HART_ID_W 1\n`define E203_LIRQ_NUM 1\n\n// Debug parameters\n`define E203_DEBUG_HAS_DM 1\n`define E203_CFG_DEBUG_HAS_JTAG 1\n`define E203_DEBUG_HAS_JTAG `E203_CFG_DEBUG_HAS_JTAG\n\n// Instruction fetch unit parameters\n`define E203_OITF_DEPTH 4\n`define E203_ITAG_WIDTH 2\n\n// Register file parameters\n`define E203_RFREG_NUM 32\n`define E203_RFIDX_WIDTH 5\n\n// Data width parameters\n`define E203_XLEN 32\n`define E203_XLEN_MW 4\n`define E203_SYSMEM_DATA_WIDTH 32\n\n// Memory parameters\n`define E203_HAS_ITCM 1\n`define E203_HAS_DTCM 1\n`define E203_CFG_ITCM_ADDR_WIDTH 16\n`define E203_CFG_DTCM_ADDR_WIDTH 16\n`define E203_ITCM_DATA_WIDTH 64\n`define E203_DTCM_DATA_WIDTH 32\n`define E203_ITCM_RAM_DP (2**(`E203_CFG_ITCM_ADDR_WIDTH - 3)) // 64-bit wide memory\n`define E203_DTCM_RAM_DP (2**(`E203_CFG_DTCM_ADDR_WIDTH - 2)) // 32-bit wide memory\n`define E203_ITCM_RAM_AW (`E203_CFG_ITCM_ADDR_WIDTH - 3)\n`define E203_DTCM_RAM_AW (`E203_CFG_DTCM_ADDR_WIDTH - 2)\n\n// ALU parameters\n`define E203_MULDIV_ADDER_WIDTH 35\n`define E203_ALU_ADDER_WIDTH `E203_MULDIV_ADDER_WIDTH\n\n// LSU parameters\n`define E203_LSU_OUTS_NUM 1\n`define E203_LSU_OUTS_NUM_IS_1\n`define E203_SUPPORT_AMO 1\n\n// BIU parameters\n`define E203_BIU_OUTS_NUM `E203_LSU_OUTS_NUM\n`define E203_BIU_OUTS_NUM_IS_1\n`define E203_BIU_CMD_CUT_READY 1\n`define E203_BIU_RSP_CUT_READY 1\n`define E203_BIU_CMD_DP 1\n`define E203_BIU_RSP_DP_RAW 1\n`define E203_BIU_RSP_DP `E203_BIU_RSP_DP_RAW\n`define E203_BIU_OUTS_CNT_W 1\n\n// Address space parameters\n`define E203_CFG_ADDR_SIZE_IS_32\n`define E203_ADDR_SIZE 32\n`define E203_PC_SIZE 32\n\n// Decode information parameters\n`define E203_DECINFO_GRP_WIDTH 3\n`define E203_DECINFO_GRP_FPU_WIDTH 2\n`define E203_DECINFO_FPU_GRP_LSB 12\n`define E203_DECINFO_FPU_GRP_MSB (`E203_DECINFO_FPU_GRP_LSB + `E203_DECINFO_GRP_FPU_WIDTH - 1)\n`define E203_DECINFO_FPU_RM_LSB (`E203_DECINFO_FPU_GRP_MSB + 1)\n`define E203_DECINFO_FPU_RM_MSB (`E203_DECINFO_FPU_RM_LSB + 2)\n`define E203_DECINFO_FPU_USERM_LSB (`E203_DECINFO_FPU_RM_MSB + 1)\n`define E203_DECINFO_FPU_USERM_MSB `E203_DECINFO_FPU_USERM_LSB\n`define E203_DECINFO_WIDTH 14\n\n// Module interface parameters\n`define E203_INSTR_SIZE 32\n`define E203_PC_SIZE 32\n`define E203_RFIDX_WIDTH 5\n\n`endif // E203_DEFS_SV", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 4, "code": "module e203_dtcm_ctrl #(\n    parameter E203_DTCM_ADDR_WIDTH = 16,\n    parameter E203_DTCM_DATA_WIDTH = 32,\n    parameter E203_DTCM_WMSK_WIDTH = 4,\n    parameter E203_DTCM_RAM_AW = E203_DTCM_ADDR_WIDTH - 2,\n    parameter E203_DTCM_RAM_DP = 2 ** (E203_DTCM_ADDR_WIDTH - 2),\n    parameter E203_DTCM_RAM_DW = E203_DTCM_DATA_WIDTH,\n    parameter E203_DTCM_RAM_MW = E203_DTCM_WMSK_WIDTH,\n    parameter E203_HAS_DTCM_EXTITF = 0,\n    parameter E203_DTCM_OUTS_NUM = 1\n) (\n    input  logic clk,\n    input  logic rst_n,\n    input  logic test_mode,\n    input  logic tcm_cgstop,\n\n    output logic dtcm_active,\n\n    // LSU ICB Bus Interface\n    input  logic lsu2dtcm_icb_cmd_valid,\n    output logic lsu2dtcm_icb_cmd_ready,\n    input  logic [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input  logic lsu2dtcm_icb_cmd_read,\n    input  logic [E203_DTCM_DATA_WIDTH-1:0] lsu2dtcm_icb_cmd_wdata,\n    input  logic [E203_DTCM_WMSK_WIDTH-1:0] lsu2dtcm_icb_cmd_wmask,\n    output logic lsu2dtcm_icb_rsp_valid,\n    input  logic lsu2dtcm_icb_rsp_ready,\n    output logic lsu2dtcm_icb_rsp_err,\n    output logic [E203_DTCM_DATA_WIDTH-1:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Bus Interface (Optional)\n    input  logic ext2dtcm_icb_cmd_valid,\n    output logic ext2dtcm_icb_cmd_ready,\n    input  logic [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input  logic ext2dtcm_icb_cmd_read,\n    input  logic [E203_DTCM_DATA_WIDTH-1:0] ext2dtcm_icb_cmd_wdata,\n    input  logic [E203_DTCM_WMSK_WIDTH-1:0] ext2dtcm_icb_cmd_wmask,\n    output logic ext2dtcm_icb_rsp_valid,\n    input  logic ext2dtcm_icb_rsp_ready,\n    output logic ext2dtcm_icb_rsp_err,\n    output logic [E203_DTCM_DATA_WIDTH-1:0] ext2dtcm_icb_rsp_rdata,\n\n    // DTCM RAM Interface\n    output logic dtcm_ram_cs,\n    output logic dtcm_ram_we,\n    output logic [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output logic [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input  logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output logic clk_dtcm_ram\n);\n\n    // Internal signals\n    logic [E203_DTCM_DATA_WIDTH-1:0] dtcm_ram_data_in;\n    logic [E203_DTCM_DATA_WIDTH-1:0] dtcm_ram_data_out;\n    logic [E203_DTCM_WMSK_WIDTH-1:0] dtcm_ram_wem_int;\n    logic dtcm_ram_we_int;\n\n    assign dtcm_ram_data_in = lsu2dtcm_icb_cmd_wdata;\n    assign dtcm_ram_we_int = lsu2dtcm_icb_cmd_read ? 1'b0 : 1'b1;\n    assign dtcm_ram_wem_int = lsu2dtcm_icb_cmd_wmask;\n\n    sirv_sram_icb_ctrl #(\n        .DW(E203_DTCM_DATA_WIDTH),\n        .AW(E203_DTCM_ADDR_WIDTH),\n        .MW(E203_DTCM_WMSK_WIDTH),\n        .AW_LSB(2),\n        .USR_W(1)\n    ) u_dtcm_ram_ctrl (\n        .sram_ctrl_active(dtcm_active),\n        .tcm_cgstop(tcm_cgstop),\n        .i_icb_cmd_valid(lsu2dtcm_icb_cmd_valid),\n        .i_icb_cmd_ready(lsu2dtcm_icb_cmd_ready),\n        .i_icb_cmd_read(lsu2dtcm_icb_cmd_read),\n        .i_icb_cmd_addr(lsu2dtcm_icb_cmd_addr),\n        .i_icb_cmd_wdata(lsu2dtcm_icb_cmd_wdata),\n        .i_icb_cmd_wmask(lsu2dtcm_icb_cmd_wmask),\n        .i_icb_cmd_usr(1'b0),\n        .i_icb_rsp_valid(lsu2dtcm_icb_rsp_valid),\n        .i_icb_rsp_ready(lsu2dtcm_icb_rsp_ready),\n        .i_icb_rsp_rdata(lsu2dtcm_icb_rsp_rdata),\n        .i_icb_rsp_usr(1'b0),\n        .ram_cs(dtcm_ram_cs),\n        .ram_we(dtcm_ram_we),\n        .ram_addr(dtcm_ram_addr),\n        .ram_wem(dtcm_ram_wem),\n        .ram_din(dtcm_ram_din),\n        .ram_dout(dtcm_ram_dout),\n        .clk_ram(clk_dtcm_ram),\n        .test_mode(test_mode),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    assign dtcm_ram_we = dtcm_ram_we_int;\n    assign dtcm_ram_wem = dtcm_ram_wem_int;\n    assign dtcm_ram_din = dtcm_ram_data_in;\n    assign lsu2dtcm_icb_rsp_rdata = dtcm_ram_data_out;\n\n    // External interface is only valid when E203_HAS_DTCM_EXTITF is defined\n    generate\n        if (E203_HAS_DTCM_EXTITF) begin\n            sirv_gnrl_icb_arbt #(\n                .ARBT_SCHEME(0),\n                .ALLOW_0CYCL_RSP(0),\n                .FIFO_OUTS_NUM(E203_DTCM_OUTS_NUM),\n                .FIFO_CUT_READY(0),\n                .USR_W(1),\n                .ARBT_NUM(2),\n                .AW(E203_DTCM_ADDR_WIDTH),\n                .DW(E203_DTCM_DATA_WIDTH),\n                .ARBT_PTR_W(1)\n            ) u_arbitrator (\n                .o_icb_cmd_valid(lsu2dtcm_icb_cmd_valid),\n                .o_icb_cmd_ready(lsu2dtcm_icb_cmd_ready),\n                .o_icb_cmd_read(lsu2dtcm_icb_cmd_read),\n                .o_icb_cmd_addr(lsu2dtcm_icb_cmd_addr),\n                .o_icb_cmd_wdata(lsu2dtcm_icb_cmd_wdata),\n                .o_icb_cmd_wmask(lsu2dtcm_icb_cmd_wmask),\n                .o_icb_rsp_valid(lsu2dtcm_icb_rsp_valid),\n                .o_icb_rsp_ready(lsu2dtcm_icb_rsp_ready),\n                .o_icb_rsp_err(lsu2dtcm_icb_rsp_err),\n                .o_icb_rsp_rdata(lsu2dtcm_icb_rsp_rdata),\n                .i_bus_icb_cmd_valid({ext2dtcm_icb_cmd_valid, lsu2dtcm_icb_cmd_valid}),\n                .i_bus_icb_cmd_ready({ext2dtcm_icb_cmd_ready, lsu2dtcm_icb_cmd_ready}),\n                .i_bus_icb_cmd_read({ext2dtcm_icb_cmd_read, lsu2dtcm_icb_cmd_read}),\n                .i_bus_icb_cmd_addr({ext2dtcm_icb_cmd_addr, lsu2dtcm_icb_cmd_addr}),\n                .i_bus_icb_cmd_wdata({ext2dtcm_icb_cmd_wdata, lsu2dtcm_icb_cmd_wdata}),\n                .i_bus_icb_cmd_wmask({ext2dtcm_icb_cmd_wmask, lsu2dtcm_icb_cmd_wmask}),\n                .i_bus_icb_rsp_valid({ext2dtcm_icb_rsp_valid, lsu2dtcm_icb_rsp_valid}),\n                .i_bus_icb_rsp_ready({ext2dtcm_icb_rsp_ready, lsu2dtcm_icb_rsp_ready}),\n                .i_bus_icb_rsp_err({ext2dtcm_icb_rsp_err, lsu2dtcm_icb_rsp_err}),\n                .i_bus_icb_rsp_rdata({ext2dtcm_icb_rsp_rdata, lsu2dtcm_icb_rsp_rdata}),\n                .clk(clk),\n                .rst_n(rst_n)\n            );\n        end\n        else begin\n            assign ext2dtcm_icb_cmd_ready = 1'b0;\n            assign ext2dtcm_icb_rsp_valid = 1'b0;\n            assign ext2dtcm_icb_rsp_err = 1'b0;\n            assign ext2dtcm_icb_rsp_rdata = 32'd0;\n        end\n    endgenerate\n\n    assign dtcm_active = lsu2dtcm_icb_cmd_valid && !rst_n;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 5, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 5, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 4, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 1, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 2, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 3, "code": "// Define the module\nmodule example_module(\n    input  logic clk,       // Clock signal\n    input  logic rst_n,     // Active-low reset\n    input  logic [7:0] data_in, // 8-bit input data\n    output logic [7:0] data_out // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Always block for sequential logic (registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset condition\n        reg_data <= 8'd0;\n    end else begin\n        // Normal operation\n        reg_data <= data_in;\n    end\nend\n\n// Continuous assignment for output\nassign data_out = reg_data;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 4, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_branchslv(\n    input logic clk,\n    input logic rst_n,\n\n    // Command inputs\n    input logic cmt_i_valid,\n    output logic cmt_i_ready,\n    input logic cmt_i_rv32,\n    input logic cmt_i_dret,\n    input logic cmt_i_mret,\n    input logic cmt_i_fencei,\n    input logic cmt_i_bjp,\n    input logic cmt_i_bjp_prdt,\n    input logic cmt_i_bjp_rslv,\n    input logic [E203_PC_SIZE-1:0] cmt_i_pc,\n    input logic [E203_XLEN-1:0] cmt_i_imm,\n    input logic [E203_PC_SIZE-1:0] csr_epc_r,\n    input logic [E203_PC_SIZE-1:0] csr_dpc_r,\n\n    // Flush signals\n    input logic nonalu_excpirq_flush_req_raw,\n    input logic brchmis_flush_ack,\n    output logic brchmis_flush_req,\n    output logic [E203_PC_SIZE-1:0] brchmis_flush_add_op1,\n    output logic [E203_PC_SIZE-1:0] brchmis_flush_add_op2,\n    output logic [E203_PC_SIZE-1:0] brchmis_flush_pc,\n\n    // Special instruction enables\n    output logic cmt_mret_ena,\n    output logic cmt_dret_ena,\n    output logic cmt_fencei_ena\n);\n\n    // Flush need generation\n    logic flush_need;\n    assign flush_need = (cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv)) | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n\n    // Flush target calculation\n    always_comb begin\n        if (cmt_i_dret) begin\n            brchmis_flush_add_op1 = csr_dpc_r;\n            brchmis_flush_add_op2 = '0;\n        end else if (cmt_i_mret) begin\n            brchmis_flush_add_op1 = csr_epc_r;\n            brchmis_flush_add_op2 = '0;\n        end else if (cmt_i_bjp) begin\n            if (cmt_i_bjp_prdt && !cmt_i_bjp_rslv) begin\n                if (E203_CFG_ADDR_SIZE_IS_32) begin\n                    brchmis_flush_add_op1 = cmt_i_pc + 4;\n                    brchmis_flush_add_op2 = '0;\n                end else begin\n                    brchmis_flush_add_op1 = cmt_i_pc + 2;\n                    brchmis_flush_add_op2 = '0;\n                end\n            end else if (!cmt_i_bjp_prdt && cmt_i_bjp_rslv) begin\n                brchmis_flush_add_op1 = cmt_i_pc;\n                brchmis_flush_add_op2 = cmt_i_imm;\n            end else begin\n                brchmis_flush_add_op1 = '0;\n                brchmis_flush_add_op2 = '0;\n            end\n        end else begin\n            brchmis_flush_add_op1 = '0;\n            brchmis_flush_add_op2 = '0;\n        end\n    end\n\n    // Pipeline flush control\n    assign brchmis_flush_req = cmt_i_valid & flush_need & ~nonalu_excpirq_flush_req_raw;\n\n    // Prioritizing flush sources\n    assign cmt_i_ready = !flush_need | ~nonalu_excpirq_flush_req_raw | brchmis_flush_ack;\n\n    // Special signal commit\n    assign cmt_mret_ena = cmt_i_valid & cmt_i_mret & brchmis_flush_ack;\n    assign cmt_dret_ena = cmt_i_valid & cmt_i_dret & brchmis_flush_ack;\n    assign cmt_fencei_ena = cmt_i_valid & cmt_i_fencei & brchmis_flush_ack;\n\n    // Detailed brchmis_flush_pc calculation\n    `ifdef E203_TIMING_BOOST\n        always_comb begin\n            if (cmt_i_fencei | (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv)) begin\n                if (E203_CFG_ADDR_SIZE_IS_32) begin\n                    brchmis_flush_pc = cmt_i_pc + 4;\n                end else begin\n                    brchmis_flush_pc = cmt_i_pc + 2;\n                end\n            end else if (cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv) begin\n                brchmis_flush_pc = cmt_i_pc + cmt_i_imm;\n            end else if (cmt_i_dret) begin\n                brchmis_flush_pc = csr_dpc_r;\n            end else if (cmt_i_mret) begin\n                brchmis_flush_pc = csr_epc_r;\n            end else begin\n                brchmis_flush_pc = csr_epc_r;\n            end\n        end\n    `else\n        assign brchmis_flush_pc = '0;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 5, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 5, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 4, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 5, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 2, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 5, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 3, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 2, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 15, "code": "module example_module(\n    input  logic clk,       // Clock input\n    input  logic rst_n,     // Active-low reset\n    input  logic [7:0] data_in, // Input data\n    output logic [7:0] data_out // Output data\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 9, "code": "// e203_extend_csr module definition\nmodule e203_extend_csr #(\n    parameter E203_HAS_CSR_NICE = 0\n)(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire nice_csr_valid,\n    output wire nice_csr_ready,\n    input  wire [31:0] nice_csr_addr,\n    input  wire nice_csr_wr,\n    input  wire [31:0] nice_csr_wdata,\n    output wire [31:0] nice_csr_rdata\n);\n\n// Always ready by default, no actual CSR access implemented\nassign nice_csr_ready = 1'b1;\nassign nice_csr_rdata  = '0;\n\n// No functional implementation in this stub module\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset state (no effect in this stub)\n    end else begin\n        // No actual operation performed\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 6, "code": "module e203_ifu_ift2icb (\n    input logic itcm_nohold,\n    input logic ifu_req_valid,\n    input logic [E203_PC_SIZE-1:0] ifu_req_pc,\n    input logic ifu_req_seq,\n    input logic ifu_req_seq_rv32,\n    input logic [E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input logic ifu_rsp_ready,\n    input logic clk,\n    input logic rst_n,\n\n    output logic ifu_req_ready,\n    output logic ifu_rsp_valid,\n    output logic ifu_rsp_err,\n    output logic [31:0] ifu_rsp_instr,\n\n    // ITCM Interface\n    output logic ifu2itcm_icb_cmd_valid,\n    input logic ifu2itcm_icb_cmd_ready,\n    output logic [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n    input logic ifu2itcm_icb_rsp_valid,\n    output logic ifu2itcm_icb_rsp_ready,\n    input logic ifu2itcm_icb_rsp_err,\n    input logic [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n\n    // System Memory Interface\n    output logic ifu2biu_icb_cmd_valid,\n    input logic ifu2biu_icb_cmd_ready,\n    output logic [E203_ADDR_SIZE-1:0] ifu2biu_icb_cmd_addr,\n    input logic ifu2biu_icb_rsp_valid,\n    output logic ifu2biu_icb_rsp_ready,\n    input logic ifu2biu_icb_rsp_err,\n    input logic [E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata\n);\n\n// Internal signals and registers\nlogic [1:0] icb_state_r, icb_state_nxt;\nlogic icb_state_ena;\n\n// State machine implementation\nalways_comb begin\n    icb_state_nxt = icb_state_r;\n    icb_state_ena = 1'b0;\n\n    case (icb_state_r)\n        ICB_STATE_IDLE: begin\n            if (ifu_req_valid) begin\n                icb_state_nxt = ICB_STATE_1ST;\n                icb_state_ena = 1'b1;\n            end\n        end\n        ICB_STATE_1ST: begin\n            if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid) begin\n                if (req_need_2uop_r) begin\n                    if (ifu2itcm_icb_rsp_valid || ifu2biu_icb_rsp_valid) begin\n                        icb_state_nxt = ICB_STATE_WAIT2ND;\n                        icb_state_ena = 1'b1;\n                    end else begin\n                        icb_state_nxt = ICB_STATE_2ND;\n                        icb_state_ena = 1'b1;\n                    end\n                end else if (ifu_req_valid) begin\n                    icb_state_nxt = ICB_STATE_1ST;\n                    icb_state_ena = 1'b1;\n                end else begin\n                    icb_state_nxt = ICB_STATE_IDLE;\n                    icb_state_ena = 1'b1;\n                end\n            end\n        end\n        ICB_STATE_WAIT2ND: begin\n            if (ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready) begin\n                icb_state_nxt = ICB_STATE_2ND;\n                icb_state_ena = 1'b1;\n            end\n        end\n        ICB_STATE_2ND: begin\n            if (ifu_rsp_ready) begin\n                if (ifu_req_valid) begin\n                    icb_state_nxt = ICB_STATE_1ST;\n                    icb_state_ena = 1'b1;\n                end else begin\n                    icb_state_nxt = ICB_STATE_IDLE;\n                    icb_state_ena = 1'b1;\n                end\n            end\n        end\n        default: begin\n            icb_state_nxt = ICB_STATE_IDLE;\n            icb_state_ena = 1'b1;\n        end\n    endcase\nend\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        icb_state_r <= ICB_STATE_IDLE;\n    end else if (icb_state_ena) begin\n        icb_state_r <= icb_state_nxt;\n    end\nend\n\n// Request handshake signals\nlogic ifu_req_hsked;\nassign ifu_req_hsked = ifu_req_valid && ifu_req_ready;\n\n// ICB command handshake signals\nlogic ifu_icb_cmd_hsked;\nassign ifu_icb_cmd_hsked = ifu2itcm_icb_cmd_valid && ifu2itcm_icb_cmd_ready || \n                           ifu2biu_icb_cmd_valid && ifu2biu_icb_cmd_ready;\n\n// ICB response handshake signals\nlogic ifu_icb_rsp_hsked;\nassign ifu_icb_rsp_hsked = ifu2itcm_icb_rsp_valid && ifu2itcm_icb_rsp_ready || \n                           ifu2biu_icb_rsp_valid && ifu2biu_icb_rsp_ready;\n\n// Internal response handshake signals\nlogic i_ifu_rsp_hsked;\nassign i_ifu_rsp_hsked = ifu_rsp_valid && ifu_rsp_ready;\n\n// State machine control\nassign ifu_req_ready = ifu2itcm_icb_cmd_ready || ifu2biu_icb_cmd_ready && \n                       (icb_state_r == ICB_STATE_IDLE || \n                        (icb_state_r == ICB_STATE_1ST && ifu2itcm_icb_rsp_valid && !req_need_2uop_r) || \n                        (icb_state_r == ICB_STATE_2ND && ifu_rsp_ready));\n\n// Response generation\nassign ifu_rsp_valid = i_ifu_rsp_valid;\nassign ifu_rsp_err = i_ifu_rsp_err;\nassign ifu_rsp_instr = i_ifu_rsp_instr;\n\n// ITCM interface\nassign ifu2itcm_icb_rsp_ready = ifu2itcm_icb_rsp_valid && ifu_rsp_ready;\n\n// System memory interface\nassign ifu2biu_icb_rsp_ready = ifu2biu_icb_rsp_valid && ifu_rsp_ready;\n\n// ... (Other signal assignments and logic not shown for brevity)\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = reg_data;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 7, "code": "// e203_cpu module definition\nmodule e203_cpu(\n    // Core interfaces\n    output logic [E203_PC_SIZE-1:0] inspect_pc,\n    output logic inspect_dbg_irq,\n    output logic inspect_mem_cmd_valid,\n    output logic inspect_mem_cmd_ready,\n    output logic inspect_mem_rsp_valid,\n    output logic inspect_mem_rsp_ready,\n    output logic inspect_core_clk,\n    output logic core_csr_clk,\n    output logic core_wfi,\n    output logic tm_stop,\n    input logic [E203_PC_SIZE-1:0] pc_rtvec,\n    input logic [E203_HART_ID_W-1:0] core_mhartid,\n    input logic dbg_irq_a,\n    input logic ext_irq_a,\n    input logic sft_irq_a,\n    input logic tmr_irq_a,\n\n    // ITCM interfaces (optional)\n    output logic itcm_ls,\n    output logic itcm_ram_cs,\n    output logic itcm_ram_we,\n    output logic [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    output logic [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    output logic [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    input logic [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    output logic clk_itcm_ram,\n\n    // DTCM interfaces (optional)\n    output logic rst_dtcm,\n    output logic dtcm_ls,\n    output logic dtcm_ram_cs,\n    output logic dtcm_ram_we,\n    output logic [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output logic [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input logic [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n\n    // Debug related interface\n    output logic [E203_PC_SIZE-1:0] cmt_dpc,\n    output logic cmt_dpc_ena,\n    output logic [2:0] cmt_dcause,\n    output logic cmt_dcause_ena,\n    output logic dbg_irq_r,\n    output logic wr_dcsr_ena,\n    output logic wr_dpc_ena,\n    output logic wr_dscratch_ena,\n    output logic [31:0] wr_csr_nxt,\n    input logic [31:0] dcsr_r,\n    input logic [E203_PC_SIZE-1:0] dpc_r,\n    input logic [31:0] dscratch_r,\n    input logic dbg_mode,\n    input logic dbg_halt_r,\n    input logic dbg_step_r,\n    input logic dbg_ebreakm_r,\n    input logic dbg_stopcycle,\n\n    // External-agent ICB to ITCM (optional)\n    input logic ext2itcm_icb_cmd_valid,\n    output logic ext2itcm_icb_cmd_ready,\n    input logic [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input logic ext2itcm_icb_cmd_read,\n    input logic [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input logic [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    output logic ext2itcm_icb_rsp_valid,\n    input logic ext2itcm_icb_rsp_ready,\n    output logic ext2itcm_icb_rsp_err,\n    output logic [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n\n    // External-agent ICB to DTCM (optional)\n    input logic ext2dtcm_icb_cmd_valid,\n    output logic ext2dtcm_icb_cmd_ready,\n    input logic [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input logic ext2dtcm_icb_cmd_read,\n    input logic [E203_XLEN-1:0] ext2dtcm_icb_cmd_wdata,\n    input logic [E203_XLEN/8-1:0] ext2dtcm_icb_cmd_wmask,\n    output logic ext2dtcm_icb_rsp_valid,\n    input logic ext2dtcm_icb_rsp_ready,\n    output logic ext2dtcm_icb_rsp_err,\n    output logic [E203_XLEN-1:0] ext2dtcm_icb_rsp_rdata,\n\n    // Other ICB interface (e.g., CLINT, PLIC, FIO)\n    // ... (other interface signals)\n\n    // Clock and Reset signals\n    input logic clk,\n    input logic rst_n\n);\n\n// Instantiation of sub-modules\ne203_reset_ctrl u_reset_ctrl(\n    .clk(clk),\n    .rst_n(rst_n),\n    .test_mode(1'b0),\n    .rst_core(rst_core),\n    .rst_itcm(rst_itcm),\n    .rst_dtcm(rst_dtcm),\n    .rst_aon(rst_aon)\n);\n\ne203_clk_ctrl u_clk_ctrl(\n    .clk(clk),\n    .rst_n(rst_n),\n    .test_mode(1'b0),\n    .core_cgstop(core_cgstop),\n    .core_ifu_active(core_ifu_active),\n    .core_exu_active(core_exu_active),\n    .core_lsu_active(core_lsu_active),\n    .core_biu_active(core_biu_active),\n    .core_wfi(core_wfi),\n    .itcm_active(itcm_active),\n    .dtcm_active(dtcm_active),\n    .clk_aon(clk_aon),\n    .clk_core_ifu(clk_core_ifu),\n    .clk_core_exu(clk_core_exu),\n    .clk_core_lsu(clk_core_lsu),\n    .clk_core_biu(clk_core_biu),\n    .clk_itcm(clk_itcm),\n    .clk_dtcm(clk_dtcm)\n);\n\ne203_irq_sync u_irq_sync(\n    .clk(clk),\n    .rst_n(rst_n),\n    .dbg_irq_a(dbg_irq_a),\n    .ext_irq_a(ext_irq_a),\n    .sft_irq_a(sft_irq_a),\n    .tmr_irq_a(tmr_irq_a),\n    .dbg_irq_r(dbg_irq_r),\n    .ext_irq_r(ext_irq_r),\n    .sft_irq_r(sft_irq_r),\n    .tmr_irq_r(tmr_irq_r)\n);\n\ne203_core u_core(\n    // Core interfaces\n    .inspect_pc(inspect_pc),\n    .core_wfi(core_wfi),\n    .tm_stop(tm_stop),\n    .pc_rtvec(pc_rtvec),\n    .core_mhartid(core_mhartid),\n    .dbg_irq_r(dbg_irq_r),\n    .ext_irq_r(ext_irq_r),\n    .sft_irq_r(sft_irq_r),\n    .tmr_irq_r(tmr_irq_r),\n    .wr_dcsr_ena(wr_dcsr_ena),\n    .wr_dpc_ena(wr_dpc_ena),\n    .wr_dscratch_ena(wr_dscratch_ena),\n    .wr_csr_nxt(wr_csr_nxt),\n    .dcsr_r(dcsr_r),\n    .dpc_r(dpc_r),\n    .dscratch_r(dscratch_r),\n    .dbg_mode(dbg_mode),\n    .dbg_halt_r(dbg_halt_r),\n    .dbg_step_r(dbg_step_r),\n    .dbg_ebreakm_r(dbg_ebreakm_r),\n    .dbg_stopcycle(dbg_stopcycle),\n    // Other interfaces...\n);\n\n`ifdef E203_HAS_ITCM\ne203_itcm_ctrl u_itcm_ctrl(\n    // ITCM interfaces\n    .clk(clk),\n    .rst_n(rst_n),\n    .itcm_ls(itcm_ls),\n    .itcm_ram_cs(itcm_ram_cs),\n    .itcm_ram_we(itcm_ram_we),\n    .itcm_ram_addr(itcm_ram_addr),\n    .itcm_ram_wem(itcm_ram_wem),\n    .itcm_ram_din(itcm_ram_din),\n    .itcm_ram_dout(itcm_ram_dout),\n    .clk_itcm_ram(clk_itcm_ram)\n);\n`endif\n\n`ifdef E203_HAS_DTCM\ne203_dtcm_ctrl u_dtcm_ctrl(\n    // DTCM interfaces\n    .clk(clk),\n    .rst_n(rst_n),\n    .rst_dtcm(rst_dtcm),\n    .dtcm_ls(dtcm_ls),\n    .dtcm_ram_cs(dtcm_ram_cs),\n    .dtcm_ram_we(dtcm_ram_we),\n    .dtcm_ram_addr(dtcm_ram_addr),\n    .dtcm_ram_wem(dtcm_ram_wem),\n    .dtcm_ram_din(dtcm_ram_din),\n    .dtcm_ram_dout(dtcm_ram_dout)\n);\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic reset_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 5, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 17, "code": "module hardware_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 6, "code": "module hardware_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 5, "code": "module example_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] data_reg;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;  // Reset to zero\n    end else begin\n        data_reg <= data_in;  // Capture input data on rising clock edge\n    end\nend\n\n// Combinatorial logic\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 10, "code": "// Define the module with no inputs or outputs\nmodule empty_module();\n\n  // No logic or wires are needed for this empty module\n  // You can add comments or placeholder logic if desired\n  // Example placeholder logic (not functional):\n  // reg dummy_reg;\n  // initial dummy_reg = 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals and variables\nlogic [7:0] internal_reg;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Combinational logic\nalways_comb begin\n    data_out = internal_reg;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 6, "code": "module example_module(\n    input  logic clk,  \n    input  logic rst_n, \n    input  logic [7:0] data_in, \n    output logic [7:0] data_out\n);\n\nlogic [7:0] reg_data;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 8, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_alu_lsuagu (\n    input logic clk,\n    input logic rst_n,\n\n    // Handshake signals\n    input logic agu_i_valid,\n    output logic agu_i_ready,\n    output logic agu_o_valid,\n    input logic agu_o_ready,\n\n    // AGU datapath\n    input logic [`E203_XLEN-1:0] agu_i_rs1,\n    input logic [`E203_XLEN-1:0] agu_i_rs2,\n    input logic [`E203_XLEN-1:0] agu_i_imm,\n    input logic [`E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input logic [`E203_ITAG_WIDTH-1:0] agu_i_itag,\n\n    // LSU handshake signals\n    output logic agu_icb_cmd_valid,\n    input logic agu_icb_cmd_ready,\n    input logic agu_icb_rsp_valid,\n    output logic agu_icb_rsp_ready,\n    input logic agu_icb_rsp_err,\n    input logic agu_icb_rsp_excl_ok,\n    input logic [`E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    // Flush signals\n    input logic flush_req,\n    input logic flush_pulse,\n\n    // Status signals\n    output logic amo_wait,\n    output logic agu_o_cmt_misalgn,\n    output logic agu_o_cmt_ld,\n    output logic agu_o_cmt_stamo,\n    output logic agu_o_cmt_buserr,\n    output logic [`E203_ADDR_SIZE-1:0] agu_o_cmt_badaddr,\n    output logic agu_o_wbck_err,\n    output logic [`E203_XLEN-1:0] agu_o_wbck_wdat,\n    output logic agu_i_longpipe,\n\n    // Shared datapath signals\n    output logic [`E203_XLEN-1:0] agu_req_alu_op1,\n    output logic [`E203_XLEN-1:0] agu_req_alu_op2,\n    output logic agu_req_alu_swap,\n    output logic agu_req_alu_add,\n    output logic agu_req_alu_and,\n    output logic agu_req_alu_or,\n    output logic agu_req_alu_xor,\n    output logic agu_req_alu_max,\n    output logic agu_req_alu_min,\n    output logic agu_req_alu_maxu,\n    output logic agu_req_alu_minu,\n    input logic [`E203_XLEN-1:0] agu_req_alu_res,\n\n    // Shared buffer signals\n    output logic agu_sbf_0_ena,\n    output logic [`E203_XLEN-1:0] agu_sbf_0_nxt,\n    input logic [`E203_XLEN-1:0] agu_sbf_0_r,\n    output logic agu_sbf_1_ena,\n    output logic [`E203_XLEN-1:0] agu_sbf_1_nxt,\n    input logic [`E203_XLEN-1:0] agu_sbf_1_r\n);\n\n    // LSU command signals\n    assign agu_icb_cmd_addr = {`E203_ADDR_SIZE{1'b0}}; // Default address (must be modified)\n    assign agu_icb_cmd_read = 1'b0; // Default read/write (must be modified)\n    assign agu_icb_cmd_wdata = `E203_XLEN{1'b0}; // Default write data (must be modified)\n    assign agu_icb_cmd_wmask = `E203_XLEN/8{1'b0}; // Default write mask (must be modified)\n    assign agu_icb_cmd_back2agu = 1'b0; // Default back-to-AGU (must be modified)\n    assign agu_icb_cmd_lock = 1'b0; // Lock signal (not used in this implementation)\n    assign agu_icb_cmd_excl = 1'b0; // Exclusive access (must be modified for AMO)\n    assign agu_icb_cmd_size = 2'b10; // Default size (word, must be modified)\n    assign agu_icb_cmd_itag = `E203_ITAG_WIDTH{1'b0}; // Default instruction tag (must be modified)\n    assign agu_icb_cmd_usign = 1'b0; // Unsigned access (must be modified)\n\n    // AGU state machine and control logic (must be implemented)\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            // Reset state\n            agu_i_ready <= 1'b0;\n            agu_o_valid <= 1'b0;\n            // ... other state registers\n        end else begin\n            // Implementation depends on specific state machine transitions\n            // ... update state registers based on input signals\n        end\n    end\n\n    // Exception handling logic (must be implemented)\n    always_comb begin\n        agu_o_cmt_misalgn = 1'b0; // Misalignment exception (must be calculated)\n        agu_o_cmt_buserr = 1'b0; // Bus error exception (must be calculated)\n        agu_o_cmt_badaddr = `E203_ADDR_SIZE{1'b0}; // Address causing exception (must be calculated)\n    end\n\n    // LSU command generation logic (must be implemented)\n    always_comb begin\n        agu_icb_cmd_valid = 1'b0; // Command valid (must be generated)\n        agu_icb_rsp_ready = 1'b0; // Response ready (must be generated)\n        // ... other LSU command signals\n    end\n\n    // Shared datapath control (must be implemented)\n    always_comb begin\n        agu_req_alu_op1 = `E203_XLEN{1'b0}; // Operand 1 (must be calculated)\n        agu_req_alu_op2 = `E203_XLEN{1'b0}; // Operand 2 (must be calculated)\n        agu_req_alu_swap = 1'b0; // SWAP operation (must be calculated)\n        agu_req_alu_add = 1'b0; // ADD operation (must be calculated)\n        // ... other ALU control signals\n    end\n\n    // Shared buffer control (must be implemented)\n    always_comb begin\n        agu_sbf_0_ena = 1'b0; // Enable for buffer 0 (must be calculated)\n        agu_sbf_0_nxt = `E203_XLEN{1'b0}; // Next value for buffer 0 (must be calculated)\n        agu_sbf_1_ena = 1'b0; // Enable for buffer 1 (must be calculated)\n        agu_sbf_1_nxt = `E203_XLEN{1'b0}; // Next value for buffer 1 (must be calculated)\n    end\n\n    // Write-back data processing (must be implemented)\n    always_comb begin\n        agu_o_wbck_wdat = `E203_XLEN{1'b0}; // Write-back data (must be calculated)\n        agu_o_wbck_err = 1'b0; // Write-back error (must be calculated)\n    end\n\n    // State machine implementation (must be completed)\n    // ... state machine logic, state transitions, and control signals\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 11, "code": "module example_module (\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 3, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 4, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Example registers and combinational logic\nreg [7:0] internal_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 7, "code": "module hardware_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0] data_in,  // 8-bit input data\n    output logic [7:0] data_out  // 8-bit output data\n);\n\n// Internal signals and registers\nlogic [7:0] reg_data;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset condition: Clear the register\n        reg_data <= 8'd0;\n    end else begin\n        // Normal operation: Update the register with input data\n        reg_data <= data_in;\n    end\nend\n\n// Continuous assignment for output\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 3, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 7, "code": "module my_module(\n    input  logic        clk,\n    input  logic        rst_n,\n    input  logic [7:0]  data_in,\n    output logic [7:0]  data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 8, "code": "module example_module(\n    input  wire clk,      // Clock signal\n    input  wire rst_n,    // Active-low reset\n    input  wire [7:0]  data_in, // 8-bit input data\n    output wire [7:0]  data_out // 8-bit output data\n);\n\nreg [7:0] internal_reg; // Internal 8-bit register\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0; // Reset to zero\n    end else begin\n        internal_reg <= data_in; // Capture input data on rising clock edge\n    end\nend\n\nassign data_out = internal_reg; // Continuous assignment to output\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 7, "code": "module hardware_module(\n    input  wire clk,       // Clock signal\n    input  wire rst_n,     // Active-low reset\n    input  wire [7:0] data_in,  // 8-bit input data\n    output wire [7:0] data_out  // 8-bit output data\n);\n\n// Internal signals\nreg [7:0] internal_reg;\n\n// Sequential logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 12, "code": "module example_module(input logic clk, input logic rst_n, input logic [7:0] data_in, output logic [7:0] data_out);\n\n    // Internal signals\n    logic [7:0] internal_data;\n\n    // Sequential logic (registers)\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            internal_data <= 8'd0;\n        end else begin\n            internal_data <= data_in;\n        end\n    end\n\n    // Combinational logic (assign data_out)\n    assign data_out = internal_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 4, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 5, "code": "module example_module(\n    input  logic clk,     // Clock signal\n    input  logic rst_n,   // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals and registers\nlogic [7:0] internal_reg;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_reg <= 8'd0;  // Reset to zero\n    end else begin\n        internal_reg <= data_in;  // Capture input data on clock edge\n    end\nend\n\n// Combinational logic\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic (registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= '0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nalways_comb begin\n    data_out = reg_data + 8'd1; // Example operation\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 4, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 8, "code": "module example_module (\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 8, "code": "// Module Definition\nmodule example_module(\n    input logic clk,\n    input logic rst_n,\n    input logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal Signals\nlogic [7:0] internal_data;\n\n// Combinational Logic\nalways_comb begin\n    internal_data = data_in + 1;\nend\n\n// Sequential Logic (Register)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 0;\n    end else begin\n        data_out <= internal_data;\n    end\nend\n\n// Continuous Assignment (Optional)\nassign data_out = (rst_n) ? internal_data : 0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 3, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 11, "code": "module example_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signal declaration\nlogic [7:0] internal_reg;\n\n// Combinational logic\nalways_comb begin\n    data_out = internal_reg;\nend\n\n// Sequential logic (registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_reg <= 8'd0;  // Reset value\n    end else begin\n        internal_reg <= data_in;  // Update on rising clock edge\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 7, "code": "// Module Declaration\nmodule example_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] internal_reg;  // 8-bit internal register\n\n// Sequential logic (on every clock cycle)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin  // Reset condition\n        internal_reg <= 8'd0;  // Reset value is 0\n    end else begin\n        internal_reg <= data_in;  // Load input data into register\n    end\nend\n\n// Combinational logic (continuous assignment)\nassign data_out = internal_reg;  // Output is the current register value\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 5, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Combinational logic\nalways_comb begin\n    data_out = internal_reg;\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 13, "code": "module example_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] reg_data;  // 8-bit register\n\n// Sequential logic (flip-flop)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin  // Active-low reset condition\n        reg_data <= 8'd0;  // Reset value\n    end else begin\n        reg_data <= data_in;  // Capture input data on rising clock edge\n    end\nend\n\n// Combinational logic\nassign data_out = reg_data;  // Output is the current register value\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 12, "code": "`default_nettype none\n// E203 processor configuration parameters\n`define E203_CFG_ADDR_SIZE_IS_32\n`define E203_CFG_REGNUM_IS_32\n`define E203_CFG_HAS_ITCM\n`define E203_CFG_ITCM_ADDR_WIDTH 16\n`define E203_CFG_HAS_DTCM\n`define E203_CFG_DTCM_ADDR_WIDTH 16\n`define E203_CFG_HAS_NICE\n`define E203_CFG_SUPPORT_SHARE_MULDIV\n`define E203_CFG_SUPPORT_AMO\n`define E203_CFG_HAS_ECC\n\n// Derived macros based on configuration\n`ifdef E203_CFG_ADDR_SIZE_IS_32\n    `define E203_ADDR_SIZE 32\n    `define E203_PC_SIZE 32\n`endif\n\n`ifdef E203_CFG_REGNUM_IS_32\n    `define E203_RFREG_NUM 32\n`endif\n\n`ifdef E203_CFG_HAS_ITCM\n    `define E203_HAS_ITCM\n    `define E203_ITCM_ADDR_WIDTH `E203_CFG_ITCM_ADDR_WIDTH\n`endif\n\n`ifdef E203_CFG_HAS_DTCM\n    `define E203_HAS_DTCM\n    `define E203_DTCM_ADDR_WIDTH `E203_CFG_DTCM_ADDR_WIDTH\n`endif\n\n`ifdef E203_CFG_HAS_NICE\n    `define E203_HAS_NICE\n`endif\n\n`ifdef E203_CFG_SUPPORT_SHARE_MULDIV\n    `define E203_SUPPORT_MULDIV\n    `define E203_SUPPORT_SHARE_MULDIV\n`endif\n\n`ifdef E203_CFG_SUPPORT_AMO\n    `define E203_SUPPORT_AMO\n`endif\n\n`ifdef E203_CFG_HAS_ECC\n    `define E203_HAS_ECC\n`endif\n\n// Memory address base configurations\n`define E203_CFG_ITCM_ADDR_BASE 32'h8000_0000\n`define E203_CFG_DTCM_ADDR_BASE 32'h9000_0000\n`define E203_CFG_PPI_ADDR_BASE 32'h1000_0000\n`define E203_CFG_CLINT_ADDR_BASE 32'h0200_0000\n`define E203_CFG_PLIC_ADDR_BASE 32'h0C00_0000\n`define E203_CFG_FIO_ADDR_BASE 32'hF000_0000\n\n// Derived address macros\n`define E203_ITCM_BASE_REGION {`E203_PC_SIZE{1'b0}, `E203_CFG_ITCM_ADDR_BASE[`E203_PC_SIZE-1:`E203_CFG_ITCM_ADDR_WIDTH]}\n`define E203_DTCM_BASE_REGION {`E203_PC_SIZE{1'b0}, `E203_CFG_DTCM_ADDR_BASE[`E203_PC_SIZE-1:`E203_CFG_DTCM_ADDR_WIDTH]}\n`define E203_PPI_BASE_REGION {`E203_PC_SIZE{1'b0}, `E203_CFG_PPI_ADDR_BASE[`E203_PC_SIZE-1:`E203_CFG_ADDR_SIZE-16]}\n`define E203_CLINT_BASE_REGION {`E203_PC_SIZE{1'b0}, `E203_CFG_CLINT_ADDR_BASE[`E203_PC_SIZE-1:`E203_CFG_ADDR_SIZE-16]}\n`define E203_PLIC_BASE_REGION {`E203_PC_SIZE{1'b0}, `E203_CFG_PLIC_ADDR_BASE[`E203_PC_SIZE-1:`E203_CFG_ADDR_SIZE-8]}\n`define E203_FIO_BASE_REGION {`E203_PC_SIZE{1'b0}, `E203_CFG_FIO_ADDR_BASE[`E203_PC_SIZE-1:`E203_CFG_ADDR_SIZE-16]}\n\n// ITCM parameters\n`define E203_ITCM_RAM_DP (1 << (`E203_ITCM_ADDR_WIDTH - 3)) // 64-bit width (8 bytes per line)\n`define E203_ITCM_RAM_AW (`E203_ITCM_ADDR_WIDTH - 3)\n`define E203_ITCM_DATA_WIDTH 64\n`define E203_ITCM_WMSK_WIDTH 8\n`define E203_ITCM_RAM_ECC_DW (E203_ITCM_WMSK_WIDTH / 8) // 8 bits per ECC group\n`define E203_ITCM_RAM_ECC_MW 1 // 1-bit mask per ECC group\n`define E203_ITCM_OUTS_NUM 1 // 1 outstanding transaction without ECC\n\n// DTCM parameters\n`define E203_DTCM_RAM_DP (1 << (`E203_DTCM_ADDR_WIDTH - 2)) // 32-bit width (4 bytes per line)\n`define E203_DTCM_RAM_AW (`E203_DTCM_ADDR_WIDTH - 2)\n`define E203_DTCM_DATA_WIDTH 32\n`define E203_DTCM_WMSK_WIDTH 4\n`define E203_DTCM_RAM_ECC_DW (E203_DTCM_WMSK_WIDTH / 8) // 7 bits per ECC group\n`define E203_DTCM_RAM_ECC_MW 1 // 1-bit mask per ECC group\n`define E203_DTCM_OUTS_NUM 1 // 1 outstanding transaction without ECC\n\n// LSU and BIU parameters\n`define E203_LSU_OUTS_NUM 1\n`define E203_BIU_OUTS_NUM `E203_LSU_OUTS_NUM\n`define E203_BIU_CMD_DP 1\n`define E203_BIU_RSP_DP 1\n`define E203_BIU_CMD_CUT_READY 1\n`define E203_BIU_RSP_CUT_READY 1\n`define E203_BIU_OUTS_CNT_W 1\n\n// Instruction decode parameters\n`define E203_DECINFO_GRP_WIDTH 3\n`define E203_DECINFO_GRP_ALU 0\n`define E203_DECINFO_GRP_AGU 1\n`define E203_DECINFO_GRP_BJP 2\n`define E203_DECINFO_GRP_CSR 3\n`define E203_DECINFO_GRP_MULDIV 4\n`define E203_DECINFO_GRP_NICE 5\n`define E203_DECINFO_GRP_FPU 6\n\n// FPU configuration\n`define E203_DECINFO_FPU_GRP_WIDTH 2\n`define E203_DECINFO_FPU_GRP_FLSU 0\n`define E203_DECINFO_FPU_GRP_FMAC 1\n`define E203_DECINFO_FPU_GRP_FDIV 2\n`define E203_DECINFO_FPU_GRP_FMIS 3\n\n// Other derived parameters\n`define E203_XLEN 32\n`define E203_RFIDX_WIDTH 5 // log2(32)\n`define E203_INSTR_SIZE 32\n`define E203_SYSMEM_DATA_WIDTH 32\n`define E203_OITF_DEPTH 2\n`define E203_ITAG_WIDTH 1\n\n`default_nettype wire", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 7, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_excp(\n    output logic commit_trap,\n    output logic core_wfi,\n    output logic wfi_halt_ifu_req,\n    output logic wfi_halt_exu_req,\n    input logic wfi_halt_ifu_ack,\n    input logic wfi_halt_exu_ack,\n    input logic amo_wait,\n    input logic alu_excp_i_valid,\n    input logic alu_excp_i_ld,\n    input logic alu_excp_i_stamo,\n    input logic alu_excp_i_misalgn,\n    input logic alu_excp_i_buserr,\n    input logic alu_excp_i_ecall,\n    input logic alu_excp_i_ebreak,\n    input logic alu_excp_i_wfi,\n    input logic alu_excp_i_ifu_misalgn,\n    input logic alu_excp_i_ifu_buserr,\n    input logic alu_excp_i_ifu_ilegl,\n    input logic [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input logic [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input logic alu_excp_i_pc_vld,\n    input logic longp_excp_i_valid,\n    input logic longp_excp_i_ld,\n    input logic longp_excp_i_st,\n    input logic longp_excp_i_buserr,\n    input logic longp_excp_i_insterr,\n    input logic [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input logic [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input logic excpirq_flush_ack,\n    output logic excpirq_flush_req,\n    output logic nonalu_excpirq_flush_req_raw,\n    output logic [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output logic [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input logic [E203_XLEN-1:0] csr_mtvec_r,\n    input logic cmt_dret_ena,\n    input logic cmt_ena,\n    output logic [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output logic [E203_PC_SIZE-1:0] cmt_epc,\n    output logic [E203_XLEN-1:0] cmt_cause,\n    output logic cmt_badaddr_ena,\n    output logic cmt_epc_ena,\n    output logic cmt_cause_ena,\n    output logic cmt_status_ena,\n    output logic [E203_PC_SIZE-1:0] cmt_dpc,\n    output logic cmt_dpc_ena,\n    output logic [2:0] cmt_dcause,\n    output logic cmt_dcause_ena,\n    input logic dbg_irq_r,\n    input logic [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input logic ext_irq_r,\n    input logic sft_irq_r,\n    input logic tmr_irq_r,\n    input logic status_mie_r,\n    input logic mtie_r,\n    input logic msie_r,\n    input logic meie_r,\n    input logic dbg_mode,\n    input logic dbg_halt_r,\n    input logic dbg_step_r,\n    input logic dbg_ebreakm_r,\n    input logic oitf_empty,\n    input logic u_mode,\n    input logic s_mode,\n    input logic h_mode,\n    input logic m_mode,\n    output logic excp_active,\n    input logic clk,\n    input logic rst_n\n);\n\nlogic wfi_halt_req_dfflr_q, wfi_halt_req_dfflr_dnxt;\nlogic step_req_dfflr_q, step_req_dfflr_dnxt;\nlogic debug_entry_req, debug_entry_flush_req;\n\n// WFI handling\nsirv_gnrl_dfflr #(.DW(1)) wfi_halt_req_dfflr(\n    .lden(cmt_ena & alu_excp_i_wfi & ~dbg_mode),\n    .dnxt(1'b1),\n    .qout(wfi_halt_req_dfflr_q),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nsirv_gnrl_dfflr #(.DW(1)) step_req_dfflr(\n    .lden(cmt_ena & dbg_step_r),\n    .dnxt(1'b1),\n    .qout(step_req_dfflr_q),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nassign wfi_halt_ifu_req = wfi_halt_req_dfflr_q & ~wfi_halt_ifu_ack;\nassign wfi_halt_exu_req = wfi_halt_req_dfflr_q & ~wfi_halt_exu_ack;\nassign core_wfi = wfi_halt_ifu_ack & wfi_halt_exu_ack;\n\n// Debug entry request\nassign debug_entry_req = (dbg_irq_r | dbg_halt_r | dbg_step_r | dbg_ebreakm_r) & ~dbg_mode;\nassign debug_entry_flush_req = debug_entry_req & cmt_ena & alu_excp_i_pc_vld & oitf_empty & ~longp_excp_i_valid;\n\n// Exception handling\nlogic longp_excp_flush_req, alu_excp_flush_req;\nlogic [E203_XLEN-1:0] mcause;\nlogic [E203_PC_SIZE-1:0] mepc;\nlogic [E203_ADDR_SIZE-1:0] mtval;\n\nassign longp_excp_flush_req = longp_excp_i_valid & ~debug_entry_flush_req & ~debug_entry_req;\nassign alu_excp_flush_req = alu_excp_i_valid & cmt_ena & alu_excp_i_pc_vld & oitf_empty & ~longp_excp_i_valid;\n\nalways_comb begin\n    excpirq_flush_req = longp_excp_flush_req | alu_excp_flush_req | debug_entry_flush_req;\n    nonalu_excpirq_flush_req_raw = alu_excp_flush_req | debug_entry_flush_req;\n    \n    if (debug_entry_flush_req) begin\n        excpirq_flush_add_op1 = 32'h800;\n        excpirq_flush_add_op2 = 32'h0;\n    end else if (longp_excp_flush_req) begin\n        excpirq_flush_add_op1 = csr_mtvec_r;\n        excpirq_flush_add_op2 = 32'h0;\n    end else if (alu_excp_flush_req) begin\n        excpirq_flush_add_op1 = (dbg_mode) ? 32'h808 : csr_mtvec_r;\n        excpirq_flush_add_op2 = 32'h0;\n    end else begin\n        excpirq_flush_add_op1 = 32'h0;\n        excpirq_flush_add_op2 = 32'h0;\n    end\nend\n\nalways_comb begin\n    cmt_cause_ena = excpirq_flush_req;\n    cmt_epc_ena = excpirq_flush_req;\n    cmt_badaddr_ena = 0; // Not implemented in this version\n    cmt_status_ena = excpirq_flush_req;\n    \n    if (debug_entry_flush_req) begin\n        mcause = {19'd0, 3'd3}; // Debug interrupt\n        mepc = alu_excp_i_pc;\n        mtval = 0;\n    end else if (longp_excp_flush_req) begin\n        if (longp_excp_i_buserr) begin\n            mcause = {19'd0, 3'd5};\n        end else if (longp_excp_i_insterr) begin\n            mcause = {19'd0, 3'd4};\n        end else begin\n            mcause = {19'd0, 3'd0};\n        end\n        mepc = longp_excp_i_pc;\n        mtval = longp_excp_i_badaddr;\n    end else if (alu_excp_flush_req) begin\n        if (alu_excp_i_ecall) begin\n            mcause = {19'd0, 3'd8};\n        end else if (alu_excp_i_ebreak) begin\n            mcause = {19'd0, 3'd3};\n        end else if (alu_excp_i_wfi) begin\n            mcause = {19'd0, 3'd2};\n        end else if (alu_excp_i_ifu_misalgn) begin\n            mcause = {19'd0, 3'd0};\n        end else if (alu_excp_i_ifu_buserr) begin\n            mcause = {19'd0, 3'd1};\n        end else if (alu_excp_i_ifu_ilegl) begin\n            mcause = {19'd0, 3'd2};\n        end else if (alu_excp_i_misalgn) begin\n            mcause = {19'd0, 3'd0};\n        end else if (alu_excp_i_buserr) begin\n            mcause = {19'd0, 3'd1};\n        end else begin\n            mcause = {19'd0, 3'd0};\n        end\n        mepc = alu_excp_i_pc;\n        mtval = alu_excp_i_instr;\n    end else begin\n        mcause = 0;\n        mepc = 0;\n        mtval = 0;\n    end\nend\n\nalways_comb begin\n    cmt_epc = mepc;\n    cmt_cause = mcause;\n    cmt_badaddr = mtval;\nend\n\nassign excp_active = excpirq_flush_req;\n\n// WFI exit conditions\nlogic wfi_irq_valid;\nalways_comb begin\n    wfi_irq_valid = (dbg_irq_r | ext_irq_r | tmr_irq_r | sft_irq_r) & dbg_mode;\nend\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        core_wfi <= 1'b0;\n        wfi_halt_ifu_req <= 1'b0;\n        wfi_halt_exu_req <= 1'b0;\n    end else begin\n        if (wfi_irq_valid | debug_entry_req) begin\n            core_wfi <= 1'b0;\n            wfi_halt_ifu_req <= 1'b0;\n            wfi_halt_exu_req <= 1'b0;\n        end else if (wfi_halt_ifu_ack & wfi_halt_exu_ack) begin\n            core_wfi <= 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 5, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 6, "code": "module example_module(\n    input  logic clk,            // Clock signal\n    input  logic reset_n,        // Active-low reset\n    input  logic [7:0] data_in,  // 8-bit input data\n    output logic [7:0] data_out  // 8-bit output data\n);\n\nlogic [7:0] internal_register;  // Internal 8-bit register\n\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        internal_register <= 8'd0;  // Reset to zero\n    end else begin\n        internal_register <= data_in;  // Capture input data on clock edge\n    end\nend\n\nalways_comb begin\n    data_out = internal_register;  // Continuous assignment\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [3:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= {reg_data[6:0], data_in[0]};\n    end\nend\n\n// Combinational logic\nassign data_out = reg_data;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 10, "code": "module example_module(\n    input   logic       clk,\n    input   logic       rst_n,\n    input   logic [7:0] data_in,\n    output  logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_in;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 4, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 2, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 7, "code": "module example_module(\n    input   logic   clk,\n    input   logic   rst_n,\n    input   logic   [7:0] data_in,\n    output  logic   [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 5, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out,\n    input  logic [7:0] data_in\n);\n\nlogic [7:0] internal_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 3, "code": "module counter(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [3:0] count\n);\n\nlogic [3:0] next_count;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= '0;\n    end else begin\n        count <= next_count;\n    end\nend\n\nalways_comb begin\n    next_count = count + 1;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 8, "code": "module counter(\n    input  logic clk,\n    input  logic rst,\n    output logic [3:0] count\n);\n\nlogic [3:0] next_count;\n\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        count <= 4'd0;\n    end else begin\n        count <= next_count;\n    end\nend\n\nalways_comb begin\n    if (count == 4'd9) begin\n        next_count = 4'd0;\n    end else begin\n        next_count = count + 4'd1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 7, "code": "// Verilog code for a simple 2-input AND gate\nmodule and_gate(\n    input  logic a, b,\n    output logic y\n);\n\n// Continuous assignment for AND operation\nassign y = a & b;\n\nendmodule : and_gate", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 9, "code": "module example_module (\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 10, "code": "// Example Verilog Module\nmodule example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_reg <= 8'b0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 4, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 6, "code": "module example_module (\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 7, "code": "// Module Declaration\nmodule example_module(\n    input  logic clk,        // Clock signal\n    input  logic reset_n,    // Asynchronous active-low reset\n    input  logic [7:0] data_in, // 8-bit input data\n    output logic [7:0] data_out // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Always block for sequential logic (registers)\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        reg_data <= 8'd0; // Reset to zero\n    end else begin\n        reg_data <= data_in; // Capture input data on rising clock edge\n    end\nend\n\n// Continuous assignment for combinational logic\nassign data_out = reg_data;\n\nendmodule // example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 5, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 7, "code": "`include \"e203_defines.v\"\n\nmodule e203_lsu_ctrl(\n    input          commit_mret,\n    input          commit_trap,\n    output         lsu_ctrl_active,\n\n    output         lsu_o_valid,\n    input          lsu_o_ready,\n    output [E203_XLEN-1:0] lsu_o_wbck_wdat,\n    output [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n    output         lsu_o_wbck_err,\n    output         lsu_o_cmt_buserr,\n    output [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n    output         lsu_o_cmt_ld,\n    output         lsu_o_cmt_st,\n\n    input          agu_icb_cmd_valid,\n    output         agu_icb_cmd_ready,\n    input [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n    input          agu_icb_cmd_read,\n    input [E203_XLEN-1:0] agu_icb_cmd_wdata,\n    input [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n    input          agu_icb_cmd_lock,\n    input          agu_icb_cmd_excl,\n    input [1:0]    agu_icb_cmd_size,\n    input          agu_icb_cmd_back2agu,\n    input          agu_icb_cmd_usign,\n    input [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n    output         agu_icb_rsp_valid,\n    input          agu_icb_rsp_ready,\n    output         agu_icb_rsp_err,\n    output         agu_icb_rsp_excl_ok,\n    output [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n    `ifdef E203_HAS_NICE\n    input          nice_mem_holdup,\n    input          nice_icb_cmd_valid,\n    output         nice_icb_cmd_ready,\n    input [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n    input          nice_icb_cmd_read,\n    input [E203_XLEN-1:0] nice_icb_cmd_wdata,\n    input [E203_XLEN/8-1:0] nice_icb_cmd_wmask,\n    output         nice_icb_rsp_valid,\n    input          nice_icb_rsp_ready,\n    output         nice_icb_rsp_err,\n    output [E203_XLEN-1:0] nice_icb_rsp_rdata,\n    `endif\n\n    `ifdef E203_HAS_ITCM\n    output         itcm_icb_cmd_valid,\n    input          itcm_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] itcm_icb_cmd_addr,\n    output         itcm_icb_cmd_read,\n    output [E203_XLEN-1:0] itcm_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] itcm_icb_cmd_wmask,\n    input          itcm_icb_rsp_valid,\n    output         itcm_icb_rsp_ready,\n    input          itcm_icb_rsp_err,\n    input          itcm_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] itcm_icb_rsp_rdata,\n    `endif\n\n    `ifdef E203_HAS_DTCM\n    output         dtcm_icb_cmd_valid,\n    input          dtcm_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] dtcm_icb_cmd_addr,\n    output         dtcm_icb_cmd_read,\n    output [E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] dtcm_icb_cmd_wmask,\n    input          dtcm_icb_rsp_valid,\n    output         dtcm_icb_rsp_ready,\n    input          dtcm_icb_rsp_err,\n    input          dtcm_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n    `endif\n\n    output         biu_icb_cmd_valid,\n    input          biu_icb_cmd_ready,\n    output [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n    output         biu_icb_cmd_read,\n    output [E203_XLEN-1:0] biu_icb_cmd_wdata,\n    output [E203_XLEN/8-1:0] biu_icb_cmd_wmask,\n    input          biu_icb_rsp_valid,\n    output         biu_icb_rsp_ready,\n    input          biu_icb_rsp_err,\n    input          biu_icb_rsp_excl_ok,\n    input [E203_XLEN-1:0] biu_icb_rsp_rdata\n);\n\n// LSU Active State Management\nalways_ff @(posedge clk) begin\n    if (rst_n === 1'b0) begin\n        lsu_ctrl_active <= 1'b0;\n    end else begin\n        lsu_ctrl_active <= agu_icb_cmd_valid | nice_icb_cmd_valid;\n    end\nend\n\n// Write-back Channel Management\nalways_comb begin\n    lsu_o_valid = agu_icb_rsp_valid;\n    lsu_o_wbck_wdat = agu_icb_rsp_rdata;\n    lsu_o_wbck_itag = agu_icb_cmd_itag;\n    lsu_o_wbck_err = agu_icb_rsp_err;\n    lsu_o_cmt_buserr = (biu_icb_rsp_err && biu_icb_rsp_valid);\n    lsu_o_cmt_badaddr = biu_icb_rsp_err ? biu_icb_cmd_addr : '0;\n    lsu_o_cmt_ld = agu_icb_cmd_read && agu_icb_rsp_valid;\n    lsu_o_cmt_st = ~agu_icb_cmd_read && agu_icb_rsp_valid;\nend\n\n// AGU Command Handling\nalways_comb begin\n    agu_icb_cmd_ready = (lsu_o_ready && !nice_mem_holdup) || commit_trap || commit_mret;\n    agu_icb_rsp_valid = biu_icb_rsp_valid;\n    agu_icb_rsp_err = biu_icb_rsp_err;\n    agu_icb_rsp_excl_ok = biu_icb_rsp_excl_ok;\n    agu_icb_rsp_rdata = biu_icb_rsp_rdata;\nend\n\n`ifdef E203_HAS_NICE\nalways_comb begin\n    nice_icb_rsp_valid = biu_icb_rsp_valid;\n    nice_icb_rsp_err = biu_icb_rsp_err;\n    nice_icb_rsp_rdata = biu_icb_rsp_rdata;\nend\n`endif\n\n// ICB Command Arbitration and Routing\nalways_comb begin\n    // Default assignments\n    itcm_icb_cmd_valid = 1'b0;\n    dtcm_icb_cmd_valid = 1'b0;\n    biu_icb_cmd_valid = 1'b0;\n\n    itcm_icb_rsp_ready = 1'b0;\n    dtcm_icb_rsp_ready = 1'b0;\n    biu_icb_rsp_ready = 1'b0;\n\n    itcm_icb_cmd_addr = agu_icb_cmd_addr;\n    dtcm_icb_cmd_addr = agu_icb_cmd_addr;\n    biu_icb_cmd_addr = agu_icb_cmd_addr;\n\n    itcm_icb_cmd_read = agu_icb_cmd_read;\n    dtcm_icb_cmd_read = agu_icb_cmd_read;\n    biu_icb_cmd_read = agu_icb_cmd_read;\n\n    itcm_icb_cmd_wdata = agu_icb_cmd_wdata;\n    dtcm_icb_cmd_wdata = agu_icb_cmd_wdata;\n    biu_icb_cmd_wdata = agu_icb_cmd_wdata;\n\n    itcm_icb_cmd_wmask = agu_icb_cmd_wmask;\n    dtcm_icb_cmd_wmask = agu_icb_cmd_wmask;\n    biu_icb_cmd_wmask = agu_icb_cmd_wmask;\n\n    case (agu_icb_cmd_addr[E203_ADDR_SIZE-1:E203_ADDR_SIZE-16])\n        `E203_ITCM_BASE_REGION: begin\n            itcm_icb_cmd_valid = agu_icb_cmd_valid;\n            itcm_icb_rsp_ready = agu_icb_rsp_ready;\n        end\n        `E203_DTCM_BASE_REGION: begin\n            dtcm_icb_cmd_valid = agu_icb_cmd_valid;\n            dtcm_icb_rsp_ready = agu_icb_rsp_ready;\n        end\n        default: begin\n            biu_icb_cmd_valid = agu_icb_cmd_valid;\n            biu_icb_rsp_ready = agu_icb_rsp_ready;\n        end\n    endcase\nend\n\n// Exception Handling\nalways_ff @(posedge clk) begin\n    if (rst_n === 1'b0) begin\n        lsu_o_cmt_buserr <= 1'b0;\n        lsu_o_cmt_badaddr <= '0;\n    end else if (lsu_o_valid && lsu_o_wbck_err) begin\n        lsu_o_cmt_buserr <= 1'b1;\n        lsu_o_cmt_badaddr <= lsu_o_wbck_wdat;\n    end else begin\n        lsu_o_cmt_buserr <= 1'b0;\n        lsu_o_cmt_badaddr <= '0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 8, "code": "module example_module(\n    input  logic clk,        // Clock input\n    input  logic rst_n,      // Active-low reset\n    input  logic [7:0] data_in, // Data input (8-bit)\n    output logic [7:0] data_out // Data output (8-bit)\n);\n\n// Internal signal declaration\nlogic [7:0] internal_data;\n\n// Combinatorial logic\nalways_comb begin\n    data_out = internal_data;\nend\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_data <= 8'd0;\n    end else begin\n        internal_data <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 8, "code": "module example_module(\n    input logic clk,\n    input logic rst_n,\n    input logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 8, "code": "// e203_exu_excp.v\nmodule e203_exu_excp (\n    // Outputs\n    output logic commit_trap,\n    output logic core_wfi,\n    output logic wfi_halt_ifu_req,\n    output logic wfi_halt_exu_req,\n    output logic excpirq_flush_req,\n    output logic nonalu_excpirq_flush_req_raw,\n    output logic [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output logic [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    output logic [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output logic [E203_PC_SIZE-1:0] cmt_epc,\n    output logic [E203_XLEN-1:0] cmt_cause,\n    output logic cmt_badaddr_ena,\n    output logic cmt_epc_ena,\n    output logic cmt_cause_ena,\n    output logic cmt_status_ena,\n    output logic [E203_PC_SIZE-1:0] cmt_dpc,\n    output logic cmt_dpc_ena,\n    output logic [2:0] cmt_dcause,\n    output logic cmt_dcause_ena,\n    output logic excp_active,\n\n    // Inputs\n    input logic clk,\n    input logic rst_n,\n    input logic wfi_halt_ifu_ack,\n    input logic wfi_halt_exu_ack,\n    input logic amo_wait,\n    input logic alu_excp_i_valid,\n    input logic alu_excp_i_ld,\n    input logic alu_excp_i_stamo,\n    input logic alu_excp_i_misalgn,\n    input logic alu_excp_i_buserr,\n    input logic alu_excp_i_ecall,\n    input logic alu_excp_i_ebreak,\n    input logic alu_excp_i_wfi,\n    input logic alu_excp_i_ifu_misalgn,\n    input logic alu_excp_i_ifu_buserr,\n    input logic alu_excp_i_ifu_ilegl,\n    input logic [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input logic [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input logic alu_excp_i_pc_vld,\n    input logic longp_excp_i_valid,\n    input logic longp_excp_i_ld,\n    input logic longp_excp_i_st,\n    input logic longp_excp_i_buserr,\n    input logic longp_excp_i_insterr,\n    input logic longp_excp_i_badaddr,\n    input logic [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input logic excpirq_flush_ack,\n    input logic [E203_XLEN-1:0] csr_mtvec_r,\n    input logic cmt_dret_ena,\n    input logic cmt_ena,\n    input logic dbg_irq_r,\n    input logic [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input logic ext_irq_r,\n    input logic sft_irq_r,\n    input logic tmr_irq_r,\n    input logic status_mie_r,\n    input logic mtie_r,\n    input logic msie_r,\n    input logic meie_r,\n    input logic dbg_mode,\n    input logic dbg_halt_r,\n    input logic dbg_step_r,\n    input logic dbg_ebreakm_r,\n    input logic oitf_empty,\n    input logic u_mode,\n    input logic s_mode,\n    input logic h_mode,\n    input logic m_mode\n);\n\n    sirv_gnrl_dfflr #(.DW(1)) wfi_flag_dfflr (\n        .lden(1'b1),\n        .dnxt(1'b0),\n        .qout(),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    sirv_gnrl_dfflr #(.DW(1)) wfi_halt_req_dfflr (\n        .lden(1'b1),\n        .dnxt(1'b0),\n        .qout(),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    sirv_gnrl_dfflr #(.DW(1)) step_req_dfflr (\n        .lden(1'b1),\n        .dnxt(1'b0),\n        .qout(),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\n    // WFI handling\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            core_wfi <= 1'b0;\n        end else if (wfi_halt_ifu_ack && wfi_halt_exu_ack) begin\n            core_wfi <= 1'b1;\n        end else if (dbg_entry_req || valid_irq) begin\n            core_wfi <= 1'b0;\n        end\n    end\n\n    assign wfi_halt_ifu_req = (alu_excp_i_wfi && !dbg_mode && !core_wfi);\n    assign wfi_halt_exu_req = wfi_halt_ifu_req;\n\n    // Exception handling logic\n    always_comb begin\n        // Handle ALU exceptions\n        if (alu_excp_i_valid && alu_excp_i_pc_vld) begin\n            // Update cause, EPC, and badaddr\n            cmt_cause = {31'b0, alu_excp_i_ecall ? 8 : alu_excp_i_ebreak ? 3 : alu_excp_i_buserr ? 7 : alu_excp_i_misalgn ? 0 : 0};\n            cmt_epc = alu_excp_i_pc;\n            cmt_badaddr = alu_excp_i_buserr ? alu_excp_i_pc : 0;\n            cmt_cause_ena = 1'b1;\n            cmt_epc_ena = 1'b1;\n            cmt_badaddr_ena = 1'b1;\n        end else if (longp_excp_i_valid) begin\n            // Update cause, EPC, and badaddr\n            cmt_cause = {31'b0, longp_excp_i_insterr ? 16 : longp_excp_i_buserr ? 7 : 0};\n            cmt_epc = longp_excp_i_pc;\n            cmt_badaddr = longp_excp_i_buserr ? longp_excp_i_badaddr : 0;\n            cmt_cause_ena = 1'b1;\n            cmt_epc_ena = 1'b1;\n            cmt_badaddr_ena = 1'b1;\n        end else begin\n            cmt_cause = 0;\n            cmt_epc = 0;\n            cmt_badaddr = 0;\n            cmt_cause_ena = 1'b0;\n            cmt_epc_ena = 1'b0;\n            cmt_badaddr_ena = 1'b0;\n        end\n\n        // Update status register\n        cmt_status_ena = 1'b0; // Not handled in this module\n    end\n\n    // Pipeline flush control\n    assign excpirq_flush_req = (alu_excp_i_valid || longp_excp_i_valid) && alu_excp_i_pc_vld && oitf_empty;\n    assign nonalu_excpirq_flush_req_raw = (dbg_entry_req || valid_irq) && alu_excp_i_pc_vld && oitf_empty;\n\n    // Calculate flush addresses\n    assign excpirq_flush_add_op1 = (dbg_mode) ? 32'h800 : (longp_excp_i_valid || alu_excp_i_valid) && dbg_mode ? 32'h808 : csr_mtvec_r;\n    assign excpirq_flush_add_op2 = 32'h0;\n\n    // Debug handling\n    assign cmt_dcause_ena = dbg_entry_req ? 1'b1 : 1'b0;\n    assign cmt_dcause = dbg_halt_r ? 3'b001 : dbg_step_r ? 3'b010 : dbg_ebreakm_r ? 3'b100 : 3'b000;\n    assign cmt_dpc = dbg_entry_req ? alu_excp_i_pc : 0;\n    assign cmt_dpc_ena = dbg_entry_req ? 1'b1 : 1'b0;\n\n    // Interrupt handling\n    assign valid_irq = (dbg_irq_r || lcl_irq_r[0] || ext_irq_r || sft_irq_r || tmr_irq_r) && (dbg_mode || status_mie_r) && (dbg_irq_r ? 1'b1 : (lcl_irq_r[0] ? msie_r : (ext_irq_r ? meie_r : (sft_irq_r ? 1'b1 : (tmr_irq_r ? mtie_r : 1'b0)))));\n    assign commit_trap = valid_irq || alu_excp_i_valid || longp_excp_i_valid;\n\n    // Debug entry request\n    assign dbg_entry_req = dbg_halt_r || dbg_step_r || dbg_ebreakm_r || dbg_irq_r;\n\n    // Exception active status\n    assign excp_active = commit_trap;\n\nendmodule\n\nmodule sirv_gnrl_dfflr #(\n    DW = 32\n)(\n    input logic lden,\n    input logic [DW-1:0] dnxt,\n    output logic [DW-1:0] qout,\n    input logic clk,\n    input logic rst_n\n);\n\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            qout <= 0;\n        end else if (lden) begin\n            qout <= dnxt;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'b0;\n    end else begin\n        data_reg <= data_reg + 1'b1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 6, "code": "module example_module(\n    input logic clk,\n    input logic rst_n,\n    input logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 8, "code": "// Example Verilog Module (Replace with your actual design)\nmodule example_module(\n    input  logic clk,    // Clock signal\n    input  logic reset,  // Active-high reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals (if needed)\nlogic [7:0] internal_reg;\n\n// Combinational logic (if needed)\nalways_comb begin\n    data_out = internal_reg;\nend\n\n// Sequential logic (if needed)\nalways_ff @(posedge clk) begin\n    if (reset) begin\n        internal_reg <= 8'd0; // Reset to zero\n    end else begin\n        internal_reg <= data_in; // Capture input data\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 11, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nalways_comb begin\n    data_out = reg_data + 8'd1;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic reset_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 13, "code": "module example_module(\n    // Inputs\n    input  logic        clk,         // Clock signal\n    input  logic        rst_n,       // Active-low reset\n    input  logic [7:0]  data_in,     // 8-bit input data\n    input  logic        valid_in,    // Input data valid signal\n    \n    // Outputs\n    output logic [7:0]  data_out,    // 8-bit output data\n    output logic        valid_out    // Output data valid signal\n);\n\n// Internal signals\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;    // Reset to zero\n    end else if (valid_in) begin\n        data_reg <= data_in; // Capture input data on valid signal\n    end\nend\n\nalways_comb begin\n    data_out = data_reg;    // Output registered data\n    valid_out = valid_in;  // Echo valid signal (could be modified based on logic)\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 7, "code": "module example_module(\n    input  logic clk,  \n    input  logic rst_n, \n    input  logic [7:0] data_in,  \n    output logic [7:0] data_out  \n);  \n\nlogic [7:0] reg_data;  \n\nalways_ff @(posedge clk or negedge rst_n) begin  \n    if (!rst_n) begin  \n        reg_data <= 8'd0;  \n    end else begin  \n        reg_data <= data_in;  \n    end  \nend  \n\nalways_comb begin  \n    data_out = reg_data;  \nend  \n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 13, "code": "// Module declaration\nmodule example_module(input  logic clk, \n                     input  logic reset_n, \n                     input  logic [7:0] data_in, \n                     output logic [7:0] data_out);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Combinational logic\nalways_comb begin\n    data_out = internal_reg;\nend\n\n// Sequential logic\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 7, "code": "module example_module(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\nreg [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_in;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 12, "code": "// Define a module for a simple AND gate\nmodule and_gate(\n    input  logic a,  // First input\n    input  logic b,  // Second input\n    output logic y   // Output\n);\n\n// Internal logic for AND operation\nassign y = a & b;\n\nendmodule : and_gate\n\n// Define a module for a 2-to-1 multiplexer\nmodule mux2to1(\n    input  logic sel,  // Select line\n    input  logic a,    // First input\n    input  logic b,    // Second input\n    output logic y     // Output\n);\n\n// Internal logic for multiplexing\nassign y = sel ? b : a;\n\nendmodule : mux2to1\n\n// Define a module for a D flip-flop with asynchronous reset\nmodule dff(\n    input  logic clk,   // Clock signal\n    input  logic rst_n, // Asynchronous active-low reset\n    input  logic d,     // Data input\n    output logic q      // Data output\n);\n\n// Internal logic for D flip-flop\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule : dff\n\n// Define a module for a 4-bit counter with enable\nmodule counter4(\n    input  logic clk,   // Clock signal\n    input  logic en,    // Enable signal\n    output logic [3:0] count  // Output count\n);\n\n// Internal logic for counter\nalways_ff @(posedge clk) begin\n    if (en) begin\n        count <= count + 1'b1;\n    end\nend\n\nendmodule : counter4\n\n// Define a top-level module that instantiates other modules\nmodule top(\n    input  logic clk,   // Clock signal\n    input  logic rst_n, // Asynchronous active-low reset\n    input  logic a,     // Input for AND gate\n    input  logic b,     // Input for AND gate\n    input  logic sel,   // Select line for multiplexer\n    input  logic d,     // Data input for D flip-flop\n    output logic and_out, // Output from AND gate\n    output logic mux_out, // Output from multiplexer\n    output logic q,      // Output from D flip-flop\n    output logic [3:0] count // Output from counter\n);\n\n// Instantiate modules\nand_gate u_and(\n    .a(a),\n    .b(b),\n    .y(and_out)\n);\n\nmux2to1 u_mux(\n    .sel(sel),\n    .a(a),\n    .b(b),\n    .y(mux_out)\n);\n\ndff u_dff(\n    .clk(clk),\n    .rst_n(rst_n),\n    .d(d),\n    .q(q)\n);\n\ncounter4 u_counter(\n    .clk(clk),\n    .en(1'b1), // Always enable the counter\n    .count(count)\n);\n\nendmodule : top", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 4, "code": "// Define a module named 'example_module'\nmodule example_module(\n    // Input ports\n    input  logic clk,    // Clock signal\n    input  logic reset,  // Active-high reset\n    input  logic [7:0] data_in,  // 8-bit input data\n    \n    // Output ports\n    output logic [7:0] data_out, // 8-bit output data\n    output logic valid    // Data validity signal\n);\n\n// Internal signals\nlogic [7:0] internal_reg;  // 8-bit internal register\nlogic       reg_en;        // Register enable signal\n\n// Combinational logic\nalways_comb begin\n    // Example logic: forward data_in to data_out with a validity check\n    if (data_in == 8'b0) begin\n        data_out = 8'b0;\n        valid   = 1'b0;\n    end else begin\n        data_out = data_in;\n        valid   = 1'b1;\n    end\n    \n    // Example control signal generation\n    reg_en = (reset == 1'b0) && (data_in != 8'b0);\nend\n\n// Sequential logic\nalways_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n        // Reset condition: clear internal register\n        internal_reg <= 8'b0;\n    end else if (reg_en) begin\n        // Update internal register with data_in\n        internal_reg <= data_in;\n    end\nend\n\n// Continuous assignment (optional)\nassign data_out = internal_reg;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 11, "code": "// Define a module named \"example_module\" with no inputs or outputs\nmodule example_module();\n\n    // Initialize a reg variable named \"counter\" with a width of 8 bits\n    reg [7:0] counter;\n\n    // Initialize an integer variable named \"i\" for loop control\n    integer i;\n\n    // Initialize a wire variable named \"clk\" for clock signal\n    wire clk;\n\n    // Continuous assignment statement for the clock signal\n    assign clk = 1'b1;\n\n    // Initial block to demonstrate initialization\n    initial begin\n        // Initialize counter to 0\n        counter = 8'd0;\n\n        // Loop through values 0 to 255 and print the counter value\n        for (i = 0; i <= 255; i++) begin\n            $display(\"Counter value: %d\", counter);\n            counter = counter + 1'b1;\n        end\n\n        // Finish simulation after 1000 time units\n        #1000 $finish;\n    end\n\n    // Always block to demonstrate clock-driven logic\n    always @(posedge clk) begin\n        // Increment counter every clock cycle\n        counter <= counter + 1'b1;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 5, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_decode(\n    input  logic [E203_INSTR_SIZE-1:0] i_instr,\n    input  logic [E203_PC_SIZE-1:0]    i_pc,\n    input  logic                       i_prdt_taken,\n    input  logic                       i_misalgn,\n    input  logic                       i_buserr,\n    input  logic                       i_muldiv_b2b,\n    input  logic                       dbg_mode,\n    output logic                       dec_rs1x0,\n    output logic                       dec_rs2x0,\n    output logic                       dec_rs1en,\n    output logic                       dec_rs2en,\n    output logic                       dec_rdwen,\n    output logic [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output logic [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output logic [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output logic [E203_DECINFO_WIDTH-1:0] dec_info,\n    output logic [E203_XLEN-1:0]        dec_imm,\n    output logic [E203_PC_SIZE-1:0]     dec_pc,\n    output logic                       dec_misalgn,\n    output logic                       dec_buserr,\n    output logic                       dec_ilegl,\n    output logic                       dec_mulhsu,\n    output logic                       dec_mul,\n    output logic                       dec_div,\n    output logic                       dec_rem,\n    output logic                       dec_divu,\n    output logic                       dec_remu,\n    output logic                       dec_rv32,\n    output logic                       dec_bjp,\n    output logic                       dec_jal,\n    output logic                       dec_jalr,\n    output logic                       dec_bxx,\n    output logic [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output logic [E203_XLEN-1:0]        dec_bjp_imm\n);\n\n// Instruction decoding logic\nassign dec_pc = i_pc;\n\n// Immediate extraction logic\nalways_comb begin\n    casez(i_instr)\n        // RV32I instructions\n        32'b0010011???????010???????000: begin // I-Type (addi, srli, etc.)\n            dec_imm = {{20{1'b1}}, i_instr[19:12]};\n        end\n        32'b0000011???????010???????000: begin // S-Type (sb, sh, sw)\n            dec_imm = {\n                i_instr[31],\n                i_instr[11:5],\n                i_instr[4:0],\n                i_instr[7]\n            };\n        end\n        32'b1100011???????000???????000: begin // SB-Type (beq, bne, etc.)\n            dec_imm = {\n                i_instr[31],\n                i_instr[7],\n                i_instr[30:25],\n                i_instr[11:8],\n                1'b0,\n                i_instr[12]\n            };\n        end\n        32'b0110111???????000???????000: begin // U-Type (lui, auipc)\n            dec_imm = i_instr[31:12];\n        end\n        32'b1101111???????000???????000: begin // UJ-Type (jal)\n            dec_imm = {\n                i_instr[31],\n                i_instr[19:12],\n                i_instr[20],\n                i_instr[30:21],\n                1'b0\n            };\n        end\n        // RV32A instructions\n        32'b0101111???????010???????000: begin // S-Type (lr.w, sc.w)\n            dec_imm = {\n                i_instr[31],\n                i_instr[11:5],\n                i_instr[4:0],\n                i_instr[7]\n            };\n        end\n        // RV32M instructions (if E203_SUPPORT_MULDIV is defined)\n        32'b0110011???????000???????000: begin // R-Type (mul, div, etc.)\n            dec_imm = '0;\n        end\n        // RV32C instructions\n        32'b01???????010???????000: begin // C-Type (c.addi, c.lwsp, etc.)\n            // Immediate extraction for compressed instructions\n            casez(i_instr[15:13])\n                3'b000: begin // C.ADDI4SPN\n                    dec_imm = {\n                        i_instr[12:7],\n                        i_instr[2:0]\n                    };\n                end\n                3'b001: begin // C.ADDI\n                    dec_imm = {\n                        i_instr[12:7],\n                        i_instr[2:0]\n                    };\n                end\n                // Other C-Type instructions\n                default: dec_imm = '0;\n            endcase\n        end\n        default: dec_imm = '0;\n    endcase\nend\n\n// Instruction type decoding\nlogic is_rv32i, is_rv32a, is_rv32m, is_rv32c;\n\nalways_comb begin\n    is_rv32i = (i_instr[15:0] == 16'b0000000000000000) || (i_instr[15:0] == 16'b1000000000000000);\n    is_rv32a = (i_instr[15:0] == 16'b0100000000000000);\n    is_rv32m = (i_instr[15:0] == 16'b0000000000000000) && (E203_SUPPORT_MULDIV);\n    is_rv32c = (i_instr[15:0] == 16'b01???????010???????000);\nend\n\nalways_comb begin\n    dec_rs1x0 = (i_instr[19:15] == 5'b00000);\n    dec_rs2x0 = (i_instr[24:20] == 5'b00000);\n    dec_rs1en = (is_rv32i || is_rv32a || is_rv32m) && (i_instr[19:15] != 5'b00000);\n    dec_rs2en = (is_rv32i || is_rv32a || is_rv32m) && (i_instr[24:20] != 5'b00000);\n    dec_rdwen = (is_rv32i || is_rv32a || is_rv32m) && (i_instr[11:7] != 5'b00000);\n    dec_rs1idx = i_instr[19:15];\n    dec_rs2idx = i_instr[24:20];\n    dec_rdidx = i_instr[11:7];\n    dec_misalgn = i_misalgn;\n    dec_buserr = i_buserr;\n    dec_ilegl = i_instr == 32'b0000000000000000 || i_instr == 32'b1111111111111111;\n    dec_mulhsu = (is_rv32m && i_instr[14:12] == 3'b010);\n    dec_mul = (is_rv32m && i_instr[14:12] == 3'b000);\n    dec_div = (is_rv32m && i_instr[14:12] == 3'b100);\n    dec_rem = (is_rv32m && i_instr[14:12] == 3'b110);\n    dec_divu = (is_rv32m && i_instr[14:12] == 3'b101);\n    dec_remu = (is_rv32m && i_instr[14:12] == 3'b111);\n    dec_rv32 = is_rv32i || is_rv32a || is_rv32m;\n    dec_bjp = is_rv32i && i_instr[6:0] == 7'b1100011;\n    dec_jal = is_rv32i && i_instr[6:0] == 7'b1101111;\n    dec_jalr = is_rv32i && i_instr[6:0] == 7'b1100111;\n    dec_bxx = is_rv32i && i_instr[14:12] == 3'b000 && i_instr[6:0] == 7'b1100011;\n    dec_jalr_rs1idx = i_instr[19:15];\n    dec_bjp_imm = i_instr[31:12];\nend\n\n// Information bus decoding (example for ALU group)\nalways_comb begin\n    casez(i_instr[6:0])\n        7'b0010011: begin // I-Type\n            dec_info = {\n                E203_DECINFO_RV32,\n                E203_DECINFO_ALU_ADD | E203_DECINFO_ALU_SUB | E203_DECINFO_ALU_SLT | E203_DECINFO_ALU_SLTU | E203_DECINFO_ALU_XOR |\n                             E203_DECINFO_ALU_SLL | E203_DECINFO_ALU_SRL | E203_DECINFO_ALU_SRA | E203_DECINFO_ALU_OR | E203_DECINFO_ALU_AND |\n                             E203_DECINFO_ALU_LUI | E203_DECINFO_ALU_OP2IMM | E203_DECINFO_ALU_OP1PC | E203_DECINFO_ALU_NOP | E203_DECINFO_ALU_ECAL |\n                             E203_DECINFO_ALU_EBRK | E203_DECINFO_ALU_WFI\n            };\n        end\n        // ... other instruction types\n        default: dec_info = '0;\n    endcase\nend\n\n`ifdef E203_HAS_NICE\n    logic dec_nice;\n    logic nice_xs_off;\n    logic nice_cmt_off_ilgl_o;\n\n    assign dec_nice = is_rv32c && i_instr[15:13] == 3'b101;\n    assign nice_xs_off = i[12];\n    assign nice_cmt_off_ilgl_o = dec_nice && nice_xs_off;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 8, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 5, "code": "module example_module(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\nreg [7:0] data_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_in;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 7, "code": "module [Module Name] (\n    input  logic [N:0]  in_a,\n    input  logic [M:0]  in_b,\n    output logic [P:0]  out_c\n);\n\n    // Internal signals or logic declarations\n    logic [Q:0] internal_signal;\n\n    // Main logic implementation\n    assign out_c = in_a + in_b;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 10, "code": "// Example Verilog Module: 4-bit Counter with Asynchronous Reset\nmodule counter_4bit(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Asynchronous active-low reset\n    output logic [3:0] count  // 4-bit counter output\n);\n\nlogic [3:0] next_count;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        count <= 4'b0000;  // Reset to zero on active-low reset\n    end else begin\n        count <= next_count;\n    end\nend\n\nalways_comb begin\n    next_count = count + 1'b1;\nend\n\nendmodule : counter_4bit", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 9, "code": "module example_module(\n    input logic clk,\n    input logic rst_n,\n    input logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 9, "code": "module example_module(\n    input   logic       clk,\n    input   logic       rst_n,\n    input   logic [7:0] data_in,\n    output  logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 10, "code": "module example_module(\n    input  logic clk,  // Clock signal\n    input  logic rst_n, // Active-low reset\n    input  logic [7:0] data_in,  // 8-bit input data\n    output logic [7:0] data_out  // 8-bit output data\n);\n\n// Internal signal declarations\nlogic [7:0] internal_data;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset logic: Set output to zero on reset\n        data_out <= 8'd0;\n        internal_data <= 8'd0;\n    end else begin\n        // Main operation: Shift data_in to internal_data and assign to data_out\n        internal_data <= data_in;\n        data_out <= internal_data;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic reset_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = internal_reg;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 9, "code": "// Module Definition\nmodule example_module(\n    input  logic clk,       // Clock signal\n    input  logic rst_n,     // Active-low reset\n    input  logic [7:0] data_in, // 8-bit input data\n    output logic [7:0] data_out  // 8-bit output data\n);\n\n// Internal Signals\nlogic [7:0] reg_data;\n\n// Always Block for Sequential Logic (Reset and Clock)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset condition: Clear the register\n        reg_data <= 8'd0;\n    end else begin\n        // Normal operation: Load input data into register\n        reg_data <= data_in;\n    end\nend\n\n// Continuous Assignment for Output\nassign data_out = reg_data;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 9, "code": "// Verilog Module Example\nmodule example_module (\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal Signals\nlogic [7:0] internal_reg;\n\n// Combinatorial Logic\nalways_comb begin\n    data_out = internal_reg;\nend\n\n// Sequential Logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 6, "code": "// Module declaration\nmodule my_module(\n    input  logic clk,    // Clock input\n    input  logic reset_n, // Asynchronous active-low reset\n    input  logic [7:0] data_in, // 8-bit input data\n    output logic [7:0] data_out // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Always block for sequential logic (reset and clock)\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        reg_data <= 8'd0; // Reset to zero\n    end else begin\n        reg_data <= data_in; // Capture input data on rising clock edge\n    end\nend\n\n// Continuous assignment for output\nassign data_out = reg_data;\n\nendmodule : my_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 9, "code": "// Define the module\nmodule my_module(\n    // Input ports\n    input logic clk,\n    input logic rst_n,\n    \n    // Data input\n    input logic [7:0] data_in,\n    \n    // Data output\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Combinatorial logic\nalways_comb begin\n    // Example assignment\n    data_out = internal_reg;\nend\n\n// Sequential logic (flip-flop)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset condition\n        internal_reg <= 8'd0;\n    end else begin\n        // Clock condition\n        internal_reg <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 7, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 13, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Combinational logic\nalways_comb begin\n    data_out = internal_reg;\nend\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 8, "code": "module example_module(input [7:0] a, input [7:0] b, output [7:0] sum);\n    assign sum = a + b;\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 11, "code": "// Verilog code for a basic 2-input AND gate\nmodule and_gate(\n    input  logic a, \n    input  logic b, \n    output logic result\n);\n\nassign result = a & b;\n\nendmodule\n\n// Verilog code for a 4-bit counter\nmodule counter(\n    input  logic clk, \n    input  logic rst, \n    output logic [3:0] count\n);\n\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        count <= 4'd0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule\n\n// Verilog code for a multiplexer (2-input, 1-bit)\nmodule mux(\n    input  logic sel, \n    input  logic a, \n    input  logic b, \n    output logic result\n);\n\nassign result = sel ? b : a;\n\nendmodule\n\n// Verilog code for a D flip-flop\nmodule d_flipflop(\n    input  logic clk, \n    input  logic rst, \n    input  logic d, \n    output logic q\n);\n\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n\n// Verilog code for a 4-to-1 multiplexer\nmodule mux_4to1(\n    input  logic [1:0] sel, \n    input  logic [3:0] data, \n    output logic       result\n);\n\nalways_comb begin\n    case (sel)\n        2'd0: result = data[0];\n        2'd1: result = data[1];\n        2'd2: result = data[2];\n        2'd3: result = data[3];\n        default: result = 1'b0;\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 12, "code": "module example_module(\n    input  logic clk,         // Clock signal\n    input  logic reset_n,     // Active-low reset\n    input  logic [7:0] data_in, // 8-bit input data\n    output logic [7:0] data_out // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Always block for sequential logic (register)\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Continuous assignment for output\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 8, "code": "// Module declaration\nmodule example_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals and registers\nlogic [7:0] data_reg;\n\n// Always block for sequential logic (register update)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset condition\n        data_reg <= 8'd0;\n    end else begin\n        // Normal operation (capture input data)\n        data_reg <= data_in;\n    end\nend\n\n// Continuous assignment ( combinational logic)\nassign data_out = data_reg;\n\nendmodule // example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 9, "code": "module hardware_module(\n    input  logic clk,        // Clock input\n    input  logic rst_n,      // Active-low reset\n    input  logic [7:0] data_in, // 8-bit input data\n    output logic [7:0] data_out // 8-bit output data\n);\n\n// Internal registers and wires\nlogic [7:0] reg_data;\n\n// Sequential logic (registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0; // Reset to zero\n    end else begin\n        reg_data <= data_in; // Capture input data\n    end\nend\n\n// Combinational logic (assign output)\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 9, "code": "module example_module (\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] counter;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        counter <= 8'd0;\n    end else begin\n        counter <= counter + 1'b1;\n    end\nend\n\nassign data_out = counter;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 10, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nalways_comb begin\n    data_out = reg_data;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] counter = 8'd0;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 8'd0;\n    end else begin\n        counter <= counter + 8'd1;\n    end\nend\n\nalways_comb begin\n    data_out = counter;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 10, "code": "module example_module(\n    input  logic clk,          // Clock signal\n    input  logic rst_n,        // Active-low reset\n    input  logic [7:0] data_in, // 8-bit input data\n    output logic [7:0] data_out // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0; // Reset value\n    end else begin\n        reg_data <= data_in; // Capture input data on rising clock edge\n    end\nend\n\n// Continuous assignment for output\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 9, "code": "module your_module_name(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 11, "code": "module example_module(input logic clk, input logic rst_n, output logic [7:0] data_out);\n\n    logic [7:0] data_reg = 8'd0;\n\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_reg <= 8'd0;\n        end else begin\n            data_reg <= data_reg + 8'd1;\n        end\n    end\n\n    assign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 11, "code": "module example_module(\n    input logic clk,\n    input logic rst_n,\n    input logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] temp_data;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= temp_data;\n    end\nend\n\nalways_comb begin\n    temp_data = data_out + 8'd1;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 15, "code": "module counter(\n    input   clk,\n    input   rst_n,\n    output  reg [7:0] count = 0\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 8'd0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 11, "code": "module example_module(\n    input  wire clk,       // Clock signal\n    input  wire rst_n,     // Active-low reset\n    input  wire [7:0] data_in, // 8-bit input data\n    output wire [7:0] data_out // 8-bit output data\n);\n\n// Internal signals\nreg [7:0] internal_reg;\n\n// Always block for sequential logic (reset and clock)\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0; // Reset to zero\n    end else begin\n        internal_reg <= data_in; // Capture input data on rising clock edge\n    end\nend\n\n// Continuous assignment for output\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 10, "code": "// Example Verilog Module (Hardware Engineer's Implementation)\nmodule example_module(\n    input  logic        clk,         // Clock signal\n    input  logic        reset_n,     // Active-low reset\n    input  logic [7:0]  data_in,     // 8-bit input data\n    output logic [7:0]  data_out     // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] data_reg;\n\n// Sequential logic (registers)\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        data_reg <= '0; // Reset value\n    end else begin\n        data_reg <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 8, "code": "module example_module(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\n// Internal signals\nreg [7:0] data_reg;\n\n// Sequential logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_in;\n    end\nend\n\n// Combinatorial logic\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule: example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic reset_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 11, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 10, "code": "module example_module (\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] internal_reg;\n\nalways_ff @(posedge clk) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= internal_reg + 1;\n    end\nend\n\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 6, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 10, "code": "module your_module_name(\n    // Add input ports here, e.g., \n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    \n    // Add output ports here, e.g.,\n    output logic [7:0] data_out\n);\n\n// Internal signals, parameters, or variables\nlogic [7:0] internal_reg;\n\n// Combinational logic\nalways_comb begin\n    // Example combinational logic\n    data_out = internal_reg;\nend\n\n// Sequential logic (e.g., registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset logic\n        internal_reg <= 8'd0;\n    end else begin\n        // Regular operation\n        internal_reg <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 7, "code": "// Module Definition\nmodule example_module(\n    input  logic clk,      // Clock signal\n    input  logic reset_n,  // Active low reset\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal Signals\nlogic [7:0] internal_reg;\n\n// Sequential Logic\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        internal_reg <= 8'd0; // Reset to zero\n    end else begin\n        internal_reg <= data_in; // Capture input data\n    end\nend\n\n// Combinatorial Logic\nalways_comb begin\n    data_out = internal_reg; // Continuous assignment\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 12, "code": "module example_module(\n    input  logic clk,        // Clock signal\n    input  logic reset_n,    // Active-low reset\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        reg_data <= 8'd0; // Reset to zero\n    end else begin\n        reg_data <= data_in; // Capture input data on rising clock\n    end\nend\n\n// Combinational logic\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 12, "code": "module example_module(\n    input logic clk,\n    input logic rst_n,\n    input logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 12, "code": "// Define a module named \"encoder_8to3\" with 8-bit input and 3-bit output\nmodule encoder_8to3(input [7:0] in, output [2:0] out);\n\n    // Initialize the output to zero by default\n    assign out = 3'b000;\n\n    // Check each bit of the input from MSB to LSB and assign the corresponding 3-bit code\n    always @(*) begin\n        casez (in)\n            8'b1XXXXXXX: out = 3'b000;\n            8'b01XXXXXX: out = 3'b001;\n            8'b001XXXXX: out = 3'b010;\n            8'b0001XXXX: out = 3'b011;\n            8'b00001XXX: out = 3'b100;\n            8'b000001XX: out = 3'b101;\n            8'b0000001X: out = 3'b110;\n            8'b00000001: out = 3'b111;\n            default: out = 3'b000; // If no bit is set, default to 3'b000\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 13, "code": "module example_module(input  logic clk,\n                     input  logic rst_n,\n                     input  logic [7:0] data_in,\n                     output logic [7:0] data_out);\n\n    logic [7:0] reg_data;\n\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            reg_data <= 8'd0;\n        end else begin\n            reg_data <= data_in;\n        end\n    end\n\n    assign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 8, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n       _out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 12, "code": "// Module definition\nmodule example_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic (on rising clock edge)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset condition: clear register\n        reg_data <= 8'd0;\n    end else begin\n        // Normal operation: latch input data\n        reg_data <= data_in;\n    end\nend\n\n// Continuous assignment for output\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals and registers\nlogic [7:0] register_data;\n\n// Combinational logic\nassign data_out = register_data;\n\n// Sequential logic (registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset condition\n        register_data <= 8'd0;\n    end else begin\n        // Normal operation\n        register_data <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals and variables\nlogic [7:0] internal_reg;\n\n// Sequential logic (registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0; // Reset to zero\n    end else begin\n        internal_reg <= data_in; // Load input data\n    end\nend\n\n// Combinational logic (output assignment)\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 15, "code": "module example_module (\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 13, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 15, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 12, "code": "module example_module(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\n// Internal signals\nreg [7:0] internal_reg;\n\n// Sequential logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 12, "code": "module example_module(\n    input  logic clk,  \n    input  logic rst_n, \n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_out + 8'd1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nreg [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 14, "code": "// Example Verilog Module: 8-bit Carry Ripple Adder\n\nmodule carry_ripple_adder (\n    input [7:0] a,   // First 8-bit operand\n    input [7:0] b,   // Second 8-bit operand\n    input cin,       // Carry-in bit\n    output [7:0] sum, // 8-bit sum output\n    output cout      // Carry-out bit\n);\n\n    // Internal carry signals\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    // Full adder instances\n    full_adder fa0(a[0], b[0], cin, sum[0], c1);\n    full_adder fa1(a[1], b[1], c1, sum[1], c2);\n    full_adder fa2(a[2], b[2], c2, sum[2], c3);\n    full_adder fa3(a[3], b[3], c3, sum[3], c4);\n    full_adder fa4(a[4], b[4], c4, sum[4], c5);\n    full_adder fa5(a[5], b[5], c5, sum[5], c6);\n    full_adder fa6(a[6], b[6], c6, sum[6], c7);\n    full_adder fa7(a[7], b[7], c7, sum[7], cout);\n\nendmodule\n\n// Full Adder submodule\nmodule full_adder (\n    input a, b, cin,\n    output sum, cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= reg_data + 1;\n    end\nend\n\n// Combinational logic\nassign data_out = reg_data;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 15, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] counter;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 8'd0;\n    end else begin\n        counter <= counter + 1'b1;\n    end\nend\n\nassign data_out = counter;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Combinational logic\nalways_comb begin\n    data_out = reg_data;\nend\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Continuous assignment\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 12, "code": "module example_module (\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Reset logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Output logic\nalways_comb begin\n    data_out = internal_reg;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 14, "code": "module fsm_example(\n    input logic clk,\n    input logic rst_n,\n    input logic start,\n    output logic busy,\n    output logic done\n);\n\n// Define the states\ntypedef enum logic[1:0] {\n    IDLE = 2'b00,\n    WORK = 2'b01,\n    DONE = 2'b10\n} state_t;\n\n// Current and next state\nstate_t current_state, next_state;\n\n// Sequential logic for state register\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        current_state <= IDLE;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Combinatorial logic for next state and outputs\nalways_comb begin\n    next_state = current_state;\n    busy = 1'b0;\n    done = 1'b0;\n\n    case (current_state)\n        IDLE: begin\n            if (start) begin\n                next_state = WORK;\n            end\n            done = 1'b0;\n            busy = 1'b0;\n        end\n        \n        WORK: begin\n            next_state = WORK; // Stay in WORK until some condition is met\n            busy = 1'b1;\n            done = 1'b0;\n        end\n        \n        DONE: begin\n            next_state = IDLE;\n            busy = 1'b0;\n            done = 1'b1;\n        end\n        \n        default: begin\n            next_state = IDLE;\n            busy = 1'b0;\n            done = 1'b0;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 10, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 10, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 14, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 12, "code": "// Verilog code for a basic 2-input AND gate\nmodule and_gate(\n    input logic a, \n    input logic b, \n    output logic y\n);\n\nassign y = a & b;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= '0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Combinatorial logic\nalways_comb begin\n    data_out = internal_reg;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [31:0] data_in,\n    output logic [31:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 32'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Combinational logic\nalways_comb begin\n    data_out = internal_reg;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 16, "code": "module example_module(\n    input logic clk,\n    input logic rst_n,\n    input logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways @(*) begin\n    data_out = data_in;\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 14, "code": "module example_module(\n    input  logic clk,  \n    input  logic rst_n, \n    input  logic [7:0] data_in, \n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinatorial logic\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 16, "code": "module example_module(\n    input   logic   clk,       // Clock signal\n    input   logic   rst_n,     // Active-low reset\n    input   logic   [7:0] data_in, // Input data (8 bits)\n    output  logic   [7:0] data_out // Output data (8 bits)\n);\n\n// Internal signals\nlogic [7:0] reg_data; // Registered data\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset logic: clear registered data\n        reg_data <= 8'd0;\n    end else begin\n        // Normal operation: capture input data\n        reg_data <= data_in;\n    end\nend\n\n// Continuous assignment for output\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 16, "code": "module example_module(\n    input   logic   clk,\n    input   logic   rst_n,\n    input   logic   [7:0] data_in,\n    output  logic   [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule: example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 14, "code": "module example_module(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\nreg [7:0] data_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'b0;\n    end else begin\n        data_reg <= data_in;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 11, "code": "// Define the module (replace 'module_name' with your actual module name)\nmodule module_name(\n    // List input ports (replace 'input_data' with actual port names and widths)\n    input logic [7:0] input_data,\n    // List output ports (replace 'output_data' with actual port names and widths)\n    output logic [7:0] output_data\n);\n\n// Internal signals (if needed)\nlogic [7:0] internal_signal;\n\n// Example combinational logic (replace with your actual logic)\nalways_comb begin\n    output_data = input_data + internal_signal;\nend\n\n// Example sequential logic (if needed)\nalways_ff @(posedge clk) begin\n    internal_signal <= input_data;\nend\n\nendmodule : module_name", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 17, "code": "// Define a module named \"my_counter\" with input clock (clk) and output count (out_count)\nmodule my_counter(clk, out_count);\n    input clk; // Clock input\n    output [3:0] out_count; // 4-bit output counter\n    \n    // Internal variable to store the counter value\n    reg [3:0] count = 4'd0;\n    \n    // Always block triggered by the rising edge of the clock\n    always @(posedge clk) begin\n        count <= count + 1; // Increment the counter\n        if (count == 4'd9) begin\n            count <= 4'd0; // Reset to zero when reaching 9\n        end\n    end\n    \n    // Continuous assignment to output the current count value\n    assign out_count = count;\nendmodule\n\n// Define another module named \"my_mux\" with input select (sel) and data (data_in)\nmodule my_mux(sel, data_in, data_out);\n    input [1:0] sel; // 2-bit select signal\n    input [7:0] data_in[3:0]; // Array of 8-bit inputs\n    output [7:0] data_out; // 8-bit output\n    \n    // Use a case statement to select the output based on the sel input\n    always @(*) begin\n        case (sel)\n            2'd0: data_out = data_in[0];\n            2'd1: data_out = data_in[1];\n            2'd2: data_out = data_in[2];\n            2'd3: data_out = data_in[3];\n            default: data_out = 8'd0; // Default to zero if sel is invalid\n        endcase\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 16, "code": "module example_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_data <= 8'd0;  // Reset to zero\n    end else begin\n        reg_data <= data_in;  // Capture input data on rising clock edge\n    end\nend\n\n// Combinational logic\nassign data_out = reg_data;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 13, "code": "// Define the module (replace with your actual module name and ports)\nmodule example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0]  data_in,\n    output logic [7:0]  data_out\n);\n\n// Define internal signals if needed\nlogic [7:0] internal_data;\n\n// Example sequential logic (e.g., a register)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= internal_data;\n    end\nend\n\n// Example combinational logic\nalways_comb begin\n    internal_data = data_in + 8'd1; // Example operation (increment data)\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 17, "code": "module example_module(\n    input       clk,\n    input       rst_n,\n    input       [7:0] data_in,\n    output      [7:0] data_out\n);\n\nreg    [7:0]    data_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_in;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 15, "code": "// Example Verilog Module: 8-bit Full Adder\nmodule full_adder_8bit(a, b, cin, sum, cout);\n    input   [7:0] a, b;\n    input   cin;\n    output  [7:0] sum;\n    output  cout;\n    \n    assign {cout, sum} = a + b + cin;\nendmodule\n\n// Example Verilog Testbench\nmodule full_adder_8bit_tb();\n    reg [7:0] a, b;\n    reg cin;\n    wire [7:0] sum;\n    wire cout;\n    \n    full_adder_8bit uut(a, b, cin, sum, cout);\n    \n    initial begin\n        a = 8'b00000000; b = 8'b00000000; cin = 1'b0;\n        #10; $display(\"a = %b, b = %b, cin = %b, sum = %b, cout = %b\", a, b, cin, sum, cout);\n        \n        a = 8'b11111111; b = 8'b00000001; cin = 1'b0;\n        #10; $display(\"a = %b, b = %b, cin = %b, sum = %b, cout = %b\", a, b, cin, sum, cout);\n        \n        a = 8'b11111111; b = 8'b00000001; cin = 1'b1;\n        #10; $display(\"a = %b, b = %b, cin = %b, sum = %b, cout = %b\", a, b, cin, sum, cout);\n        \n        #10; $finish;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] counter;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 8'd0;\n    end else begin\n        counter <= counter + 8'd1;\n    end\nend\n\nassign data_out = counter;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic reset_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nalways_comb begin\n    data_out = reg_data;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 14, "code": "// Module Definition\nmodule my_module(\n    input  logic clk,    // Clock signal\n    input  logic reset_n, // Active low reset\n    input  logic [7:0] data_in, // 8-bit input data\n    output logic [7:0] data_out // 8-bit output data\n);\n\n// Internal Signals\nlogic [7:0] internal_reg; // 8-bit internal register\n\n// Sequential Logic (on clock edge)\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin // Reset condition\n        internal_reg <= 8'd0; // Reset register to zero\n    end else begin\n        internal_reg <= data_in; // Capture input data\n    end\nend\n\n// Combinational Logic\nalways_comb begin\n    data_out = internal_reg; // Output is current register value\nend\n\n// Alternative way to write the same functionality\n//assign data_out = (reset_n) ? internal_reg : 8'd0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 15, "code": "module hardware_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals and variables\nlogic [7:0] internal_reg;\n\n// Combinational logic\nalways_comb begin\n    data_out = internal_reg;\nend\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 12, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 13, "code": "module example_module(\n    input   logic   clk,\n    input   logic   rst_n,\n    input   logic   [7:0] data_in,\n    output  logic   [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 15, "code": "module example_module(\n    input logic clk,\n    input logic rst_n,\n    input logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 13, "code": "module ExampleModule(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @ (posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic[7:0] data_in,\n    output logic[7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 17, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 17, "code": "module example_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal registers\nreg [7:0] data_reg;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0; // Reset to zero\n    end else begin\n        data_reg <= data_in; // Capture input data on rising clock edge\n    end\nend\n\n// Combinational logic\nassign data_out = data_reg; // Output is the current value of the register\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 15, "code": "module example_module(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\n// Internal signals\nreg [7:0] data_reg;\n\n// Sequential logic\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 16, "code": "module counter(\n    input           clk,\n    input           rst_n,\n    output          [7:0] count\n);\n\nreg [7:0] count_reg;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count_reg <= 8'd0;\n    end else begin\n        count_reg <= count_reg + 8'd1;\n    end\nend\n\nassign count = count_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 16, "code": "// Module Declaration\nmodule example_module(\n    input  logic clk,      // Clock input\n    input  logic rst_n,    // Active-low reset\n    input  logic [7:0] data_in, // 8-bit input data\n    output logic [7:0] data_out // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nalways_comb begin\n    data_out = reg_data + 8'd1; // Increment the registered data by 1\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 17, "code": "// Module declaration\nmodule example_module(\n    input  logic clk,    // Clock input\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signal declaration\nlogic [7:0] internal_reg;\n\n// Always block for sequential logic (clocked process)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset condition: clear the internal register\n        internal_reg <= 8'd0;\n    end else begin\n        // On clock edge: update internal register with input data\n        internal_reg <= data_in;\n    end\nend\n\n// Continuous assignment for output\nassign data_out = internal_reg;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 17, "code": "module example_module(\n    input  logic clk,  \n    input  logic rst_n, \n    input  logic [7:0] data_in, \n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Combinatorial logic\nalways_comb begin\n    data_out = internal_reg + data_in;\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic reset_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 16, "code": "module example_module(\n    input  logic clk,      // Clock signal\n    input  logic rst_n,    // Active-low reset\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic (registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals and registers\nlogic [7:0] reg_data;\n\n// Sequential logic (registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nalways_comb begin\n    data_out = reg_data;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_extend_csr", "codeid": 20, "code": "module counter(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] count\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        count <= 8'd0;\n    end else begin\n        count <= count + 1'b1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 17, "code": "// Define the module (replace with your actual module name and ports)\nmodule example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Example combinational logic\nalways_comb begin\n    data_out = data_in + 8'd1;\nend\n\n// Example sequential logic (D-flipflop)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 19, "code": "module example_module (\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Combinational logic\nalways_comb begin\n    data_out = (rst_n) ? internal_reg : 8'd0;\nend\n\n// Sequential logic (registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 17, "code": "module your_module_name(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 17, "code": "module example_module(\n    input  logic clk,    // Clock input\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Example combinational logic\nalways_comb begin\n    data_out = data_in + 8'd1;  // Increment input by 1\nend\n\n// Example sequential logic (D Flip-Flop)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;  // Reset to zero\n    end else begin\n        data_out <= data_in;  // Capture input on rising clock edge\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 14, "code": "module example_module(\n    input logic clk,\n    input logic rst_n,\n    input logic [7:0] data,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic reset_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 18, "code": "module my_counter(\n    input   clk,\n    input   rst_n,\n    output  reg [7:0] count = 8'd0\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        count <= 8'd0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_in;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 19, "code": "// Verilog code for a basic 4-bit counter with asynchronous reset\nmodule counter_4bit(\n    input clk,\n    input reset_n,\n    output reg [3:0] count = 4'b0000\n);\n\nalways @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        count <= 4'b0000;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 20, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 20, "code": "module my_module(\n    input  logic clk,    // Clock signal\n    input  logic reset_n, // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal registers\nlogic [7:0] reg_data;\n\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        // Reset condition: clear the register\n        reg_data <= 8'd0;\n    end else begin\n        // Normal operation: load data_in into reg_data\n        reg_data <= data_in;\n    end\nend\n\n// Continuous assignment for output\nassign data_out = reg_data;\n\nendmodule : my_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 15, "code": "module example_module(\n    input   logic   clk,\n    input   logic   rst_n,\n    input   logic   [7:0]  data_in,\n    output  logic   [7:0]  data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 18, "code": "// Module declaration\nmodule example_module(\n    input  logic clk,         // Clock input\n    input  logic rst_n,       // Active-low reset\n    input  logic [7:0] data_in, // 8-bit input data\n    output logic [7:0] data_out // 8-bit output data\n);\n\n// Internal signal declaration\nlogic [7:0] internal_reg;\n\n// Always block for sequential logic (reset and clock)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'b0; // Reset to zero\n    end else begin\n        internal_reg <= data_in; // Capture input data on clock edge\n    end\nend\n\n// Continuous assignment for output\nassign data_out = internal_reg;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 19, "code": "// Define the module\nmodule example_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Sequential logic (flip-flop)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_reg <= 8'd0;  // Reset to zero\n    end else begin\n        internal_reg <= data_in;  // Capture input data\n    end\nend\n\n// Combinational logic\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 18, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_data <= '0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nalways_comb begin\n    data_out = reg_data;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 17, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 20, "code": "module example_module(\n    input logic clk,\n    input logic rst_n,\n    input logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 19, "code": "module example_module(\n    input logic clk,\n    input logic rst_n,\n    input logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 19, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 20, "code": "module example_module(\n    input logic clk,\n    input logic rst_n,\n    input logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 20, "code": "module example_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;  // Reset to zero\n    end else begin\n        data_reg <= data_in;  // Capture input data on rising clock edge\n    end\nend\n\nassign data_out = data_reg;  // Continuous assignment\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 20, "code": "module example_module(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\n// Internal signals\nreg [7:0] data_reg;\n\n// Always block for sequential logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_in;\n    end\nend\n\n// Assign output\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 20, "code": "// Define a basic AND gate module\nmodule and_gate(\n    input  logic a, \n    input  logic b, \n    output logic out\n);\n\n// Continuous assignment for AND operation\nassign out = a & b;\n\nendmodule\n\n// Define a basic D-flipflop module\nmodule d_flipflop(\n    input  logic clk, \n    input  logic reset, \n    input  logic d, \n    output logic q\n);\n\n// Sequential logic for D-flipflop\nalways_ff @(posedge clk or negedge reset) begin\n    if (!reset) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n\n// Define a 4-to-1 multiplexer module\nmodule mux4to1(\n    input  logic [1:0] sel, \n    input  logic [3:0] in0, \n    input  logic [3:0] in1, \n    input  logic [3:0] in2, \n    input  logic [3:0] in3, \n    output logic [3:0] out\n);\n\n// Continuous assignment for multiplexing\nassign out = (sel == 2'b00) ? in0 :\n             (sel == 2'b01) ? in1 :\n             (sel == 2'b10) ? in2 :\n             (sel == 2'b11) ? in3 :\n             4'bxxxx;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 19, "code": "// Verilog module template\nmodule my_module(\n    // Input ports\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    \n    // Output ports\n    output logic [7:0] data_out,\n    output logic valid_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\nlogic       internal_valid;\n\n// Combinatorial logic\nalways_comb begin\n    data_out = internal_reg;\n    valid_out = internal_valid;\nend\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_reg <= 8'd0;\n        internal_valid <= 1'b0;\n    end else begin\n        internal_reg <= data_in;\n        internal_valid <= 1'b1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 20, "code": "module example_module (\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic reset_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @ (posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 20, "code": "module MyModule(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 20, "code": "// Define a module named \"my_module\" with two inputs (clk, reset) and one output (out_data)\nmodule my_module(\n    input clk,\n    input reset,\n    output reg [7:0] out_data\n);\n\n// Always block to handle clock edge and reset\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        // Reset out_data to zero when reset is high\n        out_data <= 8'd0;\n    end else begin\n        // Increment out_data by 1 on every positive clock edge when reset is low\n        out_data <= out_data + 8'd1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 19, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 20, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 20, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
