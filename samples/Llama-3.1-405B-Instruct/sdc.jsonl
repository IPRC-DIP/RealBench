{"task": "sd_bd", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input               clk,\n    input               rst,\n    input               we_m,\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output  [BD_WIDTH-1:0] free_bd,\n    input               re_s,\n    output              ack_o_s,\n    input               a_cmp,\n    output [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nreg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [BD_WIDTH-1:0] free_bd_reg;\nreg [1:0] new_bw;\nreg [1:0] last_a_cmp;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd_reg <= (RAM_MEM_WIDTH == 32) ? BD_SIZE/2 : BD_SIZE/4;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Writing Buffer Descriptor\n        if (we_m) begin\n            if (free_bd_reg > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                if (m_wr_pnt == BD_SIZE) begin\n                    m_wr_pnt <= 0;\n                end\n                if (new_bw == (RAM_MEM_WIDTH == 32) ? 1 : 3) begin\n                    free_bd_reg <= free_bd_reg - 1;\n                    new_bw <= 0;\n                end else begin\n                    new_bw <= new_bw + 1;\n                end\n            end\n        end\n\n        // Reading Buffer Descriptor\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= s_rd_pnt + 1;\n            if (s_rd_pnt == BD_SIZE) begin\n                s_rd_pnt <= 0;\n            end\n            if (RAM_MEM_WIDTH == 16) begin\n                ack_o_s <= 1;\n            end\n        end\n\n        // Releasing Buffer Descriptor\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nassign free_bd = free_bd_reg;\nassign ack_o_s = (RAM_MEM_WIDTH == 16) ? 1 : 0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 2, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Define the sd_bd module\nmodule sd_bd(\n    // Input ports\n    input clk, // System clock\n    input rst, // Asynchronous reset, active high\n    input we_m, // Write enable signal\n    input [RAM_MEM_WIDTH-1:0] dat_in_m, // Input data for writing BD\n    input re_s, // Read enable signal\n    input a_cmp, // SD card operation completion\n\n    // Output ports\n    output [BD_WIDTH-1:0] free_bd, // Number of free buffer descriptors\n    output ack_o_s, // Read operation acknowledgment\n    output [RAM_MEM_WIDTH-1:0] dat_out_s // Output data from reading BD\n);\n\n// Define internal signals and variables\nreg [BD_WIDTH-1:0] free_bd_reg; // Register for free_bd output\nreg ack_o_s_reg; // Register for ack_o_s output\nreg [RAM_MEM_WIDTH-1:0] dat_out_s_reg; // Register for dat_out_s output\nreg [BD_WIDTH-1:0] m_wr_pnt; // Write pointer\nreg [BD_WIDTH-1:0] s_rd_pnt; // Read pointer\nreg [1:0] write_counter; // Write counter\nreg [1:0] read_counter; // Read counter\nreg new_bw; // New buffer write flag\nreg last_a_cmp; // Last a_cmp signal\n\n// Initialize the module\ninitial begin\n    free_bd_reg = (BD_SIZE / 2); // Initialize free_bd counter to half of BD_SIZE\n    m_wr_pnt = 0; // Reset write pointer\n    s_rd_pnt = 0; // Reset read pointer\n    write_counter = 0; // Reset write counter\n    read_counter = 0; // Reset read counter\n    new_bw = 0; // Reset new buffer write flag\n    last_a_cmp = 0; // Reset last a_cmp signal\nend\n\n// Write buffer descriptor\nalways @(posedge clk) begin\n    if (we_m) begin\n        if (free_bd_reg > 0) begin\n            // Write data to bd_mem\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            write_counter <= write_counter + 1;\n            if (write_counter == 2) begin // 32-bit mode: two writes complete one BD\n                new_bw <= 1;\n                free_bd_reg <= free_bd_reg - 1;\n                write_counter <= 0;\n            end else if (write_counter == 4) begin // 16-bit mode: four writes complete one BD\n                new_bw <= 1;\n                free_bd_reg <= free_bd_reg - 1;\n                write_counter <= 0;\n            end\n        end\n    end\nend\n\n// Read buffer descriptor\nalways @(posedge clk) begin\n    if (re_s) begin\n        dat_out_s_reg <= bd_mem[s_rd_pnt];\n        s_rd_pnt <= s_rd_pnt + 1;\n        read_counter <= read_counter + 1;\n        if (read_counter == 2) begin // 32-bit mode: two reads obtain complete BD information\n            ack_o_s_reg <= 1;\n            read_counter <= 0;\n        end else if (read_counter == 4) begin // 16-bit mode: four reads obtain complete BD information\n            ack_o_s_reg <= 1;\n            read_counter <= 0;\n        end\n    end\nend\n\n// Release buffer descriptor\nalways @(posedge clk) begin\n    if (a_cmp && !last_a_cmp) begin\n        free_bd_reg <= free_bd_reg + 1;\n    end\n    last_a_cmp <= a_cmp;\nend\n\n// Circular operation\nalways @(posedge clk) begin\n    if (m_wr_pnt == BD_SIZE - 1) begin\n        m_wr_pnt <= 0;\n    end\n    if (s_rd_pnt == BD_SIZE - 1) begin\n        s_rd_pnt <= 0;\n    end\nend\n\n// Assign output signals\nassign free_bd = free_bd_reg;\nassign ack_o_s = ack_o_s_reg;\nassign dat_out_s = dat_out_s_reg;\n\n// Define the bd_mem array\nreg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd(\n    input               clk,\n    input               rst,\n    input               we_m,\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output  [BD_WIDTH-1:0] free_bd,\n    input               re_s,\n    output              ack_o_s,\n    input               a_cmp,\n    output [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal signals and variables\nreg [BD_WIDTH-1:0] free_bd_reg;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [1:0] write_counter;\nreg [1:0] read_counter;\nreg new_bw;\nreg last_a_cmp;\n\n// Initialize free_bd counter and pointers\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        free_bd_reg <= (RAM_MEM_WIDTH == 32) ? BD_SIZE / 2 : BD_SIZE / 4;\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        write_counter <= 0;\n        read_counter <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Update free_bd counter and pointers\n        if (we_m && (free_bd_reg > 0)) begin\n            if (write_counter == (RAM_MEM_WIDTH == 32) ? 1 : 3) begin\n                free_bd_reg <= free_bd_reg - 1;\n                new_bw <= 1;\n            end\n            write_counter <= write_counter + 1;\n            m_wr_pnt <= m_wr_pnt + 1;\n        end else if (re_s) begin\n            if (read_counter == (RAM_MEM_WIDTH == 32) ? 1 : 3) begin\n                s_rd_pnt <= s_rd_pnt + 1;\n            end\n            read_counter <= read_counter + 1;\n        end\n\n        // Update ack_o_s\n        if (re_s && (RAM_MEM_WIDTH == 16)) begin\n            ack_o_s <= 1;\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Update last_a_cmp\n        last_a_cmp <= a_cmp;\n\n        // Update free_bd counter on a_cmp rising edge\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n    end\nend\n\n// Write data to bd_mem\nalways @(posedge clk) begin\n    if (we_m) begin\n        bd_mem[m_wr_pnt] <= dat_in_m;\n    end\nend\n\n// Read data from bd_mem\nalways @(posedge clk) begin\n    if (re_s) begin\n        dat_out_s <= bd_mem[s_rd_pnt];\n    end\nend\n\n// Assign output signals\nassign free_bd = free_bd_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 4, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\nmodule sd_bd (\n    // Input ports\n    input               clk,          // System clock\n    input               rst,          // Asynchronous reset, active high\n    input               we_m,         // Write enable signal\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m,  // Input data for writing BD\n    input               re_s,         // Read enable signal\n    input               a_cmp,        // SD card operation completion\n\n    // Output ports\n    output  [BD_WIDTH-1:0] free_bd,    // Number of free buffer descriptors\n    output              ack_o_s,      // Read operation acknowledgment\n    output  [RAM_MEM_WIDTH-1:0] dat_out_s  // Output data from reading BD\n);\n\n// Internal signals and variables\nreg     [BD_WIDTH-1:0] free_bd_reg;\nreg     [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\nreg     [BD_WIDTH-1:0] m_wr_pnt;\nreg     [BD_WIDTH-1:0] s_rd_pnt;\nreg               new_bw;\nreg               last_a_cmp;\n\n// Initialize the free_bd counter and pointers on system reset\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        free_bd_reg <= (BIG_ENDIAN) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Update the free_bd counter and pointers based on write and read operations\n        if (we_m) begin\n            // Write operation\n            if (free_bd_reg > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                if ((BIG_ENDIAN && m_wr_pnt % 2 == 0) || (!BIG_ENDIAN && m_wr_pnt % 4 == 0)) begin\n                    free_bd_reg <= free_bd_reg - 1;\n                    new_bw <= 1;\n                end else begin\n                    new_bw <= 0;\n                end\n            end\n        end else if (re_s) begin\n            // Read operation\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= s_rd_pnt + 1;\n            if (BIG_ENDIAN && s_rd_pnt % 2 == 0) begin\n                ack_o_s <= 1;\n            end else if (!BIG_ENDIAN && s_rd_pnt % 4 == 0) begin\n                ack_o_s <= 1;\n            end else begin\n                ack_o_s <= 0;\n            end\n        end else if (a_cmp && !last_a_cmp) begin\n            // SD card operation completion\n            free_bd_reg <= free_bd_reg + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\n// Assign the output ports\nassign free_bd = free_bd_reg;\nassign ack_o_s = (BIG_ENDIAN && s_rd_pnt % 2 == 0) || (!BIG_ENDIAN && s_rd_pnt % 4 == 0);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 5, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Module declaration for sd_bd\nmodule sd_bd(\n    // Input ports\n    input             clk,        // System clock\n    input             rst,        // Asynchronous reset, active high\n    input             we_m,       // Write enable signal\n    input  [RAM_MEM_WIDTH-1:0] dat_in_m, // Input data for writing BD\n    input             re_s,       // Read enable signal\n    input             a_cmp,      // SD card operation completion\n\n    // Output ports\n    output [BD_WIDTH-1:0] free_bd, // Number of free buffer descriptors\n    output             ack_o_s,   // Read operation acknowledgment\n    output [RAM_MEM_WIDTH-1:0] dat_out_s // Output data from reading BD\n);\n\n// Internal signals and variables\nreg [BD_WIDTH-1:0] free_bd_reg; // Register for free_bd\nreg [RAM_MEM_WIDTH-1:0] dat_out_s_reg; // Register for dat_out_s\nreg [BD_WIDTH-1:0] m_wr_pnt; // Write pointer\nreg [BD_WIDTH-1:0] s_rd_pnt; // Read pointer\nreg [1:0] write_cnt; // Write counter\nreg [1:0] read_cnt; // Read counter\nreg new_bw; // New buffer write flag\nreg last_a_cmp; // Last a_cmp signal\n\n// Initialize free_bd, m_wr_pnt, and s_rd_pnt on reset\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        free_bd_reg <= (RAM_MEM_WIDTH == 32) ? BD_SIZE / 2 : BD_SIZE / 4;\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        write_cnt <= 0;\n        read_cnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Update free_bd, m_wr_pnt, and s_rd_pnt based on we_m, re_s, and a_cmp\n        if (we_m) begin\n            if (write_cnt == (RAM_MEM_WIDTH == 32) ? 1 : 3) begin\n                free_bd_reg <= free_bd_reg - 1;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_cnt <= 0;\n                new_bw <= 1;\n            end else begin\n                write_cnt <= write_cnt + 1;\n            end\n        end\n\n        if (re_s) begin\n            if (read_cnt == (RAM_MEM_WIDTH == 32) ? 1 : 3) begin\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_cnt <= 0;\n            end else begin\n                read_cnt <= read_cnt + 1;\n            end\n        end\n\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n\n        last_a_cmp <= a_cmp;\n    end\nend\n\n// Assign output ports\nassign free_bd = free_bd_reg;\nassign ack_o_s = (re_s && read_cnt == (RAM_MEM_WIDTH == 32) ? 1 : 3);\nassign dat_out_s = dat_out_s_reg;\n\n// Update dat_out_s_reg based on re_s and s_rd_pnt\nalways @(posedge clk) begin\n    if (re_s) begin\n        dat_out_s_reg <= dat_out_s_reg; // Update dat_out_s_reg based on s_rd_pnt\n    end else begin\n        dat_out_s_reg <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 6, "code": "// Include the sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\n// Module declaration\nmodule sd_bd(\n    // Input ports\n    input clk,            // System clock\n    input rst,            // Asynchronous reset, active high\n    input we_m,           // Write enable signal\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,  // Input data for writing BD\n    input re_s,           // Read enable signal\n    input a_cmp,          // SD card operation completion\n\n    // Output ports\n    output [BD_WIDTH-1:0] free_bd,      // Number of free buffer descriptors\n    output ack_o_s,       // Read operation acknowledgment\n    output [RAM_MEM_WIDTH-1:0] dat_out_s  // Output data from reading BD\n);\n\n// Internal signals and variables\nreg [BD_WIDTH-1:0] free_bd_reg;  // Register for free buffer descriptors\nreg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];  // Buffer descriptor memory\nreg [BD_WIDTH-1:0] m_wr_pnt;  // Write pointer\nreg [BD_WIDTH-1:0] s_rd_pnt;  // Read pointer\nreg new_bw;  // New buffer write flag\nreg last_a_cmp;  // Last SD card operation completion flag\nreg ack_o_s_reg;  // Register for read operation acknowledgment\n\n// Initialize free_bd counter based on RAM_MEM_WIDTH\ninitial begin\n    if (RAM_MEM_WIDTH == 32) begin\n        free_bd_reg = BD_SIZE / 2;\n    end else if (RAM_MEM_WIDTH == 16) begin\n        free_bd_reg = BD_SIZE / 4;\n    end\nend\n\n// Reset logic\nalways @(posedge rst or posedge clk) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n        ack_o_s_reg <= 0;\n    end else begin\n        // Update write pointer and new buffer write flag\n        if (we_m) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                if (new_bw) begin\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    new_bw <= 0;\n                end else begin\n                    new_bw <= 1;\n                end\n            end else if (RAM_MEM_WIDTH == 16) begin\n                if (new_bw == 3) begin\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    new_bw <= 0;\n                end else begin\n                    new_bw <= new_bw + 1;\n                end\n            end\n        end\n\n        // Update read pointer and acknowledgment flag\n        if (re_s) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                if (ack_o_s_reg) begin\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    ack_o_s_reg <= 0;\n                end else begin\n                    ack_o_s_reg <= 1;\n                end\n            end else if (RAM_MEM_WIDTH == 16) begin\n                if (ack_o_s_reg == 3) begin\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    ack_o_s_reg <= 0;\n                end else begin\n                    ack_o_s_reg <= ack_o_s_reg + 1;\n                end\n            end\n        end\n\n        // Update last SD card operation completion flag\n        last_a_cmp <= a_cmp;\n    end\nend\n\n// Update free buffer descriptors counter\nalways @(posedge clk) begin\n    if (new_bw) begin\n        free_bd_reg <= free_bd_reg - 1;\n    end else if (a_cmp && !last_a_cmp) begin\n        free_bd_reg <= free_bd_reg + 1;\n    end\nend\n\n// Assign output ports\nassign free_bd = free_bd_reg;\nassign ack_o_s = ack_o_s_reg;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 7, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Define the sd_bd module\nmodule sd_bd(\n    // Input ports\n    input clk,            // System clock\n    input rst,            // Asynchronous reset, active high\n    input we_m,           // Write enable signal\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,  // Input data for writing BD\n    input re_s,           // Read enable signal\n    input a_cmp,          // SD card operation completion\n\n    // Output ports\n    output [BD_WIDTH-1:0] free_bd,      // Number of free buffer descriptors\n    output ack_o_s,      // Read operation acknowledgment\n    output [RAM_MEM_WIDTH-1:0] dat_out_s  // Output data from reading BD\n);\n\n// Define internal signals and variables\nreg [BD_WIDTH-1:0] free_bd_reg;  // Register for free buffer descriptors\nreg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];  // Buffer descriptor memory\nreg [BD_WIDTH-1:0] m_wr_pnt;  // Write pointer\nreg [BD_WIDTH-1:0] s_rd_pnt;  // Read pointer\nreg new_bw;  // New buffer write flag\nreg last_a_cmp;  // Last SD card operation completion flag\n\n// Initialize the free_bd counter based on the RAM_MEM_WIDTH\ninitial begin\n    if (RAM_MEM_WIDTH == 32) begin\n        free_bd_reg = BD_SIZE / 2;\n    end else if (RAM_MEM_WIDTH == 16) begin\n        free_bd_reg = BD_SIZE / 4;\n    end\nend\n\n// Reset the module\nalways @(posedge rst or posedge clk) begin\n    if (rst) begin\n        free_bd_reg <= 0;\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Update the free_bd counter and pointers\n        if (we_m && (free_bd_reg > 0)) begin\n            // Write operation\n            if (RAM_MEM_WIDTH == 32) begin\n                // 32-bit mode: Two writes complete one BD\n                if (new_bw == 0) begin\n                    bd_mem[m_wr_pnt] <= dat_in_m;\n                    new_bw <= 1;\n                end else begin\n                    bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][15:0], dat_in_m[15:0]};\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    free_bd_reg <= free_bd_reg - 1;\n                    new_bw <= 0;\n                end\n            end else if (RAM_MEM_WIDTH == 16) begin\n                // 16-bit mode: Four writes complete one BD\n                if (new_bw == 0) begin\n                    bd_mem[m_wr_pnt] <= {16'd0, dat_in_m};\n                    new_bw <= 1;\n                end else if (new_bw == 1) begin\n                    bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][15:0], dat_in_m};\n                    new_bw <= 2;\n                end else if (new_bw == 2) begin\n                    bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][15:0], {8'd0, dat_in_m[7:0]}};\n                    new_bw <= 3;\n                end else begin\n                    bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][15:0], {8'd0, dat_in_m[7:0]}};\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    free_bd_reg <= free_bd_reg - 1;\n                    new_bw <= 0;\n                end\n            end\n        end\n\n        // Update the read pointer and output data\n        if (re_s) begin\n            // Read operation\n            if (RAM_MEM_WIDTH == 32) begin\n                // 32-bit mode: Two reads obtain complete BD information\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n            end else if (RAM_MEM_WIDTH == 16) begin\n                // 16-bit mode: Four reads obtain complete BD information\n                dat_out_s <= bd_mem[s_rd_pnt][15:0];\n                s_rd_pnt <= s_rd_pnt + 1;\n                ack_o_s <= 1;\n            end\n        end\n\n        // Update the free_bd counter on SD card operation completion\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\n// Assign the output signals\nassign free_bd = free_bd_reg;\nassign ack_o_s = (re_s && (RAM_MEM_WIDTH == 16)) ? 1 : 0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd(\n    input               clk,\n    input               rst,\n    input               we_m,\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output  [BD_WIDTH-1:0] free_bd,\n    input               re_s,\n    output              ack_o_s,\n    input               a_cmp,\n    output [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal signals and variables\nreg [BD_WIDTH-1:0] free_bd_reg;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [1:0] write_cnt;\nreg [1:0] read_cnt;\nreg new_bw;\nreg last_a_cmp;\n\n// Initialize free_bd counter and pointers\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        if (RAM_MEM_WIDTH == 32) begin\n            free_bd_reg <= BD_SIZE / 2;\n        end else if (RAM_MEM_WIDTH == 16) begin\n            free_bd_reg <= BD_SIZE / 4;\n        end\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        write_cnt <= 0;\n        read_cnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Update free_bd counter\n        if (new_bw) begin\n            free_bd_reg <= free_bd_reg - 1;\n            new_bw <= 0;\n        end else if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n\n        // Update write pointer\n        if (we_m) begin\n            if (write_cnt == 1 && RAM_MEM_WIDTH == 32) begin\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_cnt <= 0;\n            end else if (write_cnt == 3 && RAM_MEM_WIDTH == 16) begin\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_cnt <= 0;\n            end else begin\n                write_cnt <= write_cnt + 1;\n            end\n        end\n\n        // Update read pointer\n        if (re_s) begin\n            if (read_cnt == 1 && RAM_MEM_WIDTH == 32) begin\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_cnt <= 0;\n            end else if (read_cnt == 3 && RAM_MEM_WIDTH == 16) begin\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_cnt <= 0;\n            end else begin\n                read_cnt <= read_cnt + 1;\n            end\n        end\n\n        // Update last_a_cmp\n        last_a_cmp <= a_cmp;\n    end\nend\n\n// Write buffer descriptor\nalways @(posedge clk) begin\n    if (we_m) begin\n        if (RAM_MEM_WIDTH == 32) begin\n            if (write_cnt == 0) begin\n                bd_mem[m_wr_pnt] <= {dat_in_m, 16'd0};\n            end else begin\n                bd_mem[m_wr_pnt] <= {16'd0, dat_in_m};\n                new_bw <= 1;\n            end\n        end else if (RAM_MEM_WIDTH == 16) begin\n            case (write_cnt)\n                0: bd_mem[m_wr_pnt] <= {dat_in_m, 16'd0};\n                1: bd_mem[m_wr_pnt] <= {16'd0, dat_in_m};\n                2: bd_mem[m_wr_pnt] <= {dat_in_m, 16'd0};\n                3: begin\n                    bd_mem[m_wr_pnt] <= {16'd0, dat_in_m};\n                    new_bw <= 1;\n                end\n            endcase\n        end\n    end\nend\n\n// Read buffer descriptor\nalways @(posedge clk) begin\n    if (re_s) begin\n        if (RAM_MEM_WIDTH == 32) begin\n            if (read_cnt == 0) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n            end else begin\n                dat_out_s <= {bd_mem[s_rd_pnt][15:0], 16'd0};\n            end\n        end else if (RAM_MEM_WIDTH == 16) begin\n            case (read_cnt)\n                0: dat_out_s <= bd_mem[s_rd_pnt];\n                1: dat_out_s <= {bd_mem[s_rd_pnt][15:0], 16'd0};\n                2: dat_out_s <= {bd_mem[s_rd_pnt][15:0], 16'd0};\n                3: dat_out_s <= {bd_mem[s_rd_pnt][15:0], 16'd0};\n            endcase\n        end\n        ack_o_s <= 1;\n    end else begin\n        ack_o_s <= 0;\n    end\nend\n\nassign free_bd = free_bd_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 9, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Module declaration for sd_bd\nmodule sd_bd(\n    // Input ports\n    input             clk,          // System clock\n    input             rst,          // Asynchronous reset, active high\n    input             we_m,         // Write enable signal\n    input  [RAM_MEM_WIDTH-1:0] dat_in_m,  // Input data for writing BD\n    input             re_s,         // Read enable signal\n    input             a_cmp,        // SD card operation completion\n\n    // Output ports\n    output [BD_WIDTH-1:0] free_bd,  // Number of free buffer descriptors\n    output            ack_o_s,      // Read operation acknowledgment\n    output [RAM_MEM_WIDTH-1:0] dat_out_s  // Output data from reading BD\n);\n\n// Internal signals and variables\nreg [BD_WIDTH-1:0] free_bd_reg;  // Register for free_bd output\nreg [RAM_MEM_WIDTH-1:0] dat_out_s_reg;  // Register for dat_out_s output\nreg ack_o_s_reg;  // Register for ack_o_s output\nreg [BD_WIDTH-1:0] m_wr_pnt;  // Write pointer\nreg [BD_WIDTH-1:0] s_rd_pnt;  // Read pointer\nreg new_bw;  // Flag for new buffer write\nreg last_a_cmp;  // Flag for last a_cmp signal\n\n// Initialize free_bd, m_wr_pnt, and s_rd_pnt on system reset\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        free_bd_reg <= (BD_SIZE / 2);  // Initialize free_bd to half of BD_SIZE\n        m_wr_pnt <= 0;  // Reset write pointer\n        s_rd_pnt <= 0;  // Reset read pointer\n    end else begin\n        // Update free_bd, m_wr_pnt, and s_rd_pnt based on write and read operations\n        if (we_m) begin\n            // Write operation\n            if (free_bd_reg > 0) begin\n                // Check if free buffer descriptors are available\n                if (RAM_MEM_WIDTH == 32) begin\n                    // 32-bit mode: Two writes complete one BD\n                    if (new_bw) begin\n                        free_bd_reg <= free_bd_reg - 1;  // Decrement free_bd\n                        m_wr_pnt <= m_wr_pnt + 1;  // Increment write pointer\n                        new_bw <= 0;  // Reset new_bw flag\n                    end else begin\n                        new_bw <= 1;  // Set new_bw flag\n                    end\n                end else if (RAM_MEM_WIDTH == 16) begin\n                    // 16-bit mode: Four writes complete one BD\n                    if (new_bw) begin\n                        free_bd_reg <= free_bd_reg - 1;  // Decrement free_bd\n                        m_wr_pnt <= m_wr_pnt + 1;  // Increment write pointer\n                        new_bw <= 0;  // Reset new_bw flag\n                    end else begin\n                        new_bw <= 1;  // Set new_bw flag\n                    end\n                end\n            end\n        end else if (re_s) begin\n            // Read operation\n            if (RAM_MEM_WIDTH == 32) begin\n                // 32-bit mode: Two reads obtain complete BD information\n                dat_out_s_reg <= dat_in_m;  // Output data from bd_mem[s_rd_pnt]\n                s_rd_pnt <= s_rd_pnt + 1;  // Increment read pointer\n            end else if (RAM_MEM_WIDTH == 16) begin\n                // 16-bit mode: Four reads obtain complete BD information\n                dat_out_s_reg <= dat_in_m;  // Output data from bd_mem[s_rd_pnt]\n                s_rd_pnt <= s_rd_pnt + 1;  // Increment read pointer\n                ack_o_s_reg <= 1;  // Set ack_o_s high\n            end\n        end else if (a_cmp) begin\n            // Release buffer descriptor on SD card operation completion\n            free_bd_reg <= free_bd_reg + 1;  // Increment free_bd\n            last_a_cmp <= 1;  // Set last_a_cmp flag\n        end\n    end\nend\n\n// Assign output ports\nassign free_bd = free_bd_reg;\nassign dat_out_s = dat_out_s_reg;\nassign ack_o_s = ack_o_s_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 10, "code": "// sd_bd module\nmodule sd_bd(\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output ack_o_s,\n    input a_cmp,\n    output [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Include sd_defines.v for global variables\n`include \"sd_defines.v\"\n\n// Internal signals and variables\nreg [BD_WIDTH-1:0] free_bd_reg;\nreg [RAM_MEM_WIDTH-1:0] dat_out_s_reg;\nreg ack_o_s_reg;\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [1:0] write_counter;\nreg [1:0] read_counter;\nreg new_bw;\nreg last_a_cmp;\n\n// Initialize free_bd counter based on RAM_MEM_WIDTH\ninitial begin\n    if (RAM_MEM_WIDTH == 32) begin\n        free_bd_reg = BD_SIZE / 2;\n    end else if (RAM_MEM_WIDTH == 16) begin\n        free_bd_reg = BD_SIZE / 4;\n    end\nend\n\n// Reset logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        free_bd_reg <= 0;\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        write_counter <= 0;\n        read_counter <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Writing Buffer Descriptor\n        if (we_m) begin\n            if (free_bd_reg > 0) begin\n                if (RAM_MEM_WIDTH == 32) begin\n                    if (write_counter == 1) begin\n                        free_bd_reg <= free_bd_reg - 1;\n                        new_bw <= 1;\n                        write_counter <= 0;\n                    end else begin\n                        write_counter <= write_counter + 1;\n                    end\n                end else if (RAM_MEM_WIDTH == 16) begin\n                    if (write_counter == 3) begin\n                        free_bd_reg <= free_bd_reg - 1;\n                        new_bw <= 1;\n                        write_counter <= 0;\n                    end else begin\n                        write_counter <= write_counter + 1;\n                    end\n                end\n                m_wr_pnt <= m_wr_pnt + 1;\n            end\n        end\n\n        // Reading Buffer Descriptor\n        if (re_s) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                if (read_counter == 1) begin\n                    read_counter <= 0;\n                end else begin\n                    read_counter <= read_counter + 1;\n                end\n            end else if (RAM_MEM_WIDTH == 16) begin\n                if (read_counter == 3) begin\n                    read_counter <= 0;\n                end else begin\n                    read_counter <= read_counter + 1;\n                end\n            end\n            s_rd_pnt <= s_rd_pnt + 1;\n            dat_out_s_reg <= dat_in_m;\n            ack_o_s_reg <= 1;\n        end\n\n        // Releasing Buffer Descriptor\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\n// Assign outputs\nassign free_bd = free_bd_reg;\nassign dat_out_s = dat_out_s_reg;\nassign ack_o_s = ack_o_s_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 11, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Module declaration\nmodule sd_bd(\n    // Input ports\n    input clk,            // System clock\n    input rst,            // Asynchronous reset, active high\n    input we_m,           // Write enable signal\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,  // Input data for writing BD\n    input re_s,           // Read enable signal\n    input a_cmp,          // SD card operation completion\n\n    // Output ports\n    output [BD_WIDTH-1:0] free_bd,      // Number of free buffer descriptors\n    output ack_o_s,       // Read operation acknowledgment\n    output [RAM_MEM_WIDTH-1:0] dat_out_s  // Output data from reading BD\n);\n\n// Internal signals and variables\nreg [BD_WIDTH-1:0] free_bd_reg;  // Register for free buffer descriptors\nreg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];  // Buffer descriptor memory\nreg [BD_WIDTH-1:0] m_wr_pnt;  // Write pointer\nreg [BD_WIDTH-1:0] s_rd_pnt;  // Read pointer\nreg new_bw;  // New buffer write flag\nreg last_a_cmp;  // Last value of a_cmp\n\n// Initialize free_bd_reg and pointers on reset\nalways @(posedge rst or posedge clk) begin\n    if (rst) begin\n        free_bd_reg <= (BD_SIZE / 2);  // Initialize free buffer descriptors\n        m_wr_pnt <= 0;  // Reset write pointer\n        s_rd_pnt <= 0;  // Reset read pointer\n        new_bw <= 0;  // Reset new buffer write flag\n        last_a_cmp <= 0;  // Reset last a_cmp value\n    end else begin\n        // Update free_bd_reg and pointers based on write and read operations\n        if (we_m) begin\n            // Write operation\n            if (free_bd_reg > 0) begin\n                // Check if there are available buffer descriptors\n                if (RAM_MEM_WIDTH == 32) begin\n                    // 32-bit mode: Two writes complete one BD\n                    if (new_bw == 0) begin\n                        // First write of a BD\n                        bd_mem[m_wr_pnt] <= dat_in_m;\n                        new_bw <= 1;\n                    end else begin\n                        // Second write of a BD\n                        bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][31:16], dat_in_m[15:0]};\n                        new_bw <= 0;\n                        free_bd_reg <= free_bd_reg - 1;  // Decrement free buffer descriptors\n                        m_wr_pnt <= m_wr_pnt + 1;  // Increment write pointer\n                    end\n                end else if (RAM_MEM_WIDTH == 16) begin\n                    // 16-bit mode: Four writes complete one BD\n                    if (new_bw == 0) begin\n                        // First write of a BD\n                        bd_mem[m_wr_pnt] <= {16'd0, dat_in_m};\n                        new_bw <= 1;\n                    end else if (new_bw == 1) begin\n                        // Second write of a BD\n                        bd_mem[m_wr_pnt] <= {dat_in_m, bd_mem[m_wr_pnt][15:0]};\n                        new_bw <= 2;\n                    end else if (new_bw == 2) begin\n                        // Third write of a BD\n                        bd_mem[m_wr_pnt] <= {dat_in_m, bd_mem[m_wr_pnt][31:16]};\n                        new_bw <= 3;\n                    end else begin\n                        // Fourth write of a BD\n                        bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][31:16], dat_in_m};\n                        new_bw <= 0;\n                        free_bd_reg <= free_bd_reg - 1;  // Decrement free buffer descriptors\n                        m_wr_pnt <= m_wr_pnt + 1;  // Increment write pointer\n                    end\n                end\n            end\n        end else if (re_s) begin\n            // Read operation\n            if (RAM_MEM_WIDTH == 32) begin\n                // 32-bit mode: Two reads obtain complete BD information\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;  // Increment read pointer\n                ack_o_s <= 1;  // Set read operation acknowledgment\n            end else if (RAM_MEM_WIDTH == 16) begin\n                // 16-bit mode: Four reads obtain complete BD information\n                dat_out_s <= bd_mem[s_rd_pnt][15:0];\n                s_rd_pnt <= s_rd_pnt + 1;  // Increment read pointer\n                ack_o_s <= 1;  // Set read operation acknowledgment\n            end\n        end else if (a_cmp && !last_a_cmp) begin\n            // Release buffer descriptor on SD card operation completion\n            free_bd_reg <= free_bd_reg + 1;  // Increment free buffer descriptors\n        end\n        last_a_cmp <= a_cmp;  // Update last a_cmp value\n    end\nend\n\n// Assign output signals\nassign free_bd = free_bd_reg;\nassign ack_o_s = ack_o_s;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd(\n    input               clk,\n    input               rst,\n    input               we_m,\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output  [BD_WIDTH-1:0] free_bd,\n    input               re_s,\n    output              ack_o_s,\n    input               a_cmp,\n    output [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nreg [BD_WIDTH-1:0] free_bd_reg;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [1:0] write_counter;\nreg [1:0] read_counter;\nreg new_bw;\nreg last_a_cmp;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        free_bd_reg <= BD_SIZE / 2;\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        write_counter <= 0;\n        read_counter <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Writing Buffer Descriptor\n        if (we_m) begin\n            if (free_bd_reg > 0) begin\n                if (RAM_MEM_WIDTH == 32) begin\n                    if (write_counter == 1) begin\n                        bd_mem[m_wr_pnt] <= {dat_in_m, bd_mem[m_wr_pnt][RAM_MEM_WIDTH-1:0]};\n                        m_wr_pnt <= m_wr_pnt + 1;\n                        write_counter <= 0;\n                        new_bw <= 1;\n                        free_bd_reg <= free_bd_reg - 1;\n                    end else begin\n                        bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][RAM_MEM_WIDTH-1:0], dat_in_m};\n                        write_counter <= write_counter + 1;\n                    end\n                end else if (RAM_MEM_WIDTH == 16) begin\n                    if (write_counter == 3) begin\n                        bd_mem[m_wr_pnt] <= {dat_in_m, bd_mem[m_wr_pnt][RAM_MEM_WIDTH-1:0]};\n                        m_wr_pnt <= m_wr_pnt + 1;\n                        write_counter <= 0;\n                        new_bw <= 1;\n                        free_bd_reg <= free_bd_reg - 1;\n                    end else begin\n                        bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][RAM_MEM_WIDTH-1:0], dat_in_m};\n                        write_counter <= write_counter + 1;\n                    end\n                end\n            end\n        end\n\n        // Reading Buffer Descriptor\n        if (re_s) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                if (read_counter == 1) begin\n                    dat_out_s <= {bd_mem[s_rd_pnt][RAM_MEM_WIDTH-1:0], dat_out_s};\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_counter <= 0;\n                    ack_o_s <= 1;\n                end else begin\n                    dat_out_s <= {dat_out_s, bd_mem[s_rd_pnt][RAM_MEM_WIDTH-1:0]};\n                    read_counter <= read_counter + 1;\n                end\n            end else if (RAM_MEM_WIDTH == 16) begin\n                if (read_counter == 3) begin\n                    dat_out_s <= {bd_mem[s_rd_pnt][RAM_MEM_WIDTH-1:0], dat_out_s};\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_counter <= 0;\n                    ack_o_s <= 1;\n                end else begin\n                    dat_out_s <= {dat_out_s, bd_mem[s_rd_pnt][RAM_MEM_WIDTH-1:0]};\n                    read_counter <= read_counter + 1;\n                    ack_o_s <= 1;\n                end\n            end\n        end\n\n        // Releasing Buffer Descriptor\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n        last_a_cmp <= a_cmp;\n\n        // Circular Operation\n        if (m_wr_pnt == BD_SIZE) begin\n            m_wr_pnt <= 0;\n        end\n        if (s_rd_pnt == BD_SIZE) begin\n            s_rd_pnt <= 0;\n        end\n    end\nend\n\nassign free_bd = free_bd_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd(\n    input           clk,\n    input           rst,\n    input           we_m,\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output  [BD_WIDTH-1:0] free_bd,\n    input           re_s,\n    output          ack_o_s,\n    input           a_cmp,\n    output [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Define constants and parameters\nlocalparam BD_SIZE = 2 ** BD_WIDTH;\n\n// Define internal signals and variables\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [BD_WIDTH-1:0] free_bd_reg;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\nreg new_bw;\nreg last_a_cmp;\n\n// Initialize free_bd counter based on RAM_MEM_WIDTH\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        if (RAM_MEM_WIDTH == 32) begin\n            free_bd_reg <= BD_SIZE / 2;\n        end else if (RAM_MEM_WIDTH == 16) begin\n            free_bd_reg <= BD_SIZE / 4;\n        end\n    end\nend\n\n// Update write pointer and free_bd counter on write operation\nalways @(posedge clk) begin\n    if (we_m) begin\n        if (RAM_MEM_WIDTH == 32) begin\n            // Two writes complete one BD in 32-bit mode\n            if (new_bw) begin\n                m_wr_pnt <= m_wr_pnt + 1;\n                free_bd_reg <= free_bd_reg - 1;\n                new_bw <= 0;\n            end else begin\n                new_bw <= 1;\n            end\n        end else if (RAM_MEM_WIDTH == 16) begin\n            // Four writes complete one BD in 16-bit mode\n            if (new_bw == 3) begin\n                m_wr_pnt <= m_wr_pnt + 1;\n                free_bd_reg <= free_bd_reg - 1;\n                new_bw <= 0;\n            end else begin\n                new_bw <= new_bw + 1;\n            end\n        end\n    end\nend\n\n// Update read pointer and output data on read operation\nalways @(posedge clk) begin\n    if (re_s) begin\n        if (RAM_MEM_WIDTH == 32) begin\n            // Two reads obtain complete BD information in 32-bit mode\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= s_rd_pnt + 1;\n        end else if (RAM_MEM_WIDTH == 16) begin\n            // Four reads obtain complete BD information in 16-bit mode\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= s_rd_pnt + 1;\n            ack_o_s <= 1;\n        end\n    end else begin\n        ack_o_s <= 0;\n    end\nend\n\n// Update free_bd counter on SD card operation completion\nalways @(posedge clk) begin\n    if (a_cmp && !last_a_cmp) begin\n        free_bd_reg <= free_bd_reg + 1;\n    end\n    last_a_cmp <= a_cmp;\nend\n\n// Assign output signals\nassign free_bd = free_bd_reg;\n\n// Initialize internal signals and variables\ninitial begin\n    m_wr_pnt = 0;\n    s_rd_pnt = 0;\n    free_bd_reg = 0;\n    new_bw = 0;\n    last_a_cmp = 0;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 14, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Module declaration\nmodule sd_bd (\n    // Input ports\n    input               clk,            // System clock\n    input               rst,            // Asynchronous reset, active high\n    input               we_m,           // Write enable signal\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m, // Input data for writing BD\n    input               re_s,           // Read enable signal\n    input               a_cmp,          // SD card operation completion\n\n    // Output ports\n    output  [BD_WIDTH-1:0] free_bd,      // Number of free buffer descriptors\n    output              ack_o_s,        // Read operation acknowledgment\n    output [RAM_MEM_WIDTH-1:0] dat_out_s  // Output data from reading BD\n);\n\n// Internal signals and variables\nreg [BD_WIDTH-1:0] free_bd_reg;  // Register for free buffer descriptors\nreg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];  // Buffer descriptor memory\nreg [BD_WIDTH-1:0] m_wr_pnt;  // Write pointer\nreg [BD_WIDTH-1:0] s_rd_pnt;  // Read pointer\nreg [1:0] write_cnt;  // Write counter\nreg [1:0] read_cnt;   // Read counter\nreg new_bw;           // New buffer write flag\nreg last_a_cmp;       // Last value of a_cmp\n\n// Initialize free_bd counter based on RAM_MEM_WIDTH\ninitial begin\n    if (RAM_MEM_WIDTH == 32) begin\n        free_bd_reg = BD_SIZE / 2;\n    end else if (RAM_MEM_WIDTH == 16) begin\n        free_bd_reg = BD_SIZE / 4;\n    end\nend\n\n// Reset logic\nalways @(posedge rst or posedge clk) begin\n    if (rst) begin\n        free_bd_reg <= 0;\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        write_cnt <= 0;\n        read_cnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Update free_bd counter\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n\n        // Update last_a_cmp\n        last_a_cmp <= a_cmp;\n\n        // Write buffer descriptor\n        if (we_m) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                // 32-bit mode: Two writes complete one BD\n                if (write_cnt == 0) begin\n                    bd_mem[m_wr_pnt] <= {dat_in_m, 16'd0};\n                end else if (write_cnt == 1) begin\n                    bd_mem[m_wr_pnt] <= {16'd0, dat_in_m};\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    write_cnt <= 0;\n                    new_bw <= 1;\n                    free_bd_reg <= free_bd_reg - 1;\n                end\n                write_cnt <= write_cnt + 1;\n            end else if (RAM_MEM_WIDTH == 16) begin\n                // 16-bit mode: Four writes complete one BD\n                if (write_cnt == 0) begin\n                    bd_mem[m_wr_pnt] <= {dat_in_m, 16'd0};\n                end else if (write_cnt == 1) begin\n                    bd_mem[m_wr_pnt] <= {dat_in_m, bd_mem[m_wr_pnt][15:0]};\n                end else if (write_cnt == 2) begin\n                    bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][31:16], dat_in_m};\n                end else if (write_cnt == 3) begin\n                    bd_mem[m_wr_pnt] <= {dat_in_m, bd_mem[m_wr_pnt][15:0]};\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    write_cnt <= 0;\n                    new_bw <= 1;\n                    free_bd_reg <= free_bd_reg - 1;\n                end\n                write_cnt <= write_cnt + 1;\n            end\n        end\n\n        // Read buffer descriptor\n        if (re_s) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                // 32-bit mode: Two reads obtain complete BD information\n                if (read_cnt == 0) begin\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                end else if (read_cnt == 1) begin\n                    dat_out_s <= {bd_mem[s_rd_pnt][31:16], 16'd0};\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_cnt <= 0;\n                    ack_o_s <= 1;\n                end\n                read_cnt <= read_cnt + 1;\n            end else if (RAM_MEM_WIDTH == 16) begin\n                // 16-bit mode: Four reads obtain complete BD information\n                if (read_cnt == 0) begin\n                    dat_out_s <= bd_mem[s_rd_pnt][15:0];\n                end else if (read_cnt == 1) begin\n                    dat_out_s <= bd_mem[s_rd_pnt][31:16];\n                end else if (read_cnt == 2) begin\n                    dat_out_s <= bd_mem[s_rd_pnt][15:0];\n                end else if (read_cnt == 3) begin\n                    dat_out_s <= bd_mem[s_rd_pnt][31:16];\n                    s_rd_pnt <= s_rd_pnt + 1;\n                    read_cnt <= 0;\n                    ack_o_s <= 1;\n                end\n                read_cnt <= read_cnt + 1;\n            end\n        end\n    end\nend\n\n// Output assignments\nassign free_bd = free_bd_reg;\nassign ack_o_s = (re_s && read_cnt == 3) ? 1 : 0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 15, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\nmodule sd_bd(\n    // Input ports\n    input               clk,        // System clock\n    input               rst,        // Asynchronous reset, active high\n    input               we_m,       // Write enable signal\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m, // Input data for writing BD\n    input               re_s,       // Read enable signal\n    input               a_cmp,      // SD card operation completion\n\n    // Output ports\n    output  [BD_WIDTH-1:0] free_bd,  // Number of free buffer descriptors\n    output              ack_o_s,    // Read operation acknowledgment\n    output  [RAM_MEM_WIDTH-1:0] dat_out_s // Output data from reading BD\n);\n\n// Internal signals and variables\nreg    [BD_WIDTH-1:0] free_bd_reg;\nreg    [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\nreg    [BD_WIDTH-1:0] m_wr_pnt;\nreg    [BD_WIDTH-1:0] s_rd_pnt;\nreg               new_bw;\nreg               last_a_cmp;\n\n// Initialize the module on system reset\nalways @(posedge rst or posedge clk) begin\n    if (rst) begin\n        // Reset the free_bd counter, write and read pointers\n        free_bd_reg <= (BIG_ENDIAN) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Update the free_bd counter, write and read pointers\n        if (we_m) begin\n            // Write operation\n            if (free_bd_reg > 0) begin\n                // Check if there are available buffer descriptors\n                if (BIG_ENDIAN) begin\n                    // 32-bit mode: Two writes complete one BD\n                    if (new_bw == 0) begin\n                        // First write\n                        bd_mem[m_wr_pnt] <= dat_in_m;\n                        new_bw <= 1;\n                    end else begin\n                        // Second write\n                        bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][RAM_MEM_WIDTH-1:0], dat_in_m};\n                        new_bw <= 0;\n                        m_wr_pnt <= m_wr_pnt + 1;\n                        free_bd_reg <= free_bd_reg - 1;\n                    end\n                end else begin\n                    // 16-bit mode: Four writes complete one BD\n                    if (new_bw == 0) begin\n                        // First write\n                        bd_mem[m_wr_pnt] <= dat_in_m;\n                        new_bw <= 1;\n                    end else if (new_bw == 1) begin\n                        // Second write\n                        bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][RAM_MEM_WIDTH-1:0], dat_in_m};\n                        new_bw <= 2;\n                    end else if (new_bw == 2) begin\n                        // Third write\n                        bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][RAM_MEM_WIDTH-1:0], dat_in_m};\n                        new_bw <= 3;\n                    end else begin\n                        // Fourth write\n                        bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][RAM_MEM_WIDTH-1:0], dat_in_m};\n                        new_bw <= 0;\n                        m_wr_pnt <= m_wr_pnt + 1;\n                        free_bd_reg <= free_bd_reg - 1;\n                    end\n                end\n            end\n        end else if (re_s) begin\n            // Read operation\n            if (BIG_ENDIAN) begin\n                // 32-bit mode: Two reads obtain complete BD information\n                if (ack_o_s == 0) begin\n                    // First read\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    ack_o_s <= 1;\n                end else begin\n                    // Second read\n                    dat_out_s <= {dat_out_s[RAM_MEM_WIDTH-1:0], bd_mem[s_rd_pnt]};\n                    ack_o_s <= 0;\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end\n            end else begin\n                // 16-bit mode: Four reads obtain complete BD information\n                if (ack_o_s == 0) begin\n                    // First read\n                    dat_out_s <= bd_mem[s_rd_pnt];\n                    ack_o_s <= 1;\n                end else if (ack_o_s == 1) begin\n                    // Second read\n                    dat_out_s <= {dat_out_s[RAM_MEM_WIDTH-1:0], bd_mem[s_rd_pnt]};\n                    ack_o_s <= 1;\n                end else if (ack_o_s == 2) begin\n                    // Third read\n                    dat_out_s <= {dat_out_s[RAM_MEM_WIDTH-1:0], bd_mem[s_rd_pnt]};\n                    ack_o_s <= 1;\n                end else begin\n                    // Fourth read\n                    dat_out_s <= {dat_out_s[RAM_MEM_WIDTH-1:0], bd_mem[s_rd_pnt]};\n                    ack_o_s <= 0;\n                    s_rd_pnt <= s_rd_pnt + 1;\n                end\n            end\n        end else if (a_cmp && !last_a_cmp) begin\n            // Release buffer descriptor\n            free_bd_reg <= free_bd_reg + 1;\n            last_a_cmp <= 1;\n        end else if (!a_cmp && last_a_cmp) begin\n            last_a_cmp <= 0;\n        end\n    end\nend\n\n// Assign output signals\nassign free_bd = free_bd_reg;\nassign ack_o_s = ack_o_s;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 16, "code": "// Include the sd_defines.v file for global variables and macros\n`include \"sd_defines.v\"\n\nmodule sd_bd(\n    // Input ports\n    input               clk,          // System clock\n    input               rst,          // Asynchronous reset, active high\n    input               we_m,         // Write enable signal\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m,  // Input data for writing BD\n    input               re_s,         // Read enable signal\n    input               a_cmp,        // SD card operation completion\n\n    // Output ports\n    output  [BD_WIDTH-1:0] free_bd,    // Number of free buffer descriptors\n    output              ack_o_s,      // Read operation acknowledgment\n    output  [RAM_MEM_WIDTH-1:0] dat_out_s  // Output data from reading BD\n);\n\n// Internal signals and variables\nreg    [BD_WIDTH-1:0] free_bd_reg;    // Register for free buffer descriptors\nreg    [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];  // Buffer descriptor memory\nreg    [BD_WIDTH-1:0] m_wr_pnt;       // Write pointer\nreg    [BD_WIDTH-1:0] s_rd_pnt;       // Read pointer\nreg               new_bw;            // New buffer write flag\nreg               last_a_cmp;        // Last value of a_cmp\n\n// Initialize the module on reset\nalways @(posedge rst or posedge clk) begin\n    if (rst) begin\n        // Reset the free buffer descriptors counter\n        free_bd_reg <= BD_SIZE / 2;\n        // Reset the write and read pointers\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        // Reset the new buffer write flag\n        new_bw <= 0;\n        // Reset the last value of a_cmp\n        last_a_cmp <= 0;\n    end else begin\n        // Update the free buffer descriptors counter\n        if (we_m && (free_bd_reg > 0)) begin\n            free_bd_reg <= free_bd_reg - 1;\n        end else if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n\n        // Update the write pointer\n        if (we_m) begin\n            m_wr_pnt <= m_wr_pnt + 1;\n            if (m_wr_pnt == BD_SIZE - 1) begin\n                m_wr_pnt <= 0;\n            end\n        end\n\n        // Update the read pointer\n        if (re_s) begin\n            s_rd_pnt <= s_rd_pnt + 1;\n            if (s_rd_pnt == BD_SIZE - 1) begin\n                s_rd_pnt <= 0;\n            end\n        end\n\n        // Update the new buffer write flag\n        if (we_m && (free_bd_reg > 0)) begin\n            new_bw <= 1;\n        end else begin\n            new_bw <= 0;\n        end\n\n        // Update the last value of a_cmp\n        last_a_cmp <= a_cmp;\n    end\nend\n\n// Write buffer descriptor\nalways @(posedge clk) begin\n    if (we_m && (free_bd_reg > 0)) begin\n        // Write data to the buffer descriptor memory\n        bd_mem[m_wr_pnt] <= dat_in_m;\n    end\nend\n\n// Read buffer descriptor\nalways @(posedge clk) begin\n    if (re_s) begin\n        // Read data from the buffer descriptor memory\n        dat_out_s <= bd_mem[s_rd_pnt];\n        // Set the acknowledgment signal\n        ack_o_s <= 1;\n    end else begin\n        ack_o_s <= 0;\n    end\nend\n\n// Assign the output ports\nassign free_bd = free_bd_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 17, "code": "```include \"sd_defines.v\"\n\nmodule sd_bd (\n    input               clk,\n    input               rst,\n    input               we_m,\n    input  [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output [BD_WIDTH-1:0] free_bd,\n    input               re_s,\n    output              ack_o_s,\n    input               a_cmp,\n    output [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\nreg [BD_WIDTH-1:0] free_bd_reg;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [1:0] new_bw;\nreg [1:0] last_a_cmp;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        free_bd_reg <= (RAM_MEM_WIDTH == 32) ? BD_SIZE/2 : BD_SIZE/4;\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Write buffer descriptor\n        if (we_m) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                // 32-bit mode: Two writes complete one BD\n                if (new_bw == 0) begin\n                    bd_mem[m_wr_pnt] <= dat_in_m;\n                    new_bw <= 1;\n                end else begin\n                    bd_mem[m_wr_pnt] <= {bd_mem[m_wr_pnt][RAM_MEM_WIDTH-1:0], dat_in_m[RAM_MEM_WIDTH-1:0]};\n                    new_bw <= 0;\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    if (free_bd_reg > 0) begin\n                        free_bd_reg <= free_bd_reg - 1;\n                    end\n                end\n            end else begin\n                // 16-bit mode: Four writes complete one BD\n                if (new_bw == 0) begin\n                    bd_mem[m_wr_pnt] <= {16'd0, dat_in_m[15:0]};\n                    new_bw <= 1;\n                end else if (new_bw == 1) begin\n                    bd_mem[m_wr_pnt] <= {dat_in_m[15:0], bd_mem[m_wr_pnt][15:0]};\n                    new_bw <= 2;\n                end else if (new_bw == 2) begin\n                    bd_mem[m_wr_pnt] <= {16'd0, dat_in_m[15:0]};\n                    new_bw <= 3;\n                end else begin\n                    bd_mem[m_wr_pnt] <= {dat_in_m[15:0], bd_mem[m_wr_pnt][15:0]};\n                    new_bw <= 0;\n                    m_wr_pnt <= m_wr_pnt + 1;\n                    if (free_bd_reg > 0) begin\n                        free_bd_reg <= free_bd_reg - 1;\n                    end\n                end\n            end\n        end\n\n        // Read buffer descriptor\n        if (re_s) begin\n            if (RAM_MEM_WIDTH == 32) begin\n                // 32-bit mode: Two reads obtain complete BD information\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n            end else begin\n                // 16-bit mode: Four reads obtain complete BD information\n                dat_out_s <= bd_mem[s_rd_pnt][15:0];\n                s_rd_pnt <= s_rd_pnt + 1;\n                ack_o_s <= 1'b1;\n            end\n        end else begin\n            ack_o_s <= 1'b0;\n        end\n\n        // Release buffer descriptor\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nassign free_bd = free_bd_reg;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 18, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Module declaration\nmodule sd_bd(\n    // Input ports\n    input               clk,          // System clock\n    input               rst,          // Asynchronous reset, active high\n    input               we_m,         // Write enable signal\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m,  // Input data for writing BD\n    input               re_s,         // Read enable signal\n    input               a_cmp,        // SD card operation completion\n\n    // Output ports\n    output  [BD_WIDTH-1:0] free_bd,    // Number of free buffer descriptors\n    output              ack_o_s,      // Read operation acknowledgment\n    output  [RAM_MEM_WIDTH-1:0] dat_out_s  // Output data from reading BD\n);\n\n// Internal signals and variables\nreg    [BD_WIDTH-1:0] free_bd_reg;    // Register for free buffer descriptors\nreg    [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];  // Buffer descriptor memory\nreg    [BD_WIDTH-1:0] m_wr_pnt;       // Write pointer\nreg    [BD_WIDTH-1:0] s_rd_pnt;       // Read pointer\nreg               new_bw;            // New buffer write flag\nreg               last_a_cmp;        // Last value of a_cmp\n\n// Initialize free_bd counter based on RAM_MEM_WIDTH\ninitial begin\n    if (RAM_MEM_WIDTH == 32) begin\n        free_bd_reg = BD_SIZE / 2;\n    end else if (RAM_MEM_WIDTH == 16) begin\n        free_bd_reg = BD_SIZE / 4;\n    end\nend\n\n// Write operation\nalways @(posedge clk) begin\n    if (we_m) begin\n        // Check if free_bd is greater than 0\n        if (free_bd_reg > 0) begin\n            // Write data to bd_mem\n            if (RAM_MEM_WIDTH == 32) begin\n                // Two writes complete one BD in 32-bit mode\n                bd_mem[m_wr_pnt] = dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                if (m_wr_pnt == BD_SIZE - 1) begin\n                    m_wr_pnt <= 0;\n                end\n                new_bw <= 1;\n                free_bd_reg <= free_bd_reg - 1;\n            end else if (RAM_MEM_WIDTH == 16) begin\n                // Four writes complete one BD in 16-bit mode\n                bd_mem[m_wr_pnt] = {bd_mem[m_wr_pnt][15:0], dat_in_m[15:0]};\n                m_wr_pnt <= m_wr_pnt + 1;\n                if (m_wr_pnt == BD_SIZE - 1) begin\n                    m_wr_pnt <= 0;\n                end\n                new_bw <= 1;\n                free_bd_reg <= free_bd_reg - 1;\n            end\n        end\n    end\nend\n\n// Read operation\nalways @(posedge clk) begin\n    if (re_s) begin\n        // Check if free_bd is greater than 0\n        if (free_bd_reg > 0) begin\n            // Read data from bd_mem\n            if (RAM_MEM_WIDTH == 32) begin\n                // Two reads obtain complete BD information in 32-bit mode\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                if (s_rd_pnt == BD_SIZE - 1) begin\n                    s_rd_pnt <= 0;\n                end\n                ack_o_s <= 1;\n            end else if (RAM_MEM_WIDTH == 16) begin\n                // Four reads obtain complete BD information in 16-bit mode\n                dat_out_s <= bd_mem[s_rd_pnt][15:0];\n                s_rd_pnt <= s_rd_pnt + 1;\n                if (s_rd_pnt == BD_SIZE - 1) begin\n                    s_rd_pnt <= 0;\n                end\n                ack_o_s <= 1;\n            end\n        end\n    end\nend\n\n// Release buffer descriptor\nalways @(posedge clk) begin\n    if (a_cmp && !last_a_cmp) begin\n        free_bd_reg <= free_bd_reg + 1;\n    end\n    last_a_cmp <= a_cmp;\nend\n\n// Assign output signals\nassign free_bd = free_bd_reg;\nassign ack_o_s = ack_o_s;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 19, "code": "// sd_bd.v\n\n`include \"sd_defines.v\"\n\nmodule sd_bd(\n    input               clk,\n    input               rst,\n    input               we_m,\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output  [BD_WIDTH-1:0] free_bd,\n    input               re_s,\n    output              ack_o_s,\n    input               a_cmp,\n    output [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal signals and variables\nreg [BD_WIDTH-1:0] free_bd_reg;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0];\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [1:0] new_bw;\nreg [1:0] last_a_cmp;\n\n// Initialize free_bd counter and pointers\ninitial begin\n    free_bd_reg = (RAM_MEM_WIDTH == 32) ? BD_SIZE/2 : BD_SIZE/4;\n    m_wr_pnt = 0;\n    s_rd_pnt = 0;\nend\n\n// Update free_bd counter and pointers\nalways @(posedge clk) begin\n    if (rst) begin\n        free_bd_reg <= (RAM_MEM_WIDTH == 32) ? BD_SIZE/2 : BD_SIZE/4;\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n    end else begin\n        // Update free_bd counter\n        if (a_cmp && !last_a_cmp) begin\n            free_bd_reg <= free_bd_reg + 1;\n        end\n\n        // Update write pointer\n        if (we_m) begin\n            if (new_bw == 2'd3) begin\n                m_wr_pnt <= m_wr_pnt + 1;\n                new_bw <= 2'd0;\n            end else begin\n                new_bw <= new_bw + 1;\n            end\n        end\n\n        // Update read pointer\n        if (re_s) begin\n            if (new_bw == 2'd3) begin\n                s_rd_pnt <= s_rd_pnt + 1;\n                new_bw <= 2'd0;\n            end else begin\n                new_bw <= new_bw + 1;\n            end\n        end\n    end\nend\n\n// Write buffer descriptor\nalways @(posedge clk) begin\n    if (we_m) begin\n        if (free_bd_reg > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            free_bd_reg <= free_bd_reg - 1;\n        end\n    end\nend\n\n// Read buffer descriptor\nalways @(posedge clk) begin\n    if (re_s) begin\n        dat_out_s <= bd_mem[s_rd_pnt];\n        ack_o_s <= 1'b1;\n    end else begin\n        ack_o_s <= 1'b0;\n    end\nend\n\n// Release buffer descriptor\nalways @(posedge clk) begin\n    last_a_cmp <= a_cmp;\nend\n\n// Circular operation\nalways @(posedge clk) begin\n    if (m_wr_pnt == BD_SIZE-1) begin\n        m_wr_pnt <= 0;\n    end\n    if (s_rd_pnt == BD_SIZE-1) begin\n        s_rd_pnt <= 0;\n    end\nend\n\n// Assign output signals\nassign free_bd = free_bd_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 20, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Module declaration\nmodule sd_bd(\n    // Input ports\n    input               clk,            // System clock\n    input               rst,            // Asynchronous reset, active high\n    input               we_m,           // Write enable signal\n    input   [RAM_MEM_WIDTH-1:0] dat_in_m, // Input data for writing BD\n    input               re_s,           // Read enable signal\n    input               a_cmp,          // SD card operation completion\n\n    // Output ports\n    output  [BD_WIDTH-1:0] free_bd,      // Number of free buffer descriptors\n    output              ack_o_s,        // Read operation acknowledgment\n    output  [RAM_MEM_WIDTH-1:0] dat_out_s // Output data from reading BD\n);\n\n// Internal signals and variables\nreg     [BD_WIDTH-1:0] free_bd_reg;     // Register for free buffer descriptors\nreg     [RAM_MEM_WIDTH-1:0] bd_mem [BD_SIZE-1:0]; // Buffer descriptor memory\nreg     [BD_WIDTH-1:0] m_wr_pnt;        // Write pointer\nreg     [BD_WIDTH-1:0] s_rd_pnt;        // Read pointer\nreg               new_bw;              // New buffer write flag\nreg               last_a_cmp;          // Last a_cmp signal value\n\n// Initialize free_bd counter based on RAM_MEM_WIDTH\ninitial begin\n    if (RAM_MEM_WIDTH == 32) begin\n        free_bd_reg = BD_SIZE / 2;\n    end else if (RAM_MEM_WIDTH == 16) begin\n        free_bd_reg = BD_SIZE / 4;\n    end\nend\n\n// Reset logic\nalways @(posedge rst or posedge clk) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        new_bw <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Update last_a_cmp signal\n        last_a_cmp <= a_cmp;\n    end\nend\n\n// Write buffer descriptor logic\nalways @(posedge clk) begin\n    if (we_m) begin\n        // Check if free_bd is greater than 0\n        if (free_bd_reg > 0) begin\n            // Write data to bd_mem\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            // Increment write pointer\n            m_wr_pnt <= m_wr_pnt + 1;\n            // Decrement free_bd counter\n            free_bd_reg <= free_bd_reg - 1;\n            // Set new buffer write flag\n            new_bw <= 1;\n        end\n    end else begin\n        new_bw <= 0;\n    end\nend\n\n// Read buffer descriptor logic\nalways @(posedge clk) begin\n    if (re_s) begin\n        // Output data from bd_mem\n        dat_out_s <= bd_mem[s_rd_pnt];\n        // Increment read pointer\n        s_rd_pnt <= s_rd_pnt + 1;\n        // Set read operation acknowledgment\n        ack_o_s <= 1;\n    end else begin\n        ack_o_s <= 0;\n    end\nend\n\n// Release buffer descriptor logic\nalways @(posedge clk) begin\n    if (a_cmp && !last_a_cmp) begin\n        // Increment free_bd counter\n        free_bd_reg <= free_bd_reg + 1;\n    end\nend\n\n// Assign output ports\nassign free_bd = free_bd_reg;\nassign dat_out_s = bd_mem[s_rd_pnt];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 1, "code": "module sd_clock_divider(\n    input  CLK,\n    input  [7:0] DIVIDER,\n    input  RST,\n    output SD_CLK\n);\n\nreg [7:0] counter;\nreg sd_clk_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if(RST) begin\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if(counter == DIVIDER) begin\n            counter <= 8'd0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 8'd1;\n        end\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input           CLK,\n    input   [7:0]   DIVIDER,\n    input           RST,\n    output          SD_CLK\n);\n\nreg [7:0] counter;\nreg       sd_clk_reg;\n\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter == DIVIDER) begin\n            counter <= 8'd0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 3, "code": "// sd_clock_divider module\nmodule sd_clock_divider(\n    input           CLK,     // input clock signal\n    input   [7:0]   DIVIDER, // division ratio\n    input           RST,     // asynchronous reset signal\n    output          SD_CLK   // output clock signal\n);\n\nreg [7:0] counter; // counter to divide the clock\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // reset the counter and output clock when reset is high\n        counter <= 8'd0;\n        SD_CLK <= 1'b0;\n    end else begin\n        // increment the counter on every clock cycle\n        counter <= counter + 8'd1;\n        \n        // generate the output clock when the counter reaches the division ratio\n        if (counter == DIVIDER) begin\n            SD_CLK <= ~SD_CLK; // toggle the output clock\n            counter <= 8'd0;   // reset the counter\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 4, "code": "module sd_clock_divider(\n    input           CLK,\n    input   [7:0]   DIVIDER,\n    input           RST,\n    output          SD_CLK\n);\n\nreg [7:0] counter;\nreg       sd_clk_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if(RST) begin\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if(counter == DIVIDER) begin\n            counter <= 8'd0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 8'd1;\n        end\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 5, "code": "// sd_clock_divider module\nmodule sd_clock_divider(\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output SD_CLK\n);\n\nreg [7:0] counter;\nreg sd_clk_reg;\n\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else if (counter == DIVIDER) begin\n        counter <= 8'd0;\n        sd_clk_reg <= ~sd_clk_reg;\n    end else begin\n        counter <= counter + 8'd1;\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 6, "code": "// sd_clock_divider module\nmodule sd_clock_divider(\n    input  CLK,        // input clock signal\n    input  [7:0] DIVIDER,  // division ratio\n    input  RST,        // asynchronous reset signal\n    output SD_CLK      // output clock signal\n);\n\nreg [7:0] counter;  // counter to keep track of the division ratio\nreg sd_clk_reg;     // register to store the output clock signal\n\n// asynchronous reset\nalways @(posedge RST or posedge CLK) begin\n    if (RST) begin\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else if (counter == DIVIDER) begin\n        counter <= 8'd0;\n        sd_clk_reg <= ~sd_clk_reg;\n    end else begin\n        counter <= counter + 8'd1;\n    end\nend\n\n// assign output clock signal\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 7, "code": "module sd_clock_divider(\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output SD_CLK\n);\n\nreg [7:0] counter = 8'd0;\nreg sd_clk_reg = 1'b0;\n\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter == DIVIDER) begin\n            counter <= 8'd0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 8'd1;\n        end\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input         CLK,\n    input  [7:0]  DIVIDER,\n    input         RST,\n    output        SD_CLK\n);\n\nreg [7:0] counter;\nreg         sd_clk_reg;\n\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter == DIVIDER) begin\n            counter <= 8'd0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 8'd1;\n        end\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 9, "code": "// sd_clock_divider module\nmodule sd_clock_divider(\n    input CLK,      // input clock signal\n    input [7:0] DIVIDER,  // division ratio\n    input RST,      // asynchronous reset signal\n    output SD_CLK   // output clock signal\n);\n\nreg [7:0] counter;  // counter to keep track of the division ratio\nreg sd_clk_reg;     // register to store the output clock signal\n\n// asynchronous reset\nalways @(posedge RST or posedge CLK) begin\n    if (RST) begin\n        counter <= 8'd0;  // reset counter to 0\n        sd_clk_reg <= 1'b0;  // reset output clock signal to 0\n    end else if (counter == DIVIDER) begin\n        counter <= 8'd0;  // reset counter to 0 when it reaches the division ratio\n        sd_clk_reg <= ~sd_clk_reg;  // toggle the output clock signal\n    end else begin\n        counter <= counter + 8'd1;  // increment the counter\n    end\nend\n\n// assign output clock signal\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output SD_CLK\n);\n\nreg [7:0] counter;\nreg sd_clk_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter == DIVIDER) begin\n            counter <= 8'd0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 8'd1;\n        end\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 11, "code": "module sd_clock_divider(\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output SD_CLK\n);\n\nreg [7:0] counter = 0;\nreg sd_clk_reg = 0;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        sd_clk_reg <= 0;\n        counter <= 0;\n    end else begin\n        if (counter == DIVIDER) begin\n            sd_clk_reg <= ~sd_clk_reg;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 12, "code": "```ilog\nmodule sd_clock_divider(\n    input           CLK,\n    input   [7:0]   DIVIDER,\n    input           RST,\n    output          SD_CLK\n);\n\nreg [7:0] counter;\nreg       sd_clk_reg;\n\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter == DIVIDER) begin\n            counter <= 8'd0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 8'd1;\n        end\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 13, "code": "// sd_clock_divider module\nmodule sd_clock_divider(\n    input  wire        CLK,     // input clock signal\n    input  wire [7:0]  DIVIDER, // division ratio\n    input  wire        RST,     // asynchronous reset signal\n    output wire        SD_CLK   // output clock signal\n);\n\nreg [7:0] counter; // counter to keep track of the division ratio\n\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin // reset the counter and output clock signal\n        counter <= 8'd0;\n        SD_CLK <= 1'b0;\n    end else begin\n        if (counter == DIVIDER) begin // if the counter reaches the division ratio\n            counter <= 8'd0; // reset the counter\n            SD_CLK <= ~SD_CLK; // toggle the output clock signal\n        end else begin\n            counter <= counter + 8'd1; // increment the counter\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input  CLK,\n    input  [7:0] DIVIDER,\n    input  RST,\n    output SD_CLK\n);\n\nreg [7:0] counter;\nreg       sd_clk_reg;\n\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter == DIVIDER) begin\n            counter <= 8'd0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 8'd1;\n        end\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 15, "code": "// Include the sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input CLK,        // Input clock signal\n    input [7:0] DIVIDER,  // Division ratio\n    input RST,        // Asynchronous reset signal\n    output SD_CLK     // Output clock signal\n);\n\nreg [7:0] counter;  // Counter to divide the clock\nreg sd_clk_reg;     // Register to store the output clock signal\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Reset the counter and output clock signal on asynchronous reset\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        // Increment the counter on every positive edge of the input clock\n        if (counter == DIVIDER) begin\n            // If the counter reaches the division ratio, reset it and toggle the output clock\n            counter <= 8'd0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            // Otherwise, increment the counter\n            counter <= counter + 8'd1;\n        end\n    end\nend\n\n// Assign the output clock signal\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input             CLK,\n    input      [7:0]  DIVIDER,\n    input             RST,\n    output            SD_CLK\n);\n\nreg [7:0] counter = 8'd0;\nreg       sd_clk_reg = 1'b0;\n\nalways @(posedge CLK or posedge RST) begin\n    if(RST) begin\n        sd_clk_reg <= 1'b0;\n        counter <= 8'd0;\n    end else begin\n        if(counter == DIVIDER) begin\n            sd_clk_reg <= ~sd_clk_reg;\n            counter <= 8'd0;\n        end else begin\n            counter <= counter + 8'd1;\n        end\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input           CLK,\n    input   [7:0]   DIVIDER,\n    input           RST,\n    output          SD_CLK\n);\n\nreg [7:0] counter;\nreg       sd_clk_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if(RST) begin\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if(counter == DIVIDER) begin\n            counter <= 8'd0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 18, "code": "module sd_clock_divider(\n    input           CLK,\n    input   [7:0]   DIVIDER,\n    input           RST,\n    output          SD_CLK\n);\n\nreg [7:0] counter;\nreg       sd_clk_reg;\n\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter == DIVIDER) begin\n            counter <= 8'd0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 8'd1;\n        end\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 19, "code": "```ilog\nmodule sd_clock_divider(\n    input         CLK,\n    input  [7:0]  DIVIDER,\n    input         RST,\n    output        SD_CLK\n);\n\nreg [7:0] counter;\nreg         sd_clk_reg;\n\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'd0;\n        sd_clk_reg <= 1'b0;\n    end else begin\n        if (counter == DIVIDER) begin\n            counter <= 8'd0;\n            sd_clk_reg <= ~sd_clk_reg;\n        end else begin\n            counter <= counter + 8'd1;\n        end\n    end\nend\n\nassign SD_CLK = sd_clk_reg;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    input             CLK_PAD_IO,\n    input             RST_PAD_I,\n    input             New_CMD,\n    input             data_write,\n    input             data_read,\n    input      [31:0] ARG_REG,\n    input      [13:0] CMD_SET_REG,\n    input      [15:0] TIMEOUT_REG,\n    output     [15:0] STATUS_REG,\n    output     [31:0] RESP_1_REG,\n    output     [ 4:0] ERR_INT_REG,\n    output     [15:0] NORMAL_INT_REG,\n    input             ERR_INT_RST,\n    input             NORMAL_INT_RST,\n    output     [15:0] settings,\n    output             go_idle_o,\n    output     [39:0] cmd_out,\n    output             req_out,\n    output             ack_out,\n    input             req_in,\n    input             ack_in,\n    input      [39:0] cmd_in,\n    input       [7:0] serial_status,\n    input             card_detect\n);\n\n// Internal signals and registers\nreg [2:0] state; // Current state of the FSM\nreg [2:0] next_state; // Next state of the FSM\nreg [3:0] debounce; // Debounce counter for card detection\nreg card_present; // Flag indicating card presence\nreg req_in_int; // Synchronized req_in signal\nreg ack_in_int; // Synchronized ack_in signal\nreg [39:0] cmd_out_int; // Internal command output\nreg [15:0] settings_int; // Internal settings output\nreg req_out_int; // Internal request output\nreg ack_out_int; // Internal acknowledge output\nreg complete; // Flag indicating command completion\nreg index_check_enable; // Flag enabling index check\nreg CRC_check_enable; // Flag enabling CRC check\nreg [7:0] response_size; // Response size\nreg [31:0] RESP_1_REG_int; // Internal response register\nreg [4:0] ERR_INT_REG_int; // Internal error interrupt register\nreg [15:0] NORMAL_INT_REG_int; // Internal normal interrupt register\nreg Watchdog_Cnt; // Watchdog counter\nreg CTE; // Command timeout error flag\nreg CIE; // Command index error flag\nreg CCRCE; // CRC error flag\nreg EI; // Error interrupt flag\nreg CC; // Command complete flag\nreg go_idle_o_int; // Internal go idle signal\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else if (!card_detect) begin\n        if (debounce < 4'b1111) begin\n            debounce <= debounce + 1;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end\n    end else begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end\nend\n\n// Synchronization logic for req_in and ack_in\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_in_int <= 1'b0;\n        ack_in_int <= 1'b0;\n    end else begin\n        req_in_int <= req_in;\n        ack_in_int <= ack_in;\n    end\nend\n\n// Finite state machine\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE state\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        3'b001: // IDLE state\n            begin\n                if (New_CMD) begin\n                    next_state <= 3'b010; // SETUP state\n                end else begin\n                    next_state <= 3'b001; // IDLE state\n                end\n            end\n        3'b010: // SETUP state\n            begin\n                if (ack_in_int) begin\n                    next_state <= 3'b100; // EXECUTE state\n                end else begin\n                    next_state <= 3'b010; // SETUP state\n                end\n            end\n        3'b100: // EXECUTE state\n            begin\n                if (complete) begin\n                    next_state <= 3'b001; // IDLE state\n                end else begin\n                    next_state <= 3'b100; // EXECUTE state\n                end\n            end\n        default:\n            begin\n                next_state <= 3'b001; // IDLE state\n            end\n    endcase\nend\n\n// Output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        go_idle_o_int <= 1'b0;\n        req_out_int <= 1'b0;\n        ack_out_int <= 1'b0;\n        complete <= 1'b0;\n        index_check_enable <= 1'b0;\n        CRC_check_enable <= 1'b0;\n        response_size <= 8'b00000000;\n        RESP_1_REG_int <= 32'b00000000;\n        ERR_INT_REG_int <= 5'b00000;\n        NORMAL_INT_REG_int <= 16'b00000000;\n        Watchdog_Cnt <= 1'b0;\n        CTE <= 1'b0;\n        CIE <= 1'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n    end else begin\n        case (state)\n            3'b001: // IDLE state\n                begin\n                    go_idle_o_int <= 1'b0;\n                    req_out_int <= 1'b0;\n                    ack_out_int <= 1'b0;\n                    complete <= 1'b0;\n                    if (req_in_int) begin\n                        ack_out_int <= 1'b1;\n                    end\n                end\n            3'b010: // SETUP state\n                begin\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    response_size <= {8{CMD_SET_REG[1]}};\n                    cmd_out_int <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    settings_int <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 1'b0;\n                end\n            3'b100: // EXECUTE state\n                begin\n                    if (ack_in_int) begin\n                        req_out_int <= 1'b1;\n                    end\n                    if (req_in_int) begin\n                        ack_out_int <= 1'b1;\n                        if (serial_status[6]) begin\n                            complete <= 1'b1;\n                            if (CRC_check_enable && !serial_status[5]) begin\n                                CCRCE <= 1'b1;\n                                EI <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out_int[37:32] != cmd_in[37:32])) begin\n                                CIE <= 1'b1;\n                                EI <= 1'b1;\n                            end\n                            CC <= 1'b1;\n                            if (response_size != 8'b00000000) begin\n                                RESP_1_REG_int <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        CTE <= 1'b1;\n                        EI <= 1'b1;\n                        go_idle_o_int <= 1'b1;\n                    end\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                end\n            default:\n                begin\n                    go_idle_o_int <= 1'b0;\n                    req_out_int <= 1'b0;\n                    ack_out_int <= 1'b0;\n                    complete <= 1'b0;\n                end\n        endcase\n    end\nend\n\nassign go_idle_o = go_idle_o_int;\nassign req_out = req_out_int;\nassign ack_out = ack_out_int;\nassign STATUS_REG = {15'b000000000000000, card_present};\nassign RESP_1_REG = RESP_1_REG_int;\nassign ERR_INT_REG = {ERR_INT_RST, CTE, CCRCE, CIE, EI};\nassign NORMAL_INT_REG = {NORMAL_INT_RST, CC, 14'b00000000000000};\nassign settings = settings_int;\nassign cmd_out = cmd_out_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 2, "code": "module sd_cmd_master(\n    input           CLK_PAD_IO,\n    input           RST_PAD_I,\n    input           New_CMD,\n    input           data_write,\n    input           data_read,\n    input   [31:0]  ARG_REG,\n    input   [13:0]  CMD_SET_REG,\n    input   [15:0]  TIMEOUT_REG,\n    output  [15:0]  STATUS_REG,\n    output  [31:0]  RESP_1_REG,\n    output  [4:0]   ERR_INT_REG,\n    output  [15:0]  NORMAL_INT_REG,\n    input           ERR_INT_RST,\n    input           NORMAL_INT_RST,\n    output  [15:0]  settings,\n    output          go_idle_o,\n    output  [39:0]  cmd_out,\n    output          req_out,\n    output          ack_out,\n    input           req_in,\n    input           ack_in,\n    input   [39:0]  cmd_in,\n    input   [7:0]   serial_status,\n    input           card_detect\n);\n\n// Internal signals and registers\nreg [2:0] state;\nreg [2:0] next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_in_int;\nreg req_in_int;\nreg [31:0] status;\nreg [39:0] cmd_out_int;\nreg [15:0] settings_int;\nreg [15:0] response_size;\nreg CRC_check_enable;\nreg index_check_enable;\nreg [15:0] Watchdog_Cnt;\nreg complete;\nreg CCRCE;\nreg EI;\nreg CC;\nreg go_idle_int;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else begin\n        if (~card_detect) begin\n            if (debounce < 4'b1111) begin\n                debounce <= debounce + 1'b1;\n            end\n            if (debounce == 4'b1111) begin\n                card_present <= 1'b1;\n            end\n        end else begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end\n    end\nend\n\n// Synchronization of req_in and ack_in signals\nreg req_q;\nreg ack_q;\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_q <= 1'b0;\n        ack_q <= 1'b0;\n    end else begin\n        req_q <= req_in;\n        ack_q <= ack_in;\n    end\nend\nassign req_in_int = req_q;\nassign ack_in_int = ack_q;\n\n// Finite state machine\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE state\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        3'b001: // IDLE state\n            if (New_CMD) begin\n                next_state = 3'b010; // SETUP state\n            end else begin\n                next_state = 3'b001; // IDLE state\n            end\n        3'b010: // SETUP state\n            if (ack_in_int) begin\n                next_state = 3'b100; // EXECUTE state\n            end else begin\n                next_state = 3'b010; // SETUP state\n            end\n        3'b100: // EXECUTE state\n            if (complete) begin\n                next_state = 3'b001; // IDLE state\n            end else begin\n                next_state = 3'b100; // EXECUTE state\n            end\n        default:\n            next_state = 3'b001; // IDLE state\n    endcase\nend\n\n// Output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        go_idle_o <= 1'b0;\n        req_out <= 1'b0;\n        ack_out <= 1'b0;\n        cmd_out_int <= 40'b0;\n        settings_int <= 16'b0;\n        response_size <= 16'b0;\n        CRC_check_enable <= 1'b0;\n        index_check_enable <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        complete <= 1'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_int <= 1'b0;\n    end else begin\n        case (state)\n            3'b001: // IDLE state\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            3'b010: // SETUP state\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                index_check_enable <= CMD_SET_REG[4];\n                CRC_check_enable <= CMD_SET_REG[3];\n                cmd_out_int <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                settings_int <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                Watchdog_Cnt <= 16'b0;\n            3'b100: // EXECUTE state\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    EI <= 1'b1;\n                    go_idle_int <= 1'b1;\n                end\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    if (status[6]) begin\n                        complete <= 1'b1;\n                        if (CRC_check_enable && ~status[5]) begin\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        if (index_check_enable && (cmd_out_int[37:32] != cmd_in[37:32])) begin\n                            EI <= 1'b1;\n                        end\n                        CC <= 1'b1;\n                        if (response_size != 0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n        endcase\n    end\nend\n\nassign go_idle_o = go_idle_int;\nassign cmd_out = cmd_out_int;\nassign settings = settings_int;\nassign STATUS_REG = {15'b0, card_present};\nassign ERR_INT_REG = {4'b0, CCRCE, 1'b0, EI};\nassign NORMAL_INT_REG = {14'b0, CC, 1'b0};\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 3, "code": "// sd_cmd_master.v\n\n`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    // Inputs\n    input           CLK_PAD_IO,\n    input           RST_PAD_I,\n    input           New_CMD,\n    input           data_write,\n    input           data_read,\n    input   [31:0]  ARG_REG,\n    input   [13:0]  CMD_SET_REG,\n    input   [15:0]  TIMEOUT_REG,\n    input           req_in,\n    input           ack_in,\n    input   [39:0]  cmd_in,\n    input   [7:0]   serial_status,\n    input           card_detect,\n    input           ERR_INT_RST,\n    input           NORMAL_INT_RST,\n\n    // Outputs\n    output  [15:0]  STATUS_REG,\n    output  [31:0]  RESP_1_REG,\n    output  [4:0]   ERR_INT_REG,\n    output  [15:0]  NORMAL_INT_REG,\n    output  [15:0]  settings,\n    output          go_idle_o,\n    output  [39:0]  cmd_out,\n    output          req_out,\n    output          ack_out\n);\n\n// Internal signals\nreg [2:0] state;\nreg [3:0] debounce;\nreg       card_present;\nreg       ack_in_int;\nreg       req_in_int;\nreg [31:0] cmd_out_int;\nreg [15:0] settings_int;\nreg       CRC_check_enable;\nreg       index_check_enable;\nreg       complete;\nreg [15:0] Watchdog_Cnt;\nreg       CCRCE;\nreg       EI;\nreg       CC;\nreg       CIE;\nreg       CTE;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else if (!card_detect) begin\n        if (debounce != 4'b1111) begin\n            debounce <= debounce + 1'b1;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end\n    end else begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end\nend\n\n// Synchronize req_in and ack_in\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_in_int <= 1'b0;\n        ack_in_int <= 1'b0;\n    end else begin\n        req_in_int <= req_in;\n        ack_in_int <= ack_in;\n    end\nend\n\n// Finite state machine\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                if (New_CMD) begin\n                    state <= 3'b010; // SETUP\n                end\n            3'b010: // SETUP\n                if (ack_in_int) begin\n                    state <= 3'b100; // EXECUTE\n                end\n            3'b100: // EXECUTE\n                if (complete) begin\n                    state <= 3'b001; // IDLE\n                end\n            default:\n                state <= 3'b001; // IDLE\n        endcase\n    end\nend\n\n// State operation\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all signals\n        CRC_check_enable <= 1'b0;\n        index_check_enable <= 1'b0;\n        complete <= 1'b0;\n        Watchdog_Cnt <= 16'b0000;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        CIE <= 1'b0;\n        CTE <= 1'b0;\n        cmd_out_int <= 40'b0000;\n        settings_int <= 16'b0000;\n        go_idle_o <= 1'b0;\n        req_out <= 1'b0;\n        ack_out <= 1'b0;\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                // Reset outputs\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                // Check for new command\n                if (req_in_int) begin\n                    // Update status\n                    STATUS_REG <= serial_status;\n                    // Acknowledge\n                    ack_out <= 1'b1;\n                end\n            3'b010: // SETUP\n                // Clear interrupt registers\n                NORMAL_INT_REG <= 16'b0000;\n                ERR_INT_REG <= 5'b00000;\n                // Enable checks\n                index_check_enable <= CMD_SET_REG[4];\n                CRC_check_enable <= CMD_SET_REG[3];\n                // Determine response size\n                if (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) begin\n                    settings_int[6:0] <= 7'b0101000; // small_rsp\n                end else if (CMD_SET_REG[1:0] == 2'b01) begin\n                    settings_int[6:0] <= 7'b1111111; // big_rsp\n                end else begin\n                    settings_int[6:0] <= 7'b0000000;\n                end\n                // Assemble cmd_out and settings\n                cmd_out_int[39:38] <= 2'b01;\n                cmd_out_int[37:32] <= CMD_SET_REG[13:8];\n                cmd_out_int[31:0] <= ARG_REG;\n                settings_int[14:13] <= CMD_SET_REG[7:6];\n                settings_int[12] <= data_read;\n                settings_int[11] <= data_write;\n                settings_int[10:8] <= 3'b111;\n                settings_int[7] <= CRC_check_enable;\n                // Reset watchdog\n                Watchdog_Cnt <= 16'b0000;\n            3'b100: // EXECUTE\n                // Increment watchdog\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                // Check watchdog timeout\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    CTE <= 1'b1;\n                    EI <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                // Request and acknowledge handling\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                if (req_in_int) begin\n                    // Update status\n                    STATUS_REG <= serial_status;\n                    // Acknowledge\n                    ack_out <= 1'b1;\n                    // Check for command completion\n                    if (serial_status[6]) begin\n                        complete <= 1'b1;\n                        // Check for CRC error\n                        if (CRC_check_enable && !serial_status[5]) begin\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        // Check for index mismatch\n                        if (index_check_enable && cmd_out_int[37:32] != cmd_in[37:32]) begin\n                            CIE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        // Set command complete flag\n                        CC <= 1'b1;\n                        // Store response data\n                        if (settings_int[6:0] != 0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            default:\n                // Default to IDLE state\n                state <= 3'b001;\n        endcase\n    end\nend\n\n// Assign outputs\nassign STATUS_REG = STATUS_REG;\nassign RESP_1_REG = RESP_1_REG;\nassign ERR_INT_REG = {CCRCE, EI, CIE, CTE};\nassign NORMAL_INT_REG = {EI, CC};\nassign settings = settings_int;\nassign go_idle_o = go_idle_o;\nassign cmd_out = cmd_out_int;\nassign req_out = req_out;\nassign ack_out = ack_out;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 4, "code": "// sd_cmd_master.v\n\n`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    // Inputs\n    input           CLK_PAD_IO,\n    input           RST_PAD_I,\n    input           New_CMD,\n    input           data_write,\n    input           data_read,\n    input   [31:0]  ARG_REG,\n    input   [13:0]  CMD_SET_REG,\n    input   [15:0]  TIMEOUT_REG,\n    input           req_in,\n    input           ack_in,\n    input   [39:0]  cmd_in,\n    input   [7:0]   serial_status,\n    input           card_detect,\n    input           ERR_INT_RST,\n    input           NORMAL_INT_RST,\n\n    // Outputs\n    output  [15:0]  STATUS_REG,\n    output  [31:0]  RESP_1_REG,\n    output  [4:0]   ERR_INT_REG,\n    output  [15:0]  NORMAL_INT_REG,\n    output  [15:0]  settings,\n    output          go_idle_o,\n    output  [39:0]  cmd_out,\n    output          req_out,\n    output          ack_out\n);\n\n// Internal signals\nreg [2:0] state;\nreg [2:0] next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_in_int;\nreg req_in_int;\nreg CRC_check_enable;\nreg index_check_enable;\nreg complete;\nreg CTE;\nreg EI;\nreg CC;\nreg CIE;\nreg CCRCE;\nreg [31:0] cmd_out_reg;\nreg [15:0] settings_reg;\nreg [7:0] response_size;\nreg [7:0] small_rsp;\nreg [7:0] big_rsp;\nreg Watchdog_Cnt;\nreg [3:0] watchdog_cnt_reg;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else if (!card_detect) begin\n        if (debounce < 4'b1111) begin\n            debounce <= debounce + 1'b1;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end\n    end else begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end\nend\n\n// Synchronize req_in and ack_in signals\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_in_int <= 1'b0;\n        ack_in_int <= 1'b0;\n    end else begin\n        req_in_int <= req_in;\n        ack_in_int <= ack_in;\n    end\nend\n\n// Finite state machine\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE state\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        3'b001: // IDLE state\n            if (New_CMD) begin\n                next_state = 3'b010; // SETUP state\n            end else begin\n                next_state = 3'b001; // IDLE state\n            end\n        3'b010: // SETUP state\n            if (ack_in_int) begin\n                next_state = 3'b100; // EXECUTE state\n            end else begin\n                next_state = 3'b010; // SETUP state\n            end\n        3'b100: // EXECUTE state\n            if (complete) begin\n                next_state = 3'b001; // IDLE state\n            end else begin\n                next_state = 3'b100; // EXECUTE state\n            end\n        default:\n            next_state = 3'b001; // IDLE state\n    endcase\nend\n\n// State operation\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs\n        go_idle_o <= 1'b0;\n        req_out <= 1'b0;\n        ack_out <= 1'b0;\n        CRC_check_enable <= 1'b0;\n        index_check_enable <= 1'b0;\n        complete <= 1'b0;\n        CTE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        CIE <= 1'b0;\n        CCRCE <= 1'b0;\n        cmd_out_reg <= 40'b0;\n        settings_reg <= 16'b0;\n        response_size <= 8'b0;\n        small_rsp <= 8'b0101000;\n        big_rsp <= 8'b1111111;\n        Watchdog_Cnt <= 8'b0;\n    end else begin\n        case (state)\n            3'b001: // IDLE state\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                if (req_in_int) begin\n                    // Update status\n                end\n            3'b010: // SETUP state\n                // Compose cmd_out and settings\n                cmd_out_reg <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                settings_reg <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                // Reset watchdog counter\n                Watchdog_Cnt <= 8'b0;\n            3'b100: // EXECUTE state\n                // Increment watchdog counter\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    // Timeout error\n                    CTE <= 1'b1;\n                    EI <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                if (ack_in_int) begin\n                    // Request for service\n                    req_out <= 1'b1;\n                end\n                if (req_in_int) begin\n                    // Update status\n                    if (serial_status[6]) begin\n                        // Command cycle completed\n                        complete <= 1'b1;\n                        if (CRC_check_enable && !serial_status[5]) begin\n                            // CRC error\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        if (index_check_enable && (cmd_out_reg[37:32] != cmd_in[37:32])) begin\n                            // Index mismatch\n                            CIE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        CC <= 1'b1;\n                        if (response_size != 0) begin\n                            // Store response data\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n        endcase\n    end\nend\n\n// Assign outputs\nassign STATUS_REG = {15'b0, card_present};\nassign ERR_INT_REG = {4'b0, CIE, CCRCE, CTE};\nassign NORMAL_INT_REG = {15'b0, CC, EI};\nassign settings = settings_reg;\nassign go_idle_o = go_idle_o;\nassign cmd_out = cmd_out_reg;\nassign req_out = req_out;\nassign ack_out = ack_out;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    input           CLK_PAD_IO,\n    input           RST_PAD_I,\n    input           New_CMD,\n    input           data_write,\n    input           data_read,\n    input   [31:0]  ARG_REG,\n    input   [13:0]  CMD_SET_REG,\n    input   [15:0]  TIMEOUT_REG,\n    output  [15:0]  STATUS_REG,\n    output  [31:0]  RESP_1_REG,\n    output  [4:0]   ERR_INT_REG,\n    output  [15:0]  NORMAL_INT_REG,\n    input           ERR_INT_RST,\n    input           NORMAL_INT_RST,\n    output  [15:0]  settings,\n    output          go_idle_o,\n    output  [39:0]  cmd_out,\n    output          req_out,\n    output          ack_out,\n    input           req_in,\n    input           ack_in,\n    input   [39:0]  cmd_in,\n    input   [7:0]   serial_status,\n    input           card_detect\n);\n\n// Internal signals and registers\nreg [2:0] state; // Current state of the FSM\nreg [2:0] next_state; // Next state of the FSM\nreg [3:0] debounce; // Debounce counter for card detection\nreg card_present; // Flag indicating card presence\nreg ack_in_int; // Synchronized ack_in signal\nreg req_in_int; // Synchronized req_in signal\nreg [31:0] status; // Status register\nreg [15:0] response_size; // Response size\nreg CRC_check_enable; // CRC check enable flag\nreg index_check_enable; // Index check enable flag\nreg complete; // Command completion flag\nreg EI; // Error interrupt flag\nreg CC; // Command complete flag\nreg CIE; // Command index error flag\nreg CCRCE; // CRC error flag\nreg CTE; // Command timeout error flag\nreg [15:0] Watchdog_Cnt; // Watchdog counter\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else if (!card_detect) begin\n        if (debounce < 4'b1111) begin\n            debounce <= debounce + 1;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end\n    end else begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end\nend\n\n// Synchronization of req_in and ack_in signals\nreg req_q;\nreg ack_q;\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_q <= 1'b0;\n        ack_q <= 1'b0;\n    end else begin\n        req_q <= req_in;\n        ack_q <= ack_in;\n    end\nend\nassign req_in_int = req_q;\nassign ack_in_int = ack_q;\n\n// Finite state machine\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE state\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        3'b001: // IDLE state\n            if (New_CMD) begin\n                next_state <= 3'b010; // SETUP state\n            end else begin\n                next_state <= 3'b001; // IDLE state\n            end\n        3'b010: // SETUP state\n            if (ack_in_int) begin\n                next_state <= 3'b100; // EXECUTE state\n            end else begin\n                next_state <= 3'b010; // SETUP state\n            end\n        3'b100: // EXECUTE state\n            if (complete) begin\n                next_state <= 3'b001; // IDLE state\n            end else begin\n                next_state <= 3'b100; // EXECUTE state\n            end\n        default:\n            next_state <= 3'b001; // IDLE state\n    endcase\nend\n\n// State operations\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs and internal signals\n        go_idle_o <= 1'b0;\n        req_out <= 1'b0;\n        ack_out <= 1'b0;\n        STATUS_REG <= 16'b0000;\n        RESP_1_REG <= 32'b0000;\n        ERR_INT_REG <= 5'b00000;\n        NORMAL_INT_REG <= 16'b0000;\n        settings <= 16'b0000;\n        cmd_out <= 40'b0000;\n        CRC_check_enable <= 1'b0;\n        index_check_enable <= 1'b0;\n        complete <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        CIE <= 1'b0;\n        CCRCE <= 1'b0;\n        CTE <= 1'b0;\n        Watchdog_Cnt <= 16'b0000;\n    end else begin\n        case (state)\n            3'b001: // IDLE state\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            3'b010: // SETUP state\n                NORMAL_INT_REG <= 16'b0000;\n                ERR_INT_REG <= 5'b00000;\n                STATUS_REG <= 16'b0000;\n                index_check_enable <= CMD_SET_REG[4];\n                CRC_check_enable <= CMD_SET_REG[3];\n                cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                Watchdog_Cnt <= 16'b0000;\n            3'b100: // EXECUTE state\n                Watchdog_Cnt <= Watchdog_Cnt + 1;\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    CTE <= 1'b1;\n                    EI <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    if (status[6]) begin // dat_ava\n                        complete <= 1'b1;\n                        EI <= 1'b0;\n                        if (CRC_check_enable && !status[5]) begin // crc_valid\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            CIE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        CC <= 1'b1;\n                        if (response_size != 0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 6, "code": "module sd_cmd_master(\n    input           CLK_PAD_IO,\n    input           RST_PAD_I,\n    input           New_CMD,\n    input           data_write,\n    input           data_read,\n    input   [31:0]  ARG_REG,\n    input   [13:0]  CMD_SET_REG,\n    input   [15:0]  TIMEOUT_REG,\n    output  [15:0]  STATUS_REG,\n    output  [31:0]  RESP_1_REG,\n    output  [4:0]   ERR_INT_REG,\n    output  [15:0]  NORMAL_INT_REG,\n    input           ERR_INT_RST,\n    input           NORMAL_INT_RST,\n    output  [15:0]  settings,\n    output          go_idle_o,\n    output  [39:0]  cmd_out,\n    output          req_out,\n    output          ack_out,\n    input           req_in,\n    input           ack_in,\n    input   [39:0]  cmd_in,\n    input   [7:0]   serial_status,\n    input           card_detect\n);\n\n// Debounce Logic\nreg [3:0] debounce;\nreg card_present;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else if (!card_detect) begin\n        if (debounce != 4'b1111) begin\n            debounce <= debounce + 1'b1;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end\n    end else begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end\nend\n\n// Request and Acknowledge Synchronizers\nreg req_q;\nreg req_in_int;\nreg ack_q;\nreg ack_in_int;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n    end else begin\n        req_q <= req_in;\n        req_in_int <= req_q;\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n    end\nend\n\n// Finite State Machine (FSM)\nreg [2:0] state;\nreg [2:0] next_state;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        3'b001: // IDLE\n            if (New_CMD) begin\n                next_state <= 3'b010; // SETUP\n            end else begin\n                next_state <= 3'b001; // IDLE\n            end\n        3'b010: // SETUP\n            if (ack_in_int) begin\n                next_state <= 3'b100; // EXECUTE\n            end else begin\n                next_state <= 3'b010; // SETUP\n            end\n        3'b100: // EXECUTE\n            if (complete) begin\n                next_state <= 3'b001; // IDLE\n            end else begin\n                next_state <= 3'b100; // EXECUTE\n            end\n        default:\n            next_state <= 3'b001; // IDLE\n    endcase\nend\n\n// FSM State operation\nreg complete;\nreg CRC_check_enable;\nreg index_check_enable;\nreg [39:0] cmd_out_reg;\nreg [15:0] settings_reg;\nreg [7:0] response_size;\nreg req_out_reg;\nreg ack_out_reg;\nreg [15:0] Watchdog_Cnt;\nreg CCRCE;\nreg EI;\nreg CC;\nreg go_idle_o_reg;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        complete <= 1'b0;\n        CRC_check_enable <= 1'b0;\n        index_check_enable <= 1'b0;\n        cmd_out_reg <= 40'b0;\n        settings_reg <= 16'b0;\n        response_size <= 8'b0;\n        req_out_reg <= 1'b0;\n        ack_out_reg <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_o_reg <= 1'b0;\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                go_idle_o_reg <= 1'b0;\n                req_out_reg <= 1'b0;\n                ack_out_reg <= 1'b0;\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out_reg <= 1'b1;\n                end\n            3'b010: // SETUP\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4];\n                CRC_check_enable <= CMD_SET_REG[3];\n                cmd_out_reg <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                settings_reg <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                Watchdog_Cnt <= 16'b0;\n            3'b100: // EXECUTE\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    CTE <= 1'b1;\n                    EI <= 1'b1;\n                    go_idle_o_reg <= 1'b1;\n                end\n                if (ack_in_int) begin\n                    req_out_reg <= 1'b1;\n                end\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out_reg <= 1'b1;\n                    if (dat_ava) begin\n                        complete <= 1'b1;\n                        EI <= 1'b0;\n                        if (CRC_check_enable && ~crc_valid) begin\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        if (index_check_enable && (cmd_out_reg[37:32] != cmd_in[37:32])) begin\n                            CIE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        CC <= 1'b1;\n                        if (response_size != 0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n        endcase\n    end\nend\n\nassign go_idle_o = go_idle_o_reg;\nassign req_out = req_out_reg;\nassign ack_out = ack_out_reg;\nassign cmd_out = cmd_out_reg;\nassign settings = settings_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 7, "code": "// Import necessary definitions\n`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    // Clock and Reset\n    input           CLK_PAD_IO,\n    input           RST_PAD_I,\n\n    // Command and Data Signals\n    input           New_CMD,\n    input           data_write,\n    input           data_read,\n    input   [31:0]  ARG_REG,\n    input   [13:0]  CMD_SET_REG,\n    input   [15:0]  TIMEOUT_REG,\n\n    // Status and Response Registers\n    output  [15:0]  STATUS_REG,\n    output  [31:0]  RESP_1_REG,\n\n    // Interrupt Registers\n    output  [4:0]   ERR_INT_REG,\n    output  [15:0]  NORMAL_INT_REG,\n\n    // Interrupt Reset Signals\n    input           ERR_INT_RST,\n    input           NORMAL_INT_RST,\n\n    // Command Settings Output\n    output  [15:0]  settings,\n\n    // Idle and Request Signals\n    output          go_idle_o,\n    output  [39:0]  cmd_out,\n    output          req_out,\n    output          ack_out,\n\n    // Request and Acknowledge Input Signals\n    input           req_in,\n    input           ack_in,\n\n    // Command Input from SD/MMC Card\n    input   [39:0]  cmd_in,\n\n    // Serial Status Input\n    input   [7:0]   serial_status,\n\n    // Card Detection Signal\n    input           card_detect\n);\n\n// Internal Signals and Registers\nreg     [2:0]  state;  // Current state of the FSM\nreg     [2:0]  next_state;  // Next state of the FSM\nreg     [3:0]  debounce;  // Debounce counter for card detection\nreg             card_present;  // Flag indicating card presence\nreg             ack_in_int;  // Synchronized acknowledge input signal\nreg             req_in_int;  // Synchronized request input signal\nreg     [15:0]  Watchdog_Cnt;  // Watchdog counter for command timeout\nreg             complete;  // Flag indicating command completion\nreg             CRC_check_enable;  // Flag enabling CRC check\nreg             index_check_enable;  // Flag enabling index check\nreg     [31:0]  resp_data;  // Response data from SD/MMC card\nreg             dat_ava;  // Flag indicating data availability\nreg             crc_valid;  // Flag indicating CRC validity\nreg             CIE;  // Command Index Error flag\nreg             CCRCE;  // CRC Check Error flag\nreg             CTE;  // Command Timeout Error flag\nreg             EI;  // Error Interrupt flag\nreg             CC;  // Command Complete flag\n\n// Debounce Logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else if (!card_detect) begin\n        if (debounce < 4'b1111) begin\n            debounce <= debounce + 1'b1;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end\n    end else begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end\nend\n\n// Synchronization of Request and Acknowledge Signals\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_in_int <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_in_int <= ack_in;\n        req_in_int <= req_in;\n    end\nend\n\n// Finite State Machine (FSM) Logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001;  // IDLE state\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        3'b001:  // IDLE state\n            begin\n                if (New_CMD) begin\n                    next_state <= 3'b010;  // SETUP state\n                end else begin\n                    next_state <= 3'b001;  // Remain in IDLE\n                end\n            end\n        3'b010:  // SETUP state\n            begin\n                if (ack_in_int) begin\n                    next_state <= 3'b100;  // EXECUTE state\n                end else begin\n                    next_state <= 3'b010;  // Remain in SETUP\n                end\n            end\n        3'b100:  // EXECUTE state\n            begin\n                if (complete) begin\n                    next_state <= 3'b001;  // IDLE state\n                end else begin\n                    next_state <= 3'b100;  // Remain in EXECUTE\n                end\n            end\n        default:\n            begin\n                next_state <= 3'b001;  // Default to IDLE\n            end\n    endcase\nend\n\n// FSM State Operations\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs and flags\n        go_idle_o <= 1'b0;\n        req_out <= 1'b0;\n        ack_out <= 1'b0;\n        cmd_out <= 40'b0;\n        settings <= 16'b0;\n        Watchdog_Cnt <= 16'b0;\n        complete <= 1'b0;\n        CRC_check_enable <= 1'b0;\n        index_check_enable <= 1'b0;\n        resp_data <= 32'b0;\n        dat_ava <= 1'b0;\n        crc_valid <= 1'b0;\n        CIE <= 1'b0;\n        CCRCE <= 1'b0;\n        CTE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n    end else begin\n        case (state)\n            3'b001:  // IDLE state\n                begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        // Update status and acknowledge\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n            3'b010:  // SETUP state\n                begin\n                    // Configure command settings and assemble cmd_out\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    index_check_enable <= CMD_SET_REG[4];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], 7'b0};\n                    Watchdog_Cnt <= 16'b0;\n                end\n            3'b100:  // EXECUTE state\n                begin\n                    // Increment watchdog counter and check for timeout\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        CTE <= 1'b1;\n                        EI <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    // Check for command completion and update response data\n                    if (complete) begin\n                        resp_data <= cmd_in[31:0];\n                        dat_ava <= 1'b1;\n                    end\n                    // Check for CRC and index errors\n                    if (CRC_check_enable && !crc_valid) begin\n                        CCRCE <= 1'b1;\n                        EI <= 1'b1;\n                    end\n                    if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                        CIE <= 1'b1;\n                        EI <= 1'b1;\n                    end\n                end\n        endcase\n    end\nend\n\n// Assign outputs\nassign STATUS_REG = {15'b0, card_present};\nassign RESP_1_REG = resp_data;\nassign ERR_INT_REG = {4'b0, CIE, CCRCE, CTE};\nassign NORMAL_INT_REG = {14'b0, EI, CC};\nassign settings = {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], 7'b0};\nassign go_idle_o = (state == 3'b100 && complete);\nassign cmd_out = {2'b01, CMD_SET_REG[13:8], ARG_REG};\nassign req_out = (state == 3'b100 && ack_in_int);\nassign ack_out = (state == 3'b001 && req_in_int);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    input               CLK_PAD_IO,\n    input               RST_PAD_I,\n    input               New_CMD,\n    input               data_write,\n    input               data_read,\n    input   [31:0]      ARG_REG,\n    input   [13:0]      CMD_SET_REG,\n    input   [15:0]      TIMEOUT_REG,\n    output  [15:0]      STATUS_REG,\n    output  [31:0]      RESP_1_REG,\n    output  [4:0]       ERR_INT_REG,\n    output  [15:0]      NORMAL_INT_REG,\n    input               ERR_INT_RST,\n    input               NORMAL_INT_RST,\n    output  [15:0]      settings,\n    output              go_idle_o,\n    output  [39:0]      cmd_out,\n    output              req_out,\n    output              ack_out,\n    input               req_in,\n    input               ack_in,\n    input   [39:0]      cmd_in,\n    input   [7:0]       serial_status,\n    input               card_detect\n);\n\nreg [2:0] state;\nreg [2:0] next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_in_int;\nreg req_in_int;\n\n// Debounce Logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else begin\n        if (~card_detect) begin\n            if (debounce < 4'b1111) begin\n                debounce <= debounce + 1;\n            end\n        end else begin\n            debounce <= 4'b0000;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end else begin\n            card_present <= 1'b0;\n        end\n    end\nend\n\n// Synchronize req_in and ack_in signals\nreg ack_q;\nreg req_q;\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        req_q <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        req_q <= req_in;\n    end\nend\nassign ack_in_int = ack_q;\nassign req_in_int = req_q;\n\n// Finite State Machine (FSM)\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE state\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        3'b001: // IDLE state\n            if (New_CMD) begin\n                next_state = 3'b010; // SETUP state\n            end else begin\n                next_state = 3'b001; // IDLE state\n            end\n        3'b010: // SETUP state\n            if (ack_in_int) begin\n                next_state = 3'b100; // EXECUTE state\n            end else begin\n                next_state = 3'b010; // SETUP state\n            end\n        3'b100: // EXECUTE state\n            if (serial_status[6]) begin // dat_ava\n                next_state = 3'b001; // IDLE state\n            end else begin\n                next_state = 3'b100; // EXECUTE state\n            end\n        default:\n            next_state = 3'b001; // IDLE state\n    endcase\nend\n\n// FSM State operation\nreg CRC_check_enable;\nreg index_check_enable;\nreg [15:0] response_size;\nreg [39:0] cmd_out_reg;\nreg [15:0] settings_reg;\nreg [31:0] RESP_1_REG_int;\nreg [4:0] ERR_INT_REG_int;\nreg [15:0] NORMAL_INT_REG_int;\nreg complete;\nreg go_idle_o_reg;\nreg req_out_reg;\nreg ack_out_reg;\nreg [7:0] status;\nreg Watchdog_Cnt;\nreg CTE;\nreg CCRCE;\nreg EI;\nreg CC;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        CRC_check_enable <= 1'b0;\n        index_check_enable <= 1'b0;\n        response_size <= 16'd0;\n        cmd_out_reg <= 40'd0;\n        settings_reg <= 16'd0;\n        RESP_1_REG_int <= 32'd0;\n        ERR_INT_REG_int <= 5'd0;\n        NORMAL_INT_REG_int <= 16'd0;\n        complete <= 1'b0;\n        go_idle_o_reg <= 1'b0;\n        req_out_reg <= 1'b0;\n        ack_out_reg <= 1'b0;\n        status <= 8'd0;\n        Watchdog_Cnt <= 8'd0;\n        CTE <= 1'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n    end else begin\n        case (state)\n            3'b001: // IDLE state\n                go_idle_o_reg <= 1'b0;\n                req_out_reg <= 1'b0;\n                ack_out_reg <= 1'b0;\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out_reg <= 1'b1;\n                end\n            3'b010: // SETUP state\n                NORMAL_INT_REG_int <= 16'd0;\n                ERR_INT_REG_int <= 5'd0;\n                index_check_enable <= CMD_SET_REG[4];\n                CRC_check_enable <= CMD_SET_REG[3];\n                cmd_out_reg <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                settings_reg <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                Watchdog_Cnt <= 8'd0;\n            3'b100: // EXECUTE state\n                Watchdog_Cnt <= Watchdog_Cnt + 1;\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    CTE <= 1'b1;\n                    EI <= 1'b1;\n                    go_idle_o_reg <= 1'b1;\n                end\n                if (ack_in_int) begin\n                    req_out_reg <= 1'b1;\n                end\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out_reg <= 1'b1;\n                    if (serial_status[6]) begin // dat_ava\n                        complete <= 1'b1;\n                        EI <= 1'b0;\n                        if (CRC_check_enable && ~serial_status[5]) begin // crc_valid\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        if (index_check_enable && (cmd_out_reg[37:32] != cmd_in[37:32])) begin\n                            CIE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        CC <= 1'b1;\n                        if (response_size != 0) begin\n                            RESP_1_REG_int <= cmd_in[31:0];\n                        end\n                    end\n                end\n            default:\n                go_idle_o_reg <= 1'b0;\n                req_out_reg <= 1'b0;\n                ack_out_reg <= 1'b0;\n        endcase\n    end\nend\n\nassign STATUS_REG = {15'd0, card_present};\nassign RESP_1_REG = RESP_1_REG_int;\nassign ERR_INT_REG = {ERR_INT_REG_int, 3'd0};\nassign NORMAL_INT_REG = {NORMAL_INT_REG_int[14:1], CC};\nassign settings = settings_reg;\nassign go_idle_o = go_idle_o_reg;\nassign cmd_out = cmd_out_reg;\nassign req_out = req_out_reg;\nassign ack_out = ack_out_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    // Clock and Reset\n    input           CLK_PAD_IO,\n    input           RST_PAD_I,\n\n    // Command and Data\n    input           New_CMD,\n    input           data_write,\n    input           data_read,\n    input   [31:0]  ARG_REG,\n    input   [13:0]  CMD_SET_REG,\n    input   [15:0]  TIMEOUT_REG,\n\n    // Status and Response\n    output  [15:0]  STATUS_REG,\n    output  [31:0]  RESP_1_REG,\n\n    // Interrupts\n    output  [4:0]   ERR_INT_REG,\n    output  [15:0]  NORMAL_INT_REG,\n    input           ERR_INT_RST,\n    input           NORMAL_INT_RST,\n\n    // Command Settings and Output\n    output  [15:0]  settings,\n    output          go_idle_o,\n    output  [39:0]  cmd_out,\n    output          req_out,\n    output          ack_out,\n\n    // Serial Interface\n    input           req_in,\n    input           ack_in,\n    input   [39:0]  cmd_in,\n    input   [7:0]   serial_status,\n    input           card_detect\n);\n\n// Internal Signals\nreg [2:0] state; // IDLE, SETUP, EXECUTE\nreg [3:0] debounce;\nreg card_present;\nreg [39:0] cmd_out_int;\nreg [15:0] settings_int;\nreg req_out_int;\nreg ack_out_int;\nreg [31:0] RESP_1_REG_int;\nreg [15:0] STATUS_REG_int;\nreg [4:0] ERR_INT_REG_int;\nreg [15:0] NORMAL_INT_REG_int;\nreg go_idle_o_int;\nreg Watchdog_Cnt;\nreg index_check_enable;\nreg CRC_check_enable;\nreg complete;\nreg dat_ava;\nreg crc_valid;\nreg CIE;\nreg CCRCE;\nreg CTE;\nreg EI;\nreg CC;\n\n// Debounce Logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else if (!card_detect) begin\n        if (debounce != 4'b1111) begin\n            debounce <= debounce + 1'b1;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end\n    end else begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end\nend\n\n// Synchronization\nreg ack_q;\nreg ack_in_int;\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n    end\nend\n\nreg req_q;\nreg req_in_int;\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// Finite State Machine\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                if (New_CMD) begin\n                    state <= 3'b010; // SETUP\n                end\n            3'b010: // SETUP\n                if (ack_in_int) begin\n                    state <= 3'b100; // EXECUTE\n                end\n            3'b100: // EXECUTE\n                if (complete) begin\n                    state <= 3'b001; // IDLE\n                end\n            default:\n                state <= 3'b001; // IDLE\n        endcase\n    end\nend\n\n// State Operations\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        dat_ava <= 1'b0;\n        crc_valid <= 1'b0;\n        CIE <= 1'b0;\n        CCRCE <= 1'b0;\n        CTE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_o_int <= 1'b0;\n        req_out_int <= 1'b0;\n        ack_out_int <= 1'b0;\n        Watchdog_Cnt <= 8'b00000000;\n        index_check_enable <= 1'b0;\n        cmd_out_int <= 40'b000000000000000000000000000000000000;\n        settings_int <= 16'b0000000000000000;\n        RESP_1_REG_int <= 32'b00000000000000000000000000000000;\n        STATUS_REG_int <= 16'b0000000000000000;\n        ERR_INT_REG_int <= 5'b00000;\n        NORMAL_INT_REG_int <= 16'b0000000000000000;\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                go_idle_o_int <= 1'b0;\n                req_out_int <= 1'b0;\n                ack_out_int <= 1'b0;\n                CICMD <= 1'b0;\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out_int <= 1'b1;\n                end\n            3'b010: // SETUP\n                NORMAL_INT_REG_int <= 16'b0000000000000000;\n                ERR_INT_REG_int <= 5'b00000;\n                index_check_enable <= CMD_SET_REG[4];\n                CRC_check_enable <= CMD_SET_REG[3];\n                cmd_out_int[39:38] <= 2'b01;\n                cmd_out_int[37:32] <= CMD_SET_REG[13:8];\n                cmd_out_int[31:0] <= ARG_REG;\n                settings_int[14:13] <= CMD_SET_REG[7:6];\n                settings_int[12] <= data_read;\n                settings_int[11] <= data_write;\n                settings_int[10:8] <= 3'b111;\n                settings_int[7] <= CMD_SET_REG[3];\n                settings_int[6:0] <= 7'b0000000; // response_size\n                Watchdog_Cnt <= 8'b00000000;\n                CICMD <= 1'b1;\n            3'b100: // EXECUTE\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    CTE <= 1'b1;\n                    EI <= 1'b1;\n                    if (ack_in_int) begin\n                        complete <= 1'b1;\n                    end\n                    go_idle_o_int <= 1'b1;\n                end\n                if (ack_in_int) begin\n                    req_out_int <= 1'b1;\n                end\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out_int <= 1'b1;\n                    if (dat_ava) begin\n                        complete <= 1'b1;\n                        EI <= 1'b0;\n                        if (CRC_check_enable && !crc_valid) begin\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        if (index_check_enable && (cmd_out_int[37:32] != cmd_in[37:32])) begin\n                            CIE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        CC <= 1'b1;\n                        if (settings_int[6:0] != 7'b0000000) begin\n                            RESP_1_REG_int <= cmd_in[31:0];\n                        end\n                    end\n                end\n            default:\n                go_idle_o_int <= 1'b0;\n                req_out_int <= 1'b0;\n                ack_out_int <= 1'b0;\n        endcase\n    end\nend\n\nassign go_idle_o = go_idle_o_int;\nassign req_out = req_out_int;\nassign ack_out = ack_out_int;\nassign cmd_out = cmd_out_int;\nassign settings = settings_int;\nassign RESP_1_REG = RESP_1_REG_int;\nassign STATUS_REG = STATUS_REG_int;\nassign ERR_INT_REG = ERR_INT_REG_int;\nassign NORMAL_INT_REG = NORMAL_INT_REG_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 10, "code": "// sd_cmd_master.v\n\n`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    input             CLK_PAD_IO,    // Clock input\n    input             RST_PAD_I,     // Asynchronous reset, active high\n    input             New_CMD,       // Signal indicating a new command is available\n    input             data_write,    // Indicates a block write command\n    input             data_read,     // Indicates a block read command\n    input     [31:0]  ARG_REG,       // Command argument register\n    input     [13:0]  CMD_SET_REG,   // Command settings register\n    input     [15:0]  TIMEOUT_REG,   // Timeout configuration register\n    output    [15:0]  STATUS_REG,    // Status register\n    output    [31:0]  RESP_1_REG,    // Response register\n    output    [4:0]   ERR_INT_REG,   // Error interrupt register\n    output    [15:0]  NORMAL_INT_REG,// Normal interrupt register\n    input             ERR_INT_RST,   // Error interrupt reset signal\n    input             NORMAL_INT_RST,// Normal interrupt reset signal\n    output    [15:0]  settings,      // Command settings output\n    output            go_idle_o,     // Signal to reset the module to idle state\n    output    [39:0]  cmd_out,       // Command output to SD/MMC card\n    output            req_out,       // Request signal for service\n    output            ack_out,       // Acknowledge signal for service completion\n    input             req_in,        // Request input signal from serial interface\n    input             ack_in,        // Acknowledge input signal from serial interface\n    input     [39:0]  cmd_in,        // Command input from SD/MMC card\n    input     [7:0]   serial_status, // Serial status input\n    input             card_detect    // SD card presence detection signal\n);\n\n// Internal signals and registers\nreg [2:0] state;      // Current state of the FSM\nreg [2:0] next_state; // Next state of the FSM\nreg [3:0] debounce;   // Debounce counter for card detection\nreg       card_present; // Flag indicating card presence\nreg       ack_in_int;  // Synchronized acknowledge input signal\nreg       req_in_int;  // Synchronized request input signal\nreg [39:0] cmd_out_int; // Internal command output signal\nreg [15:0] settings_int; // Internal command settings signal\nreg       complete;    // Flag indicating command completion\nreg       CRC_check_enable; // Flag enabling CRC check\nreg       index_check_enable; // Flag enabling index check\nreg [15:0] Watchdog_Cnt; // Watchdog counter\nreg       CTE;          // Command timeout error flag\nreg       CCRCE;        // CRC error flag\nreg       CIE;          // Command index error flag\nreg       EI;           // Error interrupt flag\nreg       CC;           // Command complete flag\n\n// FSM state definitions\nlocalparam IDLE = 3'b001;\nlocalparam SETUP = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else if (!card_detect) begin\n        if (debounce < 4'b1111) begin\n            debounce <= debounce + 1;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end\n    end else begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end\nend\n\n// Synchronization of acknowledge and request input signals\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_in_int <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_in_int <= ack_in;\n        req_in_int <= req_in;\n    end\nend\n\n// FSM next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (New_CMD) begin\n                next_state <= SETUP;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        SETUP: begin\n            if (ack_in_int) begin\n                next_state <= EXECUTE;\n            end else begin\n                next_state <= SETUP;\n            end\n        end\n        EXECUTE: begin\n            if (complete) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= EXECUTE;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\n// FSM state register update\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM output logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            go_idle_o <= 1'b0;\n            req_out <= 1'b0;\n            ack_out <= 1'b0;\n            CICMD <= 1'b0;\n            if (req_in_int) begin\n                status <= serial_status;\n                ack_out <= 1'b1;\n            end\n        end\n        SETUP: begin\n            NORMAL_INT_REG <= 16'b0;\n            ERR_INT_REG <= 5'b0;\n            index_check_enable <= CMD_SET_REG[4];\n            CRC_check_enable <= CMD_SET_REG[3];\n            cmd_out_int <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n            settings_int <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n            Watchdog_Cnt <= 16'b0;\n        end\n        EXECUTE: begin\n            Watchdog_Cnt <= Watchdog_Cnt + 1;\n            if (Watchdog_Cnt > TIMEOUT_REG) begin\n                CTE <= 1'b1;\n                EI <= 1'b1;\n                go_idle_o <= 1'b1;\n            end\n            if (ack_in_int) begin\n                req_out <= 1'b1;\n            end\n            if (req_in_int) begin\n                status <= serial_status;\n                ack_out <= 1'b1;\n                if (dat_ava) begin\n                    complete <= 1'b1;\n                    EI <= 1'b0;\n                    if (CRC_check_enable && !crc_valid) begin\n                        CCRCE <= 1'b1;\n                        EI <= 1'b1;\n                    end\n                    if (index_check_enable && (cmd_out_int[37:32] != cmd_in[37:32])) begin\n                        CIE <= 1'b1;\n                        EI <= 1'b1;\n                    end\n                    CC <= 1'b1;\n                    if (response_size != 0) begin\n                        RESP_1_REG <= cmd_in[31:0];\n                    end\n                end\n            end\n        end\n        default: begin\n            go_idle_o <= 1'b0;\n            req_out <= 1'b0;\n            ack_out <= 1'b0;\n        end\n    endcase\nend\n\n// Assign outputs\nassign STATUS_REG = status;\nassign RESP_1_REG = RESP_1_REG;\nassign ERR_INT_REG = {CIE, CCRCE, CTE};\nassign NORMAL_INT_REG = {EI, CC};\nassign settings = settings_int;\nassign cmd_out = cmd_out_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 11, "code": "// sd_cmd_master.v\n\n`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    input           CLK_PAD_IO,\n    input           RST_PAD_I,\n    input           New_CMD,\n    input           data_write,\n    input           data_read,\n    input   [31:0]  ARG_REG,\n    input   [13:0]  CMD_SET_REG,\n    input   [15:0]  TIMEOUT_REG,\n    output  [15:0]  STATUS_REG,\n    output  [31:0]  RESP_1_REG,\n    output  [4:0]   ERR_INT_REG,\n    output  [15:0]  NORMAL_INT_REG,\n    input           ERR_INT_RST,\n    input           NORMAL_INT_RST,\n    output  [15:0]  settings,\n    output          go_idle_o,\n    output  [39:0]  cmd_out,\n    output          req_out,\n    output          ack_out,\n    input           req_in,\n    input           ack_in,\n    input   [39:0]  cmd_in,\n    input   [7:0]   serial_status,\n    input           card_detect\n);\n\n// Internal signals\nreg [2:0] state;\nreg [2:0] next_state;\nreg [3:0] debounce;\nreg card_present;\nreg req_in_int;\nreg ack_in_int;\nreg [31:0] status;\nreg [15:0] Watchdog_Cnt;\nreg CICMD;\nreg complete;\nreg EI;\nreg CC;\nreg CTE;\nreg CCRCE;\nreg CIE;\nreg [39:0] cmd_out_int;\nreg [15:0] settings_int;\nreg req_out_int;\nreg ack_out_int;\nreg [7:0] response_size;\nreg CRC_check_enable;\nreg index_check_enable;\nreg dat_ava;\nreg crc_valid;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce != 4'b1111) begin\n                debounce <= debounce + 1;\n            end\n        end else begin\n            debounce <= 4'b0000;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end else begin\n            card_present <= 1'b0;\n        end\n    end\nend\n\n// Synchronize req_in and ack_in signals\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_in_int <= 1'b0;\n        ack_in_int <= 1'b0;\n    end else begin\n        req_in_int <= req_in;\n        ack_in_int <= ack_in;\n    end\nend\n\n// Finite state machine\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE state\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        3'b001: // IDLE state\n            if (New_CMD) begin\n                next_state <= 3'b010; // SETUP state\n            end else begin\n                next_state <= 3'b001; // IDLE state\n            end\n        3'b010: // SETUP state\n            if (ack_in_int) begin\n                next_state <= 3'b100; // EXECUTE state\n            end else begin\n                next_state <= 3'b010; // SETUP state\n            end\n        3'b100: // EXECUTE state\n            if (complete) begin\n                next_state <= 3'b001; // IDLE state\n            end else begin\n                next_state <= 3'b100; // EXECUTE state\n            end\n        default:\n            next_state <= 3'b001; // IDLE state\n    endcase\nend\n\n// Output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        go_idle_o <= 1'b0;\n        req_out <= 1'b0;\n        ack_out <= 1'b0;\n        CICMD <= 1'b0;\n        complete <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        CTE <= 1'b0;\n        CCRCE <= 1'b0;\n        CIE <= 1'b0;\n        cmd_out <= 40'b0;\n        settings <= 16'b0;\n        response_size <= 8'b0;\n        CRC_check_enable <= 1'b0;\n        index_check_enable <= 1'b0;\n        dat_ava <= 1'b0;\n        crc_valid <= 1'b0;\n    end else begin\n        case (state)\n            3'b001: // IDLE state\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                CICMD <= 1'b0;\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            3'b010: // SETUP state\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4];\n                CRC_check_enable <= CMD_SET_REG[3];\n                cmd_out_int <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                settings_int <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                Watchdog_Cnt <= 16'b0;\n            3'b100: // EXECUTE state\n                Watchdog_Cnt <= Watchdog_Cnt + 1;\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    CTE <= 1'b1;\n                    EI <= 1'b1;\n                    go_idle_o <= 1'b1;\n                end\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    if (dat_ava) begin\n                        complete <= 1'b1;\n                        EI <= 1'b0;\n                        if (CRC_check_enable && !crc_valid) begin\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        if (index_check_enable && (cmd_out_int[37:32] != cmd_in[37:32])) begin\n                            CIE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        CC <= 1'b1;\n                        if (response_size != 0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n        endcase\n    end\nend\n\nassign cmd_out = cmd_out_int;\nassign settings = settings_int;\nassign req_out = req_out_int;\nassign ack_out = ack_out_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 12, "code": "// sd_cmd_master.v\n\n`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    // Inputs\n    input           CLK_PAD_IO,\n    input           RST_PAD_I,\n    input           New_CMD,\n    input           data_write,\n    input           data_read,\n    input   [31:0]  ARG_REG,\n    input   [13:0]  CMD_SET_REG,\n    input   [15:0]  TIMEOUT_REG,\n    input           req_in,\n    input           ack_in,\n    input   [39:0]  cmd_in,\n    input   [7:0]   serial_status,\n    input           card_detect,\n    input           ERR_INT_RST,\n    input           NORMAL_INT_RST,\n\n    // Outputs\n    output  [15:0]  STATUS_REG,\n    output  [31:0]  RESP_1_REG,\n    output  [4:0]   ERR_INT_REG,\n    output  [15:0]  NORMAL_INT_REG,\n    output  [15:0]  settings,\n    output          go_idle_o,\n    output  [39:0]  cmd_out,\n    output          req_out,\n    output          ack_out\n);\n\n// Internal signals\nreg [2:0] state;\nreg [3:0] debounce;\nreg        card_present;\nreg        req_in_int;\nreg        ack_in_int;\nreg [39:0] cmd_out_int;\nreg [15:0] settings_int;\nreg [31:0] RESP_1_REG_int;\nreg [4:0]  ERR_INT_REG_int;\nreg [15:0] NORMAL_INT_REG_int;\nreg [15:0] STATUS_REG_int;\nreg        go_idle_o_int;\nreg        req_out_int;\nreg        ack_out_int;\nreg [7:0]  status_int;\nreg [7:0]  response_size_int;\nreg        complete_int;\nreg        CRC_check_enable_int;\nreg        index_check_enable_int;\nreg        Watchdog_Cnt_int;\nreg        CCRCE_int;\nreg        EI_int;\nreg        CC_int;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else begin\n        if (~card_detect) begin\n            if (debounce < 4'b1111) begin\n                debounce <= debounce + 1'b1;\n            end\n            if (debounce == 4'b1111) begin\n                card_present <= 1'b1;\n            end\n        end else begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end\n    end\nend\n\n// Synchronize req_in and ack_in\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_in_int <= 1'b0;\n        ack_in_int <= 1'b0;\n    end else begin\n        req_in_int <= req_in;\n        ack_in_int <= ack_in;\n    end\nend\n\n// Finite state machine\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                if (New_CMD) begin\n                    state <= 3'b010; // SETUP\n                end\n            3'b010: // SETUP\n                if (ack_in_int) begin\n                    state <= 3'b100; // EXECUTE\n                end\n            3'b100: // EXECUTE\n                if (complete_int) begin\n                    state <= 3'b001; // IDLE\n                end\n            default:\n                state <= 3'b001; // IDLE\n        endcase\n    end\nend\n\n// Output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        go_idle_o_int <= 1'b0;\n        req_out_int <= 1'b0;\n        ack_out_int <= 1'b0;\n        cmd_out_int <= 40'b0;\n        settings_int <= 16'b0;\n        RESP_1_REG_int <= 32'b0;\n        ERR_INT_REG_int <= 5'b0;\n        NORMAL_INT_REG_int <= 16'b0;\n        STATUS_REG_int <= 16'b0;\n        status_int <= 8'b0;\n        response_size_int <= 8'b0;\n        complete_int <= 1'b0;\n        CRC_check_enable_int <= 1'b0;\n        index_check_enable_int <= 1'b0;\n        Watchdog_Cnt_int <= 8'b0;\n        CCRCE_int <= 1'b0;\n        EI_int <= 1'b0;\n        CC_int <= 1'b0;\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                go_idle_o_int <= 1'b0;\n                req_out_int <= 1'b0;\n                ack_out_int <= 1'b0;\n                if (req_in_int) begin\n                    status_int <= serial_status;\n                    ack_out_int <= 1'b1;\n                end\n            3'b010: // SETUP\n                NORMAL_INT_REG_int <= 16'b0;\n                ERR_INT_REG_int <= 5'b0;\n                STATUS_REG_int <= 16'b0;\n                index_check_enable_int <= CMD_SET_REG[4];\n                CRC_check_enable_int <= CMD_SET_REG[3];\n                cmd_out_int <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                settings_int <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size_int};\n                Watchdog_Cnt_int <= 8'b0;\n            3'b100: // EXECUTE\n                Watchdog_Cnt_int <= Watchdog_Cnt_int + 1'b1;\n                if (Watchdog_Cnt_int > TIMEOUT_REG) begin\n                    CCRCE_int <= 1'b1;\n                    EI_int <= 1'b1;\n                    go_idle_o_int <= 1'b1;\n                end\n                if (ack_in_int) begin\n                    req_out_int <= 1'b1;\n                end\n                if (req_in_int) begin\n                    status_int <= serial_status;\n                    ack_out_int <= 1'b1;\n                    if (status_int[6]) begin\n                        complete_int <= 1'b1;\n                        EI_int <= 1'b0;\n                        if (CRC_check_enable_int && ~status_int[5]) begin\n                            CCRCE_int <= 1'b1;\n                            EI_int <= 1'b1;\n                        end\n                        if (index_check_enable_int && (cmd_out_int[37:32] != cmd_in[37:32])) begin\n                            // CIE_int <= 1'b1; // Not defined in the spec\n                            EI_int <= 1'b1;\n                        end\n                        CC_int <= 1'b1;\n                        if (response_size_int != 0) begin\n                            RESP_1_REG_int <= cmd_in[31:0];\n                        end\n                    end\n                end\n            default:\n                go_idle_o_int <= 1'b0;\n                req_out_int <= 1'b0;\n                ack_out_int <= 1'b0;\n        endcase\n    end\nend\n\nassign go_idle_o = go_idle_o_int;\nassign req_out = req_out_int;\nassign ack_out = ack_out_int;\nassign cmd_out = cmd_out_int;\nassign settings = settings_int;\nassign RESP_1_REG = RESP_1_REG_int;\nassign ERR_INT_REG = ERR_INT_REG_int;\nassign NORMAL_INT_REG = NORMAL_INT_REG_int;\nassign STATUS_REG = STATUS_REG_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 13, "code": "// sd_cmd_master.v\n\n`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    input           CLK_PAD_IO,\n    input           RST_PAD_I,\n    input           New_CMD,\n    input           data_write,\n    input           data_read,\n    input   [31:0]  ARG_REG,\n    input   [13:0]  CMD_SET_REG,\n    input   [15:0]  TIMEOUT_REG,\n    output  [15:0]  STATUS_REG,\n    output  [31:0]  RESP_1_REG,\n    output  [4:0]   ERR_INT_REG,\n    output  [15:0]  NORMAL_INT_REG,\n    input           ERR_INT_RST,\n    input           NORMAL_INT_RST,\n    output  [15:0]  settings,\n    output          go_idle_o,\n    output  [39:0]  cmd_out,\n    output          req_out,\n    output          ack_out,\n    input           req_in,\n    input           ack_in,\n    input   [39:0]  cmd_in,\n    input   [7:0]   serial_status,\n    input           card_detect\n);\n\n// Internal signals\nreg [2:0] state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_in_int;\nreg req_in_int;\nreg [39:0] cmd_out_int;\nreg [15:0] settings_int;\nreg [31:0] resp_1_reg_int;\nreg [4:0] err_int_reg_int;\nreg [15:0] normal_int_reg_int;\nreg [15:0] status_reg_int;\nreg go_idle_o_int;\nreg req_out_int;\nreg ack_out_int;\nreg crc_check_enable;\nreg index_check_enable;\nreg complete;\nreg watchdog_cnt [7:0];\nreg cte;\nreg ei;\nreg cc;\nreg cie;\nreg ccrce;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else if (~card_detect) begin\n        if (debounce < 4'b1111) begin\n            debounce <= debounce + 1;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end\n    end else begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end\nend\n\n// Synchronization logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_in_int <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_in_int <= ack_in;\n        req_in_int <= req_in;\n    end\nend\n\n// Finite state machine\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE state\n    end else begin\n        case (state)\n            3'b001: // IDLE state\n                if (New_CMD) begin\n                    state <= 3'b010; // SETUP state\n                end\n            3'b010: // SETUP state\n                if (ack_in_int) begin\n                    state <= 3'b100; // EXECUTE state\n                end\n            3'b100: // EXECUTE state\n                if (complete) begin\n                    state <= 3'b001; // IDLE state\n                end\n            default:\n                state <= 3'b001; // IDLE state\n        endcase\n    end\nend\n\n// Output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    case (state)\n        3'b001: // IDLE state\n            begin\n                go_idle_o_int <= 1'b0;\n                req_out_int <= 1'b0;\n                ack_out_int <= 1'b0;\n                crc_check_enable <= 1'b0;\n                index_check_enable <= 1'b0;\n                complete <= 1'b0;\n                watchdog_cnt <= 8'b00000000;\n                cte <= 1'b0;\n                ei <= 1'b0;\n                cc <= 1'b0;\n                cie <= 1'b0;\n                ccrce <= 1'b0;\n            end\n        3'b010: // SETUP state\n            begin\n                cmd_out_int <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                settings_int <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], 7'b0000000};\n                normal_int_reg_int <= 16'b0000000000000000;\n                err_int_reg_int <= 5'b00000;\n                status_reg_int <= 16'b0000000000000000;\n                go_idle_o_int <= 1'b0;\n                req_out_int <= 1'b0;\n                ack_out_int <= 1'b0;\n                crc_check_enable <= CMD_SET_REG[3];\n                index_check_enable <= CMD_SET_REG[4];\n                complete <= 1'b0;\n                watchdog_cnt <= 8'b00000000;\n                cte <= 1'b0;\n                ei <= 1'b0;\n                cc <= 1'b0;\n                cie <= 1'b0;\n                ccrce <= 1'b0;\n            end\n        3'b100: // EXECUTE state\n            begin\n                if (watchdog_cnt > TIMEOUT_REG) begin\n                    cte <= 1'b1;\n                    ei <= 1'b1;\n                    go_idle_o_int <= 1'b1;\n                end\n                if (ack_in_int) begin\n                    req_out_int <= 1'b1;\n                end\n                if (req_in_int) begin\n                    ack_out_int <= 1'b1;\n                    if (serial_status[6]) begin\n                        complete <= 1'b1;\n                        if (crc_check_enable && ~serial_status[5]) begin\n                            ccrce <= 1'b1;\n                            ei <= 1'b1;\n                        end\n                        if (index_check_enable && (cmd_out_int[37:32] != cmd_in[37:32])) begin\n                            cie <= 1'b1;\n                            ei <= 1'b1;\n                        end\n                        cc <= 1'b1;\n                        resp_1_reg_int <= cmd_in[31:0];\n                    end\n                end\n            end\n        default:\n            begin\n                go_idle_o_int <= 1'b0;\n                req_out_int <= 1'b0;\n                ack_out_int <= 1'b0;\n                crc_check_enable <= 1'b0;\n                index_check_enable <= 1'b0;\n                complete <= 1'b0;\n                watchdog_cnt <= 8'b00000000;\n                cte <= 1'b0;\n                ei <= 1'b0;\n                cc <= 1'b0;\n                cie <= 1'b0;\n                ccrce <= 1'b0;\n            end\n    endcase\nend\n\n// Continuous assignments\nassign go_idle_o = go_idle_o_int;\nassign req_out = req_out_int;\nassign ack_out = ack_out_int;\nassign cmd_out = cmd_out_int;\nassign settings = settings_int;\nassign RESP_1_REG = resp_1_reg_int;\nassign ERR_INT_REG = err_int_reg_int;\nassign NORMAL_INT_REG = normal_int_reg_int;\nassign STATUS_REG = status_reg_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 14, "code": "// sd_cmd_master.v\n\n`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    // Input signals\n    input           CLK_PAD_IO,     // Clock input\n    input           RST_PAD_I,      // Asynchronous reset, active high\n    input           New_CMD,        // Signal indicating a new command is available\n    input           data_write,     // Indicates a block write command\n    input           data_read,      // Indicates a block read command\n    input   [31:0]  ARG_REG,        // Command argument register\n    input   [13:0]  CMD_SET_REG,    // Command settings register\n    input   [15:0]  TIMEOUT_REG,    // Timeout configuration register\n    input           req_in,         // Request input signal from serial interface\n    input           ack_in,         // Acknowledge input signal from serial interface\n    input   [39:0]  cmd_in,         // Command input from SD/MMC card\n    input   [7:0]   serial_status,  // Serial status input\n    input           card_detect,    // SD card presence detection signal\n    input           ERR_INT_RST,    // Error interrupt reset signal\n    input           NORMAL_INT_RST, // Normal interrupt reset signal\n\n    // Output signals\n    output  [15:0]  STATUS_REG,     // Status register\n    output  [31:0]  RESP_1_REG,     // Response register\n    output  [4:0]   ERR_INT_REG,    // Error interrupt register\n    output  [15:0]  NORMAL_INT_REG, // Normal interrupt register\n    output  [15:0]  settings,       // Command settings output\n    output          go_idle_o,      // Signal to reset the module to idle state\n    output  [39:0]  cmd_out,        // Command output to SD/MMC card\n    output          req_out,        // Request signal for service\n    output          ack_out         // Acknowledge signal for service completion\n);\n\n// Internal signals and registers\nreg [2:0] state; // Current state of the FSM\nreg [2:0] next_state; // Next state of the FSM\nreg [3:0] debounce; // Debounce counter for card detection\nreg card_present; // Flag indicating card presence\nreg ack_in_int; // Synchronized acknowledge input signal\nreg req_in_int; // Synchronized request input signal\nreg [39:0] cmd_out_reg; // Registered command output\nreg [15:0] settings_reg; // Registered command settings\nreg go_idle_o_reg; // Registered go_idle signal\nreg req_out_reg; // Registered request output signal\nreg ack_out_reg; // Registered acknowledge output signal\nreg complete; // Flag indicating command completion\nreg CRC_check_enable; // Flag enabling CRC checks\nreg index_check_enable; // Flag enabling index checks\nreg [31:0] RESP_1_REG_reg; // Registered response register\nreg [4:0] ERR_INT_REG_reg; // Registered error interrupt register\nreg [15:0] NORMAL_INT_REG_reg; // Registered normal interrupt register\nreg [15:0] STATUS_REG_reg; // Registered status register\nreg Watchdog_Cnt; // Watchdog counter\n\n// Debounce logic for card detection\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce < 4'b1111) begin\n                debounce <= debounce + 1'b1;\n            end\n            if (debounce == 4'b1111) begin\n                card_present <= 1'b1;\n            end\n        end else begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end\n    end\nend\n\n// Synchronization of acknowledge and request input signals\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_in_int <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_in_int <= ack_in;\n        req_in_int <= req_in;\n    end\nend\n\n// Finite state machine (FSM) logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE state\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        3'b001: // IDLE state\n            begin\n                if (New_CMD) begin\n                    next_state <= 3'b010; // SETUP state\n                end else begin\n                    next_state <= 3'b001; // IDLE state\n                end\n            end\n        3'b010: // SETUP state\n            begin\n                if (ack_in_int) begin\n                    next_state <= 3'b100; // EXECUTE state\n                end else begin\n                    next_state <= 3'b010; // SETUP state\n                end\n            end\n        3'b100: // EXECUTE state\n            begin\n                if (complete) begin\n                    next_state <= 3'b001; // IDLE state\n                end else begin\n                    next_state <= 3'b100; // EXECUTE state\n                end\n            end\n        default:\n            begin\n                next_state <= 3'b001; // IDLE state\n            end\n    endcase\nend\n\n// Output logic based on current state\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        go_idle_o_reg <= 1'b0;\n        req_out_reg <= 1'b0;\n        ack_out_reg <= 1'b0;\n        cmd_out_reg <= 40'b0;\n        settings_reg <= 16'b0;\n        complete <= 1'b0;\n        CRC_check_enable <= 1'b0;\n        index_check_enable <= 1'b0;\n        RESP_1_REG_reg <= 32'b0;\n        ERR_INT_REG_reg <= 5'b0;\n        NORMAL_INT_REG_reg <= 16'b0;\n        STATUS_REG_reg <= 16'b0;\n        Watchdog_Cnt <= 1'b0;\n    end else begin\n        case (state)\n            3'b001: // IDLE state\n                begin\n                    go_idle_o_reg <= 1'b0;\n                    req_out_reg <= 1'b0;\n                    ack_out_reg <= 1'b0;\n                    complete <= 1'b0;\n                end\n            3'b010: // SETUP state\n                begin\n                    // Compose cmd_out by combining command_setting_reg and arg_reg\n                    cmd_out_reg <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    // Set up the settings output vector\n                    settings_reg <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], 7'b0};\n                    // Reset NORMAL_INT_REG, ERR_INT_REG, and STATUS_REG\n                    NORMAL_INT_REG_reg <= 16'b0;\n                    ERR_INT_REG_reg <= 5'b0;\n                    STATUS_REG_reg <= 16'b0;\n                end\n            3'b100: // EXECUTE state\n                begin\n                    // Increment Watchdog_Cnt\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    // Check for watchdog timeout\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        // Assert CTE (Command Timeout Error) and EI (Error Interrupt)\n                        ERR_INT_REG_reg[0] <= 1'b1;\n                        ERR_INT_REG_reg[1] <= 1'b1;\n                        // Transition to IDLE state\n                        go_idle_o_reg <= 1'b1;\n                    end\n                    // Check for new serial_status\n                    if (req_in_int) begin\n                        // Update status with serial_status\n                        STATUS_REG_reg <= {serial_status, 8'b0};\n                        // Assert ack_out\n                        ack_out_reg <= 1'b1;\n                        // Check if dat_ava is set\n                        if (serial_status[6]) begin\n                            // Set complete to 1\n                            complete <= 1'b1;\n                            // Check for CRC errors\n                            if (CRC_check_enable && !serial_status[5]) begin\n                                // Assert CCRCE (CRC Error)\n                                ERR_INT_REG_reg[1] <= 1'b1;\n                            end\n                            // Check for index mismatch\n                            if (index_check_enable && (cmd_out_reg[37:32] != cmd_in[37:32])) begin\n                                // Assert CIE (Command Index Error)\n                                ERR_INT_REG_reg[2] <= 1'b1;\n                            end\n                            // Store response data in RESP_1_REG\n                            RESP_1_REG_reg <= cmd_in[31:0];\n                        end\n                    end\n                end\n            default:\n                begin\n                    go_idle_o_reg <= 1'b0;\n                    req_out_reg <= 1'b0;\n                    ack_out_reg <= 1'b0;\n                end\n        endcase\n    end\nend\n\n// Assign outputs\nassign go_idle_o = go_idle_o_reg;\nassign req_out = req_out_reg;\nassign ack_out = ack_out_reg;\nassign cmd_out = cmd_out_reg;\nassign settings = settings_reg;\nassign STATUS_REG = STATUS_REG_reg;\nassign RESP_1_REG = RESP_1_REG_reg;\nassign ERR_INT_REG = ERR_INT_REG_reg;\nassign NORMAL_INT_REG = NORMAL_INT_REG_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    input             CLK_PAD_IO,\n    input             RST_PAD_I,\n    input             New_CMD,\n    input             data_write,\n    input             data_read,\n    input      [31:0] ARG_REG,\n    input      [13:0] CMD_SET_REG,\n    input      [15:0] TIMEOUT_REG,\n    output     [15:0] STATUS_REG,\n    output     [31:0] RESP_1_REG,\n    output     [ 4:0] ERR_INT_REG,\n    output     [15:0] NORMAL_INT_REG,\n    input             ERR_INT_RST,\n    input             NORMAL_INT_RST,\n    output     [15:0] settings,\n    output             go_idle_o,\n    output     [39:0] cmd_out,\n    output             req_out,\n    output             ack_out,\n    input             req_in,\n    input             ack_in,\n    input      [39:0] cmd_in,\n    input       [7:0] serial_status,\n    input             card_detect\n);\n\n// Debounce Logic\nreg [3:0] debounce;\nreg       card_present;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce < 4'b1111) begin\n                debounce <= debounce + 1'b1;\n            end\n        end else begin\n            debounce <= 4'b0000;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end else begin\n            card_present <= 1'b0;\n        end\n    end\nend\n\n// Synchronization\nreg ack_q;\nreg ack_in_int;\nreg req_q;\nreg req_in_int;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// Finite State Machine (FSM)\nreg [2:0] state;\nreg [2:0] next_state;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        3'b001: // IDLE\n            if (New_CMD) begin\n                next_state = 3'b010; // SETUP\n            end else begin\n                next_state = 3'b001; // IDLE\n            end\n        3'b010: // SETUP\n            if (ack_in_int) begin\n                next_state = 3'b100; // EXECUTE\n            end else begin\n                next_state = 3'b010; // SETUP\n            end\n        3'b100: // EXECUTE\n            if (complete) begin\n                next_state = 3'b001; // IDLE\n            end else begin\n                next_state = 3'b100; // EXECUTE\n            end\n        default:\n            next_state = 3'b001; // IDLE\n    endcase\nend\n\n// FSM State operation\nreg CRC_check_enable;\nreg index_check_enable;\nreg complete;\nreg [31:0] RESP_1_REG_int;\nreg [4:0] ERR_INT_REG_int;\nreg [15:0] NORMAL_INT_REG_int;\nreg [15:0] settings_int;\nreg [39:0] cmd_out_int;\nreg Watchdog_Cnt;\n\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        CRC_check_enable <= 1'b0;\n        index_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG_int <= 32'b0;\n        ERR_INT_REG_int <= 5'b0;\n        NORMAL_INT_REG_int <= 16'b0;\n        settings_int <= 16'b0;\n        cmd_out_int <= 40'b0;\n        Watchdog_Cnt <= 16'b0;\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end\n            3'b010: // SETUP\n                NORMAL_INT_REG_int <= 16'b0;\n                ERR_INT_REG_int <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4];\n                CRC_check_enable <= CMD_SET_REG[3];\n                cmd_out_int <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                settings_int <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], 7'b0};\n                Watchdog_Cnt <= 16'b0;\n            3'b100: // EXECUTE\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    ERR_INT_REG_int[0] <= 1'b1; // CTE\n                    go_idle_o <= 1'b1;\n                end\n                if (ack_in_int) begin\n                    req_out <= 1'b1;\n                end\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                    if (status[6]) begin // dat_ava\n                        complete <= 1'b1;\n                        if (CRC_check_enable && !status[5]) begin // crc_valid\n                            ERR_INT_REG_int[1] <= 1'b1; // CCRCE\n                        end\n                        if (index_check_enable && (cmd_out_int[37:32] != cmd_in[37:32])) begin\n                            ERR_INT_REG_int[3] <= 1'b1; // CIE\n                        end\n                        NORMAL_INT_REG_int[0] <= 1'b1; // CC\n                        if (settings_int[6:0] != 0) begin\n                            RESP_1_REG_int <= cmd_in[31:0];\n                        end\n                    end\n                end\n        endcase\n    end\nend\n\nassign STATUS_REG = status;\nassign RESP_1_REG = RESP_1_REG_int;\nassign ERR_INT_REG = ERR_INT_REG_int;\nassign NORMAL_INT_REG = NORMAL_INT_REG_int;\nassign settings = settings_int;\nassign cmd_out = cmd_out_int;\nassign go_idle_o = go_idle_o;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 16, "code": "// sd_cmd_master module\nmodule sd_cmd_master(\n    // Input ports\n    input           CLK_PAD_IO,     // Clock input\n    input           RST_PAD_I,      // Asynchronous reset, active high\n    input           New_CMD,        // Signal indicating a new command is available\n    input           data_write,     // Indicates a block write command\n    input           data_read,      // Indicates a block read command\n    input   [31:0]  ARG_REG,        // Command argument register\n    input   [13:0]  CMD_SET_REG,    // Command settings register\n    input   [15:0]  TIMEOUT_REG,    // Timeout configuration register\n    input           req_in,         // Request input signal from serial interface\n    input           ack_in,         // Acknowledge input signal from serial interface\n    input   [39:0]  cmd_in,         // Command input from SD/MMC card\n    input   [7:0]   serial_status,  // Serial status input\n    input           card_detect,    // SD card presence detection signal\n    input           ERR_INT_RST,    // Error interrupt reset signal\n    input           NORMAL_INT_RST, // Normal interrupt reset signal\n\n    // Output ports\n    output  [15:0]  STATUS_REG,     // Status register\n    output  [31:0]  RESP_1_REG,     // Response register\n    output  [4:0]   ERR_INT_REG,    // Error interrupt register\n    output  [15:0]  NORMAL_INT_REG, // Normal interrupt register\n    output  [15:0]  settings,       // Command settings output\n    output          go_idle_o,      // Signal to reset the module to idle state\n    output  [39:0]  cmd_out,        // Command output to SD/MMC card\n    output          req_out,        // Request signal for service\n    output          ack_out         // Acknowledge signal for service completion\n);\n\n// Internal signals and registers\nreg [2:0] state;        // Current state of the FSM\nreg [2:0] next_state;   // Next state of the FSM\nreg [3:0] debounce;     // Debounce counter for card detection\nreg       card_present; // Flag indicating card presence\nreg       ack_in_int;   // Synchronized acknowledge input signal\nreg       req_in_int;   // Synchronized request input signal\nreg [39:0] cmd_out_reg; // Registered command output\nreg [15:0] settings_reg; // Registered command settings\nreg       req_out_reg;  // Registered request output\nreg       ack_out_reg;  // Registered acknowledge output\nreg       go_idle_o_reg; // Registered go idle output\nreg [15:0] STATUS_REG_reg; // Registered status register\nreg [31:0] RESP_1_REG_reg; // Registered response register\nreg [4:0]  ERR_INT_REG_reg; // Registered error interrupt register\nreg [15:0] NORMAL_INT_REG_reg; // Registered normal interrupt register\n\n// FSM state definitions\nparameter IDLE = 3'b001;\nparameter SETUP = 3'b010;\nparameter EXECUTE = 3'b100;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else if (!card_detect) begin\n        if (debounce < 4'b1111) begin\n            debounce <= debounce + 1;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end\n    end else begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end\nend\n\n// Synchronize request and acknowledge signals\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_in_int <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_in_int <= ack_in;\n        req_in_int <= req_in;\n    end\nend\n\n// FSM next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (New_CMD) begin\n                next_state <= SETUP;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        SETUP: begin\n            if (ack_in_int) begin\n                next_state <= EXECUTE;\n            end else begin\n                next_state <= SETUP;\n            end\n        end\n        EXECUTE: begin\n            if (complete) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= EXECUTE;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\n// FSM state register update\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM output logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            go_idle_o_reg <= 1'b0;\n            req_out_reg <= 1'b0;\n            ack_out_reg <= 1'b0;\n            STATUS_REG_reg <= 16'b0000;\n            RESP_1_REG_reg <= 32'b0000;\n            ERR_INT_REG_reg <= 5'b00000;\n            NORMAL_INT_REG_reg <= 16'b0000;\n        end\n        SETUP: begin\n            NORMAL_INT_REG_reg <= 16'b0000;\n            ERR_INT_REG_reg <= 5'b00000;\n            STATUS_REG_reg <= 16'b0000;\n            cmd_out_reg <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n            settings_reg <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n            Watchdog_Cnt <= 16'b0000;\n        end\n        EXECUTE: begin\n            Watchdog_Cnt <= Watchdog_Cnt + 1;\n            if (Watchdog_Cnt > TIMEOUT_REG) begin\n                ERR_INT_REG_reg[0] <= 1'b1;\n                go_idle_o_reg <= 1'b1;\n            end\n            if (ack_in_int) begin\n                req_out_reg <= 1'b1;\n            end\n            if (req_in_int) begin\n                status <= serial_status;\n                ack_out_reg <= 1'b1;\n                if (dat_ava) begin\n                    complete <= 1'b1;\n                    if (CRC_check_enable && ~crc_valid) begin\n                        ERR_INT_REG_reg[1] <= 1'b1;\n                    end\n                    if (index_check_enable && (cmd_out_reg[37:32] != cmd_in[37:32])) begin\n                        ERR_INT_REG_reg[2] <= 1'b1;\n                    end\n                    NORMAL_INT_REG_reg[0] <= 1'b1;\n                    if (response_size != 0) begin\n                        RESP_1_REG_reg <= cmd_in[31:0];\n                    end\n                end\n            end\n        end\n        default: begin\n            go_idle_o_reg <= 1'b0;\n            req_out_reg <= 1'b0;\n            ack_out_reg <= 1'b0;\n            STATUS_REG_reg <= 16'b0000;\n            RESP_1_REG_reg <= 32'b0000;\n            ERR_INT_REG_reg <= 5'b00000;\n            NORMAL_INT_REG_reg <= 16'b0000;\n        end\n    endcase\nend\n\n// Output assignments\nassign go_idle_o = go_idle_o_reg;\nassign req_out = req_out_reg;\nassign ack_out = ack_out_reg;\nassign STATUS_REG = STATUS_REG_reg;\nassign RESP_1_REG = RESP_1_REG_reg;\nassign ERR_INT_REG = ERR_INT_REG_reg;\nassign NORMAL_INT_REG = NORMAL_INT_REG_reg;\nassign cmd_out = cmd_out_reg;\nassign settings = settings_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 17, "code": "// sd_cmd_master.v\n\n`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    // IO Ports\n    input           CLK_PAD_IO,     // Clock input\n    input           RST_PAD_I,      // Asynchronous reset, active high\n    input           New_CMD,        // Signal indicating a new command is available\n    input           data_write,     // Indicates a block write command\n    input           data_read,      // Indicates a block read command\n    input   [31:0]  ARG_REG,        // Command argument register\n    input   [13:0]  CMD_SET_REG,    // Command settings register\n    input   [15:0]  TIMEOUT_REG,    // Timeout configuration register\n    output  [15:0]  STATUS_REG,     // Status register\n    output  [31:0]  RESP_1_REG,     // Response register\n    output  [4:0]   ERR_INT_REG,    // Error interrupt register\n    output  [15:0]  NORMAL_INT_REG, // Normal interrupt register\n    input           ERR_INT_RST,    // Error interrupt reset signal\n    input           NORMAL_INT_RST, // Normal interrupt reset signal\n    output  [15:0]  settings,       // Command settings output\n    output          go_idle_o,      // Signal to reset the module to idle state\n    output  [39:0]  cmd_out,        // Command output to SD/MMC card\n    output          req_out,        // Request signal for service\n    output          ack_out,        // Acknowledge signal for service completion\n    input           req_in,         // Request input signal from serial interface\n    input           ack_in,         // Acknowledge input signal from serial interface\n    input   [39:0]  cmd_in,         // Command input from SD/MMC card\n    input   [7:0]   serial_status,  // Serial status input\n    input           card_detect     // SD card presence detection signal\n);\n\n// Internal signals\nreg [2:0] state;         // Current state of the FSM\nreg [2:0] next_state;    // Next state of the FSM\nreg [3:0] debounce;      // Debounce counter for card detection\nreg       card_present;  // Flag indicating card presence\nreg       ack_in_int;    // Synchronized acknowledge input signal\nreg       req_in_int;    // Synchronized request input signal\nreg [31:0] status;       // Status register\nreg [39:0] cmd_out_int;  // Internal command output\nreg [15:0] settings_int; // Internal command settings\nreg       complete;      // Flag indicating command completion\nreg       CRC_check_enable; // Flag enabling CRC check\nreg       index_check_enable; // Flag enabling index check\nreg [15:0] Watchdog_Cnt; // Watchdog counter\nreg       CCRCE;         // CRC error flag\nreg       CIE;           // Command index error flag\nreg       EI;            // Error interrupt flag\nreg       CC;            // Command complete flag\n\n// FSM state definitions\nlocalparam IDLE = 3'b001;\nlocalparam SETUP = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else begin\n        if (!card_detect) begin\n            if (debounce < 4'b1111) begin\n                debounce <= debounce + 1;\n            end\n        end else begin\n            debounce <= 4'b0000;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end else begin\n            card_present <= 1'b0;\n        end\n    end\nend\n\n// Synchronization logic for ack_in and req_in\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_in_int <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        ack_in_int <= ack_in;\n        req_in_int <= req_in;\n    end\nend\n\n// FSM next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (New_CMD) begin\n                next_state <= SETUP;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        SETUP: begin\n            if (ack_in_int) begin\n                next_state <= EXECUTE;\n            end else begin\n                next_state <= SETUP;\n            end\n        end\n        EXECUTE: begin\n            if (complete) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= EXECUTE;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\n// FSM state register update\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM output logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            go_idle_o <= 1'b0;\n            req_out <= 1'b0;\n            ack_out <= 1'b0;\n            CICMD <= 1'b0;\n            if (req_in_int) begin\n                status <= serial_status;\n                ack_out <= 1'b1;\n            end\n        end\n        SETUP: begin\n            NORMAL_INT_REG <= 16'b0;\n            ERR_INT_REG <= 5'b0;\n            index_check_enable <= CMD_SET_REG[4];\n            CRC_check_enable <= CMD_SET_REG[3];\n            cmd_out_int <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n            settings_int <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], 7'b0};\n            Watchdog_Cnt <= 16'b0;\n        end\n        EXECUTE: begin\n            Watchdog_Cnt <= Watchdog_Cnt + 1;\n            if (Watchdog_Cnt > TIMEOUT_REG) begin\n                CTE <= 1'b1;\n                EI <= 1'b1;\n                go_idle_o <= 1'b1;\n            end\n            if (ack_in_int) begin\n                req_out <= 1'b1;\n            end\n            if (req_in_int) begin\n                status <= serial_status;\n                ack_out <= 1'b1;\n                if (status[6]) begin\n                    complete <= 1'b1;\n                    EI <= 1'b0;\n                    if (CRC_check_enable && !status[5]) begin\n                        CCRCE <= 1'b1;\n                        EI <= 1'b1;\n                    end\n                    if (index_check_enable && (cmd_out_int[37:32] != cmd_in[37:32])) begin\n                        CIE <= 1'b1;\n                        EI <= 1'b1;\n                    end\n                    CC <= 1'b1;\n                    if (settings_int[6:0] != 0) begin\n                        RESP_1_REG <= cmd_in[31:0];\n                    end\n                end\n            end\n        end\n        default: begin\n            // No action\n        end\n    endcase\nend\n\n// Output assignments\nassign STATUS_REG = status;\nassign RESP_1_REG = RESP_1_REG;\nassign ERR_INT_REG = {CCRCE, CIE, EI, 2'b0};\nassign NORMAL_INT_REG = {CC, 15'b0};\nassign settings = settings_int;\nassign cmd_out = cmd_out_int;\nassign req_out = req_out;\nassign ack_out = ack_out;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 18, "code": "// sd_cmd_master.v\n\n`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    input           CLK_PAD_IO,\n    input           RST_PAD_I,\n    input           New_CMD,\n    input           data_write,\n    input           data_read,\n    input   [31:0]  ARG_REG,\n    input   [13:0]  CMD_SET_REG,\n    input   [15:0]  TIMEOUT_REG,\n    output  [15:0]  STATUS_REG,\n    output  [31:0]  RESP_1_REG,\n    output  [4:0]   ERR_INT_REG,\n    output  [15:0]  NORMAL_INT_REG,\n    input           ERR_INT_RST,\n    input           NORMAL_INT_RST,\n    output  [15:0]  settings,\n    output          go_idle_o,\n    output  [39:0]  cmd_out,\n    output          req_out,\n    output          ack_out,\n    input           req_in,\n    input           ack_in,\n    input   [39:0]  cmd_in,\n    input   [7:0]   serial_status,\n    input           card_detect\n);\n\n// Internal signals and registers\nreg [2:0] state; // IDLE, SETUP, EXECUTE\nreg [3:0] debounce;\nreg card_present;\nreg [15:0] Watchdog_Cnt;\nreg CICMD;\nreg complete;\nreg CRC_check_enable;\nreg index_check_enable;\nreg [39:0] cmd_out_int;\nreg [15:0] settings_int;\nreg [7:0] response_size;\nreg req_out_int;\nreg ack_out_int;\nreg [4:0] ERR_INT_REG_int;\nreg [15:0] NORMAL_INT_REG_int;\nreg [31:0] RESP_1_REG_int;\nreg [15:0] STATUS_REG_int;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else if (!card_detect) begin\n        if (debounce < 4'b1111) begin\n            debounce <= debounce + 1;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end\n    end else begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end\nend\n\n// Synchronization of req_in and ack_in\nreg req_q;\nreg ack_q;\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_q <= 1'b0;\n        ack_q <= 1'b0;\n    end else begin\n        req_q <= req_in;\n        ack_q <= ack_in;\n    end\nend\nreg req_in_int;\nreg ack_in_int;\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_in_int <= 1'b0;\n        ack_in_int <= 1'b0;\n    end else begin\n        req_in_int <= req_q;\n        ack_in_int <= ack_q;\n    end\nend\n\n// Finite state machine\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                if (New_CMD) begin\n                    state <= 3'b010; // SETUP\n                end\n            3'b010: // SETUP\n                if (ack_in_int) begin\n                    state <= 3'b100; // EXECUTE\n                end\n            3'b100: // EXECUTE\n                if (complete) begin\n                    state <= 3'b001; // IDLE\n                end\n            default:\n                state <= 3'b001; // IDLE\n        endcase\n    end\nend\n\n// State operations\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs\n        go_idle_o <= 1'b0;\n        req_out <= 1'b0;\n        ack_out <= 1'b0;\n        CICMD <= 1'b0;\n        complete <= 1'b0;\n        CRC_check_enable <= 1'b0;\n        index_check_enable <= 1'b0;\n        cmd_out_int <= 40'b0;\n        settings_int <= 16'b0;\n        response_size <= 8'b0;\n        req_out_int <= 1'b0;\n        ack_out_int <= 1'b0;\n        ERR_INT_REG_int <= 5'b0;\n        NORMAL_INT_REG_int <= 16'b0;\n        RESP_1_REG_int <= 32'b0;\n        STATUS_REG_int <= 16'b0;\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                // Reset outputs\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                CICMD <= 1'b0;\n                // Check for new command\n                if (req_in_int) begin\n                    // Update status\n                    STATUS_REG_int <= serial_status;\n                    // Acknowledge\n                    ack_out_int <= 1'b1;\n                end\n            3'b010: // SETUP\n                // Clear interrupt registers\n                NORMAL_INT_REG_int <= 16'b0;\n                ERR_INT_REG_int <= 5'b0;\n                // Enable checks\n                index_check_enable <= CMD_SET_REG[4];\n                CRC_check_enable <= CMD_SET_REG[3];\n                // Determine response size\n                if (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) begin\n                    response_size <= 8'b0101000; // small_rsp\n                end else if (CMD_SET_REG[1:0] == 2'b01) begin\n                    response_size <= 8'b1111111; // big_rsp\n                end else begin\n                    response_size <= 8'b0;\n                end\n                // Assemble cmd_out and settings\n                cmd_out_int[39:38] <= 2'b01;\n                cmd_out_int[37:32] <= CMD_SET_REG[13:8];\n                cmd_out_int[31:0] <= ARG_REG;\n                settings_int[14:13] <= CMD_SET_REG[7:6];\n                settings_int[12] <= data_read;\n                settings_int[11] <= data_write;\n                settings_int[10:8] <= 3'b111;\n                settings_int[7] <= CRC_check_enable;\n                settings_int[6:0] <= response_size;\n                // Reset watchdog\n                Watchdog_Cnt <= 16'b0;\n            3'b100: // EXECUTE\n                // Increment watchdog\n                Watchdog_Cnt <= Watchdog_Cnt + 1;\n                // Check watchdog timeout\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    // Set error flags\n                    ERR_INT_REG_int[2] <= 1'b1; // CTE\n                    ERR_INT_REG_int[0] <= 1'b1; // EI\n                    // Transition to IDLE\n                    go_idle_o <= 1'b1;\n                end\n                // Control req_out and ack_out\n                if (ack_in_int) begin\n                    req_out_int <= 1'b1;\n                end\n                if (req_in_int) begin\n                    // Update status\n                    STATUS_REG_int <= serial_status;\n                    // Acknowledge\n                    ack_out_int <= 1'b1;\n                    // Check for command completion\n                    if (serial_status[6]) begin\n                        complete <= 1'b1;\n                        // Check CRC and index\n                        if (CRC_check_enable && !serial_status[5]) begin\n                            ERR_INT_REG_int[1] <= 1'b1; // CCRCE\n                            ERR_INT_REG_int[0] <= 1'b1; // EI\n                        end\n                        if (index_check_enable && (cmd_out_int[37:32] != cmd_in[37:32])) begin\n                            ERR_INT_REG_int[3] <= 1'b1; // CIE\n                            ERR_INT_REG_int[0] <= 1'b1; // EI\n                        end\n                        // Store response data\n                        if (response_size != 0) begin\n                            RESP_1_REG_int <= cmd_in[31:0];\n                        end\n                    end\n                end\n            default:\n                // Reset outputs\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                CICMD <= 1'b0;\n        endcase\n    end\nend\n\n// Output assignments\nassign go_idle_o = go_idle_o;\nassign req_out = req_out_int;\nassign ack_out = ack_out_int;\nassign cmd_out = cmd_out_int;\nassign settings = settings_int;\nassign STATUS_REG = STATUS_REG_int;\nassign RESP_1_REG = RESP_1_REG_int;\nassign ERR_INT_REG = ERR_INT_REG_int;\nassign NORMAL_INT_REG = NORMAL_INT_REG_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    input           CLK_PAD_IO,\n    input           RST_PAD_I,\n    input           New_CMD,\n    input           data_write,\n    input           data_read,\n    input   [31:0]  ARG_REG,\n    input   [13:0]  CMD_SET_REG,\n    input   [15:0]  TIMEOUT_REG,\n    output  [15:0]  STATUS_REG,\n    output  [31:0]  RESP_1_REG,\n    output  [4:0]   ERR_INT_REG,\n    output  [15:0]  NORMAL_INT_REG,\n    input           ERR_INT_RST,\n    input           NORMAL_INT_RST,\n    output  [15:0]  settings,\n    output          go_idle_o,\n    output  [39:0]  cmd_out,\n    output          req_out,\n    output          ack_out,\n    input           req_in,\n    input           ack_in,\n    input   [39:0]  cmd_in,\n    input   [7:0]   serial_status,\n    input           card_detect\n);\n\nreg [2:0] state;\nreg [2:0] next_state;\nreg [3:0] debounce;\nreg card_present;\nreg ack_in_int;\nreg req_in_int;\n\n// Debounce Logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else begin\n        if (~card_detect) begin\n            if (debounce != 4'b1111) begin\n                debounce <= debounce + 1'b1;\n            end\n        end else begin\n            debounce <= 4'b0000;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end else begin\n            card_present <= 1'b0;\n        end\n    end\nend\n\n// Synchronize req_in and ack_in signals\nreg ack_q;\nreg req_q;\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        req_q <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        req_q <= req_in;\n    end\nend\nassign ack_in_int = ack_q;\nassign req_in_int = req_q;\n\n// Finite State Machine\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        3'b001: begin // IDLE\n            if (New_CMD) begin\n                next_state <= 3'b010; // SETUP\n            end else begin\n                next_state <= 3'b001; // IDLE\n            end\n        end\n        3'b010: begin // SETUP\n            if (ack_in_int) begin\n                next_state <= 3'b100; // EXECUTE\n            end else begin\n                next_state <= 3'b010; // SETUP\n            end\n        end\n        3'b100: begin // EXECUTE\n            if (/* complete condition */) begin\n                next_state <= 3'b001; // IDLE\n            end else begin\n                next_state <= 3'b100; // EXECUTE\n            end\n        end\n        default: begin\n            next_state <= 3'b001; // IDLE\n        end\n    endcase\nend\n\n// State Operations\nreg CRC_check_enable;\nreg index_check_enable;\nreg [39:0] cmd_out_reg;\nreg [15:0] settings_reg;\nreg [7:0] response_size;\nreg req_out_reg;\nreg ack_out_reg;\nreg Watchdog_Cnt;\nreg CCRCE;\nreg EI;\nreg CC;\nreg go_idle_o_reg;\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        CRC_check_enable <= 1'b0;\n        index_check_enable <= 1'b0;\n        cmd_out_reg <= 40'b0;\n        settings_reg <= 16'b0;\n        response_size <= 8'b0;\n        req_out_reg <= 1'b0;\n        ack_out_reg <= 1'b0;\n        Watchdog_Cnt <= 8'b0;\n        CCRCE <= 1'b0;\n        EI <= 1'b0;\n        CC <= 1'b0;\n        go_idle_o_reg <= 1'b0;\n    end else begin\n        case (state)\n            3'b001: begin // IDLE\n                go_idle_o_reg <= 1'b0;\n                req_out_reg <= 1'b0;\n                ack_out_reg <= 1'b0;\n                if (req_in_int) begin\n                    // Update status and acknowledge\n                end\n            end\n            3'b010: begin // SETUP\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4];\n                CRC_check_enable <= CMD_SET_REG[3];\n                cmd_out_reg <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                settings_reg <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                Watchdog_Cnt <= 8'b0;\n            end\n            3'b100: begin // EXECUTE\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    CCRCE <= 1'b1;\n                    EI <= 1'b1;\n                    go_idle_o_reg <= 1'b1;\n                end\n                if (ack_in_int) begin\n                    req_out_reg <= 1'b1;\n                end\n                if (req_in_int) begin\n                    // Update status and acknowledge\n                    if (/* dat_ava condition */) begin\n                        CC <= 1'b1;\n                        if (CRC_check_enable && ~crc_valid) begin\n                            CCRCE <= 1'b1;\n                            EI <= 1'b1;\n                        end\n                        if (index_check_enable && (cmd_out_reg[37:32] != cmd_in[37:32])) begin\n                            // Index mismatch\n                        end\n                        if (response_size != 0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            end\n        endcase\n    end\nend\n\nassign go_idle_o = go_idle_o_reg;\nassign req_out = req_out_reg;\nassign ack_out = ack_out_reg;\nassign cmd_out = cmd_out_reg;\nassign settings = settings_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 20, "code": "// sd_cmd_master.v\n\n// Import necessary definitions\n`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    // Inputs\n    input               CLK_PAD_IO,\n    input               RST_PAD_I,\n    input               New_CMD,\n    input               data_write,\n    input               data_read,\n    input      [31:0]   ARG_REG,\n    input      [13:0]   CMD_SET_REG,\n    input      [15:0]   TIMEOUT_REG,\n    input               req_in,\n    input               ack_in,\n    input      [39:0]   cmd_in,\n    input       [7:0]   serial_status,\n    input               card_detect,\n    input               ERR_INT_RST,\n    input               NORMAL_INT_RST,\n\n    // Outputs\n    output     [15:0]   STATUS_REG,\n    output     [31:0]   RESP_1_REG,\n    output      [4:0]   ERR_INT_REG,\n    output     [15:0]   NORMAL_INT_REG,\n    output     [15:0]   settings,\n    output              go_idle_o,\n    output     [39:0]   cmd_out,\n    output              req_out,\n    output              ack_out\n);\n\n// Internal signals\nreg [2:0] state; // IDLE, SETUP, EXECUTE\nreg [3:0] debounce; // Debounce counter\nreg       card_present; // Card presence flag\nreg       ack_in_int; // Synchronized ack_in signal\nreg       req_in_int; // Synchronized req_in signal\nreg [39:0] cmd_out_int; // Internal command output\nreg [15:0] settings_int; // Internal settings output\nreg       complete; // Command completion flag\nreg       CRC_check_enable; // CRC check enable flag\nreg       index_check_enable; // Index check enable flag\nreg [7:0] response_size; // Response size\nreg [31:0] RESP_1_REG_int; // Internal response register\nreg [4:0] ERR_INT_REG_int; // Internal error interrupt register\nreg [15:0] NORMAL_INT_REG_int; // Internal normal interrupt register\nreg       CIE; // Command index error flag\nreg       CCRCE; // CRC error flag\nreg       CTE; // Command timeout error flag\nreg       EI; // Error interrupt flag\nreg       CC; // Command complete flag\nreg       go_idle_o_int; // Internal go_idle_o signal\nreg       req_out_int; // Internal req_out signal\nreg       ack_out_int; // Internal ack_out signal\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end else if (!card_detect) begin\n        if (debounce < 4'b1111) begin\n            debounce <= debounce + 1;\n        end\n        if (debounce == 4'b1111) begin\n            card_present <= 1'b1;\n        end\n    end else begin\n        debounce <= 4'b0000;\n        card_present <= 1'b0;\n    end\nend\n\n// Synchronize req_in and ack_in signals\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_in_int <= 1'b0;\n        ack_in_int <= 1'b0;\n    end else begin\n        req_in_int <= req_in;\n        ack_in_int <= ack_in;\n    end\nend\n\n// Finite state machine\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        state <= 3'b001; // IDLE\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                if (New_CMD) begin\n                    state <= 3'b010; // SETUP\n                end\n            3'b010: // SETUP\n                if (ack_in_int) begin\n                    state <= 3'b100; // EXECUTE\n                end\n            3'b100: // EXECUTE\n                if (complete) begin\n                    state <= 3'b001; // IDLE\n                end\n            default:\n                state <= 3'b001; // IDLE\n        endcase\n    end\nend\n\n// Output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs\n        STATUS_REG <= 16'b0000;\n        RESP_1_REG <= 32'b0000;\n        ERR_INT_REG <= 5'b00000;\n        NORMAL_INT_REG <= 16'b0000;\n        settings <= 16'b0000;\n        go_idle_o <= 1'b0;\n        cmd_out <= 40'b0000;\n        req_out <= 1'b0;\n        ack_out <= 1'b0;\n    end else begin\n        case (state)\n            3'b001: // IDLE\n                // Reset outputs\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                // Check for new command\n                if (New_CMD) begin\n                    // Transition to SETUP state\n                    state <= 3'b010;\n                end\n            3'b010: // SETUP\n                // Configure command output and settings\n                cmd_out_int <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                settings_int <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                // Transition to EXECUTE state\n                if (ack_in_int) begin\n                    state <= 3'b100;\n                end\n            3'b100: // EXECUTE\n                // Check for command completion\n                if (complete) begin\n                    // Transition to IDLE state\n                    state <= 3'b001;\n                end\n                // Check for errors\n                if (CTE || CCRCE || CIE) begin\n                    // Set error flags\n                    ERR_INT_REG_int <= {CTE, CCRCE, CIE, 2'b00};\n                    EI <= 1'b1;\n                end\n                // Check for command index mismatch\n                if (index_check_enable && (cmd_out_int[37:32] != cmd_in[37:32])) begin\n                    // Set command index error flag\n                    CIE <= 1'b1;\n                    EI <= 1'b1;\n                end\n                // Check for CRC error\n                if (CRC_check_enable && !crc_valid) begin\n                    // Set CRC error flag\n                    CCRCE <= 1'b1;\n                    EI <= 1'b1;\n                end\n                // Update response register\n                if (response_size != 0) begin\n                    RESP_1_REG_int <= cmd_in[31:0];\n                end\n        endcase\n    end\nend\n\n// Assign outputs\nassign STATUS_REG = STATUS_REG;\nassign RESP_1_REG = RESP_1_REG_int;\nassign ERR_INT_REG = ERR_INT_REG_int;\nassign NORMAL_INT_REG = NORMAL_INT_REG_int;\nassign settings = settings_int;\nassign go_idle_o = go_idle_o_int;\nassign cmd_out = cmd_out_int;\nassign req_out = req_out_int;\nassign ack_out = ack_out_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 1, "code": "// sd_cmd_serial_host module\nmodule sd_cmd_serial_host(\n    // Input ports\n    input               SD_CLK_IN,\n    input               RST_IN,\n    input      [15:0]   SETTING_IN,\n    input      [39:0]   CMD_IN,\n    input               REQ_IN,\n    input               ACK_IN,\n    input               cmd_dat_i,\n\n    // Output ports\n    output     [39:0]   CMD_OUT,\n    output              ACK_OUT,\n    output              REQ_OUT,\n    output     [7:0]    STATUS,\n    output              cmd_oe_o,\n    output              cmd_out_o,\n    output     [1:0]    st_dat_t\n);\n\n// Internal signals and registers\nreg   [9:0]  state;\nreg   [9:0]  next_state;\nreg   [7:0]  Response_Size;\nreg   [2:0]  Delay_Cycler;\nreg           Write_Read;\nreg           Write_Only;\nreg   [39:0]  In_Buff;\nreg   [39:0]  Out_Buff;\nreg           block_write;\nreg           block_read;\nreg   [1:0]   word_select;\nreg           FSM_ACK;\nreg           DECODER_ACK;\nreg           q;\nreg           Req_internal_in;\nreg           q1;\nreg           Ack_internal_in;\nreg           CRC_RST;\nreg           CRC_Enable;\nreg   [6:0]   CRC_IN;\nwire  [6:0]   CRC_VAL;\nreg           CRC_OUT;\nreg           Crc_Buffering;\nreg           CRC_Valid;\nreg   [7:0]   Cmd_Cnt;\nreg   [2:0]   Delay_Cnt;\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ block\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC block\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC block\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER block\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        DECODER_ACK <= 0;\n        Write_Read <= SETTING_IN[11];\n        Write_Only <= SETTING_IN[12];\n        In_Buff <= CMD_IN;\n        block_write <= SETTING_IN[13];\n        block_read <= SETTING_IN[14];\n        word_select <= SETTING_IN[15:14];\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC Buffering and Bit Transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC Buffering and Bit Transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 16'b0000_0000_0000_0101;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // Response Reception\n                if (Cmd_Cnt < Response_Size) begin\n                    // Capture incoming data bits into Out_Buff\n                    Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                    CRC_IN <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    // Assign CRC_IN from cmd_dat_i\n                    CRC_IN <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    // Validate CRC\n                    if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    // Update st_dat_t based on block_read and block_write flags\n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                CMD_OUT <= Out_Buff;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    input               SD_CLK_IN,\n    input               RST_IN,\n    input  [15:0]       SETTING_IN,\n    input  [39:0]       CMD_IN,\n    input               REQ_IN,\n    input               ACK_IN,\n    input               cmd_dat_i,\n    output [39:0]       CMD_OUT,\n    output              ACK_OUT,\n    output              REQ_OUT,\n    output [7:0]        STATUS,\n    output              cmd_oe_o,\n    output              cmd_out_o,\n    output [1:0]        st_dat_t\n);\n\n// Internal signals and registers\nreg [9:0] state, next_state;\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff, Out_Buff;\nreg Write_Read, Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST, CRC_Enable;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_OUT;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg block_write, block_read;\nreg [1:0] word_select;\nreg FSM_ACK, DECODER_ACK;\nreg q, Req_internal_in;\nreg q1, Ack_internal_in;\nreg [7:0] CRC_Valid;\nreg Crc_Buffering;\n\n// FSM_COMBO logic\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY)\n                next_state = IDLE;\n            else\n                next_state = INIT;\n        end\n        IDLE: begin\n            if (Write_Read)\n                next_state = WRITE_WR;\n            else if (Write_Only)\n                next_state = WRITE_WO;\n            else\n                next_state = IDLE;\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1)\n                next_state = DLY_WR;\n            else\n                next_state = WRITE_WR;\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1)\n                next_state = DLY_WO;\n            else\n                next_state = WRITE_WO;\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i)\n                next_state = READ_WR;\n            else\n                next_state = DLY_WR;\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler)\n                next_state = ACK_WO;\n            else\n                next_state = DLY_WO;\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD)\n                next_state = DLY_READ;\n            else\n                next_state = READ_WR;\n        end\n        DLY_READ: begin\n            if (Ack_internal_in)\n                next_state = ACK_WR;\n            else\n                next_state = DLY_READ;\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        DECODER_ACK <= 0;\n        Write_Read <= SETTING_IN[11];\n        Write_Only <= SETTING_IN[12];\n        In_Buff <= CMD_IN;\n        block_write <= SETTING_IN[13];\n        block_read <= SETTING_IN[14];\n        word_select <= SETTING_IN[15:14];\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        // Transmit command bits and manage CRC output\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        // Transmit CRC bits and update st_dat_t\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Cmd_Cnt <= 1;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            READ_WR: begin\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 16'b0000_0000_0000_0101;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Cmd_Cnt < Response_Size) begin\n                    // Capture incoming data bits\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    // Validate CRC\n                    if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                    end\n                    // Update st_dat_t\n                    st_dat_t <= {block_read, block_write};\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// sd_crc_7 module instantiation\nsd_crc_7 crc_module(\n    .BITVAL(cmd_dat_i),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(RST_IN),\n    .CRC(CRC_VAL)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    // Input Ports\n    input  wire            SD_CLK_IN,\n    input  wire            RST_IN,\n    input  wire [15:0]     SETTING_IN,\n    input  wire [39:0]     CMD_IN,\n    input  wire            REQ_IN,\n    input  wire            ACK_IN,\n    input  wire            cmd_dat_i,\n\n    // Output Ports\n    output wire [39:0]     CMD_OUT,\n    output wire            ACK_OUT,\n    output wire            REQ_OUT,\n    output wire [7:0]      STATUS,\n    output wire            cmd_oe_o,\n    output wire            cmd_out_o,\n    output wire [1:0]      st_dat_t\n);\n\n// Internal Constants and Parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// Internal Signals\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg Write_Read;\nreg Write_Only;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\nreg [6:0] CRC_IN;\nreg [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_RST;\nreg Crc_Buffering;\nreg CRC_Valid;\n\n// FSM_COMBO Logic\nalways @(*) begin\n    case(state)\n        INIT: begin\n            if(Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if(Write_Read) begin\n                next_state = WRITE_WR;\n            end else if(Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if(Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if(Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if(Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if(Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if(Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if(Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ Logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if(RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC Logic\nreg q;\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if(RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC Logic\nreg q1;\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if(RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER Logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if(RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if(Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        Write_Read <= SETTING_IN[11];\n        Write_Only <= SETTING_IN[12];\n        In_Buff <= CMD_IN;\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        DECODER_ACK <= 1;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 0;\n    end\nend\n\n// FSM_OUT Logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if(RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case(state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if(Cmd_Cnt == 0) begin\n                    STATUS <= 8'b0000_0001;\n                    REQ_OUT <= 1;\n                end else if(Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if(Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if(Cmd_Cnt > 8) begin\n                        // Transmit command bits and manage CRC output\n                    end else if(Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        // Transmit CRC bits and update st_dat_t\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if(Cmd_Cnt == 0) begin\n                    STATUS <= 8'b0010;\n                    REQ_OUT <= 1;\n                end else if(Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if(Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                end\n            end\n            DLY_WR: begin\n                if(Delay_Cnt == 0) begin\n                    STATUS <= 8'b0011;\n                    REQ_OUT <= 1;\n                end else if(Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Cmd_Cnt <= 1;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                if(Delay_Cnt == 0) begin\n                    STATUS <= 8'b0100;\n                    REQ_OUT <= 1;\n                end else if(Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Cmd_Cnt <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if(Cmd_Cnt == 1) begin\n                    STATUS <= 8'b0101;\n                    REQ_OUT <= 1;\n                end else if(Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if(Cmd_Cnt < Response_Size) begin\n                    // Capture incoming data bits into Out_Buff\n                    CRC_IN <= cmd_dat_i;\n                end else if((Cmd_Cnt - Response_Size) <= 6) begin\n                    // Assign CRC_IN from cmd_dat_i\n                    CRC_Enable <= 0;\n                end else begin\n                    // Validate CRC\n                    if(CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                    end\n                    CRC_Enable <= 0;\n                    // Update st_dat_t based on block_read and block_write flags\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                if(Delay_Cnt == 0) begin\n                    STATUS <= 8'b0110;\n                    REQ_OUT <= 1;\n                end else if(Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Cmd_Cnt <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                CMD_OUT <= Out_Buff;\n                Crc_Buffering <= 0;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 4, "code": "// sd_defines.v\n`define BIG_ENDIAN\n`define LITTLE_ENDIAN\n`define SIM\n`define SYN\n`define SDC_IRQ_ENABLE\n`define ACTEL\n`define BD_WIDTH 8\n`define BD_SIZE 255\n`define RAM_MEM_WIDTH_16\n`define RAM_MEM_WIDTH 16\n`define RESEND_MAX_CNT 10\n`define MEM_OFFSET 2\n`define RESET_CLK_DIV 10\n`define SD_CLK_BUS_CLK\n`define SD_CLK_SEP\n`define SD_CLK_STATIC\n`define SD_CLK_DYNAMIC\n`define BLOCK_SIZE 512\n`define SD_BUS_WIDTH_4\n`define SD_BUS_W 4\n`define FIFO_RX_MEM_DEPTH 1024\n`define FIFO_RX_MEM_ADR_SIZE 11\n`define FIFO_TX_MEM_DEPTH 1024\n`define FIFO_TX_MEM_ADR_SIZE 11\n\n// sd_cmd_serial_host.v\nmodule sd_cmd_serial_host(\n    input  wire        SD_CLK_IN,\n    input  wire        RST_IN,\n    input  wire [15:0] SETTING_IN,\n    input  wire [39:0] CMD_IN,\n    input  wire        REQ_IN,\n    input  wire        ACK_IN,\n    input  wire        cmd_dat_i,\n    output wire [39:0] CMD_OUT,\n    output wire        ACK_OUT,\n    output wire        REQ_OUT,\n    output wire [7:0]  STATUS,\n    output wire        cmd_oe_o,\n    output wire        cmd_out_o,\n    output wire [1:0]  st_dat_t\n);\n\n// Internal signals and registers\nreg [9:0] state;\nreg [9:0] next_state;\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [7:0] In_Buff;\nreg [7:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg CRC_Check_On;\nreg [6:0] CRC_IN;\nreg [6:0] CRC_VAL;\nreg CRC_Enable;\nreg CRC_RST;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// FSM_COMBO\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= `INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= `SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= `SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= `NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + `EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        CRC_Check_On <= SETTING_IN[7];\n        Delay_Cycler <= SETTING_IN[10:8];\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        In_Buff <= CMD_IN;\n        if (SETTING_IN[6:0] > 0) begin\n            Write_Read <= 1;\n            Write_Only <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 1;\n        end\n        DECODER_ACK <= 0;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        CMD_OUT <= In_Buff;\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        CMD_OUT <= CRC_OUT;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff;\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    CMD_OUT <= In_Buff;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff;\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 16'b0000_0000_0000_0101;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff <= {Out_Buff[38:0], cmd_dat_i};\n                    CRC_IN <= cmd_dat_i;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                    end\n                    CRC_Enable <= 0;\n                    st_dat_t <= {block_read, block_write};\n                end\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                CMD_OUT <= Out_Buff;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 5, "code": "````include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    // Input Ports\n    input               SD_CLK_IN,\n    input               RST_IN,\n    input  [15:0]       SETTING_IN,\n    input  [39:0]       CMD_IN,\n    input               REQ_IN,\n    input               ACK_IN,\n    input               cmd_dat_i,\n\n    // Output Ports\n    output [39:0]       CMD_OUT,\n    output              ACK_OUT,\n    output              REQ_OUT,\n    output [7:0]        STATUS,\n    output              cmd_oe_o,\n    output              cmd_out_o,\n    output [1:0]        st_dat_t\n);\n\n// Internal Constants and Parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// Internal Signals\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nreg CRC_Enable;\nreg CRC_OUT;\nreg [6:0] CRC_VAL;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// FSM_COMBO\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        CRC_Check_On <= SETTING_IN[7];\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        In_Buff <= CMD_IN;\n        if (SETTING_IN[6:0] > 0) begin\n            Write_Read <= 1;\n            Write_Only <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 1;\n        end\n        DECODER_ACK <= 0;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 8'b0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        // Transmit command bits and CRC\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        // Transmit CRC bits and update st_dat_t\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 8'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and CRC\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'b0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 8'b0101;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Cmd_Cnt < Response_Size) begin\n                    // Capture incoming data bits\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    // Assign CRC_IN\n                    CRC_Enable <= 0;\n                end else begin\n                    // Validate CRC\n                    if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                    end\n                    CRC_Enable <= 0;\n                    // Update st_dat_t\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'b0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                CMD_OUT <= Out_Buff;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 6, "code": "// sd_cmd_serial_host module\nmodule sd_cmd_serial_host(\n    input  wire        SD_CLK_IN,\n    input  wire        RST_IN,\n    input  wire [15:0] SETTING_IN,\n    input  wire [39:0] CMD_IN,\n    input  wire        REQ_IN,\n    input  wire        ACK_IN,\n    input  wire        cmd_dat_i,\n    output wire [39:0] CMD_OUT,\n    output wire        ACK_OUT,\n    output wire        REQ_OUT,\n    output wire [7:0]  STATUS,\n    output wire        cmd_oe_o,\n    output wire        cmd_out_o,\n    output wire [1:0]  st_dat_t\n);\n\n// Internal signals and registers\nreg [9:0] state;\nreg [9:0] next_state;\nreg [2:0] Delay_Cnt;\nreg [7:0] Response_Size;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nreg CRC_Enable;\nreg CRC_OUT;\nreg [6:0] CRC_VAL;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg block_write;\nreg block_read;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// FSM_COMBO logic\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n        In_Buff <= 0;\n        DECODER_ACK <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Write_Read <= SETTING_IN[11];\n        Write_Only <= SETTING_IN[12];\n        block_write <= SETTING_IN[13];\n        block_read <= SETTING_IN[14];\n        word_select <= SETTING_IN[15:14];\n        In_Buff <= CMD_IN;\n        DECODER_ACK <= 0;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CMD_OUT <= 0;\n        ACK_OUT <= 0;\n        REQ_OUT <= 0;\n        STATUS <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        st_dat_t <= 0;\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        Cmd_Cnt <= 0;\n        CRC_RST <= 1;\n        CRC_IN <= 0;\n        CRC_OUT <= 0;\n        Crc_Buffering <= 0;\n        CRC_Valid <= 0;\n        FSM_ACK <= 1;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_Enable <= 1;\n                CRC_RST <= 0;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC Buffering and Bit Transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    if (Cmd_Cnt < Response_Size) begin\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_Enable <= 1;\n                CRC_RST <= 0;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC Buffering and Bit Transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    if (Cmd_Cnt < Response_Size) begin\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            READ_WR: begin\n                CRC_Enable <= 1;\n                CRC_RST <= 0;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 16'b0000_0000_0000_0101;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // Response Reception\n                if (Cmd_Cnt < Response_Size) begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    // Validate CRC\n                    if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                    end\n                    st_dat_t <= {block_read, block_write};\n                end\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 7, "code": "module sd_cmd_serial_host(\n    input  wire        SD_CLK_IN,\n    input  wire        RST_IN,\n    input  wire [15:0] SETTING_IN,\n    input  wire [39:0] CMD_IN,\n    input  wire        REQ_IN,\n    input  wire        ACK_IN,\n    input  wire        cmd_dat_i,\n    output wire [39:0] CMD_OUT,\n    output wire        ACK_OUT,\n    output wire        REQ_OUT,\n    output wire [7:0]  STATUS,\n    output wire        cmd_oe_o,\n    output wire        cmd_out_o,\n    output wire [1:0]  st_dat_t\n);\n\n// Internal Constants and Parameters\nparameter INIT_DELAY = 2; // For simulation\nparameter NCR = 2; // Number of cycles required for write delay\nparameter SEND_SIZE = 48; // Total number of bits to send for a complete command transmission\nparameter SIZE = 10; // Width of the state variable for FSM\nparameter CONTENT_SIZE = 40; // Size of the internal command buffer\nparameter Read_Delay = 7; // Number of cycles to delay before processing read response\nparameter EIGHT_PAD = 8; // Number of padding bits used in response handling\n\n// Internal Signals\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg Write_Read;\nreg Write_Only;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// FSM States\nparameter INIT = 10'd0;\nparameter IDLE = 10'd1;\nparameter WRITE_WR = 10'd2;\nparameter DLY_WR = 10'd3;\nparameter READ_WR = 10'd4;\nparameter DLY_READ = 10'd5;\nparameter ACK_WR = 10'd6;\nparameter WRITE_WO = 10'd7;\nparameter DLY_WO = 10'd8;\nparameter ACK_WO = 10'd9;\n\n// FSM_COMBO\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        In_Buff <= CMD_IN;\n        if (SETTING_IN[6:0] > 0) begin\n            Write_Read <= 1;\n            Write_Only <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 1;\n        end\n        DECODER_ACK <= 0;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CMD_OUT <= 0;\n        ACK_OUT <= 0;\n        REQ_OUT <= 0;\n        STATUS <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 1;\n                Cmd_Cnt <= 0;\n                Delay_Cnt <= 0;\n            end\n            WRITE_WR: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 0;\n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            WRITE_WO: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 0;\n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_WR: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 1;\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            DLY_WO: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 1;\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            READ_WR: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 1;\n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 1;\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0111;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n            default: begin\n                // Handle default state\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    input               SD_CLK_IN,\n    input               RST_IN,\n    input  [15:0]       SETTING_IN,\n    input  [39:0]       CMD_IN,\n    input               REQ_IN,\n    input               ACK_IN,\n    input               cmd_dat_i,\n    output [39:0]       CMD_OUT,\n    output              ACK_OUT,\n    output              REQ_OUT,\n    output [7:0]        STATUS,\n    output              cmd_oe_o,\n    output              cmd_out_o,\n    output [1:0]        st_dat_t\n);\n\n// Internal signals and registers\nreg [9:0] state, next_state;\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff, Out_Buff;\nreg Write_Read, Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST, CRC_Enable, CRC_Check_On, Crc_Buffering, CRC_Valid;\nreg [6:0] CRC_IN, CRC_OUT, CRC_VAL;\nreg [7:0] Cmd_Cnt, Delay_Cnt;\nreg [3:0] block_write, block_read;\nreg FSM_ACK, DECODER_ACK;\nreg q, Req_internal_in, q1, Ack_internal_in;\n\n// FSM_COMBO logic\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        CRC_Check_On <= SETTING_IN[7];\n        In_Buff <= CMD_IN;\n        Write_Read <= (SETTING_IN[6:0] > 0);\n        Write_Only <= !Write_Read;\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        DECODER_ACK <= 0;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                Crc_Buffering <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC Buffering and Bit Transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    if (Cmd_Cnt >= 8) begin\n                        // Transmit CRC bits and update st_dat_t\n                        if (Cmd_Cnt >= 9) begin\n                            st_dat_t <= (block_read ? 2'b01 : 2'b00);\n                        end\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC Buffering and Bit Transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    if (Cmd_Cnt >= 8) begin\n                        // Transmit CRC bits and update st_dat_t\n                        if (Cmd_Cnt >= 9) begin\n                            st_dat_t <= (block_write ? 2'b10 : 2'b00);\n                        end\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 16'b0000_0000_0000_0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0; // Start bit\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // Response Reception\n                if (Cmd_Cnt < Response_Size) begin\n                    // Capture incoming data bits into Out_Buff\n                    Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                    CRC_IN <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    // Validate CRC\n                    if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    // Update st_dat_t\n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                CMD_OUT <= Out_Buff;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\n// sd_crc_7 instantiation\nsd_crc_7 u_sd_crc_7(\n    .BITVAL(cmd_dat_i),\n    .Enable(CRC_Enable),\n    .CLK(SD_CLK_IN),\n    .RST(RST_IN),\n    .CRC(CRC_OUT)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 9, "code": "// sd_cmd_serial_host module\nmodule sd_cmd_serial_host(\n    // Input ports\n    input           SD_CLK_IN,\n    input           RST_IN,\n    input   [15:0]  SETTING_IN,\n    input   [39:0]  CMD_IN,\n    input           REQ_IN,\n    input           ACK_IN,\n    input           cmd_dat_i,\n\n    // Output ports\n    output  [39:0]  CMD_OUT,\n    output          ACK_OUT,\n    output          REQ_OUT,\n    output  [7:0]   STATUS,\n    output          cmd_oe_o,\n    output          cmd_out_o,\n    output  [1:0]   st_dat_t\n);\n\n// Internal signals and registers\nreg    [9:0]  state;\nreg    [9:0]  next_state;\nreg    [6:0]  Response_Size;\nreg    [2:0]  Delay_Cycler;\nreg    [39:0] In_Buff;\nreg    [39:0] Out_Buff;\nreg             Write_Read;\nreg             Write_Only;\nreg             block_write;\nreg             block_read;\nreg    [1:0]    word_select;\nreg             FSM_ACK;\nreg             DECODER_ACK;\nreg             q;\nreg             Req_internal_in;\nreg             q1;\nreg             Ack_internal_in;\nreg    [6:0]    CRC_IN;\nreg             CRC_Enable;\nreg             CRC_RST;\nreg             Crc_Buffering;\nreg             CRC_Valid;\nreg    [7:0]    Cmd_Cnt;\nreg    [2:0]    Delay_Cnt;\n\n// FSM_combo logic\nalways @(*)\nbegin\n    case(state)\n        INIT:\n            if(Cmd_Cnt >= INIT_DELAY)\n                next_state = IDLE;\n            else\n                next_state = INIT;\n        IDLE:\n            if(Write_Read)\n                next_state = WRITE_WR;\n            else if(Write_Only)\n                next_state = WRITE_WO;\n            else\n                next_state = IDLE;\n        WRITE_WR:\n            if(Cmd_Cnt >= SEND_SIZE - 1)\n                next_state = DLY_WR;\n            else\n                next_state = WRITE_WR;\n        WRITE_WO:\n            if(Cmd_Cnt >= SEND_SIZE - 1)\n                next_state = DLY_WO;\n            else\n                next_state = WRITE_WO;\n        DLY_WR:\n            if(Delay_Cnt >= NCR && !cmd_dat_i)\n                next_state = READ_WR;\n            else\n                next_state = DLY_WR;\n        DLY_WO:\n            if(Delay_Cnt >= Delay_Cycler)\n                next_state = ACK_WO;\n            else\n                next_state = DLY_WO;\n        READ_WR:\n            if(Cmd_Cnt >= Response_Size + EIGHT_PAD)\n                next_state = DLY_READ;\n            else\n                next_state = READ_WR;\n        DLY_READ:\n            if(Ack_internal_in)\n                next_state = ACK_WR;\n            else\n                next_state = DLY_READ;\n        ACK_WO:\n            next_state = IDLE;\n        ACK_WR:\n            next_state = IDLE;\n        default:\n            next_state = INIT;\n    endcase\nend\n\n// FSM_seq logic\nalways @(posedge SD_CLK_IN or posedge RST_IN)\nbegin\n    if(RST_IN)\n        state <= INIT;\n    else\n        state <= next_state;\nend\n\n// REQ_sync logic\nalways @(posedge SD_CLK_IN or posedge RST_IN)\nbegin\n    if(RST_IN)\n    begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end\n    else\n    begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_sync logic\nalways @(posedge SD_CLK_IN or posedge RST_IN)\nbegin\n    if(RST_IN)\n    begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end\n    else\n    begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER logic\nalways @(posedge SD_CLK_IN or posedge RST_IN)\nbegin\n    if(RST_IN)\n    begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n        In_Buff <= 0;\n    end\n    else if(Req_internal_in)\n    begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        In_Buff <= CMD_IN;\n        if(SETTING_IN[6:0] > 0)\n        begin\n            Write_Read <= 1;\n            Write_Only <= 0;\n        end\n        else\n        begin\n            Write_Read <= 0;\n            Write_Only <= 1;\n        end\n        DECODER_ACK <= 0;\n    end\n    else\n    begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_out logic\nalways @(posedge SD_CLK_IN or posedge RST_IN)\nbegin\n    if(RST_IN)\n    begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end\n    else\n    begin\n        case(state)\n            INIT:\n                begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n            IDLE:\n                begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    st_dat_t <= 0;\n                end\n            WRITE_WR:\n                begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if(Cmd_Cnt == 0)\n                    begin\n                        STATUS[3:0] <= 4'b0001;\n                        REQ_OUT <= 1;\n                    end\n                    else if(Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    // CRC buffering and bit transmission\n                    if(Crc_Buffering)\n                    begin\n                        cmd_oe_o <= 1;\n                        // transmit command bits and manage CRC output\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                    else\n                    begin\n                        Crc_Buffering <= 1;\n                        // pre-load CRC\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n            WRITE_WO:\n                begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if(Cmd_Cnt == 0)\n                    begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end\n                    else if(Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    // CRC buffering and bit transmission\n                    if(Crc_Buffering)\n                    begin\n                        cmd_oe_o <= 1;\n                        // transmit command bits and manage CRC output\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                    else\n                    begin\n                        Crc_Buffering <= 1;\n                        // pre-load CRC\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n            DLY_WR:\n                begin\n                    if(Delay_Cnt == 0)\n                    begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end\n                    else if(Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n            DLY_WO:\n                begin\n                    if(Delay_Cnt == 0)\n                    begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end\n                    else if(Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n            READ_WR:\n                begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if(Cmd_Cnt == 1)\n                    begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end\n                    else if(Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    // response reception\n                    if(Cmd_Cnt < Response_Size)\n                    begin\n                        // capture incoming data bits\n                        Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                        CRC_IN <= cmd_dat_i;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                    else if((Cmd_Cnt - Response_Size) <= 6)\n                    begin\n                        CRC_IN <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end\n                    else\n                    begin\n                        // validate CRC\n                        if(CRC_IN != CRC_VAL && CRC_Check_On)\n                        begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end\n                        else\n                        begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        // update st_dat_t\n                        if(block_read && block_write)\n                        begin\n                            st_dat_t <= 2'b11;\n                        end\n                        else if(block_write)\n                        begin\n                            st_dat_t <= 2'b01;\n                        end\n                    end\n                end\n            DLY_READ:\n                begin\n                    if(Delay_Cnt == 0)\n                    begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end\n                    else if(Ack_internal_in)\n                    begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    CMD_OUT <= Out_Buff;\n                end\n            ACK_WO:\n                FSM_ACK <= 1;\n            ACK_WR:\n                FSM_ACK <= 1;\n            default:\n                ;\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 10, "code": "```ilog\n`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    input               SD_CLK_IN,\n    input               RST_IN,\n    input      [15:0]   SETTING_IN,\n    input      [39:0]   CMD_IN,\n    input               REQ_IN,\n    input               ACK_IN,\n    input               cmd_dat_i,\n    output     [39:0]   CMD_OUT,\n    output              ACK_OUT,\n    output              REQ_OUT,\n    output     [7:0]    STATUS,\n    output              cmd_oe_o,\n    output              cmd_out_o,\n    output     [1:0]    st_dat_t\n);\n\n// Internal signals and registers\nreg [9:0] state, next_state;\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff, Out_Buff;\nreg Write_Read, Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST, CRC_Enable, CRC_Check_On, Crc_Buffering, CRC_Valid;\nreg [6:0] CRC_IN, CRC_VAL, CRC_OUT;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg FSM_ACK, DECODER_ACK;\nreg [1:0] q, q1;\nreg Req_internal_in, Ack_internal_in;\nreg [1:0] block_write, block_read;\n\n// FSM_combo logic\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_seq logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_sync logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_sync logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        CRC_Check_On <= SETTING_IN[7];\n        Write_Read <= SETTING_IN[6:0] > 0;\n        Write_Only <= !Write_Read;\n        In_Buff <= CMD_IN;\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n    end\nend\n\n// FSM_out logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CMD_OUT <= 0;\n        ACK_OUT <= 0;\n        REQ_OUT <= 0;\n        STATUS <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        st_dat_t <= 0;\n        FSM_ACK <= 1;\n        CRC_RST <= 1;\n        CRC_Enable <= 0;\n        CRC_OUT <= 0;\n        Cmd_Cnt <= 0;\n        Delay_Cnt <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                Cmd_Cnt <= 0;\n                Delay_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CRC_OUT <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC buffering and bit transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // transmit command bits and manage CRC output\n                    if (Cmd_Cnt < Response_Size) begin\n                        CMD_OUT <= In_Buff;\n                    end else begin\n                        CMD_OUT <= CRC_OUT;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_IN <= In_Buff;\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC buffering and bit transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // transmit command bits and manage CRC output\n                    if (Cmd_Cnt < Response_Size) begin\n                        CMD_OUT <= In_Buff;\n                    end else begin\n                        CMD_OUT <= CRC_OUT;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_IN <= In_Buff;\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            READ_WR: begin\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 16'b0000_0000_0000_0101;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // receive and process read response\n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff <= {Out_Buff[38:0], cmd_dat_i};\n                end else begin\n                    CRC_IN <= cmd_dat_i;\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n            end\n            default: begin\n                state <= INIT;\n            end\n        endcase\n    end\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 11, "code": "```ilog\n// Import necessary definitions\n`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    input               SD_CLK_IN,\n    input               RST_IN,\n    input  [15:0]       SETTING_IN,\n    input  [39:0]       CMD_IN,\n    input               REQ_IN,\n    input               ACK_IN,\n    input               cmd_dat_i,\n    output [39:0]       CMD_OUT,\n    output              ACK_OUT,\n    output              REQ_OUT,\n    output [7:0]        STATUS,\n    output              cmd_oe_o,\n    output              cmd_out_o,\n    output [1:0]        st_dat_t\n);\n\n// Internal signals and registers\nreg [9:0] state, next_state;\nreg [2:0] Delay_Cnt;\nreg [7:0] Response_Size;\nreg [39:0] In_Buff, Out_Buff;\nreg Write_Read, Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST, CRC_Enable, CRC_Check_On, Crc_Buffering, CRC_Valid;\nreg [6:0] CRC_IN, CRC_VAL, CRC_OUT;\nreg [7:0] Cmd_Cnt;\nreg [3:0] Delay_Cycler;\nreg FSM_ACK, DECODER_ACK;\nreg Req_internal_in, Ack_internal_in;\nreg q, q1;\n\n// FSM_combo logic\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY)\n                next_state = IDLE;\n            else\n                next_state = INIT;\n        end\n        IDLE: begin\n            if (Write_Read)\n                next_state = WRITE_WR;\n            else if (Write_Only)\n                next_state = WRITE_WO;\n            else\n                next_state = IDLE;\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1)\n                next_state = DLY_WR;\n            else\n                next_state = WRITE_WR;\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1)\n                next_state = DLY_WO;\n            else\n                next_state = WRITE_WO;\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i)\n                next_state = READ_WR;\n            else\n                next_state = DLY_WR;\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler)\n                next_state = ACK_WO;\n            else\n                next_state = DLY_WO;\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD)\n                next_state = DLY_READ;\n            else\n                next_state = READ_WR;\n        end\n        DLY_READ: begin\n            if (Ack_internal_in)\n                next_state = ACK_WR;\n            else\n                next_state = DLY_READ;\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        // Decode SETTING_IN and load command data\n        Response_Size <= SETTING_IN[6:0];\n        CRC_Check_On <= SETTING_IN[7];\n        Delay_Cycler <= SETTING_IN[10:8];\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        In_Buff <= CMD_IN;\n        if (SETTING_IN[6:0] > 0) begin\n            Write_Read <= 1;\n            Write_Only <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 1;\n        end\n        DECODER_ACK <= 0;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC buffering and bit transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        // Transmit command bits and manage CRC output\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        // Transmit CRC bits and update st_dat_t\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                end\n            end\n            WRITE_WO: begin\n                // Similar to WRITE_WR with adjustments for write-only\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 16'b0000_0000_0000_0101;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // Response reception\n                if (Cmd_Cnt < Response_Size) begin\n                    // Capture incoming data bits into Out_Buff\n                    // Assign CRC_OUT from cmd_dat_i for CRC computation\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    // Assign CRC_IN from cmd_dat_i\n                    CRC_Enable <= 0;\n                end else begin\n                    // Validate CRC\n                    if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                    end\n                    CRC_Enable <= 0;\n                    // Update st_dat_t based on block_read and block_write flags\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                CMD_OUT <= Out_Buff;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    input               SD_CLK_IN,\n    input               RST_IN,\n    input   [15:0]      SETTING_IN,\n    input   [39:0]      CMD_IN,\n    input               REQ_IN,\n    input               ACK_IN,\n    input               cmd_dat_i,\n    output  [39:0]      CMD_OUT,\n    output              ACK_OUT,\n    output              REQ_OUT,\n    output  [7:0]       STATUS,\n    output              cmd_oe_o,\n    output              cmd_out_o,\n    output  [1:0]       st_dat_t\n);\n\n// Internal signals and registers\nreg [9:0] state, next_state;\nreg [2:0] Delay_Cnt;\nreg [7:0] Response_Size;\nreg [39:0] In_Buff, Out_Buff;\nreg Write_Read, Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST, CRC_Enable;\nreg [6:0] CRC_IN;\nwire [6:0] CRC_VAL;\nreg CRC_Out;\nreg [3:0] Cmd_Cnt;\nreg block_write, block_read;\nreg FSM_ACK, DECODER_ACK;\nreg q, Req_internal_in;\nreg q1, Ack_internal_in;\nreg Crc_Buffering, CRC_Valid;\n\n// FSM_COMBO logic\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Delay_Cycler <= SETTING_IN[10:8];\n        Response_Size <= SETTING_IN[6:0];\n        CRC_Check_On <= SETTING_IN[7];\n        In_Buff <= CMD_IN;\n        Write_Read <= (SETTING_IN[6:0] > 0);\n        Write_Only <= (SETTING_IN[6:0] == 0);\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        DECODER_ACK <= 0;\n    end else begin\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_Out <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                Crc_Buffering <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        // Transmit command bits and manage CRC output\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        // Transmit CRC bits and update st_dat_t\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 16'b0000_0000_0000_0101;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Cmd_Cnt < Response_Size) begin\n                    // Capture incoming data bits into Out_Buff\n                    CRC_IN <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    // Assign CRC_IN from cmd_dat_i\n                    CRC_Enable <= 0;\n                end else begin\n                    // Validate CRC\n                    if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                    end\n                    CRC_Enable <= 0;\n                    // Update st_dat_t\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                CMD_OUT <= Out_Buff;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 13, "code": "// Import necessary definitions\n`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    input  wire        SD_CLK_IN,    // Clock signal for SD interface synchronization\n    input  wire        RST_IN,       // Synchronous reset signal (active high)\n    input  wire [15:0] SETTING_IN,   // Settings for the current command\n    input  wire [39:0] CMD_IN,       // Command to be sent to the SD/MMC card\n    input  wire        REQ_IN,       // Request signal for service initiation\n    input  wire        ACK_IN,       // Acknowledgment signal for service completion\n    input  wire        cmd_dat_i,    // Command data input from the SD/MMC card\n    output wire [39:0] CMD_OUT,      // Command output to be sent to the SD/MMC card\n    output wire        ACK_OUT,      // Acknowledgment signal for service completion\n    output wire        REQ_OUT,      // Request signal to initiate service\n    output wire [7:0]  STATUS,       // Status register indicating module state and flags\n    output wire        cmd_oe_o,     // Tri-state control for CMD output enable\n    output wire        cmd_out_o,    // Command output enable signal to SD/MMC card\n    output wire [1:0]  st_dat_t      // Start data transfer signal indicating transfer type\n);\n\n// Internal signals and registers\nreg [9:0] state;         // Current state of the FSM\nreg [9:0] next_state;    // Next state of the FSM\nreg [6:0] Response_Size; // Stores the size of the expected response from the SD/MMC card\nreg [2:0] Delay_Cycler;  // Counter for managing delay cycles during state transitions\nreg [39:0] In_Buff;      // Internal buffer holding the incoming command data (CMD_IN)\nreg [39:0] Out_Buff;     // Internal buffer for storing the outgoing command response data\nreg Write_Read;          // Flag indicating a write operation expecting a read response\nreg Write_Only;          // Flag indicating a write-only operation without expecting a read response\nreg [4:0] word_select_counter; // Counter for managing word selection during CRC operations\nreg CRC_RST;             // Signal to reset the CRC computation unit\nreg [6:0] CRC_IN;        // Input data for CRC computation\nreg CRC_Enable;          // Enable signal for the CRC computation unit\nreg CRC_OUT;             // Output signal from the CRC computation unit indicating CRC bit transmissions\nreg CRC_Check_On;        // Flag indicating whether CRC checking is enabled for the current command\nreg Crc_Buffering;       // Flag indicating if CRC data is being buffered\nreg CRC_Valid;           // Flag indicating the validity of the received CRC\nreg [7:0] Cmd_Cnt;       // Counter for tracking the number of command bits sent or received\nreg [2:0] Delay_Cnt;     // Counter for managing delay states and transitions\nreg block_write;         // Flag indicating a block write operation\nreg block_read;          // Flag indicating a block read operation\nreg [1:0] word_select;   // Signals for selecting specific words during data transfer\nreg FSM_ACK;             // Acknowledgment flag for FSM operations\nreg DECODER_ACK;         // Acknowledgment flag for the command decoder completion\nreg q;                   // Intermediate flip-flop for synchronizing REQ_IN\nreg Req_internal_in;     // Synchronized internal request signal after crossing clock domains\nreg q1;                  // Intermediate flip-flop for synchronizing ACK_IN\nreg Ack_internal_in;     // Synchronized internal acknowledgment signal after crossing clock domains\n\n// FSM_COMBO logic\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        // Reset all internal registers and flags\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        // Decode SETTING_IN\n        Response_Size <= SETTING_IN[6:0];\n        CRC_Check_On <= SETTING_IN[7];\n        Delay_Cycler <= SETTING_IN[10:8];\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        \n        // Load Command Data\n        In_Buff <= CMD_IN;\n        \n        // Set Operation Flags\n        if (SETTING_IN[6:0] > 0) begin\n            Write_Read <= 1;\n            Write_Only <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 1;\n        end\n        \n        // Manage Acknowledgment\n        DECODER_ACK <= 0;\n    end else begin\n        // Decoding Completion\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        // Reset all internal signals and control flags\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                // Initialize the module by keeping the CMD line active for a predefined number of cycles\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                // Await new command requests\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                // Send a write command expecting a read response\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC Buffering and Bit Transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= CRC_OUT;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_IN <= In_Buff[39 - Cmd_Cnt];\n                end\n            end\n            WRITE_WO: begin\n                // Send a write-only command without expecting a read response\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC Buffering and Bit Transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= CRC_OUT;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_IN <= In_Buff[39 - Cmd_Cnt];\n                end\n            end\n            DLY_WR: begin\n                // Introduce a delay after sending a write command\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                // Introduce a delay after sending a write-only command\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                // Receive and process the read response from the SD/MMC card\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 16'b0000_0000_0000_0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // Response Reception\n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_IN <= cmd_dat_i;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    // Validate CRC\n                    if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                    end\n                    CRC_Enable <= 0;\n                    // Update st_dat_t based on block_read and block_write flags\n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n            end\n            DLY_READ: begin\n                // Finalize the read response processing\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                CMD_OUT <= Out_Buff;\n            end\n            ACK_WO: begin\n                // Acknowledge the completion of a write-only operation\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                // Acknowledge the completion of a read operation\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    input               SD_CLK_IN,\n    input               RST_IN,\n    input  [15:0]       SETTING_IN,\n    input  [39:0]       CMD_IN,\n    input               REQ_IN,\n    input               ACK_IN,\n    input               cmd_dat_i,\n    output [39:0]       CMD_OUT,\n    output              ACK_OUT,\n    output              REQ_OUT,\n    output [7:0]        STATUS,\n    output              cmd_oe_o,\n    output              cmd_out_o,\n    output [1:0]        st_dat_t\n);\n\n// Internal signals and registers\nreg [9:0] state, next_state;\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff, Out_Buff;\nreg Write_Read, Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST, CRC_Enable, CRC_Check_On;\nreg [6:0] CRC_IN, CRC_VAL, CRC_OUT;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg block_write, block_read;\nreg [1:0] word_select;\nreg FSM_ACK, DECODER_ACK;\nreg q, Req_internal_in;\nreg q1, Ack_internal_in;\nreg Crc_Buffering, CRC_Valid;\n\n// FSM states\nlocalparam INIT = 10'b0000000001;\nlocalparam IDLE = 10'b0000000010;\nlocalparam WRITE_WR = 10'b0000000100;\nlocalparam DLY_WR = 10'b0000001000;\nlocalparam READ_WR = 10'b0000010000;\nlocalparam DLY_READ = 10'b0000100000;\nlocalparam ACK_WR = 10'b0001000000;\nlocalparam WRITE_WO = 10'b0010000000;\nlocalparam DLY_WO = 10'b0100000000;\nlocalparam ACK_WO = 10'b1000000000;\n\n// FSM_combo logic\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_seq logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_sync logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_sync logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_decoder logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n        DECODER_ACK <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        Write_Read <= SETTING_IN[11];\n        Write_Only <= SETTING_IN[12];\n        CRC_Check_On <= SETTING_IN[7];\n        In_Buff <= CMD_IN;\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        DECODER_ACK <= 0;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_out logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Cmd_Cnt <= 0;\n                Delay_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                Crc_Buffering <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 8'b0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC buffering and bit transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 8'b0000_0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC buffering and bit transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            DLY_WR: begin\n                Delay_Cnt <= Delay_Cnt + 1;\n                cmd_oe_o <= 0;\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'b0000_0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n            end\n            DLY_WO: begin\n                Delay_Cnt <= Delay_Cnt + 1;\n                cmd_oe_o <= 0;\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'b0000_0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n            end\n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 8'b0000_0101;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // Response reception\n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                    CRC_IN <= cmd_dat_i;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    // Validate CRC\n                    if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    // Update st_dat_t based on block_read and block_write flags\n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'b0000_0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 15, "code": "// sd_cmd_serial_host module\nmodule sd_cmd_serial_host(\n    // Input ports\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n\n    // Output ports\n    output [39:0] CMD_OUT,\n    output ACK_OUT,\n    output REQ_OUT,\n    output [7:0] STATUS,\n    output cmd_oe_o,\n    output cmd_out_o,\n    output [1:0] st_dat_t\n);\n\n// Internal signals and registers\nreg [9:0] state;\nreg [9:0] next_state;\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nreg CRC_Enable;\nreg CRC_OUT;\nreg [6:0] CRC_VAL;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// FSM_COMBO logic\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        DECODER_ACK <= 0;\n        Write_Read <= SETTING_IN[11];\n        Write_Only <= SETTING_IN[12];\n        In_Buff <= CMD_IN;\n        block_write <= SETTING_IN[13];\n        block_read <= SETTING_IN[14];\n        word_select <= SETTING_IN[15:14];\n    end\nend\n\n// FSM_OUT logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CMD_OUT <= 0;\n        ACK_OUT <= 0;\n        REQ_OUT <= 0;\n        STATUS <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        st_dat_t <= 0;\n        FSM_ACK <= 1;\n        CRC_RST <= 1;\n        CRC_IN <= 0;\n        CRC_Enable <= 0;\n        CRC_OUT <= 0;\n        Crc_Buffering <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        Delay_Cnt <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 1;\n                Cmd_Cnt <= 0;\n                Delay_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CRC_OUT <= 0;\n                Crc_Buffering <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC buffering and bit transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        // transmit command bits and manage CRC output\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        // transmit CRC bits and update st_dat_t\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // pre-load CRC\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC buffering and bit transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // transmit command bits and manage CRC output\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // pre-load CRC\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            READ_WR: begin\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 16'b0000_0000_0000_0101;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // response reception\n                if (Cmd_Cnt < Response_Size) begin\n                    // capture incoming data bits\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    // assign CRC_IN\n                    CRC_Enable <= 0;\n                end else begin\n                    // validate CRC\n                    if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                    end\n                    // update st_dat_t\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 16, "code": "// sd_cmd_serial_host.v\n\n`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    // Input Ports\n    input               SD_CLK_IN,\n    input               RST_IN,\n    input      [15:0]   SETTING_IN,\n    input      [39:0]   CMD_IN,\n    input               REQ_IN,\n    input               ACK_IN,\n    input               cmd_dat_i,\n\n    // Output Ports\n    output     [39:0]   CMD_OUT,\n    output              ACK_OUT,\n    output              REQ_OUT,\n    output     [7:0]    STATUS,\n    output              cmd_oe_o,\n    output              cmd_out_o,\n    output     [1:0]    st_dat_t\n);\n\n// Internal Constants and Parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// Internal Signals\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg Write_Read;\nreg Write_Only;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg [7:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nreg CRC_Enable;\nreg CRC_OUT;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// FSM States\nparameter INIT = 10'd0;\nparameter IDLE = 10'd1;\nparameter WRITE_WR = 10'd2;\nparameter DLY_WR = 10'd3;\nparameter READ_WR = 10'd4;\nparameter DLY_READ = 10'd5;\nparameter ACK_WR = 10'd6;\nparameter WRITE_WO = 10'd7;\nparameter DLY_WO = 10'd8;\nparameter ACK_WO = 10'd9;\n\nreg [9:0] state;\nreg [9:0] next_state;\n\n// FSM_COMBO\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        Write_Read <= SETTING_IN[11];\n        Write_Only <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        In_Buff <= CMD_IN;\n        DECODER_ACK <= 0;\n    end else begin\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CMD_OUT <= 0;\n        ACK_OUT <= 0;\n        REQ_OUT <= 0;\n        STATUS <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        st_dat_t <= 0;\n        FSM_ACK <= 1;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CRC_Enable <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 8'd1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                REQ_OUT <= 0;\n                STATUS <= 0;\n            end\n            WRITE_WR: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 0;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 8'd2;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n            end\n            WRITE_WO: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 0;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 8'd3;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n            end\n            DLY_WR: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'd4;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n            end\n            DLY_WO: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'd5;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n            end\n            READ_WR: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 8'd6;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n            end\n            DLY_READ: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'd7;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 17, "code": "```ilog\n// sd_cmd_serial_host module\nmodule sd_cmd_serial_host(\n    input  wire        SD_CLK_IN,\n    input  wire        RST_IN,\n    input  wire [15:0] SETTING_IN,\n    input  wire [39:0] CMD_IN,\n    input  wire        REQ_IN,\n    input  wire        ACK_IN,\n    input  wire        cmd_dat_i,\n    output wire [39:0] CMD_OUT,\n    output wire        ACK_OUT,\n    output wire        REQ_OUT,\n    output wire [7:0]  STATUS,\n    output wire        cmd_oe_o,\n    output wire        cmd_out_o,\n    output wire [1:0]  st_dat_t\n);\n\n// Internal constants and parameters\nparameter INIT_DELAY = 2; // SIM: 2, Other: 64\nparameter NCR = 2; // Number of cycles required for write delay\nparameter SEND_SIZE = 48; // Total number of bits to send for a complete command transmission\nparameter SIZE = 10; // Width of the state variable for FSM\nparameter CONTENT_SIZE = 40; // Size of the internal command buffer\nparameter Read_Delay = 7; // Number of cycles to delay before processing read response\nparameter EIGHT_PAD = 8; // Number of padding bits used in response handling\n\n// Internal signals\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg Write_Read;\nreg Write_Only;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state;\nreg [9:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\nreg CRC_RST;\nreg CRC_Enable;\nreg [6:0] CRC_IN;\nreg [6:0] CRC_VAL;\nreg CRC_Valid;\nreg Crc_Buffering;\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ block\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC block\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC block\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER block\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n        DECODER_ACK <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        Write_Read <= SETTING_IN[11];\n        Write_Only <= SETTING_IN[12];\n        In_Buff <= CMD_IN;\n        block_write <= SETTING_IN[13];\n        block_read <= SETTING_IN[14];\n        word_select <= SETTING_IN[15:14];\n        DECODER_ACK <= 0;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT block\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CMD_OUT <= 0;\n        ACK_OUT <= 0;\n        REQ_OUT <= 0;\n        STATUS <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        st_dat_t <= 0;\n        CRC_RST <= 1;\n        CRC_Enable <= 0;\n        CRC_IN <= 0;\n        CRC_VAL <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        Delay_Cnt <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Cmd_Cnt <= 0;\n                Delay_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 8'b0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 1;\n                cmd_oe_o <= 1;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 8'b0000_0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 1;\n                cmd_oe_o <= 1;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'b0000_0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'b0000_0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 8'b0000_0101;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'b0000_0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n            end\n        endcase\n    end\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 18, "code": "// sd_cmd_serial_host module\nmodule sd_cmd_serial_host(\n    input  wire        SD_CLK_IN,    // Clock signal for SD interface synchronization\n    input  wire        RST_IN,       // Synchronous reset signal (active high)\n    input  wire [15:0] SETTING_IN,   // Settings for the current command\n    input  wire [39:0] CMD_IN,       // Command to be sent to the SD/MMC card\n    input  wire        REQ_IN,       // Request signal for service initiation\n    input  wire        ACK_IN,       // Acknowledgment signal for service completion\n    input  wire        cmd_dat_i,    // Command data input from the SD/MMC card\n    output wire [39:0] CMD_OUT,      // Command output to be sent to the SD/MMC card\n    output wire        ACK_OUT,      // Acknowledgment signal for service completion\n    output wire        REQ_OUT,      // Request signal to initiate service\n    output wire [7:0]  STATUS,       // Status register indicating module state and flags\n    output wire        cmd_oe_o,     // Tri-state control for CMD output enable\n    output wire        cmd_out_o,    // Command output enable signal to SD/MMC card\n    output wire [1:0]  st_dat_t      // Start data transfer signal indicating transfer type\n);\n\n// Internal signals and registers\nreg [9:0] state;         // Current state of the FSM\nreg [9:0] next_state;   // Next state of the FSM\nreg [7:0] Response_Size; // Stores the size of the expected response from the SD/MMC card\nreg [2:0] Delay_Cycler; // Counter for managing delay cycles during state transitions\nreg [39:0] In_Buff;     // Internal buffer holding the incoming command data (CMD_IN)\nreg [39:0] Out_Buff;    // Internal buffer for storing the outgoing command response data\nreg        Write_Read;  // Flag indicating a write operation expecting a read response\nreg        Write_Only;  // Flag indicating a write-only operation without expecting a read response\nreg [4:0]  word_select_counter; // Counter for managing word selection during CRC operations\nreg        CRC_RST;     // Signal to reset the CRC computation unit\nreg [6:0]  CRC_IN;      // Input data for CRC computation\nreg        CRC_Enable;  // Enable signal for the CRC computation unit\nreg        CRC_OUT;     // Output signal from the CRC computation unit indicating CRC bit transmissions\nreg        CRC_Check_On;// Flag indicating whether CRC checking is enabled for the current command\nreg        Crc_Buffering;// Flag indicating if CRC data is being buffered\nreg        CRC_Valid;   // Flag indicating the validity of the received CRC\nreg [7:0]  Cmd_Cnt;     // Counter for tracking the number of command bits sent or received\nreg [2:0]  Delay_Cnt;   // Counter for managing delay states and transitions\nreg        block_write; // Flag indicating a block write operation\nreg        block_read;  // Flag indicating a block read operation\nreg [1:0]  word_select; // Signals for selecting specific words during data transfer\nreg        FSM_ACK;     // Acknowledgment flag for FSM operations\nreg        DECODER_ACK; // Acknowledgment flag for the command decoder completion\nreg        q;           // Intermediate flip-flop for synchronizing REQ_IN\nreg        Req_internal_in;// Synchronized internal request signal after crossing clock domains\nreg        q1;          // Intermediate flip-flop for synchronizing ACK_IN\nreg        Ack_internal_in;// Synchronized internal acknowledgment signal after crossing clock domains\n\n// FSM_COMBO: Combinatorial logic to determine the next state of the FSM\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ: Sequential logic that updates the current state of the FSM\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC: Synchronizes the asynchronous REQ_IN signal to the local clock domain\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC: Synchronizes the asynchronous ACK_IN signal to the local clock domain\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER: Decodes the SETTING_IN register and prepares internal settings and buffers\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Delay_Cycler <= 0;\n        Response_Size <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        // Decode SETTING_IN and load command data into In_Buff\n        Delay_Cycler <= SETTING_IN[10:8];\n        Response_Size <= SETTING_IN[6:0];\n        CRC_Check_On <= SETTING_IN[7];\n        In_Buff <= CMD_IN;\n        // Set operation flags\n        if (SETTING_IN[6:0] > 0) begin\n            Write_Read <= 1;\n            Write_Only <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 1;\n        end\n        DECODER_ACK <= 0;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT: Manages the output logic based on the current state of the FSM\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        // Reset all output signals and internal registers\n        CMD_OUT <= 0;\n        ACK_OUT <= 0;\n        REQ_OUT <= 0;\n        STATUS <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        st_dat_t <= 0;\n        CRC_Enable <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        Crc_Buffering <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        Delay_Cnt <= 0;\n        FSM_ACK <= 1;\n    end else begin\n        case (state)\n            INIT: begin\n                // Initialize the module by keeping the CMD line active for a predefined number of cycles\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                // Await new command requests\n                cmd_oe_o <= 0;\n                Cmd_Cnt <= 0;\n                Delay_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                // Send a write command expecting a read response\n                FSM_ACK <= 0;\n                CRC_Enable <= 1;\n                CRC_RST <= 0;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC buffering and bit transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            WRITE_WO: begin\n                // Send a write-only command without expecting a read response\n                FSM_ACK <= 0;\n                CRC_Enable <= 1;\n                CRC_RST <= 0;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // CRC buffering and bit transmission\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                    CRC_OUT <= In_Buff[39];\n                end\n            end\n            DLY_WR: begin\n                // Introduce a delay after sending a write command\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                // Introduce a delay after sending a write-only command\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0100;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                // Receive and process the read response from the SD/MMC card\n                Delay_Cnt <= 0;\n                CRC_Enable <= 1;\n                CRC_RST <= 0;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 16'b0000_0000_0000_0101;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                // Response reception\n                if (Cmd_Cnt < Response_Size) begin\n                    // Capture incoming data bits into Out_Buff\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_IN <= cmd_dat_i;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    // Assign CRC_IN from cmd_dat_i\n                    CRC_IN <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    // Validate CRC\n                    if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                    end\n                    CRC_Enable <= 0;\n                    // Update st_dat_t based on block_read and block_write flags\n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'b11;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'b01;\n                    end\n                end\n            end\n            DLY_READ: begin\n                // Finalize the read response processing\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0110;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            ACK_WO: begin\n                // Acknowledge the completion of a write-only operation\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                // Acknowledge the completion of a read operation\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n            default: begin\n                // Default to INIT state\n                state <= INIT;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 19, "code": "````include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    input               SD_CLK_IN,\n    input               RST_IN,\n    input  [15:0]       SETTING_IN,\n    input  [39:0]       CMD_IN,\n    input               REQ_IN,\n    input               ACK_IN,\n    input               cmd_dat_i,\n    output [39:0]       CMD_OUT,\n    output              ACK_OUT,\n    output              REQ_OUT,\n    output [7:0]        STATUS,\n    output              cmd_oe_o,\n    output              cmd_out_o,\n    output [1:0]        st_dat_t\n);\n\n// Internal constants and parameters\nparameter INIT_DELAY = `SIM ? 2 : 64;\nparameter NCR = 2;\nparameter SEND_SIZE = 48;\nparameter SIZE = 10;\nparameter CONTENT_SIZE = 40;\nparameter Read_Delay = 7;\nparameter EIGHT_PAD = 8;\n\n// Internal signals\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff;\nreg [39:0] Out_Buff;\nreg Write_Read;\nreg Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST;\nreg [6:0] CRC_IN;\nreg CRC_Enable;\nreg CRC_OUT;\nreg [6:0] CRC_VAL;\nreg CRC_Check_On;\nreg Crc_Buffering;\nreg CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg block_write;\nreg block_read;\nreg [1:0] word_select;\nreg FSM_ACK;\nreg DECODER_ACK;\nreg q;\nreg Req_internal_in;\nreg q1;\nreg Ack_internal_in;\n\n// FSM states\nparameter INIT = 10'd0;\nparameter IDLE = 10'd1;\nparameter WRITE_WR = 10'd2;\nparameter DLY_WR = 10'd3;\nparameter READ_WR = 10'd4;\nparameter DLY_READ = 10'd5;\nparameter ACK_WR = 10'd6;\nparameter WRITE_WO = 10'd7;\nparameter DLY_WO = 10'd8;\nparameter ACK_WO = 10'd9;\n\n// FSM_COMBO logic\nalways @(*) begin\n    case (state)\n        INIT: begin\n            if (Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (Write_Read) begin\n                next_state = WRITE_WR;\n            end else if (Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if (Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if (Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if (Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if (Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if (Ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        CRC_Check_On <= 0;\n        In_Buff <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        CRC_Check_On <= SETTING_IN[7];\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        In_Buff <= CMD_IN;\n        Write_Read <= (SETTING_IN[6:0] > 0);\n        Write_Only <= !Write_Read;\n        DECODER_ACK <= 0;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        CRC_Enable <= 0;\n        word_select_counter <= 0;\n        Delay_Cnt <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        CRC_RST <= 1;\n        CRC_OUT <= 0;\n        CRC_IN <= 0;\n        CMD_OUT <= 0;\n        Crc_Buffering <= 0;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        st_dat_t <= 0;\n    end else begin\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                Crc_Buffering <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 8'd1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        CMD_OUT <= In_Buff[39 - Cmd_Cnt];\n                    end else if (Cmd_Cnt > 2) begin\n                        CMD_OUT <= CRC_OUT;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_IN <= In_Buff[39];\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 8'd2;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        CMD_OUT <= In_Buff[39 - Cmd_Cnt];\n                    end else if (Cmd_Cnt > 2) begin\n                        CMD_OUT <= CRC_OUT;\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_IN <= In_Buff[39];\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'd3;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'd4;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS <= 8'd5;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_IN <= cmd_dat_i;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if (CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    if (block_read && block_write) begin\n                        st_dat_t <= 2'd3;\n                    end else if (block_write) begin\n                        st_dat_t <= 2'd1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS <= 8'd6;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                CMD_OUT <= Out_Buff;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    input             SD_CLK_IN,\n    input             RST_IN,\n    input      [15:0] SETTING_IN,\n    input      [39:0] CMD_IN,\n    input             REQ_IN,\n    input             ACK_IN,\n    input             cmd_dat_i,\n    output    [39:0] CMD_OUT,\n    output            ACK_OUT,\n    output            REQ_OUT,\n    output     [7:0] STATUS,\n    output            cmd_oe_o,\n    output            cmd_out_o,\n    output     [1:0] st_dat_t\n);\n\n// Internal signals and registers\nreg [9:0] state, next_state;\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff, Out_Buff;\nreg Write_Read, Write_Only, block_write, block_read;\nreg [1:0] word_select;\nreg FSM_ACK, DECODER_ACK;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg CRC_Enable, CRC_RST, Crc_Buffering, CRC_Valid;\nreg [6:0] CRC_IN, CRC_OUT, CRC_VAL;\nreg [7:0] Vector_Index;\nreg req_internal_in, ack_internal_in;\nreg q, q1;\n\n// FSM_COMBO logic\nalways @(*) begin\n    case(state)\n        INIT: begin\n            if(Cmd_Cnt >= INIT_DELAY) begin\n                next_state = IDLE;\n            end else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if(Write_Read) begin\n                next_state = WRITE_WR;\n            end else if(Write_Only) begin\n                next_state = WRITE_WO;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        WRITE_WR: begin\n            if(Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WR;\n            end else begin\n                next_state = WRITE_WR;\n            end\n        end\n        WRITE_WO: begin\n            if(Cmd_Cnt >= SEND_SIZE - 1) begin\n                next_state = DLY_WO;\n            end else begin\n                next_state = WRITE_WO;\n            end\n        end\n        DLY_WR: begin\n            if(Delay_Cnt >= NCR && !cmd_dat_i) begin\n                next_state = READ_WR;\n            end else begin\n                next_state = DLY_WR;\n            end\n        end\n        DLY_WO: begin\n            if(Delay_Cnt >= Delay_Cycler) begin\n                next_state = ACK_WO;\n            end else begin\n                next_state = DLY_WO;\n            end\n        end\n        READ_WR: begin\n            if(Cmd_Cnt >= Response_Size + EIGHT_PAD) begin\n                next_state = DLY_READ;\n            end else begin\n                next_state = READ_WR;\n            end\n        end\n        DLY_READ: begin\n            if(ack_internal_in) begin\n                next_state = ACK_WR;\n            end else begin\n                next_state = DLY_READ;\n            end\n        end\n        ACK_WO: begin\n            next_state = IDLE;\n        end\n        ACK_WR: begin\n            next_state = IDLE;\n        end\n        default: begin\n            next_state = INIT;\n        end\n    endcase\nend\n\n// FSM_SEQ logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if(RST_IN) begin\n        state <= INIT;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// REQ_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if(RST_IN) begin\n        q <= 0;\n        req_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        req_internal_in <= q;\n    end\nend\n\n// ACK_SYNC logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if(RST_IN) begin\n        q1 <= 0;\n        ack_internal_in <= 0;\n    end else begin\n        q1 <= ACK_IN;\n        ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if(RST_IN) begin\n        Response_Size <= 0;\n        Delay_Cycler <= 0;\n        DECODER_ACK <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n        In_Buff <= 0;\n    end else if(req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        Delay_Cycler <= SETTING_IN[10:8];\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        In_Buff <= CMD_IN;\n        if(SETTING_IN[6:0] > 0) begin\n            Write_Read <= 1;\n            Write_Only <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 1;\n        end\n        DECODER_ACK <= 0;\n    end else if(!req_internal_in && DECODER_ACK) begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 1;\n    end\nend\n\n// FSM_OUT logic\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if(RST_IN) begin\n        CMD_OUT <= 0;\n        ACK_OUT <= 0;\n        REQ_OUT <= 0;\n        STATUS <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        st_dat_t <= 0;\n        CRC_Enable <= 0;\n        CRC_RST <= 1;\n        Crc_Buffering <= 0;\n        CRC_Valid <= 0;\n        Cmd_Cnt <= 0;\n        Delay_Cnt <= 0;\n        FSM_ACK <= 1;\n    end else begin\n        case(state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                if(Cmd_Cnt == 0) begin\n                    Cmd_Cnt <= 1;\n                end else begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Delay_Cnt <= 0;\n                Cmd_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                Crc_Buffering <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_Enable <= 1;\n                CRC_RST <= 0;\n                if(Cmd_Cnt == 0) begin\n                    STATUS <= 8'b0000_0001;\n                    REQ_OUT <= 1;\n                end else if(ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if(Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if(Cmd_Cnt > 8) begin\n                        // Transmit command bits and manage CRC output\n                    end else if(Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        // Transmit CRC bits and update st_dat_t\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_Enable <= 1;\n                CRC_RST <= 0;\n                if(Cmd_Cnt == 0) begin\n                    STATUS <= 8'b0000_0010;\n                    REQ_OUT <= 1;\n                end else if(ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if(Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    // Transmit command bits and manage CRC output\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    // Pre-load CRC\n                end\n            end\n            DLY_WR: begin\n                if(Delay_Cnt == 0) begin\n                    STATUS <= 8'b0000_0011;\n                    REQ_OUT <= 1;\n                end else if(ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                cmd_oe_o <= 0;\n                if(Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                if(Delay_Cnt == 0) begin\n                    STATUS <= 8'b0000_0100;\n                    REQ_OUT <= 1;\n                end else if(ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                CRC_Enable <= 1;\n                CRC_RST <= 0;\n                cmd_oe_o <= 0;\n                if(Cmd_Cnt == 1) begin\n                    STATUS <= 8'b0000_0101;\n                    REQ_OUT <= 1;\n                end else if(ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if(Cmd_Cnt < Response_Size) begin\n                    // Capture incoming data bits into Out_Buff\n                    // Assign CRC_OUT from cmd_dat_i for CRC computation\n                end else if((Cmd_Cnt - Response_Size) <= 6) begin\n                    // Assign CRC_IN from cmd_dat_i\n                    CRC_Enable <= 0;\n                end else begin\n                    // Validate CRC\n                    if(CRC_IN != CRC_VAL && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                    end\n                    CRC_Enable <= 0;\n                    // Update st_dat_t based on block_read and block_write flags\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                if(Delay_Cnt == 0) begin\n                    STATUS <= 8'b0000_0110;\n                    REQ_OUT <= 1;\n                end else if(ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                CMD_OUT <= Out_Buff;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // WISHBONE signals\n    input             wb_clk_i,\n    input             wb_rst_i,\n    input      [31:0] wb_dat_i,\n    output     [31:0] wb_dat_o,\n    input       [7:0] wb_adr_i,\n    input       [3:0] wb_sel_i,\n    input             wb_we_i,\n    input             wb_cyc_i,\n    input             wb_stb_i,\n    output            wb_ack_o,\n\n    // Other signals\n    output            we_m_tx_bd,\n    output            we_m_rx_bd,\n    output            new_cmd,\n    output            we_ack,\n    output            int_ack,\n    output            cmd_int_busy,\n    output            int_busy,\n    input             write_req_s,\n    input      [15:0] cmd_set_s,\n    input      [31:0] cmd_arg_s,\n    output     [31:0] argument_reg,\n    output     [15:0] cmd_setting_reg,\n    input      [15:0] status_reg,\n    input      [31:0] cmd_resp_1,\n    output      [7:0] software_reset_reg,\n    output     [15:0] time_out_reg,\n    input      [15:0] normal_int_status_reg,\n    input      [15:0] error_int_status_reg,\n    output     [15:0] normal_int_signal_enable_reg,\n    output     [15:0] error_int_signal_enable_reg,\n    output      [7:0] clock_divider,\n    input      [15:0] Bd_Status_reg,\n    input       [7:0] Bd_isr_reg,\n    output      [7:0] Bd_isr_enable_reg,\n    output            Bd_isr_reset,\n    output            normal_isr_reset,\n    output            error_isr_reset,\n    output     [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output     [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nreg [31:0] registers [0:63];\n\n// Initialize registers\ninitial begin\n    for (int i = 0; i < 64; i++) begin\n        if (i == 0) begin\n            // Argument register\n            registers[i] = 32'd0;\n        end else if (i == 1) begin\n            // Command setting register\n            registers[i] = 16'd0;\n        end else if (i == 2) begin\n            // Card status register\n            registers[i] = 16'd0;\n        end else if (i == 3) begin\n            // Response register\n            registers[i] = 32'd0;\n        end else if (i == 4) begin\n            // Controller settings\n            registers[i] = 16'd0;\n        end else if (i == 5) begin\n            // Block size register\n            registers[i] = 16'd512;\n        end else if (i == 6) begin\n            // Power control register\n            registers[i] = 8'd15;\n        end else if (i == 7) begin\n            // Software reset register\n            registers[i] = 8'd0;\n        end else if (i == 8) begin\n            // Timeout register\n            registers[i] = 16'd0;\n        end else if (i == 9) begin\n            // Normal interrupt status register\n            registers[i] = 16'd0;\n        end else if (i == 10) begin\n            // Error interrupt status register\n            registers[i] = 16'd0;\n        end else if (i == 11) begin\n            // Normal interrupt enable register\n            registers[i] = 16'd0;\n        end else if (i == 12) begin\n            // Error interrupt enable register\n            registers[i] = 16'd0;\n        end else if (i == 13) begin\n            // Capability register\n            registers[i] = 16'd0;\n        end else if (i == 14) begin\n            // Clock divider register\n            registers[i] = 8'd0;\n        end else if (i == 15) begin\n            // BD buffer status register\n            registers[i] = 16'd516;\n        end else if (i == 16) begin\n            // Data interrupt status register\n            registers[i] = 8'd0;\n        end else if (i == 17) begin\n            // Data interrupt enable register\n            registers[i] = 8'd0;\n        end else begin\n            registers[i] = 32'd0;\n        end\n    end\nend\n\n// Reset logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers\n        for (int i = 0; i < 64; i++) begin\n            registers[i] <= 32'd0;\n        end\n        int_ack <= 1'b1;\n    end else begin\n        // Update registers based on WISHBONE signals\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write to register\n                registers[wb_adr_i] <= wb_dat_i;\n                if (wb_adr_i == 8'd0) begin\n                    // Argument register\n                    argument_reg <= wb_dat_i;\n                end else if (wb_adr_i == 8'd1) begin\n                    // Command setting register\n                    cmd_setting_reg <= wb_dat_i[15:0];\n                end else if (wb_adr_i == 8'd7) begin\n                    // Software reset register\n                    software_reset_reg <= wb_dat_i[7:0];\n                end else if (wb_adr_i == 8'd8) begin\n                    // Timeout register\n                    time_out_reg <= wb_dat_i[15:0];\n                end else if (wb_adr_i == 8'd14) begin\n                    // Clock divider register\n                    clock_divider <= wb_dat_i[7:0];\n                end else if (wb_adr_i == 8'd17) begin\n                    // Data interrupt enable register\n                    Bd_isr_enable_reg <= wb_dat_i[7:0];\n                end\n            end else begin\n                // Read from register\n                wb_dat_o <= registers[wb_adr_i];\n            end\n        end\n    end\nend\n\n// Other logic\nassign we_m_tx_bd = (wb_adr_i == 8'd16) && wb_we_i;\nassign we_m_rx_bd = (wb_adr_i == 8'd18) && wb_we_i;\nassign new_cmd = (wb_adr_i == 8'd0) && wb_we_i;\nassign we_ack = write_req_s;\nassign cmd_int_busy = (wb_adr_i == 8'd0 || wb_adr_i == 8'd1) && wb_we_i;\nassign int_busy = (wb_adr_i == 8'd1) && wb_we_i;\nassign wb_ack_o = wb_cyc_i && wb_stb_i && !wb_ack_o && int_ack;\nassign int_ack = !(wb_adr_i == 8'd16 || wb_adr_i == 8'd18) || wb_ack_o;\n\n// Assign outputs\nassign dat_in_m_tx_bd = registers[16];\nassign dat_in_m_rx_bd = registers[18];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 2, "code": "// sd_controller_wb module\nmodule sd_controller_wb(\n    // WISHBONE interface\n    input           wb_clk_i,         // Slave WISHBONE Clock Input\n    input           wb_rst_i,         // Slave WISHBONE Reset Input\n    input   [31:0]  wb_dat_i,         // Slave WISHBONE Data Inputs\n    output  [31:0]  wb_dat_o,         // Slave WISHBONE Data Outputs\n    input   [ 7:0]  wb_adr_i,         // Slave WISHBONE Address Input\n    input   [ 3:0]  wb_sel_i,         // Slave WISHBONE Select Input\n    input           wb_we_i,          // Slave WISHBONE Write Enable\n    input           wb_cyc_i,         // Slave WISHBONE Cycle\n    input           wb_stb_i,         // Slave WISHBONE Strobe\n    output          wb_ack_o,         // Slave WISHBONE Acknowledge\n\n    // Other signals\n    output          we_m_tx_bd,       // Write enable TIx BD\n    output          we_m_rx_bd,       // Write enable Rx BD\n    output          new_cmd,          // New command indication signal\n    output          we_ack,           // Ack on cmd access request\n    output          int_ack,          // Internal Delayed Acknowledge\n    output          cmd_int_busy,     // Cmd busy by data module\n    output          int_busy,         // Command Busy by data module\n    input           write_req_s,      // Cmd access request\n    input   [15:0]  cmd_set_s,        // Command setting input from data master\n    input   [31:0]  cmd_arg_s,        // Command argument input from data master\n    output  [31:0]  argument_reg,     // Command Argument Reg\n    output  [15:0]  cmd_setting_reg,  // Command Setting Reg\n    input   [15:0]  status_reg,       // Card Status Reg\n    input   [31:0]  cmd_resp_1,       // Command Response\n    output  [ 7:0]  software_reset_reg, // Software reset Reg\n    output  [15:0]  time_out_reg,     // Timeout Reg\n    input   [15:0]  normal_int_status_reg, // Normal Interrupt Status Reg\n    input   [15:0]  error_int_status_reg,  // Error Interrupt Status Reg\n    output  [15:0]  normal_int_signal_enable_reg, // Normal Interrupt Enable Reg\n    output  [15:0]  error_int_signal_enable_reg,  // Error Interrupt Enable Reg\n    output  [ 7:0]  clock_divider,    // Clock Divider Reg\n    input   [15:0]  Bd_Status_reg,    // BD Status Reg\n    input   [ 7:0]  Bd_isr_reg,       // Data Interrupt Status Reg\n    output  [ 7:0]  Bd_isr_enable_reg, // Data Interrupt Enable Reg\n    output          Bd_isr_reset,     // Reset data interrupt status\n    output          normal_isr_reset, // Reset normal interrupt status\n    output          error_isr_reset,  // Reset error interrupt status\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd, // Data going to the Tx BD\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd  // Data going to the RX BD\n);\n\n// Internal signals\nreg [31:0] argument_reg_i;\nreg [15:0] cmd_setting_reg_i;\nreg [15:0] status_reg_i;\nreg [31:0] cmd_resp_1_i;\nreg [7:0] software_reset_reg_i;\nreg [15:0] time_out_reg_i;\nreg [15:0] normal_int_status_reg_i;\nreg [15:0] error_int_status_reg_i;\nreg [15:0] normal_int_signal_enable_reg_i;\nreg [15:0] error_int_signal_enable_reg_i;\nreg [7:0] clock_divider_i;\nreg [15:0] Bd_Status_reg_i;\nreg [7:0] Bd_isr_reg_i;\nreg [7:0] Bd_isr_enable_reg_i;\n\n// Reset values\ninitial begin\n    argument_reg_i = 32'h0000;\n    cmd_setting_reg_i = 16'h0000;\n    status_reg_i = 16'h0000;\n    cmd_resp_1_i = 32'h0000;\n    software_reset_reg_i = 8'h00;\n    time_out_reg_i = 16'h0000;\n    normal_int_status_reg_i = 16'h0000;\n    error_int_status_reg_i = 16'h0000;\n    normal_int_signal_enable_reg_i = 16'h0000;\n    error_int_signal_enable_reg_i = 16'h0000;\n    clock_divider_i = 8'h00;\n    Bd_Status_reg_i = 16'h0404;\n    Bd_isr_reg_i = 8'h00;\n    Bd_isr_enable_reg_i = 8'h00;\nend\n\n// Register write\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers\n        argument_reg_i <= 32'h0000;\n        cmd_setting_reg_i <= 16'h0000;\n        status_reg_i <= 16'h0000;\n        cmd_resp_1_i <= 32'h0000;\n        software_reset_reg_i <= 8'h00;\n        time_out_reg_i <= 16'h0000;\n        normal_int_status_reg_i <= 16'h0000;\n        error_int_status_reg_i <= 16'h0000;\n        normal_int_signal_enable_reg_i <= 16'h0000;\n        error_int_signal_enable_reg_i <= 16'h0000;\n        clock_divider_i <= 8'h00;\n        Bd_Status_reg_i <= 16'h0404;\n        Bd_isr_reg_i <= 8'h00;\n        Bd_isr_enable_reg_i <= 8'h00;\n    end else if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n        case (wb_adr_i)\n            8'h00: argument_reg_i <= wb_dat_i;\n            8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n            8'h08: status_reg_i <= wb_dat_i[15:0];\n            8'h0c: cmd_resp_1_i <= wb_dat_i;\n            8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n            8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n            8'h30: normal_int_status_reg_i <= wb_dat_i[15:0];\n            8'h34: error_int_status_reg_i <= wb_dat_i[15:0];\n            8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n            8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n            8'h4c: clock_divider_i <= wb_dat_i[7:0];\n            8'h54: Bd_isr_reg_i <= wb_dat_i[7:0];\n            8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n            default: ;\n        endcase\n    end\nend\n\n// Register read\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i) begin\n        case (wb_adr_i)\n            8'h00: wb_dat_o <= argument_reg_i;\n            8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg_i};\n            8'h08: wb_dat_o <= {16'h0000, status_reg_i};\n            8'h0c: wb_dat_o <= cmd_resp_1_i;\n            8'h28: wb_dat_o <= {24'h000000, software_reset_reg_i};\n            8'h2c: wb_dat_o <= {16'h0000, time_out_reg_i};\n            8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg_i};\n            8'h34: wb_dat_o <= {16'h0000, error_int_status_reg_i};\n            8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg_i};\n            8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg_i};\n            8'h4c: wb_dat_o <= {24'h000000, clock_divider_i};\n            8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg_i};\n            8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg_i};\n            8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg_i};\n            default: wb_dat_o <= 32'h0000;\n        endcase\n    end\nend\n\n// Other logic\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        // Reset all signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end else begin\n        // Control logic\n        if (write_req_s) begin\n            we_ack <= 1'b1;\n        end else begin\n            we_ack <= 1'b0;\n        end\n\n        if (cmd_set_s != 16'h0000) begin\n            cmd_int_busy <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n        end\n\n        if (cmd_arg_s != 32'h0000) begin\n            new_cmd <= 1'b1;\n        end else begin\n            new_cmd <= 1'b0;\n        end\n\n        // wb_ack_o generation\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o && int_ack) begin\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n\n        // int_ack signal\n        if (wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n            int_ack <= 1'b0;\n        end else if (!wb_we_i && int_ack == 1'b0) begin\n            int_ack <= 1'b1;\n        end\n\n        // we_m_rx_bd and we_m_tx_bd signals\n        if (wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n            if (wb_adr_i == 8'h60) begin\n                we_m_rx_bd <= 1'b1;\n            end else begin\n                we_m_tx_bd <= 1'b1;\n            end\n        end else begin\n            we_m_rx_bd <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n        end\n\n        // Bd_isr_reset, normal_isr_reset, and error_isr_reset signals\n        if (wb_we_i && wb_adr_i == 8'h54) begin\n            Bd_isr_reset <= 1'b1;\n        end else begin\n            Bd_isr_reset <= 1'b0;\n        end\n\n        if (wb_we_i && wb_adr_i == 8'h30) begin\n            normal_isr_reset <= 1'b1;\n        end else begin\n            normal_isr_reset <= 1'b0;\n        end\n\n        if (wb_we_i && wb_adr_i == 8'h34) begin\n            error_isr_reset <= 1'b1;\n        end else begin\n            error_isr_reset <= 1'b0;\n        end\n    end\nend\n\n// Assign outputs\nassign argument_reg = argument_reg_i;\nassign cmd_setting_reg = cmd_setting_reg_i;\nassign software_reset_reg = software_reset_reg_i;\nassign time_out_reg = time_out_reg_i;\nassign normal_int_signal_enable_reg = normal_int_signal_enable_reg_i;\nassign error_int_signal_enable_reg = error_int_signal_enable_reg_i;\nassign clock_divider = clock_divider_i;\nassign Bd_isr_enable_reg = Bd_isr_enable_reg_i;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // WISHBONE signals\n    input           wb_clk_i,\n    input           wb_rst_i,\n    input   [31:0]  wb_dat_i,\n    output  [31:0]  wb_dat_o,\n    input   [7:0]   wb_adr_i,\n    input   [3:0]   wb_sel_i,\n    input           wb_we_i,\n    input           wb_cyc_i,\n    input           wb_stb_i,\n    output          wb_ack_o,\n\n    // Other signals\n    output          we_m_tx_bd,\n    output          we_m_rx_bd,\n    output          new_cmd,\n    output          we_ack,\n    output          int_ack,\n    output          cmd_int_busy,\n    output          int_busy,\n    input           write_req_s,\n    input   [15:0]  cmd_set_s,\n    input   [31:0]  cmd_arg_s,\n    output  [31:0]  argument_reg,\n    output  [15:0]  cmd_setting_reg,\n    input   [15:0]  status_reg,\n    input   [31:0]  cmd_resp_1,\n    output  [7:0]   software_reset_reg,\n    output  [15:0]  time_out_reg,\n    input   [15:0]  normal_int_status_reg,\n    input   [15:0]  error_int_status_reg,\n    output  [15:0]  normal_int_signal_enable_reg,\n    output  [15:0]  error_int_signal_enable_reg,\n    output  [7:0]   clock_divider,\n    input   [15:0]  Bd_Status_reg,\n    input   [7:0]   Bd_isr_reg,\n    output  [7:0]   Bd_isr_enable_reg,\n    output          Bd_isr_reset,\n    output          normal_isr_reset,\n    output          error_isr_reset,\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n// Internal signals\nreg [31:0] argument_reg_i;\nreg [15:0] cmd_setting_reg_i;\nreg [7:0] software_reset_reg_i;\nreg [15:0] time_out_reg_i;\nreg [15:0] normal_int_signal_enable_reg_i;\nreg [15:0] error_int_signal_enable_reg_i;\nreg [7:0] clock_divider_i;\nreg [7:0] Bd_isr_enable_reg_i;\nreg int_ack_i;\nreg we_m_tx_bd_i;\nreg we_m_rx_bd_i;\n\n// Assign outputs\nassign wb_dat_o = (wb_adr_i == 8'h00) ? argument_reg_i :\n                  (wb_adr_i == 8'h04) ? {16'h0, cmd_setting_reg_i} :\n                  (wb_adr_i == 8'h08) ? {16'h0, status_reg} :\n                  (wb_adr_i == 8'h0c) ? cmd_resp_1 :\n                  (wb_adr_i == 8'h28) ? {24'h0, software_reset_reg_i} :\n                  (wb_adr_i == 8'h2c) ? {16'h0, time_out_reg_i} :\n                  (wb_adr_i == 8'h38) ? {16'h0, normal_int_signal_enable_reg_i} :\n                  (wb_adr_i == 8'h3c) ? {16'h0, error_int_signal_enable_reg_i} :\n                  (wb_adr_i == 8'h4c) ? {24'h0, clock_divider_i} :\n                  (wb_adr_i == 8'h58) ? {24'h0, Bd_isr_enable_reg_i} :\n                  32'h0;\n\nassign argument_reg = argument_reg_i;\nassign cmd_setting_reg = cmd_setting_reg_i;\nassign software_reset_reg = software_reset_reg_i;\nassign time_out_reg = time_out_reg_i;\nassign normal_int_signal_enable_reg = normal_int_signal_enable_reg_i;\nassign error_int_signal_enable_reg = error_int_signal_enable_reg_i;\nassign clock_divider = clock_divider_i;\nassign Bd_isr_enable_reg = Bd_isr_enable_reg_i;\n\nassign we_m_tx_bd = we_m_tx_bd_i;\nassign we_m_rx_bd = we_m_rx_bd_i;\n\n// Reset logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        argument_reg_i <= 32'h0;\n        cmd_setting_reg_i <= 16'h0;\n        software_reset_reg_i <= 8'h0;\n        time_out_reg_i <= 16'h0;\n        normal_int_signal_enable_reg_i <= 16'h0;\n        error_int_signal_enable_reg_i <= 16'h0;\n        clock_divider_i <= 8'h0;\n        Bd_isr_enable_reg_i <= 8'h0;\n        int_ack_i <= 1'b1;\n        we_m_tx_bd_i <= 1'b0;\n        we_m_rx_bd_i <= 1'b0;\n    end else begin\n        // Register write logic\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg_i <= wb_dat_i;\n                8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n                8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n                8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h4c: clock_divider_i <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n                default: ;\n            endcase\n        end\n\n        // int_ack logic\n        if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n            int_ack_i <= 1'b0;\n        end else if (int_ack_i == 1'b0) begin\n            int_ack_i <= 1'b1;\n        end\n\n        // we_m_tx_bd and we_m_rx_bd logic\n        if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n            if (wb_adr_i == 8'h60) begin\n                we_m_rx_bd_i <= 1'b1;\n            end else begin\n                we_m_tx_bd_i <= 1'b1;\n            end\n        end else if (we_m_tx_bd_i || we_m_rx_bd_i) begin\n            we_m_tx_bd_i <= 1'b0;\n            we_m_rx_bd_i <= 1'b0;\n        end\n    end\nend\n\n// wb_ack_o logic\nassign wb_ack_o = wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack_i;\n\n// int_ack output\nassign int_ack = int_ack_i;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // WISHBONE interface\n    input           wb_clk_i,\n    input           wb_rst_i,\n    input   [31:0]  wb_dat_i,\n    output  [31:0]  wb_dat_o,\n    input   [7:0]   wb_adr_i,\n    input   [3:0]   wb_sel_i,\n    input           wb_we_i,\n    input           wb_cyc_i,\n    input           wb_stb_i,\n    output          wb_ack_o,\n\n    // Other signals\n    output          we_m_tx_bd,\n    output          we_m_rx_bd,\n    output          new_cmd,\n    output          we_ack,\n    output          int_ack,\n    output          cmd_int_busy,\n    output          int_busy,\n    input           write_req_s,\n    input   [15:0]  cmd_set_s,\n    input   [31:0]  cmd_arg_s,\n    output  [31:0]  argument_reg,\n    output  [15:0]  cmd_setting_reg,\n    input   [15:0]  status_reg,\n    input   [31:0]  cmd_resp_1,\n    output  [7:0]   software_reset_reg,\n    output  [15:0]  time_out_reg,\n    input   [15:0]  normal_int_status_reg,\n    input   [15:0]  error_int_status_reg,\n    output  [15:0]  normal_int_signal_enable_reg,\n    output  [15:0]  error_int_signal_enable_reg,\n    output  [7:0]   clock_divider,\n    input   [15:0]  Bd_Status_reg,\n    input   [7:0]   Bd_isr_reg,\n    output  [7:0]   Bd_isr_enable_reg,\n    output          Bd_isr_reset,\n    output          normal_isr_reset,\n    output          error_isr_reset,\n    output  [RAM_MEM_WIDTH-1:0]  dat_in_m_tx_bd,\n    output  [RAM_MEM_WIDTH-1:0]  dat_in_m_rx_bd\n);\n\n    // Internal registers\n    reg [31:0] argument_reg_i;\n    reg [15:0] cmd_setting_reg_i;\n    reg [7:0] software_reset_reg_i;\n    reg [15:0] time_out_reg_i;\n    reg [15:0] normal_int_signal_enable_reg_i;\n    reg [15:0] error_int_signal_enable_reg_i;\n    reg [7:0] clock_divider_i;\n    reg [7:0] Bd_isr_enable_reg_i;\n\n    // Internal signals\n    reg we_m_tx_bd_i;\n    reg we_m_rx_bd_i;\n    reg new_cmd_i;\n    reg we_ack_i;\n    reg int_ack_i;\n    reg cmd_int_busy_i;\n    reg int_busy_i;\n\n    // Assign outputs\n    assign wb_dat_o = (wb_adr_i == 8'h00) ? argument_reg_i :\n                      (wb_adr_i == 8'h04) ? {16'h0, cmd_setting_reg_i} :\n                      (wb_adr_i == 8'h08) ? {16'h0, status_reg} :\n                      (wb_adr_i == 8'h0c) ? cmd_resp_1 :\n                      (wb_adr_i == 8'h1c) ? 16'h0 :\n                      (wb_adr_i == 8'h20) ? 16'h200 :\n                      (wb_adr_i == 8'h24) ? {24'h0, 8'h0f} :\n                      (wb_adr_i == 8'h28) ? {24'h0, software_reset_reg_i} :\n                      (wb_adr_i == 8'h2c) ? {16'h0, time_out_reg_i} :\n                      (wb_adr_i == 8'h30) ? {16'h0, normal_int_status_reg} :\n                      (wb_adr_i == 8'h34) ? {16'h0, error_int_status_reg} :\n                      (wb_adr_i == 8'h38) ? {16'h0, normal_int_signal_enable_reg_i} :\n                      (wb_adr_i == 8'h3c) ? {16'h0, error_int_signal_enable_reg_i} :\n                      (wb_adr_i == 8'h48) ? {24'h0, clock_divider_i} :\n                      (wb_adr_i == 8'h50) ? {16'h0, Bd_Status_reg} :\n                      (wb_adr_i == 8'h54) ? {24'h0, Bd_isr_reg} :\n                      (wb_adr_i == 8'h58) ? {24'h0, Bd_isr_enable_reg_i} :\n                      32'h0;\n\n    assign we_m_tx_bd = we_m_tx_bd_i;\n    assign we_m_rx_bd = we_m_rx_bd_i;\n    assign new_cmd = new_cmd_i;\n    assign we_ack = we_ack_i;\n    assign int_ack = int_ack_i;\n    assign cmd_int_busy = cmd_int_busy_i;\n    assign int_busy = int_busy_i;\n\n    // Reset logic\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            argument_reg_i <= 32'h0;\n            cmd_setting_reg_i <= 16'h0;\n            software_reset_reg_i <= 8'h0;\n            time_out_reg_i <= 16'h0;\n            normal_int_signal_enable_reg_i <= 16'h0;\n            error_int_signal_enable_reg_i <= 16'h0;\n            clock_divider_i <= 8'h0;\n            Bd_isr_enable_reg_i <= 8'h0;\n            we_m_tx_bd_i <= 1'b0;\n            we_m_rx_bd_i <= 1'b0;\n            new_cmd_i <= 1'b0;\n            we_ack_i <= 1'b0;\n            int_ack_i <= 1'b1;\n            cmd_int_busy_i <= 1'b0;\n            int_busy_i <= 1'b0;\n        end else begin\n            // Write logic\n            if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg_i <= wb_dat_i;\n                    8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                    8'h48: clock_divider_i <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n                    8'h60: begin\n                        if (RAM_MEM_WIDTH == 16) begin\n                            dat_in_m_rx_bd <= wb_dat_i[15:0];\n                        end else begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end\n                    end\n                    8'h80: begin\n                        if (RAM_MEM_WIDTH == 16) begin\n                            dat_in_m_tx_bd <= wb_dat_i[15:0];\n                        end else begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                        end\n                    end\n                endcase\n            end\n\n            // Update internal signals\n            if (write_req_s) begin\n                we_ack_i <= 1'b1;\n            end else begin\n                we_ack_i <= 1'b0;\n            end\n\n            if (wb_stb_i && wb_cyc_i && ~wb_we_i && (wb_adr_i == 8'h04 || wb_adr_i == 8'h00)) begin\n                cmd_int_busy_i <= 1'b1;\n            end else begin\n                cmd_int_busy_i <= 1'b0;\n            end\n\n            if (wb_stb_i && wb_cyc_i && ~wb_we_i && wb_adr_i == 8'h00) begin\n                int_busy_i <= 1'b1;\n            end else begin\n                int_busy_i <= 1'b0;\n            end\n\n            if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h00 || wb_adr_i == 8'h04)) begin\n                new_cmd_i <= 1'b1;\n            end else begin\n                new_cmd_i <= 1'b0;\n            end\n\n            if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n                we_m_tx_bd_i <= 1'b1;\n                we_m_rx_bd_i <= 1'b1;\n                int_ack_i <= 1'b0;\n            end else begin\n                we_m_tx_bd_i <= 1'b0;\n                we_m_rx_bd_i <= 1'b0;\n                int_ack_i <= 1'b1;\n            end\n        end\n    end\n\n    // Acknowledge logic\n    always @(posedge wb_clk_i) begin\n        if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack_i) begin\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // WISHBONE slave interface\n    input           wb_clk_i,    // Slave WISHBONE Clock Input\n    input           wb_rst_i,    // Slave WISHBONE Reset Input\n    input   [31:0]  wb_dat_i,    // Slave WISHBONE Data Inputs\n    output  [31:0]  wb_dat_o,    // Slave WISHBONE Data Outputs\n    input   [ 7:0]  wb_adr_i,    // Slave WISHBONE Address Input\n    input   [ 3:0]  wb_sel_i,    // Slave WISHBONE Select Input\n    input           wb_we_i,     // Slave WISHBONE Write Enable\n    input           wb_cyc_i,    // Slave WISHBONE Cycle\n    input           wb_stb_i,    // Slave WISHBONE Strobe\n    output          wb_ack_o,    // Slave WISHBONE Acknowledge\n\n    // Control and status signals\n    output          we_m_tx_bd,  // Write enable TIx BD\n    output          we_m_rx_bd,  // Write enable Rx BD\n    output          new_cmd,     // New command indication signal\n    output          we_ack,      // Ack on cmd access request\n    output          int_ack,     // Internal Delayed Acknowledge\n    output          cmd_int_busy,// Cmd busy by data module\n    output          int_busy,    // Command Busy by data module\n\n    // Data master interface\n    input           write_req_s, // Cmd access request\n    input   [15:0]  cmd_set_s,   // Command setting input from data master\n    input   [31:0]  cmd_arg_s,   // Command argument input from data master\n\n    // Registers\n    output  [31:0]  argument_reg,// Command Argument Reg\n    output  [15:0]  cmd_setting_reg,// Command Setting Reg\n    input   [15:0]  status_reg,  // Card Status Reg\n    input   [31:0]  cmd_resp_1,  // Command Response\n    output  [ 7:0]  software_reset_reg,// Software reset Reg\n    output  [15:0]  time_out_reg, // Timeout Reg\n    input   [15:0]  normal_int_status_reg,// Normal Interrupt Status Reg\n    input   [15:0]  error_int_status_reg,// Error Interrupt Status Reg\n    output  [15:0]  normal_int_signal_enable_reg,// Normal Interrupt Enable Reg\n    output  [15:0]  error_int_signal_enable_reg,// Error Interrupt Enable Reg\n    output  [ 7:0]  clock_divider, // Clock Divider Reg\n    input   [15:0]  Bd_Status_reg,// BD Status Reg\n    input   [ 7:0]  Bd_isr_reg,  // Data Interrupt Status Reg\n    output  [ 7:0]  Bd_isr_enable_reg,// Data Interrupt Enable Reg\n    output          Bd_isr_reset, // Reset data interrupt status\n    output          normal_isr_reset,// Reset normal interrupt status\n    output          error_isr_reset,// Reset error interrupt status\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd, // Data going to the Tx BD\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd  // Data going to the RX BD\n);\n\n// Internal registers\nreg [31:0] argument_reg_i;\nreg [15:0] cmd_setting_reg_i;\nreg [15:0] status_reg_i;\nreg [31:0] cmd_resp_1_i;\nreg [7:0] software_reset_reg_i;\nreg [15:0] time_out_reg_i;\nreg [15:0] normal_int_status_reg_i;\nreg [15:0] error_int_status_reg_i;\nreg [15:0] normal_int_signal_enable_reg_i;\nreg [15:0] error_int_signal_enable_reg_i;\nreg [7:0] clock_divider_i;\nreg [15:0] Bd_Status_reg_i;\nreg [7:0] Bd_isr_reg_i;\nreg [7:0] Bd_isr_enable_reg_i;\n\n// Internal signals\nreg we_m_tx_bd_i;\nreg we_m_rx_bd_i;\nreg new_cmd_i;\nreg we_ack_i;\nreg int_ack_i;\nreg cmd_int_busy_i;\nreg int_busy_i;\n\n// Assign outputs\nassign wb_dat_o = (wb_adr_i == 8'h00) ? argument_reg_i :\n                  (wb_adr_i == 8'h04) ? {16'h0, cmd_setting_reg_i} :\n                  (wb_adr_i == 8'h08) ? {16'h0, status_reg_i} :\n                  (wb_adr_i == 8'h0c) ? cmd_resp_1_i :\n                  (wb_adr_i == 8'h28) ? {24'h0, software_reset_reg_i} :\n                  (wb_adr_i == 8'h2c) ? {16'h0, time_out_reg_i} :\n                  (wb_adr_i == 8'h30) ? {16'h0, normal_int_status_reg_i} :\n                  (wb_adr_i == 8'h34) ? {16'h0, error_int_status_reg_i} :\n                  (wb_adr_i == 8'h38) ? {16'h0, normal_int_signal_enable_reg_i} :\n                  (wb_adr_i == 8'h3c) ? {16'h0, error_int_signal_enable_reg_i} :\n                  (wb_adr_i == 8'h4c) ? {24'h0, clock_divider_i} :\n                  (wb_adr_i == 8'h50) ? {16'h0, Bd_Status_reg_i} :\n                  (wb_adr_i == 8'h54) ? {24'h0, Bd_isr_reg_i} :\n                  (wb_adr_i == 8'h58) ? {24'h0, Bd_isr_enable_reg_i} :\n                  32'h0;\n\nassign we_m_tx_bd = we_m_tx_bd_i;\nassign we_m_rx_bd = we_m_rx_bd_i;\nassign new_cmd = new_cmd_i;\nassign we_ack = we_ack_i;\nassign int_ack = int_ack_i;\nassign cmd_int_busy = cmd_int_busy_i;\nassign int_busy = int_busy_i;\n\nassign argument_reg = argument_reg_i;\nassign cmd_setting_reg = cmd_setting_reg_i;\nassign software_reset_reg = software_reset_reg_i;\nassign time_out_reg = time_out_reg_i;\nassign normal_int_signal_enable_reg = normal_int_signal_enable_reg_i;\nassign error_int_signal_enable_reg = error_int_signal_enable_reg_i;\nassign clock_divider = clock_divider_i;\nassign Bd_isr_enable_reg = Bd_isr_enable_reg_i;\n\n// Internal logic\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        // Reset all internal registers and signals\n        argument_reg_i <= 32'h0;\n        cmd_setting_reg_i <= 16'h0;\n        status_reg_i <= 16'h0;\n        cmd_resp_1_i <= 32'h0;\n        software_reset_reg_i <= 8'h0;\n        time_out_reg_i <= 16'h0;\n        normal_int_status_reg_i <= 16'h0;\n        error_int_status_reg_i <= 16'h0;\n        normal_int_signal_enable_reg_i <= 16'h0;\n        error_int_signal_enable_reg_i <= 16'h0;\n        clock_divider_i <= 8'h0;\n        Bd_Status_reg_i <= 16'h0;\n        Bd_isr_reg_i <= 8'h0;\n        Bd_isr_enable_reg_i <= 8'h0;\n        we_m_tx_bd_i <= 1'b0;\n        we_m_rx_bd_i <= 1'b0;\n        new_cmd_i <= 1'b0;\n        we_ack_i <= 1'b0;\n        int_ack_i <= 1'b1;\n        cmd_int_busy_i <= 1'b0;\n        int_busy_i <= 1'b0;\n    end else begin\n        // Register write logic\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg_i <= wb_dat_i;\n                8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n                8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n                8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n                8'h30: normal_int_status_reg_i <= 16'h0;\n                8'h34: error_int_status_reg_i <= 16'h0;\n                8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h4c: clock_divider_i <= wb_dat_i[7:0];\n                8'h54: Bd_isr_reg_i <= 8'h0;\n                8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n                8'h60: begin\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                end\n                8'h80: begin\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_tx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                end\n            endcase\n        end\n\n        // Register read logic\n        if (wb_stb_i && wb_cyc_i) begin\n            // Update internal signals\n            we_m_tx_bd_i <= (wb_adr_i == 8'h80) ? 1'b1 : 1'b0;\n            we_m_rx_bd_i <= (wb_adr_i == 8'h60) ? 1'b1 : 1'b0;\n            new_cmd_i <= (wb_adr_i == 8'h00) ? 1'b1 : 1'b0;\n            we_ack_i <= write_req_s ? 1'b1 : 1'b0;\n            int_ack_i <= (wb_adr_i == 8'h60 || wb_adr_i == 8'h80) ? 1'b0 : 1'b1;\n            cmd_int_busy_i <= (wb_adr_i == 8'h00 || wb_adr_i == 8'h04) ? 1'b1 : 1'b0;\n            int_busy_i <= (wb_adr_i == 8'h04) ? 1'b1 : 1'b0;\n        end\n    end\nend\n\n// Assign wb_ack_o\nassign wb_ack_o = wb_cyc_i && wb_stb_i && !wb_ack_o && int_ack_i;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // WISHBONE slave interface\n    input           wb_clk_i,    // Slave WISHBONE Clock Input\n    input           wb_rst_i,    // Slave WISHBONE Reset Input\n    input   [31:0]  wb_dat_i,    // Slave WISHBONE Data Inputs\n    output  [31:0]  wb_dat_o,    // Slave WISHBONE Data Outputs\n    input   [ 7:0]  wb_adr_i,    // Slave WISHBONE Address Input\n    input   [ 3:0]  wb_sel_i,    // Slave WISHBONE Select Input\n    input           wb_we_i,     // Slave WISHBONE Write Enable\n    input           wb_cyc_i,    // Slave WISHBONE Cycle\n    input           wb_stb_i,    // Slave WISHBONE Strobe\n    output          wb_ack_o,    // Slave WISHBONE Acknowledge\n\n    // Other signals\n    output          we_m_tx_bd,  // Write enable TX BD\n    output          we_m_rx_bd,  // Write enable RX BD\n    output          new_cmd,     // New command indication signal\n    output          we_ack,      // Ack on cmd access request\n    output          int_ack,     // Internal Delayed Acknowledge\n    output          cmd_int_busy,// Cmd busy by data module\n    output          int_busy,    // Command Busy by data module\n    input           write_req_s, // Cmd access request\n    input   [15:0]  cmd_set_s,   // Command setting input from data master\n    input   [31:0]  cmd_arg_s,   // Command argument input from data master\n    output  [31:0]  argument_reg,// Command Argument Reg\n    output  [15:0]  cmd_setting_reg,// Command Setting Reg\n    input   [15:0]  status_reg,  // Card Status Reg\n    input   [31:0]  cmd_resp_1,  // Command Response\n    output  [ 7:0]  software_reset_reg,// Software reset Reg\n    output  [15:0]  time_out_reg, // Timeout Reg\n    input   [15:0]  normal_int_status_reg,// Normal Interrupt Status Reg\n    input   [15:0]  error_int_status_reg,// Error Interrupt Status Reg\n    output  [15:0]  normal_int_signal_enable_reg,// Normal Interrupt Enable Reg\n    output  [15:0]  error_int_signal_enable_reg,// Error Interrupt Enable Reg\n    output  [ 7:0]  clock_divider, // Clock Divider Reg\n    input   [15:0]  Bd_Status_reg,// BD Status Reg\n    input   [ 7:0]  Bd_isr_reg,   // Data Interrupt Status Reg\n    output  [ 7:0]  Bd_isr_enable_reg,// Data Interrupt Enable Reg\n    output          Bd_isr_reset, // Reset data interrupt status\n    output          normal_isr_reset,// Reset normal interrupt status\n    output          error_isr_reset,// Reset error interrupt status\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd, // Data going to the Tx BD\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd  // Data going to the RX BD\n);\n\n// Internal variables\nreg [31:0] argument_reg_i;\nreg [15:0] cmd_setting_reg_i;\nreg [15:0] status_reg_i;\nreg [31:0] cmd_resp_1_i;\nreg [7:0] software_reset_reg_i;\nreg [15:0] time_out_reg_i;\nreg [15:0] normal_int_status_reg_i;\nreg [15:0] error_int_status_reg_i;\nreg [15:0] normal_int_signal_enable_reg_i;\nreg [15:0] error_int_signal_enable_reg_i;\nreg [7:0] clock_divider_i;\nreg [15:0] Bd_Status_reg_i;\nreg [7:0] Bd_isr_reg_i;\nreg [7:0] Bd_isr_enable_reg_i;\n\n// Reset logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg_i <= 32'd0;\n        cmd_setting_reg_i <= 16'd0;\n        status_reg_i <= 16'd0;\n        cmd_resp_1_i <= 32'd0;\n        software_reset_reg_i <= 8'd0;\n        time_out_reg_i <= 16'd0;\n        normal_int_status_reg_i <= 16'd0;\n        error_int_status_reg_i <= 16'd0;\n        normal_int_signal_enable_reg_i <= 16'd0;\n        error_int_signal_enable_reg_i <= 16'd0;\n        clock_divider_i <= 8'd0;\n        Bd_Status_reg_i <= 16'd0;\n        Bd_isr_reg_i <= 8'd0;\n        Bd_isr_enable_reg_i <= 8'd0;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end else begin\n        // Update registers based on WISHBONE interface\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg_i <= wb_dat_i;\n                8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n                8'h08: status_reg_i <= wb_dat_i[15:0];\n                8'h0c: cmd_resp_1_i <= wb_dat_i;\n                8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n                8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n                8'h30: normal_int_status_reg_i <= wb_dat_i[15:0];\n                8'h34: error_int_status_reg_i <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h4c: clock_divider_i <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n                default: ;\n            endcase\n        end\n    end\nend\n\n// WISHBONE output logic\nalways @(*) begin\n    wb_dat_o = 32'd0;\n    case (wb_adr_i)\n        8'h00: wb_dat_o = argument_reg_i;\n        8'h04: wb_dat_o[15:0] = cmd_setting_reg_i;\n        8'h08: wb_dat_o[15:0] = status_reg_i;\n        8'h0c: wb_dat_o = cmd_resp_1_i;\n        8'h28: wb_dat_o[7:0] = software_reset_reg_i;\n        8'h2c: wb_dat_o[15:0] = time_out_reg_i;\n        8'h30: wb_dat_o[15:0] = normal_int_status_reg_i;\n        8'h34: wb_dat_o[15:0] = error_int_status_reg_i;\n        8'h38: wb_dat_o[15:0] = normal_int_signal_enable_reg_i;\n        8'h3c: wb_dat_o[15:0] = error_int_signal_enable_reg_i;\n        8'h4c: wb_dat_o[7:0] = clock_divider_i;\n        8'h50: wb_dat_o[15:0] = Bd_Status_reg_i;\n        8'h54: wb_dat_o[7:0] = Bd_isr_reg_i;\n        8'h58: wb_dat_o[7:0] = Bd_isr_enable_reg_i;\n        default: ;\n    endcase\nend\n\n// Other output logic\nalways @(*) begin\n    we_m_tx_bd = 1'b0;\n    we_m_rx_bd = 1'b0;\n    new_cmd = 1'b0;\n    we_ack = 1'b0;\n    cmd_int_busy = 1'b0;\n    int_busy = 1'b0;\n    Bd_isr_reset = 1'b0;\n    normal_isr_reset = 1'b0;\n    error_isr_reset = 1'b0;\n    int_ack = 1'b1;\n    if (write_req_s) begin\n        we_ack = 1'b1;\n    end\n    if (wb_stb_i && wb_cyc_i && ~wb_we_i) begin\n        case (wb_adr_i)\n            8'h60: begin\n                we_m_rx_bd = 1'b1;\n                int_ack = 1'b0;\n            end\n            8'h80: begin\n                we_m_tx_bd = 1'b1;\n                int_ack = 1'b0;\n            end\n            default: ;\n        endcase\n    end\n    if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n        case (wb_adr_i)\n            8'h04: cmd_int_busy = 1'b1;\n            8'h00: new_cmd = 1'b1;\n            default: ;\n        endcase\n    end\nend\n\n// Acknowledge logic\nalways @(*) begin\n    wb_ack_o = 1'b0;\n    if (wb_stb_i && wb_cyc_i && int_ack) begin\n        wb_ack_o = 1'b1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 7, "code": "module sd_controller_wb(\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input  [31:0]       wb_dat_i,\n    output [31:0]       wb_dat_o,\n    input  [7:0]        wb_adr_i,\n    input  [3:0]        wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output              wb_ack_o,\n    output              we_m_tx_bd,\n    output              we_m_rx_bd,\n    output              new_cmd,\n    output              we_ack,\n    output              int_ack,\n    output              cmd_int_busy,\n    output              int_busy,\n    input               write_req_s,\n    input  [15:0]       cmd_set_s,\n    input  [31:0]       cmd_arg_s,\n    output [31:0]       argument_reg,\n    output [15:0]       cmd_setting_reg,\n    input  [15:0]       status_reg,\n    input  [31:0]       cmd_resp_1,\n    output [7:0]        software_reset_reg,\n    output [15:0]       time_out_reg,\n    input  [15:0]       normal_int_status_reg,\n    input  [15:0]       error_int_status_reg,\n    output [15:0]       normal_int_signal_enable_reg,\n    output [15:0]       error_int_signal_enable_reg,\n    output [7:0]        clock_divider,\n    input  [15:0]       Bd_Status_reg,\n    input  [7:0]        Bd_isr_reg,\n    output [7:0]        Bd_isr_enable_reg,\n    output              Bd_isr_reset,\n    output              normal_isr_reset,\n    output              error_isr_reset,\n    output [31:0]       dat_in_m_tx_bd,\n    output [31:0]       dat_in_m_rx_bd\n);\n\nreg [31:0] argument_reg_reg;\nreg [15:0] cmd_setting_reg_reg;\nreg [7:0] software_reset_reg_reg;\nreg [15:0] time_out_reg_reg;\nreg [15:0] normal_int_signal_enable_reg_reg;\nreg [15:0] error_int_signal_enable_reg_reg;\nreg [7:0] clock_divider_reg;\nreg [7:0] Bd_isr_enable_reg_reg;\n\nassign argument_reg = argument_reg_reg;\nassign cmd_setting_reg = cmd_setting_reg_reg;\nassign software_reset_reg = software_reset_reg_reg;\nassign time_out_reg = time_out_reg_reg;\nassign normal_int_signal_enable_reg = normal_int_signal_enable_reg_reg;\nassign error_int_signal_enable_reg = error_int_signal_enable_reg_reg;\nassign clock_divider = clock_divider_reg;\nassign Bd_isr_enable_reg = Bd_isr_enable_reg_reg;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        argument_reg_reg <= 32'd0;\n        cmd_setting_reg_reg <= 16'd0;\n        software_reset_reg_reg <= 8'd0;\n        time_out_reg_reg <= 16'd0;\n        normal_int_signal_enable_reg_reg <= 16'd0;\n        error_int_signal_enable_reg_reg <= 16'd0;\n        clock_divider_reg <= 8'd0;\n        Bd_isr_enable_reg_reg <= 8'd0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg_reg <= wb_dat_i[15:0];\n                8'h28: software_reset_reg_reg <= wb_dat_i[7:0];\n                8'h2c: time_out_reg_reg <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg_reg <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg_reg <= wb_dat_i[15:0];\n                8'h4c: clock_divider_reg <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg_reg <= wb_dat_i[7:0];\n            endcase\n        end\n    end\nend\n\nassign wb_dat_o = (wb_adr_i == 8'h00) ? argument_reg_reg :\n                  (wb_adr_i == 8'h04) ? {16'd0, cmd_setting_reg_reg} :\n                  (wb_adr_i == 8'h08) ? {16'd0, status_reg} :\n                  (wb_adr_i == 8'h0c) ? cmd_resp_1 :\n                  (wb_adr_i == 8'h28) ? {24'd0, software_reset_reg_reg} :\n                  (wb_adr_i == 8'h2c) ? {16'd0, time_out_reg_reg} :\n                  (wb_adr_i == 8'h30) ? {16'd0, normal_int_status_reg} :\n                  (wb_adr_i == 8'h34) ? {16'd0, error_int_status_reg} :\n                  (wb_adr_i == 8'h38) ? {16'd0, normal_int_signal_enable_reg_reg} :\n                  (wb_adr_i == 8'h3c) ? {16'd0, error_int_signal_enable_reg_reg} :\n                  (wb_adr_i == 8'h4c) ? {24'd0, clock_divider_reg} :\n                  (wb_adr_i == 8'h50) ? {16'd0, Bd_Status_reg} :\n                  (wb_adr_i == 8'h54) ? {24'd0, Bd_isr_reg} :\n                  (wb_adr_i == 8'h58) ? {24'd0, Bd_isr_enable_reg_reg} :\n                  32'd0;\n\nreg int_ack_reg;\nreg we_m_tx_bd_reg;\nreg we_m_rx_bd_reg;\nreg new_cmd_reg;\nreg we_ack_reg;\nreg cmd_int_busy_reg;\nreg int_busy_reg;\n\nassign int_ack = int_ack_reg;\nassign we_m_tx_bd = we_m_tx_bd_reg;\nassign we_m_rx_bd = we_m_rx_bd_reg;\nassign new_cmd = new_cmd_reg;\nassign we_ack = we_ack_reg;\nassign cmd_int_busy = cmd_int_busy_reg;\nassign int_busy = int_busy_reg;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        int_ack_reg <= 1'b1;\n        we_m_tx_bd_reg <= 1'b0;\n        we_m_rx_bd_reg <= 1'b0;\n        new_cmd_reg <= 1'b0;\n        we_ack_reg <= 1'b0;\n        cmd_int_busy_reg <= 1'b0;\n        int_busy_reg <= 1'b0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h60: begin\n                    we_m_rx_bd_reg <= 1'b1;\n                    int_ack_reg <= 1'b0;\n                end\n                8'h80: begin\n                    we_m_tx_bd_reg <= 1'b1;\n                    int_ack_reg <= 1'b0;\n                end\n            endcase\n        end else if (~wb_stb_i || ~wb_cyc_i || ~wb_we_i) begin\n            we_m_tx_bd_reg <= 1'b0;\n            we_m_rx_bd_reg <= 1'b0;\n            int_ack_reg <= 1'b1;\n        end\n        if (write_req_s) begin\n            we_ack_reg <= 1'b1;\n        end else begin\n            we_ack_reg <= 1'b0;\n        end\n        if (wb_adr_i == 8'h00 || wb_adr_i == 8'h04) begin\n            cmd_int_busy_reg <= 1'b1;\n        end else begin\n            cmd_int_busy_reg <= 1'b0;\n        end\n        if (wb_adr_i == 8'h04) begin\n            int_busy_reg <= 1'b1;\n        end else begin\n            int_busy_reg <= 1'b0;\n        end\n        if (wb_adr_i == 8'h00) begin\n            new_cmd_reg <= 1'b1;\n        end else begin\n            new_cmd_reg <= 1'b0;\n        end\n    end\nend\n\nassign wb_ack_o = wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // WISHBONE slave interface\n    input  wire            wb_clk_i,\n    input  wire            wb_rst_i,\n    input  wire [31:0]     wb_dat_i,\n    output wire [31:0]     wb_dat_o,\n    input  wire [7:0]      wb_adr_i,\n    input  wire [3:0]      wb_sel_i,\n    input  wire            wb_we_i,\n    input  wire            wb_cyc_i,\n    input  wire            wb_stb_i,\n    output wire            wb_ack_o,\n\n    // Other signals\n    output wire            we_m_tx_bd,\n    output wire            we_m_rx_bd,\n    output wire            new_cmd,\n    output wire            we_ack,\n    output wire            int_ack,\n    output wire            cmd_int_busy,\n    output wire            int_busy,\n    input  wire            write_req_s,\n    input  wire [15:0]     cmd_set_s,\n    input  wire [31:0]     cmd_arg_s,\n    output wire [31:0]     argument_reg,\n    output wire [15:0]     cmd_setting_reg,\n    input  wire [15:0]     status_reg,\n    input  wire [31:0]     cmd_resp_1,\n    output wire [7:0]      software_reset_reg,\n    output wire [15:0]     time_out_reg,\n    input  wire [15:0]     normal_int_status_reg,\n    input  wire [15:0]     error_int_status_reg,\n    output wire [15:0]     normal_int_signal_enable_reg,\n    output wire [15:0]     error_int_signal_enable_reg,\n    output wire [7:0]      clock_divider,\n    input  wire [15:0]     Bd_Status_reg,\n    input  wire [7:0]      Bd_isr_reg,\n    output wire [7:0]      Bd_isr_enable_reg,\n    output wire            Bd_isr_reset,\n    output wire            normal_isr_reset,\n    output wire            error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n// Internal signals\nreg [31:0] argument_reg_i;\nreg [15:0] cmd_setting_reg_i;\nreg [7:0] software_reset_reg_i;\nreg [15:0] time_out_reg_i;\nreg [15:0] normal_int_signal_enable_reg_i;\nreg [15:0] error_int_signal_enable_reg_i;\nreg [7:0] clock_divider_i;\nreg [7:0] Bd_isr_enable_reg_i;\nreg int_ack_i;\nreg we_m_tx_bd_i;\nreg we_m_rx_bd_i;\n\n// Assign outputs\nassign wb_dat_o = (wb_adr_i == 8'h00) ? argument_reg_i :\n                  (wb_adr_i == 8'h04) ? {16'h0, cmd_setting_reg_i} :\n                  (wb_adr_i == 8'h08) ? {16'h0, status_reg} :\n                  (wb_adr_i == 8'h0c) ? cmd_resp_1 :\n                  (wb_adr_i == 8'h28) ? {24'h0, software_reset_reg_i} :\n                  (wb_adr_i == 8'h2c) ? {16'h0, time_out_reg_i} :\n                  (wb_adr_i == 8'h38) ? {16'h0, normal_int_signal_enable_reg_i} :\n                  (wb_adr_i == 8'h3c) ? {16'h0, error_int_signal_enable_reg_i} :\n                  (wb_adr_i == 8'h4c) ? {24'h0, clock_divider_i} :\n                  (wb_adr_i == 8'h58) ? {24'h0, Bd_isr_enable_reg_i} :\n                  32'h0;\n\nassign argument_reg = argument_reg_i;\nassign cmd_setting_reg = cmd_setting_reg_i;\nassign software_reset_reg = software_reset_reg_i;\nassign time_out_reg = time_out_reg_i;\nassign normal_int_signal_enable_reg = normal_int_signal_enable_reg_i;\nassign error_int_signal_enable_reg = error_int_signal_enable_reg_i;\nassign clock_divider = clock_divider_i;\nassign Bd_isr_enable_reg = Bd_isr_enable_reg_i;\n\n// Internal logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg_i <= 32'h0;\n        cmd_setting_reg_i <= 16'h0;\n        software_reset_reg_i <= 8'h0;\n        time_out_reg_i <= 16'h0;\n        normal_int_signal_enable_reg_i <= 16'h0;\n        error_int_signal_enable_reg_i <= 16'h0;\n        clock_divider_i <= 8'h0;\n        Bd_isr_enable_reg_i <= 8'h0;\n        int_ack_i <= 1'b1;\n        we_m_tx_bd_i <= 1'b0;\n        we_m_rx_bd_i <= 1'b0;\n    end else begin\n        // Update registers based on WISHBONE signals\n        if (wb_cyc_i && wb_stb_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg_i <= wb_dat_i;\n                8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n                8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n                8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h4c: clock_divider_i <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n                default: ;\n            endcase\n        end\n\n        // Update int_ack signal\n        if (wb_cyc_i && wb_stb_i && wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n            int_ack_i <= 1'b0;\n        end else if (int_ack_i == 1'b0) begin\n            int_ack_i <= 1'b1;\n        end\n\n        // Update we_m_tx_bd and we_m_rx_bd signals\n        if (wb_cyc_i && wb_stb_i && wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n            we_m_tx_bd_i <= 1'b1;\n            we_m_rx_bd_i <= 1'b1;\n        end else begin\n            we_m_tx_bd_i <= 1'b0;\n            we_m_rx_bd_i <= 1'b0;\n        end\n    end\nend\n\nassign int_ack = int_ack_i;\nassign we_m_tx_bd = we_m_tx_bd_i;\nassign we_m_rx_bd = we_m_rx_bd_i;\n\n// Other logic\nalways @(posedge wb_clk_i) begin\n    if (wb_cyc_i && wb_stb_i && wb_we_i) begin\n        case (wb_adr_i)\n            8'h60: dat_in_m_rx_bd <= wb_dat_i;\n            8'h80: dat_in_m_tx_bd <= wb_dat_i;\n            default: ;\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 9, "code": "// sd_controller_wb module\nmodule sd_controller_wb(\n    // WISHBONE signals\n    input  wire        wb_clk_i,    // Slave WISHBONE Clock Input\n    input  wire        wb_rst_i,    // Slave WISHBONE Reset Input\n    input  wire [31:0] wb_dat_i,    // Slave WISHBONE Data Inputs\n    output wire [31:0] wb_dat_o,    // Slave WISHBONE Data Outputs\n    input  wire [7:0]  wb_adr_i,    // Slave WISHBONE Address Input\n    input  wire [3:0]  wb_sel_i,    // Slave WISHBONE Select Input\n    input  wire        wb_we_i,     // Slave WISHBONE Write Enable\n    input  wire        wb_cyc_i,    // Slave WISHBONE Cycle\n    input  wire        wb_stb_i,    // Slave WISHBONE Strobe\n    output wire        wb_ack_o,    // Slave WISHBONE Acknowledge\n\n    // Other signals\n    output wire        we_m_tx_bd,  // Write enable TIx BD\n    output wire        we_m_rx_bd,  // Write enable Rx BD\n    output wire        new_cmd,     // New command indication signal\n    output wire        we_ack,      // Ack on cmd access request\n    output wire        int_ack,     // Internal Delayed Acknowledge\n    output wire        cmd_int_busy, // Cmd busy by data module\n    output wire        int_busy,    // Command Busy by data module\n    input  wire        write_req_s, // Cmd access request\n    input  wire [15:0] cmd_set_s,   // Command setting input from data master\n    input  wire [31:0] cmd_arg_s,   // Command argument input from data master\n    output wire [31:0] argument_reg, // Command Argument Reg\n    output wire [15:0] cmd_setting_reg, // Command Setting Reg\n    input  wire [15:0] status_reg,  // Card Status Reg\n    input  wire [31:0] cmd_resp_1,  // Command Response\n    output wire [7:0]  software_reset_reg, // Software reset Reg\n    output wire [15:0] time_out_reg, // Timeout Reg\n    input  wire [15:0] normal_int_status_reg, // Normal Interrupt Status Reg\n    input  wire [15:0] error_int_status_reg, // Error Interrupt Status Reg\n    output wire [15:0] normal_int_signal_enable_reg, // Normal Interrupt Enable Reg\n    output wire [15:0] error_int_signal_enable_reg, // Error Interrupt Enable Reg\n    output wire [7:0]  clock_divider, // Clock Divider Reg\n    input  wire [15:0] Bd_Status_reg, // BD Status Reg\n    input  wire [7:0]  Bd_isr_reg,   // Data Interrupt Status Reg\n    output wire [7:0]  Bd_isr_enable_reg, // Data Interrupt Enable Reg\n    output wire        Bd_isr_reset, // Reset data interrupt status\n    output wire        normal_isr_reset, // Reset normal interrupt status\n    output wire        error_isr_reset, // Reset error interrupt status\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd, // Data going to the Tx BD\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd  // Data going to the RX BD\n);\n\n// Register declarations\nreg [31:0] argument_reg;\nreg [15:0] cmd_setting_reg;\nreg [15:0] status_reg;\nreg [31:0] cmd_resp_1;\nreg [7:0]  software_reset_reg;\nreg [15:0] time_out_reg;\nreg [15:0] normal_int_status_reg;\nreg [15:0] error_int_status_reg;\nreg [15:0] normal_int_signal_enable_reg;\nreg [15:0] error_int_signal_enable_reg;\nreg [7:0]  clock_divider;\nreg [15:0] Bd_Status_reg;\nreg [7:0]  Bd_isr_reg;\nreg [7:0]  Bd_isr_enable_reg;\n\n// Internal signals\nreg int_ack;\nreg we_m_rx_bd;\nreg we_m_tx_bd;\n\n// Reset logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg <= 32'd0;\n        cmd_setting_reg <= 16'd0;\n        status_reg <= 16'd0;\n        cmd_resp_1 <= 32'd0;\n        software_reset_reg <= 8'd0;\n        time_out_reg <= 16'd0;\n        normal_int_status_reg <= 16'd0;\n        error_int_status_reg <= 16'd0;\n        normal_int_signal_enable_reg <= 16'd0;\n        error_int_signal_enable_reg <= 16'd0;\n        clock_divider <= 8'd0;\n        Bd_Status_reg <= 16'd0;\n        Bd_isr_reg <= 8'd0;\n        Bd_isr_enable_reg <= 8'd0;\n        int_ack <= 1'b1;\n        we_m_rx_bd <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n    end else begin\n        // Update registers based on WISHBONE signals\n        if (wb_stb_i && wb_cyc_i && !wb_ack_o && int_ack) begin\n            case (wb_adr_i)\n                8'h00: argument_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                8'h08: status_reg <= wb_dat_i[15:0];\n                8'h0c: cmd_resp_1 <= wb_dat_i;\n                8'h28: software_reset_reg <= wb_dat_i[7:0];\n                8'h2c: time_out_reg <= wb_dat_i[15:0];\n                8'h30: normal_int_status_reg <= wb_dat_i[15:0];\n                8'h34: error_int_status_reg <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h4c: clock_divider <= wb_dat_i[7:0];\n                8'h50: Bd_Status_reg <= wb_dat_i[15:0];\n                8'h54: Bd_isr_reg <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                default: ;\n            endcase\n        end\n    end\nend\n\n// WISHBONE acknowledge logic\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && !wb_ack_o && int_ack) begin\n        wb_ack_o <= 1'b1;\n    end else begin\n        wb_ack_o <= 1'b0;\n    end\nend\n\n// int_ack logic\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n        int_ack <= 1'b0;\n    end else if (!wb_stb_i || !wb_cyc_i || !wb_we_i) begin\n        int_ack <= 1'b1;\n    end\nend\n\n// we_m_rx_bd and we_m_tx_bd logic\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n        we_m_rx_bd <= 1'b1;\n        we_m_tx_bd <= 1'b1;\n    end else begin\n        we_m_rx_bd <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n    end\nend\n\n// Output assignments\nassign wb_dat_o = (wb_adr_i == 8'h00) ? argument_reg :\n                  (wb_adr_i == 8'h04) ? {16'd0, cmd_setting_reg} :\n                  (wb_adr_i == 8'h08) ? {16'd0, status_reg} :\n                  (wb_adr_i == 8'h0c) ? cmd_resp_1 :\n                  (wb_adr_i == 8'h28) ? {24'd0, software_reset_reg} :\n                  (wb_adr_i == 8'h2c) ? {16'd0, time_out_reg} :\n                  (wb_adr_i == 8'h30) ? {16'd0, normal_int_status_reg} :\n                  (wb_adr_i == 8'h34) ? {16'd0, error_int_status_reg} :\n                  (wb_adr_i == 8'h38) ? {16'd0, normal_int_signal_enable_reg} :\n                  (wb_adr_i == 8'h3c) ? {16'd0, error_int_signal_enable_reg} :\n                  (wb_adr_i == 8'h4c) ? {24'd0, clock_divider} :\n                  (wb_adr_i == 8'h50) ? {16'd0, Bd_Status_reg} :\n                  (wb_adr_i == 8'h54) ? {24'd0, Bd_isr_reg} :\n                  (wb_adr_i == 8'h58) ? {24'd0, Bd_isr_enable_reg} :\n                  32'd0;\n\nassign new_cmd = (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h00);\nassign we_ack = (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h04);\nassign cmd_int_busy = (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h00 || wb_adr_i == 8'h04));\nassign int_busy = (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h04);\nassign Bd_isr_reset = (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h54);\nassign normal_isr_reset = (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h30);\nassign error_isr_reset = (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h34);\nassign dat_in_m_tx_bd = (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h80) ? wb_dat_i : 32'd0;\nassign dat_in_m_rx_bd = (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h60) ? wb_dat_i : 32'd0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // WISHBONE Slave Interface\n    input           wb_clk_i,        // Slave WISHBONE Clock Input\n    input           wb_rst_i,        // Slave WISHBONE Reset Input\n    input   [31:0]  wb_dat_i,        // Slave WISHBONE Data Inputs\n    output  [31:0]  wb_dat_o,        // Slave WISHBONE Data Outputs\n    input   [ 7:0]  wb_adr_i,        // Slave WISHBONE Address Input\n    input   [ 3:0]  wb_sel_i,        // Slave WISHBONE Select Input\n    input           wb_we_i,         // Slave WISHBONE Write Enable\n    input           wb_cyc_i,        // Slave WISHBONE Cycle\n    input           wb_stb_i,        // Slave WISHBONE Strobe\n    output          wb_ack_o,        // Slave WISHBONE Acknowledge\n\n    // Other Outputs\n    output          we_m_tx_bd,      // Write enable TX BD\n    output          we_m_rx_bd,      // Write enable RX BD\n    output          new_cmd,         // New command indication signal\n    output          we_ack,          // Ack on cmd access request\n    output          int_ack,         // Internal Delayed Acknowledge\n    output          cmd_int_busy,    // Cmd busy by data module\n    output          int_busy,        // Command Busy by data module\n\n    // Inputs from sd_data_master\n    input           write_req_s,     // Cmd access request\n    input   [15:0]  cmd_set_s,       // Command setting input from data master\n    input   [31:0]  cmd_arg_s,       // Command argument input from data master\n\n    // Registers\n    output  [31:0]  argument_reg,    // Command Argument Reg\n    output  [15:0]  cmd_setting_reg, // Command Setting Reg\n    input   [15:0]  status_reg,      // Card Status Reg\n    input   [31:0]  cmd_resp_1,      // Command Response\n    output  [ 7:0]  software_reset_reg, // Software reset Reg\n    output  [15:0]  time_out_reg,    // Timeout Reg\n    input   [15:0]  normal_int_status_reg, // Normal Interrupt Status Reg\n    input   [15:0]  error_int_status_reg,  // Error Interrupt Status Reg\n    output  [15:0]  normal_int_signal_enable_reg, // Normal Interrupt Enable Reg\n    output  [15:0]  error_int_signal_enable_reg,  // Error Interrupt Enable Reg\n    output  [ 7:0]  clock_divider,   // Clock Divider Reg\n    input   [15:0]  Bd_Status_reg,   // BD Status Reg\n    input   [ 7:0]  Bd_isr_reg,      // Data Interrupt Status Reg\n    output  [ 7:0]  Bd_isr_enable_reg, // Data Interrupt Enable Reg\n    output          Bd_isr_reset,    // Reset data interrupt status\n    output          normal_isr_reset, // Reset normal interrupt status\n    output          error_isr_reset,  // Reset error interrupt status\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd, // Data going to the Tx BD\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd  // Data going to the RX BD\n);\n\n// Internal signals\nreg [31:0] argument_reg_i;\nreg [15:0] cmd_setting_reg_i;\nreg [7:0] software_reset_reg_i;\nreg [15:0] time_out_reg_i;\nreg [15:0] normal_int_signal_enable_reg_i;\nreg [15:0] error_int_signal_enable_reg_i;\nreg [7:0] clock_divider_i;\nreg [7:0] Bd_isr_enable_reg_i;\nreg int_ack_i;\nreg we_m_tx_bd_i;\nreg we_m_rx_bd_i;\n\n// Assign outputs\nassign argument_reg = argument_reg_i;\nassign cmd_setting_reg = cmd_setting_reg_i;\nassign software_reset_reg = software_reset_reg_i;\nassign time_out_reg = time_out_reg_i;\nassign normal_int_signal_enable_reg = normal_int_signal_enable_reg_i;\nassign error_int_signal_enable_reg = error_int_signal_enable_reg_i;\nassign clock_divider = clock_divider_i;\nassign Bd_isr_enable_reg = Bd_isr_enable_reg_i;\nassign int_ack = int_ack_i;\nassign we_m_tx_bd = we_m_tx_bd_i;\nassign we_m_rx_bd = we_m_rx_bd_i;\n\n// Reset logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg_i <= 32'd0;\n        cmd_setting_reg_i <= 16'd0;\n        software_reset_reg_i <= 8'd0;\n        time_out_reg_i <= 16'd0;\n        normal_int_signal_enable_reg_i <= 16'd0;\n        error_int_signal_enable_reg_i <= 16'd0;\n        clock_divider_i <= 8'd0;\n        Bd_isr_enable_reg_i <= 8'd0;\n        int_ack_i <= 1'b1;\n        we_m_tx_bd_i <= 1'b0;\n        we_m_rx_bd_i <= 1'b0;\n    end else begin\n        // Update registers based on WISHBONE interface\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg_i <= wb_dat_i;\n                8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n                8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n                8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h4c: clock_divider_i <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n                default: ;\n            endcase\n        end\n    end\nend\n\n// WISHBONE acknowledge logic\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && !wb_ack_o && int_ack_i) begin\n        wb_ack_o <= 1'b1;\n    end else begin\n        wb_ack_o <= 1'b0;\n    end\nend\n\n// int_ack logic\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n        int_ack_i <= 1'b0;\n    end else if (!int_ack_i && !wb_stb_i && !wb_cyc_i) begin\n        int_ack_i <= 1'b1;\n    end\nend\n\n// we_m_tx_bd and we_m_rx_bd logic\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n        if (wb_adr_i == 8'h60) begin\n            we_m_rx_bd_i <= 1'b1;\n        end else begin\n            we_m_tx_bd_i <= 1'b1;\n        end\n    end else if (!wb_stb_i && !wb_cyc_i) begin\n        we_m_tx_bd_i <= 1'b0;\n        we_m_rx_bd_i <= 1'b0;\n    end\nend\n\n// Other output logic\nalways @(posedge wb_clk_i) begin\n    if (write_req_s) begin\n        we_ack <= 1'b1;\n    end else begin\n        we_ack <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_arg_s != 0) begin\n        new_cmd <= 1'b1;\n    end else begin\n        new_cmd <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s != 0 || cmd_arg_s != 0) begin\n        cmd_int_busy <= 1'b1;\n    end else begin\n        cmd_int_busy <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h04) begin\n        int_busy <= 1'b1;\n    end else begin\n        int_busy <= 1'b0;\n    end\nend\n\n// Register read logic\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i) begin\n        case (wb_adr_i)\n            8'h00: wb_dat_o <= argument_reg_i;\n            8'h04: wb_dat_o <= {16'd0, cmd_setting_reg_i};\n            8'h08: wb_dat_o <= {16'd0, status_reg};\n            8'h0c: wb_dat_o <= cmd_resp_1;\n            8'h28: wb_dat_o <= {24'd0, software_reset_reg_i};\n            8'h2c: wb_dat_o <= {16'd0, time_out_reg_i};\n            8'h30: wb_dat_o <= {16'd0, normal_int_status_reg};\n            8'h34: wb_dat_o <= {16'd0, error_int_status_reg};\n            8'h38: wb_dat_o <= {16'd0, normal_int_signal_enable_reg_i};\n            8'h3c: wb_dat_o <= {16'd0, error_int_signal_enable_reg_i};\n            8'h4c: wb_dat_o <= {24'd0, clock_divider_i};\n            8'h50: wb_dat_o <= {16'd0, Bd_Status_reg};\n            8'h54: wb_dat_o <= {24'd0, Bd_isr_reg};\n            8'h58: wb_dat_o <= {24'd0, Bd_isr_enable_reg_i};\n            default: wb_dat_o <= 32'd0;\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // WISHBONE signals\n    input               wb_clk_i,\n    input               wb_rst_i,\n    input  [31:0]       wb_dat_i,\n    output [31:0]       wb_dat_o,\n    input  [7:0]        wb_adr_i,\n    input  [3:0]        wb_sel_i,\n    input               wb_we_i,\n    input               wb_cyc_i,\n    input               wb_stb_i,\n    output              wb_ack_o,\n\n    // Other signals\n    output              we_m_tx_bd,\n    output              we_m_rx_bd,\n    output              new_cmd,\n    output              we_ack,\n    output              int_ack,\n    output              cmd_int_busy,\n    output              int_busy,\n\n    input               write_req_s,\n    input  [15:0]       cmd_set_s,\n    input  [31:0]       cmd_arg_s,\n\n    output [31:0]       argument_reg,\n    output [15:0]       cmd_setting_reg,\n    input  [15:0]       status_reg,\n    input  [31:0]       cmd_resp_1,\n\n    output [7:0]        software_reset_reg,\n    output [15:0]       time_out_reg,\n    input  [15:0]       normal_int_status_reg,\n    input  [15:0]       error_int_status_reg,\n    output [15:0]       normal_int_signal_enable_reg,\n    output [15:0]       error_int_signal_enable_reg,\n    output [7:0]        clock_divider,\n    input  [15:0]       Bd_Status_reg,\n    input  [7:0]        Bd_isr_reg,\n    output [7:0]        Bd_isr_enable_reg,\n    output              Bd_isr_reset,\n    output              normal_isr_reset,\n    output              error_isr_reset,\n    output [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Internal signals\n    reg [31:0] argument_reg_i;\n    reg [15:0] cmd_setting_reg_i;\n    reg [7:0] software_reset_reg_i;\n    reg [15:0] time_out_reg_i;\n    reg [15:0] normal_int_signal_enable_reg_i;\n    reg [15:0] error_int_signal_enable_reg_i;\n    reg [7:0] clock_divider_i;\n    reg [7:0] Bd_isr_enable_reg_i;\n    reg int_ack_i;\n    reg we_m_tx_bd_i;\n    reg we_m_rx_bd_i;\n    reg new_cmd_i;\n    reg we_ack_i;\n    reg cmd_int_busy_i;\n    reg int_busy_i;\n\n    // Assign outputs\n    assign wb_dat_o = argument_reg_i;\n    assign argument_reg = argument_reg_i;\n    assign cmd_setting_reg = cmd_setting_reg_i;\n    assign software_reset_reg = software_reset_reg_i;\n    assign time_out_reg = time_out_reg_i;\n    assign normal_int_signal_enable_reg = normal_int_signal_enable_reg_i;\n    assign error_int_signal_enable_reg = error_int_signal_enable_reg_i;\n    assign clock_divider = clock_divider_i;\n    assign Bd_isr_enable_reg = Bd_isr_enable_reg_i;\n    assign int_ack = int_ack_i;\n    assign we_m_tx_bd = we_m_tx_bd_i;\n    assign we_m_rx_bd = we_m_rx_bd_i;\n    assign new_cmd = new_cmd_i;\n    assign we_ack = we_ack_i;\n    assign cmd_int_busy = cmd_int_busy_i;\n    assign int_busy = int_busy_i;\n\n    // Reset logic\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            argument_reg_i <= 32'd0;\n            cmd_setting_reg_i <= 16'd0;\n            software_reset_reg_i <= 8'd0;\n            time_out_reg_i <= 16'd0;\n            normal_int_signal_enable_reg_i <= 16'd0;\n            error_int_signal_enable_reg_i <= 16'd0;\n            clock_divider_i <= 8'd0;\n            Bd_isr_enable_reg_i <= 8'd0;\n            int_ack_i <= 1'b1;\n            we_m_tx_bd_i <= 1'b0;\n            we_m_rx_bd_i <= 1'b0;\n            new_cmd_i <= 1'b0;\n            we_ack_i <= 1'b0;\n            cmd_int_busy_i <= 1'b0;\n            int_busy_i <= 1'b0;\n        end else begin\n            // Write logic\n            if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg_i <= wb_dat_i;\n                    8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                    8'h4c: clock_divider_i <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n                endcase\n            end\n\n            // Read logic\n            if (wb_stb_i && wb_cyc_i && !wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg_i;\n                    8'h04: wb_dat_o <= {16'd0, cmd_setting_reg_i};\n                    8'h08: wb_dat_o <= {16'd0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h28: wb_dat_o <= {24'd0, software_reset_reg_i};\n                    8'h2c: wb_dat_o <= {16'd0, time_out_reg_i};\n                    8'h30: wb_dat_o <= {16'd0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'd0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'd0, normal_int_signal_enable_reg_i};\n                    8'h3c: wb_dat_o <= {16'd0, error_int_signal_enable_reg_i};\n                    8'h4c: wb_dat_o <= {24'd0, clock_divider_i};\n                    8'h50: wb_dat_o <= {16'd0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'd0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'd0, Bd_isr_enable_reg_i};\n                endcase\n            end\n\n            // Other logic\n            if (write_req_s) begin\n                we_ack_i <= 1'b1;\n            end else begin\n                we_ack_i <= 1'b0;\n            end\n\n            if (cmd_set_s != 16'd0 || cmd_arg_s != 32'd0) begin\n                cmd_int_busy_i <= 1'b1;\n            end else begin\n                cmd_int_busy_i <= 1'b0;\n            end\n\n            if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n                int_ack_i <= 1'b0;\n                if (RAM_MEM_WIDTH == 32) begin\n                    we_m_tx_bd_i <= 1'b1;\n                    we_m_rx_bd_i <= 1'b1;\n                end else begin\n                    we_m_tx_bd_i <= 1'b0;\n                    we_m_rx_bd_i <= 1'b0;\n                end\n            end else begin\n                int_ack_i <= 1'b1;\n                we_m_tx_bd_i <= 1'b0;\n                we_m_rx_bd_i <= 1'b0;\n            end\n        end\n    end\n\n    // Acknowledge logic\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            wb_ack_o <= 1'b0;\n        end else if (wb_stb_i && wb_cyc_i && !wb_ack_o && int_ack_i) begin\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // WISHBONE slave interface\n    input  wire         wb_clk_i,\n    input  wire         wb_rst_i,\n    input  wire [31:0]  wb_dat_i,\n    output wire [31:0]  wb_dat_o,\n    input  wire [7:0]   wb_adr_i,\n    input  wire [3:0]   wb_sel_i,\n    input  wire         wb_we_i,\n    input  wire         wb_cyc_i,\n    input  wire         wb_stb_i,\n    output wire         wb_ack_o,\n\n    // Other signals\n    output wire         we_m_tx_bd,\n    output wire         we_m_rx_bd,\n    output wire         new_cmd,\n    output wire         we_ack,\n    output wire         int_ack,\n    output wire         cmd_int_busy,\n    output wire         int_busy,\n    input  wire         write_req_s,\n    input  wire [15:0]  cmd_set_s,\n    input  wire [31:0]  cmd_arg_s,\n    output wire [31:0]  argument_reg,\n    output wire [15:0]  cmd_setting_reg,\n    input  wire [15:0]  status_reg,\n    input  wire [31:0]  cmd_resp_1,\n    output wire [7:0]   software_reset_reg,\n    output wire [15:0]  time_out_reg,\n    input  wire [15:0]  normal_int_status_reg,\n    input  wire [15:0]  error_int_status_reg,\n    output wire [15:0]  normal_int_signal_enable_reg,\n    output wire [15:0]  error_int_signal_enable_reg,\n    output wire [7:0]   clock_divider,\n    input  wire [15:0]  Bd_Status_reg,\n    input  wire [7:0]   Bd_isr_reg,\n    output wire [7:0]   Bd_isr_enable_reg,\n    output wire         Bd_isr_reset,\n    output wire         normal_isr_reset,\n    output wire         error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Internal registers\n    reg [31:0] argument_reg_i;\n    reg [15:0] cmd_setting_reg_i;\n    reg [7:0] software_reset_reg_i;\n    reg [15:0] time_out_reg_i;\n    reg [15:0] normal_int_signal_enable_reg_i;\n    reg [15:0] error_int_signal_enable_reg_i;\n    reg [7:0] clock_divider_i;\n    reg [7:0] Bd_isr_enable_reg_i;\n\n    // Internal signals\n    reg we_m_tx_bd_i;\n    reg we_m_rx_bd_i;\n    reg new_cmd_i;\n    reg we_ack_i;\n    reg int_ack_i;\n    reg cmd_int_busy_i;\n    reg int_busy_i;\n    reg Bd_isr_reset_i;\n    reg normal_isr_reset_i;\n    reg error_isr_reset_i;\n\n    // Assign outputs\n    assign wb_dat_o = (wb_adr_i == 8'h00) ? argument_reg_i :\n                      (wb_adr_i == 8'h04) ? {16'h0, cmd_setting_reg_i} :\n                      (wb_adr_i == 8'h08) ? {16'h0, status_reg} :\n                      (wb_adr_i == 8'h0c) ? cmd_resp_1 :\n                      (wb_adr_i == 8'h28) ? {24'h0, software_reset_reg_i} :\n                      (wb_adr_i == 8'h2c) ? {16'h0, time_out_reg_i} :\n                      (wb_adr_i == 8'h38) ? {16'h0, normal_int_signal_enable_reg_i} :\n                      (wb_adr_i == 8'h3c) ? {16'h0, error_int_signal_enable_reg_i} :\n                      (wb_adr_i == 8'h4c) ? {24'h0, clock_divider_i} :\n                      (wb_adr_i == 8'h58) ? {24'h0, Bd_isr_enable_reg_i} :\n                      32'h0;\n\n    assign we_m_tx_bd = we_m_tx_bd_i;\n    assign we_m_rx_bd = we_m_rx_bd_i;\n    assign new_cmd = new_cmd_i;\n    assign we_ack = we_ack_i;\n    assign int_ack = int_ack_i;\n    assign cmd_int_busy = cmd_int_busy_i;\n    assign int_busy = int_busy_i;\n    assign Bd_isr_reset = Bd_isr_reset_i;\n    assign normal_isr_reset = normal_isr_reset_i;\n    assign error_isr_reset = error_isr_reset_i;\n\n    // Register write logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            argument_reg_i <= 32'h0;\n            cmd_setting_reg_i <= 16'h0;\n            software_reset_reg_i <= 8'h0;\n            time_out_reg_i <= 16'h0;\n            normal_int_signal_enable_reg_i <= 16'h0;\n            error_int_signal_enable_reg_i <= 16'h0;\n            clock_divider_i <= 8'h0;\n            Bd_isr_enable_reg_i <= 8'h0;\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg_i <= wb_dat_i;\n                8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n                8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n                8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h4c: clock_divider_i <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n                default: ;\n            endcase\n        end\n    end\n\n    // Register read logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all signals\n            we_m_tx_bd_i <= 1'b0;\n            we_m_rx_bd_i <= 1'b0;\n            new_cmd_i <= 1'b0;\n            we_ack_i <= 1'b0;\n            int_ack_i <= 1'b1;\n            cmd_int_busy_i <= 1'b0;\n            int_busy_i <= 1'b0;\n            Bd_isr_reset_i <= 1'b0;\n            normal_isr_reset_i <= 1'b0;\n            error_isr_reset_i <= 1'b0;\n        end else if (wb_stb_i && wb_cyc_i) begin\n            if (wb_we_i) begin\n                // Write operation\n                we_m_tx_bd_i <= (wb_adr_i == 8'h80) ? 1'b1 : 1'b0;\n                we_m_rx_bd_i <= (wb_adr_i == 8'h60) ? 1'b1 : 1'b0;\n                new_cmd_i <= (wb_adr_i == 8'h00) ? 1'b1 : 1'b0;\n                we_ack_i <= write_req_s ? 1'b1 : 1'b0;\n                int_ack_i <= (wb_adr_i == 8'h60 || wb_adr_i == 8'h80) ? 1'b0 : 1'b1;\n                cmd_int_busy_i <= (wb_adr_i == 8'h00 || wb_adr_i == 8'h04) ? 1'b1 : 1'b0;\n                int_busy_i <= (wb_adr_i == 8'h04) ? 1'b1 : 1'b0;\n                Bd_isr_reset_i <= (wb_adr_i == 8'h54) ? 1'b1 : 1'b0;\n                normal_isr_reset_i <= (wb_adr_i == 8'h30) ? 1'b1 : 1'b0;\n                error_isr_reset_i <= (wb_adr_i == 8'h34) ? 1'b1 : 1'b0;\n            end else begin\n                // Read operation\n                we_m_tx_bd_i <= 1'b0;\n                we_m_rx_bd_i <= 1'b0;\n                new_cmd_i <= 1'b0;\n                we_ack_i <= 1'b0;\n                int_ack_i <= 1'b1;\n                cmd_int_busy_i <= 1'b0;\n                int_busy_i <= 1'b0;\n                Bd_isr_reset_i <= 1'b0;\n                normal_isr_reset_i <= 1'b0;\n                error_isr_reset_i <= 1'b0;\n            end\n        end\n    end\n\n    // Acknowledge logic\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            wb_ack_o <= 1'b0;\n        end else if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack_i) begin\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 13, "code": "```ilog\n`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // WISHBONE slave interface\n    input           wb_clk_i,\n    input           wb_rst_i,\n    input   [31:0]  wb_dat_i,\n    output  [31:0]  wb_dat_o,\n    input   [7:0]   wb_adr_i,\n    input   [3:0]   wb_sel_i,\n    input           wb_we_i,\n    input           wb_cyc_i,\n    input           wb_stb_i,\n    output          wb_ack_o,\n\n    // Control signals\n    output          we_m_tx_bd,\n    output          we_m_rx_bd,\n    output          new_cmd,\n    output          we_ack,\n    output          int_ack,\n    output          cmd_int_busy,\n    output          int_busy,\n\n    // Data master interface\n    input           write_req_s,\n    input   [15:0]  cmd_set_s,\n    input   [31:0]  cmd_arg_s,\n\n    // Register outputs\n    output  [31:0]  argument_reg,\n    output  [15:0]  cmd_setting_reg,\n    input   [15:0]  status_reg,\n    input   [31:0]  cmd_resp_1,\n    output  [7:0]   software_reset_reg,\n    output  [15:0]  time_out_reg,\n    input   [15:0]  normal_int_status_reg,\n    input   [15:0]  error_int_status_reg,\n    output  [15:0]  normal_int_signal_enable_reg,\n    output  [15:0]  error_int_signal_enable_reg,\n    output  [7:0]   clock_divider,\n    input   [15:0]  Bd_Status_reg,\n    input   [7:0]   Bd_isr_reg,\n    output  [7:0]   Bd_isr_enable_reg,\n    output          Bd_isr_reset,\n    output          normal_isr_reset,\n    output          error_isr_reset,\n    output  [RAM_MEM_WIDTH-1:0]  dat_in_m_tx_bd,\n    output  [RAM_MEM_WIDTH-1:0]  dat_in_m_rx_bd\n);\n\n// Register declarations\nreg [31:0] argument_reg;\nreg [15:0] cmd_setting_reg;\nreg [7:0] software_reset_reg;\nreg [15:0] time_out_reg;\nreg [15:0] normal_int_signal_enable_reg;\nreg [15:0] error_int_signal_enable_reg;\nreg [7:0] clock_divider;\nreg [7:0] Bd_isr_enable_reg;\n\n// Control signal declarations\nreg we_m_tx_bd;\nreg we_m_rx_bd;\nreg new_cmd;\nreg we_ack;\nreg int_ack;\nreg cmd_int_busy;\nreg int_busy;\n\n// Internal signals\nreg [31:0] reg_value;\nreg [7:0] addr;\n\n// Reset logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg <= 32'd0;\n        cmd_setting_reg <= 16'd0;\n        software_reset_reg <= 8'd0;\n        time_out_reg <= 16'd0;\n        normal_int_signal_enable_reg <= 16'd0;\n        error_int_signal_enable_reg <= 16'd0;\n        clock_divider <= 8'd0;\n        Bd_isr_enable_reg <= 8'd0;\n        // Reset control signals\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1; // Default to high\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n    end else begin\n        // Update registers based on write operations\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            addr = wb_adr_i[7:0];\n            case (addr)\n                8'h00: argument_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                8'h28: software_reset_reg <= wb_dat_i[7:0];\n                8'h2c: time_out_reg <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h4c: clock_divider <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                default: ;\n            endcase\n        end\n\n        // Update control signals\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            if (addr == 8'h00) begin\n                new_cmd <= 1'b1;\n            end\n            if (addr == 8'h60 || addr == 8'h80) begin\n                we_m_tx_bd <= 1'b1;\n                we_m_rx_bd <= 1'b1;\n                int_ack <= 1'b0;\n            end\n        end\n\n        if (write_req_s) begin\n            we_ack <= 1'b1;\n        end\n\n        if (cmd_set_s || cmd_arg_s) begin\n            cmd_int_busy <= 1'b1;\n        end\n\n        if (wb_stb_i && wb_cyc_i && ~wb_we_i) begin\n            if (addr == 8'h04) begin\n                int_busy <= 1'b1;\n            end\n        end\n    end\nend\n\n// Read logic\nalways @(*) begin\n    reg_value = 32'd0;\n    case (wb_adr_i[7:0])\n        8'h00: reg_value = argument_reg;\n        8'h04: reg_value = {16'd0, cmd_setting_reg};\n        8'h08: reg_value = {16'd0, status_reg};\n        8'h0c: reg_value = cmd_resp_1;\n        8'h28: reg_value = {24'd0, software_reset_reg};\n        8'h2c: reg_value = {16'd0, time_out_reg};\n        8'h30: reg_value = {16'd0, normal_int_status_reg};\n        8'h34: reg_value = {16'd0, error_int_status_reg};\n        8'h38: reg_value = {16'd0, normal_int_signal_enable_reg};\n        8'h3c: reg_value = {16'd0, error_int_signal_enable_reg};\n        8'h4c: reg_value = {24'd0, clock_divider};\n        8'h50: reg_value = {16'd0, Bd_Status_reg};\n        8'h54: reg_value = {24'd0, Bd_isr_reg};\n        8'h58: reg_value = {24'd0, Bd_isr_enable_reg};\n        default: ;\n    endcase\n    wb_dat_o = reg_value;\nend\n\n// Acknowledge logic\nalways @(*) begin\n    if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n        wb_ack_o = 1'b1;\n    end else begin\n        wb_ack_o = 1'b0;\n    end\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // WISHBONE slave interface\n    input  wire            wb_clk_i,\n    input  wire            wb_rst_i,\n    input  wire [31:0]     wb_dat_i,\n    output wire [31:0]     wb_dat_o,\n    input  wire [7:0]      wb_adr_i,\n    input  wire [3:0]      wb_sel_i,\n    input  wire            wb_we_i,\n    input  wire            wb_cyc_i,\n    input  wire            wb_stb_i,\n    output wire            wb_ack_o,\n\n    // Other signals\n    output wire            we_m_tx_bd,\n    output wire            we_m_rx_bd,\n    output wire            new_cmd,\n    output wire            we_ack,\n    output wire            int_ack,\n    output wire            cmd_int_busy,\n    output wire            int_busy,\n\n    input  wire            write_req_s,\n    input  wire [15:0]     cmd_set_s,\n    input  wire [31:0]     cmd_arg_s,\n\n    output wire [31:0]     argument_reg,\n    output wire [15:0]     cmd_setting_reg,\n    input  wire [15:0]     status_reg,\n    input  wire [31:0]     cmd_resp_1,\n\n    output wire [7:0]      software_reset_reg,\n    output wire [15:0]     time_out_reg,\n    input  wire [15:0]     normal_int_status_reg,\n    input  wire [15:0]     error_int_status_reg,\n    output wire [15:0]     normal_int_signal_enable_reg,\n    output wire [15:0]     error_int_signal_enable_reg,\n    output wire [7:0]      clock_divider,\n    input  wire [15:0]     Bd_Status_reg,\n    input  wire [7:0]      Bd_isr_reg,\n    output wire [7:0]      Bd_isr_enable_reg,\n    output wire            Bd_isr_reset,\n    output wire            normal_isr_reset,\n    output wire            error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\nreg [31:0] argument_reg_i;\nreg [15:0] cmd_setting_reg_i;\nreg [7:0] software_reset_reg_i;\nreg [15:0] time_out_reg_i;\nreg [15:0] normal_int_signal_enable_reg_i;\nreg [15:0] error_int_signal_enable_reg_i;\nreg [7:0] clock_divider_i;\nreg [7:0] Bd_isr_enable_reg_i;\n\nassign argument_reg = argument_reg_i;\nassign cmd_setting_reg = cmd_setting_reg_i;\nassign software_reset_reg = software_reset_reg_i;\nassign time_out_reg = time_out_reg_i;\nassign normal_int_signal_enable_reg = normal_int_signal_enable_reg_i;\nassign error_int_signal_enable_reg = error_int_signal_enable_reg_i;\nassign clock_divider = clock_divider_i;\nassign Bd_isr_enable_reg = Bd_isr_enable_reg_i;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        argument_reg_i <= 32'd0;\n        cmd_setting_reg_i <= 16'd0;\n        software_reset_reg_i <= 8'd0;\n        time_out_reg_i <= 16'd0;\n        normal_int_signal_enable_reg_i <= 16'd0;\n        error_int_signal_enable_reg_i <= 16'd0;\n        clock_divider_i <= 8'd0;\n        Bd_isr_enable_reg_i <= 8'd0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg_i <= wb_dat_i;\n                8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n                8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n                8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h4c: clock_divider_i <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n            endcase\n        end\n    end\nend\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_dat_o <= 32'd0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i) begin\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= argument_reg_i;\n                8'h04: wb_dat_o <= {16'd0, cmd_setting_reg_i};\n                8'h08: wb_dat_o <= {16'd0, status_reg};\n                8'h0c: wb_dat_o <= cmd_resp_1;\n                8'h28: wb_dat_o <= {24'd0, software_reset_reg_i};\n                8'h2c: wb_dat_o <= {16'd0, time_out_reg_i};\n                8'h30: wb_dat_o <= {16'd0, normal_int_status_reg};\n                8'h34: wb_dat_o <= {16'd0, error_int_status_reg};\n                8'h38: wb_dat_o <= {16'd0, normal_int_signal_enable_reg_i};\n                8'h3c: wb_dat_o <= {16'd0, error_int_signal_enable_reg_i};\n                8'h4c: wb_dat_o <= {24'd0, clock_divider_i};\n                8'h50: wb_dat_o <= {16'd0, Bd_Status_reg};\n                8'h54: wb_dat_o <= {24'd0, Bd_isr_reg};\n                8'h58: wb_dat_o <= {24'd0, Bd_isr_enable_reg_i};\n            endcase\n        end\n    end\nend\n\nreg we_m_tx_bd_i;\nreg we_m_rx_bd_i;\nreg new_cmd_i;\nreg we_ack_i;\nreg int_ack_i;\nreg cmd_int_busy_i;\nreg int_busy_i;\n\nassign we_m_tx_bd = we_m_tx_bd_i;\nassign we_m_rx_bd = we_m_rx_bd_i;\nassign new_cmd = new_cmd_i;\nassign we_ack = we_ack_i;\nassign int_ack = int_ack_i;\nassign cmd_int_busy = cmd_int_busy_i;\nassign int_busy = int_busy_i;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        we_m_tx_bd_i <= 1'b0;\n        we_m_rx_bd_i <= 1'b0;\n        new_cmd_i <= 1'b0;\n        we_ack_i <= 1'b0;\n        int_ack_i <= 1'b1;\n        cmd_int_busy_i <= 1'b0;\n        int_busy_i <= 1'b0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h60: begin\n                    we_m_rx_bd_i <= 1'b1;\n                    int_ack_i <= 1'b0;\n                end\n                8'h80: begin\n                    we_m_tx_bd_i <= 1'b1;\n                    int_ack_i <= 1'b0;\n                end\n            endcase\n        end else if (~wb_stb_i || ~wb_cyc_i || ~wb_we_i) begin\n            we_m_rx_bd_i <= 1'b0;\n            we_m_tx_bd_i <= 1'b0;\n            int_ack_i <= 1'b1;\n        end\n\n        if (write_req_s) begin\n            we_ack_i <= 1'b1;\n        end else begin\n            we_ack_i <= 1'b0;\n        end\n\n        if (cmd_set_s != 16'd0 || cmd_arg_s != 32'd0) begin\n            cmd_int_busy_i <= 1'b1;\n        end else begin\n            cmd_int_busy_i <= 1'b0;\n        end\n\n        if (wb_adr_i == 8'h04) begin\n            int_busy_i <= 1'b1;\n        end else begin\n            int_busy_i <= 1'b0;\n        end\n\n        if (cmd_arg_s != 32'd0) begin\n            new_cmd_i <= 1'b1;\n        end else begin\n            new_cmd_i <= 1'b0;\n        end\n    end\nend\n\nreg Bd_isr_reset_i;\nreg normal_isr_reset_i;\nreg error_isr_reset_i;\n\nassign Bd_isr_reset = Bd_isr_reset_i;\nassign normal_isr_reset = normal_isr_reset_i;\nassign error_isr_reset = error_isr_reset_i;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        Bd_isr_reset_i <= 1'b0;\n        normal_isr_reset_i <= 1'b0;\n        error_isr_reset_i <= 1'b0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h54: Bd_isr_reset_i <= 1'b1;\n                8'h30: normal_isr_reset_i <= 1'b1;\n                8'h34: error_isr_reset_i <= 1'b1;\n            endcase\n        end else begin\n            Bd_isr_reset_i <= 1'b0;\n            normal_isr_reset_i <= 1'b0;\n            error_isr_reset_i <= 1'b0;\n        end\n    end\nend\n\nreg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd_i;\nreg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd_i;\n\nassign dat_in_m_tx_bd = dat_in_m_tx_bd_i;\nassign dat_in_m_rx_bd = dat_in_m_rx_bd_i;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        dat_in_m_tx_bd_i <= {RAM_MEM_WIDTH{1'b0}};\n        dat_in_m_rx_bd_i <= {RAM_MEM_WIDTH{1'b0}};\n    end else begin\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h80: dat_in_m_tx_bd_i <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                8'h60: dat_in_m_rx_bd_i <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n            endcase\n        end\n    end\nend\n\nreg wb_ack_o_i;\n\nassign wb_ack_o = wb_ack_o_i;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o_i <= 1'b0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i && ~wb_ack_o_i && int_ack_i) begin\n            wb_ack_o_i <= 1'b1;\n        end else begin\n            wb_ack_o_i <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // Wishbone slave interface\n    input           wb_clk_i,         // Slave WISHBONE Clock Input\n    input           wb_rst_i,         // Slave WISHBONE Reset Input\n    input   [31:0]  wb_dat_i,         // Slave WISHBONE Data Inputs\n    output  [31:0]  wb_dat_o,         // Slave WISHBONE Data Outputs\n    input   [ 7:0]  wb_adr_i,         // Slave WISHBONE Address Input\n    input   [ 3:0]  wb_sel_i,         // Slave WISHBONE Select Input\n    input           wb_we_i,          // Slave WISHBONE Write Enable\n    input           wb_cyc_i,         // Slave WISHBONE Cycle\n    input           wb_stb_i,         // Slave WISHBONE Strobe\n    output          wb_ack_o,         // Slave WISHBONE Acknowledge\n\n    // Output signals\n    output          we_m_tx_bd,       // Write enable TIx BD\n    output          we_m_rx_bd,       // Write enable Rx BD\n    output          new_cmd,          // New command indication signal\n    output          we_ack,           // Ack on cmd access request\n    output          int_ack,          // Internal Delayed Acknowledge\n    output          cmd_int_busy,     // Cmd busy by data module\n    output          int_busy,         // Command Busy by data module\n\n    // Input signals\n    input           write_req_s,      // Cmd access request\n    input   [15:0]  cmd_set_s,        // Command setting input from data master\n    input   [31:0]  cmd_arg_s,        // Command argument input from data master\n\n    // Registers\n    output  [31:0]  argument_reg,     // Command Argument Reg\n    output  [15:0]  cmd_setting_reg,  // Command Setting Reg\n    input   [15:0]  status_reg,       // Card Status Reg\n    input   [31:0]  cmd_resp_1,       // Command Response\n    output  [ 7:0]  software_reset_reg, // Software reset Reg\n    output  [15:0]  time_out_reg,     // Timeout Reg\n    input   [15:0]  normal_int_status_reg, // Normal Interrupt Status Reg\n    input   [15:0]  error_int_status_reg,  // Error Interrupt Status Reg\n    output  [15:0]  normal_int_signal_enable_reg, // Normal Interrupt Enable Reg\n    output  [15:0]  error_int_signal_enable_reg,  // Error Interrupt Enable Reg\n    output  [ 7:0]  clock_divider,    // Clock Divider Reg\n    input   [15:0]  Bd_Status_reg,    // BD Status Reg\n    input   [ 7:0]  Bd_isr_reg,       // Data Interrupt Status Reg\n    output  [ 7:0]  Bd_isr_enable_reg, // Data Interrupt Enable Reg\n    output          Bd_isr_reset,     // Reset data interrupt status\n    output          normal_isr_reset, // Reset normal interrupt status\n    output          error_isr_reset,  // Reset error interrupt status\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd, // Data going to the Tx BD\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd  // Data going to the RX BD\n);\n\n// Internal signals\nreg [31:0] argument_reg_i;\nreg [15:0] cmd_setting_reg_i;\nreg [7:0] software_reset_reg_i;\nreg [15:0] time_out_reg_i;\nreg [15:0] normal_int_signal_enable_reg_i;\nreg [15:0] error_int_signal_enable_reg_i;\nreg [7:0] clock_divider_i;\nreg [7:0] Bd_isr_enable_reg_i;\nreg int_ack_i;\nreg we_m_tx_bd_i;\nreg we_m_rx_bd_i;\nreg new_cmd_i;\nreg we_ack_i;\nreg cmd_int_busy_i;\nreg int_busy_i;\n\n// Assign outputs\nassign argument_reg = argument_reg_i;\nassign cmd_setting_reg = cmd_setting_reg_i;\nassign software_reset_reg = software_reset_reg_i;\nassign time_out_reg = time_out_reg_i;\nassign normal_int_signal_enable_reg = normal_int_signal_enable_reg_i;\nassign error_int_signal_enable_reg = error_int_signal_enable_reg_i;\nassign clock_divider = clock_divider_i;\nassign Bd_isr_enable_reg = Bd_isr_enable_reg_i;\nassign int_ack = int_ack_i;\nassign we_m_tx_bd = we_m_tx_bd_i;\nassign we_m_rx_bd = we_m_rx_bd_i;\nassign new_cmd = new_cmd_i;\nassign we_ack = we_ack_i;\nassign cmd_int_busy = cmd_int_busy_i;\nassign int_busy = int_busy_i;\n\n// Register write\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg_i <= 32'd0;\n        cmd_setting_reg_i <= 16'd0;\n        software_reset_reg_i <= 8'd0;\n        time_out_reg_i <= 16'd0;\n        normal_int_signal_enable_reg_i <= 16'd0;\n        error_int_signal_enable_reg_i <= 16'd0;\n        clock_divider_i <= 8'd0;\n        Bd_isr_enable_reg_i <= 8'd0;\n        int_ack_i <= 1'b1;\n        we_m_tx_bd_i <= 1'b0;\n        we_m_rx_bd_i <= 1'b0;\n        new_cmd_i <= 1'b0;\n        we_ack_i <= 1'b0;\n        cmd_int_busy_i <= 1'b0;\n        int_busy_i <= 1'b0;\n    end else if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n        case (wb_adr_i)\n            8'h00: argument_reg_i <= wb_dat_i;\n            8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n            8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n            8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n            8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n            8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n            8'h4c: clock_divider_i <= wb_dat_i[7:0];\n            8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n            default: ;\n        endcase\n    end\nend\n\n// Register read\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i) begin\n        case (wb_adr_i)\n            8'h00: wb_dat_o <= argument_reg_i;\n            8'h04: wb_dat_o <= {16'd0, cmd_setting_reg_i};\n            8'h08: wb_dat_o <= {16'd0, status_reg};\n            8'h0c: wb_dat_o <= cmd_resp_1;\n            8'h28: wb_dat_o <= {24'd0, software_reset_reg_i};\n            8'h2c: wb_dat_o <= {16'd0, time_out_reg_i};\n            8'h30: wb_dat_o <= {16'd0, normal_int_status_reg};\n            8'h34: wb_dat_o <= {16'd0, error_int_status_reg};\n            8'h38: wb_dat_o <= {16'd0, normal_int_signal_enable_reg_i};\n            8'h3c: wb_dat_o <= {16'd0, error_int_signal_enable_reg_i};\n            8'h4c: wb_dat_o <= {24'd0, clock_divider_i};\n            8'h50: wb_dat_o <= {16'd0, Bd_Status_reg};\n            8'h54: wb_dat_o <= {24'd0, Bd_isr_reg};\n            8'h58: wb_dat_o <= {24'd0, Bd_isr_enable_reg_i};\n            default: wb_dat_o <= 32'd0;\n        endcase\n    end\nend\n\n// Control logic\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        int_ack_i <= 1'b1;\n        we_m_tx_bd_i <= 1'b0;\n        we_m_rx_bd_i <= 1'b0;\n        new_cmd_i <= 1'b0;\n        we_ack_i <= 1'b0;\n        cmd_int_busy_i <= 1'b0;\n        int_busy_i <= 1'b0;\n    end else begin\n        if (write_req_s) begin\n            we_ack_i <= 1'b1;\n        end else begin\n            we_ack_i <= 1'b0;\n        end\n\n        if (wb_stb_i && wb_cyc_i && ~wb_we_i && (wb_adr_i == 8'h04)) begin\n            int_busy_i <= 1'b1;\n        end else begin\n            int_busy_i <= 1'b0;\n        end\n\n        if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h00)) begin\n            new_cmd_i <= 1'b1;\n        end else begin\n            new_cmd_i <= 1'b0;\n        end\n\n        if (wb_stb_i && wb_cyc_i && wb_we_i && ((wb_adr_i == 8'h60) || (wb_adr_i == 8'h80))) begin\n            int_ack_i <= 1'b0;\n            if (wb_adr_i == 8'h60) begin\n                we_m_rx_bd_i <= 1'b1;\n            end else begin\n                we_m_tx_bd_i <= 1'b1;\n            end\n        end else if (int_ack_i == 1'b0) begin\n            int_ack_i <= 1'b1;\n            we_m_tx_bd_i <= 1'b0;\n            we_m_rx_bd_i <= 1'b0;\n        end\n    end\nend\n\n// Acknowledge generation\nassign wb_ack_o = wb_cyc_i && wb_stb_i && int_ack_i;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 16, "code": "module sd_controller_wb(\n    // WISHBONE slave interface\n    input           wb_clk_i,      // Slave WISHBONE Clock Input\n    input           wb_rst_i,      // Slave WISHBONE Reset Input\n    input   [31:0]  wb_dat_i,      // Slave WISHBONE Data Inputs\n    output  [31:0]  wb_dat_o,      // Slave WISHBONE Data Outputs\n    input   [ 7:0]  wb_adr_i,      // Slave WISHBONE Address Input\n    input   [ 3:0]  wb_sel_i,      // Slave WISHBONE Select Input\n    input           wb_we_i,       // Slave WISHBONE Write Enable\n    input           wb_cyc_i,      // Slave WISHBONE Cycle\n    input           wb_stb_i,      // Slave WISHBONE Strobe\n    output          wb_ack_o,      // Slave WISHBONE Acknowledge\n\n    // Other signals\n    output          we_m_tx_bd,    // Write enable TIx BD\n    output          we_m_rx_bd,    // Write enable Rx BD\n    output          new_cmd,       // New command indication signal\n    output          we_ack,        // Ack on cmd access request\n    output          int_ack,       // Internal Delayed Acknowledge\n    output          cmd_int_busy,  // Cmd busy by data module\n    output          int_busy,      // Command Busy by data module\n    input           write_req_s,   // Cmd access request\n    input   [15:0]  cmd_set_s,     // Command setting input from data master\n    input   [31:0]  cmd_arg_s,     // Command argument input from data master\n    output  [31:0]  argument_reg,  // Command Argument Reg\n    output  [15:0]  cmd_setting_reg, // Command Setting Reg\n    input   [15:0]  status_reg,    // Card Status Reg\n    input   [31:0]  cmd_resp_1,    // Command Response\n    output  [ 7:0]  software_reset_reg, // Software reset Reg\n    output  [15:0]  time_out_reg,  // Timeout Reg\n    input   [15:0]  normal_int_status_reg, // Normal Interrupt Status Reg\n    input   [15:0]  error_int_status_reg,  // Error Interrupt Status Reg\n    output  [15:0]  normal_int_signal_enable_reg, // Normal Interrupt Enable Reg\n    output  [15:0]  error_int_signal_enable_reg,  // Error Interrupt Enable Reg\n    output  [ 7:0]  clock_divider, // Clock Divider Reg\n    input   [15:0]  Bd_Status_reg, // BD Status Reg\n    input   [ 7:0]  Bd_isr_reg,    // Data Interrupt Status Reg\n    output  [ 7:0]  Bd_isr_enable_reg, // Data Interrupt Enable Reg\n    output          Bd_isr_reset,  // Reset data interrupt status\n    output          normal_isr_reset, // Reset normal interrupt status\n    output          error_isr_reset, // Reset error interrupt status\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd, // Data going to the Tx BD\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd  // Data going to the RX BD\n);\n\n    // Internal registers\n    reg [31:0] argument_reg_i;\n    reg [15:0] cmd_setting_reg_i;\n    reg [15:0] status_reg_i;\n    reg [31:0] cmd_resp_1_i;\n    reg [7:0] software_reset_reg_i;\n    reg [15:0] time_out_reg_i;\n    reg [15:0] normal_int_status_reg_i;\n    reg [15:0] error_int_status_reg_i;\n    reg [15:0] normal_int_signal_enable_reg_i;\n    reg [15:0] error_int_signal_enable_reg_i;\n    reg [7:0] clock_divider_i;\n    reg [15:0] Bd_Status_reg_i;\n    reg [7:0] Bd_isr_reg_i;\n    reg [7:0] Bd_isr_enable_reg_i;\n\n    // Internal signals\n    reg we_m_tx_bd_i;\n    reg we_m_rx_bd_i;\n    reg new_cmd_i;\n    reg we_ack_i;\n    reg int_ack_i;\n    reg cmd_int_busy_i;\n    reg int_busy_i;\n\n    // Assign outputs\n    assign wb_dat_o = (wb_adr_i == 8'h00) ? argument_reg_i :\n                      (wb_adr_i == 8'h04) ? {16'h0, cmd_setting_reg_i} :\n                      (wb_adr_i == 8'h08) ? {16'h0, status_reg_i} :\n                      (wb_adr_i == 8'h0c) ? cmd_resp_1_i :\n                      (wb_adr_i == 8'h28) ? {24'h0, software_reset_reg_i} :\n                      (wb_adr_i == 8'h2c) ? {16'h0, time_out_reg_i} :\n                      (wb_adr_i == 8'h30) ? {16'h0, normal_int_status_reg_i} :\n                      (wb_adr_i == 8'h34) ? {16'h0, error_int_status_reg_i} :\n                      (wb_adr_i == 8'h38) ? {16'h0, normal_int_signal_enable_reg_i} :\n                      (wb_adr_i == 8'h3c) ? {16'h0, error_int_signal_enable_reg_i} :\n                      (wb_adr_i == 8'h4c) ? {24'h0, clock_divider_i} :\n                      (wb_adr_i == 8'h50) ? {16'h0, Bd_Status_reg_i} :\n                      (wb_adr_i == 8'h54) ? {24'h0, Bd_isr_reg_i} :\n                      (wb_adr_i == 8'h58) ? {24'h0, Bd_isr_enable_reg_i} :\n                      32'h0;\n\n    assign we_m_tx_bd = we_m_tx_bd_i;\n    assign we_m_rx_bd = we_m_rx_bd_i;\n    assign new_cmd = new_cmd_i;\n    assign we_ack = we_ack_i;\n    assign int_ack = int_ack_i;\n    assign cmd_int_busy = cmd_int_busy_i;\n    assign int_busy = int_busy_i;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all internal registers and signals\n            argument_reg_i <= 32'h0;\n            cmd_setting_reg_i <= 16'h0;\n            status_reg_i <= 16'h0;\n            cmd_resp_1_i <= 32'h0;\n            software_reset_reg_i <= 8'h0;\n            time_out_reg_i <= 16'h0;\n            normal_int_status_reg_i <= 16'h0;\n            error_int_status_reg_i <= 16'h0;\n            normal_int_signal_enable_reg_i <= 16'h0;\n            error_int_signal_enable_reg_i <= 16'h0;\n            clock_divider_i <= 8'h0;\n            Bd_Status_reg_i <= 16'h0;\n            Bd_isr_reg_i <= 8'h0;\n            Bd_isr_enable_reg_i <= 8'h0;\n            we_m_tx_bd_i <= 1'b0;\n            we_m_rx_bd_i <= 1'b0;\n            new_cmd_i <= 1'b0;\n            we_ack_i <= 1'b0;\n            int_ack_i <= 1'b1;\n            cmd_int_busy_i <= 1'b0;\n            int_busy_i <= 1'b0;\n        end else begin\n            // Write logic\n            if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg_i <= wb_dat_i;\n                    8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n                    8'h30: normal_int_status_reg_i <= wb_dat_i[15:0];\n                    8'h34: error_int_status_reg_i <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                    8'h4c: clock_divider_i <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reg_i <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n                endcase\n            end\n\n            // Read logic\n            if (wb_stb_i && wb_cyc_i) begin\n                // No read logic needed, as outputs are assigned directly\n            end\n\n            // Other logic\n            if (write_req_s) begin\n                we_ack_i <= 1'b1;\n            end else begin\n                we_ack_i <= 1'b0;\n            end\n\n            if (cmd_set_s != 16'h0) begin\n                cmd_int_busy_i <= 1'b1;\n            end else begin\n                cmd_int_busy_i <= 1'b0;\n            end\n\n            if (cmd_arg_s != 32'h0) begin\n                new_cmd_i <= 1'b1;\n            end else begin\n                new_cmd_i <= 1'b0;\n            end\n\n            if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n                we_m_tx_bd_i <= 1'b1;\n                we_m_rx_bd_i <= 1'b1;\n                int_ack_i <= 1'b0;\n            end else begin\n                we_m_tx_bd_i <= 1'b0;\n                we_m_rx_bd_i <= 1'b0;\n                int_ack_i <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 17, "code": "module sd_controller_wb(\n    // Wishbone interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input  [3:0]  wb_sel_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Other signals\n    output        we_m_tx_bd,\n    output        we_m_rx_bd,\n    output        new_cmd,\n    output        we_ack,\n    output        int_ack,\n    output        cmd_int_busy,\n    output        int_busy,\n\n    input         write_req_s,\n    input  [15:0] cmd_set_s,\n    input  [31:0] cmd_arg_s,\n\n    output [31:0] argument_reg,\n    output [15:0] cmd_setting_reg,\n    input  [15:0] status_reg,\n    input  [31:0] cmd_resp_1,\n\n    output [7:0]  software_reset_reg,\n    output [15:0] time_out_reg,\n    input  [15:0] normal_int_status_reg,\n    input  [15:0] error_int_status_reg,\n    output [15:0] normal_int_signal_enable_reg,\n    output [15:0] error_int_signal_enable_reg,\n    output [7:0]  clock_divider,\n    input  [15:0] Bd_Status_reg,\n    input  [7:0]  Bd_isr_reg,\n    output [7:0]  Bd_isr_enable_reg,\n    output        Bd_isr_reset,\n    output        normal_isr_reset,\n    output        error_isr_reset,\n    output [31:0] dat_in_m_tx_bd,\n    output [31:0] dat_in_m_rx_bd\n);\n\n    reg [31:0] argument_reg;\n    reg [15:0] cmd_setting_reg;\n    reg [7:0]  software_reset_reg;\n    reg [15:0] time_out_reg;\n    reg [15:0] normal_int_signal_enable_reg;\n    reg [15:0] error_int_signal_enable_reg;\n    reg [7:0]  clock_divider;\n    reg [7:0]  Bd_isr_enable_reg;\n    reg        Bd_isr_reset;\n    reg        normal_isr_reset;\n    reg        error_isr_reset;\n\n    wire [31:0] wb_dat_o_wire;\n\n    assign wb_dat_o = wb_dat_o_wire;\n\n    always @(*) begin\n        case (wb_adr_i)\n            8'h00: wb_dat_o_wire = argument_reg;\n            8'h04: wb_dat_o_wire = {16'h0, cmd_setting_reg};\n            8'h08: wb_dat_o_wire = {16'h0, status_reg};\n            8'h0c: wb_dat_o_wire = cmd_resp_1;\n            8'h28: wb_dat_o_wire = {24'h0, software_reset_reg};\n            8'h2c: wb_dat_o_wire = {16'h0, time_out_reg};\n            8'h30: wb_dat_o_wire = {16'h0, normal_int_status_reg};\n            8'h34: wb_dat_o_wire = {16'h0, error_int_status_reg};\n            8'h38: wb_dat_o_wire = {16'h0, normal_int_signal_enable_reg};\n            8'h3c: wb_dat_o_wire = {16'h0, error_int_signal_enable_reg};\n            8'h4c: wb_dat_o_wire = {24'h0, clock_divider};\n            8'h50: wb_dat_o_wire = {16'h0, Bd_Status_reg};\n            8'h54: wb_dat_o_wire = {24'h0, Bd_isr_reg};\n            8'h58: wb_dat_o_wire = {24'h0, Bd_isr_enable_reg};\n            default: wb_dat_o_wire = 32'h0;\n        endcase\n    end\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            argument_reg <= 32'h0;\n            cmd_setting_reg <= 16'h0;\n            software_reset_reg <= 8'h0;\n            time_out_reg <= 16'h0;\n            normal_int_signal_enable_reg <= 16'h0;\n            error_int_signal_enable_reg <= 16'h0;\n            clock_divider <= 8'h0;\n            Bd_isr_enable_reg <= 8'h0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                8'h28: software_reset_reg <= wb_dat_i[7:0];\n                8'h2c: time_out_reg <= wb_dat_i[15:0];\n                8'h30: normal_int_status_reg <= wb_dat_i[15:0];\n                8'h34: error_int_status_reg <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h4c: clock_divider <= wb_dat_i[7:0];\n                8'h54: Bd_isr_reg <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                default: ;\n            endcase\n        end\n    end\n\n    reg int_ack_reg;\n    assign int_ack = int_ack_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            int_ack_reg <= 1'b1;\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n            int_ack_reg <= 1'b0;\n        end else if (!int_ack_reg) begin\n            int_ack_reg <= 1'b1;\n        end\n    end\n\n    reg we_m_tx_bd_reg;\n    assign we_m_tx_bd = we_m_tx_bd_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            we_m_tx_bd_reg <= 1'b0;\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h80) begin\n            we_m_tx_bd_reg <= 1'b1;\n        end else if (we_m_tx_bd_reg && int_ack) begin\n            we_m_tx_bd_reg <= 1'b0;\n        end\n    end\n\n    reg we_m_rx_bd_reg;\n    assign we_m_rx_bd = we_m_rx_bd_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            we_m_rx_bd_reg <= 1'b0;\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h60) begin\n            we_m_rx_bd_reg <= 1'b1;\n        end else if (we_m_rx_bd_reg && int_ack) begin\n            we_m_rx_bd_reg <= 1'b0;\n        end\n    end\n\n    reg new_cmd_reg;\n    assign new_cmd = new_cmd_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            new_cmd_reg <= 1'b0;\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h00) begin\n            new_cmd_reg <= 1'b1;\n        end else if (new_cmd_reg && int_ack) begin\n            new_cmd_reg <= 1'b0;\n        end\n    end\n\n    reg we_ack_reg;\n    assign we_ack = we_ack_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            we_ack_reg <= 1'b0;\n        end else if (write_req_s) begin\n            we_ack_reg <= 1'b1;\n        end else if (we_ack_reg && int_ack) begin\n            we_ack_reg <= 1'b0;\n        end\n    end\n\n    reg cmd_int_busy_reg;\n    assign cmd_int_busy = cmd_int_busy_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            cmd_int_busy_reg <= 1'b0;\n        end else if (write_req_s) begin\n            cmd_int_busy_reg <= 1'b1;\n        end else if (cmd_int_busy_reg && int_ack) begin\n            cmd_int_busy_reg <= 1'b0;\n        end\n    end\n\n    reg int_busy_reg;\n    assign int_busy = int_busy_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            int_busy_reg <= 1'b0;\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h04) begin\n            int_busy_reg <= 1'b1;\n        end else if (int_busy_reg && int_ack) begin\n            int_busy_reg <= 1'b0;\n        end\n    end\n\n    reg wb_ack_o_reg;\n    assign wb_ack_o = wb_ack_o_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            wb_ack_o_reg <= 1'b0;\n        end else if (wb_stb_i && wb_cyc_i && !wb_ack_o_reg && int_ack) begin\n            wb_ack_o_reg <= 1'b1;\n        end else if (wb_ack_o_reg && !wb_stb_i) begin\n            wb_ack_o_reg <= 1'b0;\n        end\n    end\n\n    reg Bd_isr_reset_reg;\n    assign Bd_isr_reset = Bd_isr_reset_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            Bd_isr_reset_reg <= 1'b0;\n        end else if (Bd_isr_reg != 8'h0) begin\n            Bd_isr_reset_reg <= 1'b1;\n        end else if (Bd_isr_reset_reg && int_ack) begin\n            Bd_isr_reset_reg <= 1'b0;\n        end\n    end\n\n    reg normal_isr_reset_reg;\n    assign normal_isr_reset = normal_isr_reset_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            normal_isr_reset_reg <= 1'b0;\n        end else if (normal_int_status_reg != 16'h0) begin\n            normal_isr_reset_reg <= 1'b1;\n        end else if (normal_isr_reset_reg && int_ack) begin\n            normal_isr_reset_reg <= 1'b0;\n        end\n    end\n\n    reg error_isr_reset_reg;\n    assign error_isr_reset = error_isr_reset_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            error_isr_reset_reg <= 1'b0;\n        end else if (error_int_status_reg != 16'h0) begin\n            error_isr_reset_reg <= 1'b1;\n        end else if (error_isr_reset_reg && int_ack) begin\n            error_isr_reset_reg <= 1'b0;\n        end\n    end\n\n    reg [31:0] dat_in_m_tx_bd_reg;\n    assign dat_in_m_tx_bd = dat_in_m_tx_bd_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            dat_in_m_tx_bd_reg <= 32'h0;\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h80) begin\n            dat_in_m_tx_bd_reg <= wb_dat_i;\n        end\n    end\n\n    reg [31:0] dat_in_m_rx_bd_reg;\n    assign dat_in_m_rx_bd = dat_in_m_rx_bd_reg;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            dat_in_m_rx_bd_reg <= 32'h0;\n        end else if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h60) begin\n            dat_in_m_rx_bd_reg <= wb_dat_i;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // WISHBONE Slave Interface\n    input  wire            wb_clk_i,     // Slave WISHBONE Clock Input\n    input  wire            wb_rst_i,     // Slave WISHBONE Reset Input\n    input  wire [31:0]     wb_dat_i,     // Slave WISHBONE Data Inputs\n    output wire [31:0]     wb_dat_o,     // Slave WISHBONE Data Outputs\n    input  wire [7:0]      wb_adr_i,     // Slave WISHBONE Address Input\n    input  wire [3:0]      wb_sel_i,     // Slave WISHBONE Select Input\n    input  wire            wb_we_i,      // Slave WISHBONE Write Enable\n    input  wire            wb_cyc_i,     // Slave WISHBONE Cycle\n    input  wire            wb_stb_i,     // Slave WISHBONE Strobe\n    output wire            wb_ack_o,     // Slave WISHBONE Acknowledge\n\n    // Other Outputs\n    output wire            we_m_tx_bd,   // Write enable TX BD\n    output wire            we_m_rx_bd,   // Write enable RX BD\n    output wire            new_cmd,      // New command indication signal\n    output wire            we_ack,       // Ack on cmd access request\n    output wire            int_ack,      // Internal Delayed Acknowledge\n    output wire            cmd_int_busy, // Cmd busy by data module\n    output wire            int_busy,     // Command Busy by data module\n\n    // Inputs from sd_data_master\n    input  wire            write_req_s,  // Cmd access request\n    input  wire [15:0]     cmd_set_s,    // Command setting input from data master\n    input  wire [31:0]     cmd_arg_s,    // Command argument input from data master\n\n    // Registers\n    output wire [31:0]     argument_reg, // Command Argument Reg\n    output wire [15:0]     cmd_setting_reg, // Command Setting Reg\n    input  wire [15:0]     status_reg,   // Card Status Reg\n    input  wire [31:0]     cmd_resp_1,   // Command Response\n    output wire [7:0]      software_reset_reg, // Software reset Reg\n    output wire [15:0]     time_out_reg, // Timeout Reg\n    input  wire [15:0]     normal_int_status_reg, // Normal Interrupt Status Reg\n    input  wire [15:0]     error_int_status_reg, // Error Interrupt Status Reg\n    output wire [15:0]     normal_int_signal_enable_reg, // Normal Interrupt Enable Reg\n    output wire [15:0]     error_int_signal_enable_reg, // Error Interrupt Enable Reg\n    output wire [7:0]      clock_divider, // Clock Divider Reg\n    input  wire [15:0]     Bd_Status_reg, // BD Status Reg\n    input  wire [7:0]      Bd_isr_reg,    // Data Interrupt Status Reg\n    output wire [7:0]      Bd_isr_enable_reg, // Data Interrupt Enable Reg\n    output wire            Bd_isr_reset,  // Reset data interrupt status\n    output wire            normal_isr_reset, // Reset normal interrupt status\n    output wire            error_isr_reset, // Reset error interrupt status\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd, // Data going to the Tx BD\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd // Data going to the RX BD\n);\n\n// Internal registers\nreg [31:0] argument_reg_i;\nreg [15:0] cmd_setting_reg_i;\nreg [7:0] software_reset_reg_i;\nreg [15:0] time_out_reg_i;\nreg [15:0] normal_int_signal_enable_reg_i;\nreg [15:0] error_int_signal_enable_reg_i;\nreg [7:0] clock_divider_i;\nreg [7:0] Bd_isr_enable_reg_i;\n\n// Internal wires\nwire [31:0] wb_dat_o_wire;\nwire wb_ack_o_wire;\n\n// Assign outputs\nassign wb_dat_o = wb_dat_o_wire;\nassign wb_ack_o = wb_ack_o_wire;\nassign argument_reg = argument_reg_i;\nassign cmd_setting_reg = cmd_setting_reg_i;\nassign software_reset_reg = software_reset_reg_i;\nassign time_out_reg = time_out_reg_i;\nassign normal_int_signal_enable_reg = normal_int_signal_enable_reg_i;\nassign error_int_signal_enable_reg = error_int_signal_enable_reg_i;\nassign clock_divider = clock_divider_i;\nassign Bd_isr_enable_reg = Bd_isr_enable_reg_i;\n\n// Reset logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg_i <= 32'd0;\n        cmd_setting_reg_i <= 16'd0;\n        software_reset_reg_i <= 8'd0;\n        time_out_reg_i <= 16'd0;\n        normal_int_signal_enable_reg_i <= 16'd0;\n        error_int_signal_enable_reg_i <= 16'd0;\n        clock_divider_i <= 8'd0;\n        Bd_isr_enable_reg_i <= 8'd0;\n        int_ack <= 1'b1;\n    end else begin\n        // Update registers based on WISHBONE inputs\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg_i <= wb_dat_i;\n                8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n                8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n                8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h4c: clock_divider_i <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n                default: ;\n            endcase\n        end\n    end\nend\n\n// WISHBONE acknowledge logic\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && ~wb_ack_o_wire) begin\n        wb_ack_o_wire <= 1'b1;\n    end else begin\n        wb_ack_o_wire <= 1'b0;\n    end\nend\n\n// WISHBONE data output logic\nalways @(posedge wb_clk_i) begin\n    case (wb_adr_i)\n        8'h00: wb_dat_o_wire <= argument_reg_i;\n        8'h04: wb_dat_o_wire <= {16'd0, cmd_setting_reg_i};\n        8'h08: wb_dat_o_wire <= {16'd0, status_reg};\n        8'h0c: wb_dat_o_wire <= cmd_resp_1;\n        8'h28: wb_dat_o_wire <= {24'd0, software_reset_reg_i};\n        8'h2c: wb_dat_o_wire <= {16'd0, time_out_reg_i};\n        8'h30: wb_dat_o_wire <= {16'd0, normal_int_status_reg};\n        8'h34: wb_dat_o_wire <= {16'd0, error_int_status_reg};\n        8'h38: wb_dat_o_wire <= {16'd0, normal_int_signal_enable_reg_i};\n        8'h3c: wb_dat_o_wire <= {16'd0, error_int_signal_enable_reg_i};\n        8'h4c: wb_dat_o_wire <= {24'd0, clock_divider_i};\n        8'h50: wb_dat_o_wire <= {16'd0, Bd_Status_reg};\n        8'h54: wb_dat_o_wire <= {24'd0, Bd_isr_reg};\n        8'h58: wb_dat_o_wire <= {24'd0, Bd_isr_enable_reg_i};\n        default: wb_dat_o_wire <= 32'd0;\n    endcase\nend\n\n// Other output logic\nalways @(posedge wb_clk_i) begin\n    // Update we_m_tx_bd and we_m_rx_bd\n    if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n        case (wb_adr_i)\n            8'h60: we_m_rx_bd <= 1'b1;\n            8'h80: we_m_tx_bd <= 1'b1;\n            default: ;\n        endcase\n    end else begin\n        we_m_rx_bd <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n    end\n\n    // Update new_cmd\n    if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h00) begin\n        new_cmd <= 1'b1;\n    end else begin\n        new_cmd <= 1'b0;\n    end\n\n    // Update we_ack\n    if (write_req_s) begin\n        we_ack <= 1'b1;\n    end else begin\n        we_ack <= 1'b0;\n    end\n\n    // Update int_ack\n    if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h60 || wb_adr_i == 8'h80)) begin\n        int_ack <= 1'b0;\n    end else begin\n        int_ack <= 1'b1;\n    end\n\n    // Update cmd_int_busy\n    if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h00 || wb_adr_i == 8'h04)) begin\n        cmd_int_busy <= 1'b1;\n    end else begin\n        cmd_int_busy <= 1'b0;\n    end\n\n    // Update int_busy\n    if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h04) begin\n        int_busy <= 1'b1;\n    end else begin\n        int_busy <= 1'b0;\n    end\n\n    // Update Bd_isr_reset, normal_isr_reset, and error_isr_reset\n    if (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h54) begin\n        Bd_isr_reset <= 1'b1;\n        normal_isr_reset <= 1'b1;\n        error_isr_reset <= 1'b1;\n    end else begin\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end\n\n    // Update dat_in_m_tx_bd and dat_in_m_rx_bd\n    if (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h80 || wb_adr_i == 8'h60)) begin\n        if (RAM_MEM_WIDTH == 16) begin\n            if (wb_adr_i == 8'h80) begin\n                dat_in_m_tx_bd <= wb_dat_i[15:0];\n            end else begin\n                dat_in_m_rx_bd <= wb_dat_i[15:0];\n            end\n        end else begin\n            if (wb_adr_i == 8'h80) begin\n                dat_in_m_tx_bd <= wb_dat_i;\n            end else begin\n                dat_in_m_rx_bd <= wb_dat_i;\n            end\n        end\n    end else begin\n        dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    // WISHBONE slave interface\n    input           wb_clk_i,         // Slave WISHBONE Clock Input\n    input           wb_rst_i,         // Slave WISHBONE Reset Input\n    input   [31:0]  wb_dat_i,         // Slave WISHBONE Data Inputs\n    output  [31:0]  wb_dat_o,         // Slave WISHBONE Data Outputs\n    input   [ 7:0]  wb_adr_i,         // Slave WISHBONE Address Input\n    input   [ 3:0]  wb_sel_i,         // Slave WISHBONE Select Input\n    input           wb_we_i,          // Slave WISHBONE Write Enable\n    input           wb_cyc_i,         // Slave WISHBONE Cycle\n    input           wb_stb_i,         // Slave WISHBONE Strobe\n    output          wb_ack_o,         // Slave WISHBONE Acknowledge\n\n    // Other signals\n    output          we_m_tx_bd,       // Write enable TIx BD\n    output          we_m_rx_bd,       // Write enable Rx BD\n    output          new_cmd,          // New command indication signal\n    output          we_ack,           // Ack on cmd access request\n    output          int_ack,          // Internal Delayed Acknowledge\n    output          cmd_int_busy,     // Cmd busy by data module\n    output          int_busy,         // Command Busy by data module\n    input           write_req_s,      // Cmd access request\n    input   [15:0]  cmd_set_s,        // Command setting input from data master\n    input   [31:0]  cmd_arg_s,        // Command argument input from data master\n    output  [31:0]  argument_reg,     // Command Argument Reg\n    output  [15:0]  cmd_setting_reg,  // Command Setting Reg\n    input   [15:0]  status_reg,       // Card Status Reg\n    input   [31:0]  cmd_resp_1,       // Command Response\n    output  [ 7:0]  software_reset_reg, // Software reset Reg\n    output  [15:0]  time_out_reg,     // Timeout Reg\n    input   [15:0]  normal_int_status_reg, // Normal Interrupt Status Reg\n    input   [15:0]  error_int_status_reg,  // Error Interrupt Status Reg\n    output  [15:0]  normal_int_signal_enable_reg, // Normal Interrupt Enable Reg\n    output  [15:0]  error_int_signal_enable_reg,  // Error Interrupt Enable Reg\n    output  [ 7:0]  clock_divider,    // Clock Divider Reg\n    input   [15:0]  Bd_Status_reg,    // BD Status Reg\n    input   [ 7:0]  Bd_isr_reg,       // Data Interrupt Status Reg\n    output  [ 7:0]  Bd_isr_enable_reg, // Data Interrupt Enable Reg\n    output          Bd_isr_reset,     // Reset data interrupt status\n    output          normal_isr_reset, // Reset normal interrupt status\n    output          error_isr_reset,  // Reset error interrupt status\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd, // Data going to the Tx BD\n    output  [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd  // Data going to the RX BD\n);\n\n// Internal signals\nreg [31:0] argument_reg_i;\nreg [15:0] cmd_setting_reg_i;\nreg [15:0] status_reg_i;\nreg [31:0] cmd_resp_1_i;\nreg [7:0] software_reset_reg_i;\nreg [15:0] time_out_reg_i;\nreg [15:0] normal_int_status_reg_i;\nreg [15:0] error_int_status_reg_i;\nreg [15:0] normal_int_signal_enable_reg_i;\nreg [15:0] error_int_signal_enable_reg_i;\nreg [7:0] clock_divider_i;\nreg [15:0] Bd_Status_reg_i;\nreg [7:0] Bd_isr_reg_i;\nreg [7:0] Bd_isr_enable_reg_i;\n\n// Reset logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg_i <= 32'd0;\n        cmd_setting_reg_i <= 16'd0;\n        status_reg_i <= 16'd0;\n        cmd_resp_1_i <= 32'd0;\n        software_reset_reg_i <= 8'd0;\n        time_out_reg_i <= 16'd0;\n        normal_int_status_reg_i <= 16'd0;\n        error_int_status_reg_i <= 16'd0;\n        normal_int_signal_enable_reg_i <= 16'd0;\n        error_int_signal_enable_reg_i <= 16'd0;\n        clock_divider_i <= 8'd0;\n        Bd_Status_reg_i <= 16'd0;\n        Bd_isr_reg_i <= 8'd0;\n        Bd_isr_enable_reg_i <= 8'd0;\n        int_ack <= 1'b1;\n    end else begin\n        // Update registers based on write operations\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg_i <= wb_dat_i;\n                8'h04: cmd_setting_reg_i <= wb_dat_i[15:0];\n                8'h08: status_reg_i <= wb_dat_i[15:0];\n                8'h0c: cmd_resp_1_i <= wb_dat_i;\n                8'h28: software_reset_reg_i <= wb_dat_i[7:0];\n                8'h2c: time_out_reg_i <= wb_dat_i[15:0];\n                8'h30: normal_int_status_reg_i <= wb_dat_i[15:0];\n                8'h34: error_int_status_reg_i <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg_i <= wb_dat_i[15:0];\n                8'h4c: clock_divider_i <= wb_dat_i[7:0];\n                8'h54: Bd_isr_reg_i <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg_i <= wb_dat_i[7:0];\n            endcase\n        end\n    end\nend\n\n// Write logic\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n        case (wb_adr_i)\n            8'h60: begin\n                // Write to BD RX register\n                dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                we_m_rx_bd <= 1'b1;\n                int_ack <= 1'b0;\n            end\n            8'h80: begin\n                // Write to BD TX register\n                dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                we_m_tx_bd <= 1'b1;\n                int_ack <= 1'b0;\n            end\n        endcase\n    end else begin\n        we_m_rx_bd <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n    end\nend\n\n// Read logic\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i) begin\n        case (wb_adr_i)\n            8'h00: wb_dat_o <= argument_reg_i;\n            8'h04: wb_dat_o <= {16'd0, cmd_setting_reg_i};\n            8'h08: wb_dat_o <= {16'd0, status_reg_i};\n            8'h0c: wb_dat_o <= cmd_resp_1_i;\n            8'h28: wb_dat_o <= {24'd0, software_reset_reg_i};\n            8'h2c: wb_dat_o <= {16'd0, time_out_reg_i};\n            8'h30: wb_dat_o <= {16'd0, normal_int_status_reg_i};\n            8'h34: wb_dat_o <= {16'd0, error_int_status_reg_i};\n            8'h38: wb_dat_o <= {16'd0, normal_int_signal_enable_reg_i};\n            8'h3c: wb_dat_o <= {16'd0, error_int_signal_enable_reg_i};\n            8'h4c: wb_dat_o <= {24'd0, clock_divider_i};\n            8'h50: wb_dat_o <= {16'd0, Bd_Status_reg_i};\n            8'h54: wb_dat_o <= {24'd0, Bd_isr_reg_i};\n            8'h58: wb_dat_o <= {24'd0, Bd_isr_enable_reg_i};\n        endcase\n    end\nend\n\n// Acknowledge logic\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n        wb_ack_o <= 1'b1;\n    end else begin\n        wb_ack_o <= 1'b0;\n    end\nend\n\n// Other logic\nalways @(posedge wb_clk_i) begin\n    if (write_req_s) begin\n        we_ack <= 1'b1;\n    end else begin\n        we_ack <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s != 16'd0 || cmd_arg_s != 32'd0) begin\n        cmd_int_busy <= 1'b1;\n    end else begin\n        cmd_int_busy <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_arg_s != 32'd0) begin\n        new_cmd <= 1'b1;\n    end else begin\n        new_cmd <= 1'b0;\n    end\nend\n\nassign argument_reg = argument_reg_i;\nassign cmd_setting_reg = cmd_setting_reg_i;\nassign software_reset_reg = software_reset_reg_i;\nassign time_out_reg = time_out_reg_i;\nassign normal_int_signal_enable_reg = normal_int_signal_enable_reg_i;\nassign error_int_signal_enable_reg = error_int_signal_enable_reg_i;\nassign clock_divider = clock_divider_i;\nassign Bd_isr_enable_reg = Bd_isr_enable_reg_i;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 20, "code": "module sd_controller_wb(\n    // Wishbone Slave Interface\n    input           wb_clk_i,         // Slave WISHBONE Clock Input\n    input           wb_rst_i,         // Slave WISHBONE Reset Input\n    input   [31:0]  wb_dat_i,         // Slave WISHBONE Data Inputs\n    output  [31:0]  wb_dat_o,         // Slave WISHBONE Data Outputs\n    input   [ 7:0]  wb_adr_i,         // Slave WISHBONE Address Input\n    input   [ 3:0]  wb_sel_i,         // Slave WISHBONE Select Input\n    input           wb_we_i,          // Slave WISHBONE Write Enable\n    input           wb_cyc_i,         // Slave WISHBONE Cycle\n    input           wb_stb_i,         // Slave WISHBONE Strobe\n    output          wb_ack_o,         // Slave WISHBONE Acknowledge\n\n    // Control and Status Signals\n    output          we_m_tx_bd,       // Write enable TIx BD\n    output          we_m_rx_bd,       // Write enable Rx BD\n    output          new_cmd,          // New command indication signal\n    output          we_ack,           // Ack on cmd access request\n    output          int_ack,          // Internal Delayed Acknowledge\n    output          cmd_int_busy,     // Cmd busy by data module\n    output          int_busy,         // Command Busy by data module\n\n    // Data Master Interface\n    input           write_req_s,      // Cmd access request\n    input   [15:0]  cmd_set_s,        // Command setting input from data master\n    input   [31:0]  cmd_arg_s,        // Command argument input from data master\n\n    // Registers\n    output  [31:0]  argument_reg,     // Command Argument Reg\n    output  [15:0]  cmd_setting_reg,  // Command Setting Reg\n    input   [15:0]  status_reg,       // Card Status Reg\n    input   [31:0]  cmd_resp_1,       // Command Response\n    output  [ 7:0]  software_reset_reg, // Software reset Reg\n    output  [15:0]  time_out_reg,     // Timeout Reg\n    input   [15:0]  normal_int_status_reg, // Normal Interrupt Status Reg\n    input   [15:0]  error_int_status_reg,  // Error Interrupt Status Reg\n    output  [15:0]  normal_int_signal_enable_reg, // Normal Interrupt Enable Reg\n    output  [15:0]  error_int_signal_enable_reg,  // Error Interrupt Enable Reg\n    output  [ 7:0]  clock_divider,    // Clock Divider Reg\n    input   [15:0]  Bd_Status_reg,    // BD Status Reg\n    input   [ 7:0]  Bd_isr_reg,       // Data Interrupt Status Reg\n    output  [ 7:0]  Bd_isr_enable_reg, // Data Interrupt Enable Reg\n    output          Bd_isr_reset,     // Reset data interrupt status\n    output          normal_isr_reset, // Reset normal interrupt status\n    output          error_isr_reset,  // Reset error interrupt status\n    output  [31:0]  dat_in_m_tx_bd,   // Data going to the Tx BD\n    output  [31:0]  dat_in_m_rx_bd    // Data going to the RX BD\n);\n\n// Register definitions\nreg [31:0] argument_reg;\nreg [15:0] cmd_setting_reg;\nreg [15:0] status_reg;\nreg [31:0] cmd_resp_1;\nreg [7:0] software_reset_reg;\nreg [15:0] time_out_reg;\nreg [15:0] normal_int_status_reg;\nreg [15:0] error_int_status_reg;\nreg [15:0] normal_int_signal_enable_reg;\nreg [15:0] error_int_signal_enable_reg;\nreg [7:0] clock_divider;\nreg [15:0] Bd_Status_reg;\nreg [7:0] Bd_isr_reg;\nreg [7:0] Bd_isr_enable_reg;\n\n// Internal signals\nreg int_ack;\nreg we_m_tx_bd;\nreg we_m_rx_bd;\nreg new_cmd;\nreg we_ack;\nreg cmd_int_busy;\nreg int_busy;\n\n// Reset logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg <= 32'd0;\n        cmd_setting_reg <= 16'd0;\n        software_reset_reg <= 8'd0;\n        time_out_reg <= 16'd0;\n        normal_int_signal_enable_reg <= 16'd0;\n        error_int_signal_enable_reg <= 16'd0;\n        clock_divider <= 8'd0;\n        Bd_isr_enable_reg <= 8'd0;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n    end else begin\n        // Update registers based on Wishbone interface\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                8'h28: software_reset_reg <= wb_dat_i[7:0];\n                8'h2c: time_out_reg <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h4c: clock_divider <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n            endcase\n        end\n    end\nend\n\n// Wishbone interface logic\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i) begin\n        if (wb_we_i) begin\n            // Write operation\n            case (wb_adr_i)\n                8'h60: begin\n                    // BD RX register\n                    dat_in_m_rx_bd <= wb_dat_i;\n                    we_m_rx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                end\n                8'h80: begin\n                    // BD TX register\n                    dat_in_m_tx_bd <= wb_dat_i;\n                    we_m_tx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                end\n            endcase\n        end else begin\n            // Read operation\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= argument_reg;\n                8'h04: wb_dat_o <= {16'd0, cmd_setting_reg};\n                8'h08: wb_dat_o <= {16'd0, status_reg};\n                8'h0c: wb_dat_o <= cmd_resp_1;\n                8'h28: wb_dat_o <= {24'd0, software_reset_reg};\n                8'h2c: wb_dat_o <= {16'd0, time_out_reg};\n                8'h30: wb_dat_o <= {16'd0, normal_int_status_reg};\n                8'h34: wb_dat_o <= {16'd0, error_int_status_reg};\n                8'h38: wb_dat_o <= {16'd0, normal_int_signal_enable_reg};\n                8'h3c: wb_dat_o <= {16'd0, error_int_signal_enable_reg};\n                8'h4c: wb_dat_o <= {24'd0, clock_divider};\n                8'h50: wb_dat_o <= {16'd0, Bd_Status_reg};\n                8'h54: wb_dat_o <= {24'd0, Bd_isr_reg};\n                8'h58: wb_dat_o <= {24'd0, Bd_isr_enable_reg};\n            endcase\n        end\n    end\nend\n\n// Acknowledge logic\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n        wb_ack_o <= 1'b1;\n    end else begin\n        wb_ack_o <= 1'b0;\n    end\nend\n\n// Command interface logic\nalways @(posedge wb_clk_i) begin\n    if (write_req_s) begin\n        we_ack <= 1'b1;\n    end else begin\n        we_ack <= 1'b0;\n    end\nend\n\n// Interrupt logic\nalways @(posedge wb_clk_i) begin\n    if (normal_int_status_reg[0]) begin\n        normal_isr_reset <= 1'b1;\n    end else begin\n        normal_isr_reset <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (error_int_status_reg[0]) begin\n        error_isr_reset <= 1'b1;\n    end else begin\n        error_isr_reset <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (Bd_isr_reg[0]) begin\n        Bd_isr_reset <= 1'b1;\n    end else begin\n        Bd_isr_reset <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 1, "code": "// sd_crc_16 module\nmodule sd_crc_16(\n    input BITVAL,  // Next input bit\n    input Enable,  // Enables CRC updating\n    input CLK,     // Current bit valid (Clock)\n    input RST,     // Initializes CRC value to zero\n    output [15:0] CRC  // Current output CRC value\n);\n\nreg [15:0] crc_reg;  // CRC value register\n\n// Combinational logic: inv calculation\nwire inv;\nassign inv = BITVAL ^ crc_reg[15];  // XOR of current input bit and MSB of CRC\n\n// Sequential logic\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin  // Reset handling\n        crc_reg <= 16'd0;  // Set CRC value to zero\n    end else if (Enable) begin  // CRC update\n        // Bit-shifting and updating operations for CRC\n        crc_reg <= {crc_reg[14:0], inv};  // Shift CRC to the left and update LSB\n        crc_reg[12] <= crc_reg[11] ^ inv;  // Update CRC[12]\n        crc_reg[5] <= crc_reg[4] ^ inv;  // Update CRC[5]\n    end\nend\n\n// Output assignment\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [15:0] CRC\n);\n\nreg [15:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 16'd0;\n    end else if (CLK && Enable) begin\n        reg [15:0] crc_next;\n        reg inv;\n        inv = BITVAL ^ (crc_reg[15]);\n        crc_next[15] = crc_reg[14];\n        crc_next[14] = crc_reg[13];\n        crc_next[13] = crc_reg[12];\n        crc_next[12] = crc_reg[11] ^ inv;\n        crc_next[11] = crc_reg[10];\n        crc_next[10] = crc_reg[9];\n        crc_next[9] = crc_reg[8];\n        crc_next[8] = crc_reg[7];\n        crc_next[7] = crc_reg[6];\n        crc_next[6] = crc_reg[5];\n        crc_next[5] = crc_reg[4] ^ inv;\n        crc_next[4] = crc_reg[3];\n        crc_next[3] = crc_reg[2];\n        crc_next[2] = crc_reg[1];\n        crc_next[1] = crc_reg[0];\n        crc_next[0] = inv;\n        crc_reg = crc_next;\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 3, "code": "// sd_crc_16 module\nmodule sd_crc_16(\n    input BITVAL,  // Next input bit\n    input Enable,  // Enables CRC updating\n    input CLK,     // Current bit valid (Clock)\n    input RST,     // Initializes CRC value to zero\n    output [15:0] CRC  // Current output CRC value\n);\n\nreg [15:0] crc_reg;  // Internal CRC register\n\n// Combinational logic: inv calculation\nwire inv;\nassign inv = BITVAL ^ crc_reg[15];  // XOR of current input bit and MSB of CRC\n\n// Sequential logic\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin  // Reset handling\n        crc_reg <= 16'd0;  // Set CRC value to zero\n    end else if (Enable) begin  // CRC update\n        // Bit-shifting and updating operations\n        crc_reg <= {crc_reg[14:0], inv};  // Shift CRC to the left and set LSB to inv\n        crc_reg[12] <= crc_reg[11] ^ inv;  // Update CRC[12]\n        crc_reg[5] <= crc_reg[4] ^ inv;  // Update CRC[5]\n    end\nend\n\n// Output assignment\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 4, "code": "// sd_crc_16 module\nmodule sd_crc_16(\n    input BITVAL,  // Next input bit\n    input Enable,  // Enables CRC updating\n    input CLK,     // Current bit valid (Clock)\n    input RST,     // Initializes CRC value to zero\n    output [15:0] CRC  // Current output CRC value\n);\n\nreg [15:0] crc_reg;  // Internal CRC register\n\n// Combinational logic: inv calculation\nwire inv;\nassign inv = BITVAL ^ crc_reg[15];\n\n// Sequential logic\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin  // Asynchronous reset\n        crc_reg <= 16'd0;  // Initialize CRC value to zero\n    end else if (Enable) begin  // CRC update\n        // Shift each bit of the CRC to the left\n        crc_reg <= {crc_reg[14:0], inv};\n        \n        // Update specific bits of the CRC\n        crc_reg[12] <= crc_reg[11] ^ inv;\n        crc_reg[5] <= crc_reg[4] ^ inv;\n        crc_reg[0] <= inv;\n    end\nend\n\n// Continuous assignment for output\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 5, "code": "// Include the sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\n// Module declaration\nmodule sd_crc_16(\n    input BITVAL,  // Next input bit\n    input Enable,  // Enables CRC updating\n    input CLK,     // Current bit valid (Clock)\n    input RST,     // Initializes CRC value to zero\n    output [15:0] CRC  // Current output CRC value\n);\n\n// Internal signals\nreg [15:0] crc_reg;  // Internal CRC register\nwire inv;            // XOR of current input bit and MSB of CRC\n\n// Combinational logic for inv calculation\nassign inv = BITVAL ^ crc_reg[15];\n\n// Sequential logic\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Reset handling: set CRC value to zero\n        crc_reg <= 16'd0;\n    end else if (Enable) begin\n        // CRC update\n        crc_reg <= {crc_reg[14:0], inv};  // Shift CRC to the left\n        crc_reg[12] <= crc_reg[11] ^ inv;  // Update CRC[12]\n        crc_reg[5] <= crc_reg[4] ^ inv;    // Update CRC[5]\n        crc_reg[0] <= inv;                 // Update CRC[0]\n    end\nend\n\n// Output assignment\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [15:0] CRC\n);\n\nreg [15:0] crc_reg;\n\nalways @(*) begin\n    if(RST) begin\n        crc_reg = 16'd0;\n    end else if(Enable && CLK) begin\n        reg inv;\n        inv = BITVAL ^ crc_reg[15];\n        crc_reg[15:1] = crc_reg[14:0];\n        crc_reg[12] = crc_reg[11] ^ inv;\n        crc_reg[5] = crc_reg[4] ^ inv;\n        crc_reg[0] = inv;\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 7, "code": "```ilog\n// sd_crc_16 module\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [15:0] CRC\n);\n\nreg [15:0] crc_reg;\n\n// Asynchronous reset\nalways @(RST or posedge CLK) begin\n    if (RST) begin\n        crc_reg <= 16'd0;\n    end else if (Enable) begin\n        reg inv;\n        inv = BITVAL ^ crc_reg[15];\n        crc_reg[15:1] <= crc_reg[14:0];\n        crc_reg[12] <= crc_reg[11] ^ inv;\n        crc_reg[5] <= crc_reg[4] ^ inv;\n        crc_reg[0] <= inv;\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input           BITVAL,\n    input           Enable,\n    input           CLK,\n    input           RST,\n    output reg [15:0] CRC\n);\n\nreg [15:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 16'd0;\n    end else if (CLK && Enable) begin\n        reg inv;\n        inv = BITVAL ^ (crc_reg[15]);\n        crc_reg[15:1] = crc_reg[14:0];\n        crc_reg[12] = crc_reg[11] ^ inv;\n        crc_reg[5] = crc_reg[4] ^ inv;\n        crc_reg[0] = inv;\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 9, "code": "// Include the sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\n// Module declaration\nmodule sd_crc_16(\n    input BITVAL,  // Next input bit\n    input Enable,  // Enables CRC updating\n    input CLK,     // Current bit valid (Clock)\n    input RST,     // Initializes CRC value to zero\n    output [15:0] CRC  // Current output CRC value\n);\n\n// Internal signals\nreg [15:0] crc_reg;  // CRC value register\nwire inv;            // Inverse calculation\n\n// Combinational logic\nassign inv = BITVAL ^ crc_reg[15];\n\n// Sequential logic\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Reset handling: set CRC value to zero\n        crc_reg <= 16'd0;\n    end else if (Enable) begin\n        // CRC update\n        crc_reg[15] <= crc_reg[14];\n        crc_reg[14] <= crc_reg[13];\n        crc_reg[13] <= crc_reg[12] ^ inv;\n        crc_reg[12] <= crc_reg[11] ^ inv;\n        crc_reg[11] <= crc_reg[10];\n        crc_reg[10] <= crc_reg[9];\n        crc_reg[9] <= crc_reg[8];\n        crc_reg[8] <= crc_reg[7];\n        crc_reg[7] <= crc_reg[6];\n        crc_reg[6] <= crc_reg[5] ^ inv;\n        crc_reg[5] <= crc_reg[4] ^ inv;\n        crc_reg[4] <= crc_reg[3];\n        crc_reg[3] <= crc_reg[2];\n        crc_reg[2] <= crc_reg[1];\n        crc_reg[1] <= crc_reg[0];\n        crc_reg[0] <= inv;\n    end\nend\n\n// Output assignment\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 10, "code": "// sd_crc_16 module\nmodule sd_crc_16(\n    input BITVAL,  // Next input bit\n    input Enable,  // Enables CRC updating\n    input CLK,     // Current bit valid (Clock)\n    input RST,     // Initializes CRC value to zero\n    output [15:0] CRC  // Current output CRC value\n);\n\nreg [15:0] crc_reg;  // CRC value register\n\n// Combinational logic: inv calculation\nwire inv;\nassign inv = BITVAL ^ (crc_reg[15] ? 1'b1 : 1'b0);\n\n// Sequential logic\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin  // Reset handling\n        crc_reg <= 16'd0;\n    end else if (Enable) begin  // CRC update\n        // Bit-shifting and updating operations\n        crc_reg <= {crc_reg[14:0], inv};\n        crc_reg[12] <= crc_reg[11] ^ inv;\n        crc_reg[5] <= crc_reg[4] ^ inv;\n        crc_reg[0] <= inv;\n    end\nend\n\n// Continuous assignment for output\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 11, "code": "// sd_crc_16 module\nmodule sd_crc_16(\n    input BITVAL,  // Next input bit\n    input Enable,  // Enables CRC updating\n    input CLK,     // Current bit valid (Clock)\n    input RST,     // Initializes CRC value to zero\n    output [15:0] CRC  // Current output CRC value\n);\n\nreg [15:0] crc_reg;  // CRC value register\nwire inv;            // XOR of current input bit and MSB of CRC\n\n// inv calculation\nassign inv = BITVAL ^ crc_reg[15];\n\n// Sequential logic\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin  // Reset handling\n        crc_reg <= 16'd0;\n    end else if (Enable) begin  // CRC update\n        crc_reg[15] <= crc_reg[14];\n        crc_reg[14] <= crc_reg[13];\n        crc_reg[13] <= crc_reg[12] ^ inv;\n        crc_reg[12] <= crc_reg[11] ^ inv;\n        crc_reg[11] <= crc_reg[10];\n        crc_reg[10] <= crc_reg[9];\n        crc_reg[9] <= crc_reg[8];\n        crc_reg[8] <= crc_reg[7];\n        crc_reg[7] <= crc_reg[6];\n        crc_reg[6] <= crc_reg[5] ^ inv;\n        crc_reg[5] <= crc_reg[4] ^ inv;\n        crc_reg[4] <= crc_reg[3];\n        crc_reg[3] <= crc_reg[2];\n        crc_reg[2] <= crc_reg[1];\n        crc_reg[1] <= crc_reg[0];\n        crc_reg[0] <= inv;\n    end\nend\n\n// Output CRC value\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [15:0] CRC\n);\n\nreg [15:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 16'd0;\n    end else if (CLK && Enable) begin\n        reg [15:0] crc_next;\n        reg inv;\n        inv = BITVAL ^ (crc_reg[15]);\n        crc_next[15] = crc_reg[14];\n        crc_next[14] = crc_reg[13];\n        crc_next[13] = crc_reg[12];\n        crc_next[12] = crc_reg[11] ^ inv;\n        crc_next[11] = crc_reg[10];\n        crc_next[10] = crc_reg[9];\n        crc_next[9] = crc_reg[8];\n        crc_next[8] = crc_reg[7];\n        crc_next[7] = crc_reg[6];\n        crc_next[6] = crc_reg[5];\n        crc_next[5] = crc_reg[4] ^ inv;\n        crc_next[4] = crc_reg[3];\n        crc_next[3] = crc_reg[2];\n        crc_next[2] = crc_reg[1];\n        crc_next[1] = crc_reg[0];\n        crc_next[0] = inv;\n        crc_reg = crc_next;\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 13, "code": "// Include the sd_defines.v file for macro definitions\n`include \"sd_defines.v\"\n\n// Module declaration for sd_crc_16\nmodule sd_crc_16(\n    input BITVAL,  // Next input bit\n    input Enable,  // Enables CRC updating\n    input CLK,     // Current bit valid (Clock)\n    input RST,     // Initializes CRC value to zero\n    output [15:0] CRC  // Current output CRC value\n);\n\n// Internal signals\nreg [15:0] crc_reg;  // Register to hold the CRC value\nwire inv;            // XOR of the current input bit and the most significant bit (MSB) of the CRC\n\n// Combinational logic for inv calculation\nassign inv = BITVAL ^ crc_reg[15];\n\n// Sequential logic for CRC update\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin  // Reset handling\n        crc_reg <= 16'd0;\n    end else if (Enable) begin  // CRC update\n        // Shift each bit of the CRC to the left\n        crc_reg <= {crc_reg[14:0], inv};\n        \n        // Update specific bits of the CRC\n        crc_reg[12] <= crc_reg[11] ^ inv;\n        crc_reg[5] <= crc_reg[4] ^ inv;\n        crc_reg[0] <= inv;\n    end\nend\n\n// Output assignment\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 14, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Module declaration for sd_crc_16\nmodule sd_crc_16(\n    input BITVAL,  // Next input bit\n    input Enable,  // Enables CRC updating\n    input CLK,     // Current bit valid (Clock)\n    input RST,     // Initializes CRC value to zero\n    output [15:0] CRC  // Current output CRC value\n);\n\n// Internal signal declaration for inv calculation\nreg inv;\n\n// Internal signal declaration for CRC value\nreg [15:0] crc_reg;\n\n// Combinational logic for inv calculation\nalways @(*) begin\n    inv = BITVAL ^ crc_reg[15];\nend\n\n// Sequential logic for CRC update\nalways @(*) begin\n    if (RST) begin\n        // Reset handling: set CRC value to zero\n        crc_reg = 16'd0;\n    end else if (CLK && Enable) begin\n        // CRC update: shift and update bits\n        crc_reg = {crc_reg[14:0], inv};\n        crc_reg[12] = crc_reg[11] ^ inv;\n        crc_reg[5] = crc_reg[4] ^ inv;\n        crc_reg[0] = inv;\n    end\nend\n\n// Continuous assignment for output CRC value\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 15, "code": "```ilog\n// Include the sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\n// Module declaration\nmodule sd_crc_16(\n    input BITVAL,  // Next input bit\n    input Enable,  // Enables CRC updating\n    input CLK,     // Current bit valid (Clock)\n    input RST,     // Initializes CRC value to zero\n    output [15:0] CRC  // Current output CRC value\n);\n\n// Internal signals\nreg [15:0] crc_reg;  // CRC register\nwire inv;            // Inverse calculation\n\n// Combinational logic for inv calculation\nassign inv = BITVAL ^ crc_reg[15];\n\n// Sequential logic\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Reset handling: set CRC value to zero\n        crc_reg <= 16'd0;\n    end else if (Enable) begin\n        // CRC update\n        crc_reg[15:1] <= crc_reg[14:0];  // Shift CRC to the left\n        crc_reg[12] <= crc_reg[11] ^ inv;  // Update CRC[12]\n        crc_reg[5] <= crc_reg[4] ^ inv;    // Update CRC[5]\n        crc_reg[0] <= inv;                 // Update CRC[0]\n    end\nend\n\n// Output assignment\nassign CRC = crc_reg;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 16, "code": "```ilog\n`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [15:0] CRC\n);\n\nreg [15:0] crc_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        crc_reg <= 16'd0;\n    end else if (Enable) begin\n        reg inv;\n        inv = BITVAL ^ crc_reg[15];\n        crc_reg[15:1] <= crc_reg[14:0];\n        crc_reg[12] <= crc_reg[11] ^ inv;\n        crc_reg[5] <= crc_reg[4] ^ inv;\n        crc_reg[0] <= inv;\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [15:0] CRC\n);\n\nreg [15:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 16'd0;\n    end else if (CLK && Enable) begin\n        reg inv;\n        inv = BITVAL ^ crc_reg[15];\n        crc_reg[15:1] = crc_reg[14:0];\n        crc_reg[12] = crc_reg[11] ^ inv;\n        crc_reg[5] = crc_reg[4] ^ inv;\n        crc_reg[0] = inv;\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [15:0] CRC\n);\n\nreg [15:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 16'd0;\n    end else if (CLK && Enable) begin\n        reg inv;\n        inv = BITVAL ^ crc_reg[15];\n        crc_reg[15:1] = crc_reg[14:0];\n        crc_reg[12] = crc_reg[11] ^ inv;\n        crc_reg[5] = crc_reg[4] ^ inv;\n        crc_reg[0] = inv;\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 19, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Module declaration for sd_crc_16\nmodule sd_crc_16(\n    input BITVAL,  // Next input bit\n    input Enable,  // Enables CRC updating\n    input CLK,     // Current bit valid (Clock)\n    input RST,     // Initializes CRC value to zero\n    output [15:0] CRC  // Current output CRC value\n);\n\n// Internal signal declaration for inv calculation\nreg inv;\n\n// Combinational logic for inv calculation\nalways @(*) begin\n    inv = BITVAL ^ CRC[15];  // inv is computed as the XOR of the current input bit and the most significant bit (MSB) of the CRC\nend\n\n// Sequential logic for CRC update\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin  // Reset handling\n        CRC <= 16'd0;  // CRC value is immediately set to zero\n    end else if (Enable) begin  // CRC update\n        // Each bit of the CRC is shifted to the left\n        CRC <= {CRC[14:0], inv};\n        \n        // Specific bits of the CRC are updated\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[5] <= CRC[4] ^ inv;\n        CRC[0] <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 20, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Module declaration for sd_crc_16\nmodule sd_crc_16(\n    // Input ports\n    input BITVAL,  // Next input bit\n    input Enable,  // Enables CRC updating\n    input CLK,     // Current bit valid (Clock)\n    input RST,     // Initializes CRC value to zero\n    // Output port\n    output [15:0] CRC  // Current output CRC value\n);\n\n// Internal signals and variables\nreg [15:0] crc_reg;  // Register to hold the CRC value\nwire inv;            // Wire to compute the XOR of the current input bit and the MSB of the CRC\n\n// Combinational logic to compute inv\nassign inv = BITVAL ^ crc_reg[15];\n\n// Sequential logic to update the CRC value\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin  // Reset handling\n        crc_reg <= 16'd0;  // Set CRC value to zero on reset\n    end else if (Enable) begin  // CRC update\n        // Shift each bit of the CRC to the left\n        crc_reg <= {crc_reg[14:0], inv};\n        // Update specific bits of the CRC\n        crc_reg[12] <= crc_reg[11] ^ inv;\n        crc_reg[5] <= crc_reg[4] ^ inv;\n        crc_reg[0] <= inv;  // Set the least significant bit directly to inv\n    end\nend\n\n// Continuous assignment to output the CRC value\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 1, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Module declaration for sd_crc_7\nmodule sd_crc_7(\n    input BITVAL,    // The next input bit to be processed for CRC computation\n    input Enable,    // A control signal that enables the CRC update on the rising edge of the clock\n    input CLK,       // The clock signal that synchronizes the CRC computation\n    input RST,       // The reset signal\n    output [6:0] CRC // The current 7-bit CRC value\n);\n\n// Internal signal declaration for inversion calculation\nwire inv;\n\n// Inversion calculation based on the highest bit of the current CRC value and the input bit\nassign inv = BITVAL ^ CRC[6];\n\n// CRC update logic\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset: immediately reset the CRC register to 0\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Update CRC value based on the current input and previous CRC state\n        CRC[0] <= inv;\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 7'd0;\n    end else if (CLK && Enable) begin\n        reg inv;\n        inv = BITVAL ^ crc_reg[6];\n        crc_reg[0] = inv;\n        crc_reg[1] = crc_reg[0];\n        crc_reg[2] = crc_reg[1];\n        crc_reg[3] = crc_reg[2] ^ inv;\n        crc_reg[4] = crc_reg[3];\n        crc_reg[5] = crc_reg[4];\n        crc_reg[6] = crc_reg[5];\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 3, "code": "module sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] CRC;\n\nalways @(*) begin\n    if (RST) begin\n        CRC = 7'b0;\n    end else if (CLK && Enable) begin\n        reg inv;\n        inv = BITVAL ^ CRC[6];\n        CRC[0] = inv;\n        CRC[1] = CRC[0];\n        CRC[2] = CRC[1];\n        CRC[3] = CRC[2] ^ inv;\n        CRC[4] = CRC[3];\n        CRC[5] = CRC[4];\n        CRC[6] = CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 7'b0;\n    end else if (CLK && Enable) begin\n        reg inv;\n        inv = BITVAL ^ crc_reg[6];\n        crc_reg[0] = inv;\n        crc_reg[3] = crc_reg[2] ^ inv;\n        crc_reg[1] = crc_reg[0];\n        crc_reg[2] = crc_reg[1];\n        crc_reg[4] = crc_reg[3];\n        crc_reg[5] = crc_reg[4];\n        crc_reg[6] = crc_reg[5];\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 7'b0;\n    end else if (CLK && Enable) begin\n        reg inv;\n        inv = BITVAL ^ crc_reg[6];\n        crc_reg[0] = inv;\n        crc_reg[1] = crc_reg[0];\n        crc_reg[2] = crc_reg[1];\n        crc_reg[3] = crc_reg[2] ^ inv;\n        crc_reg[4] = crc_reg[3];\n        crc_reg[5] = crc_reg[4];\n        crc_reg[6] = crc_reg[5];\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 6, "code": "// sd_crc_7 module\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] CRC_reg;\n\nalways @(*) begin\n    if (RST) begin\n        CRC_reg = 7'b0;\n    end else if (CLK && Enable) begin\n        reg inv;\n        inv = BITVAL ^ CRC_reg[6];\n        CRC_reg[0] = inv;\n        CRC_reg[1] = CRC_reg[0];\n        CRC_reg[2] = CRC_reg[1];\n        CRC_reg[3] = CRC_reg[2] ^ inv;\n        CRC_reg[4] = CRC_reg[3];\n        CRC_reg[5] = CRC_reg[4];\n        CRC_reg[6] = CRC_reg[5];\n    end\nend\n\nassign CRC = CRC_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 7, "code": "```sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 7'd0;\n    end else if (CLK && Enable) begin\n        reg [6:0] inv;\n        inv = BITVAL ^ crc_reg[6];\n        crc_reg[0] = inv;\n        crc_reg[3] = crc_reg[2] ^ inv;\n        for (int i = 1; i < 7; i++) begin\n            if (i != 3) begin\n                crc_reg[i] = crc_reg[i-1];\n            end\n        end\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 8, "code": "module sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 7'b0;\n    end else if (Enable && CLK) begin\n        reg [6:0] inv;\n        inv = BITVAL ^ crc_reg[6];\n        crc_reg[0] = inv;\n        crc_reg[1] = crc_reg[0];\n        crc_reg[2] = crc_reg[1];\n        crc_reg[3] = crc_reg[2] ^ inv;\n        crc_reg[4] = crc_reg[3];\n        crc_reg[5] = crc_reg[4];\n        crc_reg[6] = crc_reg[5];\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 7'b0;\n    end else if (Enable && CLK) begin\n        reg inv;\n        inv = BITVAL ^ crc_reg[6];\n        crc_reg[0] = inv;\n        crc_reg[3] = crc_reg[2] ^ inv;\n        for (int i = 1; i < 7; i++) begin\n            if (i != 3) begin\n                crc_reg[i] = crc_reg[i-1];\n            end\n        end\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 10, "code": "module sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] CRC_reg;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC_reg <= 7'b0;\n    end else if (Enable) begin\n        reg inv;\n        inv = BITVAL ^ CRC_reg[6];\n        CRC_reg[0] <= inv;\n        CRC_reg[1] <= CRC_reg[0];\n        CRC_reg[2] <= CRC_reg[1];\n        CRC_reg[3] <= CRC_reg[2] ^ inv;\n        CRC_reg[4] <= CRC_reg[3];\n        CRC_reg[5] <= CRC_reg[4];\n        CRC_reg[6] <= CRC_reg[5];\n    end\nend\n\nassign CRC = CRC_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 7'b0;\n    end else if (CLK && Enable) begin\n        reg [6:0] crc_next;\n        reg inv;\n        inv = BITVAL ^ crc_reg[6];\n        crc_next[0] = inv;\n        crc_next[3] = crc_reg[2] ^ inv;\n        crc_next[1] = crc_reg[0];\n        crc_next[2] = crc_reg[1];\n        crc_next[4] = crc_reg[3];\n        crc_next[5] = crc_reg[4];\n        crc_next[6] = crc_reg[5];\n        crc_reg = crc_next;\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 12, "code": "module sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(*) begin\n    if (RST) begin\n        CRC = 7'b0;\n    end else if (Enable && CLK) begin\n        reg inv;\n        inv = BITVAL ^ CRC[6];\n        CRC[0] = inv;\n        CRC[1] = CRC[0];\n        CRC[2] = CRC[1];\n        CRC[3] = CRC[2] ^ inv;\n        CRC[4] = CRC[3];\n        CRC[5] = CRC[4];\n        CRC[6] = CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 7'd0;\n    end else if (Enable && CLK) begin\n        reg [6:0] inv;\n        inv = BITVAL ^ crc_reg[6];\n        crc_reg[0] = inv;\n        crc_reg[3] = crc_reg[2] ^ inv;\n        for (int i = 1; i < 7; i++) begin\n            if (i != 3) begin\n                crc_reg[i] = crc_reg[i-1];\n            end\n        end\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 14, "code": "// sd_crc_7 module\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] crc_reg;\n\n// Initialize CRC value to 0\ninitial crc_reg = 7'b0;\n\n// Asynchronous reset\nalways @(posedge RST or posedge CLK) begin\n    if (RST) begin\n        crc_reg <= 7'b0;\n    end else if (Enable) begin\n        // Inverse calculation\n        reg inv;\n        assign inv = BITVAL ^ crc_reg[6];\n        \n        // CRC update\n        crc_reg[0] <= inv;\n        crc_reg[3] <= crc_reg[2] ^ inv;\n        crc_reg[1] <= crc_reg[0];\n        crc_reg[2] <= crc_reg[1];\n        crc_reg[4] <= crc_reg[3];\n        crc_reg[5] <= crc_reg[4];\n        crc_reg[6] <= crc_reg[5];\n    end\nend\n\n// Assign output\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] CRC_reg;\n\nalways @(*) begin\n    if (RST) begin\n        CRC_reg = 7'b0;\n    end else if (CLK && Enable) begin\n        reg inv;\n        inv = BITVAL ^ CRC_reg[6];\n        CRC_reg[0] = inv;\n        CRC_reg[3] = CRC_reg[2] ^ inv;\n        for (int i = 1; i < 7; i++) begin\n            if (i != 3) begin\n                CRC_reg[i] = CRC_reg[i-1];\n            end\n        end\n    end\nend\n\nassign CRC = CRC_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 16, "code": "module sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] crc_reg;\n\nalways @(*) begin\n    if (RST) begin\n        crc_reg = 7'b0;\n    end else if (CLK && Enable) begin\n        reg inv;\n        inv = BITVAL ^ crc_reg[6];\n        crc_reg[0] = inv;\n        crc_reg[1] = crc_reg[0];\n        crc_reg[2] = crc_reg[1];\n        crc_reg[3] = crc_reg[2] ^ inv;\n        crc_reg[4] = crc_reg[3];\n        crc_reg[5] = crc_reg[4];\n        crc_reg[6] = crc_reg[5];\n    end\nend\n\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] CRC_reg;\n\nalways @(*) begin\n    if (RST) begin\n        CRC_reg = 7'd0;\n    end else if (Enable && CLK) begin\n        reg inv;\n        inv = BITVAL ^ CRC_reg[6];\n        CRC_reg[0] = inv;\n        CRC_reg[1] = CRC_reg[0];\n        CRC_reg[2] = CRC_reg[1];\n        CRC_reg[3] = CRC_reg[2] ^ inv;\n        CRC_reg[4] = CRC_reg[3];\n        CRC_reg[5] = CRC_reg[4];\n        CRC_reg[6] = CRC_reg[5];\n    end\nend\n\nassign CRC = CRC_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 18, "code": "// sd_crc_7 module\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] crc_reg;\n\n// Initialize CRC value to 0\ninitial crc_reg = 7'b0;\n\n// Update CRC value on rising edge of CLK or when RST is asserted\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Reset CRC value to 0 when RST is high\n        crc_reg <= 7'b0;\n    end else if (Enable) begin\n        // Calculate inverse of BITVAL based on highest bit of CRC\n        reg inv;\n        assign inv = BITVAL ^ crc_reg[6];\n        \n        // Update CRC value\n        crc_reg[0] <= inv;\n        crc_reg[3] <= crc_reg[2] ^ inv;\n        crc_reg[1] <= crc_reg[0];\n        crc_reg[2] <= crc_reg[1];\n        crc_reg[4] <= crc_reg[3];\n        crc_reg[5] <= crc_reg[4];\n        crc_reg[6] <= crc_reg[5];\n    end\nend\n\n// Assign output CRC\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 19, "code": "// sd_crc_7 module\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] crc_reg;\n\n// Initialize CRC value to zero on reset\nalways @(posedge RST or posedge CLK) begin\n    if (RST) begin\n        crc_reg <= 7'b0;\n    end else if (Enable) begin\n        // Inverse calculation\n        reg inv;\n        inv = BITVAL ^ crc_reg[6];\n        \n        // CRC update\n        crc_reg[0] <= inv;\n        crc_reg[3] <= crc_reg[2] ^ inv;\n        crc_reg[1] <= crc_reg[0];\n        crc_reg[2] <= crc_reg[1];\n        crc_reg[4] <= crc_reg[3];\n        crc_reg[5] <= crc_reg[4];\n        crc_reg[6] <= crc_reg[5];\n    end\nend\n\n// Assign output CRC value\nassign CRC = crc_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 20, "code": "module sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [6:0] CRC\n);\n\nreg [6:0] CRC_reg;\n\nalways @(*) begin\n    if (RST) begin\n        CRC_reg = 7'b0;\n    end else if (Enable && CLK) begin\n        reg inv;\n        inv = BITVAL ^ CRC_reg[6];\n        CRC_reg[0] = inv;\n        CRC_reg[1] = CRC_reg[0];\n        CRC_reg[2] = CRC_reg[1];\n        CRC_reg[3] = CRC_reg[2] ^ inv;\n        CRC_reg[4] = CRC_reg[3];\n        CRC_reg[5] = CRC_reg[4];\n        CRC_reg[6] = CRC_reg[5];\n    end\nend\n\nassign CRC = CRC_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 1, "code": "module sd_data_master(\n    // Input Ports\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    // Output Ports\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg CIDAT_reg;\nreg [7:0] Dat_Int_Status_reg;\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        CIDAT_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state <= GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state <= GET_RX_BD;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_TX_BD;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_RX_BD;\n                end\n            end\n            SEND_CMD: begin\n                if (tx_cycle == 1) begin\n                    d_write <= 1;\n                end else if (rx_cycle == 1) begin\n                    d_read <= 1;\n                end\n                if (cmd_busy == 0) begin\n                    we_req <= 1;\n                end\n                if (we_ack == 1) begin\n                    send_done <= 1;\n                    next_state <= RECIVE_CMD;\n                end else begin\n                    next_state <= SEND_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state <= DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= RECIVE_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (tx_cycle == 1) begin\n                    start_tx_fifo <= 1;\n                end else if (rx_cycle == 1) begin\n                    start_rx_fifo <= 1;\n                end\n                if (transm_complete == 1) begin\n                    internal_transm_complete <= 1;\n                    next_state <= IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state <= STOP;\n                end else begin\n                    next_state <= DATA_TRANSFER;\n                end\n            end\n            STOP: begin\n                cmd_set_reg <= CMD12;\n                next_state <= STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= STOP_SEND;\n                end\n            end\n            default: begin\n                next_state <= IDLE;\n            end\n        endcase\n        state <= next_state;\n    end\nend\n\n// Output logic\nalways @(*) begin\n    re_s_tx = 0;\n    re_s_rx = 0;\n    a_cmp_tx = 0;\n    a_cmp_rx = 0;\n    we_req = 0;\n    d_write = 0;\n    d_read = 0;\n    start_tx_fifo = 0;\n    start_rx_fifo = 0;\n    ack_transfer = 0;\n    case (state)\n        GET_TX_BD: begin\n            re_s_tx = 1;\n        end\n        GET_RX_BD: begin\n            re_s_rx = 1;\n        end\n        SEND_CMD: begin\n            we_req = 1;\n            if (tx_cycle == 1) begin\n                d_write = 1;\n            end else if (rx_cycle == 1) begin\n                d_read = 1;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (tx_cycle == 1) begin\n                start_tx_fifo = 1;\n            end else if (rx_cycle == 1) begin\n                start_rx_fifo = 1;\n            end\n            if (internal_transm_complete == 1) begin\n                ack_transfer = 1;\n            end\n        end\n        STOP_SEND: begin\n            we_req = 1;\n        end\n    endcase\nend\n\n// Command and argument logic\nalways @(posedge clk) begin\n    if (rst) begin\n        cmd_set_reg <= 0;\n        cmd_arg_reg <= 0;\n    end else begin\n        case (state)\n            GET_TX_BD: begin\n                if (bd_cnt == 0) begin\n                    sys_adr_reg <= dat_in_tx;\n                end else if (bd_cnt == 1) begin\n                    cmd_arg_reg <= dat_in_tx;\n                end\n                cmd_set_reg <= CMD24;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt == 0) begin\n                    sys_adr_reg <= dat_in_rx;\n                end else if (bd_cnt == 1) begin\n                    cmd_arg_reg <= dat_in_rx;\n                end\n                cmd_set_reg <= CMD17;\n            end\n        endcase\n    end\nend\n\n// Status register logic\nalways @(posedge clk) begin\n    if (rst) begin\n        Dat_Int_Status_reg <= 0;\n    end else begin\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status_reg <= 0;\n        end else begin\n            case (state)\n                DATA_TRANSFER: begin\n                    if (crc_ok == 0) begin\n                        Dat_Int_Status_reg[0] <= 1;\n                    end\n                end\n            endcase\n        end\n    end\nend\n\nassign cmd_set = cmd_set_reg;\nassign cmd_arg = cmd_arg_reg;\nassign sys_adr = sys_adr_reg;\nassign Dat_Int_Status = Dat_Int_Status_reg;\nassign CIDAT = CIDAT_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [RESEND_MAX_CNT-1:0] resend_try_cnt;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg Dat_Int_Status_reg;\nreg CIDAT_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n        CIDAT_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= internal_transm_complete;\n        if (state == GET_TX_BD) begin\n            if (bd_cnt < READ_CYCLE - 1) begin\n                bd_cnt <= bd_cnt + 1;\n            end else begin\n                bd_cnt <= 0;\n            end\n        end else if (state == GET_RX_BD) begin\n            if (bd_cnt < READ_CYCLE - 1) begin\n                bd_cnt <= bd_cnt + 1;\n            end else begin\n                bd_cnt <= 0;\n            end\n        end\n        if (state == SEND_CMD) begin\n            if (cmd_busy == 0) begin\n                send_done <= 1;\n            end\n        end\n        if (state == RECIVE_CMD) begin\n            if (cmd_tsf_err == 0) begin\n                rec_done <= 1;\n            end else begin\n                rec_failed <= 1;\n            end\n        end\n        if (state == DATA_TRANSFER) begin\n            if (transm_complete == 1) begin\n                trans_done <= 1;\n            end else if (crc_ok == 0) begin\n                trans_failed <= 1;\n            end\n        end\n    end\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (tx_full == 1 && bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done == 1) begin\n                next_state = IDLE;\n            end else if (trans_failed == 1) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done == 1) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        GET_TX_BD: begin\n            re_s_tx = 1;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = dat_in_tx;\n            cmd_set = CMD24;\n            start_tx_fifo = 1;\n            start_rx_fifo = 0;\n            sys_adr = sys_adr_reg;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        GET_RX_BD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 1;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = dat_in_rx;\n            cmd_set = CMD17;\n            start_tx_fifo = 0;\n            start_rx_fifo = 1;\n            sys_adr = sys_adr_reg;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        SEND_CMD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 1;\n            d_write = (transfer_type == 2'b00) ? 1 : 0;\n            d_read = (transfer_type == 2'b01) ? 1 : 0;\n            cmd_arg = cmd_arg_reg;\n            cmd_set = cmd_set_reg;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        RECIVE_CMD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = (rx_cycle == 1) ? 1 : 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        DATA_TRANSFER: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = (tx_cycle == 1) ? 1 : 0;\n            start_rx_fifo = (rx_cycle == 1) ? 1 : 0;\n            sys_adr = sys_adr_reg;\n            ack_transfer = transm_complete_q;\n            Dat_Int_Status = Dat_Int_Status_reg;\n            CIDAT = CIDAT_reg;\n        end\n        STOP: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = CMD12;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        STOP_SEND: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 1;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = CMD12;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        default: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg [8:0] state;\nreg [8:0] next_state;\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg CIDAT_reg;\nreg [7:0] Dat_Int_Status_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        CIDAT_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= resend_try_cnt;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= internal_transm_complete;\n        transm_complete_q <= internal_transm_complete;\n        bd_cnt <= bd_cnt;\n        sys_adr_reg <= sys_adr_reg;\n        cmd_arg_reg <= cmd_arg_reg;\n        cmd_set_reg <= cmd_set_reg;\n        CIDAT_reg <= CIDAT_reg;\n        Dat_Int_Status_reg <= Dat_Int_Status_reg;\n\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state <= GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state <= GET_RX_BD;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_TX_BD;\n                end\n            end\n\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_RX_BD;\n                end\n            end\n\n            SEND_CMD: begin\n                if (tx_cycle) begin\n                    d_write <= 1;\n                end else if (rx_cycle) begin\n                    d_read <= 1;\n                end\n                we_req <= 1;\n                if (we_ack) begin\n                    send_done <= 1;\n                    next_state <= RECIVE_CMD;\n                end else begin\n                    next_state <= SEND_CMD;\n                end\n            end\n\n            RECIVE_CMD: begin\n                if (rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                if (cmd_busy == 0) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                        next_state <= SEND_CMD;\n                    end else begin\n                        rec_done <= 1;\n                        next_state <= DATA_TRANSFER;\n                    end\n                end else begin\n                    next_state <= RECIVE_CMD;\n                end\n            end\n\n            DATA_TRANSFER: begin\n                if (tx_cycle) begin\n                    if (tx_empt) begin\n                        next_state <= STOP;\n                    end\n                end else if (rx_cycle) begin\n                    if (rx_full) begin\n                        next_state <= STOP;\n                    end\n                end\n                if (transm_complete) begin\n                    trans_done <= 1;\n                    next_state <= IDLE;\n                end else if (crc_ok == 0) begin\n                    trans_failed <= 1;\n                    next_state <= STOP;\n                end else begin\n                    next_state <= DATA_TRANSFER;\n                end\n            end\n\n            STOP: begin\n                cmd_set_reg <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                next_state <= STOP_SEND;\n            end\n\n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                    Dat_Int_Status_reg[1] <= 1;\n                end\n                we_req <= 1;\n                if (we_ack) begin\n                    send_done <= 1;\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= STOP_SEND;\n                end\n            end\n\n            default: begin\n                next_state <= IDLE;\n            end\n        endcase\n    end\nend\n\nassign re_s_tx = (state == GET_TX_BD) ? 1 : 0;\nassign re_s_rx = (state == GET_RX_BD) ? 1 : 0;\nassign we_req = (state == SEND_CMD) ? 1 : 0;\nassign d_write = (state == SEND_CMD && tx_cycle) ? 1 : 0;\nassign d_read = (state == SEND_CMD && rx_cycle) ? 1 : 0;\nassign cmd_arg = cmd_arg_reg;\nassign cmd_set = cmd_set_reg;\nassign start_tx_fifo = (state == GET_TX_BD && tx_full) ? 1 : 0;\nassign start_rx_fifo = (state == RECIVE_CMD && rx_cycle) ? 1 : 0;\nassign sys_adr = sys_adr_reg;\nassign ack_transfer = transm_complete_q;\nassign Dat_Int_Status = Dat_Int_Status_reg;\nassign CIDAT = CIDAT_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg CIDAT_reg;\nreg [7:0] Dat_Int_Status_reg;\n\nalways @(*) begin\n    case(state)\n        IDLE: begin\n            if(free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if(free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if(bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if(bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if(send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if(rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end else if(rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if(trans_done == 1) begin\n                next_state = IDLE;\n            end else if(trans_failed == 1) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if(send_done == 1) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\nalways @(posedge clk or posedge rst) begin\n    if(rst) begin\n        state <= IDLE;\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        CIDAT_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n    end else begin\n        state <= next_state;\n        case(state)\n            IDLE: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= Dat_Int_Status_reg;\n                CIDAT <= CIDAT_reg;\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr_reg <= 0;\n                cmd_arg_reg <= 0;\n                cmd_set_reg <= 0;\n                CIDAT_reg <= 0;\n                Dat_Int_Status_reg <= 0;\n            end\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if(ack_i_s_tx) begin\n                    if(RAM_MEM_WIDTH_32) begin\n                        if(bd_cnt == 0) begin\n                            sys_adr_reg <= dat_in_tx;\n                        end else if(bd_cnt == 1) begin\n                            cmd_arg_reg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end else if(RAM_MEM_WIDTH_16) begin\n                        if(bd_cnt < 2) begin\n                            sys_adr_reg <= {sys_adr_reg, dat_in_tx};\n                        end else if(bd_cnt < 4) begin\n                            cmd_arg_reg <= {cmd_arg_reg, dat_in_tx};\n                        end\n                        if(bd_cnt == 3) begin\n                            start_tx_fifo <= 1;\n                        end\n                    end\n                    bd_cnt <= bd_cnt + 1;\n                end\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= Dat_Int_Status_reg;\n                CIDAT <= CIDAT_reg;\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 1;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                sys_adr_reg <= sys_adr_reg;\n                cmd_arg_reg <= cmd_arg_reg;\n                cmd_set_reg <= cmd_set_reg;\n                CIDAT_reg <= CIDAT_reg;\n                Dat_Int_Status_reg <= Dat_Int_Status_reg;\n            end\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if(ack_i_s_rx) begin\n                    if(RAM_MEM_WIDTH_32) begin\n                        if(bd_cnt == 0) begin\n                            sys_adr_reg <= dat_in_rx;\n                        end else if(bd_cnt == 1) begin\n                            cmd_arg_reg <= dat_in_rx;\n                        end\n                    end else if(RAM_MEM_WIDTH_16) begin\n                        if(bd_cnt < 2) begin\n                            sys_adr_reg <= {sys_adr_reg, dat_in_rx};\n                        end else if(bd_cnt < 4) begin\n                            cmd_arg_reg <= {cmd_arg_reg, dat_in_rx};\n                        end\n                    end\n                    bd_cnt <= bd_cnt + 1;\n                end\n                a_cmp_rx <= 0;\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= Dat_Int_Status_reg;\n                CIDAT <= CIDAT_reg;\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 1;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                sys_adr_reg <= sys_adr_reg;\n                cmd_arg_reg <= cmd_arg_reg;\n                cmd_set_reg <= cmd_set_reg;\n                CIDAT_reg <= CIDAT_reg;\n                Dat_Int_Status_reg <= Dat_Int_Status_reg;\n            end\n            SEND_CMD: begin\n                if(tx_cycle) begin\n                    d_write <= 1;\n                end else if(rx_cycle) begin\n                    d_read <= 1;\n                end\n                if(cmd_busy == 0) begin\n                    we_req <= 1;\n                end\n                if(we_ack) begin\n                    send_done <= 1;\n                end\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                cmd_arg <= cmd_arg_reg;\n                cmd_set <= cmd_set_reg;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= Dat_Int_Status_reg;\n                CIDAT <= CIDAT_reg;\n                rec_done <= 0;\n                rec_failed <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                sys_adr_reg <= sys_adr_reg;\n                cmd_arg_reg <= cmd_arg_reg;\n                cmd_set_reg <= cmd_set_reg;\n                CIDAT_reg <= CIDAT_reg;\n                Dat_Int_Status_reg <= Dat_Int_Status_reg;\n            end\n            RECIVE_CMD: begin\n                if(rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                if(cmd_tsf_err) begin\n                    rec_failed <= 1;\n                end\n                if(card_status[0] == 1) begin\n                    rec_done <= 1;\n                end\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= Dat_Int_Status_reg;\n                CIDAT <= CIDAT_reg;\n                send_done <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                sys_adr_reg <= sys_adr_reg;\n                cmd_arg_reg <= cmd_arg_reg;\n                cmd_set_reg <= cmd_set_reg;\n                CIDAT_reg <= CIDAT_reg;\n                Dat_Int_Status_reg <= Dat_Int_Status_reg;\n            end\n            DATA_TRANSFER: begin\n                if(tx_cycle) begin\n                    if(tx_empt) begin\n                        trans_failed <= 1;\n                    end\n                end else if(rx_cycle) begin\n                    if(rx_full) begin\n                        trans_failed <= 1;\n                    end\n                end\n                if(transm_complete) begin\n                    internal_transm_complete <= 1;\n                end\n                if(crc_ok) begin\n                    trans_done <= 1;\n                end\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= sys_adr_reg;\n                ack_transfer <= 0;\n                Dat_Int_Status <= Dat_Int_Status_reg;\n                CIDAT <= CIDAT_reg;\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                resend_try_cnt <= 0;\n                transm_complete_q <= internal_transm_complete;\n                sys_adr_reg <= sys_adr_reg;\n                cmd_arg_reg <= cmd_arg_reg;\n                cmd_set_reg <= cmd_set_reg;\n                CIDAT_reg <= CIDAT_reg;\n                Dat_Int_Status_reg <= Dat_Int_Status_reg;\n            end\n            STOP: begin\n                cmd_set_reg <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= Dat_Int_Status_reg;\n                CIDAT <= CIDAT_reg;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                sys_adr_reg <= sys_adr_reg;\n                cmd_arg_reg <= cmd_arg_reg;\n                cmd_set_reg <= cmd_set_reg;\n                CIDAT_reg <= CIDAT_reg;\n                Dat_Int_Status_reg <= Dat_Int_Status_reg;\n            end\n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if(resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status_reg[1] <= 1;\n                end\n                if(cmd_busy == 0) begin\n                    we_req <= 1;\n                end\n                if(we_ack) begin\n                    send_done <= 1;\n                end\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                cmd_arg <= 0;\n                cmd_set <= cmd_set_reg;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= Dat_Int_Status_reg;\n                CIDAT <= CIDAT_reg;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                sys_adr_reg <= sys_adr_reg;\n                cmd_arg_reg <= cmd_arg_reg;\n                CIDAT_reg <= CIDAT_reg;\n                Dat_Int_Status_reg <= Dat_Int_Status_reg;\n            end\n            default: begin\n                state <= IDLE;\n            end\n        endcase\n        if(Dat_Int_Status_rst) begin\n            Dat_Int_Status_reg <= 0;\n        end\n    end\nend\n\nassign Dat_Int_Status = Dat_Int_Status_reg;\nassign CIDAT = CIDAT_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 5, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg CIDAT_reg;\nreg [7:0] Dat_Int_Status_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        CIDAT_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= transm_complete;\n\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state <= GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state <= GET_RX_BD;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_TX_BD;\n                end\n            end\n\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_RX_BD;\n                end\n            end\n\n            SEND_CMD: begin\n                if (tx_cycle == 1) begin\n                    d_write <= 1;\n                end else if (rx_cycle == 1) begin\n                    d_read <= 1;\n                end\n                if (cmd_busy == 0) begin\n                    we_req <= 1;\n                end\n                if (we_ack == 1) begin\n                    send_done <= 1;\n                    next_state <= RECIVE_CMD;\n                end else begin\n                    next_state <= SEND_CMD;\n                end\n            end\n\n            RECIVE_CMD: begin\n                if (rx_cycle == 1) begin\n                    start_rx_fifo <= 1;\n                end\n                if (cmd_tsf_err == 0 && card_status[0] == 1) begin\n                    rec_done <= 1;\n                    next_state <= DATA_TRANSFER;\n                end else if (cmd_tsf_err == 1) begin\n                    rec_failed <= 1;\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= RECIVE_CMD;\n                end\n            end\n\n            DATA_TRANSFER: begin\n                if (tx_cycle == 1) begin\n                    if (tx_empt == 1) begin\n                        next_state <= IDLE;\n                    end else begin\n                        next_state <= DATA_TRANSFER;\n                    end\n                end else if (rx_cycle == 1) begin\n                    if (rx_full == 1) begin\n                        next_state <= IDLE;\n                    end else begin\n                        next_state <= DATA_TRANSFER;\n                    end\n                end\n                if (transm_complete == 1 && crc_ok == 1) begin\n                    trans_done <= 1;\n                    internal_transm_complete <= 1;\n                    next_state <= IDLE;\n                end else if (transm_complete == 1 && crc_ok == 0) begin\n                    trans_failed <= 1;\n                    next_state <= STOP;\n                end\n            end\n\n            STOP: begin\n                cmd_set_reg <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                d_read <= 1;\n                d_write <= 1;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n                next_state <= STOP_SEND;\n            end\n\n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                    Dat_Int_Status_reg[1] <= 1;\n                end\n                if (cmd_busy == 0) begin\n                    we_req <= 1;\n                end\n                if (we_ack == 1) begin\n                    send_done <= 1;\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= STOP_SEND;\n                end\n            end\n        endcase\n    end\nend\n\nalways @(*) begin\n    re_s_tx = 0;\n    re_s_rx = 0;\n    a_cmp_tx = 0;\n    a_cmp_rx = 0;\n    we_req = 0;\n    d_write = 0;\n    d_read = 0;\n    cmd_arg = cmd_arg_reg;\n    cmd_set = cmd_set_reg;\n    start_tx_fifo = 0;\n    start_rx_fifo = 0;\n    sys_adr = sys_adr_reg;\n    ack_transfer = internal_transm_complete;\n    Dat_Int_Status = Dat_Int_Status_reg;\n    CIDAT = CIDAT_reg;\nend\n\nassign Dat_Int_Status_rst = Dat_Int_Status_rst;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 6, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg CIDAT_reg;\nreg [7:0] Dat_Int_Status_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        next_state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        CIDAT_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= transm_complete;\n        if (state == IDLE) begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state <= GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state <= GET_RX_BD;\n            end else begin\n                next_state <= IDLE;\n            end\n        end else if (state == GET_TX_BD) begin\n            re_s_tx <= 1;\n            if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                next_state <= SEND_CMD;\n                sys_adr_reg <= dat_in_tx;\n                cmd_arg_reg <= dat_in_tx;\n                cmd_set_reg <= CMD24;\n                tx_cycle <= 1;\n            end else begin\n                next_state <= GET_TX_BD;\n                bd_cnt <= bd_cnt + 1;\n            end\n        end else if (state == GET_RX_BD) begin\n            re_s_rx <= 1;\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state <= SEND_CMD;\n                sys_adr_reg <= dat_in_rx;\n                cmd_arg_reg <= dat_in_rx;\n                if (transfer_type == 2'b00) begin\n                    cmd_set_reg <= CMD17;\n                end else if (transfer_type == 2'b01) begin\n                    cmd_set_reg <= ACMD13;\n                end else begin\n                    cmd_set_reg <= ACMD51;\n                end\n                rx_cycle <= 1;\n            end else begin\n                next_state <= GET_RX_BD;\n                bd_cnt <= bd_cnt + 1;\n            end\n        end else if (state == SEND_CMD) begin\n            if (tx_cycle == 1) begin\n                d_write <= 1;\n            end else if (rx_cycle == 1) begin\n                d_read <= 1;\n            end\n            we_req <= 1;\n            if (we_ack == 1) begin\n                send_done <= 1;\n                next_state <= RECIVE_CMD;\n            end else begin\n                next_state <= SEND_CMD;\n            end\n        end else if (state == RECIVE_CMD) begin\n            if (rx_cycle == 1) begin\n                start_rx_fifo <= 1;\n            end\n            if (cmd_busy == 0) begin\n                if (cmd_tsf_err == 1) begin\n                    rec_failed <= 1;\n                    next_state <= SEND_CMD;\n                end else if (card_status[0] == 1) begin\n                    rec_done <= 1;\n                    next_state <= DATA_TRANSFER;\n                end else begin\n                    next_state <= RECIVE_CMD;\n                end\n            end else begin\n                next_state <= RECIVE_CMD;\n            end\n        end else if (state == DATA_TRANSFER) begin\n            if (tx_cycle == 1) begin\n                if (tx_empt == 1) begin\n                    trans_failed <= 1;\n                    next_state <= STOP;\n                end\n            end else if (rx_cycle == 1) begin\n                if (rx_full == 1) begin\n                    trans_failed <= 1;\n                    next_state <= STOP;\n                end\n            end\n            if (transm_complete == 1) begin\n                internal_transm_complete <= 1;\n                next_state <= IDLE;\n            end else begin\n                next_state <= DATA_TRANSFER;\n            end\n        end else if (state == STOP) begin\n            cmd_set_reg <= CMD12;\n            next_state <= STOP_SEND;\n        end else if (state == STOP_SEND) begin\n            resend_try_cnt <= resend_try_cnt + 1;\n            if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                Dat_Int_Status_reg[1] <= 1;\n            end\n            we_req <= 1;\n            if (we_ack == 1) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= STOP_SEND;\n            end\n        end\n    end\nend\n\nalways @(*) begin\n    re_s_tx = 0;\n    a_cmp_tx = 0;\n    re_s_rx = 0;\n    a_cmp_rx = 0;\n    we_req = 0;\n    d_write = 0;\n    d_read = 0;\n    cmd_arg = cmd_arg_reg;\n    cmd_set = cmd_set_reg;\n    start_tx_fifo = 0;\n    start_rx_fifo = 0;\n    sys_adr = sys_adr_reg;\n    ack_transfer = 0;\n    Dat_Int_Status = Dat_Int_Status_reg;\n    CIDAT = CIDAT_reg;\n    if (state == GET_TX_BD) begin\n        re_s_tx = 1;\n    end else if (state == GET_RX_BD) begin\n        re_s_rx = 1;\n    end else if (state == SEND_CMD) begin\n        we_req = 1;\n        if (tx_cycle == 1) begin\n            d_write = 1;\n        end else if (rx_cycle == 1) begin\n            d_read = 1;\n        end\n    end else if (state == DATA_TRANSFER) begin\n        if (internal_transm_complete == 1) begin\n            ack_transfer = 1;\n        end\n    end else if (state == STOP_SEND) begin\n        we_req = 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg Dat_Int_Status_reg [7:0];\nreg CIDAT_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n        CIDAT_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= (state == SEND_CMD && we_ack);\n        rec_done <= (state == RECIVE_CMD && !cmd_busy);\n        rec_failed <= (state == RECIVE_CMD && cmd_tsf_err);\n        tx_cycle <= (state == GET_TX_BD);\n        rx_cycle <= (state == GET_RX_BD);\n        resend_try_cnt <= (state == STOP_SEND) ? resend_try_cnt + 1 : 0;\n        trans_done <= (state == DATA_TRANSFER && transm_complete);\n        trans_failed <= (state == DATA_TRANSFER && !crc_ok);\n        internal_transm_complete <= (state == DATA_TRANSFER && transm_complete);\n        transm_complete_q <= internal_transm_complete;\n        bd_cnt <= (state == GET_TX_BD || state == GET_RX_BD) ? bd_cnt + 1 : 0;\n        sys_adr_reg <= (state == GET_TX_BD || state == GET_RX_BD) ? dat_in_tx : sys_adr_reg;\n        cmd_arg_reg <= (state == GET_TX_BD || state == GET_RX_BD) ? dat_in_tx : cmd_arg_reg;\n        cmd_set_reg <= (state == GET_TX_BD) ? CMD24 : (state == GET_RX_BD) ? CMD17 : cmd_set_reg;\n        Dat_Int_Status_reg <= (Dat_Int_Status_rst) ? 0 : Dat_Int_Status_reg;\n        CIDAT_reg <= (state == DATA_TRANSFER && crc_ok) ? 1 : 0;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1 && tx_full) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\nassign re_s_tx = (state == GET_TX_BD);\nassign a_cmp_tx = (state == DATA_TRANSFER && trans_done);\nassign re_s_rx = (state == GET_RX_BD);\nassign a_cmp_rx = (state == DATA_TRANSFER && trans_done);\nassign we_req = (state == SEND_CMD && !cmd_busy);\nassign d_write = (state == SEND_CMD && tx_cycle);\nassign d_read = (state == SEND_CMD && rx_cycle);\nassign cmd_arg = cmd_arg_reg;\nassign cmd_set = cmd_set_reg;\nassign start_tx_fifo = (state == GET_TX_BD && bd_cnt >= READ_CYCLE - 1);\nassign start_rx_fifo = (state == GET_RX_BD && bd_cnt >= READ_CYCLE - 1);\nassign sys_adr = sys_adr_reg;\nassign ack_transfer = transm_complete_q;\nassign Dat_Int_Status = Dat_Int_Status_reg;\nassign CIDAT = CIDAT_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 8, "code": "module sd_data_master(\n    // Input Ports\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    // Output Ports\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\n// Internal signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg CIDAT_reg;\nreg [7:0] Dat_Int_Status_reg;\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\n\n// State Transition Table\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done == 1) begin\n                next_state = IDLE;\n            end else if (trans_failed == 1) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done == 1) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\n// Output Logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            GET_RX_BD: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 1;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            SEND_CMD: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 1;\n                d_write <= (transfer_type == 2'b00) ? 1 : 0;\n                d_read <= (transfer_type == 2'b01) ? 1 : 0;\n                cmd_arg <= cmd_arg_reg;\n                cmd_set <= cmd_set_reg;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= sys_adr_reg;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            RECIVE_CMD: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= (tx_cycle == 1) ? 1 : 0;\n                start_rx_fifo <= (rx_cycle == 1) ? 1 : 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            DATA_TRANSFER: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= (transm_complete == 1) ? 1 : 0;\n                Dat_Int_Status <= Dat_Int_Status_reg;\n                CIDAT <= CIDAT_reg;\n            end\n            STOP: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= CMD12;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            STOP_SEND: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 1;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n            default: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n                Dat_Int_Status <= 0;\n                CIDAT <= 0;\n            end\n        endcase\n    end\nend\n\n// Internal Signal Logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        CIDAT_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr_reg <= 0;\n                cmd_arg_reg <= 0;\n                cmd_set_reg <= 0;\n                CIDAT_reg <= 0;\n                Dat_Int_Status_reg <= 0;\n            end\n            GET_TX_BD: begin\n                if (ack_i_s_tx == 1) begin\n                    sys_adr_reg <= dat_in_tx;\n                    cmd_arg_reg <= dat_in_tx;\n                    tx_cycle <= 1;\n                end\n                bd_cnt <= bd_cnt + 1;\n            end\n            GET_RX_BD: begin\n                if (ack_i_s_rx == 1) begin\n                    sys_adr_reg <= dat_in_rx;\n                    cmd_arg_reg <= dat_in_rx;\n                    rx_cycle <= 1;\n                end\n                bd_cnt <= bd_cnt + 1;\n            end\n            SEND_CMD: begin\n                if (we_ack == 1) begin\n                    send_done <= 1;\n                end\n            end\n            RECIVE_CMD: begin\n                if (cmd_busy == 0) begin\n                    rec_done <= 1;\n                end else if (cmd_tsf_err == 1) begin\n                    rec_failed <= 1;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete == 1) begin\n                    trans_done <= 1;\n                end else if (crc_ok == 0) begin\n                    trans_failed <= 1;\n                end\n                internal_transm_complete <= transm_complete;\n                transm_complete_q <= internal_transm_complete;\n            end\n            STOP: begin\n                cmd_set_reg <= CMD12;\n            end\n            STOP_SEND: begin\n                if (we_ack == 1) begin\n                    send_done <= 1;\n                end\n                resend_try_cnt <= resend_try_cnt + 1;\n            end\n            default: begin\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                resend_try_cnt <= 0;\n                trans_done <= 0;\n                trans_failed <= 0;\n                internal_transm_complete <= 0;\n                transm_complete_q <= 0;\n                bd_cnt <= 0;\n                sys_adr_reg <= 0;\n                cmd_arg_reg <= 0;\n                cmd_set_reg <= 0;\n                CIDAT_reg <= 0;\n                Dat_Int_Status_reg <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 9, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\n\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg CIDAT_reg;\nreg [7:0] Dat_Int_Status_reg;\n\nalways @(*) begin\n    case(state)\n        IDLE: begin\n            if(free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if(free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if(bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if(bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if(send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if(rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end else if(rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if(trans_done == 1) begin\n                next_state = IDLE;\n            end else if(trans_failed == 1) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if(send_done == 1) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\nalways @(posedge clk or posedge rst) begin\n    if(rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        CIDAT_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n    end else begin\n        state <= next_state;\n        if(state == GET_TX_BD) begin\n            re_s_tx <= 1;\n            if(ack_i_s_tx) begin\n                // Process data based on memory width\n                if(RAM_MEM_WIDTH_32) begin\n                    // First read: Store data to sys_adr\n                    // Second read: Store data to cmd_arg and start TX FIFO\n                end else if(RAM_MEM_WIDTH_16) begin\n                    // Four reads to populate sys_adr and cmd_arg (16 bits at a time)\n                    // After last read, start TX FIFO\n                end\n                cmd_set_reg <= CMD24;\n                tx_cycle <= 1;\n            end\n        end else if(state == GET_RX_BD) begin\n            re_s_rx <= 1;\n            if(ack_i_s_rx) begin\n                // Process data based on memory width\n                if(RAM_MEM_WIDTH_32) begin\n                    // First read: Store data to sys_adr\n                    // Second read: Store data to cmd_arg\n                end else if(RAM_MEM_WIDTH_16) begin\n                    // Four reads to populate sys_adr and cmd_arg (16 bits at a time)\n                end\n                // Set command based on transfer_type\n                if(transfer_type == 2'b00) begin\n                    cmd_set_reg <= CMD17;\n                end else if(transfer_type == 2'b01) begin\n                    cmd_set_reg <= ACMD13;\n                end else begin\n                    cmd_set_reg <= ACMD51;\n                end\n                rx_cycle <= 1;\n            end\n        end else if(state == SEND_CMD) begin\n            // Check type of cycle rx or tx\n            if(tx_cycle) begin\n                d_write <= 1;\n            end else if(rx_cycle) begin\n                d_read <= 1;\n            end\n            // Check if CMD is free, if so assert we_req\n            if(!cmd_busy) begin\n                we_req <= 1;\n            end\n            // Wait for we_ack\n            if(we_ack) begin\n                send_done <= 1;\n            end\n        end else if(state == RECIVE_CMD) begin\n            // Start Rx_Fifo_Filer if Rx cycle\n            if(rx_cycle) begin\n                start_rx_fifo <= 1;\n            end\n            // Wait for command response (indicated by cmd_busy are low)\n            if(!cmd_busy) begin\n                // Check so cmd_tsf_err is not asserted, if asserted set command_failed\n                if(cmd_tsf_err) begin\n                    rec_failed <= 1;\n                end else begin\n                    rec_done <= 1;\n                end\n            end\n        end else if(state == DATA_TRANSFER) begin\n            // If tx_cycle check so tx_fifo doenst get empty\n            if(tx_cycle) begin\n                if(tx_empt) begin\n                    trans_failed <= 1;\n                end\n            end\n            // If rx_cycle check so rx_fifo doenst get full\n            if(rx_cycle) begin\n                if(rx_full) begin\n                    trans_failed <= 1;\n                end\n            end\n            // Wait for command complete\n            if(transm_complete) begin\n                trans_done <= 1;\n            end\n            // Check so crc_ok == 1\n            if(crc_ok) begin\n                internal_transm_complete <= 1;\n            end else begin\n                trans_failed <= 1;\n            end\n        end else if(state == STOP) begin\n            cmd_set_reg <= CMD12;\n            rec_done <= 0;\n            rec_failed <= 0;\n            send_done <= 0;\n            trans_failed <= 0;\n            trans_done <= 0;\n            d_read <= 1;\n            d_write <= 1;\n            start_rx_fifo <= 0;\n            start_tx_fifo <= 0;\n        end else if(state == STOP_SEND) begin\n            resend_try_cnt <= resend_try_cnt + 1;\n            if(resend_try_cnt == RESEND_MAX_CNT) begin\n                Dat_Int_Status_reg[1] <= 1;\n            end\n            if(!cmd_busy) begin\n                we_req <= 1;\n            end\n            if(we_ack) begin\n                send_done <= 1;\n            end\n        end\n        if(Dat_Int_Status_rst) begin\n            Dat_Int_Status_reg <= 0;\n        end\n    end\nend\n\nassign re_s_tx = (state == GET_TX_BD) ? 1 : 0;\nassign a_cmp_tx = (state == DATA_TRANSFER && trans_done) ? 1 : 0;\nassign re_s_rx = (state == GET_RX_BD) ? 1 : 0;\nassign a_cmp_rx = (state == DATA_TRANSFER && trans_done) ? 1 : 0;\nassign we_req = (state == SEND_CMD && !cmd_busy) ? 1 : 0;\nassign d_write = (state == SEND_CMD && tx_cycle) ? 1 : 0;\nassign d_read = (state == SEND_CMD && rx_cycle) ? 1 : 0;\nassign cmd_arg = cmd_arg_reg;\nassign cmd_set = cmd_set_reg;\nassign start_tx_fifo = (state == GET_TX_BD && ack_i_s_tx) ? 1 : 0;\nassign start_rx_fifo = (state == RECIVE_CMD && rx_cycle) ? 1 : 0;\nassign sys_adr = sys_adr_reg;\nassign ack_transfer = (state == DATA_TRANSFER && trans_done) ? 1 : 0;\nassign Dat_Int_Status = Dat_Int_Status_reg;\nassign CIDAT = CIDAT_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 10, "code": "```ilog\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [RESEND_MAX_CNT-1:0] resend_try_cnt;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg Dat_Int_Status_reg;\nreg CIDAT_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n        CIDAT_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= resend_try_cnt;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= internal_transm_complete;\n        transm_complete_q <= transm_complete_q;\n        bd_cnt <= bd_cnt;\n        sys_adr_reg <= sys_adr_reg;\n        cmd_arg_reg <= cmd_arg_reg;\n        cmd_set_reg <= cmd_set_reg;\n        Dat_Int_Status_reg <= Dat_Int_Status_reg;\n        CIDAT_reg <= CIDAT_reg;\n\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state <= GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state <= GET_RX_BD;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_TX_BD;\n                end\n            end\n\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_RX_BD;\n                end\n            end\n\n            SEND_CMD: begin\n                if (tx_cycle == 1) begin\n                    d_write <= 1;\n                end else if (rx_cycle == 1) begin\n                    d_read <= 1;\n                end\n                if (cmd_busy == 0) begin\n                    we_req <= 1;\n                end\n                if (we_ack == 1) begin\n                    send_done <= 1;\n                    next_state <= RECIVE_CMD;\n                end else begin\n                    next_state <= SEND_CMD;\n                end\n            end\n\n            RECIVE_CMD: begin\n                if (rx_cycle == 1) begin\n                    start_rx_fifo <= 1;\n                end\n                if (cmd_tsf_err == 0 && card_status[0] == 1) begin\n                    rec_done <= 1;\n                    next_state <= DATA_TRANSFER;\n                end else if (cmd_tsf_err == 1) begin\n                    rec_failed <= 1;\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= RECIVE_CMD;\n                end\n            end\n\n            DATA_TRANSFER: begin\n                if (tx_cycle == 1) begin\n                    if (tx_empt == 0) begin\n                        start_tx_fifo <= 1;\n                    end\n                end else if (rx_cycle == 1) begin\n                    if (rx_full == 0) begin\n                        start_rx_fifo <= 1;\n                    end\n                end\n                if (transm_complete == 1 && crc_ok == 1) begin\n                    trans_done <= 1;\n                    next_state <= IDLE;\n                end else if (transm_complete == 1 && crc_ok == 0) begin\n                    trans_failed <= 1;\n                    next_state <= STOP;\n                end else begin\n                    next_state <= DATA_TRANSFER;\n                end\n            end\n\n            STOP: begin\n                cmd_set_reg <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                next_state <= STOP_SEND;\n            end\n\n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    Dat_Int_Status_reg[1] <= 1;\n                end\n                if (cmd_busy == 0) begin\n                    we_req <= 1;\n                end\n                if (we_ack == 1) begin\n                    send_done <= 1;\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= STOP_SEND;\n                end\n            end\n\n            default: begin\n                next_state <= IDLE;\n            end\n        endcase\n    end\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            re_s_tx = 0;\n            re_s_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            ack_transfer = 0;\n        end\n\n        GET_TX_BD: begin\n            re_s_tx = 1;\n            re_s_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            ack_transfer = 0;\n        end\n\n        GET_RX_BD: begin\n            re_s_tx = 0;\n            re_s_rx = 1;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            ack_transfer = 0;\n        end\n\n        SEND_CMD: begin\n            re_s_tx = 0;\n            re_s_rx = 0;\n            if (tx_cycle == 1) begin\n                d_write = 1;\n            end else if (rx_cycle == 1) begin\n                d_read = 1;\n            end\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            ack_transfer = 0;\n        end\n\n        RECIVE_CMD: begin\n            re_s_tx = 0;\n            re_s_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            if (rx_cycle == 1) begin\n                start_rx_fifo = 1;\n            end else begin\n                start_rx_fifo = 0;\n            end\n            start_tx_fifo = 0;\n            ack_transfer = 0;\n        end\n\n        DATA_TRANSFER: begin\n            re_s_tx = 0;\n            re_s_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            if (tx_cycle == 1) begin\n                if (tx_empt == 0) begin\n                    start_tx_fifo = 1;\n                end else begin\n                    start_tx_fifo = 0;\n                end\n            end else begin\n                start_tx_fifo = 0;\n            end\n            if (rx_cycle == 1) begin\n                if (rx_full == 0) begin\n                    start_rx_fifo = 1;\n                end else begin\n                    start_rx_fifo = 0;\n                end\n            end else begin\n                start_rx_fifo = 0;\n            end\n            ack_transfer = 0;\n        end\n\n        STOP: begin\n            re_s_tx = 0;\n            re_s_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            ack_transfer = 0;\n        end\n\n        STOP_SEND: begin\n            re_s_tx = 0;\n            re_s_rx = 0;\n            if (cmd_busy == 0) begin\n                we_req = 1;\n            end else begin\n                we_req = 0;\n            end\n            d_write = 0;\n            d_read = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            ack_transfer = 0;\n        end\n\n        default: begin\n            re_s_tx = 0;\n            re_s_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            ack_transfer = 0;\n        end\n    endcase\nend\n\nassign cmd_arg = cmd_arg_reg;\nassign cmd_set = cmd_set_reg;\nassign sys_adr = sys_adr_reg;\nassign Dat_Int_Status = Dat_Int_Status_reg;\nassign CIDAT = CIDAT_reg;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 11, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg [SIZE-1:0] state, next_state;\nreg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\nreg [2:0] resend_try_cnt;\nreg trans_done, trans_failed;\nreg internal_transm_complete, transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg re_s_tx_reg, a_cmp_tx_reg, re_s_rx_reg, a_cmp_rx_reg;\nreg we_req_reg, d_write_reg, d_read_reg, start_tx_fifo_reg, start_rx_fifo_reg;\nreg ack_transfer_reg;\nreg [7:0] Dat_Int_Status_reg;\nreg CIDAT_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        re_s_tx_reg <= 0;\n        a_cmp_tx_reg <= 0;\n        re_s_rx_reg <= 0;\n        a_cmp_rx_reg <= 0;\n        we_req_reg <= 0;\n        d_write_reg <= 0;\n        d_read_reg <= 0;\n        start_tx_fifo_reg <= 0;\n        start_rx_fifo_reg <= 0;\n        ack_transfer_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n        CIDAT_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= (state == SEND_CMD && we_ack);\n        rec_done <= (state == RECIVE_CMD && !cmd_busy);\n        rec_failed <= (state == RECIVE_CMD && cmd_tsf_err);\n        tx_cycle <= (state == GET_TX_BD);\n        rx_cycle <= (state == GET_RX_BD);\n        resend_try_cnt <= (state == STOP_SEND) ? resend_try_cnt + 1 : 0;\n        trans_done <= (state == DATA_TRANSFER && transm_complete);\n        trans_failed <= (state == DATA_TRANSFER && !crc_ok);\n        internal_transm_complete <= (state == DATA_TRANSFER && transm_complete);\n        transm_complete_q <= internal_transm_complete;\n        bd_cnt <= (state == GET_TX_BD || state == GET_RX_BD) ? bd_cnt + 1 : 0;\n        sys_adr_reg <= (state == GET_TX_BD || state == GET_RX_BD) ? dat_in_tx : sys_adr_reg;\n        cmd_arg_reg <= (state == GET_TX_BD || state == GET_RX_BD) ? dat_in_tx : cmd_arg_reg;\n        cmd_set_reg <= (state == GET_TX_BD) ? CMD24 : (state == GET_RX_BD) ? CMD17 : cmd_set_reg;\n        re_s_tx_reg <= (state == GET_TX_BD);\n        a_cmp_tx_reg <= (state == GET_TX_BD && bd_cnt == READ_CYCLE - 1);\n        re_s_rx_reg <= (state == GET_RX_BD);\n        a_cmp_rx_reg <= (state == GET_RX_BD && bd_cnt == READ_CYCLE - 1);\n        we_req_reg <= (state == SEND_CMD && !cmd_busy);\n        d_write_reg <= (state == SEND_CMD && tx_cycle);\n        d_read_reg <= (state == SEND_CMD && rx_cycle);\n        start_tx_fifo_reg <= (state == SEND_CMD && tx_cycle);\n        start_rx_fifo_reg <= (state == SEND_CMD && rx_cycle);\n        ack_transfer_reg <= (state == DATA_TRANSFER && transm_complete);\n        Dat_Int_Status_reg <= (state == DATA_TRANSFER && trans_failed) ? 8'h01 : Dat_Int_Status_reg;\n        CIDAT_reg <= (state == DATA_TRANSFER && crc_ok);\n    end\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\nassign re_s_tx = re_s_tx_reg;\nassign a_cmp_tx = a_cmp_tx_reg;\nassign re_s_rx = re_s_rx_reg;\nassign a_cmp_rx = a_cmp_rx_reg;\nassign we_req = we_req_reg;\nassign d_write = d_write_reg;\nassign d_read = d_read_reg;\nassign cmd_arg = cmd_arg_reg;\nassign cmd_set = cmd_set_reg;\nassign start_tx_fifo = start_tx_fifo_reg;\nassign start_rx_fifo = start_rx_fifo_reg;\nassign sys_adr = sys_adr_reg;\nassign ack_transfer = ack_transfer_reg;\nassign Dat_Int_Status = Dat_Int_Status_reg;\nassign CIDAT = CIDAT_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 12, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg [SIZE-1:0] state, next_state;\nreg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\nreg [RESEND_MAX_CNT-1:0] resend_try_cnt;\nreg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg CIDAT_reg;\nreg [7:0] Dat_Int_Status_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if(rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        CIDAT_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= resend_try_cnt + 1;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= transm_complete;\n        bd_cnt <= bd_cnt + 1;\n        sys_adr_reg <= sys_adr;\n        cmd_arg_reg <= cmd_arg;\n        cmd_set_reg <= cmd_set;\n        CIDAT_reg <= CIDAT;\n        Dat_Int_Status_reg <= Dat_Int_Status;\n    end\nend\n\nalways @(*) begin\n    case(state)\n        IDLE: begin\n            if(free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if(free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if(bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if(bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if(send_done == 1) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if(rec_done == 1) begin\n                next_state = DATA_TRANSFER;\n            end else if(rec_failed == 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if(trans_done == 1) begin\n                next_state = IDLE;\n            end else if(trans_failed == 1) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if(send_done == 1) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\nalways @(*) begin\n    case(state)\n        IDLE: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        GET_TX_BD: begin\n            re_s_tx = 1;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = dat_in_tx;\n            cmd_set = CMD24;\n            start_tx_fifo = 1;\n            start_rx_fifo = 0;\n            sys_adr = sys_adr_reg;\n            ack_transfer = 0;\n            Dat_Int_Status = Dat_Int_Status_reg;\n            CIDAT = CIDAT_reg;\n        end\n        GET_RX_BD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 1;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = dat_in_rx;\n            cmd_set = CMD17;\n            start_tx_fifo = 0;\n            start_rx_fifo = 1;\n            sys_adr = sys_adr_reg;\n            ack_transfer = 0;\n            Dat_Int_Status = Dat_Int_Status_reg;\n            CIDAT = CIDAT_reg;\n        end\n        SEND_CMD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 1;\n            d_write = (transfer_type == 2'b00) ? 1 : 0;\n            d_read = (transfer_type == 2'b01) ? 1 : 0;\n            cmd_arg = cmd_arg_reg;\n            cmd_set = cmd_set_reg;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = sys_adr_reg;\n            ack_transfer = 0;\n            Dat_Int_Status = Dat_Int_Status_reg;\n            CIDAT = CIDAT_reg;\n        end\n        RECIVE_CMD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 1;\n            sys_adr = sys_adr_reg;\n            ack_transfer = 0;\n            Dat_Int_Status = Dat_Int_Status_reg;\n            CIDAT = CIDAT_reg;\n        end\n        DATA_TRANSFER: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = (tx_cycle == 1) ? 1 : 0;\n            start_rx_fifo = (rx_cycle == 1) ? 1 : 0;\n            sys_adr = sys_adr_reg;\n            ack_transfer = (transm_complete == 1) ? 1 : 0;\n            Dat_Int_Status = Dat_Int_Status_reg;\n            CIDAT = CIDAT_reg;\n        end\n        STOP: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = CMD12;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = sys_adr_reg;\n            ack_transfer = 0;\n            Dat_Int_Status = Dat_Int_Status_reg;\n            CIDAT = CIDAT_reg;\n        end\n        STOP_SEND: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 1;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = CMD12;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = sys_adr_reg;\n            ack_transfer = 0;\n            Dat_Int_Status = Dat_Int_Status_reg;\n            CIDAT = CIDAT_reg;\n        end\n        default: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = sys_adr_reg;\n            ack_transfer = 0;\n            Dat_Int_Status = Dat_Int_Status_reg;\n            CIDAT = CIDAT_reg;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 13, "code": "// sd_data_master.v\n\n`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    // Input Ports\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    // Output Ports\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\n// Internal Signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg CIDAT_reg;\n\n// State Machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        CIDAT_reg <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    state <= GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    state <= GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    // Process data based on memory width\n                    if (RAM_MEM_WIDTH_32) begin\n                        // First read: Store data to sys_adr\n                        // Second read: Store data to cmd_arg and start TX FIFO\n                    end else if (RAM_MEM_WIDTH_16) begin\n                        // Four reads to populate sys_adr and cmd_arg (16 bits at a time)\n                        // After last read, start TX FIFO\n                    end\n                    cmd_set_reg <= CMD24;\n                    tx_cycle <= 1;\n                    state <= SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    // Process data based on memory width\n                    if (RAM_MEM_WIDTH_32) begin\n                        // First read: Store data to sys_adr\n                        // Second read: Store data to cmd_arg\n                    end else if (RAM_MEM_WIDTH_16) begin\n                        // Four reads to populate sys_adr and cmd_arg (16 bits at a time)\n                    end\n                    // Set command based on transfer_type\n                    case (transfer_type)\n                        2'b00: cmd_set_reg <= CMD17;\n                        2'b01: cmd_set_reg <= ACMD13;\n                        default: cmd_set_reg <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                    state <= SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                // Check type of cycle (rx or tx)\n                if (tx_cycle) begin\n                    d_write <= 1;\n                end else if (rx_cycle) begin\n                    d_read <= 1;\n                end\n                // Check if CMD is free\n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                        state <= RECIVE_CMD;\n                    end\n                end\n            end\n            RECIVE_CMD: begin\n                // Start Rx_Fifo_Filer if Rx cycle\n                if (rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                // Wait for command response\n                if (!cmd_busy) begin\n                    // Check response data\n                    if (card_status[0] == 1) begin\n                        // Card is ready for data\n                        state <= DATA_TRANSFER;\n                    end else if (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6) begin\n                        // Card is in transmission state for data\n                        state <= DATA_TRANSFER;\n                    end\n                end\n            end\n            DATA_TRANSFER: begin\n                // Check if tx_cycle\n                if (tx_cycle) begin\n                    // Check so tx_fifo doenst get empty\n                    if (tx_empt) begin\n                        // Handle tx_fifo empty\n                    end\n                end else if (rx_cycle) begin\n                    // Check so rx_fifo doenst get full\n                    if (rx_full) begin\n                        // Handle rx_fifo full\n                    end\n                end\n                // Wait for command complete\n                if (transm_complete) begin\n                    // Check so crc_ok == 1\n                    if (crc_ok) begin\n                        // Data transfer successful\n                        trans_done <= 1;\n                        state <= IDLE;\n                    end else begin\n                        // Data transfer failed\n                        trans_failed <= 1;\n                        state <= STOP;\n                    end\n                end\n            end\n            STOP: begin\n                // Set cmd_set to CMD12\n                cmd_set_reg <= CMD12;\n                // Reset variables\n                send_done <= 0;\n                rec_done <= 0;\n                rec_failed <= 0;\n                tx_cycle <= 0;\n                rx_cycle <= 0;\n                state <= STOP_SEND;\n            end\n            STOP_SEND: begin\n                // Increment resend_try_cnt\n                resend_try_cnt <= resend_try_cnt + 1;\n                // Check if resend_try_cnt reaches RESEND_MAX_CNT\n                if (resend_try_cnt == RESEND_MAX_CNT) begin\n                    // Set Dat_Int_Status[1] to 1\n                    Dat_Int_Status[1] <= 1;\n                end\n                // Request access to CMD registers\n                we_req <= 1;\n                if (we_ack) begin\n                    // Message has been sent\n                    state <= IDLE;\n                end\n            end\n            default: state <= IDLE;\n        endcase\n    end\nend\n\n// Output Logic\nalways @(*) begin\n    re_s_tx = 0;\n    a_cmp_tx = 0;\n    re_s_rx = 0;\n    a_cmp_rx = 0;\n    we_req = 0;\n    d_write = 0;\n    d_read = 0;\n    cmd_arg = cmd_arg_reg;\n    cmd_set = cmd_set_reg;\n    start_tx_fifo = 0;\n    start_rx_fifo = 0;\n    sys_adr = sys_adr_reg;\n    ack_transfer = 0;\n    Dat_Int_Status = 0;\n    CIDAT = CIDAT_reg;\n    case (state)\n        GET_TX_BD: begin\n            re_s_tx = 1;\n        end\n        GET_RX_BD: begin\n            re_s_rx = 1;\n        end\n        SEND_CMD: begin\n            we_req = 1;\n            if (tx_cycle) begin\n                d_write = 1;\n            end else if (rx_cycle) begin\n                d_read = 1;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                ack_transfer = 1;\n            end\n        end\n        STOP_SEND: begin\n            we_req = 1;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 14, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg Dat_Int_Status_reg [7:0];\nreg CIDAT_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n        CIDAT_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= resend_try_cnt;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= internal_transm_complete;\n        transm_complete_q <= internal_transm_complete;\n        bd_cnt <= bd_cnt;\n        sys_adr_reg <= sys_adr_reg;\n        cmd_arg_reg <= cmd_arg_reg;\n        cmd_set_reg <= cmd_set_reg;\n        Dat_Int_Status_reg <= Dat_Int_Status_reg;\n        CIDAT_reg <= CIDAT_reg;\n\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state <= GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state <= GET_RX_BD;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_TX_BD;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= GET_RX_BD;\n                end\n            end\n            SEND_CMD: begin\n                if (tx_cycle == 1) begin\n                    d_write <= 1;\n                end else if (rx_cycle == 1) begin\n                    d_read <= 1;\n                end\n                if (cmd_busy == 0) begin\n                    we_req <= 1;\n                end\n                if (we_ack == 1) begin\n                    send_done <= 1;\n                    next_state <= RECIVE_CMD;\n                end else begin\n                    next_state <= SEND_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rx_cycle == 1) begin\n                    start_rx_fifo <= 1;\n                end\n                if (cmd_tsf_err == 0 && card_status[0] == 1) begin\n                    rec_done <= 1;\n                    next_state <= DATA_TRANSFER;\n                end else if (cmd_tsf_err == 1) begin\n                    rec_failed <= 1;\n                    next_state <= SEND_CMD;\n                end else begin\n                    next_state <= RECIVE_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (tx_cycle == 1) begin\n                    if (tx_empt == 0) begin\n                        start_tx_fifo <= 1;\n                    end\n                end else if (rx_cycle == 1) begin\n                    if (rx_full == 0) begin\n                        start_rx_fifo <= 1;\n                    end\n                end\n                if (transm_complete == 1 && crc_ok == 1) begin\n                    trans_done <= 1;\n                    internal_transm_complete <= 1;\n                    next_state <= IDLE;\n                end else if (transm_complete == 1 && crc_ok == 0) begin\n                    trans_failed <= 1;\n                    next_state <= STOP;\n                end else begin\n                    next_state <= DATA_TRANSFER;\n                end\n            end\n            STOP: begin\n                cmd_set_reg <= CMD12;\n                rec_done <= 0;\n                rec_failed <= 0;\n                send_done <= 0;\n                trans_failed <= 0;\n                trans_done <= 0;\n                start_rx_fifo <= 0;\n                start_tx_fifo <= 0;\n                next_state <= STOP_SEND;\n            end\n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                    Dat_Int_Status_reg[1] <= 1;\n                end\n                if (cmd_busy == 0) begin\n                    we_req <= 1;\n                end\n                if (we_ack == 1) begin\n                    send_done <= 1;\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= STOP_SEND;\n                end\n            end\n            default: begin\n                next_state <= IDLE;\n            end\n        endcase\n    end\nend\n\nalways @(*) begin\n    re_s_tx = 0;\n    a_cmp_tx = 0;\n    re_s_rx = 0;\n    a_cmp_rx = 0;\n    we_req = 0;\n    d_write = 0;\n    d_read = 0;\n    cmd_arg = cmd_arg_reg;\n    cmd_set = cmd_set_reg;\n    start_tx_fifo = 0;\n    start_rx_fifo = 0;\n    sys_adr = sys_adr_reg;\n    ack_transfer = 0;\n    Dat_Int_Status = Dat_Int_Status_reg;\n    CIDAT = CIDAT_reg;\n\n    case (state)\n        IDLE: begin\n        end\n        GET_TX_BD: begin\n            re_s_tx = 1;\n        end\n        GET_RX_BD: begin\n            re_s_rx = 1;\n        end\n        SEND_CMD: begin\n            if (tx_cycle == 1) begin\n                d_write = 1;\n            end else if (rx_cycle == 1) begin\n                d_read = 1;\n            end\n            if (cmd_busy == 0) begin\n                we_req = 1;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rx_cycle == 1) begin\n                start_rx_fifo = 1;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (tx_cycle == 1) begin\n                if (tx_empt == 0) begin\n                    start_tx_fifo = 1;\n                end\n            end else if (rx_cycle == 1) begin\n                if (rx_full == 0) begin\n                    start_rx_fifo = 1;\n                end\n            end\n            if (transm_complete == 1 && crc_ok == 1) begin\n                ack_transfer = 1;\n            end\n        end\n        STOP: begin\n            cmd_set = CMD12;\n        end\n        STOP_SEND: begin\n        end\n        default: begin\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 15, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg Dat_Int_Status_reg [7:0];\nreg CIDAT_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n        CIDAT_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= (state == SEND_CMD && we_ack);\n        rec_done <= (state == RECIVE_CMD && !cmd_busy);\n        rec_failed <= (state == RECIVE_CMD && cmd_tsf_err);\n        tx_cycle <= (state == GET_TX_BD);\n        rx_cycle <= (state == GET_RX_BD);\n        resend_try_cnt <= (state == STOP_SEND) ? resend_try_cnt + 1 : 0;\n        trans_done <= (state == DATA_TRANSFER && transm_complete);\n        trans_failed <= (state == DATA_TRANSFER && !crc_ok);\n        internal_transm_complete <= (state == DATA_TRANSFER && transm_complete);\n        transm_complete_q <= internal_transm_complete;\n        bd_cnt <= (state == GET_TX_BD || state == GET_RX_BD) ? bd_cnt + 1 : 0;\n        sys_adr_reg <= (state == GET_TX_BD || state == GET_RX_BD) ? dat_in_tx : sys_adr_reg;\n        cmd_arg_reg <= (state == GET_TX_BD || state == GET_RX_BD) ? dat_in_tx : cmd_arg_reg;\n        cmd_set_reg <= (state == GET_TX_BD) ? CMD24 : (state == GET_RX_BD) ? CMD17 : cmd_set_reg;\n        Dat_Int_Status_reg <= (state == STOP_SEND && resend_try_cnt == RESEND_MAX_CNT) ? 1 : Dat_Int_Status_reg;\n        CIDAT_reg <= (state == DATA_TRANSFER && crc_ok) ? 1 : 0;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            re_s_tx = 1;\n            if (bd_cnt >= READ_CYCLE - 1 && tx_full) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            re_s_rx = 1;\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            we_req = 1;\n            d_write = (tx_cycle) ? 1 : 0;\n            d_read = (rx_cycle) ? 1 : 0;\n            cmd_arg = cmd_arg_reg;\n            cmd_set = cmd_set_reg;\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            start_rx_fifo = (rx_cycle) ? 1 : 0;\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (tx_cycle) begin\n                start_tx_fifo = 1;\n            end\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            cmd_set = CMD12;\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            we_req = 1;\n            d_write = 1;\n            d_read = 1;\n            if (send_done) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\nassign re_s_tx = (state == GET_TX_BD) ? 1 : 0;\nassign re_s_rx = (state == GET_RX_BD) ? 1 : 0;\nassign we_req = (state == SEND_CMD || state == STOP_SEND) ? 1 : 0;\nassign d_write = (state == SEND_CMD && tx_cycle) ? 1 : (state == STOP_SEND) ? 1 : 0;\nassign d_read = (state == SEND_CMD && rx_cycle) ? 1 : (state == STOP_SEND) ? 1 : 0;\nassign cmd_arg = cmd_arg_reg;\nassign cmd_set = cmd_set_reg;\nassign start_tx_fifo = (state == GET_TX_BD && bd_cnt >= READ_CYCLE - 1) ? 1 : 0;\nassign start_rx_fifo = (state == GET_RX_BD && bd_cnt >= READ_CYCLE - 1) ? 1 : 0;\nassign sys_adr = sys_adr_reg;\nassign ack_transfer = transm_complete_q;\nassign Dat_Int_Status = Dat_Int_Status_reg;\nassign CIDAT = CIDAT_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg re_s_tx_reg;\nreg a_cmp_tx_reg;\nreg re_s_rx_reg;\nreg a_cmp_rx_reg;\nreg we_req_reg;\nreg d_write_reg;\nreg d_read_reg;\nreg start_tx_fifo_reg;\nreg start_rx_fifo_reg;\nreg ack_transfer_reg;\nreg [7:0] Dat_Int_Status_reg;\nreg CIDAT_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        re_s_tx_reg <= 0;\n        a_cmp_tx_reg <= 0;\n        re_s_rx_reg <= 0;\n        a_cmp_rx_reg <= 0;\n        we_req_reg <= 0;\n        d_write_reg <= 0;\n        d_read_reg <= 0;\n        start_tx_fifo_reg <= 0;\n        start_rx_fifo_reg <= 0;\n        ack_transfer_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n        CIDAT_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= resend_try_cnt + 1;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= internal_transm_complete;\n        bd_cnt <= bd_cnt + 1;\n        sys_adr_reg <= sys_adr;\n        cmd_arg_reg <= cmd_arg;\n        cmd_set_reg <= cmd_set;\n        re_s_tx_reg <= re_s_tx;\n        a_cmp_tx_reg <= a_cmp_tx;\n        re_s_rx_reg <= re_s_rx;\n        a_cmp_rx_reg <= a_cmp_rx;\n        we_req_reg <= we_req;\n        d_write_reg <= d_write;\n        d_read_reg <= d_read;\n        start_tx_fifo_reg <= start_tx_fifo;\n        start_rx_fifo_reg <= start_rx_fifo;\n        ack_transfer_reg <= ack_transfer;\n        Dat_Int_Status_reg <= Dat_Int_Status;\n        CIDAT_reg <= CIDAT;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state <= GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state <= GET_RX_BD;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                next_state <= SEND_CMD;\n            end else begin\n                next_state <= GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state <= SEND_CMD;\n            end else begin\n                next_state <= GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done == 1) begin\n                next_state <= RECIVE_CMD;\n            end else begin\n                next_state <= SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done == 1) begin\n                next_state <= DATA_TRANSFER;\n            end else if (rec_failed == 1) begin\n                next_state <= SEND_CMD;\n            end else begin\n                next_state <= RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done == 1) begin\n                next_state <= IDLE;\n            end else if (trans_failed == 1) begin\n                next_state <= STOP;\n            end else begin\n                next_state <= DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state <= STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done == 1) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= STOP_SEND;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        GET_TX_BD: begin\n            re_s_tx = 1;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = dat_in_tx;\n            cmd_set = CMD24;\n            start_tx_fifo = 1;\n            start_rx_fifo = 0;\n            sys_adr = dat_in_tx;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        GET_RX_BD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 1;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = dat_in_rx;\n            cmd_set = CMD17;\n            start_tx_fifo = 0;\n            start_rx_fifo = 1;\n            sys_adr = dat_in_rx;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        SEND_CMD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 1;\n            d_write = tx_cycle;\n            d_read = rx_cycle;\n            cmd_arg = cmd_arg_reg;\n            cmd_set = cmd_set_reg;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = sys_adr_reg;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        RECIVE_CMD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = start_tx_fifo_reg;\n            start_rx_fifo = start_rx_fifo_reg;\n            sys_adr = sys_adr_reg;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        DATA_TRANSFER: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = start_tx_fifo_reg;\n            start_rx_fifo = start_rx_fifo_reg;\n            sys_adr = sys_adr_reg;\n            ack_transfer = ack_transfer_reg;\n            Dat_Int_Status = Dat_Int_Status_reg;\n            CIDAT = CIDAT_reg;\n        end\n        STOP: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = CMD12;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        STOP_SEND: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 1;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = CMD12;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        default: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n    endcase\nend\n\nassign re_s_tx = re_s_tx_reg;\nassign a_cmp_tx = a_cmp_tx_reg;\nassign re_s_rx = re_s_rx_reg;\nassign a_cmp_rx = a_cmp_rx_reg;\nassign we_req = we_req_reg;\nassign d_write = d_write_reg;\nassign d_read = d_read_reg;\nassign cmd_arg = cmd_arg_reg;\nassign cmd_set = cmd_set_reg;\nassign start_tx_fifo = start_tx_fifo_reg;\nassign start_rx_fifo = start_rx_fifo_reg;\nassign sys_adr = sys_adr_reg;\nassign ack_transfer = ack_transfer_reg;\nassign Dat_Int_Status = Dat_Int_Status_reg;\nassign CIDAT = CIDAT_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg [SIZE-1:0] state, next_state;\nreg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\nreg [RESEND_MAX_CNT-1:0] resend_try_cnt;\nreg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg re_s_tx_reg, a_cmp_tx_reg, re_s_rx_reg, a_cmp_rx_reg, we_req_reg, d_write_reg, d_read_reg, start_tx_fifo_reg, start_rx_fifo_reg, ack_transfer_reg;\nreg [7:0] Dat_Int_Status_reg;\nreg CIDAT_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        re_s_tx_reg <= 0;\n        a_cmp_tx_reg <= 0;\n        re_s_rx_reg <= 0;\n        a_cmp_rx_reg <= 0;\n        we_req_reg <= 0;\n        d_write_reg <= 0;\n        d_read_reg <= 0;\n        start_tx_fifo_reg <= 0;\n        start_rx_fifo_reg <= 0;\n        ack_transfer_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n        CIDAT_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= transm_complete;\n        if (state == GET_TX_BD) begin\n            if (bd_cnt >= READ_CYCLE - 1 && tx_full) begin\n                send_done <= 1;\n            end\n        end else if (state == GET_RX_BD) begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                send_done <= 1;\n            end\n        end else if (state == SEND_CMD) begin\n            if (we_ack) begin\n                send_done <= 1;\n            end\n        end else if (state == RECIVE_CMD) begin\n            if (cmd_busy == 0) begin\n                rec_done <= 1;\n            end\n            if (cmd_tsf_err) begin\n                rec_failed <= 1;\n            end\n        end else if (state == DATA_TRANSFER) begin\n            if (transm_complete) begin\n                trans_done <= 1;\n            end\n            if (crc_ok == 0) begin\n                trans_failed <= 1;\n            end\n        end\n    end\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            re_s_tx_reg = 1;\n            if (send_done) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            re_s_rx_reg = 1;\n            if (send_done) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            we_req_reg = 1;\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\nassign re_s_tx = re_s_tx_reg;\nassign a_cmp_tx = a_cmp_tx_reg;\nassign re_s_rx = re_s_rx_reg;\nassign a_cmp_rx = a_cmp_rx_reg;\nassign we_req = we_req_reg;\nassign d_write = d_write_reg;\nassign d_read = d_read_reg;\nassign cmd_arg = cmd_arg_reg;\nassign cmd_set = cmd_set_reg;\nassign start_tx_fifo = start_tx_fifo_reg;\nassign start_rx_fifo = start_rx_fifo_reg;\nassign sys_adr = sys_adr_reg;\nassign ack_transfer = ack_transfer_reg;\nassign Dat_Int_Status = Dat_Int_Status_reg;\nassign CIDAT = CIDAT_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 18, "code": "module sd_data_master(\n    // Input Ports\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    // Output Ports\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\n// Internal Signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_int;\nreg [31:0] cmd_arg_int;\nreg [15:0] cmd_set_int;\nreg CIDAT_int;\nreg [7:0] Dat_Int_Status_int;\n\n// FSM States\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\n\n// Commands\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\n\n// Reset Condition\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n    end else begin\n        // State Transitions\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    state <= GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    state <= GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                    state <= SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    state <= SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                we_req <= 1;\n                if (we_ack == 1) begin\n                    state <= RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (cmd_tsf_err == 0 && card_status[0] == 1) begin\n                    state <= DATA_TRANSFER;\n                end else begin\n                    state <= SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete == 1 && crc_ok == 1) begin\n                    state <= IDLE;\n                end else if (transm_complete == 1 && crc_ok == 0) begin\n                    state <= STOP;\n                end\n            end\n            STOP: begin\n                state <= STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n\n        // Output Logic\n        case (state)\n            IDLE: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                cmd_arg <= 0;\n                cmd_set <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                sys_adr <= 0;\n                ack_transfer <= 0;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt < READ_CYCLE - 1) begin\n                    sys_adr_int <= dat_in_tx;\n                end else begin\n                    cmd_arg_int <= dat_in_tx;\n                end\n                cmd_set_int <= CMD24;\n                tx_cycle <= 1;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt < READ_CYCLE - 1) begin\n                    sys_adr_int <= dat_in_rx;\n                end else begin\n                    cmd_arg_int <= dat_in_rx;\n                end\n                case (transfer_type)\n                    2'b00: cmd_set_int <= CMD17;\n                    2'b01: cmd_set_int <= ACMD13;\n                    default: cmd_set_int <= ACMD51;\n                endcase\n                rx_cycle <= 1;\n            end\n            SEND_CMD: begin\n                d_read <= (tx_cycle == 1) ? 1 : 0;\n                d_write <= (rx_cycle == 1) ? 1 : 0;\n                cmd_arg <= cmd_arg_int;\n                cmd_set <= cmd_set_int;\n            end\n            RECIVE_CMD: begin\n                start_rx_fifo <= (rx_cycle == 1) ? 1 : 0;\n                start_tx_fifo <= (tx_cycle == 1) ? 1 : 0;\n            end\n            DATA_TRANSFER: begin\n                if (tx_empt == 1 || tx_full == 1) begin\n                    start_tx_fifo <= 1;\n                end\n                if (rx_full == 1) begin\n                    start_rx_fifo <= 1;\n                end\n            end\n            STOP: begin\n                cmd_set_int <= CMD12;\n                d_read <= 1;\n                d_write <= 1;\n            end\n            STOP_SEND: begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                    Dat_Int_Status_int[1] <= 1;\n                end\n            end\n        endcase\n\n        // Update Outputs\n        cmd_arg <= cmd_arg_int;\n        cmd_set <= cmd_set_int;\n        sys_adr <= sys_adr_int;\n        Dat_Int_Status <= Dat_Int_Status_int;\n        CIDAT <= CIDAT_int;\n    end\nend\n\n// Update Internal Signals\nalways @(posedge clk) begin\n    send_done <= (state == STOP_SEND && we_ack == 1) ? 1 : 0;\n    rec_done <= (state == RECIVE_CMD && cmd_tsf_err == 0) ? 1 : 0;\n    rec_failed <= (state == RECIVE_CMD && cmd_tsf_err == 1) ? 1 : 0;\n    trans_done <= (state == DATA_TRANSFER && transm_complete == 1) ? 1 : 0;\n    trans_failed <= (state == DATA_TRANSFER && transm_complete == 1 && crc_ok == 0) ? 1 : 0;\n    internal_transm_complete <= (state == DATA_TRANSFER && transm_complete == 1) ? 1 : 0;\n    transm_complete_q <= internal_transm_complete;\n    bd_cnt <= (state == GET_TX_BD || state == GET_RX_BD) ? bd_cnt + 1 : 0;\n    CIDAT_int <= (state == DATA_TRANSFER && crc_ok == 1) ? 1 : 0;\n    Dat_Int_Status_int <= (state == STOP_SEND && resend_try_cnt >= RESEND_MAX_CNT) ? 8'b1 : 0;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 19, "code": "module sd_data_master(\n    // Input Ports\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    // Output Ports\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\n// Internal Signals\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg [8:0] state;\nreg [8:0] next_state;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg CIDAT_reg;\nreg [7:0] Dat_Int_Status_reg;\n\n// FSM States\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\n\n// Reset Condition\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        CIDAT_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n    end\nend\n\n// FSM_COMBO\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state <= GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state <= GET_RX_BD;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                next_state <= SEND_CMD;\n            end else begin\n                next_state <= GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state <= SEND_CMD;\n            end else begin\n                next_state <= GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done == 1) begin\n                next_state <= RECIVE_CMD;\n            end else begin\n                next_state <= SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done == 1) begin\n                next_state <= DATA_TRANSFER;\n            end else if (rec_failed == 1) begin\n                next_state <= SEND_CMD;\n            end else begin\n                next_state <= RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done == 1) begin\n                next_state <= IDLE;\n            end else if (trans_failed == 1) begin\n                next_state <= STOP;\n            end else begin\n                next_state <= DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state <= STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done == 1) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= STOP_SEND;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\n// FSM_OUT\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        GET_TX_BD: begin\n            re_s_tx = 1;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        GET_RX_BD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 1;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        SEND_CMD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 1;\n            d_write = (tx_cycle == 1) ? 1 : 0;\n            d_read = (rx_cycle == 1) ? 1 : 0;\n            cmd_arg = cmd_arg_reg;\n            cmd_set = cmd_set_reg;\n            start_tx_fifo = (tx_cycle == 1) ? 1 : 0;\n            start_rx_fifo = (rx_cycle == 1) ? 1 : 0;\n            sys_adr = sys_adr_reg;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        RECIVE_CMD: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = (rx_cycle == 1) ? 1 : 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        DATA_TRANSFER: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = (tx_cycle == 1) ? 1 : 0;\n            start_rx_fifo = (rx_cycle == 1) ? 1 : 0;\n            sys_adr = 0;\n            ack_transfer = (transm_complete == 1) ? 1 : 0;\n            Dat_Int_Status = Dat_Int_Status_reg;\n            CIDAT = CIDAT_reg;\n        end\n        STOP: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = CMD12;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        STOP_SEND: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 1;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = CMD12;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n        default: begin\n            re_s_tx = 0;\n            a_cmp_tx = 0;\n            re_s_rx = 0;\n            a_cmp_rx = 0;\n            we_req = 0;\n            d_write = 0;\n            d_read = 0;\n            cmd_arg = 0;\n            cmd_set = 0;\n            start_tx_fifo = 0;\n            start_rx_fifo = 0;\n            sys_adr = 0;\n            ack_transfer = 0;\n            Dat_Int_Status = 0;\n            CIDAT = 0;\n        end\n    endcase\nend\n\n// Dat_Int_Status Update\nalways @(posedge clk) begin\n    if (Dat_Int_Status_rst) begin\n        Dat_Int_Status_reg <= 0;\n    end else if (trans_failed == 1) begin\n        Dat_Int_Status_reg <= Dat_Int_Status_reg | 8'b00000001;\n    end else if (crc_ok == 0) begin\n        Dat_Int_Status_reg <= Dat_Int_Status_reg | 8'b00000010;\n    end\nend\n\n// CIDAT Update\nalways @(posedge clk) begin\n    if (crc_ok == 1) begin\n        CIDAT_reg <= 1;\n    end else begin\n        CIDAT_reg <= 0;\n    end\nend\n\n// Assign Outputs\nassign Dat_Int_Status = Dat_Int_Status_reg;\nassign CIDAT = CIDAT_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 20, "code": "module sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n\n    output re_s_tx,\n    output a_cmp_tx,\n    output re_s_rx,\n    output a_cmp_rx,\n    output we_req,\n    output d_write,\n    output d_read,\n    output [31:0] cmd_arg,\n    output [15:0] cmd_set,\n    output start_tx_fifo,\n    output start_rx_fifo,\n    output [31:0] sys_adr,\n    output ack_transfer,\n    output [7:0] Dat_Int_Status,\n    output CIDAT\n);\n\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg trans_done;\nreg trans_failed;\nreg internal_transm_complete;\nreg transm_complete_q;\nreg [2:0] bd_cnt;\nreg [31:0] sys_adr_reg;\nreg [31:0] cmd_arg_reg;\nreg [15:0] cmd_set_reg;\nreg Dat_Int_Status_reg [7:0];\nreg CIDAT_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        internal_transm_complete <= 0;\n        transm_complete_q <= 0;\n        bd_cnt <= 0;\n        sys_adr_reg <= 0;\n        cmd_arg_reg <= 0;\n        cmd_set_reg <= 0;\n        Dat_Int_Status_reg <= 0;\n        CIDAT_reg <= 0;\n    end else begin\n        state <= next_state;\n        send_done <= (state == SEND_CMD && we_ack);\n        rec_done <= (state == RECIVE_CMD && !cmd_busy);\n        rec_failed <= (state == RECIVE_CMD && cmd_tsf_err);\n        tx_cycle <= (state == GET_TX_BD);\n        rx_cycle <= (state == GET_RX_BD);\n        resend_try_cnt <= (state == STOP_SEND) ? resend_try_cnt + 1 : 0;\n        trans_done <= (state == DATA_TRANSFER && transm_complete);\n        trans_failed <= (state == DATA_TRANSFER && !crc_ok);\n        internal_transm_complete <= (state == DATA_TRANSFER && transm_complete);\n        transm_complete_q <= internal_transm_complete;\n        bd_cnt <= (state == GET_TX_BD || state == GET_RX_BD) ? bd_cnt + 1 : 0;\n        sys_adr_reg <= (state == GET_TX_BD || state == GET_RX_BD) ? dat_in_tx : sys_adr_reg;\n        cmd_arg_reg <= (state == GET_TX_BD || state == GET_RX_BD) ? dat_in_tx : cmd_arg_reg;\n        cmd_set_reg <= (state == GET_TX_BD) ? CMD24 : (state == GET_RX_BD) ? CMD17 : cmd_set_reg;\n        Dat_Int_Status_reg <= (Dat_Int_Status_rst) ? 0 : Dat_Int_Status_reg;\n        CIDAT_reg <= (state == DATA_TRANSFER && crc_ok) ? 1 : 0;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) begin\n                next_state = GET_TX_BD;\n            end else if (free_rx_bd != BD_EMPTY) begin\n                next_state = GET_RX_BD;\n            end else begin\n                next_state = IDLE;\n            end\n        end\n        GET_TX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1 && tx_full) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_TX_BD;\n            end\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = GET_RX_BD;\n            end\n        end\n        SEND_CMD: begin\n            if (send_done) begin\n                next_state = RECIVE_CMD;\n            end else begin\n                next_state = SEND_CMD;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rec_done) begin\n                next_state = DATA_TRANSFER;\n            end else if (rec_failed) begin\n                next_state = SEND_CMD;\n            end else begin\n                next_state = RECIVE_CMD;\n            end\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) begin\n                next_state = IDLE;\n            end else if (trans_failed) begin\n                next_state = STOP;\n            end else begin\n                next_state = DATA_TRANSFER;\n            end\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done) begin\n                next_state = IDLE;\n            end else begin\n                next_state = STOP_SEND;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\nassign re_s_tx = (state == GET_TX_BD);\nassign a_cmp_tx = (state == DATA_TRANSFER && trans_done);\nassign re_s_rx = (state == GET_RX_BD);\nassign a_cmp_rx = (state == DATA_TRANSFER && trans_done);\nassign we_req = (state == SEND_CMD && !cmd_busy);\nassign d_write = (state == SEND_CMD && tx_cycle);\nassign d_read = (state == SEND_CMD && rx_cycle);\nassign cmd_arg = cmd_arg_reg;\nassign cmd_set = cmd_set_reg;\nassign start_tx_fifo = (state == GET_TX_BD && tx_full);\nassign start_rx_fifo = (state == GET_RX_BD);\nassign sys_adr = sys_adr_reg;\nassign ack_transfer = transm_complete_q;\nassign Dat_Int_Status = Dat_Int_Status_reg;\nassign CIDAT = CIDAT_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 1, "code": "module sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\n\n// CRC_16_gen module\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC module\nalways @(posedge sd_clk) begin\n    ack_q <= ack_transfer;\n    ack_transfer_int <= ack_q;\nend\n\n// START_SYNC module\nalways @(posedge sd_clk) begin\n    if (~DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 1'b0;\n    end else begin\n        q_start_bit <= 1'b1;\n    end\nend\n\n// FSM_COMBO module\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (~busy_int) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (~DAR_dat_i[0]) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\n// FSM_SEQ module\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT module\nalways @(posedge sd_clk) begin\n    case (state)\n        IDLE: begin\n            // Reset CRC and pause it\n            crc_rst <= 1'b1;\n            crc_en <= 1'b0;\n            // Reset counters\n            transf_cnt <= 11'b0;\n        end\n        WRITE_DAT: begin\n            // Fill input buffers\n            temp_in <= data_in;\n            // Set output buffer\n            DAT_dat_o <= temp_in;\n            // Send start bit\n            DAT_oe_o <= 1'b1;\n            // Read 4 bits from output buffer\n            crc_in <= temp_in[3:0];\n            // Assign value to DAT_dat_o\n            DAT_dat_o <= crc_in;\n            // Increase transfer counter\n            transf_cnt <= transf_cnt + 1;\n        end\n        WRITE_CRC: begin\n            // Read CRC response token\n            crc_in <= DAR_dat_i;\n            // Check CRC status\n            if (crc_status == 3'b000) begin\n                crc_ok <= 1'b1;\n            end else begin\n                crc_ok <= 1'b0;\n            end\n        end\n        WRITE_BUSY: begin\n            // Signal for transmission complete\n            transm_complete <= 1'b1;\n            // Check busy signal\n            busy_int <= DAR_dat_i[0];\n        end\n        READ_WAIT: begin\n            // Prepare for data reception\n            crc_en <= 1'b1;\n            DAT_oe_o <= 1'b0;\n        end\n        READ_DAT: begin\n            // Read data from SD bus\n            data_out <= DAR_dat_i;\n            // Increase transfer counter\n            transf_cnt <= transf_cnt + 1;\n            // Check CRC\n            if (crc_out == crc_in) begin\n                crc_ok <= 1'b1;\n            end else begin\n                crc_ok <= 1'b0;\n            end\n        end\n        default: begin\n            // Do nothing\n        end\n    endcase\nend\n\n// Assign outputs\nassign rd = (state == READ_DAT);\nassign we = (state == WRITE_DAT);\nassign busy_n = ~busy_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 2, "code": "module sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Define parameters\nparameter SD_BUS_W = 4; // SD data bus width\nparameter BIT_BLOCK = 8; // Bit block size\nparameter CRC_OFF = 16; // CRC offset\nparameter BIT_BLOCK_REC = 8; // Bit block size for receiving\nparameter BIT_CRC_CYCLE = 16; // CRC cycle size\nparameter LITTLE_ENDIAN = 1; // Endian type (little endian)\nparameter BIG_ENDIAN = 0; // Endian type (big endian)\nparameter SD_BUS_WIDTH_1 = 1; // SD bus width of 1\nparameter SD_BUS_WIDTH_4 = 4; // SD bus width of 4\n\n// Define internal signals\nreg [SD_BUS_W-1:0] crc_in; // Input for CRC calculation\nreg crc_en; // Enable signal for CRC calculation\nreg crc_rst; // Reset signal for CRC calculation\nwire [15:0] crc_out; // Output from CRC calculation\nreg [SD_BUS_W-1:0] temp_in; // Temporary storage for input data\nreg [10:0] transf_cnt; // Transfer counter\nreg [5:0] state; // Current state of FSM\nreg [5:0] next_state; // Next state of FSM\nreg [2:0] crc_status; // Status register for CRC\nreg busy_int; // Internal busy signal\nreg ack_transfer_int; // Synchronized version of ack_transfer\nreg ack_q; // Acknowledge signal in the synchronization process\nreg q_start_bit; // Start bit indicator for the receive operation\nreg [4:0] crc_c; // CRC counter\nreg [3:0] last_din; // Last data input for CRC calculation\nreg [2:0] crc_s; // CRC status bits\nreg [31:0] write_buf_0; // Buffer for writing data (first buffer)\nreg [31:0] write_buf_1; // Buffer for writing data (second buffer)\nreg [31:0] sd_data_out; // Output data buffer\nreg out_buff_ptr; // Pointer for output buffer\nreg in_buff_ptr; // Pointer for input buffer\nreg [2:0] data_send_index; // Index for data being sent\n\n// Define sub-modules\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// Define combinational logic for state transitions\nalways @(*) begin\n    case(state)\n        6'd0: // IDLE state\n            if(start_dat == 2'b01) begin\n                next_state = 6'd1; // Start read block\n            end else if(start_dat == 2'b10) begin\n                next_state = 6'd2; // Start write block\n            end else begin\n                next_state = 6'd0; // Remain in idle state\n            end\n        6'd1: // READ_WAIT state\n            if(DAR_dat_i[0] == 1'b0) begin\n                next_state = 6'd3; // Start bit detected, begin reading data\n            end else begin\n                next_state = 6'd1; // Wait for start bit\n            end\n        6'd2: // WRITE_DAT state\n            if(transf_cnt == SD_BUS_W) begin\n                next_state = 6'd4; // All data transferred, transition to CRC generation\n            end else begin\n                next_state = 6'd2; // Continue writing data\n            end\n        6'd3: // READ_DAT state\n            if(transf_cnt == SD_BUS_W) begin\n                next_state = 6'd0; // All data read, return to idle\n            end else begin\n                next_state = 6'd3; // Continue reading data\n            end\n        6'd4: // WRITE_CRC state\n            if(crc_status == 3'd0) begin\n                next_state = 6'd5; // CRC successfully generated, transition to busy state\n            end else begin\n                next_state = 6'd4; // Continue CRC generation\n            end\n        6'd5: // WRITE_BUSY state\n            if(busy_int == 1'b0) begin\n                next_state = 6'd0; // Data transmission complete, return to idle\n            end else begin\n                next_state = 6'd5; // Continue waiting for busy signal to deassert\n            end\n        default: next_state = 6'd0; // Default to idle state\n    endcase\nend\n\n// Define sequential logic for state updates\nalways @(posedge sd_clk or posedge rst) begin\n    if(rst) begin\n        state <= 6'd0; // Reset state to idle\n    end else begin\n        state <= next_state; // Update state\n    end\nend\n\n// Define output logic\nalways @(*) begin\n    case(state)\n        6'd0: // IDLE state\n            begin\n                rd = 1'b0; // Disable read\n                we = 1'b0; // Disable write\n                DAT_oe_o = 1'b0; // Disable output\n                DAT_dat_o = {SD_BUS_W{1'b0}}; // Set output to zero\n                busy_n = 1'b1; // Set busy signal to high\n                transm_complete = 1'b0; // Set transmission complete to low\n                crc_ok = 1'b0; // Set CRC ok to low\n            end\n        6'd1: // READ_WAIT state\n            begin\n                rd = 1'b1; // Enable read\n                we = 1'b0; // Disable write\n                DAT_oe_o = 1'b0; // Disable output\n                DAT_dat_o = {SD_BUS_W{1'b0}}; // Set output to zero\n                busy_n = 1'b0; // Set busy signal to low\n                transm_complete = 1'b0; // Set transmission complete to low\n                crc_ok = 1'b0; // Set CRC ok to low\n            end\n        6'd2: // WRITE_DAT state\n            begin\n                rd = 1'b0; // Disable read\n                we = 1'b1; // Enable write\n                DAT_oe_o = 1'b1; // Enable output\n                DAT_dat_o = sd_data_out; // Set output to data\n                busy_n = 1'b0; // Set busy signal to low\n                transm_complete = 1'b0; // Set transmission complete to low\n                crc_ok = 1'b0; // Set CRC ok to low\n            end\n        6'd3: // READ_DAT state\n            begin\n                rd = 1'b1; // Enable read\n                we = 1'b0; // Disable write\n                DAT_oe_o = 1'b0; // Disable output\n                DAT_dat_o = {SD_BUS_W{1'b0}}; // Set output to zero\n                busy_n = 1'b0; // Set busy signal to low\n                transm_complete = 1'b0; // Set transmission complete to low\n                crc_ok = 1'b0; // Set CRC ok to low\n            end\n        6'd4: // WRITE_CRC state\n            begin\n                rd = 1'b0; // Disable read\n                we = 1'b0; // Disable write\n                DAT_oe_o = 1'b1; // Enable output\n                DAT_dat_o = crc_out; // Set output to CRC\n                busy_n = 1'b0; // Set busy signal to low\n                transm_complete = 1'b0; // Set transmission complete to low\n                crc_ok = 1'b0; // Set CRC ok to low\n            end\n        6'd5: // WRITE_BUSY state\n            begin\n                rd = 1'b0; // Disable read\n                we = 1'b0; // Disable write\n                DAT_oe_o = 1'b0; // Disable output\n                DAT_dat_o = {SD_BUS_W{1'b0}}; // Set output to zero\n                busy_n = 1'b0; // Set busy signal to low\n                transm_complete = 1'b1; // Set transmission complete to high\n                crc_ok = 1'b1; // Set CRC ok to high\n            end\n        default: // Default to idle state\n            begin\n                rd = 1'b0; // Disable read\n                we = 1'b0; // Disable write\n                DAT_oe_o = 1'b0; // Disable output\n                DAT_dat_o = {SD_BUS_W{1'b0}}; // Set output to zero\n                busy_n = 1'b1; // Set busy signal to high\n                transm_complete = 1'b0; // Set transmission complete to low\n                crc_ok = 1'b0; // Set CRC ok to low\n            end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 3, "code": "module sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Define parameters\nparameter SD_BUS_W = 4;\nparameter BIT_BLOCK = 8;\nparameter CRC_OFF = 2;\nparameter BIT_BLOCK_REC = 8;\nparameter BIT_CRC_CYCLE = 16;\nparameter LITLE_ENDIAN = 1;\nparameter BIG_ENDIAN = 0;\nparameter SD_BUS_WIDTH_1 = 1;\nparameter SD_BUS_WIDTH_4 = 4;\n\n// Define internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// Define sub-modules\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == 6'd2) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_COMBO block\nalways @(*) begin\n    case (state)\n        6'd0: begin // IDLE state\n            if (start_dat == 2'b01) begin\n                next_state = 6'd1; // Start read block\n            end else if (start_dat == 2'b10) begin\n                next_state = 6'd3; // Start write block\n            end else begin\n                next_state = 6'd0; // Remain in IDLE state\n            end\n        end\n        6'd1: begin // READ_WAIT state\n            if (q_start_bit == 0) begin\n                next_state = 6'd2; // Start reading data\n            end else begin\n                next_state = 6'd1; // Wait for start bit\n            end\n        end\n        6'd2: begin // READ_DAT state\n            if (transf_cnt == SD_BUS_W) begin\n                next_state = 6'd0; // Return to IDLE state\n            end else begin\n                next_state = 6'd2; // Continue reading data\n            end\n        end\n        6'd3: begin // WRITE_DAT state\n            if (transf_cnt == SD_BUS_W) begin\n                next_state = 6'd4; // Transition to CRC generation\n            end else begin\n                next_state = 6'd3; // Continue writing data\n            end\n        end\n        6'd4: begin // WRITE_CRC state\n            if (crc_status == 3'd0) begin\n                next_state = 6'd5; // Transition to busy state\n            end else begin\n                next_state = 6'd4; // Continue CRC generation\n            end\n        end\n        6'd5: begin // WRITE_BUSY state\n            if (busy_int == 0) begin\n                next_state = 6'd0; // Return to IDLE state\n            end else begin\n                next_state = 6'd5; // Continue waiting for busy signal\n            end\n        end\n        default: begin\n            next_state = 6'd0; // Default to IDLE state\n        end\n    endcase\nend\n\n// FSM_SEQ block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= 6'd0; // Reset to IDLE state\n    end else begin\n        state <= next_state; // Update state\n    end\nend\n\n// FSM_OUT block\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        // Reset all output signals\n        DAT_oe_o <= 0;\n        DAT_dat_o <= 0;\n        rd <= 0;\n        we <= 0;\n        data_out <= 0;\n        busy_n <= 1;\n        transm_complete <= 0;\n        crc_ok <= 0;\n        // Reset internal signals\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        sd_data_out <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n        data_send_index <= 0;\n    end else begin\n        case (state)\n            6'd1: begin // READ_WAIT state\n                // Prepare for data reception\n                DAT_oe_o <= 0;\n                rd <= 1;\n                we <= 0;\n                data_out <= DAR_dat_i;\n                busy_n <= 0;\n            end\n            6'd2: begin // READ_DAT state\n                // Read data from SD bus\n                DAT_dat_o <= DAR_dat_i;\n                rd <= 1;\n                we <= 0;\n                data_out <= DAR_dat_i;\n                busy_n <= 0;\n                if (transf_cnt == SD_BUS_W) begin\n                    // Check CRC\n                    crc_ok <= (crc_out == 16'd0);\n                    transm_complete <= 1;\n                end\n            end\n            6'd3: begin // WRITE_DAT state\n                // Write data to SD bus\n                DAT_oe_o <= 1;\n                DAT_dat_o <= write_buf_0[SD_BUS_W-1:0];\n                rd <= 0;\n                we <= 1;\n                data_out <= 0;\n                busy_n <= 0;\n                if (transf_cnt == SD_BUS_W) begin\n                    // Transition to CRC generation\n                    crc_en <= 1;\n                end\n            end\n            6'd4: begin // WRITE_CRC state\n                // Generate CRC\n                crc_en <= 1;\n                DAT_oe_o <= 1;\n                DAT_dat_o <= crc_out[SD_BUS_W-1:0];\n                rd <= 0;\n                we <= 0;\n                data_out <= 0;\n                busy_n <= 0;\n                if (crc_status == 3'd0) begin\n                    // Transition to busy state\n                    busy_int <= 1;\n                end\n            end\n            6'd5: begin // WRITE_BUSY state\n                // Wait for busy signal\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 0;\n                we <= 0;\n                data_out <= 0;\n                busy_n <= 0;\n                if (busy_int == 0) begin\n                    // Return to IDLE state\n                    transm_complete <= 1;\n                end\n            end\n            default: begin\n                // Reset all output signals\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 0;\n                rd <= 0;\n                we <= 0;\n                data_out <= 0;\n                busy_n <= 1;\n                transm_complete <= 0;\n                crc_ok <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 4, "code": "// sd_data_serial_host module\nmodule sd_data_serial_host(\n    input sd_clk, // Clock signal for synchronization\n    input rst, // Reset signal to initialize the module\n    input [31:0] data_in, // 32-bit input data to transmit\n    input [1:0] start_dat, // Start data transfer\n    input ack_transfer, // ACK on transmission complete\n    input [SD_BUS_W-1:0] DAR_dat_i, // SD card data input\n\n    output rd, // FIFO read enable\n    output [SD_BUS_W-1:0] data_out, // FIFO data out\n    output we, // FIFO WriteEnable\n    output DAT_oe_o, // Tri-state Output enable\n    output [SD_BUS_W-1:0] DAT_dat_o, // SD Data output\n    output busy_n, // Data line Busy Active Low\n    output transm_complete, // Transmission complete\n    output crc_ok // CRC checksum ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in; // Input for CRC calculation\nreg crc_en; // Enable signal for CRC calculation\nreg crc_rst; // Reset signal for CRC calculation\nwire [15:0] crc_out; // Output from CRC calculation\nreg [SD_BUS_W-1:0] temp_in; // Temporary storage for input data\nreg [10:0] transf_cnt; // Transfer counter\nreg [5:0] state; // Current state of FSM\nreg [5:0] next_state; // Next state of FSM\nreg [2:0] crc_status; // Status register for CRC\nreg busy_int; // Internal busy signal\nreg ack_transfer_int; // Synchronized version of ack_transfer\nreg ack_q; // Acknowledge signal in the synchronization process\nreg q_start_bit; // Start bit indicator for the receive operation\nreg [4:0] crc_c; // CRC counter\nreg [3:0] last_din; // Last data input for CRC calculation\nreg [2:0] crc_s; // CRC status bits\nreg [31:0] write_buf_0; // Buffer for writing data (first buffer)\nreg [31:0] write_buf_1; // Buffer for writing data (second buffer)\nreg [31:0] sd_data_out; // Output data buffer\nreg out_buff_ptr; // Pointer for output buffer\nreg in_buff_ptr; // Pointer for input buffer\nreg [2:0] data_send_index; // Index for data being sent\n\n// CRC_16_gen submodule\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC submodule\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC submodule\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ submodule\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT submodule\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        // Reset all output signals\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Fill in buffers with data from FIFO\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set output buffer to point to in buffer\n                sd_data_out <= write_buf_0;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from output buffer and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // Repeat until 512 bytes have been sent\n                if (transf_cnt == 512) begin\n                    // Attach 16-bit CRC to each data line\n                    crc_en <= 1;\n                end\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Read stop bit\n                if (DAR_dat_i[0] == 1) begin\n                    // Set transm_complete and crc_ok\n                    transm_complete <= 1;\n                    crc_ok <= (crc_s == crc_out[2:0]);\n                end\n            end\n            WRITE_BUSY: begin\n                // Signal for transmission complete\n                transm_complete <= 1;\n                // Check CRC response and set crc_ok\n                crc_ok <= (crc_s == crc_out[2:0]);\n                // Poll DAT_dat_i[0] to sense busy\n                busy_int <= DAR_dat_i[0];\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                // Set up internal control register\n                sd_data_out <= 0;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == 512) begin\n                    // Compare received CRC bits with calculated crc_out values\n                    crc_ok <= (crc_out == crc_in);\n                    // Set transm_complete\n                    transm_complete <= 1;\n                end\n            end\n            default: begin\n                // Default to idle state\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// FSM_COMBO submodule\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == 512) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (busy_int == 0) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (q_start_bit == 0) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == 512) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 5, "code": "module sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// CRC_16_gen submodule\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC submodule\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC submodule\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ submodule\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT submodule\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        // Reset all output signals\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Fill inbuffers with data from FIFO\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set output buffer to point to inbuffer\n                sd_data_out <= write_buf_0;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from output buffer and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // When 28 bits have been sent, increase out_buff_ptr and read in new value to sd_data_out\n                if (transf_cnt == 28) begin\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    sd_data_out <= write_buf_1;\n                end\n                // Repeat until 512 bytes have been sent\n                transf_cnt <= transf_cnt + 1;\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Read stop bit\n                if (DAR_dat_i[0] == 1) begin\n                    // Set transm_complete and crc_ok\n                    transm_complete <= 1;\n                    crc_ok <= (crc_s == 0);\n                end\n            end\n            WRITE_BUSY: begin\n                // Signal for transm_complete\n                transm_complete <= 1;\n                // Check CRC response and set crc_ok\n                crc_ok <= (crc_s == 0);\n                // Poll DAT_dat_i[0] to sense when card is busy\n                busy_int <= DAT_dat_i[0];\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                // Set up internal control register\n                data_send_index <= 0;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == 512) begin\n                    // Compare received CRC bits with calculated crc_out values\n                    crc_ok <= (crc_out == crc_in);\n                    // Set transm_complete\n                    transm_complete <= 1;\n                end\n            end\n            default: begin\n                // Default to IDLE state\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// FSM_COMBO submodule\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (busy_int == 0) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (q_start_bit == 0) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 6, "code": "module sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// CRC_16_gen module\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC module\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC module\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ module\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_COMBO module\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (!DAR_dat_i[0]) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\n// FSM_OUT module\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        // Reset all output signals\n        DAT_oe_o <= 0;\n        DAT_dat_o <= 0;\n        rd <= 0;\n        we <= 0;\n        busy_n <= 1;\n        transm_complete <= 0;\n        crc_ok <= 0;\n        // Reset all internal registers\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        sd_data_out <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n        data_send_index <= 0;\n        crc_in <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_s <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Fill inbufferts with data from FIFO\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set outputbuffert to point at inbuffert\n                sd_data_out <= write_buf_0;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from outputbuffert and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // Increase out_buff_ptr and read in new value to sd_data_out\n                out_buff_ptr <= out_buff_ptr + 1;\n                sd_data_out <= write_buf_1;\n                // Repeat until 512 bytes have been sent\n                transf_cnt <= transf_cnt + 1;\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Check CRC status\n                if (crc_s == 3'b000) begin\n                    crc_ok <= 1;\n                end else begin\n                    crc_ok <= 0;\n                end\n            end\n            WRITE_BUSY: begin\n                // Signal for transm_complete\n                transm_complete <= 1;\n                // Check CRC response\n                if (crc_s == 3'b000) begin\n                    crc_ok <= 1;\n                end else begin\n                    crc_ok <= 0;\n                end\n                // Poll DAT_dat_i[0] to sense whenever the card is busy\n                busy_n <= !DAR_dat_i[0];\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                // Set up internal control register\n                in_buff_ptr <= 0;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == SD_BUS_W) begin\n                    // Compare received CRC bits with calculated crc_out values\n                    if (crc_out == DAR_dat_i) begin\n                        crc_ok <= 1;\n                    end else begin\n                        crc_ok <= 0;\n                    end\n                    // Set transm_complete when 16 CRC bits have been read\n                    transm_complete <= 1;\n                end\n            end\n            default: begin\n                // Do nothing\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 7, "code": "module sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// CRC_16_gen module\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC module\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC module\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ module\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_COMBO module\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (!DAR_dat_i[0]) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\n// FSM_OUT module\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        // Reset all output signals\n        rd <= 0;\n        data_out <= 0;\n        we <= 0;\n        DAT_oe_o <= 0;\n        DAT_dat_o <= 0;\n        busy_n <= 1;\n        transm_complete <= 0;\n        crc_ok <= 0;\n        // Reset all internal signals\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        sd_data_out <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n        data_send_index <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Fill inbuffers with data from FIFO\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set output buffer to point to inbuffer\n                sd_data_out <= write_buf_0;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from output buffer and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // Increment out_buff_ptr and read in new value to sd_data_out from inbuffer\n                out_buff_ptr <= out_buff_ptr + 1;\n                sd_data_out <= write_buf_1;\n                // Repeat until 512 bytes have been sent\n                transf_cnt <= transf_cnt + 1;\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Check CRC status\n                if (crc_s == 3'b000) begin\n                    crc_ok <= 1;\n                end else begin\n                    crc_ok <= 0;\n                end\n            end\n            WRITE_BUSY: begin\n                // Signal for transm_complete\n                transm_complete <= 1;\n                // Check CRC response\n                if (crc_ok) begin\n                    // Poll DAT_dat_i[0] to sense whenever the card is busy\n                    busy_n <= !DAR_dat_i[0];\n                end\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                // Set up internal control register\n                in_buff_ptr <= 0;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increment transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == SD_BUS_W) begin\n                    // Compare received CRC bits with calculated crc_out values\n                    if (crc_out == DAR_dat_i) begin\n                        crc_ok <= 1;\n                    end else begin\n                        crc_ok <= 0;\n                    end\n                    // Set transm_complete when 16 CRC bits have been read\n                    transm_complete <= 1;\n                    // Clear busy_n to indicate operation completion\n                    busy_n <= 0;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 8, "code": "```ilog\nmodule sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// Sub-modules\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Fill input buffers with data from FIFO\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set output buffer to point to input buffer\n                sd_data_out <= write_buf_0;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from output buffer and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // Repeat until 28 bits have been sent\n                if (transf_cnt == 28) begin\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    sd_data_out <= write_buf_1;\n                end\n                // Attach 16-bit CRC to each data line\n                crc_en <= 1;\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Ignore first 3 cycles, 2 delay and 1 start bit\n                if (transf_cnt == 7) begin\n                    // Save bit 4 to 6 to crc_s\n                    crc_s <= DAR_dat_i[2:0];\n                end\n                // Read bit nr 7, the stop bit\n                if (transf_cnt == 8) begin\n                    crc_rst <= 0;\n                end\n            end\n            WRITE_BUSY: begin\n                // Signal for transm_complete\n                transm_complete <= 1;\n                // Check CRC response and set crc_ok\n                if (crc_s == 7) begin\n                    crc_ok <= 1;\n                end\n                // Poll DAT_dat_i[0] to sense whenever the card is busy\n                busy_int <= DAR_dat_i[0];\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                // Set up internal control register\n                rd <= 1;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == 512) begin\n                    // Compare received CRC bits with calculated crc_out values\n                    if (crc_out == DAR_dat_i) begin\n                        crc_ok <= 1;\n                    end\n                    // Set transm_complete when 16 CRC bits have been read\n                    transm_complete <= 1;\n                end\n                // Clear busy_n to indicate operation completion\n                busy_n <= 0;\n            end\n            default: begin\n                // Default to idle state\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// FSM_COMBO\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (busy_int == 0) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (q_start_bit == 0) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 9, "code": "module sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// CRC_16_gen module\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC module\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC module\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ module\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT module\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        // Reset all output signals\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Fill input buffers with data from FIFO\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set output buffer to point to input buffer\n                sd_data_out <= write_buf_0;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from output buffer and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // When 28 bits have been sent, increase out_buff_ptr and read in new value to sd_data_out\n                if (transf_cnt == 28) begin\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    sd_data_out <= write_buf_1;\n                end\n                // Repeat until 512 bytes have been sent\n                transf_cnt <= transf_cnt + 1;\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Ignore first 3 cycles, 2 delay and 1 start bit\n                // Save bit 4 to 6 to crc_s\n                crc_s <= DAR_dat_i[2:0];\n                // Read bit 7, stop bit\n                crc_s <= DAR_dat_i[0];\n            end\n            WRITE_BUSY: begin\n                // Signal for transm_complete\n                transm_complete <= 1;\n                // Check CRC response and set crc_ok\n                crc_ok <= (crc_s == 0);\n                // Poll DAT_dat_i[0] to sense whenever card is busy\n                busy_int <= DAR_dat_i[0];\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                // Set up internal control register\n                transf_cnt <= 0;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == 512) begin\n                    // Compare received CRC bits with calculated crc_out values\n                    crc_ok <= (crc_out == crc_in);\n                    // Set transm_complete when 16 CRC bits have been read\n                    transm_complete <= 1;\n                    // Clear busy_n to indicate operation completion\n                    busy_n <= 0;\n                end\n            end\n            default: begin\n                // Default to idle state\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// FSM_COMBO module\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (busy_int == 0) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (q_start_bit == 0) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 10, "code": "// sd_data_serial_host module\nmodule sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// CRC_16_gen submodule\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC submodule\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC submodule\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ submodule\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT submodule\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        // Reset all signals\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Fill inbuffers with data from FIFO\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set output buffer to point to inbuffer\n                sd_data_out <= write_buf_0;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from output buffer and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // When 28 bits have been sent, increase out_buff_ptr and read in new value to sd_data_out\n                if (transf_cnt == 28) begin\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    sd_data_out <= write_buf_1;\n                end\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Check CRC status\n                if (crc_s == 7) begin\n                    crc_ok <= 1;\n                end else begin\n                    crc_ok <= 0;\n                end\n            end\n            WRITE_BUSY: begin\n                // Signal for transm_complete\n                transm_complete <= 1;\n                // Check CRC status\n                if (crc_ok) begin\n                    crc_status <= 0;\n                end else begin\n                    crc_status <= 7;\n                end\n                // Poll DAT_dat_i[0] to sense whenever the card is busy\n                busy_int <= DAR_dat_i[0];\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                // Set up internal control register\n                data_send_index <= 0;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == 512) begin\n                    // Compare received CRC bits with calculated crc_out values\n                    if (crc_out == crc_in) begin\n                        crc_ok <= 1;\n                    end else begin\n                        crc_ok <= 0;\n                    end\n                    // Set transm_complete when 16 CRC bits have been read\n                    transm_complete <= 1;\n                    // Clear busy_n to indicate operation completion\n                    busy_n <= 0;\n                end\n            end\n        endcase\n    end\nend\n\n// FSM_COMBO submodule\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 0) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (busy_int == 0) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (DAR_dat_i[0] == 0) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 11, "code": "module sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// Sub-modules\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (~DAR_dat_i[0] & (state == 6'd2)) begin // READ_WAIT state\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= 6'd0; // IDLE state\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        // Reset all output signals\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 3'd7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            6'd0: begin // IDLE state\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            6'd1: begin // WRITE_DAT state\n                // Fill input buffers with data from FIFO\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set output buffer to point to input buffer\n                sd_data_out <= write_buf_0;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from output buffer and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // Repeat until 28 bits have been sent\n                if (transf_cnt == 28) begin\n                    // Increase out_buff_ptr and read in new value to sd_data_out\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    sd_data_out <= write_buf_1;\n                end\n            end\n            6'd2: begin // WRITE_CRC state\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Read stop bit\n                if (DAR_dat_i[0] == 1) begin\n                    // Set transm_complete\n                    transm_complete <= 1;\n                end\n            end\n            6'd3: begin // WRITE_BUSY state\n                // Signal for transm_complete\n                transm_complete <= 1;\n                // Check CRC response and set crc_ok\n                if (crc_s == 3'd0) begin\n                    crc_ok <= 1;\n                end\n                // Poll DAT_dat_i[0] to sense busy\n                busy_int <= DAR_dat_i[0];\n            end\n            6'd4: begin // READ_WAIT state\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                // Set up internal control register\n                data_send_index <= 0;\n            end\n            6'd5: begin // READ_DAT state\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == 512) begin\n                    // Compare received CRC bits with calculated crc_out values\n                    if (crc_out == crc_in) begin\n                        crc_ok <= 1;\n                    end\n                    // Set transm_complete\n                    transm_complete <= 1;\n                end\n            end\n            default: begin\n                // Default to IDLE state\n                state <= 6'd0;\n            end\n        endcase\n    end\nend\n\n// FSM_COMBO\nalways @(*) begin\n    case (state)\n        6'd0: begin // IDLE state\n            if (start_dat == 2'd1) begin // Start read block\n                next_state <= 6'd4; // READ_WAIT state\n            end else if (start_dat == 2'd2) begin // Start write block\n                next_state <= 6'd1; // WRITE_DAT state\n            end else begin\n                next_state <= 6'd0; // IDLE state\n            end\n        end\n        6'd1: begin // WRITE_DAT state\n            if (transf_cnt == 28) begin\n                next_state <= 6'd2; // WRITE_CRC state\n            end else begin\n                next_state <= 6'd1; // WRITE_DAT state\n            end\n        end\n        6'd2: begin // WRITE_CRC state\n            if (DAR_dat_i[0] == 1) begin\n                next_state <= 6'd3; // WRITE_BUSY state\n            end else begin\n                next_state <= 6'd2; // WRITE_CRC state\n            end\n        end\n        6'd3: begin // WRITE_BUSY state\n            if (busy_int == 0) begin\n                next_state <= 6'd0; // IDLE state\n            end else begin\n                next_state <= 6'd3; // WRITE_BUSY state\n            end\n        end\n        6'd4: begin // READ_WAIT state\n            if (q_start_bit == 0) begin\n                next_state <= 6'd5; // READ_DAT state\n            end else begin\n                next_state <= 6'd4; // READ_WAIT state\n            end\n        end\n        6'd5: begin // READ_DAT state\n            if (transf_cnt == 512) begin\n                next_state <= 6'd0; // IDLE state\n            end else begin\n                next_state <= 6'd5; // READ_DAT state\n            end\n        end\n        default: begin\n            next_state <= 6'd0; // IDLE state\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 12, "code": "// sd_data_serial_host module\nmodule sd_data_serial_host(\n    // Input Ports\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n\n    // Output Ports\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal Signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// Sub-Modules\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAT_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        // Reset values for variables\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Fill input buffers with data from FIFO\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set output buffer to point to input buffer\n                sd_data_out <= write_buf_0;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from output buffer and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // When 28 bits have been sent, increase out_buff_ptr and read new value from input buffer\n                if (transf_cnt == 28) begin\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    sd_data_out <= write_buf_1;\n                end\n                // Repeat until 512 bytes have been sent\n                transf_cnt <= transf_cnt + 1;\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Check CRC status\n                if (crc_s == 7) begin\n                    crc_ok <= 1;\n                end else begin\n                    crc_ok <= 0;\n                end\n                // Signal for transmission complete\n                transm_complete <= 1;\n            end\n            WRITE_BUSY: begin\n                // Poll DAT_dat_i[0] to sense when card is busy\n                busy_int <= DAT_dat_i[0];\n                // Check if card is busy\n                if (busy_int == 0) begin\n                    busy_n <= 0;\n                end else begin\n                    busy_n <= 1;\n                end\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                // Set up internal control register\n                rd <= 1;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == 512) begin\n                    // Compare received CRC bits with calculated crc_out values\n                    if (crc_out == crc_in) begin\n                        crc_ok <= 1;\n                    end else begin\n                        crc_ok <= 0;\n                    end\n                    // Set transmission complete\n                    transm_complete <= 1;\n                end\n            end\n            default: begin\n                // Default to idle state\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// FSM_COMBO\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b111) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (busy_int == 0) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (q_start_bit == 0) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 13, "code": "// sd_data_serial_host module\nmodule sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// CRC_16_gen submodule\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC submodule\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC submodule\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ submodule\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_COMBO submodule\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (busy_int == 0) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (DAR_dat_i[0] == 0) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\n// FSM_OUT submodule\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        // Reset all output signals\n        DAT_oe_o <= 0;\n        DAT_dat_o <= 0;\n        rd <= 0;\n        we <= 0;\n        busy_n <= 1;\n        transm_complete <= 0;\n        crc_ok <= 0;\n        // Reset all internal signals\n        crc_in <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        temp_in <= 0;\n        transf_cnt <= 0;\n        crc_status <= 3'b000;\n        busy_int <= 0;\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n        q_start_bit <= 1;\n        crc_c <= 0;\n        last_din <= 0;\n        crc_s <= 0;\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        sd_data_out <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n        data_send_index <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Fill inbufferts with data from FIFO\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set outputbuffert to point at inbuffert\n                sd_data_out <= write_buf_0;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from outputbuffert and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // When 28 bits have been sent, increase out_buff_ptr and read in new value to sd_data_out\n                if (transf_cnt == 28) begin\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    sd_data_out <= write_buf_1;\n                end\n                // Repeat until 512 bytes have been sent\n                transf_cnt <= transf_cnt + 1;\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Read stop bit\n                if (DAR_dat_i[0] == 1) begin\n                    next_state <= WRITE_BUSY;\n                end\n            end\n            WRITE_BUSY: begin\n                // Signal for transm_complete\n                transm_complete <= 1;\n                // Check CRC response and set crc_ok\n                if (crc_s == 3'b000) begin\n                    crc_ok <= 1;\n                end\n                // Poll DAT_dat_i[0] to sense whenever the card is busy\n                busy_int <= DAR_dat_i[0];\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                // Set up internal control register\n                in_buff_ptr <= 0;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state <= IDLE;\n                end\n            end\n            default: begin\n                // Do nothing\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 14, "code": "// sd_data_serial_host module\nmodule sd_data_serial_host(\n    input sd_clk, // Clock signal for synchronization\n    input rst, // Reset signal to initialize the module\n    input [31:0] data_in, // 32-bit input data to transmit\n    input [1:0] start_dat, // Start data transfer\n    input ack_transfer, // ACK on transmission complete\n    input [SD_BUS_W-1:0] DAR_dat_i, // SD card data input\n    output rd, // FIFO read enable\n    output [SD_BUS_W-1:0] data_out, // FIFO data out\n    output we, // FIFO Write Enable\n    output DAT_oe_o, // Tri-state Output enable\n    output [SD_BUS_W-1:0] DAT_dat_o, // SD Data output\n    output busy_n, // Data line Busy Active Low\n    output transm_complete, // Transmission complete\n    output crc_ok // CRC checksum ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in; // Input for CRC calculation\nreg crc_en; // Enable signal for CRC calculation\nreg crc_rst; // Reset signal for CRC calculation\nwire [15:0] crc_out; // Output from CRC calculation\nreg [SD_BUS_W-1:0] temp_in; // Temporary storage for input data\nreg [10:0] transf_cnt; // Transfer counter\nreg [5:0] state; // Current state of FSM\nreg [5:0] next_state; // Next state of FSM\nreg [2:0] crc_status; // Status register for CRC\nreg busy_int; // Internal busy signal\nreg ack_transfer_int; // Synchronized version of ack_transfer\nreg ack_q; // Acknowledge signal in the synchronization process\nreg q_start_bit; // Start bit indicator for the receive operation\nreg [4:0] crc_c; // CRC counter\nreg [3:0] last_din; // Last data input for CRC calculation\nreg [2:0] crc_s; // CRC status bits\nreg [31:0] write_buf_0; // Buffer for writing data (first buffer)\nreg [31:0] write_buf_1; // Buffer for writing data (second buffer)\nreg [31:0] sd_data_out; // Output data buffer\nreg out_buff_ptr; // Pointer for output buffer\nreg in_buff_ptr; // Pointer for input buffer\nreg [2:0] data_send_index; // Index for data being sent\n\n// CRC_16_gen module\nmodule sd_crc_16(\n    input BITVAL, // Next input bit\n    input Enable, // Enables CRC updating\n    input CLK, // Current bit valid (Clock)\n    input RST, // Initializes CRC value to zero\n    output [15:0] CRC // Current output CRC value\n);\n\n// ACK_SYNC module\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC module\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ module\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_COMBO module\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (!DAR_dat_i[0]) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\n// FSM_OUT module\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        // Reset all output signals\n        DAT_oe_o <= 0;\n        DAT_dat_o <= 0;\n        rd <= 0;\n        we <= 0;\n        busy_n <= 1;\n        transm_complete <= 0;\n        crc_ok <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Fill in buffers with data from FIFO\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set output buffer to point to in buffer\n                sd_data_out <= write_buf_0;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from output buffer and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // When 28 bits have been sent, increase out_buff_ptr and read in new value to sd_data_out\n                if (transf_cnt == 28) begin\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    sd_data_out <= write_buf_1;\n                end\n                // Repeat until 512 bytes have been sent\n                transf_cnt <= transf_cnt + 1;\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_in <= DAR_dat_i;\n                // Ignore first 3 cycles, 2 delay and 1 start bit\n                if (transf_cnt >= 3) begin\n                    // Save bits 4 to 6 to crc_s\n                    crc_s <= DAR_dat_i[2:0];\n                end\n                // Read bit 7, the stop bit\n                if (transf_cnt == 7) begin\n                    crc_rst <= 0;\n                    crc_en <= 1;\n                end\n            end\n            WRITE_BUSY: begin\n                // Signal for transmission complete\n                transm_complete <= 1;\n                // Check CRC response and set crc_ok\n                if (crc_s == 3'b000) begin\n                    crc_ok <= 1;\n                end else begin\n                    crc_ok <= 0;\n                end\n                // Poll DAT_dat_i[0] to sense when card is busy\n                busy_int <= DAR_dat_i[0];\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Enable CRC unit\n                crc_en <= 1;\n                // Disable output enable\n                DAT_oe_o <= 0;\n                // Set up internal control register\n                sd_data_out <= 0;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == 512) begin\n                    // Compare received CRC bits with calculated CRC_out values\n                    if (crc_out == crc_in) begin\n                        crc_ok <= 1;\n                    end else begin\n                        crc_ok <= 0;\n                    end\n                    // Set transmission complete\n                    transm_complete <= 1;\n                end\n            end\n            default: begin\n                // Do nothing\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 15, "code": "// sd_data_serial_host.v\n\nmodule sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// CRC_16_gen module\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC module\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_q <= 0;\n        ack_transfer_int <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC module\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ module\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_COMBO module\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (busy_int == 0) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (DAR_dat_i[0] == 0) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\n// FSM_OUT module\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        // Reset all output signals\n        rd <= 0;\n        data_out <= 0;\n        we <= 0;\n        DAT_oe_o <= 0;\n        DAT_dat_o <= 0;\n        busy_n <= 1;\n        transm_complete <= 0;\n        crc_ok <= 0;\n        // Reset all internal signals\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        sd_data_out <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n        data_send_index <= 0;\n        crc_in <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_s <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Fill inbufferts with data from FIFO\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set outputbuffert to point at inbuffert\n                sd_data_out <= write_buf_0;\n                // Send Startbit\n                DAT_dat_o <= 0;\n                // Read 4 bits from outputbuffert and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // Increase out_buff_ptr and read in a new value to sd_data_out from a inbuffert\n                out_buff_ptr <= out_buff_ptr + 1;\n                sd_data_out <= write_buf_1;\n                // Repeat until 512 bytes have been sent\n                transf_cnt <= transf_cnt + 1;\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Check CRC status\n                if (crc_s == 3'b000) begin\n                    crc_ok <= 1;\n                end else begin\n                    crc_ok <= 0;\n                end\n            end\n            WRITE_BUSY: begin\n                // Signal for transm_complete\n                transm_complete <= 1;\n                // Check CRC status\n                if (crc_s == 3'b000) begin\n                    crc_ok <= 1;\n                end else begin\n                    crc_ok <= 0;\n                end\n                // Poll DAT_dat_i[0] to sense whenever the card is busy\n                busy_n <= DAR_dat_i[0];\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == SD_BUS_W) begin\n                    // Compare received CRC bits with calculated crc_out values\n                    if (crc_out == DAR_dat_i) begin\n                        crc_ok <= 1;\n                    end else begin\n                        crc_ok <= 0;\n                    end\n                    // Set transm_complete when 16 CRC bits have been read\n                    transm_complete <= 1;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 16, "code": "module sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// CRC Generation Block\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK Synchronization Block\nalways @(posedge sd_clk) begin\n    ack_q <= ack_transfer;\n    ack_transfer_int <= ack_q;\nend\n\n// START SYNC Block\nalways @(posedge sd_clk) begin\n    if (!DAT_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ Block\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT Block\nalways @(posedge sd_clk) begin\n    case (state)\n        IDLE: begin\n            // Reset CRC and pause it\n            crc_rst <= 1;\n            crc_en <= 0;\n            // Reset counters\n            transf_cnt <= 0;\n        end\n        WRITE_DAT: begin\n            // Fill inbufferts with data from FIFO\n            write_buf_0 <= data_in;\n            write_buf_1 <= data_in;\n            // Set outputbuffert to point at inbuffert\n            sd_data_out <= write_buf_0;\n            // Send Startbit\n            DAT_dat_o <= 0;\n            // Read 4 bits from outputbuffert and assign to last_din and crc_in\n            last_din <= sd_data_out[3:0];\n            crc_in <= sd_data_out[3:0];\n            // Assign value of last_din to DAT_dat_o\n            DAT_dat_o <= last_din;\n            // When 28 bits have been sent, increase out_buff_ptr and read in new value\n            if (transf_cnt == 28) begin\n                out_buff_ptr <= ~out_buff_ptr;\n                sd_data_out <= write_buf_1;\n            end\n            // Repeat until 512 bytes have been sent\n            transf_cnt <= transf_cnt + 1;\n        end\n        WRITE_CRC: begin\n            // Read CRC response token\n            crc_s <= DAR_dat_i[2:0];\n            // Check CRC response\n            if (crc_s == 7) begin\n                crc_ok <= 1;\n            end else begin\n                crc_ok <= 0;\n            end\n        end\n        WRITE_BUSY: begin\n            // Signal for transm_complete\n            transm_complete <= 1;\n            // Check CRC response\n            crc_ok <= (crc_s == 7);\n            // Poll DAT_dat_i[0] to sense whenever the card is busy\n            busy_int <= DAT_dat_i[0];\n        end\n        READ_WAIT: begin\n            // Prepare for data reception\n            crc_en <= 1;\n            DAT_oe_o <= 0;\n        end\n        READ_DAT: begin\n            // Read DAT_dat_i and store to FIFO data_out and crc_in\n            data_out <= DAR_dat_i;\n            crc_in <= DAR_dat_i;\n            // Increase transfer counter\n            transf_cnt <= transf_cnt + 1;\n            // Repeat until 512 bytes have been received\n            if (transf_cnt == 512) begin\n                transm_complete <= 1;\n            end\n        end\n        default: begin\n            // Default to IDLE state\n            state <= IDLE;\n        end\n    endcase\nend\n\n// FSM_COMBO Block\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b111) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (busy_int == 0) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (q_start_bit == 0) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 17, "code": "// sd_data_serial_host.v\nmodule sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// Sub-modules\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        // Reset all signals to their default values\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 7;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Fill inbuffers with data from FIFO\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set output buffer to point to inbuffer\n                sd_data_out <= write_buf_0;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from output buffer and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // When 28 bits have been sent, increase out_buff_ptr and read in new value to sd_data_out\n                if (transf_cnt == 28) begin\n                    out_buff_ptr <= out_buff_ptr + 1;\n                    sd_data_out <= write_buf_1;\n                end\n                // Repeat until 512 bytes have been sent\n                transf_cnt <= transf_cnt + 1;\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Read stop bit\n                if (DAR_dat_i[0] == 1) begin\n                    transm_complete <= 1;\n                end\n            end\n            WRITE_BUSY: begin\n                // Signal for transm_complete\n                transm_complete <= 1;\n                // Check CRC response and set crc_ok\n                if (crc_s == 5) begin\n                    crc_ok <= 1;\n                end\n                // Poll DAT_dat_i[0] to sense whenever the card is busy\n                busy_int <= DAR_dat_i[0];\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                // Set up internal control register\n                data_send_index <= 0;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == 512) begin\n                    // Compare received CRC bits with calculated crc_out values\n                    if (crc_out == crc_in) begin\n                        crc_ok <= 1;\n                    end\n                    transm_complete <= 1;\n                end\n            end\n            default: begin\n                // Default to idle state\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\n// FSM_COMBO\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (busy_int == 0) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (q_start_bit == 0) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 18, "code": "module sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// Sub-modules\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_transfer_int <= 0;\n        ack_q <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_COMBO\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (!busy_int) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (!DAR_dat_i[0]) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\n// FSM_OUT\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 3'b111;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Load data from FIFO to write buffers\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from output buffer and assign to last_din and crc_in\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // Increase out_buff_ptr and read in a new value to sd_data_out from a inbuffer\n                out_buff_ptr <= out_buff_ptr + 1;\n                sd_data_out <= write_buf_0;\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Read stop bit\n                if (DAR_dat_i[0] == 1) begin\n                    transm_complete <= 1;\n                end\n            end\n            WRITE_BUSY: begin\n                // Signal for transm_complete\n                transm_complete <= 1;\n                // Check the CRC response and set crc_ok\n                if (crc_s == 3'b000) begin\n                    crc_ok <= 1;\n                end\n                // Poll DAT_dat_i[0] to sense whenever the card is busy\n                busy_int <= DAR_dat_i[0];\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase the transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == SD_BUS_W) begin\n                    transm_complete <= 1;\n                end\n            end\n            default: begin\n                // Do nothing\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 19, "code": "```ilog\nmodule sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// Internal signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// CRC_16_gen module\nsd_crc_16 crc_16_gen(\n    .BITVAL(crc_in),\n    .Enable(crc_en),\n    .CLK(sd_clk),\n    .RST(crc_rst),\n    .CRC(crc_out)\n);\n\n// ACK_SYNC module\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        ack_q <= 0;\n        ack_transfer_int <= 0;\n    end else begin\n        ack_q <= ack_transfer;\n        ack_transfer_int <= ack_q;\n    end\nend\n\n// START_SYNC module\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        q_start_bit <= 1;\n    end else if (!DAR_dat_i[0] && state == READ_WAIT) begin\n        q_start_bit <= 0;\n    end else begin\n        q_start_bit <= 1;\n    end\nend\n\n// FSM_SEQ module\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_COMBO module\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (busy_int == 0) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (DAR_dat_i[0] == 0) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\n// FSM_OUT module\nalways @(posedge sd_clk or posedge rst) begin\n    if (rst) begin\n        // Reset all signals\n        write_buf_0 <= 0;\n        write_buf_1 <= 0;\n        DAT_oe_o <= 0;\n        crc_en <= 0;\n        crc_rst <= 1;\n        transf_cnt <= 0;\n        rd <= 0;\n        last_din <= 0;\n        crc_c <= 0;\n        crc_in <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 3'b111;\n        crc_s <= 0;\n        transm_complete <= 0;\n        busy_n <= 1;\n        we <= 0;\n        data_out <= 0;\n        crc_ok <= 0;\n        busy_int <= 0;\n        data_send_index <= 0;\n        out_buff_ptr <= 0;\n        in_buff_ptr <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                // Reset CRC and pause it\n                crc_rst <= 1;\n                crc_en <= 0;\n                // Reset counters\n                transf_cnt <= 0;\n            end\n            WRITE_DAT: begin\n                // Fill in buffers\n                write_buf_0 <= data_in;\n                write_buf_1 <= data_in;\n                // Set output buffer\n                sd_data_out <= write_buf_0;\n                // Send start bit\n                DAT_dat_o <= 0;\n                // Read 4 bits from output buffer\n                last_din <= sd_data_out[3:0];\n                crc_in <= sd_data_out[3:0];\n                // Assign value of last_din to DAT_dat_o\n                DAT_dat_o <= last_din;\n                // Increase out_buff_ptr\n                out_buff_ptr <= out_buff_ptr + 1;\n                // Repeat until 512 bytes have been sent\n                if (transf_cnt == SD_BUS_W) begin\n                    // Attach 16-bit CRC to each data line\n                    crc_en <= 1;\n                end\n            end\n            WRITE_CRC: begin\n                // Read CRC response token\n                crc_s <= DAR_dat_i[2:0];\n                // Read stop bit\n                if (DAR_dat_i[0] == 1) begin\n                    // Set transm_complete\n                    transm_complete <= 1;\n                    // Check CRC response\n                    if (crc_s == 3'b000) begin\n                        crc_ok <= 1;\n                    end else begin\n                        crc_ok <= 0;\n                    end\n                end\n            end\n            WRITE_BUSY: begin\n                // Signal for transm_complete\n                transm_complete <= 1;\n                // Check CRC response\n                if (crc_s == 3'b000) begin\n                    crc_ok <= 1;\n                end else begin\n                    crc_ok <= 0;\n                end\n                // Poll DAT_dat_i[0] to sense whenever the card is busy\n                if (DAR_dat_i[0] == 0) begin\n                    busy_int <= 1;\n                end else begin\n                    busy_int <= 0;\n                end\n            end\n            READ_WAIT: begin\n                // Prepare for data reception\n                crc_en <= 1;\n                DAT_oe_o <= 0;\n                // Set up internal control register\n                in_buff_ptr <= 0;\n            end\n            READ_DAT: begin\n                // Read DAT_dat_i and store to FIFO data_out and crc_in\n                data_out <= DAR_dat_i;\n                crc_in <= DAR_dat_i;\n                // Increase transfer counter\n                transf_cnt <= transf_cnt + 1;\n                // Repeat until 512 bytes have been received\n                if (transf_cnt == SD_BUS_W) begin\n                    // Compare received CRC bits with calculated crc_out values\n                    if (crc_out == crc_in) begin\n                        crc_ok <= 1;\n                    end else begin\n                        crc_ok <= 0;\n                    end\n                    // Set transm_complete\n                    transm_complete <= 1;\n                end\n            end\n            default: begin\n                // Do nothing\n            end\n        endcase\n    end\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 20, "code": "module sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAR_dat_i,\n    output rd,\n    output [SD_BUS_W-1:0] data_out,\n    output we,\n    output DAT_oe_o,\n    output [SD_BUS_W-1:0] DAT_dat_o,\n    output busy_n,\n    output transm_complete,\n    output crc_ok\n);\n\n// CRC Generation Block\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output [15:0] CRC\n);\n\n// Internal Signals\nreg [SD_BUS_W-1:0] crc_in;\nreg crc_en;\nreg crc_rst;\nwire [15:0] crc_out;\nreg [SD_BUS_W-1:0] temp_in;\nreg [10:0] transf_cnt;\nreg [5:0] state;\nreg [5:0] next_state;\nreg [2:0] crc_status;\nreg busy_int;\nreg ack_transfer_int;\nreg ack_q;\nreg q_start_bit;\nreg [4:0] crc_c;\nreg [3:0] last_din;\nreg [2:0] crc_s;\nreg [31:0] write_buf_0;\nreg [31:0] write_buf_1;\nreg [31:0] sd_data_out;\nreg out_buff_ptr;\nreg in_buff_ptr;\nreg [2:0] data_send_index;\n\n// ACK_SYNC (Acknowledgment Synchronization Block)\nalways @(posedge sd_clk) begin\n    ack_q <= ack_transfer;\n    ack_transfer_int <= ack_q;\nend\n\n// START_SYNC (Start Bit Synchronization Block)\nalways @(posedge sd_clk) begin\n    if (~DAR_dat_i[0] & (state == READ_WAIT)) begin\n        q_start_bit <= 1'b0;\n    end else begin\n        q_start_bit <= 1'b1;\n    end\nend\n\n// FSM_COMBO (Finite State Machine Logic for Transmit and Receive Operations)\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (start_dat == 2'b01) begin\n                next_state <= WRITE_DAT;\n            end else if (start_dat == 2'b10) begin\n                next_state <= READ_WAIT;\n            end else begin\n                next_state <= IDLE;\n            end\n        end\n        WRITE_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= WRITE_CRC;\n            end else begin\n                next_state <= WRITE_DAT;\n            end\n        end\n        WRITE_CRC: begin\n            if (crc_status == 3'b000) begin\n                next_state <= WRITE_BUSY;\n            end else begin\n                next_state <= WRITE_CRC;\n            end\n        end\n        WRITE_BUSY: begin\n            if (~busy_int) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= WRITE_BUSY;\n            end\n        end\n        READ_WAIT: begin\n            if (~DAR_dat_i[0]) begin\n                next_state <= READ_DAT;\n            end else begin\n                next_state <= READ_WAIT;\n            end\n        end\n        READ_DAT: begin\n            if (transf_cnt == SD_BUS_W) begin\n                next_state <= IDLE;\n            end else begin\n                next_state <= READ_DAT;\n            end\n        end\n        default: begin\n            next_state <= IDLE;\n        end\n    endcase\nend\n\n// FSM_SEQ (Sequential Logic for FSM)\nalways @(posedge sd_clk) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// FSM_OUT (Output Logic for FSM Control)\nalways @(posedge sd_clk) begin\n    case (state)\n        IDLE: begin\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'd0;\n            busy_int <= 1'b0;\n            transm_complete <= 1'b0;\n            crc_ok <= 1'b0;\n        end\n        WRITE_DAT: begin\n            // Load data from FIFO to write buffers\n            write_buf_0 <= data_in;\n            write_buf_1 <= data_in;\n            // Send start bit\n            DAT_dat_o <= 1'b0;\n            // Read 4 bits from output buffer and assign to last_din and crc_in\n            last_din <= sd_data_out[3:0];\n            crc_in <= sd_data_out[3:0];\n            // Assign value of last_din to DAT_dat_o\n            DAT_dat_o <= last_din;\n            // Increase transfer counter\n            transf_cnt <= transf_cnt + 1;\n        end\n        WRITE_CRC: begin\n            // Read CRC response token\n            crc_s <= DAR_dat_i[2:0];\n            // Check CRC status\n            if (crc_s == 3'b000) begin\n                crc_ok <= 1'b1;\n            end else begin\n                crc_ok <= 1'b0;\n            end\n        end\n        WRITE_BUSY: begin\n            // Signal for transmission complete\n            transm_complete <= 1'b1;\n            // Check busy signal\n            if (~busy_int) begin\n                busy_n <= 1'b1;\n            end else begin\n                busy_n <= 1'b0;\n            end\n        end\n        READ_WAIT: begin\n            // Prepare for data reception\n            crc_en <= 1'b1;\n            DAT_oe_o <= 1'b0;\n        end\n        READ_DAT: begin\n            // Read data from SD bus and store to FIFO\n            data_out <= DAR_dat_i;\n            // Increase transfer counter\n            transf_cnt <= transf_cnt + 1;\n            // Check CRC status\n            if (transf_cnt == SD_BUS_W) begin\n                if (crc_ok) begin\n                    crc_ok <= 1'b1;\n                end else begin\n                    crc_ok <= 1'b0;\n                end\n            end\n        end\n        default: begin\n            // Do nothing\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 1, "code": "// Include the sd_defines.v file for global variables and macros\n`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    // System clock and reset\n    input         clk,        // System clock\n    input         rst,        // Asynchronous reset, active high\n\n    // Wishbone master interface\n    output [31:0] m_wb_adr_o, // Wishbone master address output\n    output        m_wb_we_o,  // Wishbone master write enable\n    output [31:0] m_wb_dat_o, // Wishbone master data output\n    output        m_wb_cyc_o, // Wishbone master cycle output\n    output        m_wb_stb_o, // Wishbone master strobe output\n    input         m_wb_ack_i, // Wishbone master acknowledgment input\n    output [2:0]  m_wb_cti_o, // Wishbone master cycle type identifier output\n    output [1:0]  m_wb_bte_o, // Wishbone master burst type extension output\n\n    // Module control signals\n    input         en,         // Enable signal for the module\n    input [31:0]  adr,        // Base address for memory write operations\n\n    // SD card interface\n    input         sd_clk,     // SD card clock\n    input [SD_BUS_W-1:0] dat_i, // Data input from SD card interface\n    input         wr,         // Write enable for FIFO\n\n    // FIFO status signals\n    output        full,       // FIFO full flag\n    output        empty       // FIFO empty flag\n);\n\n// Instantiate the sd_rx_fifo module\nsd_rx_fifo #(\n    .FIFO_RX_MEM_DEPTH(FIFO_RX_MEM_DEPTH),\n    .FIFO_RX_MEM_ADR_SIZE(FIFO_RX_MEM_ADR_SIZE)\n) sd_rx_fifo_inst (\n    .d(dat_i),          // Input data from SD card\n    .wr(wr),            // Write enable signal\n    .wclk(sd_clk),      // Write clock\n    .q(m_wb_dat_o),     // Output data to host\n    .rd(rd),            // Read enable signal\n    .full(full),        // FIFO full flag\n    .empty(empty),      // FIFO empty flag\n    .mem_empt(),        // Memory empty space (in words)\n    .rclk(clk),         // Read clock\n    .rst(rst)           // Asynchronous reset\n);\n\n// Internal signals and registers\nreg [31:0] offset;      // Address offset for Wishbone transactions\nreg        wb_free;     // Wishbone bus availability flag\nreg        reset_rx_fifo; // RX FIFO reset control\nreg        rd;          // Read enable for RX FIFO\n\n// Initialize registers and signals\ninitial begin\n    offset = 0;\n    wb_free = 1'b1;\n    reset_rx_fifo = 1'b1;\n    rd = 1'b0;\nend\n\n// Main logic\nalways @(posedge clk) begin\n    if (rst) begin\n        // Reset all registers and signals\n        offset <= 0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n    end else if (en) begin\n        // Data reception and transfer process\n        if (!empty && wb_free) begin\n            // Read from FIFO and initiate Wishbone write transaction\n            rd <= 1'b1;\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 1'b1;\n            m_wb_dat_o <= sd_rx_fifo_inst.q;\n            m_wb_cyc_o <= 1'b1;\n            m_wb_stb_o <= 1'b1;\n            wb_free <= 1'b0;\n        end\n\n        // Wishbone write transaction completion\n        if (m_wb_ack_i) begin\n            // Reset Wishbone control signals\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            // Update address offset\n            offset <= offset + MEM_OFFSET;\n            // Mark Wishbone bus as free\n            wb_free <= 1'b1;\n        end\n    end else begin\n        // Disabled state handling\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        offset <= 0;\n        wb_free <= 1'b1;\n        m_wb_we_o <= 1'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 2, "code": "// Include the sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    // System clock\n    input clk,\n    // System reset\n    input rst,\n    // Wishbone master address output\n    output [31:0] m_wb_adr_o,\n    // Wishbone master write enable\n    output m_wb_we_o,\n    // Wishbone master data output\n    output [31:0] m_wb_dat_o,\n    // Wishbone master cycle output\n    output m_wb_cyc_o,\n    // Wishbone master strobe output\n    output m_wb_stb_o,\n    // Wishbone master acknowledgment input\n    input m_wb_ack_i,\n    // Wishbone master cycle type identifier output\n    output [2:0] m_wb_cti_o,\n    // Wishbone master burst type extension output\n    output [1:0] m_wb_bte_o,\n    // Enable signal for the module\n    input en,\n    // Base address for memory write operations\n    input [31:0] adr,\n    // SD card clock\n    input sd_clk,\n    // Data input from SD card interface\n    input [SD_BUS_W-1:0] dat_i,\n    // Write enable for FIFO\n    input wr,\n    // FIFO full flag\n    output full,\n    // FIFO empty flag\n    output empty\n);\n\n// Registers\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// sd_rx_fifo module instantiation\nsd_rx_fifo u_sd_rx_fifo(\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(m_wb_dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(clk),\n    .rst(reset_rx_fifo)\n);\n\n// Combinational logic\nalways @(*) begin\n    // Initialize Wishbone master signals to inactive state\n    m_wb_adr_o = 32'd0;\n    m_wb_we_o = 1'b0;\n    m_wb_dat_o = 32'd0;\n    m_wb_cyc_o = 1'b0;\n    m_wb_stb_o = 1'b0;\n    m_wb_cti_o = 3'b0;\n    m_wb_bte_o = 2'b0;\n    \n    // FIFO read preparation\n    if (en && !empty) begin\n        rd = 1'b1;\n        m_wb_dat_o = u_sd_rx_fifo.q;\n        m_wb_adr_o = adr + offset;\n        m_wb_we_o = 1'b1;\n        m_wb_cyc_o = 1'b1;\n        m_wb_stb_o = 1'b1;\n    end else begin\n        rd = 1'b0;\n    end\n    \n    // Wishbone write transaction completion\n    if (m_wb_ack_i) begin\n        offset = offset + MEM_OFFSET;\n        wb_free = 1'b1;\n    end\nend\n\n// Sequential logic\nalways @(posedge clk) begin\n    if (rst) begin\n        // Reset all control signals and counters\n        offset <= 9'd0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n    end else if (en) begin\n        // FIFO read preparation\n        if (!empty) begin\n            rd <= 1'b1;\n        end else begin\n            rd <= 1'b0;\n        end\n        \n        // Wishbone write transaction completion\n        if (m_wb_ack_i) begin\n            offset <= offset + MEM_OFFSET;\n            wb_free <= 1'b1;\n        end\n    end else begin\n        // Reset RX FIFO and stop FIFO read operation\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        offset <= 9'd0;\n        wb_free <= 1'b1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 3, "code": "// Include sd_defines.v for global variables and macro definitions\n`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    // System Clock\n    input clk,\n    // System Reset\n    input rst,\n    // Wishbone Master Address Output\n    output [31:0] m_wb_adr_o,\n    // Wishbone Master Write Enable\n    output m_wb_we_o,\n    // Wishbone Master Data Output\n    output [31:0] m_wb_dat_o,\n    // Wishbone Master Cycle Output\n    output m_wb_cyc_o,\n    // Wishbone Master Strobe Output\n    output m_wb_stb_o,\n    // Wishbone Master Acknowledgment Input\n    input m_wb_ack_i,\n    // Wishbone Master Cycle Type Identifier Output\n    output [2:0] m_wb_cti_o,\n    // Wishbone Master Burst Type Extension Output\n    output [1:0] m_wb_bte_o,\n    // Enable Signal for the Module\n    input en,\n    // Base Address for Memory Write Operations\n    input [31:0] adr,\n    // SD Card Clock\n    input sd_clk,\n    // Data Input from SD Card Interface\n    input [SD_BUS_W-1:0] dat_i,\n    // Write Enable for FIFO\n    input wr,\n    // FIFO Full Flag\n    output full,\n    // FIFO Empty Flag\n    output empty\n);\n\n// Instantiate sd_rx_fifo module\nsd_rx_fifo #(\n    .FIFO_RX_MEM_DEPTH(FIFO_RX_MEM_DEPTH),\n    .FIFO_RX_MEM_ADR_SIZE(FIFO_RX_MEM_ADR_SIZE)\n) u_sd_rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(m_wb_dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(clk),\n    .rst(rst)\n);\n\n// Internal signals and registers\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// Combinational logic\nassign m_wb_adr_o = adr + offset;\nassign m_wb_we_o = ~wb_free & ~reset_rx_fifo;\nassign m_wb_cyc_o = ~wb_free & ~reset_rx_fifo;\nassign m_wb_stb_o = ~wb_free & ~reset_rx_fifo;\nassign m_wb_cti_o = 3'b000; // Normal cycle\nassign m_wb_bte_o = 2'b00; // Single burst\n\n// Sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n    end else if (en) begin\n        // FIFO read preparation\n        if (~empty & wb_free) begin\n            rd <= 1;\n            reset_rx_fifo <= 0;\n        end\n        // Wishbone write transaction completion\n        if (m_wb_ack_i & ~wb_free) begin\n            offset <= offset + MEM_OFFSET;\n            wb_free <= 1;\n        end\n    end else begin\n        // Disabled state handling\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input clk, \n    input rst, \n    output [31:0] m_wb_adr_o, \n    output m_wb_we_o, \n    output [31:0] m_wb_dat_o, \n    output m_wb_cyc_o, \n    output m_wb_stb_o, \n    input m_wb_ack_i, \n    output [2:0] m_wb_cti_o, \n    output [1:0] m_wb_bte_o, \n    input en, \n    input [31:0] adr, \n    input sd_clk, \n    input [SD_BUS_W-1:0] dat_i, \n    input wr, \n    output full, \n    output empty\n);\n\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\nsd_rx_fifo u_sd_rx_fifo(\n    .d(dat_i), \n    .wr(wr), \n    .wclk(sd_clk), \n    .q(m_wb_dat_o), \n    .rd(rd), \n    .full(full), \n    .empty(empty), \n    .mem_empt(), \n    .rclk(clk), \n    .rst(reset_rx_fifo)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        offset <= 9'd0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        m_wb_adr_o <= 32'd0;\n        m_wb_we_o <= 1'b0;\n        m_wb_dat_o <= 32'd0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'd0;\n        m_wb_bte_o <= 2'd0;\n    end else if (en) begin\n        if (!wb_free && m_wb_ack_i) begin\n            wb_free <= 1'b1;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            offset <= offset + MEM_OFFSET;\n        end else if (wb_free && !empty) begin\n            wb_free <= 1'b0;\n            rd <= 1'b1;\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 1'b1;\n            m_wb_dat_o <= m_wb_dat_o;\n            m_wb_cyc_o <= 1'b1;\n            m_wb_stb_o <= 1'b1;\n            m_wb_cti_o <= 3'd0;\n            m_wb_bte_o <= 2'd0;\n        end\n        if (full) begin\n            reset_rx_fifo <= 1'b0;\n        end\n    end else begin\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        offset <= 9'd0;\n        m_wb_adr_o <= 32'd0;\n        m_wb_we_o <= 1'b0;\n        m_wb_dat_o <= 32'd0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'd0;\n        m_wb_bte_o <= 2'd0;\n        wb_free <= 1'b1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 5, "code": "// sd_fifo_rx_filler module\nmodule sd_fifo_rx_filler(\n    // System clock\n    input clk,\n    // System reset\n    input rst,\n    // Wishbone master address output\n    output [31:0] m_wb_adr_o,\n    // Wishbone master write enable\n    output m_wb_we_o,\n    // Wishbone master data output\n    output [31:0] m_wb_dat_o,\n    // Wishbone master cycle output\n    output m_wb_cyc_o,\n    // Wishbone master strobe output\n    output m_wb_stb_o,\n    // Wishbone master acknowledgment input\n    input m_wb_ack_i,\n    // Wishbone master cycle type identifier output\n    output [2:0] m_wb_cti_o,\n    // Wishbone master burst type extension output\n    output [1:0] m_wb_bte_o,\n    // Enable signal for the module\n    input en,\n    // Base address for memory write operations\n    input [31:0] adr,\n    // SD card clock\n    input sd_clk,\n    // Data input from SD card interface\n    input [SD_BUS_W-1:0] dat_i,\n    // Write enable for FIFO\n    input wr,\n    // FIFO full flag\n    output full,\n    // FIFO empty flag\n    output empty\n);\n\n// sd_rx_fifo module\nmodule sd_rx_fifo(\n    // Input data from SD card\n    input [3:0] d,\n    // Write enable signal (active high)\n    input wr,\n    // Write clock (rising edge active)\n    input wclk,\n    // Output data to host\n    output [31:0] q,\n    // Read enable signal (active high)\n    input rd,\n    // FIFO full flag (active high)\n    output full,\n    // FIFO empty flag (active high)\n    output empty,\n    // Memory empty space (in words)\n    output [1:0] mem_empt,\n    // Read clock (rising edge active)\n    input rclk,\n    // Asynchronous reset (active high)\n    input rst\n);\n\n// Define parameters\nparameter SD_BUS_W = 4;\nparameter MEM_OFFSET = 4;\nparameter FIFO_RX_MEM_DEPTH = 16;\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;\n\n// Define registers\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// Define wires\nwire [31:0] dat_o;\nwire [31:0] m_wb_adr;\nwire m_wb_we;\nwire m_wb_cyc;\nwire m_wb_stb;\nwire [2:0] m_wb_cti;\nwire [1:0] m_wb_bte;\n\n// sd_rx_fifo instantiation\nsd_rx_fifo u_sd_rx_fifo(\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(clk),\n    .rst(rst)\n);\n\n// Wishbone master logic\nalways @(posedge clk) begin\n    if (rst) begin\n        // Reset all control signals and counters\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_dat_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n    end else if (en) begin\n        // FIFO read preparation\n        if (!empty && wb_free) begin\n            // Start reading from FIFO\n            rd <= 1;\n            // Prepare Wishbone data output\n            m_wb_dat_o <= dat_o;\n            // Set Wishbone write enable and control signals\n            m_wb_we_o <= 1;\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            // Mark Wishbone bus as busy\n            wb_free <= 0;\n        end\n\n        // Wishbone write transaction completion\n        if (m_wb_ack_i) begin\n            // Reset Wishbone control signals\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            // Update address offset\n            offset <= offset + MEM_OFFSET;\n            // Mark Wishbone bus as free\n            wb_free <= 1;\n        end\n    end else begin\n        // Reset RX FIFO\n        reset_rx_fifo <= 1;\n        // Stop FIFO read operation\n        rd <= 0;\n        // Reset address offset\n        offset <= 0;\n        // Reset all Wishbone control signals\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_dat_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n        // Mark Wishbone bus as free\n        wb_free <= 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 6, "code": "```\n// Include the sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    // System clock\n    input clk,\n    // System reset\n    input rst,\n    // Wishbone master address output\n    output [31:0] m_wb_adr_o,\n    // Wishbone master write enable\n    output m_wb_we_o,\n    // Wishbone master data output\n    output [31:0] m_wb_dat_o,\n    // Wishbone master cycle output\n    output m_wb_cyc_o,\n    // Wishbone master strobe output\n    output m_wb_stb_o,\n    // Wishbone master acknowledgment input\n    input m_wb_ack_i,\n    // Wishbone master cycle type identifier output\n    output [2:0] m_wb_cti_o,\n    // Wishbone master burst type extension output\n    output [1:0] m_wb_bte_o,\n    // Enable signal for the module\n    input en,\n    // Base address for memory write operations\n    input [31:0] adr,\n    // SD card clock\n    input sd_clk,\n    // Data input from SD card interface\n    input [SD_BUS_W-1:0] dat_i,\n    // Write enable for FIFO\n    input wr,\n    // FIFO full flag\n    output full,\n    // FIFO empty flag\n    output empty\n);\n\n// Internal signals\nreg [8:0] offset; // Address offset for Wishbone transactions\nreg wb_free; // Wishbone bus availability flag\nreg reset_rx_fifo; // RX FIFO reset control\nreg rd; // Read enable for RX FIFO\n\n// Instantiate the sd_rx_fifo module\nsd_rx_fifo #(\n    .FIFO_RX_MEM_DEPTH(FIFO_RX_MEM_DEPTH),\n    .FIFO_RX_MEM_ADR_SIZE(FIFO_RX_MEM_ADR_SIZE)\n) u_sd_rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(m_wb_dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(clk),\n    .rst(reset_rx_fifo)\n);\n\n// Combinational logic\nalways @(*) begin\n    // Initialize Wishbone master signals to inactive state\n    m_wb_adr_o = 32'd0;\n    m_wb_we_o = 1'b0;\n    m_wb_dat_o = 32'd0;\n    m_wb_cyc_o = 1'b0;\n    m_wb_stb_o = 1'b0;\n    m_wb_cti_o = 3'b0;\n    m_wb_bte_o = 2'b0;\nend\n\n// Sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals and counters\n        offset <= 9'd0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n    end else if (en) begin\n        // Data reception and transfer process\n        if (!empty && wb_free) begin\n            // Read from FIFO and initiate Wishbone write transaction\n            rd <= 1'b1;\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 1'b1;\n            m_wb_dat_o <= u_sd_rx_fifo.q;\n            m_wb_cyc_o <= 1'b1;\n            m_wb_stb_o <= 1'b1;\n            wb_free <= 1'b0;\n        end else if (m_wb_ack_i) begin\n            // Wishbone write transaction completion\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            offset <= offset + MEM_OFFSET;\n            wb_free <= 1'b1;\n        end\n    end else begin\n        // Disabled state handling\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        offset <= 9'd0;\n        wb_free <= 1'b1;\n        m_wb_adr_o <= 32'd0;\n        m_wb_we_o <= 1'b0;\n        m_wb_dat_o <= 32'd0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n    end\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 7, "code": "```_filler module\nmodule sd_fifo_rx_filler(\n    // System clock\n    input           clk,\n    // System reset\n    input           rst,\n    // Wishbone master address output\n    output  [31:0]  m_wb_adr_o,\n    // Wishbone master write enable\n    output          m_wb_we_o,\n    // Wishbone master data output\n    output  [31:0]  m_wb_dat_o,\n    // Wishbone master cycle output\n    output          m_wb_cyc_o,\n    // Wishbone master strobe output\n    output          m_wb_stb_o,\n    // Wishbone master acknowledgment input\n    input           m_wb_ack_i,\n    // Wishbone master cycle type identifier output\n    output  [2:0]   m_wb_cti_o,\n    // Wishbone master burst type extension output\n    output  [1:0]   m_wb_bte_o,\n    // Enable signal for the module\n    input           en,\n    // Base address for memory write operations\n    input   [31:0]  adr,\n    // SD card clock\n    input           sd_clk,\n    // Data input from SD card interface\n    input   [SD_BUS_W-1:0]  dat_i,\n    // Write enable for FIFO\n    input           wr,\n    // FIFO full flag\n    output          full,\n    // FIFO empty flag\n    output          empty\n);\n\n// Include sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\n// Internal signals\nreg     [8:0]  offset;  // Address offset for Wishbone transactions\nreg             wb_free;  // Wishbone bus availability flag\nreg             reset_rx_fifo;  // RX FIFO reset control\nreg             rd;  // Read enable for RX FIFO\n\n// sd_rx_fifo module instantiation\nsd_rx_fifo u_sd_rx_fifo(\n    .d(dat_i),  // Input data from SD card\n    .wr(wr),  // Write enable signal\n    .wclk(sd_clk),  // Write clock\n    .q(m_wb_dat_o),  // Output data to host\n    .rd(rd),  // Read enable signal\n    .full(full),  // FIFO full flag\n    .empty(empty),  // FIFO empty flag\n    .mem_empt(),  // Memory empty space\n    .rclk(clk),  // Read clock\n    .rst(rst)  // Asynchronous reset\n);\n\n// Combinational logic\nassign m_wb_adr_o = adr + offset;\nassign m_wb_we_o = ~wb_free;\nassign m_wb_cyc_o = ~wb_free;\nassign m_wb_stb_o = ~wb_free;\nassign m_wb_cti_o = 3'b000;  // Normal cycle\nassign m_wb_bte_o = 2'b00;  // Single transfer\n\n// Sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n    end else if (en) begin\n        if (~wb_free && m_wb_ack_i) begin\n            offset <= offset + MEM_OFFSET;\n            wb_free <= 1;\n        end\n        if (~empty && wb_free) begin\n            rd <= 1;\n            wb_free <= 0;\n        end\n    end else begin\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n    end\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 8, "code": "// sd_fifo_rx_filler module\nmodule sd_fifo_rx_filler(\n    // System clock\n    input clk,\n    // System reset\n    input rst,\n    // Wishbone master address output\n    output [31:0] m_wb_adr_o,\n    // Wishbone master write enable\n    output m_wb_we_o,\n    // Wishbone master data output\n    output [31:0] m_wb_dat_o,\n    // Wishbone master cycle output\n    output m_wb_cyc_o,\n    // Wishbone master strobe output\n    output m_wb_stb_o,\n    // Wishbone master acknowledgment input\n    input m_wb_ack_i,\n    // Wishbone master cycle type identifier output\n    output [2:0] m_wb_cti_o,\n    // Wishbone master burst type extension output\n    output [1:0] m_wb_bte_o,\n    // Enable signal for the module\n    input en,\n    // Base address for memory write operations\n    input [31:0] adr,\n    // SD card clock\n    input sd_clk,\n    // Data input from SD card interface\n    input [SD_BUS_W-1:0] dat_i,\n    // Write enable for FIFO\n    input wr,\n    // FIFO full flag\n    output full,\n    // FIFO empty flag\n    output empty\n);\n\n// Internal signals\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// sd_rx_fifo module instantiation\nsd_rx_fifo u_sd_rx_fifo(\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(m_wb_dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(clk),\n    .rst(reset_rx_fifo)\n);\n\n// Main logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals and counters\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_dat_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n    end else if (en) begin\n        // FIFO read preparation\n        if (!wb_free && !empty) begin\n            rd <= 1;\n            m_wb_dat_o <= u_sd_rx_fifo.q;\n            m_wb_we_o <= 1;\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            wb_free <= 0;\n        end\n\n        // Wishbone write transaction completion\n        if (m_wb_ack_i) begin\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            offset <= offset + MEM_OFFSET;\n            wb_free <= 1;\n        end\n    end else begin\n        // Reset RX FIFO\n        reset_rx_fifo <= 1;\n        // Stop FIFO read operation\n        rd <= 0;\n        // Reset address offset\n        offset <= 0;\n        // Reset all Wishbone control signals\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_dat_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n        // Mark Wishbone bus as free\n        wb_free <= 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 9, "code": "// Include sd_defines.v for global variables and macros\n`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    // System Clock\n    input           clk,\n    // System Reset\n    input           rst,\n    // Wishbone Master Address Output\n    output  [31:0]  m_wb_adr_o,\n    // Wishbone Master Write Enable\n    output          m_wb_we_o,\n    // Wishbone Master Data Output\n    output  [31:0]  m_wb_dat_o,\n    // Wishbone Master Cycle Output\n    output          m_wb_cyc_o,\n    // Wishbone Master Strobe Output\n    output          m_wb_stb_o,\n    // Wishbone Master Acknowledgment Input\n    input           m_wb_ack_i,\n    // Wishbone Master Cycle Type Identifier Output\n    output  [2:0]   m_wb_cti_o,\n    // Wishbone Master Burst Type Extension Output\n    output  [1:0]   m_wb_bte_o,\n    // Enable Signal for the Module\n    input           en,\n    // Base Address for Memory Write Operations\n    input   [31:0]  adr,\n    // SD Card Clock\n    input           sd_clk,\n    // Data Input from SD Card Interface\n    input   [SD_BUS_W-1:0]  dat_i,\n    // Write Enable for FIFO\n    input           wr,\n    // FIFO Full Flag\n    output          full,\n    // FIFO Empty Flag\n    output          empty\n);\n\n// Internal Signals and Registers\nreg     [8:0]    offset;  // Address Offset for Wishbone Transactions\nreg             wb_free;  // Wishbone Bus Availability Flag\nreg             reset_rx_fifo;  // RX FIFO Reset Control\nreg             rd;  // Read Enable for RX FIFO\n\n// sd_rx_fifo Module Instantiation\nsd_rx_fifo u_sd_rx_fifo(\n    .d(dat_i),  // Input Data from SD Card\n    .wr(wr),  // Write Enable Signal\n    .wclk(sd_clk),  // Write Clock\n    .q(m_wb_dat_o),  // Output Data to Host\n    .rd(rd),  // Read Enable Signal\n    .full(full),  // FIFO Full Flag\n    .empty(empty),  // FIFO Empty Flag\n    .mem_empt(),  // Memory Empty Space (in words)\n    .rclk(clk),  // Read Clock\n    .rst(rst)  // Asynchronous Reset\n);\n\n// Combinational Logic\nassign m_wb_adr_o = adr + offset;\nassign m_wb_we_o = ~wb_free;\nassign m_wb_cyc_o = ~wb_free;\nassign m_wb_stb_o = ~wb_free;\nassign m_wb_cti_o = 3'b000;  // Normal Cycle\nassign m_wb_bte_o = 2'b00;  // Single Transfer\n\n// Sequential Logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        offset <= 9'd0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n    end else if (en) begin\n        if (~wb_free && m_wb_ack_i) begin\n            offset <= offset + MEM_OFFSET;\n            wb_free <= 1'b1;\n        end\n        if (~empty && wb_free) begin\n            rd <= 1'b1;\n            wb_free <= 1'b0;\n        end\n        if (empty) begin\n            rd <= 1'b0;\n        end\n    end else begin\n        offset <= 9'd0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 10, "code": "// Import necessary definitions\n`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    // System clock and reset\n    input clk,\n    input rst,\n\n    // Wishbone master interface\n    output [31:0] m_wb_adr_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output [2:0] m_wb_cti_o,\n    output [1:0] m_wb_bte_o,\n\n    // Enable and address inputs\n    input en,\n    input [31:0] adr,\n\n    // SD card clock and data inputs\n    input sd_clk,\n    input [SD_BUS_W-1:0] dat_i,\n\n    // FIFO write enable and flags\n    input wr,\n    output full,\n    output empty\n);\n\n// Internal registers and signals\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// sd_rx_fifo instance\nsd_rx_fifo #(\n    .FIFO_RX_MEM_DEPTH(FIFO_RX_MEM_DEPTH),\n    .FIFO_RX_MEM_ADR_SIZE(FIFO_RX_MEM_ADR_SIZE)\n) u_sd_rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(m_wb_dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(clk),\n    .rst(reset_rx_fifo)\n);\n\n// Combinational logic\nalways @(*) begin\n    // Default values\n    m_wb_adr_o = adr + offset;\n    m_wb_we_o = 1'b0;\n    m_wb_dat_o = 32'b0;\n    m_wb_cyc_o = 1'b0;\n    m_wb_stb_o = 1'b0;\n    m_wb_cti_o = 3'b0;\n    m_wb_bte_o = 2'b0;\n\n    // Wishbone transaction control\n    if (en && !empty && wb_free) begin\n        m_wb_we_o = 1'b1;\n        m_wb_cyc_o = 1'b1;\n        m_wb_stb_o = 1'b1;\n        m_wb_dat_o = u_sd_rx_fifo.q;\n    end\nend\n\n// Sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all registers and signals\n        offset <= 9'b0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n    end else if (en) begin\n        // Data reception and transfer process\n        if (!empty && wb_free) begin\n            // Read from FIFO and initiate Wishbone write transaction\n            rd <= 1'b1;\n            wb_free <= 1'b0;\n        end\n\n        // Wishbone write transaction completion\n        if (m_wb_ack_i) begin\n            // Reset Wishbone control signals\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n\n            // Update address offset\n            offset <= offset + MEM_OFFSET;\n\n            // Mark Wishbone bus as free\n            wb_free <= 1'b1;\n        end\n    end else begin\n        // Disabled state handling\n        offset <= 9'b0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 11, "code": "// sd_fifo_rx_filler module\nmodule sd_fifo_rx_filler(\n    // System Clock\n    input clk,\n    // System Reset\n    input rst,\n    // Wishbone master address output\n    output [31:0] m_wb_adr_o,\n    // Wishbone master write enable\n    output m_wb_we_o,\n    // Wishbone master data output\n    output [31:0] m_wb_dat_o,\n    // Wishbone master cycle output\n    output m_wb_cyc_o,\n    // Wishbone master strobe output\n    output m_wb_stb_o,\n    // Wishbone master acknowledgment input\n    input m_wb_ack_i,\n    // Wishbone master cycle type identifier output\n    output [2:0] m_wb_cti_o,\n    // Wishbone master burst type extension output\n    output [1:0] m_wb_bte_o,\n    // Enable signal for the module\n    input en,\n    // Base address for memory write operations\n    input [31:0] adr,\n    // SD card clock\n    input sd_clk,\n    // Data input from SD card interface\n    input [SD_BUS_W-1:0] dat_i,\n    // Write enable for FIFO\n    input wr,\n    // FIFO full flag\n    output full,\n    // FIFO empty flag\n    output empty\n);\n\n// sd_rx_fifo module\nmodule sd_rx_fifo(\n    // Input data from SD card\n    input [3:0] d,\n    // Write enable signal (active high)\n    input wr,\n    // Write clock (rising edge active)\n    input wclk,\n    // Output data to host\n    output [31:0] q,\n    // Read enable signal (active high)\n    input rd,\n    // FIFO full flag (active high)\n    output full,\n    // FIFO empty flag (active high)\n    output empty,\n    // Memory empty space (in words)\n    output [1:0] mem_empt,\n    // Read clock (rising edge active)\n    input rclk,\n    // Asynchronous reset (active high)\n    input rst\n);\n\n// sd_defines.v file\n`include \"sd_defines.v\"\n\n// Parameters\nparameter MEM_OFFSET = 4;\nparameter BD_WIDTH = 8;\nparameter BD_SIZE = 255;\nparameter RAM_MEM_WIDTH_16 = 16;\nparameter RAM_MEM_WIDTH = 32;\nparameter RESEND_MAX_CNT = 10;\nparameter RESET_CLK_DIV = 10;\nparameter BLOCK_SIZE = 512;\nparameter SD_BUS_W = 4;\nparameter FIFO_RX_MEM_DEPTH = 16;\nparameter FIFO_RX_MEM_ADR_SIZE = 5;\nparameter FIFO_TX_MEM_DEPTH = 16;\nparameter FIFO_TX_MEM_ADR_SIZE = 5;\n\n// Registers\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// sd_rx_fifo instance\nsd_rx_fifo u_sd_rx_fifo(\n    .d(dat_i[3:0]),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(m_wb_dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(clk),\n    .rst(rst)\n);\n\n// Main logic\nalways @(posedge clk) begin\n    if (rst) begin\n        // Reset all control signals and counters\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_dat_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n    end else if (en) begin\n        // FIFO read preparation\n        if (!empty && wb_free) begin\n            // Start reading from FIFO\n            rd <= 1;\n            // Prepare Wishbone data output\n            m_wb_dat_o <= u_sd_rx_fifo.q;\n            // Set Wishbone write enable and control signals\n            m_wb_we_o <= 1;\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            // Mark Wishbone bus as busy\n            wb_free <= 0;\n        end\n        // Wishbone write transaction completion\n        if (m_wb_ack_i) begin\n            // Reset Wishbone control signals\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            // Update address offset\n            offset <= offset + MEM_OFFSET;\n            // Mark Wishbone bus as free\n            wb_free <= 1;\n        end\n    end else begin\n        // Reset RX FIFO\n        reset_rx_fifo <= 1;\n        // Stop FIFO read operation\n        rd <= 0;\n        // Reset address offset\n        offset <= 0;\n        // Reset all Wishbone control signals\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_dat_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n        // Mark Wishbone bus as free\n        wb_free <= 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 12, "code": "// Include the sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    // System Clock\n    input           clk,\n    // Asynchronous Reset\n    input           rst,\n    // Wishbone Master Address Output\n    output  [31:0]  m_wb_adr_o,\n    // Wishbone Master Write Enable\n    output          m_wb_we_o,\n    // Wishbone Master Data Output\n    output  [31:0]  m_wb_dat_o,\n    // Wishbone Master Cycle Output\n    output          m_wb_cyc_o,\n    // Wishbone Master Strobe Output\n    output          m_wb_stb_o,\n    // Wishbone Master Acknowledgment Input\n    input           m_wb_ack_i,\n    // Wishbone Master Cycle Type Identifier Output\n    output  [2:0]   m_wb_cti_o,\n    // Wishbone Master Burst Type Extension Output\n    output  [1:0]   m_wb_bte_o,\n    // Enable Signal\n    input           en,\n    // Base Address for Memory Write Operations\n    input   [31:0]  adr,\n    // SD Card Clock\n    input           sd_clk,\n    // Data Input from SD Card Interface\n    input   [SD_BUS_W-1:0]  dat_i,\n    // Write Enable for FIFO\n    input           wr,\n    // FIFO Full Flag\n    output          full,\n    // FIFO Empty Flag\n    output          empty\n);\n\n// Internal Registers\nreg [8:0]  offset;  // Address Offset for Wishbone Transactions\nreg        wb_free;  // Wishbone Bus Availability Flag\nreg        reset_rx_fifo;  // RX FIFO Reset Control\nreg        rd;  // Read Enable for RX FIFO\n\n// sd_rx_fifo Module Instantiation\nsd_rx_fifo u_sd_rx_fifo(\n    .d(dat_i),  // Input Data from SD Card\n    .wr(wr),  // Write Enable Signal\n    .wclk(sd_clk),  // Write Clock\n    .q(m_wb_dat_o),  // Output Data to Host\n    .rd(rd),  // Read Enable Signal\n    .full(full),  // FIFO Full Flag\n    .empty(empty),  // FIFO Empty Flag\n    .mem_empt(),  // Memory Empty Space (in words)\n    .rclk(clk),  // Read Clock\n    .rst(rst)  // Asynchronous Reset\n);\n\n// Initialize Registers on Reset\nalways @(posedge rst or posedge clk) begin\n    if (rst) begin\n        offset <= 9'd0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n    end else begin\n        // Update Registers Based on State Machine\n        // ...\n    end\nend\n\n// State Machine to Control Data Reception and Transfer\nalways @(posedge clk) begin\n    if (en) begin\n        // FIFO Read Preparation\n        if (!empty && wb_free) begin\n            rd <= 1'b1;\n            m_wb_we_o <= 1'b1;\n            m_wb_cyc_o <= 1'b1;\n            m_wb_stb_o <= 1'b1;\n            m_wb_adr_o <= adr + offset;\n            wb_free <= 1'b0;\n        end\n\n        // Wishbone Write Transaction Completion\n        if (m_wb_ack_i) begin\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            offset <= offset + MEM_OFFSET;\n            wb_free <= 1'b1;\n        end\n    end else begin\n        // Disabled State Handling\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        m_wb_we_o <= 1'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        wb_free <= 1'b1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input               clk,\n    input               rst,\n    output              m_wb_adr_o,\n    output              m_wb_we_o,\n    output              m_wb_dat_o,\n    output              m_wb_cyc_o,\n    output              m_wb_stb_o,\n    input               m_wb_ack_i,\n    output              m_wb_cti_o,\n    output              m_wb_bte_o,\n    input               en,\n    input               adr,\n    input               sd_clk,\n    input               dat_i,\n    input               wr,\n    output              full,\n    output              empty\n);\n\n// sd_rx_fifo instantiation\nsd_rx_fifo u_sd_rx_fifo(\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(m_wb_dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(clk),\n    .rst(rst)\n);\n\n// registers\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// combinatorial logic\nalways @(*) begin\n    if (~en) begin\n        m_wb_adr_o = 0;\n        m_wb_we_o = 0;\n        m_wb_dat_o = 0;\n        m_wb_cyc_o = 0;\n        m_wb_stb_o = 0;\n        m_wb_cti_o = 0;\n        m_wb_bte_o = 0;\n        rd = 0;\n        reset_rx_fifo = 1;\n        wb_free = 1;\n    end else if (wb_free && ~empty) begin\n        m_wb_adr_o = adr + offset;\n        m_wb_we_o = 1;\n        m_wb_cyc_o = 1;\n        m_wb_stb_o = 1;\n        m_wb_cti_o = 3'b000; // normal cycle\n        m_wb_bte_o = 2'b00; // single transfer\n        rd = 1;\n        reset_rx_fifo = 0;\n        wb_free = 0;\n    end else begin\n        m_wb_adr_o = 0;\n        m_wb_we_o = 0;\n        m_wb_dat_o = 0;\n        m_wb_cyc_o = 0;\n        m_wb_stb_o = 0;\n        m_wb_cti_o = 0;\n        m_wb_bte_o = 0;\n        rd = 0;\n        reset_rx_fifo = 0;\n        wb_free = 1;\n    end\nend\n\n// sequential logic\nalways @(posedge clk) begin\n    if (rst) begin\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n    end else if (~en) begin\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n    end else if (m_wb_ack_i) begin\n        offset <= offset + `MEM_OFFSET;\n        wb_free <= 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 14, "code": "// Include the sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    // System Clock\n    input clk,\n    // System Reset\n    input rst,\n    // Wishbone Master Address Output\n    output [31:0] m_wb_adr_o,\n    // Wishbone Master Write Enable\n    output m_wb_we_o,\n    // Wishbone Master Data Output\n    output [31:0] m_wb_dat_o,\n    // Wishbone Master Cycle Output\n    output m_wb_cyc_o,\n    // Wishbone Master Strobe Output\n    output m_wb_stb_o,\n    // Wishbone Master Acknowledgment Input\n    input m_wb_ack_i,\n    // Wishbone Master Cycle Type Identifier Output\n    output [2:0] m_wb_cti_o,\n    // Wishbone Master Burst Type Extension Output\n    output [1:0] m_wb_bte_o,\n    // Enable Signal\n    input en,\n    // Base Address for Memory Write Operations\n    input [31:0] adr,\n    // SD Card Clock\n    input sd_clk,\n    // Data Input from SD Card Interface\n    input [SD_BUS_W-1:0] dat_i,\n    // Write Enable for FIFO\n    input wr,\n    // FIFO Full Flag\n    output full,\n    // FIFO Empty Flag\n    output empty\n);\n\n// Internal signals and registers\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// Instantiate the sd_rx_fifo module\nsd_rx_fifo u_sd_rx_fifo(\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(m_wb_dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(clk),\n    .rst(reset_rx_fifo)\n);\n\n// Combinational logic for Wishbone master signals\nassign m_wb_adr_o = adr + offset;\nassign m_wb_we_o = ~wb_free & ~empty;\nassign m_wb_cyc_o = ~wb_free;\nassign m_wb_stb_o = ~wb_free & ~empty;\nassign m_wb_cti_o = 3'b000; // Normal cycle\nassign m_wb_bte_o = 2'b00; // Single transfer\n\n// Sequential logic for state machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals and counters\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n    end else if (en) begin\n        // Data reception and transfer process\n        if (~wb_free & ~empty) begin\n            // Start reading from FIFO\n            rd <= 1;\n            // Prepare Wishbone data output\n            m_wb_dat_o <= u_sd_rx_fifo.q;\n            // Set Wishbone write enable and control signals\n            m_wb_we_o <= 1;\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            // Mark Wishbone bus as busy\n            wb_free <= 0;\n        end else if (m_wb_ack_i) begin\n            // Wishbone write transaction completion\n            // Reset Wishbone control signals\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            // Update address offset\n            offset <= offset + MEM_OFFSET;\n            // Mark Wishbone bus as free\n            wb_free <= 1;\n        end\n    end else begin\n        // Disabled state handling\n        reset_rx_fifo <= 1;\n        rd <= 0;\n        offset <= 0;\n        wb_free <= 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 15, "code": "// Import necessary definitions\n`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    // System clock and reset\n    input clk,\n    input rst,\n\n    // Wishbone master interface\n    output [31:0] m_wb_adr_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output [2:0] m_wb_cti_o,\n    output [1:0] m_wb_bte_o,\n\n    // Module enable and base address\n    input en,\n    input [31:0] adr,\n\n    // SD card clock and data\n    input sd_clk,\n    input [SD_BUS_W-1:0] dat_i,\n\n    // FIFO write enable and flags\n    input wr,\n    output full,\n    output empty\n);\n\n// Internal signals and registers\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// Instantiate the sd_rx_fifo module\nsd_rx_fifo #(\n    .FIFO_RX_MEM_DEPTH(FIFO_RX_MEM_DEPTH),\n    .FIFO_RX_MEM_ADR_SIZE(FIFO_RX_MEM_ADR_SIZE)\n) u_sd_rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(m_wb_dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(clk),\n    .rst(reset_rx_fifo)\n);\n\n// Combinational logic for Wishbone master interface\nassign m_wb_adr_o = adr + offset;\nassign m_wb_we_o = ~wb_free;\nassign m_wb_cyc_o = ~wb_free;\nassign m_wb_stb_o = ~wb_free;\nassign m_wb_cti_o = 3'b000; // Default cycle type identifier\nassign m_wb_bte_o = 2'b00; // Default burst type extension\n\n// Sequential logic for module operation\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n    end else if (en) begin\n        // FIFO read preparation\n        if (~rd && ~empty && wb_free) begin\n            rd <= 1;\n            wb_free <= 0;\n        end\n\n        // Wishbone write transaction completion\n        if (~wb_free && m_wb_ack_i) begin\n            offset <= offset + MEM_OFFSET;\n            wb_free <= 1;\n        end\n    end else begin\n        // Disabled state handling\n        reset_rx_fifo <= 1;\n        rd <= 0;\n        offset <= 0;\n        wb_free <= 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    // System Clock and Reset\n    input clk,\n    input rst,\n\n    // Wishbone Master Interface\n    output [31:0] m_wb_adr_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output [2:0] m_wb_cti_o,\n    output [1:0] m_wb_bte_o,\n\n    // Module Control\n    input en,\n    input [31:0] adr,\n\n    // SD Card Interface\n    input sd_clk,\n    input [SD_BUS_W-1:0] dat_i,\n    input wr,\n\n    // FIFO Status\n    output full,\n    output empty\n);\n\n// Registers\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\n\n// sd_rx_fifo Module\nwire [31:0] q;\nwire mem_empt;\nsd_rx_fifo u_sd_rx_fifo(\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(q),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(clk),\n    .rst(reset_rx_fifo)\n);\n\n// Combinational Logic\nalways @(*) begin\n    if (~en) begin\n        m_wb_adr_o = 0;\n        m_wb_we_o = 0;\n        m_wb_dat_o = 0;\n        m_wb_cyc_o = 0;\n        m_wb_stb_o = 0;\n        m_wb_cti_o = 0;\n        m_wb_bte_o = 0;\n        rd = 0;\n        reset_rx_fifo = 1;\n        wb_free = 1;\n    end else if (wb_free && ~empty) begin\n        m_wb_adr_o = adr + offset;\n        m_wb_we_o = 1;\n        m_wb_dat_o = q;\n        m_wb_cyc_o = 1;\n        m_wb_stb_o = 1;\n        m_wb_cti_o = 3'b000; // Normal cycle\n        m_wb_bte_o = 2'b00; // Linear burst\n        rd = 1;\n        reset_rx_fifo = 0;\n        wb_free = 0;\n    end else begin\n        m_wb_adr_o = 0;\n        m_wb_we_o = 0;\n        m_wb_dat_o = 0;\n        m_wb_cyc_o = 0;\n        m_wb_stb_o = 0;\n        m_wb_cti_o = 0;\n        m_wb_bte_o = 0;\n        rd = 0;\n        reset_rx_fifo = 0;\n        wb_free = 1;\n    end\nend\n\n// Sequential Logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n    end else if (~en) begin\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n    end else if (m_wb_ack_i) begin\n        offset <= offset + MEM_OFFSET;\n        wb_free <= 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 17, "code": "// sd_defines.v\n`define BIG_ENDIAN           1\n`define LITTLE_ENDIAN        0\n`define SIM                  1\n`define SYN                  0\n`define SDC_IRQ_ENABLE       1\n`define ACTEL                1\n`define BD_WIDTH             8\n`define BD_SIZE              255\n`define RAM_MEM_WIDTH_16     1\n`define RAM_MEM_WIDTH        32\n`define RESEND_MAX_CNT       10\n`define MEM_OFFSET           4\n`define RESET_CLK_DIV        10\n`define SD_CLK_BUS_CLK       1\n`define SD_CLK_SEP           0\n`define SD_CLK_STATIC        0\n`define SD_CLK_DYNAMIC       1\n`define BLOCK_SIZE           512\n`define SD_BUS_WIDTH_4       1\n`define SD_BUS_W             4\n`define FIFO_RX_MEM_DEPTH    1024\n`define FIFO_RX_MEM_ADR_SIZE 11\n`define FIFO_TX_MEM_DEPTH    1024\n`define FIFO_TX_MEM_ADR_SIZE 11\n\n// sd_fifo_rx_filler.v\nmodule sd_fifo_rx_filler(\n    input               clk,            // System clock\n    input               rst,            // System reset\n    output              m_wb_adr_o,     // Wishbone master address output\n    output              m_wb_we_o,      // Wishbone master write enable\n    output              m_wb_dat_o,     // Wishbone master data output\n    output              m_wb_cyc_o,     // Wishbone master cycle output\n    output              m_wb_stb_o,     // Wishbone master strobe output\n    input               m_wb_ack_i,     // Wishbone master acknowledgment input\n    output              m_wb_cti_o,     // Wishbone master cycle type identifier output\n    output              m_wb_bte_o,     // Wishbone master burst type extension output\n    input               en,             // Enable signal for the module\n    input               adr,            // Base address for memory write operations\n    input               sd_clk,         // SD card clock\n    input               dat_i,          // Data input from SD card interface\n    input               wr,             // Write enable for FIFO\n    output              full,           // FIFO full flag\n    output              empty           // FIFO empty flag\n);\n\n// Internal signals and registers\nreg     [31:0]  offset;         // Address offset for Wishbone transactions\nreg                 wb_free;    // Wishbone bus availability flag\nreg                 reset_rx_fifo; // RX FIFO reset control\nreg                 rd;         // Read enable for RX FIFO\n\n// sd_rx_fifo instance\nsd_rx_fifo u_sd_rx_fifo(\n    .d             (dat_i),      // Input data from SD card\n    .wr            (wr),         // Write enable signal (active high)\n    .wclk          (sd_clk),     // Write clock (rising edge active)\n    .q             (m_wb_dat_o), // Output data to host\n    .rd            (rd),         // Read enable signal (active high)\n    .full          (full),       // FIFO full flag (active high)\n    .empty         (empty),      // FIFO empty flag (active high)\n    .mem_empt      (),           // Memory empty space (in words)\n    .rclk          (clk),        // Read clock (rising edge active)\n    .rst           (rst)         // Asynchronous reset (active high)\n);\n\n// Control logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals and counters\n        offset         <= 0;\n        wb_free        <= 1;\n        reset_rx_fifo  <= 1;\n        rd             <= 0;\n        m_wb_adr_o     <= 0;\n        m_wb_we_o      <= 0;\n        m_wb_dat_o     <= 0;\n        m_wb_cyc_o     <= 0;\n        m_wb_stb_o     <= 0;\n        m_wb_cti_o     <= 0;\n        m_wb_bte_o     <= 0;\n    end else if (en) begin\n        // FIFO read preparation\n        if (!empty && wb_free) begin\n            rd         <= 1;\n            m_wb_dat_o <= dat_i;\n            m_wb_we_o  <= 1;\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            wb_free    <= 0;\n        end\n\n        // Wishbone write transaction completion\n        if (m_wb_ack_i) begin\n            m_wb_we_o  <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            offset     <= offset + `MEM_OFFSET;\n            wb_free    <= 1;\n        end\n    end else begin\n        // Disabled state handling\n        reset_rx_fifo  <= 1;\n        rd             <= 0;\n        m_wb_adr_o     <= 0;\n        m_wb_we_o      <= 0;\n        m_wb_dat_o     <= 0;\n        m_wb_cyc_o     <= 0;\n        m_wb_stb_o     <= 0;\n        m_wb_cti_o     <= 0;\n        m_wb_bte_o     <= 0;\n        offset         <= 0;\n        wb_free        <= 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 18, "code": "// sd_fifo_rx_filler module\nmodule sd_fifo_rx_filler(\n    input clk,            // System clock\n    input rst,            // System reset\n    output [31:0] m_wb_adr_o,  // Wishbone master address output\n    output m_wb_we_o,     // Wishbone master write enable\n    output [31:0] m_wb_dat_o,  // Wishbone master data output\n    output m_wb_cyc_o,    // Wishbone master cycle output\n    output m_wb_stb_o,    // Wishbone master strobe output\n    input m_wb_ack_i,     // Wishbone master acknowledgment input\n    output [2:0] m_wb_cti_o,  // Wishbone master cycle type identifier output\n    output [1:0] m_wb_bte_o,  // Wishbone master burst type extension output\n    input en,             // Enable signal for the module\n    input [31:0] adr,     // Base address for memory write operations\n    input sd_clk,         // SD card clock\n    input [SD_BUS_W-1:0] dat_i,  // Data input from SD card interface\n    input wr,             // Write enable for FIFO\n    output full,          // FIFO full flag\n    output empty          // FIFO empty flag\n);\n\n// sd_rx_fifo module\nmodule sd_rx_fifo(\n    input [3:0] d,        // Input data from SD card\n    input wr,             // Write enable signal (active high)\n    input wclk,           // Write clock (rising edge active)\n    output [31:0] q,      // Output data to host\n    input rd,             // Read enable signal (active high)\n    output full,          // FIFO full flag (active high)\n    output empty,         // FIFO empty flag (active high)\n    output [1:0] mem_empt, // Memory empty space (in words)\n    input rclk,           // Read clock (rising edge active)\n    input rst             // Asynchronous reset (active high)\n);\n\n// sd_defines.v file\n`include \"sd_defines.v\"\n\n// Parameters\nparameter MEM_OFFSET = 4;  // Memory address offset between 2 words\nparameter SD_BUS_W = 4;    // Only support for 4 Bit\nparameter FIFO_RX_MEM_DEPTH = 16;  // Width of RX Fifo\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1;  // log2(FIFO_RX_MEM_DEPTH) + 1\n\n// Registers\nreg [8:0] offset;  // Address offset for Wishbone transactions\nreg wb_free;       // Wishbone bus availability flag\nreg reset_rx_fifo; // RX FIFO reset control\nreg rd;            // Read enable for RX FIFO\n\n// Internal signals\nwire [31:0] dat_o;  // Output data from RX FIFO\nwire fifo_empty;    // FIFO empty flag\nwire fifo_full;     // FIFO full flag\n\n// sd_rx_fifo instance\nsd_rx_fifo u_sd_rx_fifo(\n    .d(dat_i),         // Input data from SD card\n    .wr(wr),           // Write enable signal (active high)\n    .wclk(sd_clk),     // Write clock (rising edge active)\n    .q(dat_o),         // Output data to host\n    .rd(rd),           // Read enable signal (active high)\n    .full(fifo_full),  // FIFO full flag (active high)\n    .empty(fifo_empty), // FIFO empty flag (active high)\n    .mem_empt(),       // Memory empty space (in words)\n    .rclk(clk),        // Read clock (rising edge active)\n    .rst(rst)          // Asynchronous reset (active high)\n);\n\n// Main logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals and counters\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_dat_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n    end else if (en) begin\n        // FIFO read preparation\n        if (!fifo_empty && wb_free) begin\n            rd <= 1;\n            m_wb_dat_o <= dat_o;\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 1;\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            wb_free <= 0;\n        end\n\n        // Wishbone write transaction completion\n        if (m_wb_ack_i) begin\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            offset <= offset + MEM_OFFSET;\n            wb_free <= 1;\n        end\n    end else begin\n        // Reset RX FIFO\n        reset_rx_fifo <= 1;\n        rd <= 0;\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_dat_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n        wb_free <= 1;\n    end\nend\n\n// Assign outputs\nassign full = fifo_full;\nassign empty = fifo_empty;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 19, "code": "// Include the sd_defines.v file for global variables and macros\n`include \"sd_defines.v\"\n\n// Module declaration for sd_fifo_rx_filler\nmodule sd_fifo_rx_filler(\n    // System clock\n    input clk,\n    // Asynchronous reset\n    input rst,\n    // Wishbone master address output\n    output [31:0] m_wb_adr_o,\n    // Wishbone master write enable\n    output m_wb_we_o,\n    // Wishbone master data output\n    output [31:0] m_wb_dat_o,\n    // Wishbone master cycle output\n    output m_wb_cyc_o,\n    // Wishbone master strobe output\n    output m_wb_stb_o,\n    // Wishbone master acknowledgment input\n    input m_wb_ack_i,\n    // Wishbone master cycle type identifier output\n    output [2:0] m_wb_cti_o,\n    // Wishbone master burst type extension output\n    output [1:0] m_wb_bte_o,\n    // Enable signal for the module\n    input en,\n    // Base address for memory write operations\n    input [31:0] adr,\n    // SD card clock\n    input sd_clk,\n    // Data input from SD card interface\n    input [SD_BUS_W-1:0] dat_i,\n    // Write enable for FIFO\n    input wr,\n    // FIFO full flag\n    output full,\n    // FIFO empty flag\n    output empty\n);\n\n// Internal signals and variables\nreg [8:0] offset; // Address offset for Wishbone transactions\nreg wb_free; // Wishbone bus availability flag\nreg reset_rx_fifo; // RX FIFO reset control\nreg rd; // Read enable for RX FIFO\n\n// Instantiate the sd_rx_fifo module\nsd_rx_fifo #(\n    .FIFO_RX_MEM_DEPTH(FIFO_RX_MEM_DEPTH),\n    .FIFO_RX_MEM_ADR_SIZE(FIFO_RX_MEM_ADR_SIZE)\n) u_sd_rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(m_wb_dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(clk),\n    .rst(reset_rx_fifo)\n);\n\n// Initialize internal signals and variables\ninitial begin\n    offset = 0;\n    wb_free = 1'b1;\n    reset_rx_fifo = 1'b1;\n    rd = 1'b0;\nend\n\n// Combinational logic for Wishbone master signals\nalways @(*) begin\n    m_wb_adr_o = adr + offset;\n    m_wb_we_o = ~wb_free;\n    m_wb_cyc_o = ~wb_free;\n    m_wb_stb_o = ~wb_free;\n    m_wb_cti_o = 3'b000; // Normal cycle type\n    m_wb_bte_o = 2'b00; // Single burst type\nend\n\n// Sequential logic for state transitions\nalways @(posedge clk) begin\n    if (rst) begin\n        // Reset all internal signals and variables\n        offset <= 0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n    end else if (en) begin\n        // FIFO read preparation\n        if (~empty && wb_free) begin\n            rd <= 1'b1;\n            wb_free <= 1'b0;\n        end\n        \n        // Wishbone write transaction completion\n        if (~wb_free && m_wb_ack_i) begin\n            offset <= offset + MEM_OFFSET;\n            wb_free <= 1'b1;\n        end\n    end else begin\n        // Disabled state handling\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        offset <= 0;\n        wb_free <= 1'b1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 20, "code": "// Include the sd_defines.v file for global variables and macros\n`include \"sd_defines.v\"\n\n// Module declaration\nmodule sd_fifo_rx_filler(\n    // Input ports\n    input clk,            // System clock\n    input rst,            // Asynchronous reset\n    input en,             // Enable signal for the module\n    input [31:0] adr,     // Base address for memory write operations\n    input sd_clk,         // SD card clock\n    input [SD_BUS_W-1:0] dat_i,  // Data input from SD card interface\n    input wr,             // Write enable for FIFO\n\n    // Output ports\n    output [31:0] m_wb_adr_o,  // Wishbone master address output\n    output m_wb_we_o,        // Wishbone master write enable\n    output [31:0] m_wb_dat_o,  // Wishbone master data output\n    output m_wb_cyc_o,       // Wishbone master cycle output\n    output m_wb_stb_o,       // Wishbone master strobe output\n    output [2:0] m_wb_cti_o,  // Wishbone master cycle type identifier output\n    output [1:0] m_wb_bte_o,  // Wishbone master burst type extension output\n    output full,            // FIFO full flag\n    output empty,           // FIFO empty flag\n\n    // Input ports from Wishbone bus\n    input m_wb_ack_i        // Wishbone master acknowledgment input\n);\n\n// Internal signals and registers\nreg [8:0] offset;          // Address offset for Wishbone transactions\nreg wb_free;               // Wishbone bus availability flag\nreg reset_rx_fifo;         // RX FIFO reset control\nreg rd;                    // Read enable for RX FIFO\n\n// Instantiate the sd_rx_fifo module\nsd_rx_fifo u_sd_rx_fifo(\n    .d(dat_i),             // Input data from SD card\n    .wr(wr),               // Write enable signal\n    .wclk(sd_clk),         // Write clock\n    .q(m_wb_dat_o),        // Output data to host\n    .rd(rd),               // Read enable signal\n    .full(full),           // FIFO full flag\n    .empty(empty),         // FIFO empty flag\n    .mem_empt(),           // Memory empty space (in words)\n    .rclk(clk),            // Read clock\n    .rst(rst)              // Asynchronous reset\n);\n\n// Initialize registers and signals on reset\nalways @(posedge rst or posedge clk) begin\n    if (rst) begin\n        offset <= 9'd0;\n        wb_free <= 1'b1;\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        m_wb_adr_o <= 32'd0;\n        m_wb_we_o <= 1'b0;\n        m_wb_dat_o <= 32'd0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'd0;\n        m_wb_bte_o <= 2'd0;\n    end else if (en) begin\n        // Data reception and transfer process\n        if (!empty && wb_free) begin\n            rd <= 1'b1;\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 1'b1;\n            m_wb_dat_o <= m_wb_dat_o;\n            m_wb_cyc_o <= 1'b1;\n            m_wb_stb_o <= 1'b1;\n            m_wb_cti_o <= 3'd0;\n            m_wb_bte_o <= 2'd0;\n            wb_free <= 1'b0;\n        end\n\n        // Wishbone write transaction completion\n        if (m_wb_ack_i) begin\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            offset <= offset + MEM_OFFSET;\n            wb_free <= 1'b1;\n        end\n    end else begin\n        // Disabled state handling\n        reset_rx_fifo <= 1'b1;\n        rd <= 1'b0;\n        m_wb_adr_o <= 32'd0;\n        m_wb_we_o <= 1'b0;\n        m_wb_dat_o <= 32'd0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'd0;\n        m_wb_bte_o <= 2'd0;\n        wb_free <= 1'b1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 1, "code": "// sd_fifo_tx_filler module\nmodule sd_fifo_tx_filler(\n    input clk, // system clock\n    input rst, // system reset\n    output [31:0] m_wb_adr_o, // Wishbone master address output\n    output m_wb_we_o, // Wishbone master write enable\n    input [31:0] m_wb_dat_i, // Wishbone master data input\n    output m_wb_cyc_o, // Wishbone master cycle output\n    output m_wb_stb_o, // Wishbone master strobe output\n    input m_wb_ack_i, // Wishbone master acknowledgment input\n    output [2:0] m_wb_cti_o, // Wishbone master cycle type identifier output\n    output [1:0] m_wb_bte_o, // Wishbone master burst type extension output\n    input en, // enable signal for the module\n    input [31:0] adr, // base address for memory read operations\n    input sd_clk, // SD card clock\n    output [31:0] dat_o, // data output to SD card interface\n    input rd, // read enable for FIFO\n    output empty, // FIFO empty flag\n    output fe // FIFO full flag\n);\n\n// internal signals and registers\nreg [8:0] offset; // address offset for Wishbone transactions\nreg [8:0] we; // write enable counter\nreg [31:0] din; // data to be written to FIFO\nreg wr_tx; // write control for FIFO\nreg reset_tx_fifo; // TX FIFO reset control\nreg first; // first operation flag\nreg ackd; // acknowledge delay flag\nreg delay; // delay flag for synchronization\n\n// sd_tx_fifo module instantiation\nsd_tx_fifo sd_tx_fifo_inst(\n    .d(din), // data input\n    .wr(wr_tx), // write enable\n    .wclk(clk), // write clock\n    .q(dat_o), // data output\n    .rd(rd), // read enable\n    .full(fe), // FIFO full flag\n    .empty(empty), // FIFO empty flag\n    .mem_empt(), // FIFO occupancy\n    .rclk(sd_clk), // read clock\n    .rst(rst) // asynchronous reset\n);\n\n// combinational logic\nalways @(*) begin\n    // Wishbone master signals\n    m_wb_adr_o = adr + offset;\n    m_wb_we_o = 1'b0; // always read\n    m_wb_cyc_o = en && !fe;\n    m_wb_stb_o = en && !fe;\n    m_wb_cti_o = 3'b000; // normal cycle\n    m_wb_bte_o = 2'b00; // single transfer\n\n    // data to be written to FIFO\n    din = m_wb_dat_i;\nend\n\n// sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // reset all registers and signals\n        offset <= 9'd0;\n        we <= 9'd0;\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b0;\n        first <= 1'b1;\n        ackd <= 1'b0;\n        delay <= 1'b0;\n    end else begin\n        // data transfer process\n        if (en && !fe && !m_wb_ack_i) begin\n            // start Wishbone read transaction\n            m_wb_cyc_o <= 1'b1;\n            m_wb_stb_o <= 1'b1;\n        end\n\n        // Wishbone acknowledgment\n        if (m_wb_ack_i) begin\n            // write data to FIFO\n            wr_tx <= 1'b1;\n            // deassert Wishbone signals\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            // set delay flag\n            delay <= 1'b1;\n        end\n\n        // delay flag\n        if (delay) begin\n            // increment memory address offset\n            offset <= offset + 9'd1;\n            // toggle acknowledge flag\n            ackd <= ~ackd;\n            // stop writing to FIFO\n            wr_tx <= 1'b0;\n            // reset delay flag\n            delay <= 1'b0;\n        end\n\n        // disabled state handling\n        if (!en) begin\n            // reset TX FIFO\n            reset_tx_fifo <= 1'b1;\n            // reset address offset\n            offset <= 9'd0;\n            // set Wishbone control signals to inactive state\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 2, "code": "```ilog\n// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    // System Clock\n    input           clk,\n    // System Reset\n    input           rst,\n    // Wishbone Master Address Output\n    output  [31:0]  m_wb_adr_o,\n    // Wishbone Master Write Enable\n    output          m_wb_we_o,\n    // Wishbone Master Data Input\n    input   [31:0]  m_wb_dat_i,\n    // Wishbone Master Cycle Output\n    output          m_wb_cyc_o,\n    // Wishbone Master Strobe Output\n    output          m_wb_stb_o,\n    // Wishbone Master Acknowledgment Input\n    input           m_wb_ack_i,\n    // Wishbone Master Cycle Type Identifier Output\n    output  [2:0]   m_wb_cti_o,\n    // Wishbone Master Burst Type Extension Output\n    output  [1:0]   m_wb_bte_o,\n    // Enable Signal for the Module\n    input           en,\n    // Base Address for Memory Read Operations\n    input   [31:0]  adr,\n    // SD Card Clock\n    input           sd_clk,\n    // Data Output to SD Card Interface\n    output  [31:0]  dat_o,\n    // Read Enable for FIFO\n    input           rd,\n    // FIFO Empty Flag\n    output          empty,\n    // FIFO Full Flag\n    output          fe\n);\n\n// Internal Registers and Wires\nreg     [8:0]  offset;\nreg     [8:0]  we;\nreg     [31:0] din;\nreg             wr_tx;\nreg             reset_tx_fifo;\nreg             first;\nreg             ackd;\nreg             delay;\n\n// sd_tx_fifo Module Instantiation\nsd_tx_fifo #(\n    .FIFO_TX_MEM_DEPTH(FIFO_TX_MEM_DEPTH),\n    .FIFO_TX_MEM_ADR_SIZE(FIFO_TX_MEM_ADR_SIZE)\n) sd_tx_fifo_inst (\n    .d            (din),\n    .wr           (wr_tx),\n    .wclk         (clk),\n    .q            (dat_o),\n    .rd           (rd),\n    .full         (fe),\n    .empty        (empty),\n    .mem_empt     (),\n    .rclk         (sd_clk),\n    .rst          (rst)\n);\n\n// Combinational Logic\nalways @(*) begin\n    // Default Values\n    m_wb_adr_o = 32'd0;\n    m_wb_we_o  = 1'b0;\n    m_wb_cyc_o = 1'b0;\n    m_wb_stb_o = 1'b0;\n    m_wb_cti_o = 3'b0;\n    m_wb_bte_o = 2'b0;\n    wr_tx      = 1'b0;\n    reset_tx_fifo = 1'b0;\n    \n    // Enable Signal Check\n    if (en) begin\n        // FIFO Not Full and No Ongoing Wishbone Transaction\n        if (!fe && !m_wb_ack_i) begin\n            // Start Wishbone Read Transaction\n            m_wb_adr_o = adr + offset;\n            m_wb_cyc_o = 1'b1;\n            m_wb_stb_o = 1'b1;\n        end\n        \n        // Wishbone Acknowledgment\n        if (m_wb_ack_i) begin\n            // Write Data to FIFO\n            din = m_wb_dat_i;\n            wr_tx = 1'b1;\n            // Deassert Wishbone Signals\n            m_wb_cyc_o = 1'b0;\n            m_wb_stb_o = 1'b0;\n            // Set Delay Flag\n            delay = 1'b1;\n        end\n        \n        // Delay Flag Check\n        if (delay) begin\n            // Increment Memory Address Offset\n            offset = offset + 1;\n            // Toggle Acknowledge Flag\n            ackd = !ackd;\n            // Stop Writing to FIFO\n            wr_tx = 1'b0;\n            // Reset Delay Flag\n            delay = 1'b0;\n        end\n    end else begin\n        // Reset TX FIFO\n        reset_tx_fifo = 1'b1;\n        // Reset Address Offset\n        offset = 9'd0;\n        // Set Wishbone Control Signals to Inactive State\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n        m_wb_we_o  = 1'b0;\n    end\nend\n\n// Sequential Logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset All Registers and Flags\n        offset    <= 9'd0;\n        we        <= 9'd0;\n        din       <= 32'd0;\n        wr_tx     <= 1'b0;\n        reset_tx_fifo <= 1'b0;\n        first     <= 1'b0;\n        ackd      <= 1'b0;\n        delay     <= 1'b0;\n    end else begin\n        // Update Registers and Flags\n        offset    <= offset;\n        we        <= we;\n        din       <= din;\n        wr_tx     <= wr_tx;\n        reset_tx_fifo <= reset_tx_fifo;\n        first     <= first;\n        ackd      <= ackd;\n        delay     <= delay;\n    end\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 3, "code": "// sd_fifo_tx_filler module\nmodule sd_fifo_tx_filler(\n    // System clock\n    input           clk,\n    // System reset\n    input           rst,\n    // Wishbone master address output\n    output  [31:0]  m_wb_adr_o,\n    // Wishbone master write enable\n    output          m_wb_we_o,\n    // Wishbone master data input\n    input   [31:0]  m_wb_dat_i,\n    // Wishbone master cycle output\n    output          m_wb_cyc_o,\n    // Wishbone master strobe output\n    output          m_wb_stb_o,\n    // Wishbone master acknowledgment input\n    input           m_wb_ack_i,\n    // Wishbone master cycle type identifier output\n    output  [2:0]   m_wb_cti_o,\n    // Wishbone master burst type extension output\n    output  [1:0]   m_wb_bte_o,\n    // Enable signal for the module\n    input           en,\n    // Base address for memory read operations\n    input   [31:0]  adr,\n    // SD card clock\n    input           sd_clk,\n    // Data output to SD card interface\n    output  [31:0]  dat_o,\n    // Read enable for FIFO\n    input           rd,\n    // FIFO empty flag\n    output          empty,\n    // FIFO full flag\n    output          fe\n);\n\n// Internal signals\nreg     [8:0]  offset;  // Address offset for Wishbone transactions\nreg     [8:0]  we;      // Write enable counter\nreg     [31:0] din;     // Data to be written to FIFO\nreg             wr_tx;  // Write control for FIFO\nreg             reset_tx_fifo;  // TX FIFO reset control\nreg             first;   // First operation flag\nreg             ackd;    // Acknowledge delay flag\nreg             delay;   // Delay flag for synchronization\n\n// sd_tx_fifo instance\nsd_tx_fifo u_sd_tx_fifo(\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(rst)\n);\n\n// Wishbone master signals\nassign m_wb_adr_o = adr + offset;\nassign m_wb_we_o = 1'b0;  // Always read\nassign m_wb_cyc_o = en && !fe;\nassign m_wb_stb_o = en && !fe;\nassign m_wb_cti_o = 3'b000;  // Normal cycle\nassign m_wb_bte_o = 2'b00;  // Single transfer\n\n// Internal logic\nalways @(posedge clk) begin\n    if (rst) begin\n        offset <= 9'd0;\n        we <= 9'd0;\n        din <= 32'd0;\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b0;\n        first <= 1'b1;\n        ackd <= 1'b0;\n        delay <= 1'b0;\n    end else if (en) begin\n        if (!fe && !m_wb_ack_i && ackd) begin\n            // Start Wishbone read transaction\n            m_wb_cyc_o <= 1'b1;\n            m_wb_stb_o <= 1'b1;\n        end\n        if (m_wb_ack_i) begin\n            // Write data to FIFO\n            din <= m_wb_dat_i;\n            wr_tx <= 1'b1;\n            delay <= 1'b1;\n        end\n        if (delay) begin\n            // Increment address offset\n            offset <= offset + 9'd1;\n            // Toggle acknowledge flag\n            ackd <= ~ackd;\n            // Stop writing to FIFO\n            wr_tx <= 1'b0;\n            delay <= 1'b0;\n        end\n    end else begin\n        // Reset TX FIFO\n        reset_tx_fifo <= 1'b1;\n        // Reset address offset\n        offset <= 9'd0;\n        // Set Wishbone control signals to inactive state\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_we_o <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 4, "code": "// sd_defines.v\n`ifndef sd_defines_v\n`define sd_defines_v\n\n// Define options\n`define BIG_ENDIAN           1\n`define LITTLE_ENDIAN        0\n`define SIM                  1\n`define SYN                  0\n`define SDC_IRQ_ENABLE       1\n`define ACTEL                1\n`define BD_WIDTH             8\n`define BD_SIZE              255\n`define RAM_MEM_WIDTH_16     1\n`define RAM_MEM_WIDTH        32\n`define RESEND_MAX_CNT       10\n`define MEM_OFFSET           2\n`define RESET_CLK_DIV        10\n`define SD_CLK_BUS_CLK       1\n`define SD_CLK_SEP           0\n`define SD_CLK_STATIC        0\n`define SD_CLK_DYNAMIC       1\n`define BLOCK_SIZE           512\n`define SD_BUS_WIDTH_4       1\n`define SD_BUS_W             4\n`define FIFO_RX_MEM_DEPTH    1024\n`define FIFO_RX_MEM_ADR_SIZE 11\n`define FIFO_TX_MEM_DEPTH    1024\n`define FIFO_TX_MEM_ADR_SIZE 11\n\n`endif // sd_defines_v\n\n// sd_fifo_tx_filler.v\n`timescale 1ns/1ps\nmodule sd_fifo_tx_filler(\n    input               clk,\n    input               rst,\n    output              m_wb_adr_o,\n    output              m_wb_we_o,\n    input               m_wb_dat_i,\n    output              m_wb_cyc_o,\n    output              m_wb_stb_o,\n    input               m_wb_ack_i,\n    output              m_wb_cti_o,\n    output              m_wb_bte_o,\n    input               en,\n    input               adr,\n    input               sd_clk,\n    output              dat_o,\n    input               rd,\n    output              empty,\n    output              fe\n);\n\n// Internal signals\nreg [9:0] offset;\nreg [9:0] we;\nreg [31:0] din;\nreg         wr_tx;\nreg         reset_tx_fifo;\nreg         first;\nreg         ackd;\nreg         delay;\n\n// sd_tx_fifo instance\nsd_tx_fifo u_sd_tx_fifo(\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(rst)\n);\n\n// Wishbone master signals\nassign m_wb_adr_o = adr + offset;\nassign m_wb_we_o = 1'b0;\nassign m_wb_cyc_o = en & ~fe & ~m_wb_ack_i;\nassign m_wb_stb_o = en & ~fe & ~m_wb_ack_i;\nassign m_wb_cti_o = 3'b000;\nassign m_wb_bte_o = 2'b00;\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        offset <= 10'd0;\n        we <= 10'd0;\n        din <= 32'd0;\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b0;\n        first <= 1'b1;\n        ackd <= 1'b0;\n        delay <= 1'b0;\n    end else if (en) begin\n        if (~fe & ~m_wb_ack_i) begin\n            // Start Wishbone read transaction\n            m_wb_cyc_o <= 1'b1;\n            m_wb_stb_o <= 1'b1;\n        end else if (m_wb_ack_i) begin\n            // Write data to FIFO\n            wr_tx <= 1'b1;\n            din <= m_wb_dat_i;\n            // Deassert Wishbone signals\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            // Set delay flag\n            delay <= 1'b1;\n        end else if (delay) begin\n            // Increment memory address offset\n            offset <= offset + 10'd1;\n            // Toggle acknowledge flag\n            ackd <= ~ackd;\n            // Stop writing to FIFO\n            wr_tx <= 1'b0;\n            // Clear delay flag\n            delay <= 1'b0;\n        end\n    end else begin\n        // Reset TX FIFO\n        reset_tx_fifo <= 1'b1;\n        // Reset address offset\n        offset <= 10'd0;\n        // Set Wishbone control signals to inactive state\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_we_o <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 5, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Define the sd_fifo_tx_filler module\nmodule sd_fifo_tx_filler(\n    // System clock\n    input clk,\n    // Asynchronous reset\n    input rst,\n    // Wishbone master address output\n    output [31:0] m_wb_adr_o,\n    // Wishbone master write enable\n    output m_wb_we_o,\n    // Wishbone master data input\n    input [31:0] m_wb_dat_i,\n    // Wishbone master cycle output\n    output m_wb_cyc_o,\n    // Wishbone master strobe output\n    output m_wb_stb_o,\n    // Wishbone master acknowledgment input\n    input m_wb_ack_i,\n    // Wishbone master cycle type identifier output\n    output [2:0] m_wb_cti_o,\n    // Wishbone master burst type extension output\n    output [1:0] m_wb_bte_o,\n    // Enable signal for the module\n    input en,\n    // Base address for memory read operations\n    input [31:0] adr,\n    // SD card clock\n    input sd_clk,\n    // Data output to SD card interface\n    output [31:0] dat_o,\n    // Read enable for FIFO\n    input rd,\n    // FIFO empty flag\n    output empty,\n    // FIFO full flag\n    output fe\n);\n\n// Define the registers\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg reset_tx_fifo;\nreg first;\nreg ackd;\nreg delay;\n\n// Define the sd_tx_fifo module\nsd_tx_fifo sd_tx_fifo_inst(\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(rst)\n);\n\n// Initialize the registers on reset\nalways @(posedge rst or posedge clk) begin\n    if (rst) begin\n        offset <= 0;\n        we <= 0;\n        din <= 0;\n        wr_tx <= 0;\n        reset_tx_fifo <= 0;\n        first <= 0;\n        ackd <= 0;\n        delay <= 0;\n    end else begin\n        // Implement the state transition diagram and operation\n        if (en) begin\n            // Start a Wishbone read transaction\n            if (!fe && !m_wb_ack_i && ackd) begin\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 0;\n                m_wb_cyc_o <= 1;\n                m_wb_stb_o <= 1;\n            end\n\n            // Write data to FIFO when Wishbone acknowledges\n            if (m_wb_ack_i) begin\n                din <= m_wb_dat_i;\n                wr_tx <= 1;\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                delay <= 1;\n            end\n\n            // Increment memory address offset and toggle acknowledge flag\n            if (delay) begin\n                offset <= offset + 1;\n                ackd <= !ackd;\n                wr_tx <= 0;\n                delay <= 0;\n            end\n        end else begin\n            // Reset TX FIFO and address offset when disabled\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_we_o <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 6, "code": "// sd_defines.v\n`define BIG_ENDIAN 1\n`define LITTLE_ENDIAN 0\n`define SIM 1\n`define SYN 0\n`define SDC_IRQ_ENABLE 1\n`define ACTEL 1\n`define BD_WIDTH 8\n`define BD_SIZE 255\n`define RAM_MEM_WIDTH_16 1\n`define RAM_MEM_WIDTH 32\n`define RESEND_MAX_CNT 10\n`define MEM_OFFSET 2\n`define RESET_CLK_DIV 10\n`define SD_CLK_BUS_CLK 1\n`define SD_CLK_SEP 0\n`define SD_CLK_STATIC 0\n`define SD_CLK_DYNAMIC 1\n`define BLOCK_SIZE 512\n`define SD_BUS_WIDTH_4 1\n`define SD_BUS_W 4\n`define FIFO_RX_MEM_DEPTH 1024\n`define FIFO_RX_MEM_ADR_SIZE 11\n`define FIFO_TX_MEM_DEPTH 1024\n`define FIFO_TX_MEM_ADR_SIZE 11\n\n// sd_fifo_tx_filler.v\nmodule sd_fifo_tx_filler(\n    input clk,\n    input rst,\n    output [31:0] m_wb_adr_o,\n    output m_wb_we_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output [2:0] m_wb_cti_o,\n    output [1:0] m_wb_bte_o,\n    input en,\n    input [31:0] adr,\n    input sd_clk,\n    output [31:0] dat_o,\n    input rd,\n    output empty,\n    output fe\n);\n\n// Internal signals\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg reset_tx_fifo;\nreg first;\nreg ackd;\nreg delay;\n\n// sd_tx_fifo instance\nsd_tx_fifo #(\n    .FIFO_DEPTH(`FIFO_TX_MEM_DEPTH),\n    .FIFO_WIDTH(32)\n) sd_tx_fifo_inst (\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(rst)\n);\n\n// Combinational logic\nalways @(*) begin\n    m_wb_adr_o = adr + offset;\n    m_wb_we_o = 0;\n    m_wb_cyc_o = en && !fe;\n    m_wb_stb_o = en && !fe;\n    m_wb_cti_o = 3'b000;\n    m_wb_bte_o = 2'b00;\nend\n\n// Sequential logic\nalways @(posedge clk) begin\n    if (rst) begin\n        offset <= 0;\n        we <= 0;\n        din <= 0;\n        wr_tx <= 0;\n        reset_tx_fifo <= 1;\n        first <= 1;\n        ackd <= 0;\n        delay <= 0;\n    end else if (en) begin\n        if (!fe && !m_wb_ack_i) begin\n            // Start Wishbone read transaction\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n        end\n        if (m_wb_ack_i) begin\n            // Write data to FIFO\n            din <= m_wb_dat_i;\n            wr_tx <= 1;\n            delay <= 1;\n        end\n        if (delay) begin\n            // Increment address offset\n            offset <= offset + 1;\n            // Toggle acknowledge flag\n            ackd <= !ackd;\n            // Stop writing to FIFO\n            wr_tx <= 0;\n            delay <= 0;\n        end\n    end else begin\n        // Reset TX FIFO\n        reset_tx_fifo <= 1;\n        // Reset address offset\n        offset <= 0;\n        // Set Wishbone control signals to inactive state\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_we_o <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input clk,\n    input rst,\n    output [31:0] m_wb_adr_o,\n    output m_wb_we_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output [2:0] m_wb_cti_o,\n    output [1:0] m_wb_bte_o,\n    input en,\n    input [31:0] adr,\n    input sd_clk,\n    output [31:0] dat_o,\n    input rd,\n    output empty,\n    output fe\n);\n\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg reset_tx_fifo;\nreg first;\nreg ackd;\nreg delay;\n\nsd_tx_fifo u_sd_tx_fifo(\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(rst)\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        offset <= 0;\n        we <= 0;\n        din <= 0;\n        wr_tx <= 0;\n        reset_tx_fifo <= 0;\n        first <= 1;\n        ackd <= 0;\n        delay <= 0;\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n    end else if (en) begin\n        if (!fe && !m_wb_ack_i && ackd) begin\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end\n        if (m_wb_ack_i) begin\n            din <= m_wb_dat_i;\n            wr_tx <= 1;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            delay <= 1;\n        end\n        if (delay) begin\n            offset <= offset + 1;\n            ackd <= ~ackd;\n            wr_tx <= 0;\n            delay <= 0;\n        end\n    end else begin\n        reset_tx_fifo <= 1;\n        offset <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_we_o <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 8, "code": "// Include necessary file for global variables\n`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    // System clock\n    input clk,\n    // Asynchronous reset\n    input rst,\n    // Wishbone master address output\n    output [31:0] m_wb_adr_o,\n    // Wishbone master write enable\n    output m_wb_we_o,\n    // Wishbone master data input\n    input [31:0] m_wb_dat_i,\n    // Wishbone master cycle output\n    output m_wb_cyc_o,\n    // Wishbone master strobe output\n    output m_wb_stb_o,\n    // Wishbone master acknowledgment input\n    input m_wb_ack_i,\n    // Wishbone master cycle type identifier output\n    output [2:0] m_wb_cti_o,\n    // Wishbone master burst type extension output\n    output [1:0] m_wb_bte_o,\n    // Enable signal for the module\n    input en,\n    // Base address for memory read operations\n    input [31:0] adr,\n    // SD card clock\n    input sd_clk,\n    // Data output to SD card interface\n    output [31:0] dat_o,\n    // Read enable for FIFO\n    input rd,\n    // FIFO empty flag\n    output empty,\n    // FIFO full flag\n    output fe\n);\n\n// Registers\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg reset_tx_fifo;\nreg first;\nreg ackd;\nreg delay;\n\n// sd_tx_fifo module instantiation\nsd_tx_fifo sd_tx_fifo_inst(\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(rst)\n);\n\n// Initialize registers on reset\nalways @(posedge rst or posedge clk) begin\n    if (rst) begin\n        offset <= 0;\n        we <= 0;\n        din <= 0;\n        wr_tx <= 0;\n        reset_tx_fifo <= 0;\n        first <= 0;\n        ackd <= 0;\n        delay <= 0;\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n    end else if (en) begin\n        // Start a Wishbone read transaction if FIFO is not full and no ongoing transaction\n        if (!fe && !m_wb_ack_i) begin\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            m_wb_cti_o <= 3'b000; // Normal cycle\n            m_wb_bte_o <= 2'b00; // Single transfer\n        end\n\n        // Write data to FIFO when Wishbone acknowledges\n        if (m_wb_ack_i) begin\n            din <= m_wb_dat_i;\n            wr_tx <= 1;\n            delay <= 1;\n        end\n\n        // Increment memory address offset and toggle acknowledge flag on the next clock cycle\n        if (delay) begin\n            offset <= offset + 1;\n            ackd <= !ackd;\n            wr_tx <= 0;\n            delay <= 0;\n        end\n    end else begin\n        // Reset TX FIFO and address offset when disabled\n        reset_tx_fifo <= 1;\n        offset <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_we_o <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 9, "code": "// sd_fifo_tx_filler module\nmodule sd_fifo_tx_filler(\n    // System Clock\n    input             clk,\n    // System Reset\n    input             rst,\n    // Wishbone master address output\n    output      [31:0] m_wb_adr_o,\n    // Wishbone master write enable\n    output             m_wb_we_o,\n    // Wishbone master data input\n    input      [31:0] m_wb_dat_i,\n    // Wishbone master cycle output\n    output             m_wb_cyc_o,\n    // Wishbone master strobe output\n    output             m_wb_stb_o,\n    // Wishbone master acknowledgment input\n    input             m_wb_ack_i,\n    // Wishbone master cycle type identifier output\n    output      [2:0] m_wb_cti_o,\n    // Wishbone master burst type extension output\n    output      [1:0] m_wb_bte_o,\n    // Enable signal for the module\n    input             en,\n    // Base address for memory read operations\n    input      [31:0] adr,\n    // SD card clock\n    input             sd_clk,\n    // Data output to SD card interface\n    output     [31:0] dat_o,\n    // Read enable for FIFO\n    input             rd,\n    // FIFO empty flag\n    output             empty,\n    // FIFO full flag\n    output             fe\n);\n\n// Internal signals\nreg         [8:0] offset;\nreg         [8:0] we;\nreg         [31:0] din;\nreg               wr_tx;\nreg               reset_tx_fifo;\nreg               first;\nreg               ackd;\nreg               delay;\n\n// sd_tx_fifo module\nsd_tx_fifo sd_tx_fifo_inst(\n    .d             (din),\n    .wr            (wr_tx),\n    .wclk          (clk),\n    .q             (dat_o),\n    .rd            (rd),\n    .full          (fe),\n    .empty         (empty),\n    .mem_empt      (),\n    .rclk          (sd_clk),\n    .rst           (rst)\n);\n\n// Combinational logic\nalways @(*) begin\n    // Default values\n    m_wb_adr_o = 32'd0;\n    m_wb_we_o = 1'b0;\n    m_wb_cyc_o = 1'b0;\n    m_wb_stb_o = 1'b0;\n    m_wb_cti_o = 3'b0;\n    m_wb_bte_o = 2'b0;\n    wr_tx = 1'b0;\n    reset_tx_fifo = 1'b0;\n    din = 32'd0;\nend\n\n// Sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all registers\n        offset <= 9'd0;\n        we <= 9'd0;\n        din <= 32'd0;\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b0;\n        first <= 1'b0;\n        ackd <= 1'b0;\n        delay <= 1'b0;\n        m_wb_adr_o <= 32'd0;\n        m_wb_we_o <= 1'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'b0;\n        m_wb_bte_o <= 2'b0;\n    end else if (en) begin\n        // Data transfer process\n        if (!fe && !m_wb_ack_i && ackd) begin\n            // Start Wishbone read transaction\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b1;\n            m_wb_stb_o <= 1'b1;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (m_wb_ack_i) begin\n            // Write data to FIFO\n            din <= m_wb_dat_i;\n            wr_tx <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b1;\n        end else if (delay) begin\n            // Increment memory address offset\n            offset <= offset + 1;\n            ackd <= 1'b1;\n            delay <= 1'b0;\n        end\n    end else begin\n        // Disabled state handling\n        reset_tx_fifo <= 1'b1;\n        offset <= 9'd0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_we_o <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 10, "code": "// Import necessary definitions from sd_defines.v\n`include \"sd_defines.v\"\n\n// Define the sd_fifo_tx_filler module\nmodule sd_fifo_tx_filler(\n    // System clock\n    input clk,\n    // System reset\n    input rst,\n    // Wishbone master address output\n    output [31:0] m_wb_adr_o,\n    // Wishbone master write enable\n    output m_wb_we_o,\n    // Wishbone master data input\n    input [31:0] m_wb_dat_i,\n    // Wishbone master cycle output\n    output m_wb_cyc_o,\n    // Wishbone master strobe output\n    output m_wb_stb_o,\n    // Wishbone master acknowledgment input\n    input m_wb_ack_i,\n    // Wishbone master cycle type identifier output\n    output [2:0] m_wb_cti_o,\n    // Wishbone master burst type extension output\n    output [1:0] m_wb_bte_o,\n    // Enable signal for the module\n    input en,\n    // Base address for memory read operations\n    input [31:0] adr,\n    // SD card clock\n    input sd_clk,\n    // Data output to SD card interface\n    output [31:0] dat_o,\n    // Read enable for FIFO\n    input rd,\n    // FIFO empty flag\n    output empty,\n    // FIFO full flag\n    output fe\n);\n\n// Define internal signals\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg reset_tx_fifo;\nreg first;\nreg ackd;\nreg delay;\n\n// Define the sd_tx_fifo module\nsd_tx_fifo sd_tx_fifo_inst(\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(rst)\n);\n\n// Define the main logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals and counters\n        offset <= 0;\n        we <= 0;\n        din <= 0;\n        wr_tx <= 0;\n        reset_tx_fifo <= 0;\n        first <= 0;\n        ackd <= 0;\n        delay <= 0;\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n    end else if (en) begin\n        // Start a Wishbone read transaction if FIFO is not full and no ongoing transaction\n        if (!fe && !m_wb_ack_i && ackd) begin\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n        end\n\n        // Write data to FIFO when Wishbone acknowledges\n        if (m_wb_ack_i) begin\n            din <= m_wb_dat_i;\n            wr_tx <= 1;\n            delay <= 1;\n        end\n\n        // Increment memory address offset and toggle acknowledge flag on the next clock cycle\n        if (delay) begin\n            offset <= offset + 1;\n            ackd <= !ackd;\n            wr_tx <= 0;\n            delay <= 0;\n        end\n    end else begin\n        // Reset TX FIFO and address offset when disabled\n        reset_tx_fifo <= 1;\n        offset <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_we_o <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input clk,\n    input rst,\n    output [31:0] m_wb_adr_o,\n    output m_wb_we_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output [2:0] m_wb_cti_o,\n    output [1:0] m_wb_bte_o,\n    input en,\n    input [31:0] adr,\n    input sd_clk,\n    output [31:0] dat_o,\n    input rd,\n    output empty,\n    output fe\n);\n\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg reset_tx_fifo;\nreg first;\nreg ackd;\nreg delay;\n\nsd_tx_fifo tx_fifo(\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(rst)\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        offset <= 0;\n        we <= 0;\n        din <= 0;\n        wr_tx <= 0;\n        reset_tx_fifo <= 0;\n        first <= 1;\n        ackd <= 0;\n        delay <= 0;\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n    end else if (en) begin\n        if (!fe && !m_wb_ack_i && ackd) begin\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end\n        if (m_wb_ack_i) begin\n            din <= m_wb_dat_i;\n            wr_tx <= 1;\n            delay <= 1;\n            ackd <= 1;\n        end\n        if (delay) begin\n            offset <= offset + 1;\n            wr_tx <= 0;\n            delay <= 0;\n            ackd <= 0;\n        end\n    end else begin\n        reset_tx_fifo <= 1;\n        offset <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_we_o <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 12, "code": "// sd_defines.v\n`define BIG_ENDIAN 1\n`define LITTLE_ENDIAN 0\n`define SIM 1\n`define SYN 0\n`define SDC_IRQ_ENABLE 1\n`define ACTEL 1\n`define BD_WIDTH 8\n`define BD_SIZE 255\n`define RAM_MEM_WIDTH_16 1\n`define RAM_MEM_WIDTH 32\n`define RESEND_MAX_CNT 10\n`define MEM_OFFSET 2\n`define RESET_CLK_DIV 10\n`define SD_CLK_BUS_CLK 1\n`define SD_CLK_SEP 0\n`define SD_CLK_STATIC 0\n`define SD_CLK_DYNAMIC 1\n`define BLOCK_SIZE 512\n`define SD_BUS_WIDTH_4 1\n`define SD_BUS_W 4\n`define FIFO_RX_MEM_DEPTH 1024\n`define FIFO_RX_MEM_ADR_SIZE 11\n`define FIFO_TX_MEM_DEPTH 1024\n`define FIFO_TX_MEM_ADR_SIZE 11\n\n// sd_fifo_tx_filler.v\nmodule sd_fifo_tx_filler(\n    input clk,\n    input rst,\n    output [31:0] m_wb_adr_o,\n    output m_wb_we_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output [2:0] m_wb_cti_o,\n    output [1:0] m_wb_bte_o,\n    input en,\n    input [31:0] adr,\n    input sd_clk,\n    output [31:0] dat_o,\n    input rd,\n    output empty,\n    output fe\n);\n\n// Registers\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg reset_tx_fifo;\nreg first;\nreg ackd;\nreg delay;\n\n// sd_tx_fifo instance\nsd_tx_fifo u_sd_tx_fifo(\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(rst)\n);\n\n// Wishbone master signals\nassign m_wb_adr_o = adr + offset;\nassign m_wb_we_o = 0; // Always read\nassign m_wb_cyc_o = en && !fe && !m_wb_ack_i;\nassign m_wb_stb_o = en && !fe && !m_wb_ack_i;\nassign m_wb_cti_o = 3'b000; // Classic cycle\nassign m_wb_bte_o = 2'b00; // Linear burst\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        offset <= 0;\n        we <= 0;\n        din <= 0;\n        wr_tx <= 0;\n        reset_tx_fifo <= 1;\n        first <= 1;\n        ackd <= 0;\n        delay <= 0;\n    end else if (en) begin\n        if (m_wb_ack_i) begin\n            din <= m_wb_dat_i;\n            wr_tx <= 1;\n            delay <= 1;\n        end else if (delay) begin\n            offset <= offset + 1;\n            ackd <= !ackd;\n            wr_tx <= 0;\n            delay <= 0;\n        end\n    end else begin\n        reset_tx_fifo <= 1;\n        offset <= 0;\n        we <= 0;\n        din <= 0;\n        wr_tx <= 0;\n        first <= 1;\n        ackd <= 0;\n        delay <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 13, "code": "// Include necessary file\n`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input clk,            // System clock\n    input rst,            // System reset\n    output [31:0] m_wb_adr_o,  // Wishbone master address output\n    output m_wb_we_o,     // Wishbone master write enable\n    input [31:0] m_wb_dat_i,   // Wishbone master data input\n    output m_wb_cyc_o,    // Wishbone master cycle output\n    output m_wb_stb_o,    // Wishbone master strobe output\n    input m_wb_ack_i,     // Wishbone master acknowledgment input\n    output [2:0] m_wb_cti_o,  // Wishbone master cycle type identifier output\n    output [1:0] m_wb_bte_o,  // Wishbone master burst type extension output\n    input en,             // Enable signal for the module\n    input [31:0] adr,     // Base address for memory read operations\n    input sd_clk,         // SD card clock\n    output [31:0] dat_o,  // Data output to SD card interface\n    input rd,             // Read enable for FIFO\n    output empty,         // FIFO empty flag\n    output fe             // FIFO full flag\n);\n\n// Internal signals and registers\nreg [8:0] offset;         // Address offset for Wishbone transactions\nreg [8:0] we;             // Write enable counter\nreg [31:0] din;           // Data to be written to FIFO\nreg wr_tx;                // Write control for FIFO\nreg reset_tx_fifo;        // TX FIFO reset control\nreg first;                // First operation flag\nreg ackd;                 // Acknowledge delay flag\nreg delay;                // Delay flag for synchronization\n\n// Instantiate sd_tx_fifo module\nsd_tx_fifo u_sd_tx_fifo(\n    .d(din),              // Data input\n    .wr(wr_tx),           // Write enable\n    .wclk(clk),           // Write clock\n    .q(dat_o),            // Data output\n    .rd(rd),              // Read enable\n    .full(fe),            // FIFO full flag\n    .empty(empty),        // FIFO empty flag\n    .mem_empt(),          // FIFO occupancy\n    .rclk(sd_clk),        // Read clock\n    .rst(rst)             // Asynchronous reset\n);\n\n// Initialize registers and signals\ninitial begin\n    offset = 9'd0;\n    we = 9'd0;\n    din = 32'd0;\n    wr_tx = 1'b0;\n    reset_tx_fifo = 1'b0;\n    first = 1'b0;\n    ackd = 1'b0;\n    delay = 1'b0;\nend\n\n// Main logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all registers and signals\n        offset <= 9'd0;\n        we <= 9'd0;\n        din <= 32'd0;\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b0;\n        first <= 1'b0;\n        ackd <= 1'b0;\n        delay <= 1'b0;\n        m_wb_adr_o <= 32'd0;\n        m_wb_we_o <= 1'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'd0;\n        m_wb_bte_o <= 2'd0;\n    end else if (en) begin\n        // Start a Wishbone read transaction if FIFO is not full and no ongoing transaction\n        if (!fe && !m_wb_ack_i && ackd) begin\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b1;\n            m_wb_stb_o <= 1'b1;\n            m_wb_cti_o <= 3'd0;\n            m_wb_bte_o <= 2'd0;\n        end\n\n        // Write data to FIFO when Wishbone acknowledges\n        if (m_wb_ack_i) begin\n            din <= m_wb_dat_i;\n            wr_tx <= 1'b1;\n            ackd <= 1'b1;\n            delay <= 1'b1;\n        end\n\n        // Increment address offset and toggle acknowledge flag on the next clock cycle\n        if (delay) begin\n            offset <= offset + 9'd1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            wr_tx <= 1'b0;\n        end\n    end else begin\n        // Reset TX FIFO and address offset when disabled\n        reset_tx_fifo <= 1'b1;\n        offset <= 9'd0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_we_o <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 14, "code": "// sd_defines.v\n`define BIG_ENDIAN\n`define LITTLE_ENDIAN\n`define SIM\n`define SYN\n`define SDC_IRQ_ENABLE\n`define ACTEL\n`define BD_WIDTH 8\n`define BD_SIZE 255\n`define RAM_MEM_WIDTH_16\n`define RAM_MEM_WIDTH 32\n`define RESEND_MAX_CNT 255\n`define MEM_OFFSET\n`define RESET_CLK_DIV 255\n`define SD_CLK_BUS_CLK\n`define SD_CLK_SEP\n`define SD_CLK_STATIC\n`define SD_CLK_DYNAMIC\n`define BLOCK_SIZE 512\n`define SD_BUS_WIDTH_4\n`define SD_BUS_W 4\n`define FIFO_RX_MEM_DEPTH\n`define FIFO_RX_MEM_ADR_SIZE\n`define FIFO_TX_MEM_DEPTH\n`define FIFO_TX_MEM_ADR_SIZE\n\n// sd_fifo_tx_filler.v\nmodule sd_fifo_tx_filler(\n    input clk,\n    input rst,\n    output [31:0] m_wb_adr_o,\n    output m_wb_we_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output [2:0] m_wb_cti_o,\n    output [1:0] m_wb_bte_o,\n    input en,\n    input [31:0] adr,\n    input sd_clk,\n    output [31:0] dat_o,\n    input rd,\n    output empty,\n    output fe\n);\n\n// sd_tx_fifo.v\nmodule sd_tx_fifo(\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output full,\n    output empty,\n    output [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg reset_tx_fifo;\nreg first;\nreg ackd;\nreg delay;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        offset <= 0;\n        we <= 0;\n        din <= 0;\n        wr_tx <= 0;\n        reset_tx_fifo <= 0;\n        first <= 0;\n        ackd <= 0;\n        delay <= 0;\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n    end else if (en) begin\n        if (!fe && !m_wb_ack_i && ackd) begin\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end\n        if (m_wb_ack_i) begin\n            din <= m_wb_dat_i;\n            wr_tx <= 1;\n            delay <= 1;\n        end\n        if (delay) begin\n            offset <= offset + 1;\n            ackd <= !ackd;\n            wr_tx <= 0;\n            delay <= 0;\n        end\n    end else begin\n        reset_tx_fifo <= 1;\n        offset <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_we_o <= 0;\n    end\nend\n\nsd_tx_fifo u_sd_tx_fifo(\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(reset_tx_fifo)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 15, "code": "```  [31:0]  m_wb_adr_o,   // Wishbone master address output\n    output          m_wb_we_o,    // Wishbone master write enable\n    input   [31:0]  m_wb_dat_i,   // Wishbone master data input\n    output          m_wb_cyc_o,   // Wishbone master cycle output\n    output          m_wb_stb_o,   // Wishbone master strobe output\n    input           m_wb_ack_i,   // Wishbone master acknowledgment input\n    output  [2:0]   m_wb_cti_o,   // Wishbone master cycle type identifier output\n    output  [1:0]   m_wb_bte_o,   // Wishbone master burst type extension output\n    input           en,           // Enable signal for the module\n    input   [31:0]  adr,          // Base address for memory read operations\n    input           sd_clk,       // SD card clock\n    output  [31:0]  dat_o,        // Data output to SD card interface\n    input           rd,           // Read enable for FIFO\n    output          empty,        // FIFO empty flag\n    output          fe            // FIFO full flag\n);\n\n// Internal signals\nreg     [8:0]  offset;    // Address offset for Wishbone transactions\nreg     [8:0]  we;        // Write enable counter\nreg     [31:0] din;       // Data to be written to FIFO\nreg             wr_tx;    // Write control for FIFO\nreg             reset_tx_fifo; // TX FIFO reset control\nreg             first;    // First operation flag\nreg             ackd;     // Acknowledge delay flag\nreg             delay;    // Delay flag for synchronization\n\n// Instantiate sd_tx_fifo module\nsd_tx_fifo u_sd_tx_fifo(\n    .d        (din),      // Data input\n    .wr       (wr_tx),    // Write enable\n    .wclk     (clk),      // Write clock\n    .q        (dat_o),    // Data output\n    .rd       (rd),       // Read enable\n    .full     (fe),       // FIFO full flag\n    .empty    (empty),    // FIFO empty flag\n    .mem_empt (),         // FIFO occupancy\n    .rclk     (sd_clk),   // Read clock\n    .rst      (rst)       // Asynchronous reset\n);\n\n// Initialize registers\ninitial begin\n    offset = 9'd0;\n    we = 9'd0;\n    din = 32'd0;\n    wr_tx = 1'b0;\n    reset_tx_fifo = 1'b0;\n    first = 1'b0;\n    ackd = 1'b0;\n    delay = 1'b0;\nend\n\n// Main logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals and counters\n        m_wb_adr_o <= 32'd0;\n        m_wb_we_o <= 1'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'd0;\n        m_wb_bte_o <= 2'd0;\n        offset <= 9'd0;\n        we <= 9'd0;\n        din <= 32'd0;\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b1;\n        first <= 1'b0;\n        ackd <= 1'b0;\n        delay <= 1'b0;\n    end else if (en) begin\n        // Start a Wishbone read transaction\n        if (!fe && !m_wb_ack_i && ackd) begin\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b1;\n            m_wb_stb_o <= 1'b1;\n            m_wb_cti_o <= 3'd0;\n            m_wb_bte_o <= 2'd0;\n        end\n\n        // Write data to FIFO\n        if (m_wb_ack_i) begin\n            din <= m_wb_dat_i;\n            wr_tx <= 1'b1;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            delay <= 1'b1;\n        end\n\n        // Increment memory address offset\n        if (delay) begin\n            offset <= offset + 9'd1;\n            ackd <= ~ackd;\n            wr_tx <= 1'b0;\n            delay <= 1'b0;\n        end\n    end else begin\n        // Reset TX FIFO\n        reset_tx_fifo <= 1'b1;\n        offset <= 9'd0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_we_o <= 1'b0;\n    end\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input clk,\n    input rst,\n    output [31:0] m_wb_adr_o,\n    output m_wb_we_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output [2:0] m_wb_cti_o,\n    output [1:0] m_wb_bte_o,\n    input en,\n    input [31:0] adr,\n    input sd_clk,\n    output [31:0] dat_o,\n    input rd,\n    output empty,\n    output fe\n);\n\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg reset_tx_fifo;\nreg first;\nreg ackd;\nreg delay;\n\nsd_tx_fifo u_sd_tx_fifo(\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(rst)\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        offset <= 0;\n        we <= 0;\n        din <= 0;\n        wr_tx <= 0;\n        reset_tx_fifo <= 1;\n        first <= 1;\n        ackd <= 0;\n        delay <= 0;\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n    end else if (en) begin\n        if (!fe && !m_wb_ack_i && ackd) begin\n            m_wb_adr_o <= adr + offset;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (m_wb_ack_i) begin\n            din <= m_wb_dat_i;\n            wr_tx <= 1;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            delay <= 1;\n        end else if (delay) begin\n            offset <= offset + 1;\n            ackd <= ~ackd;\n            wr_tx <= 0;\n            delay <= 0;\n        end\n    end else begin\n        reset_tx_fifo <= 1;\n        offset <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_we_o <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 17, "code": "// Include sd_defines.v for global variables and macro definitions\n`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    // System Clock\n    input clk,\n    // System Reset\n    input rst,\n    // Wishbone Master Address Output\n    output [31:0] m_wb_adr_o,\n    // Wishbone Master Write Enable\n    output m_wb_we_o,\n    // Wishbone Master Data Input\n    input [31:0] m_wb_dat_i,\n    // Wishbone Master Cycle Output\n    output m_wb_cyc_o,\n    // Wishbone Master Strobe Output\n    output m_wb_stb_o,\n    // Wishbone Master Acknowledgment Input\n    input m_wb_ack_i,\n    // Wishbone Master Cycle Type Identifier Output\n    output [2:0] m_wb_cti_o,\n    // Wishbone Master Burst Type Extension Output\n    output [1:0] m_wb_bte_o,\n    // Enable Signal\n    input en,\n    // Base Address for Memory Read Operations\n    input [31:0] adr,\n    // SD Card Clock\n    input sd_clk,\n    // Data Output to SD Card Interface\n    output [31:0] dat_o,\n    // Read Enable for FIFO\n    input rd,\n    // FIFO Empty Flag\n    output empty,\n    // FIFO Full Flag\n    output fe\n);\n\n// Internal Registers\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg reset_tx_fifo;\nreg first;\nreg ackd;\nreg delay;\n\n// sd_tx_fifo Module Instantiation\nsd_tx_fifo u_sd_tx_fifo(\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(rst)\n);\n\n// Combinational Logic\nalways @(*) begin\n    // Default Values\n    m_wb_adr_o = 32'd0;\n    m_wb_we_o = 1'b0;\n    m_wb_cyc_o = 1'b0;\n    m_wb_stb_o = 1'b0;\n    m_wb_cti_o = 3'b0;\n    m_wb_bte_o = 2'b0;\n    wr_tx = 1'b0;\n    reset_tx_fifo = 1'b0;\n    \n    // Enable Signal\n    if (en) begin\n        // Start Wishbone Read Transaction\n        if (!fe && !m_wb_ack_i && ackd) begin\n            m_wb_adr_o = adr + offset;\n            m_wb_cyc_o = 1'b1;\n            m_wb_stb_o = 1'b1;\n        end\n        \n        // Write Data to FIFO\n        if (m_wb_ack_i) begin\n            din = m_wb_dat_i;\n            wr_tx = 1'b1;\n            m_wb_cyc_o = 1'b0;\n            m_wb_stb_o = 1'b0;\n            delay = 1'b1;\n        end\n        \n        // Increment Address Offset\n        if (delay) begin\n            offset = offset + 1;\n            ackd = ~ackd;\n            wr_tx = 1'b0;\n            delay = 1'b0;\n        end\n    end else begin\n        // Reset TX FIFO\n        reset_tx_fifo = 1'b1;\n        offset = 9'd0;\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n        m_wb_we_o = 1'b0;\n    end\nend\n\n// Sequential Logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset Registers\n        offset <= 9'd0;\n        we <= 9'd0;\n        din <= 32'd0;\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b0;\n        first <= 1'b0;\n        ackd <= 1'b0;\n        delay <= 1'b0;\n    end else begin\n        // Update Registers\n        offset <= offset;\n        we <= we;\n        din <= din;\n        wr_tx <= wr_tx;\n        reset_tx_fifo <= reset_tx_fifo;\n        first <= first;\n        ackd <= ackd;\n        delay <= delay;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 18, "code": "// sd_fifo_tx_filler module\nmodule sd_fifo_tx_filler(\n    // System Clock\n    input         clk,\n    // System Reset\n    input         rst,\n    // Wishbone Master Address Output\n    output [31:0] m_wb_adr_o,\n    // Wishbone Master Write Enable\n    output        m_wb_we_o,\n    // Wishbone Master Data Input\n    input  [31:0] m_wb_dat_i,\n    // Wishbone Master Cycle Output\n    output        m_wb_cyc_o,\n    // Wishbone Master Strobe Output\n    output        m_wb_stb_o,\n    // Wishbone Master Acknowledgment Input\n    input         m_wb_ack_i,\n    // Wishbone Master Cycle Type Identifier Output\n    output [2:0]  m_wb_cti_o,\n    // Wishbone Master Burst Type Extension Output\n    output [1:0]  m_wb_bte_o,\n    // Enable Signal\n    input         en,\n    // Base Address for Memory Read Operations\n    input  [31:0] adr,\n    // SD Card Clock\n    input         sd_clk,\n    // Data Output to SD Card Interface\n    output [31:0] dat_o,\n    // Read Enable for FIFO\n    input         rd,\n    // FIFO Empty Flag\n    output        empty,\n    // FIFO Full Flag\n    output        fe\n);\n\n// sd_tx_fifo module\nmodule sd_tx_fifo(\n    // Data Input\n    input  [31:0] d,\n    // Write Enable (Active High)\n    input         wr,\n    // Write Clock (Rising Edge Active)\n    input         wclk,\n    // Data Output\n    output [31:0] q,\n    // Read Enable (Active High)\n    input         rd,\n    // FIFO Full Flag (Active High)\n    output        full,\n    // FIFO Empty Flag (Active High)\n    output        empty,\n    // FIFO Occupancy\n    output [5:0]  mem_empt,\n    // Read Clock (Rising Edge Active)\n    input         rclk,\n    // Asynchronous Reset (Active High)\n    input         rst\n);\n\n// Include sd_defines.v file for macro definitions\n`include \"sd_defines.v\"\n\n// Registers\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg         wr_tx;\nreg         reset_tx_fifo;\nreg         first;\nreg         ackd;\nreg         delay;\n\n// sd_tx_fifo instance\nsd_tx_fifo u_sd_tx_fifo(\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(rst)\n);\n\n// Combinational Logic\nalways @(*) begin\n    // Initialize Wishbone master signals to inactive state\n    m_wb_adr_o = 32'd0;\n    m_wb_we_o = 1'b0;\n    m_wb_cyc_o = 1'b0;\n    m_wb_stb_o = 1'b0;\n    m_wb_cti_o = 3'b0;\n    m_wb_bte_o = 2'b0;\n    \n    // Check if FIFO is not full and no ongoing Wishbone transaction\n    if (~fe && ~m_wb_ack_i && ackd) begin\n        // Start Wishbone read transaction\n        m_wb_adr_o = adr + offset;\n        m_wb_we_o = 1'b0;\n        m_wb_cyc_o = 1'b1;\n        m_wb_stb_o = 1'b1;\n    end\n    \n    // Check if Wishbone acknowledges\n    if (m_wb_ack_i) begin\n        // Write data to FIFO\n        din = m_wb_dat_i;\n        wr_tx = 1'b1;\n        \n        // Deassert Wishbone signals\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n        \n        // Set delay flag for timing purposes\n        delay = 1'b1;\n    end\n    \n    // Check if delay flag is set\n    if (delay) begin\n        // Increment memory address offset\n        offset = offset + 1;\n        \n        // Toggle acknowledge flag\n        ackd = ~ackd;\n        \n        // Stop writing to FIFO\n        wr_tx = 1'b0;\n        \n        // Reset delay flag\n        delay = 1'b0;\n    end\nend\n\n// Sequential Logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals and counters\n        offset <= 9'd0;\n        we <= 9'd0;\n        din <= 32'd0;\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b0;\n        first <= 1'b0;\n        ackd <= 1'b0;\n        delay <= 1'b0;\n        \n        // Reset TX FIFO\n        reset_tx_fifo <= 1'b1;\n    end else begin\n        // Check if enable signal is high\n        if (en) begin\n            // Check if FIFO is not full and no ongoing Wishbone transaction\n            if (~fe && ~m_wb_ack_i && ackd) begin\n                // Start Wishbone read transaction\n                offset <= offset + 1;\n            end\n            \n            // Check if Wishbone acknowledges\n            if (m_wb_ack_i) begin\n                // Write data to FIFO\n                din <= m_wb_dat_i;\n            end\n        end else begin\n            // Reset TX FIFO\n            reset_tx_fifo <= 1'b1;\n            \n            // Reset address offset to 0\n            offset <= 9'd0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 19, "code": "// Import necessary files\n`include \"sd_defines.v\"\n\n// Module definition\nmodule sd_fifo_tx_filler(\n    // Input ports\n    input clk,            // System clock\n    input rst,            // System reset\n    input en,             // Enable signal for the module\n    input [31:0] adr,     // Base address for memory read operations\n    input sd_clk,         // SD card clock\n    input rd,             // Read enable for FIFO\n    input m_wb_ack_i,     // Wishbone master acknowledgment input\n\n    // Output ports\n    output [31:0] m_wb_adr_o,    // Wishbone master address output\n    output m_wb_we_o,            // Wishbone master write enable\n    output m_wb_cyc_o,           // Wishbone master cycle output\n    output m_wb_stb_o,           // Wishbone master strobe output\n    output [2:0] m_wb_cti_o,     // Wishbone master cycle type identifier output\n    output [1:0] m_wb_bte_o,     // Wishbone master burst type extension output\n    output [31:0] dat_o,         // Data output to SD card interface\n    output empty,                // FIFO empty flag\n    output fe                   // FIFO full flag\n);\n\n// Internal signals and registers\nreg [8:0] offset;        // Address offset for Wishbone transactions\nreg [8:0] we;            // Write enable counter\nreg [31:0] din;          // Data to be written to FIFO\nreg wr_tx;               // Write control for FIFO\nreg reset_tx_fifo;       // TX FIFO reset control\nreg first;               // First operation flag\nreg ackd;                // Acknowledge delay flag\nreg delay;               // Delay flag for synchronization\n\n// sd_tx_fifo module instantiation\nsd_tx_fifo sd_tx_fifo_inst(\n    .d(din),             // Data input\n    .wr(wr_tx),          // Write enable\n    .wclk(clk),          // Write clock\n    .q(dat_o),           // Data output\n    .rd(rd),             // Read enable\n    .full(fe),           // FIFO full flag\n    .empty(empty),       // FIFO empty flag\n    .mem_empt(),         // FIFO occupancy\n    .rclk(sd_clk),       // Read clock\n    .rst(rst)            // Asynchronous reset\n);\n\n// Wishbone master signals\nassign m_wb_adr_o = adr + offset;\nassign m_wb_we_o = 1'b0;  // No write operation\nassign m_wb_cyc_o = en & ~ackd;\nassign m_wb_stb_o = en & ~ackd;\nassign m_wb_cti_o = 3'b000;  // Classic cycle\nassign m_wb_bte_o = 2'b00;   // Linear burst\n\n// FIFO control signals\nassign wr_tx = en & ~fe & ~ackd;\nassign reset_tx_fifo = ~en;\n\n// Sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        offset <= 9'd0;\n        we <= 9'd0;\n        din <= 32'd0;\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b0;\n        first <= 1'b1;\n        ackd <= 1'b0;\n        delay <= 1'b0;\n    end else begin\n        if (en) begin\n            if (~ackd) begin\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    ackd <= 1'b1;\n                    delay <= 1'b1;\n                end\n            end else if (delay) begin\n                offset <= offset + 9'd1;\n                ackd <= 1'b0;\n                delay <= 1'b0;\n            end\n        end else begin\n            offset <= 9'd0;\n            we <= 9'd0;\n            din <= 32'd0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 20, "code": "// sd_defines.v\n`ifndef sd_defines_v\n`define sd_defines_v\n\n// Define options for the SDC IP Core\n`define BIG_ENDIAN           1\n`define LITTLE_ENDIAN        0\n`define SIM                  1\n`define SYN                  0\n`define SDC_IRQ_ENABLE       1\n`define ACTEL                1\n`define BD_WIDTH             8\n`define BD_SIZE              255\n`define RAM_MEM_WIDTH_16     1\n`define RAM_MEM_WIDTH        32\n`define RESEND_MAX_CNT       10\n`define MEM_OFFSET           2\n`define RESET_CLK_DIV        10\n`define SD_CLK_BUS_CLK       1\n`define SD_CLK_SEP           0\n`define SD_CLK_STATIC        0\n`define SD_CLK_DYNAMIC       1\n`define BLOCK_SIZE           512\n`define SD_BUS_WIDTH_4       1\n`define SD_BUS_W             4\n`define FIFO_RX_MEM_DEPTH    1024\n`define FIFO_RX_MEM_ADR_SIZE 11\n`define FIFO_TX_MEM_DEPTH    1024\n`define FIFO_TX_MEM_ADR_SIZE 11\n\n`endif // sd_defines_v\n\n// sd_fifo_tx_filler.v\n`timescale 1ns/1ps\nmodule sd_fifo_tx_filler(\n    // System clock and reset\n    input  clk,          // System clock\n    input  rst,          // Asynchronous reset\n\n    // Wishbone master interface\n    output [31:0] m_wb_adr_o,  // Wishbone master address output\n    output        m_wb_we_o,   // Wishbone master write enable\n    input  [31:0] m_wb_dat_i,  // Wishbone master data input\n    output        m_wb_cyc_o,  // Wishbone master cycle output\n    output        m_wb_stb_o,  // Wishbone master strobe output\n    input         m_wb_ack_i,  // Wishbone master acknowledgment input\n    output [2:0]  m_wb_cti_o,  // Wishbone master cycle type identifier output\n    output [1:0]  m_wb_bte_o,  // Wishbone master burst type extension output\n\n    // Module control signals\n    input         en,          // Enable signal for the module\n    input  [31:0] adr,         // Base address for memory read operations\n    input         sd_clk,      // SD card clock\n    output [31:0] dat_o,       // Data output to SD card interface\n    input         rd,          // Read enable for FIFO\n    output        empty,       // FIFO empty flag\n    output        fe           // FIFO full flag\n);\n\n// Registers\nreg [8:0] offset;        // Address offset for Wishbone transactions\nreg [8:0] we;            // Write enable counter\nreg [31:0] din;          // Data to be written to FIFO\nreg         wr_tx;       // Write control for FIFO\nreg         reset_tx_fifo; // TX FIFO reset control\nreg         first;       // First operation flag\nreg         ackd;        // Acknowledge delay flag\nreg         delay;       // Delay flag for synchronization\n\n// sd_tx_fifo module instantiation\nsd_tx_fifo u_sd_tx_fifo(\n    .d(din),             // Data input\n    .wr(wr_tx),          // Write enable\n    .wclk(clk),          // Write clock\n    .q(dat_o),           // Data output\n    .rd(rd),             // Read enable\n    .full(fe),           // FIFO full flag\n    .empty(empty),       // FIFO empty flag\n    .mem_empt(),         // FIFO occupancy\n    .rclk(sd_clk),       // Read clock\n    .rst(rst)            // Asynchronous reset\n);\n\n// Wishbone master signals\nassign m_wb_adr_o = adr + offset;\nassign m_wb_we_o = 1'b0;  // Always read\nassign m_wb_cyc_o = en & ~ackd;\nassign m_wb_stb_o = en & ~ackd;\nassign m_wb_cti_o = 3'b000;  // Normal cycle\nassign m_wb_bte_o = 2'b00;   // Single transfer\n\n// Module logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals and counters\n        offset <= 9'd0;\n        we <= 9'd0;\n        din <= 32'd0;\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b1;\n        first <= 1'b1;\n        ackd <= 1'b0;\n        delay <= 1'b0;\n    end else if (en) begin\n        // Start a Wishbone read transaction\n        if (~fe & ~m_wb_ack_i & ackd) begin\n            m_wb_cyc_o <= 1'b1;\n            m_wb_stb_o <= 1'b1;\n        end\n\n        // Write data to FIFO when Wishbone acknowledges\n        if (m_wb_ack_i) begin\n            wr_tx <= 1'b1;\n            din <= m_wb_dat_i;\n            ackd <= 1'b1;\n            delay <= 1'b1;\n        end\n\n        // Increment memory address offset and toggle acknowledge flag\n        if (delay) begin\n            offset <= offset + 9'd1;\n            ackd <= 1'b0;\n            wr_tx <= 1'b0;\n            delay <= 1'b0;\n        end\n    end else begin\n        // Reset TX FIFO and address offset when disabled\n        reset_tx_fifo <= 1'b1;\n        offset <= 9'd0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 1, "code": "// sd_rx_fifo module\nmodule sd_rx_fifo(\n    input  wire [3:0]  d,       // Input data from SD card\n    input  wire        wr,      // Write enable signal (active high)\n    input  wire        wclk,    // Write clock (rising edge active)\n    output wire [31:0] q,       // Output data to host\n    input  wire        rd,      // Read enable signal (active high)\n    output wire        full,    // FIFO full flag (active high)\n    output wire        empty,   // FIFO empty flag (active high)\n    output wire [1:0]  mem_empt,// Memory empty space (in words)\n    input  wire        rclk,    // Read clock (rising edge active)\n    input  wire        rst      // Asynchronous reset (active high)\n);\n\n// Define parameters\nparameter FIFO_RX_MEM_DEPTH = 16; // Width of RX Fifo\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1; // log2(FIFO_RX_MEM_DEPTH) + 1\n\n// Define registers\nreg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0]; // FIFO storage array\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i; // Write address\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o; // Read address\nreg [7:0] we; // Byte-wise write enable\nreg [31:0] tmp; // Temporary storage\nreg ft; // Data written flag\n\n// Initialize registers\ninitial begin\n    for (int i = 0; i < FIFO_RX_MEM_DEPTH; i++) begin\n        ram[i] = 32'd0;\n    end\n    adr_i = {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n    adr_o = {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n    we = 8'h1;\n    tmp = 32'd0;\n    ft = 1'b0;\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n        tmp <= 32'd0;\n        ft <= 1'b0;\n    end else if (wr) begin\n        // Accumulate 4-bit data in tmp register\n        tmp <= {tmp[27:0], d};\n        // Write 32-bit word to RAM when tmp is full\n        if (ft) begin\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            tmp <= 32'd0;\n            ft <= 1'b0;\n        end else begin\n            ft <= 1'b1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i == adr_o) && ft;\nassign empty = (adr_i == adr_o) && !ft;\n\n// Memory empty space\nassign mem_empt = (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) % FIFO_RX_MEM_DEPTH;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 2, "code": "// sd_defines.v\n`define BIG_ENDIAN 1\n`define LITTLE_ENDIAN 0\n`define SIM 1\n`define SYN 0\n`define SDC_IRQ_ENABLE 1\n`define ACTEL 1\n`define BD_WIDTH 8\n`define BD_SIZE 255\n`define RAM_MEM_WIDTH_16 1\n`define RAM_MEM_WIDTH 32\n`define RESEND_MAX_CNT 10\n`define MEM_OFFSET 2\n`define RESET_CLK_DIV 10\n`define SD_CLK_BUS_CLK 1\n`define SD_CLK_SEP 0\n`define SD_CLK_STATIC 0\n`define SD_CLK_DYNAMIC 1\n`define BLOCK_SIZE 512\n`define SD_BUS_WIDTH_4 1\n`define SD_BUS_W 4\n`define FIFO_RX_MEM_DEPTH 16\n`define FIFO_RX_MEM_ADR_SIZE 5\n`define FIFO_TX_MEM_DEPTH 16\n`define FIFO_TX_MEM_ADR_SIZE 5\n\n// sd_rx_fifo.v\nmodule sd_rx_fifo(\n    input  wire        d,        // Input data from SD card (4-bit)\n    input  wire        wr,       // Write enable signal (active high)\n    input  wire        wclk,     // Write clock (rising edge active)\n    output wire [31:0] q,        // Output data to host (32-bit)\n    input  wire        rd,       // Read enable signal (active high)\n    output wire        full,     // FIFO full flag (active high)\n    output wire        empty,    // FIFO empty flag (active high)\n    output wire [1:0]  mem_empt, // Memory empty space (in words)\n    input  wire        rclk,     // Read clock (rising edge active)\n    input  wire        rst       // Asynchronous reset (active high)\n);\n\nreg [31:0] ram[`FIFO_RX_MEM_DEPTH-1:0]; // FIFO storage array\nreg [`FIFO_RX_MEM_ADR_SIZE-1:0] adr_i; // Write address\nreg [`FIFO_RX_MEM_ADR_SIZE-1:0] adr_o; // Read address\nreg [7:0] we; // Byte-wise write enable\nreg [31:0] tmp; // Temporary storage\nreg ft; // Data written flag\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n        we <= 8'h1;\n    end else if (wr) begin\n        // Write operation\n        if (ft == 0) begin\n            tmp <= {d, 28'd0};\n            ft <= 1;\n        end else if (ft == 1) begin\n            tmp <= {tmp[23:0], d, 24'd0};\n            ft <= 2;\n        end else if (ft == 2) begin\n            tmp <= {tmp[15:0], d, 16'd0};\n            ft <= 3;\n        end else if (ft == 3) begin\n            tmp <= {tmp[7:0], d};\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            ft <= 0;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        // Read operation\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\nassign full = (adr_i == adr_o);\nassign empty = (adr_i == adr_o) && (ft == 0);\nassign mem_empt = `FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input  wire [3:0] d,\n    input  wire       wr,\n    input  wire       wclk,\n    output wire [31:0] q,\n    input  wire       rd,\n    output wire       full,\n    output wire       empty,\n    output wire [1:0] mem_empt,\n    input  wire       rclk,\n    input  wire       rst\n);\n\nreg [31:0] ram[FIFO_RX_MEM_DEPTH-1:0];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr) begin\n        if (ft) begin\n            ram[adr_i] <= {d, tmp[27:0]};\n            adr_i <= adr_i + 1;\n            tmp <= 0;\n            ft <= 0;\n            we <= 8'h1;\n        end else begin\n            tmp[3:0] <= d;\n            we <= we << 1;\n            ft <= 1;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\nassign full = (adr_i == adr_o) && ft;\nassign empty = (adr_i == adr_o) && !ft;\nassign mem_empt = (FIFO_RX_MEM_DEPTH - adr_i) > 2 ? 2'b11 : (FIFO_RX_MEM_DEPTH - adr_i);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input  wire        d,           // Input data from SD card\n    input  wire        wr,          // Write enable signal (active high)\n    input  wire        wclk,        // Write clock (rising edge active)\n    output wire [31:0] q,           // Output data to host\n    input  wire        rd,          // Read enable signal (active high)\n    output wire        full,        // FIFO full flag (active high)\n    output wire        empty,       // FIFO empty flag (active high)\n    output wire [1:0]  mem_empt,    // Memory empty space (in words)\n    input  wire        rclk,        // Read clock (rising edge active)\n    input  wire        rst          // Asynchronous reset (active high)\n);\n\n// Define the width of the FIFO memory\nlocalparam MEM_WIDTH = 32;\nlocalparam MEM_DEPTH = FIFO_RX_MEM_DEPTH;\nlocalparam MEM_ADR_SIZE = FIFO_RX_MEM_ADR_SIZE;\n\n// Define the registers\nreg [MEM_WIDTH-1:0] ram [MEM_DEPTH-1:0];  // FIFO storage array\nreg [MEM_ADR_SIZE-1:0] adr_i;             // Write address\nreg [MEM_ADR_SIZE-1:0] adr_o;             // Read address\nreg [7:0] we;                              // Byte-wise write enable\nreg [31:0] tmp;                            // Temporary storage\nreg ft;                                    // Data written flag\n\n// Initialize the registers\ninitial begin\n    for (int i = 0; i < MEM_DEPTH; i++) begin\n        ram[i] = 32'h0;\n    end\n    adr_i = {MEM_ADR_SIZE{1'b0}};\n    adr_o = {MEM_ADR_SIZE{1'b0}};\n    we = 8'h1;\n    tmp = 32'h0;\n    ft = 1'b0;\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        // Reset the registers\n        adr_i <= {MEM_ADR_SIZE{1'b0}};\n        we <= 8'h1;\n        tmp <= 32'h0;\n        ft <= 1'b0;\n    end else if (wr) begin\n        // Write data to the FIFO\n        if (ft) begin\n            // Write the remaining bytes\n            ram[adr_i] <= {tmp[23:0], d};\n            we <= we >> 1;\n            ft <= 1'b0;\n            adr_i <= adr_i + 1;\n        end else begin\n            // Write the first byte\n            tmp <= {d, 24'h0};\n            we <= 8'h1;\n            ft <= 1'b1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        // Reset the registers\n        adr_o <= {MEM_ADR_SIZE{1'b0}};\n    end else if (rd && !empty) begin\n        // Read data from the FIFO\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i == adr_o) && ft;\nassign empty = (adr_i == adr_o) && !ft;\n\n// Memory empty space\nassign mem_empt = (MEM_DEPTH - (adr_i - adr_o)) % 4;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 5, "code": "// sd_defines.v\n`define BIG_ENDIAN 1\n`define LITTLE_ENDIAN 0\n`define SIM 1\n`define SYN 0\n`define SDC_IRQ_ENABLE 0\n`define ACTEL 0\n`define BD_WIDTH 8\n`define BD_SIZE 255\n`define RAM_MEM_WIDTH_16 1\n`define RAM_MEM_WIDTH 32\n`define RESEND_MAX_CNT 10\n`define MEM_OFFSET 2\n`define RESET_CLK_DIV 10\n`define SD_CLK_BUS_CLK 1\n`define SD_CLK_SEP 0\n`define SD_CLK_STATIC 0\n`define SD_CLK_DYNAMIC 1\n`define BLOCK_SIZE 512\n`define SD_BUS_WIDTH_4 1\n`define SD_BUS_W 4\n`define FIFO_RX_MEM_DEPTH 16\n`define FIFO_RX_MEM_ADR_SIZE 5\n`define FIFO_TX_MEM_DEPTH 16\n`define FIFO_TX_MEM_ADR_SIZE 5\n\n// sd_rx_fifo.v\nmodule sd_rx_fifo(\n    input  wire [3:0] d,\n    input  wire       wr,\n    input  wire       wclk,\n    output wire [31:0] q,\n    input  wire       rd,\n    output wire       full,\n    output wire       empty,\n    output wire [1:0] mem_empt,\n    input  wire       rclk,\n    input  wire       rst\n);\n\nreg [31:0] ram[`FIFO_RX_MEM_DEPTH-1:0];\nreg [`FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\nreg [`FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n        we <= 8'h1;\n    end else if (wr) begin\n        if (ft) begin\n            ram[adr_i] <= {tmp, d};\n            adr_i <= adr_i + 1;\n            tmp <= 0;\n            ft <= 0;\n        end else begin\n            tmp <= {tmp[23:0], d};\n            ft <= ft + 1;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\nassign full = (adr_i == adr_o) && ft;\nassign empty = (adr_i == adr_o) && !ft;\nassign mem_empt = `FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 6, "code": "```ilog\n`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input  wire [3:0] d,         // Input data from SD card\n    input  wire         wr,      // Write enable signal (active high)\n    input  wire         wclk,    // Write clock (rising edge active)\n    output wire [31:0] q,        // Output data to host\n    input  wire         rd,      // Read enable signal (active high)\n    output wire         full,    // FIFO full flag (active high)\n    output wire         empty,   // FIFO empty flag (active high)\n    output wire [1:0]   mem_empt,// Memory empty space (in words)\n    input  wire         rclk,    // Read clock (rising edge active)\n    input  wire         rst      // Asynchronous reset (active high)\n);\n\n// Registers\nreg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];  // FIFO storage array\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;    // Write address\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;    // Read address\nreg [7:0] we;                             // Byte-wise write enable\nreg [31:0] tmp;                           // Temporary storage\nreg ft;                                   // Data written flag\n\n// Internal wires\nwire [31:0] data_out;\n\n// Assign output\nassign q = data_out;\n\n// FIFO full and empty flags\nassign full = (adr_i == adr_o) && ft;\nassign empty = (adr_i == adr_o) && !ft;\n\n// Memory empty space\nassign mem_empt = FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n        we <= 8'h1;\n    end else if (wr) begin\n        // Accumulate data in tmp register\n        tmp <= {tmp[27:0], d};\n        we <= {we[6:0], 1'b1};\n        \n        // Write to RAM when a full 32-bit word is accumulated\n        if (we == 8'hff) begin\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            tmp <= 0;\n            ft <= 1;\n            we <= 8'h1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        data_out <= 0;\n    end else if (rd && !empty) begin\n        data_out <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input  wire            wclk,        // Write clock\n    input  wire            rclk,        // Read clock\n    input  wire            rst,         // Asynchronous active-high reset\n    input  wire    [3:0]   d,           // Input data from SD card\n    input  wire            wr,          // Write enable signal (active high)\n    input  wire            rd,          // Read enable signal (active high)\n    output wire   [31:0]   q,           // Output data to host\n    output wire            full,        // FIFO full flag (active high)\n    output wire            empty,       // FIFO empty flag (active high)\n    output wire    [1:0]   mem_empt     // Memory empty space (in words)\n);\n\n// Define parameters\nparameter RX_MEM_DEPTH = FIFO_RX_MEM_DEPTH;\nparameter RX_MEM_ADR_SIZE = FIFO_RX_MEM_ADR_SIZE;\n\n// Define registers\nreg [31:0] ram [RX_MEM_DEPTH-1:0];  // FIFO storage array\nreg [RX_MEM_ADR_SIZE-1:0] adr_i;    // Write address\nreg [RX_MEM_ADR_SIZE-1:0] adr_o;    // Read address\nreg [7:0] we;                       // Byte-wise write enable\nreg [31:0] tmp;                     // Temporary storage\nreg ft;                             // Data written flag\n\n// Initialize registers\ninitial begin\n    for (int i = 0; i < RX_MEM_DEPTH; i++) begin\n        ram[i] = 32'd0;\n    end\n    adr_i = {RX_MEM_ADR_SIZE{1'b0}};\n    adr_o = {RX_MEM_ADR_SIZE{1'b0}};\n    we = 8'h1;\n    tmp = 32'd0;\n    ft = 1'b0;\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        // Reset write pointer and temporary storage\n        adr_i <= {RX_MEM_ADR_SIZE{1'b0}};\n        tmp <= 32'd0;\n        ft <= 1'b0;\n    end else if (wr) begin\n        // Write data to temporary storage\n        tmp <= {tmp[27:0], d};\n        // Check if a full 32-bit word is accumulated\n        if (we == 8'h1) begin\n            // Write word to RAM\n            ram[adr_i] <= tmp;\n            // Increment write address\n            adr_i <= adr_i + 1;\n            // Reset temporary storage and write enable\n            tmp <= 32'd0;\n            we <= 8'h1;\n            ft <= 1'b1;\n        end else begin\n            // Update write enable\n            we <= we << 1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        // Reset read pointer\n        adr_o <= {RX_MEM_ADR_SIZE{1'b0}};\n    end else if (rd && !empty) begin\n        // Read data from RAM\n        q <= ram[adr_o];\n        // Increment read address\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i == adr_o) && ft;\nassign empty = (adr_i == adr_o) && !ft;\n\n// Memory empty space\nassign mem_empt = RX_MEM_DEPTH - (adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 8, "code": "// sd_defines.v\n`define BIG_ENDIAN 1\n`define LITTLE_ENDIAN 0\n`define SIM 1\n`define SYN 0\n`define SDC_IRQ_ENABLE 1\n`define ACTEL 1\n`define BD_WIDTH 8\n`define BD_SIZE 255\n`define RAM_MEM_WIDTH_16 1\n`define RAM_MEM_WIDTH 32\n`define RESEND_MAX_CNT 10\n`define MEM_OFFSET 2\n`define RESET_CLK_DIV 10\n`define SD_CLK_BUS_CLK 1\n`define SD_CLK_SEP 1\n`define SD_CLK_STATIC 1\n`define SD_CLK_DYNAMIC 0\n`define BLOCK_SIZE 512\n`define SD_BUS_WIDTH_4 1\n`define SD_BUS_W 4\n`define FIFO_RX_MEM_DEPTH 16\n`define FIFO_RX_MEM_ADR_SIZE 5\n`define FIFO_TX_MEM_DEPTH 16\n`define FIFO_TX_MEM_ADR_SIZE 5\n\n// sd_rx_fifo.v\nmodule sd_rx_fifo(\n    input  wire [3:0]  d,\n    input  wire        wr,\n    input  wire        wclk,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [1:0]  mem_empt,\n    input  wire        rclk,\n    input  wire        rst\n);\n\nreg [31:0] ram[`FIFO_RX_MEM_DEPTH-1:0];\nreg [`FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\nreg [`FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr) begin\n        if (ft == 0) begin\n            tmp <= {d, 24'b0};\n            we <= 8'h1;\n            ft <= 1;\n        end else if (ft == 1) begin\n            tmp <= {tmp[23:0], d, 8'b0};\n            we <= 8'h3;\n            ft <= 2;\n        end else if (ft == 2) begin\n            tmp <= {tmp[15:0], d, 16'b0};\n            we <= 8'h7;\n            ft <= 3;\n        end else if (ft == 3) begin\n            tmp <= {tmp[7:0], d, 24'b0};\n            we <= 8'hF;\n            ft <= 0;\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty <= 1'b1;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n        if (adr_o == `FIFO_RX_MEM_DEPTH-1) begin\n            adr_o <= 0;\n        end\n    end\nend\n\nassign full = (adr_i == adr_o) ? 1'b1 : 1'b0;\nassign empty = (adr_o == adr_i) ? 1'b1 : 1'b0;\nassign mem_empt = `FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input  wire        d,         // Input data from SD card (4-bit)\n    input  wire        wr,        // Write enable signal (active high)\n    input  wire        wclk,      // Write clock (rising edge active)\n    output wire [31:0] q,         // Output data to host (32-bit)\n    input  wire        rd,        // Read enable signal (active high)\n    output wire        full,      // FIFO full flag (active high)\n    output wire        empty,     // FIFO empty flag (active high)\n    output wire [1:0]  mem_empt,  // Memory empty space (in words)\n    input  wire        rclk,      // Read clock (rising edge active)\n    input  wire        rst        // Asynchronous reset (active high)\n);\n\n// Define the FIFO memory\nreg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n// Define the write and read address registers\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n\n// Define the byte-wise write enable register\nreg [7:0] we;\n\n// Define the temporary storage register\nreg [31:0] tmp;\n\n// Define the data written flag\nreg ft;\n\n// Initialize the registers\ninitial begin\n    for (int i = 0; i < FIFO_RX_MEM_DEPTH; i++) begin\n        ram[i] = 32'd0;\n    end\n    adr_i = {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n    adr_o = {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n    we = 8'h1;\n    tmp = 32'd0;\n    ft = 1'b0;\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        // Reset the registers\n        adr_i <= {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n        adr_o <= {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n        we <= 8'h1;\n        tmp <= 32'd0;\n        ft <= 1'b0;\n    end else if (wr) begin\n        // Write data to the FIFO\n        if (ft == 1'b0) begin\n            // Write the first byte\n            tmp[3:0] <= d;\n            we <= 8'h1;\n            ft <= 1'b1;\n        end else if (ft == 1'b1) begin\n            // Write the second byte\n            tmp[7:4] <= d;\n            we <= 8'h3;\n            ft <= 1'b2;\n        end else if (ft == 1'b2) begin\n            // Write the third byte\n            tmp[11:8] <= d;\n            we <= 8'h7;\n            ft <= 1'b3;\n        end else if (ft == 1'b3) begin\n            // Write the fourth byte\n            tmp[15:12] <= d;\n            we <= 8'hF;\n            ft <= 1'b4;\n        end else if (ft == 1'b4) begin\n            // Write the fifth byte\n            tmp[19:16] <= d;\n            we <= 8'h1F;\n            ft <= 1'b5;\n        end else if (ft == 1'b5) begin\n            // Write the sixth byte\n            tmp[23:20] <= d;\n            we <= 8'h3F;\n            ft <= 1'b6;\n        end else if (ft == 1'b6) begin\n            // Write the seventh byte\n            tmp[27:24] <= d;\n            we <= 8'h7F;\n            ft <= 1'b7;\n        end else if (ft == 1'b7) begin\n            // Write the eighth byte\n            tmp[31:28] <= d;\n            we <= 8'hFF;\n            ft <= 1'b0;\n            // Write the word to the FIFO\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_RX_MEM_DEPTH) begin\n                adr_i <= 0;\n            end\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        // Reset the registers\n        adr_o <= {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n    end else if (rd && !empty) begin\n        // Read data from the FIFO\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n        if (adr_o == FIFO_RX_MEM_DEPTH) begin\n            adr_o <= 0;\n        end\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i == adr_o);\nassign empty = (adr_o == adr_i) && (we == 8'h1);\n\n// Memory empty space\nassign mem_empt = FIFO_RX_MEM_DEPTH - adr_i;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input  wire [3:0]  d,\n    input  wire        wr,\n    input  wire        wclk,\n    output wire [31:0] q,\n    input  wire        rd,\n    output wire        full,\n    output wire        empty,\n    output wire [1:0]  mem_empt,\n    input  wire        rclk,\n    input  wire        rst\n);\n\nreg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr) begin\n        if (ft == 0) begin\n            tmp <= {d, 28'd0};\n            we <= 8'h1;\n            ft <= 1;\n        end else if (ft == 1) begin\n            tmp <= {tmp[23:0], d, 24'd0};\n            we <= 8'h3;\n            ft <= 2;\n        end else if (ft == 2) begin\n            tmp <= {tmp[15:0], d, 16'd0};\n            we <= 8'h7;\n            ft <= 3;\n        end else if (ft == 3) begin\n            tmp <= {tmp[7:0], d};\n            we <= 8'hF;\n            ft <= 0;\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_RX_MEM_DEPTH - 1) begin\n                adr_i <= 0;\n            end\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty <= 1;\n        full <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n        if (adr_o == FIFO_RX_MEM_DEPTH - 1) begin\n            adr_o <= 0;\n        end\n    end\nend\n\nalways @(*) begin\n    if (adr_i == adr_o) begin\n        empty <= 1;\n        full <= 0;\n    end else if (adr_i == FIFO_RX_MEM_DEPTH - 1 && adr_o == 0) begin\n        full <= 1;\n        empty <= 0;\n    end else begin\n        empty <= 0;\n        full <= 0;\n    end\n    mem_empt <= FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input  wire        wclk,        // Write clock\n    input  wire        rclk,        // Read clock\n    input  wire        rst,         // Asynchronous active-high reset\n    input  wire [3:0]  d,           // Input data from SD card\n    input  wire        wr,          // Write enable signal (active high)\n    input  wire        rd,          // Read enable signal (active high)\n    output wire [31:0] q,           // Output data to host\n    output wire        full,        // FIFO full flag (active high)\n    output wire        empty,       // FIFO empty flag (active high)\n    output wire [1:0]  mem_empt     // Memory empty space (in words)\n);\n\n// Define parameters\nparameter RX_MEM_DEPTH = FIFO_RX_MEM_DEPTH;\nparameter RX_MEM_ADR_SIZE = FIFO_RX_MEM_ADR_SIZE;\n\n// Define registers\nreg [31:0] ram [RX_MEM_DEPTH-1:0]; // FIFO storage array\nreg [RX_MEM_ADR_SIZE-1:0] adr_i;  // Write address\nreg [RX_MEM_ADR_SIZE-1:0] adr_o;  // Read address\nreg [7:0] we;                     // Byte-wise write enable\nreg [31:0] tmp;                   // Temporary storage\nreg ft;                           // Data written flag\n\n// Initialize registers\ninitial begin\n    for (int i = 0; i < RX_MEM_DEPTH; i++) begin\n        ram[i] = 32'd0;\n    end\n    adr_i = {RX_MEM_ADR_SIZE{1'b0}};\n    adr_o = {RX_MEM_ADR_SIZE{1'b0}};\n    we = 8'h1;\n    tmp = 32'd0;\n    ft = 1'b0;\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= {RX_MEM_ADR_SIZE{1'b0}};\n        tmp <= 32'd0;\n        ft <= 1'b0;\n    end else if (wr) begin\n        if (ft) begin\n            ram[adr_i] <= {tmp[31:4], d};\n            adr_i <= adr_i + 1;\n            tmp <= 32'd0;\n            ft <= 1'b0;\n        end else begin\n            tmp <= {tmp[27:0], d};\n            ft <= 1'b1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= {RX_MEM_ADR_SIZE{1'b0}};\n    end else if (rd) begin\n        if (adr_o == adr_i) begin\n            q <= 32'd0;\n        end else begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i == adr_o) && ft;\nassign empty = (adr_i == adr_o) && !ft;\n\n// Memory empty space\nassign mem_empt = (adr_i < adr_o) ? (adr_o - adr_i) : (RX_MEM_DEPTH - adr_i + adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input  wire [3:0] d,\n    input  wire       wr,\n    input  wire       wclk,\n    output wire [31:0] q,\n    input  wire       rd,\n    output wire       full,\n    output wire       empty,\n    output wire [1:0] mem_empt,\n    input  wire       rclk,\n    input  wire       rst\n);\n\nreg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr) begin\n        if (ft == 0) begin\n            tmp <= {d, 24'b0};\n            we <= 8'h1;\n            ft <= 1;\n        end else if (ft == 1) begin\n            tmp <= {tmp[23:0], d, 8'b0};\n            we <= 8'h3;\n            ft <= 2;\n        end else if (ft == 2) begin\n            tmp <= {tmp[15:0], d, 16'b0};\n            we <= 8'h7;\n            ft <= 3;\n        end else if (ft == 3) begin\n            tmp <= {tmp[7:0], d};\n            we <= 8'hF;\n            ft <= 0;\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_RX_MEM_DEPTH - 1) begin\n                adr_i <= 0;\n            end\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n        if (adr_o == FIFO_RX_MEM_DEPTH - 1) begin\n            adr_o <= 0;\n        end\n    end\nend\n\nassign full = (adr_i == adr_o) && ft == 0;\nassign empty = (adr_i == adr_o) && ft == 0;\nassign mem_empt = (FIFO_RX_MEM_DEPTH - adr_i) % 4;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 13, "code": "// Include necessary file\n`include \"sd_defines.v\"\n\n// Module declaration\nmodule sd_rx_fifo(\n    input  wire [3:0]  d,       // Input data from SD card\n    input  wire        wr,      // Write enable signal (active high)\n    input  wire        wclk,    // Write clock (rising edge active)\n    output wire [31:0] q,       // Output data to host\n    input  wire        rd,      // Read enable signal (active high)\n    output wire        full,    // FIFO full flag (active high)\n    output wire        empty,   // FIFO empty flag (active high)\n    output wire [1:0]  mem_empt,// Memory empty space (in words)\n    input  wire        rclk,    // Read clock (rising edge active)\n    input  wire        rst      // Asynchronous reset (active high)\n);\n\n// Register declarations\nreg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0]; // FIFO storage array\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;   // Write address\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;   // Read address\nreg [7:0] we;                            // Byte-wise write enable\nreg [31:0] tmp;                          // Temporary storage\nreg ft;                                  // Data written flag\n\n// Initialize registers\ninitial begin\n    for (int i = 0; i < FIFO_RX_MEM_DEPTH; i++) begin\n        ram[i] = 32'd0;\n    end\n    adr_i = 'd0;\n    adr_o = 'd0;\n    we = 8'h1;\n    tmp = 32'd0;\n    ft = 1'b0;\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        // Reset write pointer and temporary storage\n        adr_i <= 'd0;\n        tmp <= 32'd0;\n        ft <= 1'b0;\n    end else if (wr) begin\n        // Write 4-bit data to temporary storage\n        tmp <= {tmp[27:0], d};\n        we <= {we[6:0], 1'b1};\n        \n        // Write 32-bit word to RAM when full\n        if (ft) begin\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            tmp <= 32'd0;\n            we <= 8'h1;\n            ft <= 1'b0;\n        end else begin\n            ft <= 1'b1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        // Reset read pointer\n        adr_o <= 'd0;\n    end else if (rd && !empty) begin\n        // Read 32-bit data from RAM\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i == adr_o) && ft;\nassign empty = (adr_i == adr_o) && !ft;\n\n// Memory empty space\nassign mem_empt = FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input  wire        [3:0]  d,         // Input data from SD card\n    input  wire                wr,        // Write enable signal (active high)\n    input  wire                wclk,      // Write clock (rising edge active)\n    output wire        [31:0] q,         // Output data to host\n    input  wire                rd,        // Read enable signal (active high)\n    output wire                full,      // FIFO full flag (active high)\n    output wire                empty,     // FIFO empty flag (active high)\n    output wire        [1:0]  mem_empt,  // Memory empty space (in words)\n    input  wire                rclk,      // Read clock (rising edge active)\n    input  wire                rst        // Asynchronous reset (active high)\n);\n\n// Define parameters\nparameter RX_MEM_DEPTH = FIFO_RX_MEM_DEPTH;\nparameter RX_MEM_ADR_SIZE = FIFO_RX_MEM_ADR_SIZE;\n\n// Define registers\nreg [31:0] ram [RX_MEM_DEPTH-1:0];  // FIFO storage array\nreg [RX_MEM_ADR_SIZE-1:0] adr_i;    // Write address\nreg [RX_MEM_ADR_SIZE-1:0] adr_o;    // Read address\nreg [7:0] we;                       // Byte-wise write enable\nreg [31:0] tmp;                     // Temporary storage\nreg ft;                             // Data written flag\n\n// Initialize registers\ninitial begin\n    for (int i = 0; i < RX_MEM_DEPTH; i++) begin\n        ram[i] = 32'd0;\n    end\n    adr_i = {RX_MEM_ADR_SIZE{1'b0}};\n    adr_o = {RX_MEM_ADR_SIZE{1'b0}};\n    we = 8'h1;\n    tmp = 32'd0;\n    ft = 1'b0;\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= {RX_MEM_ADR_SIZE{1'b0}};\n        tmp <= 32'd0;\n        ft <= 1'b0;\n    end else if (wr) begin\n        // Accumulate 4-bit data in tmp register\n        tmp <= {tmp[27:0], d};\n        // Write full 32-bit word to RAM\n        if (ft) begin\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            tmp <= 32'd0;\n            ft <= 1'b0;\n        end else begin\n            ft <= 1'b1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= {RX_MEM_ADR_SIZE{1'b0}};\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i == adr_o) && ft;\nassign empty = (adr_i == adr_o) && !ft;\n\n// Memory empty space\nassign mem_empt = RX_MEM_DEPTH - (adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input  wire        d,       // Input data from SD card\n    input  wire        wr,      // Write enable signal (active high)\n    input  wire        wclk,    // Write clock (rising edge active)\n    output reg  [31:0] q,       // Output data to host\n    input  wire        rd,      // Read enable signal (active high)\n    output reg         full,    // FIFO full flag (active high)\n    output reg         empty,   // FIFO empty flag (active high)\n    output reg  [1:0]  mem_empt,// Memory empty space (in words)\n    input  wire        rclk,    // Read clock (rising edge active)\n    input  wire        rst      // Asynchronous reset (active high)\n);\n\n// Define FIFO parameters\nlocalparam FIFO_RX_MEM_WIDTH = 32;\nlocalparam FIFO_RX_MEM_DEPTH = `FIFO_RX_MEM_DEPTH;\nlocalparam FIFO_RX_MEM_ADR_SIZE = `FIFO_RX_MEM_ADR_SIZE;\n\n// Define internal signals\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i; // Write address\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o; // Read address\nreg [7:0] we; // Byte-wise write enable\nreg [31:0] tmp; // Temporary storage\nreg ft; // Data written flag\nreg [FIFO_RX_MEM_WIDTH-1:0] ram [FIFO_RX_MEM_DEPTH-1:0]; // FIFO storage array\n\n// Initialize internal signals\ninitial begin\n    adr_i = 0;\n    adr_o = 0;\n    we = 8'h1;\n    tmp = 0;\n    ft = 0;\n    for (int i = 0; i < FIFO_RX_MEM_DEPTH; i++) begin\n        ram[i] = 0;\n    end\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        // Reset internal signals\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr) begin\n        // Write data to temporary storage\n        tmp <= {tmp[27:0], d};\n        we <= we >> 1;\n        if (we == 0) begin\n            // Write data to FIFO\n            ram[adr_i] <= tmp;\n            adr_i <= (adr_i + 1) % FIFO_RX_MEM_DEPTH;\n            tmp <= 0;\n            we <= 8'h1;\n            ft <= 1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        // Reset internal signals\n        adr_o <= 0;\n        q <= 0;\n        empty <= 1;\n        mem_empt <= 2'd3;\n    end else if (rd && !empty) begin\n        // Read data from FIFO\n        q <= ram[adr_o];\n        adr_o <= (adr_o + 1) % FIFO_RX_MEM_DEPTH;\n        if (adr_o == adr_i) begin\n            // FIFO is empty\n            empty <= 1;\n            mem_empt <= 2'd3;\n        end else begin\n            // Update memory empty space\n            mem_empt <= mem_empt - 1;\n        end\n    end\nend\n\n// Full and empty flags\nalways @(*) begin\n    full = (adr_i == (adr_o - 1) % FIFO_RX_MEM_DEPTH);\n    empty = (adr_i == adr_o);\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 16, "code": "// sd_rx_fifo module\nmodule sd_rx_fifo(\n    input  wire [3:0]  d,       // Input data from SD card\n    input  wire        wr,      // Write enable signal (active high)\n    input  wire        wclk,    // Write clock (rising edge active)\n    output wire [31:0] q,       // Output data to host\n    input  wire        rd,      // Read enable signal (active high)\n    output wire        full,    // FIFO full flag (active high)\n    output wire        empty,   // FIFO empty flag (active high)\n    output wire [1:0]  mem_empt,// Memory empty space (in words)\n    input  wire        rclk,    // Read clock (rising edge active)\n    input  wire        rst      // Asynchronous reset (active high)\n);\n\n// Include sd_defines.v for global variables\n`include \"sd_defines.v\"\n\n// Define parameters\nparameter MEM_DEPTH = FIFO_RX_MEM_DEPTH;\nparameter MEM_ADR_SIZE = FIFO_RX_MEM_ADR_SIZE;\n\n// Define registers\nreg [31:0] ram [MEM_DEPTH-1:0]; // FIFO storage array\nreg [MEM_ADR_SIZE-1:0] adr_i;   // Write address\nreg [MEM_ADR_SIZE-1:0] adr_o;   // Read address\nreg [7:0] we;                   // Byte-wise write enable\nreg [31:0] tmp;                 // Temporary storage\nreg ft;                         // Data written flag\n\n// Initialize registers\ninitial begin\n    for (int i = 0; i < MEM_DEPTH; i++) begin\n        ram[i] = 32'd0;\n    end\n    adr_i = MEM_ADR_SIZE'd0;\n    adr_o = MEM_ADR_SIZE'd0;\n    we = 8'd1;\n    tmp = 32'd0;\n    ft = 1'd0;\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        // Reset write pointer and temporary storage\n        adr_i <= MEM_ADR_SIZE'd0;\n        tmp <= 32'd0;\n        ft <= 1'd0;\n    end else if (wr) begin\n        // Write data to temporary storage\n        tmp <= {tmp[27:0], d};\n        we <= {we[6:0], 1'd1};\n        \n        // Write data to RAM when full word is accumulated\n        if (we == 8'd255) begin\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            tmp <= 32'd0;\n            we <= 8'd1;\n            ft <= 1'd1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        // Reset read pointer\n        adr_o <= MEM_ADR_SIZE'd0;\n    end else if (rd && !empty) begin\n        // Read data from RAM\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i == adr_o) && ft;\nassign empty = (adr_i == adr_o) && !ft;\n\n// Memory empty space\nassign mem_empt = MEM_DEPTH - (adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input  wire            wclk,        // Write clock\n    input  wire            rclk,        // Read clock\n    input  wire            rst,         // Asynchronous reset\n    input  wire    [3:0]   d,           // Input data from SD card\n    input  wire            wr,          // Write enable signal\n    input  wire            rd,          // Read enable signal\n    output reg     [31:0]  q,           // Output data to host\n    output reg             full,        // FIFO full flag\n    output reg             empty,       // FIFO empty flag\n    output reg      [1:0]  mem_empt     // Memory empty space (in words)\n);\n\n// Define parameters\nparameter   FIFO_RX_MEM_DEPTH  = `FIFO_RX_MEM_DEPTH;\nparameter   FIFO_RX_MEM_ADR_SIZE = `FIFO_RX_MEM_ADR_SIZE;\n\n// Define registers\nreg [31:0]  ram [FIFO_RX_MEM_DEPTH-1:0];  // FIFO storage array\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;     // Write address\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;     // Read address\nreg [7:0]   we;                            // Byte-wise write enable\nreg [31:0]  tmp;                           // Temporary storage\nreg         ft;                            // Data written flag\n\n// Initialize registers\ninitial begin\n    for (int i = 0; i < FIFO_RX_MEM_DEPTH; i++) begin\n        ram[i] = 32'd0;\n    end\n    adr_i = {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n    adr_o = {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n    we = 8'h1;\n    tmp = 32'd0;\n    ft = 1'b0;\n    full = 1'b0;\n    empty = 1'b1;\n    mem_empt = 2'd0;\n    q = 32'd0;\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        // Reset write pointer and temporary storage\n        adr_i <= {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n        tmp <= 32'd0;\n        ft <= 1'b0;\n        we <= 8'h1;\n    end else if (wr) begin\n        // Write data to temporary storage\n        tmp <= {tmp[27:0], d};\n        we <= we >> 4;\n        if (we == 8'h0) begin\n            // Write full word to RAM\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            tmp <= 32'd0;\n            we <= 8'h1;\n            ft <= 1'b1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        // Reset read pointer\n        adr_o <= {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n        empty <= 1'b1;\n    end else if (rd && !empty) begin\n        // Read data from RAM\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n        if (adr_o == FIFO_RX_MEM_DEPTH - 1) begin\n            // Wrap around read pointer\n            adr_o <= {FIFO_RX_MEM_ADR_SIZE{1'b0}};\n        end\n        empty <= (adr_o == adr_i);\n    end\nend\n\n// Full and empty flags\nalways @(*) begin\n    full <= (adr_i == adr_o) && ft;\n    empty <= (adr_o == adr_i) && !ft;\n    mem_empt <= (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) / 2;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input  wire            wclk,    // Write clock\n    input  wire            rclk,    // Read clock\n    input  wire            rst,     // Asynchronous active-high reset\n    input  wire [3:0]      d,       // Input data from SD card\n    input  wire            wr,      // Write enable signal (active high)\n    input  wire            rd,      // Read enable signal (active high)\n    output wire [31:0]     q,       // Output data to host\n    output wire            full,    // FIFO full flag (active high)\n    output wire            empty,   // FIFO empty flag (active high)\n    output wire [1:0]      mem_empt // Memory empty space (in words)\n);\n\n// Define parameters\nparameter RX_MEM_DEPTH = FIFO_RX_MEM_DEPTH;\nparameter RX_MEM_ADR_SIZE = FIFO_RX_MEM_ADR_SIZE;\n\n// Define registers\nreg [31:0] ram [RX_MEM_DEPTH-1:0]; // FIFO storage array\nreg [RX_MEM_ADR_SIZE-1:0] adr_i; // Write address\nreg [RX_MEM_ADR_SIZE-1:0] adr_o; // Read address\nreg [7:0] we; // Byte-wise write enable\nreg [31:0] tmp; // Temporary storage\nreg ft; // Data written flag\n\n// Initialize registers\ninitial begin\n    for (int i = 0; i < RX_MEM_DEPTH; i++) begin\n        ram[i] = 32'd0;\n    end\n    adr_i = {RX_MEM_ADR_SIZE{1'b0}};\n    adr_o = {RX_MEM_ADR_SIZE{1'b0}};\n    we = 8'h1;\n    tmp = 32'd0;\n    ft = 1'b0;\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        // Reset write address and temporary storage\n        adr_i <= {RX_MEM_ADR_SIZE{1'b0}};\n        tmp <= 32'd0;\n        ft <= 1'b0;\n    end else if (wr) begin\n        // Write data to temporary storage\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1'b1;\n        \n        // Write data to RAM when 32-bit word is accumulated\n        if (ft == 4'd8) begin\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1'b1;\n            tmp <= 32'd0;\n            ft <= 1'b0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        // Reset read address\n        adr_o <= {RX_MEM_ADR_SIZE{1'b0}};\n    end else if (rd && !empty) begin\n        // Read data from RAM\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1'b1;\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i == adr_o) && (adr_i != {RX_MEM_ADR_SIZE{1'b0}});\nassign empty = (adr_i == adr_o) && (adr_i == {RX_MEM_ADR_SIZE{1'b0}});\n\n// Memory empty space\nassign mem_empt = RX_MEM_DEPTH - adr_i;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input  wire [3:0] d,\n    input  wire       wr,\n    input  wire       wclk,\n    output wire [31:0] q,\n    input  wire       rd,\n    output wire       full,\n    output wire       empty,\n    output wire [1:0] mem_empt,\n    input  wire       rclk,\n    input  wire       rst\n);\n\n// Define parameters\nparameter MEM_DEPTH = FIFO_RX_MEM_DEPTH;\nparameter MEM_ADR_SIZE = FIFO_RX_MEM_ADR_SIZE;\n\n// Define internal signals\nreg [31:0] ram [MEM_DEPTH-1:0];\nreg [MEM_ADR_SIZE-1:0] adr_i;\nreg [MEM_ADR_SIZE-1:0] adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\n// Define internal wires\nwire [31:0] data_out;\n\n// Reset logic\nalways @(posedge rst or negedge wclk) begin\n    if (rst) begin\n        adr_i <= 0;\n        adr_o <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (~wclk) begin\n        // No action on falling edge of wclk\n    end\nend\n\n// Write logic\nalways @(posedge wclk) begin\n    if (wr) begin\n        // Accumulate 4-bit data in tmp register\n        tmp <= {tmp[27:0], d};\n        // Update write enable signal\n        we <= we << 4;\n        // Check if a full 32-bit word is accumulated\n        if (we[7]) begin\n            // Write data to RAM\n            ram[adr_i] <= tmp;\n            // Increment write address\n            adr_i <= adr_i + 1;\n            // Reset tmp and we\n            tmp <= 0;\n            we <= 8'h1;\n            // Set data written flag\n            ft <= 1;\n        end\n    end\nend\n\n// Read logic\nalways @(posedge rclk) begin\n    if (rd) begin\n        // Check if FIFO is not empty\n        if (~empty) begin\n            // Read data from RAM\n            data_out <= ram[adr_o];\n            // Increment read address\n            adr_o <= adr_o + 1;\n        end\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i == adr_o) && ft;\nassign empty = (adr_i == adr_o) && ~ft;\n\n// Memory empty space\nassign mem_empt = MEM_DEPTH - (adr_i - adr_o);\n\n// Output assignment\nassign q = data_out;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 20, "code": "// sd_rx_fifo module\nmodule sd_rx_fifo(\n    input  wire [3:0]  d,        // Input data from SD card\n    input  wire        wr,       // Write enable signal (active high)\n    input  wire        wclk,     // Write clock (rising edge active)\n    output wire [31:0] q,        // Output data to host\n    input  wire        rd,       // Read enable signal (active high)\n    output wire        full,     // FIFO full flag (active high)\n    output wire        empty,    // FIFO empty flag (active high)\n    output wire [1:0]  mem_empt, // Memory empty space (in words)\n    input  wire        rclk,     // Read clock (rising edge active)\n    input  wire        rst       // Asynchronous reset (active high)\n);\n\n// Parameters\nparameter FIFO_RX_MEM_DEPTH = 16; // Width of RX Fifo\nparameter FIFO_RX_MEM_ADR_SIZE = $clog2(FIFO_RX_MEM_DEPTH) + 1; // log2(FIFO_RX_MEM_DEPTH) + 1\n\n// Registers\nreg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0]; // FIFO storage array\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i; // Write address\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o; // Read address\nreg [7:0] we; // Byte-wise write enable\nreg [31:0] tmp; // Temporary storage\nreg ft; // Data written flag\n\n// Combinational logic\nassign full = (adr_i == adr_o) && ft;\nassign empty = (adr_i == adr_o) && !ft;\nassign mem_empt = (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) % FIFO_RX_MEM_DEPTH;\n\n// Sequential logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n        we <= 8'h1;\n    end else if (wr) begin\n        // Write operation\n        if (we == 8'h1) begin\n            ram[adr_i] <= {d, tmp[23:0]};\n            tmp <= 0;\n            ft <= 1;\n            we <= 8'h0;\n            adr_i <= adr_i + 1;\n        end else begin\n            tmp[3:0] <= d;\n            we <= we << 1;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        // Read operation\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 1, "code": "// Include the sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire            wclk,        // Write clock\n    input  wire            rclk,        // Read clock\n    input  wire            rst,         // Asynchronous active-high reset\n    input  wire    [31:0]  d,           // Data input\n    input  wire            wr,          // Write enable (active high)\n    output wire    [31:0]  q,           // Data output\n    input  wire            rd,          // Read enable (active high)\n    output wire            full,        // FIFO full flag (active high)\n    output wire            empty,       // FIFO empty flag (active high)\n    output wire    [5:0]   mem_empt     // FIFO occupancy\n);\n\n// Define the FIFO memory\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Define the write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Define the write and read enable signals\nreg wr_en, rd_en;\n\n// Define the full and empty flags\nreg full_flag, empty_flag;\n\n// Define the FIFO occupancy\nreg [5:0] occupancy;\n\n// Asynchronous reset\nalways @(posedge rst) begin\n    adr_i <= 0;\n    adr_o <= 0;\n    full_flag <= 0;\n    empty_flag <= 1;\n    occupancy <= 0;\nend\n\n// Write operation\nalways @(posedge wclk) begin\n    if (wr_en) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i + 1) % FIFO_TX_MEM_DEPTH;\n        if (adr_i == FIFO_TX_MEM_DEPTH - 1) begin\n            full_flag <= 1;\n        end else begin\n            full_flag <= 0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk) begin\n    if (rd_en) begin\n        q <= ram[adr_o];\n        adr_o <= (adr_o + 1) % FIFO_TX_MEM_DEPTH;\n        if (adr_o == FIFO_TX_MEM_DEPTH - 1) begin\n            empty_flag <= 1;\n        end else begin\n            empty_flag <= 0;\n        end\n    end\nend\n\n// Write enable\nalways @(posedge wclk) begin\n    if (~full_flag && wr) begin\n        wr_en <= 1;\n    end else begin\n        wr_en <= 0;\n    end\nend\n\n// Read enable\nalways @(posedge rclk) begin\n    if (~empty_flag && rd) begin\n        rd_en <= 1;\n    end else begin\n        rd_en <= 0;\n    end\nend\n\n// FIFO occupancy\nalways @(posedge wclk or posedge rclk) begin\n    if (adr_i >= adr_o) begin\n        occupancy <= adr_i - adr_o;\n    end else begin\n        occupancy <= FIFO_TX_MEM_DEPTH - adr_o + adr_i;\n    end\nend\n\n// Assign outputs\nassign full = full_flag;\nassign empty = empty_flag;\nassign mem_empt = occupancy;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 2, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\n// Define the sd_tx_fifo module\nmodule sd_tx_fifo(\n    // Input signals\n    input wire [31:0] d,      // Data input\n    input wire         wr,    // Write enable (active high)\n    input wire         wclk,  // Write clock (rising edge active)\n    input wire         rd,    // Read enable (active high)\n    input wire         rclk,  // Read clock (rising edge active)\n    input wire         rst,   // Asynchronous reset (active high)\n\n    // Output signals\n    output wire [31:0] q,     // Data output\n    output wire         full, // FIFO full flag (active high)\n    output wire         empty,// FIFO empty flag (active high)\n    output wire [5:0]  mem_empt// FIFO occupancy\n);\n\n// Define the FIFO storage array\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Define the write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Define the write and read enable flags\nreg wr_en, rd_en;\n\n// Initialize the FIFO storage array and address pointers\ninitial begin\n    for (int i = 0; i < FIFO_TX_MEM_DEPTH; i++) begin\n        ram[i] <= 32'd0;\n    end\n    adr_i <= {FIFO_TX_MEM_ADR_SIZE{1'b0}};\n    adr_o <= {FIFO_TX_MEM_ADR_SIZE{1'b0}};\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        // Reset the write address pointer and FIFO storage array\n        adr_i <= {FIFO_TX_MEM_ADR_SIZE{1'b0}};\n        for (int i = 0; i < FIFO_TX_MEM_DEPTH; i++) begin\n            ram[i] <= 32'd0;\n        end\n    end else if (wr_en) begin\n        // Write data to the FIFO storage array\n        ram[adr_i] <= d;\n        // Increment the write address pointer\n        if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n            adr_i <= {FIFO_TX_MEM_ADR_SIZE{1'b0}};\n        end else begin\n            adr_i <= adr_i + 1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        // Reset the read address pointer\n        adr_o <= {FIFO_TX_MEM_ADR_SIZE{1'b0}};\n    end else if (rd_en) begin\n        // Read data from the FIFO storage array\n        q <= ram[adr_o];\n        // Increment the read address pointer\n        if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n            adr_o <= {FIFO_TX_MEM_ADR_SIZE{1'b0}};\n        end else begin\n            adr_o <= adr_o + 1;\n        end\n    end\nend\n\n// Write enable logic\nalways @(*) begin\n    if (rst) begin\n        wr_en <= 1'b0;\n    end else if (wr && !full) begin\n        wr_en <= 1'b1;\n    end else begin\n        wr_en <= 1'b0;\n    end\nend\n\n// Read enable logic\nalways @(*) begin\n    if (rst) begin\n        rd_en <= 1'b0;\n    end else if (rd && !empty) begin\n        rd_en <= 1'b1;\n    end else begin\n        rd_en <= 1'b0;\n    end\nend\n\n// FIFO full flag logic\nalways @(*) begin\n    if (rst) begin\n        full <= 1'b0;\n    end else if (adr_i == adr_o && wr_en) begin\n        full <= 1'b1;\n    end else begin\n        full <= 1'b0;\n    end\nend\n\n// FIFO empty flag logic\nalways @(*) begin\n    if (rst) begin\n        empty <= 1'b1;\n    end else if (adr_i == adr_o && !wr_en) begin\n        empty <= 1'b1;\n    end else begin\n        empty <= 1'b0;\n    end\nend\n\n// FIFO occupancy logic\nalways @(*) begin\n    if (rst) begin\n        mem_empt <= 6'd0;\n    end else if (adr_i > adr_o) begin\n        mem_empt <= adr_i - adr_o;\n    end else if (adr_i < adr_o) begin\n        mem_empt <= FIFO_TX_MEM_DEPTH - (adr_o - adr_i);\n    end else begin\n        mem_empt <= 6'd0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire            wclk,        // Write clock\n    input  wire            rclk,        // Read clock\n    input  wire            rst,         // Asynchronous active-high reset\n    input  wire    [31:0]  d,           // Data input\n    input  wire            wr,          // Write enable (active high)\n    input  wire            rd,          // Read enable (active high)\n    output wire    [31:0]  q,           // Data output\n    output wire            full,        // FIFO full flag (active high)\n    output wire            empty,       // FIFO empty flag (active high)\n    output wire    [5:0]   mem_empt     // FIFO occupancy\n);\n\n// Define parameters\nparameter   FIFO_TX_MEM_DEPTH  = 64;  // Width of TX Fifo\nparameter   FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1;  // log2(FIFO_TX_MEM_DEPTH) + 1\n\n// Define signals\nreg     [31:0]  ram [FIFO_TX_MEM_DEPTH-1:0];  // FIFO storage array\nreg     [FIFO_TX_MEM_ADR_SIZE-1:0]  adr_i;  // Write address\nreg     [FIFO_TX_MEM_ADR_SIZE-1:0]  adr_o;  // Read address\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n            adr_i <= 0;\n        end else begin\n            adr_i <= adr_i + 1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n            adr_o <= 0;\n        end else begin\n            adr_o <= adr_o + 1;\n        end\n    end\nend\n\n// Status update\nalways @(*) begin\n    full  = (adr_i == adr_o) && (ram[adr_i] != 0);\n    empty = (adr_i == adr_o) && (ram[adr_i] == 0);\n    mem_empt = (adr_i - adr_o) % FIFO_TX_MEM_DEPTH;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 4, "code": "// sd_tx_fifo module\nmodule sd_tx_fifo(\n    input  wire        d,          // Data input\n    input  wire        wr,         // Write enable (active high)\n    input  wire        wclk,       // Write clock (rising edge active)\n    output wire [31:0] q,          // Data output\n    input  wire        rd,         // Read enable (active high)\n    output wire        full,       // FIFO full flag (active high)\n    output wire        empty,      // FIFO empty flag (active high)\n    output wire [5:0]  mem_empt,   // FIFO occupancy\n    input  wire        rclk,       // Read clock (rising edge active)\n    input  wire        rst         // Asynchronous reset (active high)\n);\n\n// Parameters\nparameter FIFO_TX_MEM_DEPTH = 64; // Width of TX Fifo\nparameter FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1; // $\"log_2{FIFO_TX_MEM_DEPTH}$ +1\n\n// Internal signals\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0]; // FIFO storage array\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i; // Write address\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o; // Read address\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i == (adr_o == 0 ? FIFO_TX_MEM_DEPTH-1 : adr_o-1));\nassign empty = (adr_i == adr_o);\n\n// FIFO occupancy\nassign mem_empt = (adr_i >= adr_o) ? adr_i - adr_o : FIFO_TX_MEM_DEPTH - adr_o + adr_i;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 5, "code": "// Include the sd_defines.v file for global variables and macro definitions\n`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire            wclk,      // Write clock\n    input  wire            rclk,      // Read clock\n    input  wire            rst,       // Asynchronous active-high reset\n    input  wire    [31:0]  d,         // Data input\n    input  wire            wr,        // Write enable (active high)\n    output wire    [31:0]  q,         // Data output\n    input  wire            rd,        // Read enable (active high)\n    output wire            full,      // FIFO full flag (active high)\n    output wire            empty,     // FIFO empty flag (active high)\n    output wire    [5:0]   mem_empt   // FIFO occupancy\n);\n\n// Define the FIFO storage array\nreg [31:0] ram[FIFO_TX_MEM_DEPTH-1:0];\n\n// Define the write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Define the FIFO full and empty flags\nreg full_reg, empty_reg;\n\n// Define the FIFO occupancy\nreg [5:0] mem_empt_reg;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full_reg <= 0;\n    end else if (wr && !full_reg) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == (FIFO_TX_MEM_DEPTH-1)) ? 0 : adr_i + 1;\n        if (adr_i == (FIFO_TX_MEM_DEPTH-1)) begin\n            full_reg <= 1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty_reg <= 1;\n    end else if (rd && !empty_reg) begin\n        q <= ram[adr_o];\n        adr_o <= (adr_o == (FIFO_TX_MEM_DEPTH-1)) ? 0 : adr_o + 1;\n        if (adr_o == (FIFO_TX_MEM_DEPTH-1)) begin\n            empty_reg <= 1;\n        end\n    end\nend\n\n// Update FIFO full and empty flags\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full_reg <= 0;\n        empty_reg <= 1;\n    end else if (adr_i == adr_o) begin\n        empty_reg <= 1;\n        full_reg <= 0;\n    end else if (adr_i == (FIFO_TX_MEM_DEPTH-1) && adr_o == 0) begin\n        full_reg <= 1;\n        empty_reg <= 0;\n    end\nend\n\n// Update FIFO occupancy\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        mem_empt_reg <= 0;\n    end else if (adr_i == adr_o) begin\n        mem_empt_reg <= 0;\n    end else if (adr_i > adr_o) begin\n        mem_empt_reg <= adr_i - adr_o;\n    end else begin\n        mem_empt_reg <= FIFO_TX_MEM_DEPTH - (adr_o - adr_i);\n    end\nend\n\n// Assign outputs\nassign full = full_reg;\nassign empty = empty_reg;\nassign mem_empt = mem_empt_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire        d          [31:0],  // Data input\n    input  wire        wr         [0:0],   // Write enable (active high)\n    input  wire        wclk       [0:0],   // Write clock (rising edge active)\n    output wire [31:0] q          [31:0],  // Data output\n    input  wire        rd         [0:0],   // Read enable (active high)\n    output wire        full       [0:0],   // FIFO full flag (active high)\n    output wire        empty      [0:0],   // FIFO empty flag (active high)\n    output wire [5:0]  mem_empt   [5:0],   // FIFO occupancy\n    input  wire        rclk       [0:0],   // Read clock (rising edge active)\n    input  wire        rst        [0:0]    // Asynchronous reset (active high)\n);\n\n// Define the FIFO depth and address width\nlocalparam FIFO_TX_MEM_DEPTH = `FIFO_TX_MEM_DEPTH;\nlocalparam FIFO_TX_MEM_ADR_SIZE = `FIFO_TX_MEM_ADR_SIZE;\n\n// Define the RAM storage array\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Define the write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n\n// Define the FIFO full and empty flags\nreg full_flag;\nreg empty_flag;\n\n// Define the FIFO occupancy\nreg [5:0] occupancy;\n\n// Write operation\nalways @(posedge wclk) begin\n    if (rst) begin\n        // Reset the write address pointer and FIFO full flag\n        adr_i <= 0;\n        full_flag <= 0;\n    end else if (wr && !full_flag) begin\n        // Write data to the RAM location pointed to by the current write pointer\n        ram[adr_i] <= d;\n        // Increment the write address pointer\n        if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n            adr_i <= 0;\n        end else begin\n            adr_i <= adr_i + 1;\n        end\n        // Update the FIFO full flag\n        if (adr_i == adr_o) begin\n            full_flag <= 1;\n        end else begin\n            full_flag <= 0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk) begin\n    if (rst) begin\n        // Reset the read address pointer and FIFO empty flag\n        adr_o <= 0;\n        empty_flag <= 1;\n    end else if (rd && !empty_flag) begin\n        // Read data from the RAM location pointed to by the current read pointer\n        q <= ram[adr_o];\n        // Increment the read address pointer\n        if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n            adr_o <= 0;\n        end else begin\n            adr_o <= adr_o + 1;\n        end\n        // Update the FIFO empty flag\n        if (adr_o == adr_i) begin\n            empty_flag <= 1;\n        end else begin\n            empty_flag <= 0;\n        end\n    end\nend\n\n// Update the FIFO occupancy\nalways @(*) begin\n    if (adr_i >= adr_o) begin\n        occupancy = adr_i - adr_o;\n    end else begin\n        occupancy = FIFO_TX_MEM_DEPTH - adr_o + adr_i;\n    end\nend\n\n// Assign the output signals\nassign full = full_flag;\nassign empty = empty_flag;\nassign mem_empt = occupancy;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 7, "code": "// sd_tx_fifo module\nmodule sd_tx_fifo(\n    input  wire            wclk,  // Write clock\n    input  wire            rclk,  // Read clock\n    input  wire            rst,   // Asynchronous active-high reset\n    input  wire    [31:0]  d,     // Data input\n    input  wire            wr,    // Write enable (active high)\n    input  wire            rd,    // Read enable (active high)\n    output wire    [31:0]  q,     // Data output\n    output wire            full,  // FIFO full flag (active high)\n    output wire            empty, // FIFO empty flag (active high)\n    output wire     [5:0]  mem_empt // FIFO occupancy\n);\n\n// Define parameters\nparameter FIFO_TX_MEM_DEPTH = 64; // Width of TX Fifo\nparameter FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH); // log2(FIFO_TX_MEM_DEPTH)\n\n// Define internal signals\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0]; // FIFO storage array\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i; // Write address\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o; // Read address\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n    end\nend\n\n// Full and empty flag generation\nassign full = (adr_i == adr_o) && (mem_empt == FIFO_TX_MEM_DEPTH-1);\nassign empty = (adr_i == adr_o) && (mem_empt == 0);\n\n// FIFO occupancy calculation\nassign mem_empt = (adr_i > adr_o) ? adr_i - adr_o : FIFO_TX_MEM_DEPTH - (adr_o - adr_i);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 8, "code": "// sd_tx_fifo.v\n`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire            wclk,        // Write clock\n    input  wire            rclk,        // Read clock\n    input  wire            rst,         // Asynchronous active-high reset\n    input  wire    [31:0]  d,           // Data input\n    input  wire            wr,          // Write enable (active high)\n    output wire    [31:0]  q,           // Data output\n    input  wire            rd,          // Read enable (active high)\n    output wire            full,        // FIFO full flag (active high)\n    output wire            empty,       // FIFO empty flag (active high)\n    output wire    [5:0]   mem_empt     // FIFO occupancy\n);\n\n// FIFO storage array\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Write address\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n\n// Read address\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n            adr_i <= 0;\n        end else begin\n            adr_i <= adr_i + 1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n            adr_o <= 0;\n        end else begin\n            adr_o <= adr_o + 1;\n        end\n    end\nend\n\n// FIFO full status\nassign full = (adr_i == adr_o) && (mem_empt == FIFO_TX_MEM_DEPTH);\n\n// FIFO empty status\nassign empty = (adr_i == adr_o) && (mem_empt == 0);\n\n// FIFO occupancy\nassign mem_empt = (adr_i >= adr_o) ? (adr_i - adr_o) : (FIFO_TX_MEM_DEPTH - adr_o + adr_i);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 9, "code": "// Include the sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire        d,          // Data input\n    input  wire        wr,         // Write enable (active high)\n    input  wire        wclk,       // Write clock (rising edge active)\n    output wire [31:0] q,          // Data output\n    input  wire        rd,         // Read enable (active high)\n    output wire        full,       // FIFO full flag (active high)\n    output wire        empty,      // FIFO empty flag (active high)\n    output wire [5:0]  mem_empt,   // FIFO occupancy\n    input  wire        rclk,       // Read clock (rising edge active)\n    input  wire        rst         // Asynchronous reset (active high)\n);\n\n// Define the FIFO storage array\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Define the write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Define the write and read enable signals\nreg wr_en, rd_en;\n\n// Define the FIFO full and empty flags\nreg full_flag, empty_flag;\n\n// Define the FIFO occupancy\nreg [5:0] occupancy;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        // Reset the write address pointer and FIFO full flag\n        adr_i <= 0;\n        full_flag <= 0;\n    end else if (wr_en) begin\n        // Write data to the RAM location pointed to by the current write pointer\n        ram[adr_i] <= d;\n        // Increment the write address pointer\n        if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n            adr_i <= 0;\n        end else begin\n            adr_i <= adr_i + 1;\n        end\n        // Update the FIFO full flag\n        if (adr_i == adr_o) begin\n            full_flag <= 1;\n        end else begin\n            full_flag <= 0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        // Reset the read address pointer and FIFO empty flag\n        adr_o <= 0;\n        empty_flag <= 1;\n    end else if (rd_en) begin\n        // Read data from the RAM location pointed to by the current read pointer\n        q <= ram[adr_o];\n        // Increment the read address pointer\n        if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n            adr_o <= 0;\n        end else begin\n            adr_o <= adr_o + 1;\n        end\n        // Update the FIFO empty flag\n        if (adr_o == adr_i) begin\n            empty_flag <= 1;\n        end else begin\n            empty_flag <= 0;\n        end\n    end\nend\n\n// Write enable signal generation\nalways @(posedge wclk) begin\n    if (wr && !full_flag) begin\n        wr_en <= 1;\n    end else begin\n        wr_en <= 0;\n    end\nend\n\n// Read enable signal generation\nalways @(posedge rclk) begin\n    if (rd && !empty_flag) begin\n        rd_en <= 1;\n    end else begin\n        rd_en <= 0;\n    end\nend\n\n// FIFO occupancy calculation\nalways @(posedge wclk or posedge rclk) begin\n    if (adr_i >= adr_o) begin\n        occupancy <= adr_i - adr_o;\n    end else begin\n        occupancy <= FIFO_TX_MEM_DEPTH - (adr_o - adr_i);\n    end\nend\n\n// Assign output signals\nassign full = full_flag;\nassign empty = empty_flag;\nassign mem_empt = occupancy;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 10, "code": "// Include the sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire        d,          // Data input\n    input  wire        wr,         // Write enable\n    input  wire        wclk,       // Write clock\n    output wire [31:0] q,          // Data output\n    input  wire        rd,         // Read enable\n    output wire        full,       // FIFO full flag\n    output wire        empty,      // FIFO empty flag\n    output wire [5:0]  mem_empt,   // FIFO occupancy\n    input  wire        rclk,       // Read clock\n    input  wire        rst         // Asynchronous reset\n);\n\n// Define the FIFO memory\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Define the write and read pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Define the internal full and empty flags\nreg full_int, empty_int;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full_int <= 0;\n    end else if (wr && !full_int) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\n        if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n            full_int <= 1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty_int <= 1;\n    end else if (rd && !empty_int) begin\n        q <= ram[adr_o];\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n        if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n            empty_int <= 1;\n        end\n    end\nend\n\n// Status update\nalways @(*) begin\n    full <= full_int;\n    empty <= empty_int;\n    mem_empt <= (adr_i - adr_o) % FIFO_TX_MEM_DEPTH;\nend\n\n// Reset logic\nalways @(posedge rst) begin\n    adr_i <= 0;\n    adr_o <= 0;\n    full_int <= 0;\n    empty_int <= 1;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 11, "code": "// Include sd_defines.v for global variables and macro definitions\n`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire            wclk,  // Write clock\n    input  wire            rclk,  // Read clock\n    input  wire            rst,   // Asynchronous active-high reset\n    input  wire    [31:0]  d,     // Data input\n    input  wire            wr,    // Write enable (active high)\n    output wire    [31:0]  q,     // Data output\n    input  wire            rd,    // Read enable (active high)\n    output wire            full,  // FIFO full flag (active high)\n    output wire            empty, // FIFO empty flag (active high)\n    output wire     [5:0]  mem_empt // FIFO occupancy\n);\n\n// Define parameters for FIFO depth and address width\nparameter FIFO_TX_MEM_DEPTH = 64; // Width of TX Fifo\nparameter FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1; // log2(FIFO_TX_MEM_DEPTH) + 1\n\n// Define internal signals\nreg [31:0] ram [FIFO_TX_MEM_DEPTH - 1:0]; // FIFO storage array\nreg [FIFO_TX_MEM_ADR_SIZE - 1:0] adr_i; // Write address\nreg [FIFO_TX_MEM_ADR_SIZE - 1:0] adr_o; // Read address\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == FIFO_TX_MEM_DEPTH - 1) ? 0 : adr_i + 1;\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH - 1) ? 0 : adr_o + 1;\n    end\nend\n\n// FIFO full and empty status\nassign full = (adr_i == adr_o) && (mem_empt == FIFO_TX_MEM_DEPTH - 1);\nassign empty = (adr_i == adr_o) && (mem_empt == 0);\n\n// FIFO occupancy\nassign mem_empt = (adr_i > adr_o) ? adr_i - adr_o : FIFO_TX_MEM_DEPTH - adr_o + adr_i;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire                d,          // Data input\n    input  wire                wr,         // Write enable (active high)\n    input  wire                wclk,       // Write clock (rising edge active)\n    output wire [31:0]         q,          // Data output\n    input  wire                rd,         // Read enable (active high)\n    output wire                full,       // FIFO full flag (active high)\n    output wire                empty,      // FIFO empty flag (active high)\n    output wire [5:0]          mem_empt,   // FIFO occupancy\n    input  wire                rclk,       // Read clock (rising edge active)\n    input  wire                rst         // Asynchronous reset (active high)\n);\n\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;  // Write address\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;  // Read address\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];  // FIFO storage array\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        if (adr_i == FIFO_TX_MEM_DEPTH - 1) begin\n            adr_i <= 0;\n        end else begin\n            adr_i <= adr_i + 1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        if (adr_o == FIFO_TX_MEM_DEPTH - 1) begin\n            adr_o <= 0;\n        end else begin\n            adr_o <= adr_o + 1;\n        end\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i == adr_o) && (mem_empt == FIFO_TX_MEM_DEPTH);\nassign empty = (adr_i == adr_o) && (mem_empt == 0);\n\n// FIFO occupancy\nassign mem_empt = (adr_i - adr_o) % FIFO_TX_MEM_DEPTH;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 13, "code": "// Include the sd_defines.v file for global variables\n`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire        d,      // Data input\n    input  wire        wr,     // Write enable (active high)\n    input  wire        wclk,   // Write clock (rising edge active)\n    output wire [31:0] q,      // Data output\n    input  wire        rd,     // Read enable (active high)\n    output wire        full,   // FIFO full flag (active high)\n    output wire        empty,  // FIFO empty flag (active high)\n    output wire [5:0]  mem_empt, // FIFO occupancy\n    input  wire        rclk,   // Read clock (rising edge active)\n    input  wire        rst     // Asynchronous reset (active high)\n);\n\n// Define the FIFO storage array\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Define the write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Initialize the FIFO pointers and flags\ninitial begin\n    adr_i = 0;\n    adr_o = 0;\n    full = 0;\n    empty = 1;\n    mem_empt = 0;\nend\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        // Reset the FIFO pointers and flags\n        adr_i <= 0;\n        adr_o <= 0;\n        full <= 0;\n        empty <= 1;\n        mem_empt <= 0;\n    end else if (wr && !full) begin\n        // Write data to the RAM location pointed to by the current write pointer\n        ram[adr_i] <= d;\n        // Increment the write address pointer\n        if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n            adr_i <= 0;\n        end else begin\n            adr_i <= adr_i + 1;\n        end\n        // Update the FIFO full flag\n        if (adr_i == adr_o) begin\n            full <= 1;\n        end\n        // Update the FIFO occupancy\n        mem_empt <= mem_empt + 1;\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        // Reset the FIFO pointers and flags\n        adr_i <= 0;\n        adr_o <= 0;\n        full <= 0;\n        empty <= 1;\n        mem_empt <= 0;\n    end else if (rd && !empty) begin\n        // Read data from the RAM location pointed to by the current read pointer\n        q <= ram[adr_o];\n        // Increment the read address pointer\n        if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n            adr_o <= 0;\n        end else begin\n            adr_o <= adr_o + 1;\n        end\n        // Update the FIFO empty flag\n        if (adr_o == adr_i) begin\n            empty <= 1;\n        end\n        // Update the FIFO occupancy\n        mem_empt <= mem_empt - 1;\n    end\nend\n\n// Update the FIFO full and empty flags\nalways @(posedge wclk or posedge rclk) begin\n    if (adr_i == adr_o) begin\n        if (mem_empt == FIFO_TX_MEM_DEPTH) begin\n            full <= 1;\n        end else begin\n            empty <= 1;\n        end\n    end else begin\n        full <= 0;\n        empty <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire            d,          // Data input\n    input  wire            wr,         // Write enable (active high)\n    input  wire            wclk,       // Write clock (rising edge active)\n    output wire [31:0]     q,          // Data output\n    input  wire            rd,         // Read enable (active high)\n    output wire            full,       // FIFO full flag (active high)\n    output wire            empty,      // FIFO empty flag (active high)\n    output wire [5:0]      mem_empt,   // FIFO occupancy\n    input  wire            rclk,       // Read clock (rising edge active)\n    input  wire            rst         // Asynchronous reset (active high)\n);\n\n// Define parameters\nparameter RAM_MEM_WIDTH = 32;\nparameter FIFO_TX_MEM_DEPTH = 64;\nparameter FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1;\n\n// Define registers\nreg [RAM_MEM_WIDTH-1:0] ram [FIFO_TX_MEM_DEPTH-1:0];\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;  // Write address\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;  // Read address\n\n// Define wires\nwire [RAM_MEM_WIDTH-1:0] data_out;\nwire full_flag;\nwire empty_flag;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full_flag) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == FIFO_TX_MEM_DEPTH - 1) ? 0 : adr_i + 1;\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty_flag) begin\n        q <= ram[adr_o];\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH - 1) ? 0 : adr_o + 1;\n    end\nend\n\n// Status update\nassign full_flag = (adr_i == adr_o) && (ram[adr_i] != 0);\nassign empty_flag = (adr_i == adr_o) && (ram[adr_i] == 0);\nassign mem_empt = (adr_i > adr_o) ? adr_i - adr_o : FIFO_TX_MEM_DEPTH - adr_o + adr_i;\n\n// Output assignments\nassign full = full_flag;\nassign empty = empty_flag;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire        d,          // Data input\n    input  wire        wr,         // Write enable (active high)\n    input  wire        wclk,       // Write clock (rising edge active)\n    output wire [31:0] q,          // Data output\n    input  wire        rd,         // Read enable (active high)\n    output wire        full,       // FIFO full flag (active high)\n    output wire        empty,      // FIFO empty flag (active high)\n    output wire [5:0]  mem_empt,   // FIFO occupancy\n    input  wire        rclk,       // Read clock (rising edge active)\n    input  wire        rst         // Asynchronous reset (active high)\n);\n\n// Define parameters\nparameter RAM_MEM_WIDTH = 32;\nparameter FIFO_TX_MEM_DEPTH = 64;\nparameter FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1;\n\n// Define signals\nreg [RAM_MEM_WIDTH-1:0] ram [FIFO_TX_MEM_DEPTH-1:0]; // FIFO storage array\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i; // Write address\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o; // Read address\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == (FIFO_TX_MEM_DEPTH-1)) ? 0 : (adr_i + 1);\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= (adr_o == (FIFO_TX_MEM_DEPTH-1)) ? 0 : (adr_o + 1);\n    end\nend\n\n// Status update\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n        empty <= 1;\n        mem_empt <= 0;\n    end else begin\n        full <= (adr_i == (adr_o + 1) % FIFO_TX_MEM_DEPTH);\n        empty <= (adr_i == adr_o);\n        mem_empt <= (adr_i - adr_o) % FIFO_TX_MEM_DEPTH;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 16, "code": "// Include sd_defines.v for global variables and macro definitions\n`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    // Input signals\n    input  wire            d,          // Data input\n    input  wire            wr,         // Write enable (active high)\n    input  wire            wclk,       // Write clock (rising edge active)\n    input  wire            rd,         // Read enable (active high)\n    input  wire            rclk,       // Read clock (rising edge active)\n    input  wire            rst,        // Asynchronous active-high reset\n\n    // Output signals\n    output reg     [31:0]  q,          // Data output\n    output reg             full,       // FIFO full flag (active high)\n    output reg             empty,      // FIFO empty flag (active high)\n    output reg     [5:0]   mem_empt    // FIFO occupancy\n);\n\n// Define the FIFO memory\nreg [31:0] ram[FIFO_TX_MEM_DEPTH-1:0];\n\n// Define the write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n\n// Define the write and read enable signals\nreg             wr_en;\nreg             rd_en;\n\n// Define the FIFO full and empty flags\nreg             full_flag;\nreg             empty_flag;\n\n// Define the FIFO occupancy\nreg     [5:0]   occupancy;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        // Reset the write address pointer and FIFO full flag\n        adr_i <= 0;\n        full_flag <= 0;\n    end else if (wr_en) begin\n        // Write data to the FIFO memory\n        ram[adr_i] <= d;\n        // Increment the write address pointer\n        if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n            adr_i <= 0;\n        end else begin\n            adr_i <= adr_i + 1;\n        end\n        // Update the FIFO full flag\n        if (adr_i == adr_o) begin\n            full_flag <= 1;\n        end else begin\n            full_flag <= 0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        // Reset the read address pointer and FIFO empty flag\n        adr_o <= 0;\n        empty_flag <= 1;\n    end else if (rd_en) begin\n        // Read data from the FIFO memory\n        q <= ram[adr_o];\n        // Increment the read address pointer\n        if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n            adr_o <= 0;\n        end else begin\n            adr_o <= adr_o + 1;\n        end\n        // Update the FIFO empty flag\n        if (adr_o == adr_i) begin\n            empty_flag <= 1;\n        end else begin\n            empty_flag <= 0;\n        end\n    end\nend\n\n// Write enable signal\nalways @(posedge wclk) begin\n    if (wr && !full_flag) begin\n        wr_en <= 1;\n    end else begin\n        wr_en <= 0;\n    end\nend\n\n// Read enable signal\nalways @(posedge rclk) begin\n    if (rd && !empty_flag) begin\n        rd_en <= 1;\n    end else begin\n        rd_en <= 0;\n    end\nend\n\n// FIFO full flag\nassign full = full_flag;\n\n// FIFO empty flag\nassign empty = empty_flag;\n\n// FIFO occupancy\nassign mem_empt = occupancy;\n\n// Update the FIFO occupancy\nalways @(posedge wclk or posedge rclk) begin\n    if (adr_i >= adr_o) begin\n        occupancy <= adr_i - adr_o;\n    end else begin\n        occupancy <= FIFO_TX_MEM_DEPTH - (adr_o - adr_i);\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 17, "code": "// Include sd_defines.v for global variables\n`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire            wclk,       // Write clock\n    input  wire            rclk,       // Read clock\n    input  wire            rst,        // Asynchronous active-high reset\n    input  wire    [31:0]  d,          // Data input\n    input  wire            wr,         // Write enable (active high)\n    output wire    [31:0]  q,          // Data output\n    input  wire            rd,         // Read enable (active high)\n    output wire            full,       // FIFO full flag (active high)\n    output wire            empty,      // FIFO empty flag (active high)\n    output wire    [5:0]   mem_empt    // FIFO occupancy\n);\n\n// Define parameters for FIFO depth and address width\nparameter FIFO_TX_MEM_DEPTH = 64;  // Width of TX Fifo\nparameter FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1;  // log2(FIFO_TX_MEM_DEPTH) + 1\n\n// Define registers for FIFO storage array, write address, and read address\nreg [31:0] ram [FIFO_TX_MEM_DEPTH - 1:0];  // FIFO storage array\nreg [FIFO_TX_MEM_ADR_SIZE - 1:0] adr_i;  // Write address\nreg [FIFO_TX_MEM_ADR_SIZE - 1:0] adr_o;  // Read address\n\n// Define internal wires for full and empty flags\nwire full_int;\nwire empty_int;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        // Reset write address and FIFO storage array\n        adr_i <= 0;\n        for (int i = 0; i < FIFO_TX_MEM_DEPTH; i++) begin\n            ram[i] <= 0;\n        end\n    end else if (wr && !full_int) begin\n        // Write data to FIFO storage array\n        ram[adr_i] <= d;\n        // Increment write address\n        adr_i <= (adr_i == (FIFO_TX_MEM_DEPTH - 1)) ? 0 : adr_i + 1;\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        // Reset read address\n        adr_o <= 0;\n    end else if (rd && !empty_int) begin\n        // Read data from FIFO storage array\n        q <= ram[adr_o];\n        // Increment read address\n        adr_o <= (adr_o == (FIFO_TX_MEM_DEPTH - 1)) ? 0 : adr_o + 1;\n    end\nend\n\n// Full and empty flag generation\nassign full_int = (adr_i == (adr_o - 1)) || ((adr_i == (FIFO_TX_MEM_DEPTH - 1)) && (adr_o == 0));\nassign empty_int = (adr_i == adr_o);\nassign full = full_int;\nassign empty = empty_int;\n\n// FIFO occupancy calculation\nassign mem_empt = (adr_i >= adr_o) ? adr_i - adr_o : FIFO_TX_MEM_DEPTH - (adr_o - adr_i);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire                d,          // Data input\n    input  wire                wr,         // Write enable (active high)\n    input  wire                wclk,       // Write clock (rising edge active)\n    output wire [31:0]         q,          // Data output\n    input  wire                rd,         // Read enable (active high)\n    output wire                full,       // FIFO full flag (active high)\n    output wire                empty,      // FIFO empty flag (active high)\n    output wire [5:0]          mem_empt,   // FIFO occupancy\n    input  wire                rclk,       // Read clock (rising edge active)\n    input  wire                rst         // Asynchronous reset (active high)\n);\n\n// Internal signals\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];  // FIFO storage array\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;    // Write address\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;    // Read address\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == (FIFO_TX_MEM_DEPTH-1)) ? 0 : (adr_i + 1);\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= (adr_o == (FIFO_TX_MEM_DEPTH-1)) ? 0 : (adr_o + 1);\n    end\nend\n\n// Full and empty flags\nassign full = (adr_i == (adr_o - 1)) || (adr_o == 0 && adr_i == (FIFO_TX_MEM_DEPTH-1));\nassign empty = (adr_i == adr_o);\n\n// FIFO occupancy\nassign mem_empt = (adr_i >= adr_o) ? (adr_i - adr_o) : (FIFO_TX_MEM_DEPTH - adr_o + adr_i);\n\n// Reset logic\nalways @(posedge rst) begin\n    adr_i <= 0;\n    adr_o <= 0;\n    full <= 0;\n    empty <= 1;\n    mem_empt <= 0;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire        d          [31:0], // Data input\n    input  wire        wr         [0:0], // Write enable (active high)\n    input  wire        wclk       [0:0], // Write clock (rising edge active)\n    output wire [31:0] q          , // Data output\n    input  wire        rd         [0:0], // Read enable (active high)\n    output wire [0:0]  full       , // FIFO full flag (active high)\n    output wire [0:0]  empty      , // FIFO empty flag (active high)\n    output wire [5:0]  mem_empt   , // FIFO occupancy\n    input  wire        rclk       [0:0], // Read clock (rising edge active)\n    input  wire        rst        [0:0]  // Asynchronous reset (active high)\n);\n\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0]; // FIFO storage array\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i; // Write address\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o; // Read address\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n            adr_i <= 0;\n        end else begin\n            adr_i <= adr_i + 1;\n        end\n        if (adr_i == adr_o) begin\n            full <= 1;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty <= 1;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n            adr_o <= 0;\n        end else begin\n            adr_o <= adr_o + 1;\n        end\n        if (adr_o == adr_i) begin\n            empty <= 1;\n        end else begin\n            empty <= 0;\n        end\n    end\nend\n\nalways @(*) begin\n    if (adr_i == adr_o) begin\n        mem_empt = 0;\n    end else if (adr_i > adr_o) begin\n        mem_empt = adr_i - adr_o;\n    end else begin\n        mem_empt = FIFO_TX_MEM_DEPTH - adr_o + adr_i;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input  wire                d,      // Data input\n    input  wire                wr,     // Write enable (active high)\n    input  wire                wclk,   // Write clock (rising edge active)\n    output wire [31:0]         q,      // Data output\n    input  wire                rd,     // Read enable (active high)\n    output wire                full,   // FIFO full flag (active high)\n    output wire                empty,  // FIFO empty flag (active high)\n    output wire [5:0]          mem_empt,// FIFO occupancy\n    input  wire                rclk,   // Read clock (rising edge active)\n    input  wire                rst     // Asynchronous reset (active high)\n);\n\n// Define parameters\nparameter   FIFO_TX_MEM_DEPTH = 64;   // FIFO depth\nparameter   FIFO_TX_MEM_ADR_SIZE = $clog2(FIFO_TX_MEM_DEPTH) + 1;  // Address width\n\n// Define registers\nreg [31:0]  ram [FIFO_TX_MEM_DEPTH-1:0];  // FIFO storage array\nreg [FIFO_TX_MEM_ADR_SIZE-1:0]  adr_i;    // Write address\nreg [FIFO_TX_MEM_ADR_SIZE-1:0]  adr_o;    // Read address\n\n// Define internal signals\nwire        write_en;    // Write enable internal signal\nwire        read_en;     // Read enable internal signal\nreg         full_int;    // FIFO full internal flag\nreg         empty_int;   // FIFO empty internal flag\n\n// Write enable and read enable logic\nassign write_en = wr & ~full_int;\nassign read_en = rd & ~empty_int;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (write_en) begin\n        ram[adr_i] <= d;\n        if (adr_i == FIFO_TX_MEM_DEPTH-1) begin\n            adr_i <= 0;\n        end else begin\n            adr_i <= adr_i + 1;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (read_en) begin\n        q <= ram[adr_o];\n        if (adr_o == FIFO_TX_MEM_DEPTH-1) begin\n            adr_o <= 0;\n        end else begin\n            adr_o <= adr_o + 1;\n        end\n    end\nend\n\n// FIFO full and empty flag logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        full_int <= 0;\n    end else if (write_en) begin\n        if (adr_i == adr_o && full_int == 1) begin\n            full_int <= 1;\n        end else if (adr_i == adr_o && full_int == 0) begin\n            full_int <= 1;\n        end else begin\n            full_int <= 0;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        empty_int <= 1;\n    end else if (read_en) begin\n        if (adr_i == adr_o && empty_int == 1) begin\n            empty_int <= 1;\n        end else if (adr_i != adr_o) begin\n            empty_int <= 0;\n        end\n    end\nend\n\n// FIFO occupancy logic\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 0;\n    end else begin\n        if (adr_i >= adr_o) begin\n            mem_empt <= adr_i - adr_o;\n        end else begin\n            mem_empt <= FIFO_TX_MEM_DEPTH - adr_o + adr_i;\n        end\n    end\nend\n\n// Output assignments\nassign full = full_int;\nassign empty = empty_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 1, "code": "module sdc_controller(\n    // Wishbone Slave Interface\n    input  wire            wb_clk_i,\n    input  wire            wb_rst_i,\n    input  wire [3:0]      wb_sel_i,\n    input  wire [31:0]     wb_dat_i,\n    output wire [31:0]     wb_dat_o,\n    input  wire [7:0]      wb_adr_i,\n    input  wire            wb_we_i,\n    input  wire            wb_cyc_i,\n    input  wire            wb_stb_i,\n    output wire            wb_ack_o,\n\n    // Master Wishbone Interface\n    output wire [31:0]     m_wb_adr_o,\n    output wire            m_wb_sel_o,\n    output wire            m_wb_we_o,\n    output wire [31:0]     m_wb_dat_o,\n    input  wire [31:0]     m_wb_dat_i,\n    output wire            m_wb_cyc_o,\n    output wire            m_wb_stb_o,\n    input  wire            m_wb_ack_i,\n    output wire            m_wb_cti_o,\n    output wire            m_wb_bte_o,\n\n    // SDC Interface\n    output wire            sd_cmd_out_o,\n    output wire            sd_cmd_oe_o,\n    input  wire            sd_cmd_dat_i,\n    output wire [3:0]      sd_dat_out_o,\n    output wire            sd_dat_oe_o,\n    input  wire [3:0]      sd_dat_dat_i,\n    output wire            sd_clk_o_pad,\n\n    // Interrupts\n    output wire            int_a,\n    output wire            int_b,\n    output wire            int_c,\n\n    // Card Detect\n    input  wire            card_detect\n);\n\n// Internal signals\nwire            we_m_tx_bd;\nwire            we_m_rx_bd;\nwire            new_cmd;\nwire            we_ack;\nwire            int_ack;\nwire            cmd_int_busy;\nwire            int_busy;\nwire            write_req_s;\nwire [15:0]     cmd_set_s;\nwire [31:0]     cmd_arg_s;\nwire [31:0]     argument_reg;\nwire [15:0]     cmd_setting_reg;\nwire [15:0]     status_reg;\nwire [31:0]     cmd_resp_1;\nwire [7:0]      software_reset_reg;\nwire [15:0]     time_out_reg;\nwire [15:0]     normal_int_status_reg;\nwire [15:0]     error_int_status_reg;\nwire [15:0]     normal_int_signal_enable_reg;\nwire [15:0]     error_int_signal_enable_reg;\nwire [7:0]      clock_divider;\nwire [15:0]     Bd_Status_reg;\nwire [7:0]      Bd_isr_reg;\nwire [7:0]      Bd_isr_enable_reg;\nwire            bd_isr_reset;\nwire            normal_isr_reset;\nwire            error_isr_reset;\nwire [31:0]     dat_in_m_tx_bd;\nwire [31:0]     dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(write_req_s),\n    .data_read(~write_req_s),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(),\n    .go_idle_o(),\n    .cmd_out(),\n    .req_out(),\n    .ack_out(),\n    .req_in(),\n    .ack_in(),\n    .cmd_in(),\n    .serial_status(),\n    .card_detect(card_detect)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(sd_clk_o_pad),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(),\n    .CMD_IN(),\n    .REQ_IN(),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(),\n    .REQ_OUT(),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o)\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(),\n    .ack_i_s_tx(),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(),\n    .ack_i_s_rx(),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(),\n    .card_status(),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\nassign m_wb_sel_o = 4'b1111;\n\nassign int_a = normal_int_status_reg[0];\nassign int_b = error_int_status_reg[0];\nassign int_c = Bd_isr_reg[0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 2, "code": "module sdc_controller(\n    input             wb_clk_i,\n    input             wb_rst_i,\n    input      [3:0]  wb_sel_i,\n    input     [31:0]  wb_dat_i,\n    output    [31:0]  wb_dat_o,\n    input      [7:0]  wb_adr_i,\n    input             wb_we_i,\n    input             wb_cyc_i,\n    input             wb_stb_i,\n    output            wb_ack_o,\n    output   [31:0]   m_wb_adr_o,\n    output            m_wb_sel_o,\n    output            m_wb_we_o,\n    output   [31:0]   m_wb_dat_o,\n    input    [31:0]   m_wb_dat_i,\n    output            m_wb_cyc_o,\n    output            m_wb_stb_o,\n    input             m_wb_ack_i,\n    output            m_wb_cti_o,\n    output            m_wb_bte_o,\n    input             card_detect,\n    input             sd_cmd_dat_i,\n    output            sd_cmd_out_o,\n    output            sd_cmd_oe_o,\n    input      [3:0]  sd_dat_dat_i,\n    output     [3:0]  sd_dat_out_o,\n    output            sd_dat_oe_o,\n    output            sd_clk_o_pad,\n    input             sd_clk_i_pad,\n    output            int_a,\n    output            int_b,\n    output            int_c\n);\n\n// sd_controller_wb module instantiation\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(),\n    .cmd_setting_reg(),\n    .status_reg(),\n    .cmd_resp_1(),\n    .software_reset_reg(),\n    .time_out_reg(),\n    .normal_int_status_reg(),\n    .error_int_status_reg(),\n    .normal_int_signal_enable_reg(),\n    .error_int_signal_enable_reg(),\n    .clock_divider(),\n    .Bd_Status_reg(),\n    .Bd_isr_reg(),\n    .Bd_isr_enable_reg(),\n    .bd_isr_reset(),\n    .normal_isr_reset(),\n    .error_isr_reset(),\n    .dat_in_m_tx_bd(),\n    .dat_in_m_rx_bd()\n);\n\n// sd_clock_divider module instantiation\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(),\n    .RST(wb_rst_i),\n    .SD_CLK()\n);\n\n// sd_cmd_master module instantiation\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(),\n    .data_write(),\n    .data_read(),\n    .ARG_REG(),\n    .CMD_SET_REG(),\n    .TIMEOUT_REG(),\n    .STATUS_REG(),\n    .RESP_1_REG(),\n    .ERR_INT_REG(),\n    .NORMAL_INT_REG(),\n    .ERR_INT_RST(),\n    .NORMAL_INT_RST(),\n    .settings(),\n    .go_idle_o(),\n    .cmd_out(),\n    .req_out(),\n    .ack_out(),\n    .req_in(),\n    .ack_in(),\n    .cmd_in(),\n    .serial_status(),\n    .card_detect()\n);\n\n// sd_cmd_serial_host module instantiation\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(),\n    .RST_IN(),\n    .SETTING_IN(),\n    .CMD_IN(),\n    .REQ_IN(),\n    .ACK_IN(),\n    .cmd_dat_i(),\n    .CMD_OUT(),\n    .ACK_OUT(),\n    .REQ_OUT(),\n    .STATUS(),\n    .cmd_oe_o(),\n    .cmd_out_o(),\n    .st_dat_t()\n);\n\n// sd_data_master module instantiation\nsd_data_master u_sd_data_master(\n    .clk(),\n    .rst(),\n    .dat_in_tx(),\n    .free_tx_bd(),\n    .ack_i_s_tx(),\n    .dat_in_rx(),\n    .free_rx_bd(),\n    .ack_i_s_rx(),\n    .cmd_busy(),\n    .we_ack(),\n    .cmd_tsf_err(),\n    .card_status(),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\n// sd_data_serial_host module instantiation\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(),\n    .rst(),\n    .data_in(),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(),\n    .DAT_dat_o(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\n// rx_bd/tx_bd module instantiation\nrx_bd u_rx_bd(\n    .clk(),\n    .rst(),\n    .we_m(),\n    .dat_in_m(),\n    .free_bd(),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\ntx_bd u_tx_bd(\n    .clk(),\n    .rst(),\n    .we_m(),\n    .dat_in_m(),\n    .free_bd(),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\n// sd_fifo_tx_filler module instantiation\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(),\n    .rst(),\n    .m_wb_adr_o(),\n    .m_wb_we_o(),\n    .m_wb_dat_i(),\n    .m_wb_cyc_o(),\n    .m_wb_stb_o(),\n    .m_wb_ack_i(),\n    .m_wb_cti_o(),\n    .m_wb_bte(),\n    .en(),\n    .adr(),\n    .sd_clk(),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\n// sd_fifo_rx_filler module instantiation\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(),\n    .rst(),\n    .m_wb_adr_o(),\n    .m_wb_we_o(),\n    .m_wb_dat_o(),\n    .m_wb_cyc_o(),\n    .m_wb_stb_o(),\n    .m_wb_ack_i(),\n    .m_wb_cti_o(),\n    .m_wb_bte(),\n    .en(),\n    .adr(),\n    .sd_clk(),\n    .dat_i(),\n    .wr(),\n    .full()\n);\n\n// Master Wishbone Interface Control\nassign m_wb_sel_o = 4'b1111;\n\nalways @(*) begin\n    if (start_tx_fifo) begin\n        m_wb_cyc_o = u_sd_fifo_tx_filler.m_wb_cyc_o;\n        m_wb_stb_o = u_sd_fifo_tx_filler.m_wb_stb_o;\n        m_wb_cti_o = u_sd_fifo_tx_filler.m_wb_cti_o;\n        m_wb_bte  = u_sd_fifo_tx_filler.m_wb_bte;\n        m_wb_we_o = u_sd_fifo_tx_filler.m_wb_we_o;\n        m_wb_adr_o = u_sd_fifo_tx_filler.m_wb_adr_o;\n    end else if (start_rx_fifo) begin\n        m_wb_cyc_o = u_sd_fifo_rx_filler.m_wb_cyc_o;\n        m_wb_stb_o = u_sd_fifo_rx_filler.m_wb_stb_o;\n        m_wb_cti_o = u_sd_fifo_rx_filler.m_wb_cti_o;\n        m_wb_bte  = u_sd_fifo_rx_filler.m_wb_bte;\n        m_wb_we_o = u_sd_fifo_rx_filler.m_wb_we_o;\n        m_wb_adr_o = u_sd_fifo_rx_filler.m_wb_adr_o;\n    end else begin\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n        m_wb_cti_o = 3'b000;\n        m_wb_bte  = 2'b00;\n        m_wb_we_o = 1'b0;\n        m_wb_adr_o = 32'b0;\n    end\nend\n\n// Register Update\nalways @(*) begin\n    cmd_int_busy = ;\n    Bd_status_reg = {free_rx_bd, free_tx_bd};\n    status_reg = {cmd_int_busy, STATUS_REG[15:1], cidat_w};\n    normal_int_status_reg = NORMAL_INT_REG;\n    error_int_status_reg = ERR_INT_REG;\n    Bd_isr_reg = Dat_Int_Status;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 3, "code": "```ilog\nmodule sdc_controller(\n    // WISHBONE signals\n    input  wire        wb_clk_i,\n    input  wire        wb_rst_i,\n    input  wire [3:0]  wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0]  wb_adr_i,\n    input  wire        wb_we_i,\n    input  wire        wb_cyc_i,\n    input  wire        wb_stb_i,\n    output wire        wb_ack_o,\n\n    // Master WISHBONE signals\n    output wire [31:0] m_wb_adr_o,\n    output wire        m_wb_sel_o,\n    output wire        m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire        m_wb_cyc_o,\n    output wire        m_wb_stb_o,\n    input  wire        m_wb_ack_i,\n    output wire        m_wb_cti_o,\n    output wire        m_wb_bte_o,\n\n    // SDC/MMC signals\n    input  wire        sd_cmd_dat_i,\n    output wire        sd_cmd_out_o,\n    output wire        sd_cmd_oe_o,\n    input  wire [3:0]  sd_dat_dat_i,\n    output wire [3:0]  sd_dat_out_o,\n    output wire        sd_dat_oe_o,\n    output wire        sd_clk_o_pad,\n\n    // Interrupt signals\n    output wire        int_a,\n    output wire        int_b,\n    output wire        int_c,\n\n    // Card detect signal\n    input  wire        card_detect\n);\n\n// Internal wires and registers\nwire        clk;\nwire        rst;\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0]  software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0]  clock_divider;\nwire [15:0] bd_status_reg;\nwire [7:0]  bd_isr_reg;\nwire [7:0]  bd_isr_enable_reg;\nwire        bd_isr_reset;\nwire        normal_isr_reset;\nwire        error_isr_reset;\nwire [31:0] dat_in_m_tx_bd;\nwire [31:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .bd_status_reg(bd_status_reg),\n    .bd_isr_reg(bd_isr_reg),\n    .bd_isr_enable_reg(bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(),\n    .data_write(),\n    .data_read(),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(),\n    .go_idle_o(),\n    .cmd_out(),\n    .req_out(),\n    .ack_out(),\n    .req_in(),\n    .ack_in(),\n    .cmd_in(),\n    .serial_status(),\n    .card_detect(card_detect)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(wb_clk_i),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(),\n    .REQ_IN(),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(sd_cmd_oe_o),\n    .REQ_OUT(),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o)\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(),\n    .ack_i_s_tx(),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(),\n    .ack_i_s_rx(),\n    .cmd_busy(),\n    .we_ack(),\n    .cmd_tsf_err(),\n    .card_status(),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .data_in(),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(),\n    .dat_in_m(),\n    .free_bd(),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(),\n    .dat_in_m(),\n    .free_bd(),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(),\n    .m_wb_we_o(),\n    .m_wb_dat_i(),\n    .m_wb_cyc_o(),\n    .m_wb_stb_o(),\n    .m_wb_ack_i(),\n    .m_wb_cti_o(),\n    .m_wb_bte(),\n    .en(),\n    .adr(),\n    .sd_clk(),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(),\n    .m_wb_we_o(),\n    .m_wb_dat_o(),\n    .m_wb_cyc_o(),\n    .m_wb_stb_o(),\n    .m_wb_ack_i(),\n    .m_wb_cti_o(),\n    .m_wb_bte(),\n    .en(),\n    .adr(),\n    .sd_clk(),\n    .dat_i(),\n    .wr(),\n    .full()\n);\n\n// Master WISHBONE interface control\nassign m_wb_sel_o = 4'b1111;\n\nalways @(*) begin\n    if (start_tx_fifo) begin\n        m_wb_cyc_o = u_sd_fifo_tx_filler.m_wb_cyc_o;\n        m_wb_stb_o = u_sd_fifo_tx_filler.m_wb_stb_o;\n        m_wb_cti_o = u_sd_fifo_tx_filler.m_wb_cti_o;\n        m_wb_bte  = u_sd_fifo_tx_filler.m_wb_bte;\n        m_wb_we_o = u_sd_fifo_tx_filler.m_wb_we_o;\n        m_wb_adr_o = u_sd_fifo_tx_filler.m_wb_adr_o;\n    end else if (start_rx_fifo) begin\n        m_wb_cyc_o = u_sd_fifo_rx_filler.m_wb_cyc_o;\n        m_wb_stb_o = u_sd_fifo_rx_filler.m_wb_stb_o;\n        m_wb_cti_o = u_sd_fifo_rx_filler.m_wb_cti_o;\n        m_wb_bte  = u_sd_fifo_rx_filler.m_wb_bte;\n        m_wb_we_o = u_sd_fifo_rx_filler.m_wb_we_o;\n        m_wb_adr_o = u_sd_fifo_rx_filler.m_wb_adr_o;\n    end else begin\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n        m_wb_cti_o = 3'b000;\n        m_wb_bte  = 2'b00;\n        m_wb_we_o = 1'b0;\n        m_wb_adr_o = 32'b0;\n    end\nend\n\n// Register update\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        cmd_int_busy <= 1'b0;\n    end else if (cmd_int_busy) begin\n        status_reg[0] <= 1'b1;\n    end else begin\n        status_reg[0] <= STATUS_REG[0];\n    end\nend\n\nassign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) != 0;\nassign int_b = (error_int_status_reg & error_int_signal_enable_reg) != 0;\nassign int_c = (bd_isr_reg & bd_isr_enable_reg) != 0;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 4, "code": "module sdc_controller(\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Master Wishbone Interface\n    output [31:0] m_wb_adr_o,\n    output [3:0]  m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n\n    // SDC/MMC Interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n\n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c,\n\n    // Card Detect\n    input         card_detect\n);\n\n// Internal signals\nwire            we_m_tx_bd;\nwire            we_m_rx_bd;\nwire            new_cmd;\nwire            we_ack;\nwire            int_ack;\nwire            cmd_int_busy;\nwire            int_busy;\nwire            write_req_s;\nwire [15:0]     cmd_set_s;\nwire [31:0]     cmd_arg_s;\nwire [31:0]     argument_reg;\nwire [15:0]     cmd_setting_reg;\nwire [15:0]     status_reg;\nwire [31:0]     cmd_resp_1;\nwire [7:0]      software_reset_reg;\nwire [15:0]     time_out_reg;\nwire [15:0]     normal_int_status_reg;\nwire [15:0]     error_int_status_reg;\nwire [15:0]     normal_int_signal_enable_reg;\nwire [15:0]     error_int_signal_enable_reg;\nwire [7:0]      clock_divider;\nwire [15:0]     Bd_Status_reg;\nwire [7:0]      Bd_isr_reg;\nwire [7:0]      Bd_isr_enable_reg;\nwire            bd_isr_reset;\nwire            normal_isr_reset;\nwire            error_isr_reset;\nwire [31:0]     dat_in_m_tx_bd;\nwire [31:0]     dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(write_req_s),\n    .data_read(~write_req_s),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(int_ack),\n    .cmd_out(sd_cmd_out_o),\n    .req_out(sd_cmd_oe_o),\n    .ack_out(),\n    .req_in(sd_cmd_dat_i),\n    .ack_in(),\n    .cmd_in(sd_cmd_dat_i),\n    .serial_status(),\n    .card_detect(card_detect)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(wb_clk_i),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(sd_cmd_out_o),\n    .REQ_IN(sd_cmd_oe_o),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(),\n    .REQ_OUT(sd_cmd_oe_o),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t()\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(Bd_Status_reg[15:8]),\n    .ack_i_s_tx(we_m_tx_bd),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(Bd_Status_reg[7:0]),\n    .ack_i_s_rx(we_m_rx_bd),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(),\n    .card_status(status_reg[4:0]),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(bd_isr_reset),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(dat_in_m_tx_bd),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(Bd_Status_reg[15:8]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(Bd_Status_reg[7:0]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\n// Interrupt logic\nassign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) != 0;\nassign int_b = (error_int_status_reg & error_int_signal_enable_reg) != 0;\nassign int_c = (Bd_isr_reg & Bd_isr_enable_reg) != 0;\n\n// Master Wishbone Interface Control\nassign m_wb_sel_o = 4'b1111;\n\nalways @(*)\nbegin\n    if (start_tx_fifo)\n    begin\n        m_wb_cyc_o = u_sd_fifo_tx_filler.m_wb_cyc_o;\n        m_wb_stb_o = u_sd_fifo_tx_filler.m_wb_stb_o;\n        m_wb_cti_o = u_sd_fifo_tx_filler.m_wb_cti_o;\n        m_wb_bte_o = u_sd_fifo_tx_filler.m_wb_bte_o;\n        m_wb_we_o = u_sd_fifo_tx_filler.m_wb_we_o;\n        m_wb_adr_o = u_sd_fifo_tx_filler.m_wb_adr_o;\n    end\n    else if (start_rx_fifo)\n    begin\n        m_wb_cyc_o = u_sd_fifo_rx_filler.m_wb_cyc_o;\n        m_wb_stb_o = u_sd_fifo_rx_filler.m_wb_stb_o;\n        m_wb_cti_o = u_sd_fifo_rx_filler.m_wb_cti_o;\n        m_wb_bte_o = u_sd_fifo_rx_filler.m_wb_bte_o;\n        m_wb_we_o = u_sd_fifo_rx_filler.m_wb_we_o;\n        m_wb_adr_o = u_sd_fifo_rx_filler.m_wb_adr_o;\n    end\n    else\n    begin\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n        m_wb_cti_o = 3'b000;\n        m_wb_bte_o = 2'b00;\n        m_wb_we_o = 1'b0;\n        m_wb_adr_o = 32'b0;\n    end\nend\n\n// Register Update\nalways @(posedge wb_clk_i)\nbegin\n    if (wb_rst_i)\n    begin\n        cmd_int_busy <= 1'b0;\n    end\n    else\n    begin\n        cmd_int_busy <= (cmd_int_busy || new_cmd) && !int_ack;\n    end\nend\n\nalways @(posedge wb_clk_i)\nbegin\n    if (wb_rst_i)\n    begin\n        Bd_Status_reg <= 16'b0;\n    end\n    else\n    begin\n        Bd_Status_reg[15:8] <= Bd_Status_reg[15:8] - (we_m_tx_bd ? 1'b1 : 1'b0);\n        Bd_Status_reg[7:0] <= Bd_Status_reg[7:0] - (we_m_rx_bd ? 1'b1 : 1'b0);\n    end\nend\n\nalways @(posedge wb_clk_i)\nbegin\n    if (wb_rst_i)\n    begin\n        status_reg <= 16'b0;\n    end\n    else\n    begin\n        status_reg[0] <= cmd_int_busy;\n        status_reg[15:1] <= status_reg[15:1];\n    end\nend\n\nalways @(posedge wb_clk_i)\nbegin\n    if (wb_rst_i)\n    begin\n        normal_int_status_reg <= 16'b0;\n    end\n    else\n    begin\n        normal_int_status_reg <= normal_int_status_reg;\n    end\nend\n\nalways @(posedge wb_clk_i)\nbegin\n    if (wb_rst_i)\n    begin\n        error_int_status_reg <= 16'b0;\n    end\n    else\n    begin\n        error_int_status_reg <= error_int_status_reg;\n    end\nend\n\nalways @(posedge wb_clk_i)\nbegin\n    if (wb_rst_i)\n    begin\n        Bd_isr_reg <= 8'b0;\n    end\n    else\n    begin\n        Bd_isr_reg <= Dat_Int_Status;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 5, "code": "module sdc_controller(\n    // Wishbone interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Master Wishbone interface\n    output [31:0] m_wb_adr_o,\n    output [3:0]  m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n\n    // SDC interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n\n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c,\n\n    // Card detect\n    input         card_detect\n);\n\n// Internal signals\nwire            we_m_tx_bd;\nwire            we_m_rx_bd;\nwire            new_cmd;\nwire            we_ack;\nwire            int_ack;\nwire            cmd_int_busy;\nwire            int_busy;\nwire            write_req_s;\nwire [15:0]     cmd_set_s;\nwire [31:0]     cmd_arg_s;\nwire [31:0]     argument_reg;\nwire [15:0]     cmd_setting_reg;\nwire [15:0]     status_reg;\nwire [31:0]     cmd_resp_1;\nwire [7:0]      software_reset_reg;\nwire [15:0]     time_out_reg;\nwire [15:0]     normal_int_status_reg;\nwire [15:0]     error_int_status_reg;\nwire [15:0]     normal_int_signal_enable_reg;\nwire [15:0]     error_int_signal_enable_reg;\nwire [7:0]      clock_divider;\nwire [15:0]     Bd_Status_reg;\nwire [7:0]      Bd_isr_reg;\nwire [7:0]      Bd_isr_enable_reg;\nwire            bd_isr_reset;\nwire            normal_isr_reset;\nwire            error_isr_reset;\nwire [31:0]     dat_in_m_tx_bd;\nwire [31:0]     dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(write_req_s),\n    .data_read(~write_req_s),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(int_ack),\n    .cmd_out(sd_cmd_out_o),\n    .req_out(sd_cmd_oe_o),\n    .ack_out(),\n    .req_in(),\n    .ack_in(),\n    .cmd_in(sd_cmd_dat_i),\n    .serial_status(),\n    .card_detect(card_detect)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(sd_clk_o_pad),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(sd_cmd_out_o),\n    .REQ_IN(sd_cmd_oe_o),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(sd_cmd_oe_o),\n    .REQ_OUT(),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t()\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(Bd_Status_reg[15:8]),\n    .ack_i_s_tx(we_m_tx_bd),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(Bd_Status_reg[7:0]),\n    .ack_i_s_rx(we_m_rx_bd),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(),\n    .card_status(status_reg[4:0]),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(bd_isr_reset),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(Bd_Status_reg[15:8]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(Bd_Status_reg[7:0]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\n// Assign outputs\nassign m_wb_sel_o = 4'b1111;\n\n// Assign interrupts\nassign int_a = normal_int_status_reg[0];\nassign int_b = error_int_status_reg[0];\nassign int_c = Bd_isr_reg[0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 6, "code": "module sdc_controller(\n    // Wishbone Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Master Wishbone Interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n\n    // SDC Interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n\n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c,\n\n    // Card Detect\n    input         card_detect\n);\n\n// Internal signals\nwire            we_m_tx_bd;\nwire            we_m_rx_bd;\nwire            new_cmd;\nwire            we_ack;\nwire            int_ack;\nwire            cmd_int_busy;\nwire            int_busy;\nwire            write_req_s;\nwire [15:0]     cmd_set_s;\nwire [31:0]     cmd_arg_s;\nwire [31:0]     argument_reg;\nwire [15:0]     cmd_setting_reg;\nwire [15:0]     status_reg;\nwire [31:0]     cmd_resp_1;\nwire [7:0]      software_reset_reg;\nwire [15:0]     time_out_reg;\nwire [15:0]     normal_int_status_reg;\nwire [15:0]     error_int_status_reg;\nwire [15:0]     normal_int_signal_enable_reg;\nwire [15:0]     error_int_signal_enable_reg;\nwire [7:0]      clock_divider;\nwire [15:0]     Bd_Status_reg;\nwire [7:0]      Bd_isr_reg;\nwire [7:0]      Bd_isr_enable_reg;\nwire            bd_isr_reset;\nwire            normal_isr_reset;\nwire            error_isr_reset;\nwire [31:0]     dat_in_m_tx_bd;\nwire [31:0]     dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(write_req_s),\n    .data_read(~write_req_s),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(int_ack),\n    .cmd_out(sd_cmd_out_o),\n    .req_out(sd_cmd_oe_o),\n    .ack_out(),\n    .req_in(),\n    .ack_in(),\n    .cmd_in(sd_cmd_dat_i),\n    .serial_status(),\n    .card_detect(card_detect)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(wb_clk_i),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(sd_cmd_out_o),\n    .REQ_IN(sd_cmd_oe_o),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(sd_cmd_oe_o),\n    .REQ_OUT(),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t()\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(Bd_Status_reg[15:8]),\n    .ack_i_s_tx(we_m_tx_bd),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(Bd_Status_reg[7:0]),\n    .ack_i_s_rx(we_m_rx_bd),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(),\n    .card_status(status_reg[4:0]),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(bd_isr_reset),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(dat_in_m_tx_bd),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(Bd_Status_reg[15:8]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(Bd_Status_reg[7:0]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\n// Assign outputs\nassign m_wb_sel_o = 4'b1111;\n\n// Interrupt logic\nassign int_a = normal_int_status_reg & normal_int_signal_enable_reg;\nassign int_b = error_int_status_reg & error_int_signal_enable_reg;\nassign int_c = Bd_isr_reg & Bd_isr_enable_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 7, "code": "module sdc_controller(\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Master Wishbone Interface\n    output [31:0] m_wb_adr_o,\n    output [3:0]  m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n\n    // SDC/MMC Interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n\n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c,\n\n    // Card Detect\n    input         card_detect\n);\n\n// Internal signals\nwire            we_m_tx_bd;\nwire            we_m_rx_bd;\nwire            new_cmd;\nwire            we_ack;\nwire            int_ack;\nwire            cmd_int_busy;\nwire            int_busy;\nwire            write_req_s;\nwire [15:0]     cmd_set_s;\nwire [31:0]     cmd_arg_s;\nwire [31:0]     argument_reg;\nwire [15:0]     cmd_setting_reg;\nwire [15:0]     status_reg;\nwire [31:0]     cmd_resp_1;\nwire [7:0]      software_reset_reg;\nwire [15:0]     time_out_reg;\nwire [15:0]     normal_int_status_reg;\nwire [15:0]     error_int_status_reg;\nwire [15:0]     normal_int_signal_enable_reg;\nwire [15:0]     error_int_signal_enable_reg;\nwire [7:0]      clock_divider;\nwire [15:0]     Bd_Status_reg;\nwire [7:0]      Bd_isr_reg;\nwire [7:0]      Bd_isr_enable_reg;\nwire            bd_isr_reset;\nwire            normal_isr_reset;\nwire            error_isr_reset;\nwire [31:0]     dat_in_m_tx_bd;\nwire [31:0]     dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(write_req_s),\n    .data_read(~write_req_s),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(),\n    .cmd_out(),\n    .req_out(),\n    .ack_out(),\n    .req_in(),\n    .ack_in(),\n    .cmd_in(),\n    .serial_status(),\n    .card_detect(card_detect)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(sd_clk_o_pad),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(),\n    .REQ_IN(),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(sd_cmd_oe_o),\n    .REQ_OUT(),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t()\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(Bd_Status_reg[15:8]),\n    .ack_i_s_tx(),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(Bd_Status_reg[7:0]),\n    .ack_i_s_rx(),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(),\n    .card_status(status_reg[4:0]),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(Bd_Status_reg[15:8]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(Bd_Status_reg[7:0]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\nassign m_wb_sel_o = 4'b1111;\n\n// Interrupt logic\nassign int_a = normal_int_status_reg & normal_int_signal_enable_reg;\nassign int_b = error_int_status_reg & error_int_signal_enable_reg;\nassign int_c = Bd_isr_reg & Bd_isr_enable_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 8, "code": "// sd_controller_wb module\nmodule sd_controller_wb(\n    input             wb_clk_i,\n    input             wb_rst_i,\n    input      [31:0] wb_dat_i,\n    output     [31:0] wb_dat_o,\n    input       [7:0] wb_adr_i,\n    input       [3:0] wb_sel_i,\n    input             wb_we_i,\n    input             wb_cyc_i,\n    input             wb_stb_i,\n    output            wb_ack_o,\n    output            we_m_tx_bd,\n    output            we_m_rx_bd,\n    output            new_cmd,\n    output            we_ack,\n    output            int_ack,\n    output            cmd_int_busy,\n    output            int_busy,\n    input             write_req_s,\n    input      [15:0] cmd_set_s,\n    input      [31:0] cmd_arg_s,\n    output     [31:0] argument_reg,\n    output     [15:0] cmd_setting_reg,\n    input      [15:0] status_reg,\n    input      [31:0] cmd_resp_1,\n    output      [7:0] software_reset_reg,\n    output     [15:0] time_out_reg,\n    input      [15:0] normal_int_status_reg,\n    input      [15:0] error_int_status_reg,\n    output     [15:0] normal_int_signal_enable_reg,\n    output     [15:0] error_int_signal_enable_reg,\n    output      [7:0] clock_divider,\n    input      [15:0] Bd_Status_reg,\n    input       [7:0] Bd_isr_reg,\n    output      [7:0] Bd_isr_enable_reg,\n    output            bd_isr_reset,\n    output            normal_isr_reset,\n    output            error_isr_reset,\n    output     [31:0] dat_in_m_tx_bd,\n    output     [31:0] dat_in_m_rx_bd\n);\n\n// sd_clock_divider module\nmodule sd_clock_divider(\n    input             clk,\n    input       [7:0] divider,\n    input             rst,\n    output            sd_clk\n);\n\n// sd_cmd_master module\nmodule sd_cmd_master(\n    input             clk_pad_io,\n    input             rst_pad_i,\n    input             new_cmd,\n    input             data_write,\n    input             data_read,\n    input      [31:0] arg_reg,\n    input      [13:0] cmd_set_reg,\n    input      [15:0] timeout_reg,\n    output     [15:0] status_reg,\n    output     [31:0] resp_1_reg,\n    output      [4:0] err_int_reg,\n    output     [15:0] normal_int_reg,\n    input             err_int_rst,\n    input             normal_int_rst,\n    output     [15:0] settings,\n    output            go_idle_o,\n    output     [39:0] cmd_out,\n    output            req_out,\n    output            ack_out,\n    input             req_in,\n    input             ack_in,\n    input      [39:0] cmd_in,\n    input       [7:0] serial_status,\n    input             card_detect\n);\n\n// sd_cmd_serial_host module\nmodule sd_cmd_serial_host(\n    input             sd_clk_in,\n    input             rst_in,\n    input      [15:0] setting_in,\n    input      [39:0] cmd_in,\n    input             req_in,\n    input             ack_in,\n    input             cmd_dat_i,\n    output     [39:0] cmd_out,\n    output            ack_out,\n    output            req_out,\n    output      [7:0] status,\n    output            cmd_oe_o,\n    output            cmd_out_o,\n    output      [1:0] st_dat_t\n);\n\n// sd_data_master module\nmodule sd_data_master(\n    input             clk,\n    input             rst,\n    input      [31:0] dat_in_tx,\n    input      [7:0]  free_tx_bd,\n    input             ack_i_s_tx,\n    input      [31:0] dat_in_rx,\n    input      [7:0]  free_rx_bd,\n    input             ack_i_s_rx,\n    input             cmd_busy,\n    input             we_ack,\n    input             cmd_tsf_err,\n    input       [4:0] card_status,\n    input             tx_empt,\n    input             tx_full,\n    input             rx_full,\n    input             busy_n,\n    input             transm_complete,\n    input             crc_ok,\n    input             dat_int_status_rst,\n    input       [1:0] transfer_type,\n    output            re_s_tx,\n    output            a_cmp_tx,\n    output            re_s_rx,\n    output            a_cmp_rx,\n    output            we_req,\n    output            d_write,\n    output            d_read,\n    output     [31:0] cmd_arg,\n    output     [15:0] cmd_set,\n    output            start_tx_fifo,\n    output            start_rx_fifo,\n    output     [31:0] sys_adr,\n    output            ack_transfer,\n    output      [7:0] dat_int_status,\n    output            cidat\n);\n\n// sd_data_serial_host module\nmodule sd_data_serial_host(\n    input             sd_clk,\n    input             rst,\n    input      [31:0] data_in,\n    input       [1:0] start_dat,\n    input             ack_transfer,\n    input       [3:0] dat_dat_i,\n    output            rd,\n    output      [3:0] data_out,\n    output            we,\n    output            dat_oe_o,\n    output      [3:0] dat_dat_o,\n    output            busy_n,\n    output            transm_complete,\n    output            crc_ok\n);\n\n// rx_bd/tx_bd module\nmodule rx_bd(\n    input             clk,\n    input             rst,\n    input             we_m,\n    input      [31:0] dat_in_m,\n    output     [7:0]  free_bd,\n    input             re_s,\n    output            ack_o_s,\n    input             a_cmp,\n    output     [31:0] dat_out_s\n);\n\nmodule tx_bd(\n    input             clk,\n    input             rst,\n    input             we_m,\n    input      [31:0] dat_in_m,\n    output     [7:0]  free_bd,\n    input             re_s,\n    output            ack_o_s,\n    input             a_cmp,\n    output     [31:0] dat_out_s\n);\n\n// sd_fifo_tx_filler module\nmodule sd_fifo_tx_filler(\n    input             clk,\n    input             rst,\n    output     [31:0] m_wb_adr_o,\n    output            m_wb_we_o,\n    input      [31:0] m_wb_dat_i,\n    output            m_wb_cyc_o,\n    output            m_wb_stb_o,\n    input             m_wb_ack_i,\n    output      [2:0] m_wb_cti_o,\n    output      [1:0] m_wb_bte_o,\n    input             en,\n    input      [31:0] adr,\n    input             sd_clk,\n    output     [31:0] dat_o,\n    input             rd,\n    output            empty,\n    output            fe\n);\n\n// sd_fifo_rx_filler module\nmodule sd_fifo_rx_filler(\n    input             clk,\n    input             rst,\n    output     [31:0] m_wb_adr_o,\n    output            m_wb_we_o,\n    output     [31:0] m_wb_dat_o,\n    output            m_wb_cyc_o,\n    output            m_wb_stb_o,\n    input             m_wb_ack_i,\n    output      [2:0] m_wb_cti_o,\n    output      [1:0] m_wb_bte_o,\n    input             en,\n    input      [31:0] adr,\n    input             sd_clk,\n    input       [3:0] dat_i,\n    input             wr,\n    output            full\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 9, "code": "module sdc_controller(\n    // Wishbone Slave Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Master Wishbone Interface\n    output [31:0] m_wb_adr_o,\n    output [3:0]  m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n\n    // SDC/MMC Interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n\n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n// Internal signals\nwire            we_m_tx_bd;\nwire            we_m_rx_bd;\nwire            new_cmd;\nwire            we_ack;\nwire            int_ack;\nwire            cmd_int_busy;\nwire            int_busy;\nwire            write_req_s;\nwire [15:0]     cmd_set_s;\nwire [31:0]     cmd_arg_s;\nwire [31:0]     argument_reg;\nwire [15:0]     cmd_setting_reg;\nwire [15:0]     status_reg;\nwire [31:0]     cmd_resp_1;\nwire [7:0]      software_reset_reg;\nwire [15:0]     time_out_reg;\nwire [15:0]     normal_int_status_reg;\nwire [15:0]     error_int_status_reg;\nwire [15:0]     normal_int_signal_enable_reg;\nwire [15:0]     error_int_signal_enable_reg;\nwire [7:0]      clock_divider;\nwire [15:0]     Bd_Status_reg;\nwire [7:0]      Bd_isr_reg;\nwire [7:0]      Bd_isr_enable_reg;\nwire            bd_isr_reset;\nwire            normal_isr_reset;\nwire            error_isr_reset;\nwire [31:0]     dat_in_m_tx_bd;\nwire [31:0]     dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(write_req_s),\n    .data_read(~write_req_s),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(int_ack),\n    .cmd_out(sd_cmd_out_o),\n    .req_out(sd_cmd_oe_o),\n    .ack_out(),\n    .req_in(),\n    .ack_in(),\n    .cmd_in(sd_cmd_dat_i),\n    .serial_status(),\n    .card_detect()\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(sd_clk_o_pad),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(sd_cmd_out_o),\n    .REQ_IN(sd_cmd_oe_o),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(sd_cmd_oe_o),\n    .REQ_OUT(),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t()\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(Bd_Status_reg[15:8]),\n    .ack_i_s_tx(we_m_tx_bd),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(Bd_Status_reg[7:0]),\n    .ack_i_s_rx(we_m_rx_bd),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(),\n    .card_status(status_reg[4:0]),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(bd_isr_reset),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(dat_in_m_tx_bd),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(Bd_Status_reg[7:0]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(Bd_Status_reg[15:8]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\n// Assign output signals\nassign m_wb_sel_o = 4'b1111;\n\n// Assign interrupt signals\nassign int_a = normal_int_status_reg[0];\nassign int_b = error_int_status_reg[0];\nassign int_c = Bd_isr_reg[0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 10, "code": "module sdc_controller(\n    // Wishbone interface\n    input  wire wb_clk_i,\n    input  wire wb_rst_i,\n    input  wire [3:0] wb_sel_i,\n    input  wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input  wire [7:0] wb_adr_i,\n    input  wire wb_we_i,\n    input  wire wb_cyc_i,\n    input  wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Master Wishbone interface\n    output wire [31:0] m_wb_adr_o,\n    output wire [3:0] m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input  wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input  wire m_wb_ack_i,\n\n    // SDC interface\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input  wire sd_cmd_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    input  wire [3:0] sd_dat_dat_i,\n    output wire sd_clk_o,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Card detect\n    input  wire card_detect\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] bd_status_reg;\nwire [7:0] bd_isr_reg;\nwire [7:0] bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [31:0] dat_in_m_tx_bd;\nwire [31:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .bd_status_reg(bd_status_reg),\n    .bd_isr_reg(bd_isr_reg),\n    .bd_isr_enable_reg(bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .clk(wb_clk_i),\n    .divider(clock_divider),\n    .rst(wb_rst_i),\n    .sd_clk(sd_clk_o)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .new_cmd(new_cmd),\n    .data_write(data_write),\n    .data_read(data_read),\n    .arg_reg(argument_reg),\n    .cmd_set_reg(cmd_setting_reg),\n    .timeout_reg(time_out_reg),\n    .status_reg(status_reg),\n    .resp_1_reg(cmd_resp_1),\n    .err_int_reg(error_int_status_reg),\n    .normal_int_reg(normal_int_status_reg),\n    .err_int_rst(error_isr_reset),\n    .normal_int_rst(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(go_idle_o),\n    .cmd_out(sd_cmd_out_o),\n    .req_out(sd_cmd_oe_o),\n    .ack_out(ack_out),\n    .req_in(req_in),\n    .ack_in(ack_in),\n    .cmd_in(sd_cmd_dat_i),\n    .serial_status(serial_status),\n    .card_detect(card_detect)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .sd_clk_i(sd_clk_o),\n    .rst_i(wb_rst_i),\n    .setting_in(cmd_setting_reg),\n    .cmd_in(sd_cmd_out_o),\n    .req_in(sd_cmd_oe_o),\n    .ack_in(ack_in),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .cmd_out(sd_cmd_out_o),\n    .ack_out(ack_out),\n    .req_out(req_out),\n    .status(status),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t(st_dat_t)\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(rst),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(free_tx_bd),\n    .ack_i_s_tx(ack_i_s_tx),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(free_rx_bd),\n    .ack_i_s_rx(ack_i_s_rx),\n    .cmd_busy(cmd_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(cmd_tsf_err),\n    .card_status(card_status),\n    .tx_empt(tx_empt),\n    .tx_full(tx_full),\n    .rx_full(rx_full),\n    .busy_n(busy_n),\n    .transm_complete(transm_complete),\n    .crc_ok(crc_ok),\n    .dat_int_status_rst(dat_int_status_rst),\n    .transfer_type(transfer_type),\n    .re_s_tx(re_s_tx),\n    .a_cmp_tx(a_cmp_tx),\n    .re_s_rx(re_s_rx),\n    .a_cmp_rx(a_cmp_rx),\n    .we_req(we_req),\n    .d_write(d_write),\n    .d_read(d_read),\n    .cmd_arg(cmd_arg),\n    .cmd_set(cmd_set),\n    .start_tx_fifo(start_tx_fifo),\n    .start_rx_fifo(start_rx_fifo),\n    .sys_adr(sys_adr),\n    .ack_transfer(ack_transfer),\n    .dat_int_status(dat_int_status),\n    .cidat(cidat)\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o),\n    .rst(rst),\n    .data_in(data_in),\n    .start_dat(start_dat),\n    .ack_transfer(ack_transfer),\n    .dat_dat_i(sd_dat_dat_i),\n    .rd(rd),\n    .data_out(data_out),\n    .we(we),\n    .dat_oe_o(sd_dat_oe_o),\n    .dat_dat_o(sd_dat_out_o),\n    .busy_n(busy_n),\n    .transm_complete(transm_complete),\n    .crc_ok(crc_ok)\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(free_tx_bd),\n    .re_s(re_s_tx),\n    .ack_o_s(ack_o_s),\n    .a_cmp(a_cmp_tx),\n    .dat_out_s(dat_out_s)\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(free_rx_bd),\n    .re_s(re_s_rx),\n    .ack_o_s(ack_o_s),\n    .a_cmp(a_cmp_rx),\n    .dat_out_s(dat_out_s)\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(en),\n    .adr(adr),\n    .sd_clk(sd_clk_o),\n    .dat_o(dat_o),\n    .rd(rd),\n    .empty(empty),\n    .fe(fe)\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(en),\n    .adr(adr),\n    .sd_clk(sd_clk_o),\n    .dat_i(sd_dat_dat_i),\n    .wr(wr),\n    .full(full)\n);\n\n// Master Wishbone interface control\nassign m_wb_sel_o = 4'b1111;\n\nalways @(posedge wb_clk_i) begin\n    if (start_tx_fifo) begin\n        m_wb_adr_o <= u_sd_fifo_tx_filler.m_wb_adr_o;\n        m_wb_we_o <= u_sd_fifo_tx_filler.m_wb_we_o;\n        m_wb_dat_o <= u_sd_fifo_tx_filler.m_wb_dat_o;\n        m_wb_cyc_o <= u_sd_fifo_tx_filler.m_wb_cyc_o;\n        m_wb_stb_o <= u_sd_fifo_tx_filler.m_wb_stb_o;\n        m_wb_cti_o <= u_sd_fifo_tx_filler.m_wb_cti_o;\n        m_wb_bte_o <= u_sd_fifo_tx_filler.m_wb_bte_o;\n    end else if (start_rx_fifo) begin\n        m_wb_adr_o <= u_sd_fifo_rx_filler.m_wb_adr_o;\n        m_wb_we_o <= u_sd_fifo_rx_filler.m_wb_we_o;\n        m_wb_dat_o <= u_sd_fifo_rx_filler.m_wb_dat_o;\n        m_wb_cyc_o <= u_sd_fifo_rx_filler.m_wb_cyc_o;\n        m_wb_stb_o <= u_sd_fifo_rx_filler.m_wb_stb_o;\n        m_wb_cti_o <= u_sd_fifo_rx_filler.m_wb_cti_o;\n        m_wb_bte_o <= u_sd_fifo_rx_filler.m_wb_bte_o;\n    end else begin\n        m_wb_adr_o <= 32'b0;\n        m_wb_we_o <= 1'b0;\n        m_wb_dat_o <= 32'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'b0;\n        m_wb_bte_o <= 2'b0;\n    end\nend\n\n// Register update\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        cmd_int_busy <= 1'b0;\n    end else if (cmd_int_busy) begin\n        cmd_int_busy <= 1'b1;\n    end else begin\n        cmd_int_busy <= 1'b0;\n    end\nend\n\nassign bd_status_reg[15:8] = free_rx_bd;\nassign bd_status_reg[7:0] = free_tx_bd;\n\nassign status_reg[0] = cmd_int_busy ? 1'b1 : STATUS_REG[0];\nassign status_reg[15:1] = STATUS_REG[15:1];\n\nassign normal_int_status_reg = NORMAL_INT_REG;\nassign error_int_status_reg = ERR_INT_REG;\nassign bd_isr_reg = Dat_Int_Status;\nassign bd_isr_enable_reg = Bd_isr_enable_reg;\n\nassign int_a = int_a_signal;\nassign int_b = int_b_signal;\nassign int_c = int_c_signal;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 11, "code": "module sdc_controller(\n    // Wishbone interface\n    input             wb_clk_i,\n    input             wb_rst_i,\n    input      [3:0]  wb_sel_i,\n    input     [31:0]  wb_dat_i,\n    output    [31:0]  wb_dat_o,\n    input      [7:0]  wb_adr_i,\n    input             wb_we_i,\n    input             wb_cyc_i,\n    input             wb_stb_i,\n    output            wb_ack_o,\n\n    // Master Wishbone interface\n    output    [31:0]  m_wb_adr_o,\n    output            m_wb_sel_o,\n    output            m_wb_we_o,\n    output    [31:0]  m_wb_dat_o,\n    input     [31:0]  m_wb_dat_i,\n    output            m_wb_cyc_o,\n    output            m_wb_stb_o,\n    input             m_wb_ack_i,\n    output    [2:0]   m_wb_cti_o,\n    output    [1:0]   m_wb_bte_o,\n\n    // SD card interface\n    input             sd_cmd_dat_i,\n    output            sd_cmd_out_o,\n    output            sd_cmd_oe_o,\n    input      [3:0]  sd_dat_dat_i,\n    output     [3:0]  sd_dat_out_o,\n    output            sd_dat_oe_o,\n    output            sd_clk_o_pad,\n    input             sd_clk_i_pad,\n\n    // Interrupts\n    output            int_a,\n    output            int_b,\n    output            int_c,\n\n    // Card detect\n    input             card_detect\n);\n\n// Internal signals\nwire            we_m_tx_bd;\nwire            we_m_rx_bd;\nwire            new_cmd;\nwire            we_ack;\nwire            int_ack;\nwire            cmd_int_busy;\nwire            int_busy;\nwire            write_req_s;\nwire     [15:0]  cmd_set_s;\nwire     [31:0]  cmd_arg_s;\nwire     [31:0]  argument_reg;\nwire     [15:0]  cmd_setting_reg;\nwire     [15:0]  status_reg;\nwire     [31:0]  cmd_resp_1;\nwire      [7:0]  software_reset_reg;\nwire     [15:0]  time_out_reg;\nwire     [15:0]  normal_int_status_reg;\nwire     [15:0]  error_int_status_reg;\nwire     [15:0]  normal_int_signal_enable_reg;\nwire     [15:0]  error_int_signal_enable_reg;\nwire      [7:0]  clock_divider;\nwire     [15:0]  Bd_Status_reg;\nwire      [7:0]  Bd_isr_reg;\nwire      [7:0]  Bd_isr_enable_reg;\nwire            bd_isr_reset;\nwire            normal_isr_reset;\nwire            error_isr_reset;\nwire    [31:0]   dat_in_m_tx_bd;\nwire    [31:0]   dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(write_req_s),\n    .data_read(1'b0),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(int_ack),\n    .cmd_out(sd_cmd_out_o),\n    .req_out(sd_cmd_oe_o),\n    .ack_out(),\n    .req_in(),\n    .ack_in(),\n    .cmd_in(sd_cmd_dat_i),\n    .serial_status(),\n    .card_detect(card_detect)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(sd_clk_o_pad),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN({16'b0, cmd_setting_reg}),\n    .REQ_IN(sd_cmd_oe_o),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(),\n    .REQ_OUT(),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t()\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(Bd_Status_reg[15:8]),\n    .ack_i_s_tx(),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(Bd_Status_reg[7:0]),\n    .ack_i_s_rx(),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(),\n    .card_status(status_reg[4:0]),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(Bd_Status_reg[15:8]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(Bd_Status_reg[7:0]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\n// Master Wishbone interface control\nassign m_wb_sel_o = 4'b1111;\n\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'b000;\n        m_wb_bte_o <= 2'b00;\n        m_wb_we_o <= 1'b0;\n        m_wb_adr_o <= 32'b0;\n    end else begin\n        if (start_tx_fifo) begin\n            m_wb_cyc_o <= u_sd_fifo_tx_filler.m_wb_cyc_o;\n            m_wb_stb_o <= u_sd_fifo_tx_filler.m_wb_stb_o;\n            m_wb_cti_o <= u_sd_fifo_tx_filler.m_wb_cti_o;\n            m_wb_bte_o <= u_sd_fifo_tx_filler.m_wb_bte_o;\n            m_wb_we_o <= u_sd_fifo_tx_filler.m_wb_we_o;\n            m_wb_adr_o <= u_sd_fifo_tx_filler.m_wb_adr_o;\n        end else if (start_rx_fifo) begin\n            m_wb_cyc_o <= u_sd_fifo_rx_filler.m_wb_cyc_o;\n            m_wb_stb_o <= u_sd_fifo_rx_filler.m_wb_stb_o;\n            m_wb_cti_o <= u_sd_fifo_rx_filler.m_wb_cti_o;\n            m_wb_bte_o <= u_sd_fifo_rx_filler.m_wb_bte_o;\n            m_wb_we_o <= u_sd_fifo_rx_filler.m_wb_we_o;\n            m_wb_adr_o <= u_sd_fifo_rx_filler.m_wb_adr_o;\n        end else begin\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n            m_wb_we_o <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n        end\n    end\nend\n\n// Register update\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        cmd_int_busy <= 1'b0;\n        status_reg[0] <= 1'b0;\n    end else begin\n        cmd_int_busy <= int_busy;\n        status_reg[0] <= cmd_int_busy ? 1'b1 : STATUS_REG[0];\n    end\nend\n\n// Interrupt generation\nassign int_a = normal_int_status_reg[0];\nassign int_b = error_int_status_reg[0];\nassign int_c = Bd_isr_reg[0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 12, "code": "module sdc_controller(\n    // Wishbone interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Master Wishbone interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n\n    // SDC interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n\n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c,\n\n    // Card detect\n    input         card_detect\n);\n\n// Internal signals\nwire            we_m_tx_bd;\nwire            we_m_rx_bd;\nwire            new_cmd;\nwire            we_ack;\nwire            int_ack;\nwire            cmd_int_busy;\nwire            int_busy;\nwire            write_req_s;\nwire [15:0]     cmd_set_s;\nwire [31:0]     cmd_arg_s;\nwire [31:0]     argument_reg;\nwire [15:0]     cmd_setting_reg;\nwire [15:0]     status_reg;\nwire [31:0]     cmd_resp_1;\nwire [7:0]      software_reset_reg;\nwire [15:0]     time_out_reg;\nwire [15:0]     normal_int_status_reg;\nwire [15:0]     error_int_status_reg;\nwire [15:0]     normal_int_signal_enable_reg;\nwire [15:0]     error_int_signal_enable_reg;\nwire [7:0]      clock_divider;\nwire [15:0]     Bd_Status_reg;\nwire [7:0]      Bd_isr_reg;\nwire [7:0]      Bd_isr_enable_reg;\nwire            bd_isr_reset;\nwire            normal_isr_reset;\nwire            error_isr_reset;\nwire [31:0]     dat_in_m_tx_bd;\nwire [31:0]     dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(write_req_s),\n    .data_read(~write_req_s),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(int_ack),\n    .cmd_out(sd_cmd_out_o),\n    .req_out(sd_cmd_oe_o),\n    .ack_out(),\n    .req_in(),\n    .ack_in(),\n    .cmd_in(sd_cmd_dat_i),\n    .serial_status(),\n    .card_detect(card_detect)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(wb_clk_i),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(sd_cmd_out_o),\n    .REQ_IN(sd_cmd_oe_o),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(),\n    .REQ_OUT(),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t()\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(Bd_Status_reg[15:8]),\n    .ack_i_s_tx(),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(Bd_Status_reg[7:0]),\n    .ack_i_s_rx(),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(),\n    .card_status(status_reg[4:0]),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(Bd_Status_reg[7:0]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(Bd_Status_reg[15:8]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\n// Assign outputs\nassign m_wb_sel_o = 4'b1111;\nassign int_a = normal_int_status_reg[0];\nassign int_b = error_int_status_reg[0];\nassign int_c = Bd_isr_reg[0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 13, "code": "module sdc_controller(\n    // Wishbone Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Master Wishbone Interface\n    output [31:0] m_wb_adr_o,\n    output [3:0]  m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n\n    // SDC Interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n\n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c,\n\n    // Card Detect\n    input         card_detect\n);\n\n// Internal Registers\nreg [31:0] argument_reg;\nreg [15:0] cmd_setting_reg;\nreg [7:0]  software_reset_reg;\nreg [15:0] time_out_reg;\nreg [15:0] normal_int_status_reg;\nreg [15:0] error_int_status_reg;\nreg [15:0] normal_int_signal_enable_reg;\nreg [15:0] error_int_signal_enable_reg;\nreg [7:0]  clock_divider;\nreg [15:0] bd_status_reg;\nreg [7:0]  bd_isr_reg;\nreg [7:0]  bd_isr_enable_reg;\n\n// Internal Wires\nwire we_m_tx_bd;\nwire we_m_rx_bd;\nwire new_cmd;\nwire we_ack;\nwire int_ack;\nwire cmd_int_busy;\nwire int_busy;\nwire write_req_s;\nwire [15:0] cmd_set_s;\nwire [31:0] cmd_arg_s;\nwire [31:0] dat_in_m_tx_bd;\nwire [31:0] dat_in_m_rx_bd;\n\n// Instantiate Sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg({cmd_int_busy, normal_int_status_reg, error_int_status_reg}),\n    .cmd_resp_1({cmd_arg_s, cmd_set_s}),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .bd_status_reg(bd_status_reg),\n    .bd_isr_reg(bd_isr_reg),\n    .bd_isr_enable_reg(bd_isr_enable_reg),\n    .bd_isr_reset(),\n    .normal_isr_reset(),\n    .error_isr_reset(),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(),\n    .data_read(),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG({cmd_int_busy, normal_int_status_reg, error_int_status_reg}),\n    .RESP_1_REG({cmd_arg_s, cmd_set_s}),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(),\n    .NORMAL_INT_RST(),\n    .settings(),\n    .go_idle_o(),\n    .cmd_out(),\n    .req_out(),\n    .ack_out(),\n    .req_in(),\n    .ack_in(),\n    .cmd_in(),\n    .serial_status(),\n    .card_detect(card_detect)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(sd_clk_o_pad),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(),\n    .REQ_IN(),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(sd_cmd_oe_o),\n    .REQ_OUT(),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t()\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(bd_status_reg[15:8]),\n    .ack_i_s_tx(),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(bd_status_reg[7:0]),\n    .ack_i_s_rx(),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(),\n    .card_status(),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(bd_status_reg[7:0]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(bd_status_reg[15:8]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\n// Master Wishbone Interface Control\nassign m_wb_sel_o = 4'b1111;\n\nalways @(*) begin\n    if (u_sd_data_master.start_tx_fifo) begin\n        m_wb_adr_o = u_sd_fifo_tx_filler.m_wb_adr_o;\n        m_wb_we_o  = u_sd_fifo_tx_filler.m_wb_we_o;\n        m_wb_dat_o = u_sd_fifo_tx_filler.m_wb_dat_o;\n        m_wb_cyc_o = u_sd_fifo_tx_filler.m_wb_cyc_o;\n        m_wb_stb_o = u_sd_fifo_tx_filler.m_wb_stb_o;\n        m_wb_cti_o = u_sd_fifo_tx_filler.m_wb_cti_o;\n        m_wb_bte_o = u_sd_fifo_tx_filler.m_wb_bte_o;\n    end else if (u_sd_data_master.start_rx_fifo) begin\n        m_wb_adr_o = u_sd_fifo_rx_filler.m_wb_adr_o;\n        m_wb_we_o  = u_sd_fifo_rx_filler.m_wb_we_o;\n        m_wb_dat_o = u_sd_fifo_rx_filler.m_wb_dat_o;\n        m_wb_cyc_o = u_sd_fifo_rx_filler.m_wb_cyc_o;\n        m_wb_stb_o = u_sd_fifo_rx_filler.m_wb_stb_o;\n        m_wb_cti_o = u_sd_fifo_rx_filler.m_wb_cti_o;\n        m_wb_bte_o = u_sd_fifo_rx_filler.m_wb_bte_o;\n    end else begin\n        m_wb_adr_o = 32'd0;\n        m_wb_we_o  = 1'b0;\n        m_wb_dat_o = 32'd0;\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n        m_wb_cti_o = 3'b000;\n        m_wb_bte_o = 2'b00;\n    end\nend\n\n// Register Update\nalways @(*) begin\n    cmd_int_busy = u_sd_cmd_master.cmd_int_busy;\n    bd_status_reg[15:8] = u_rx_bd.free_bd;\n    bd_status_reg[7:0]  = u_tx_bd.free_bd;\n    normal_int_status_reg = u_sd_data_master.Dat_Int_Status;\n    error_int_status_reg  = u_sd_data_master.Dat_Int_Status;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 14, "code": "```ilog\nmodule sdc_controller(\n    // Wishbone Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Master Wishbone Interface\n    output [31:0] m_wb_adr_o,\n    output [3:0]  m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n\n    // SD Card Interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n\n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c,\n\n    // Card Detect\n    input         card_detect\n);\n\n// Internal signals\nwire            we_m_tx_bd;\nwire            we_m_rx_bd;\nwire            new_cmd;\nwire            we_ack;\nwire            int_ack;\nwire            cmd_int_busy;\nwire            int_busy;\nwire            write_req_s;\nwire [15:0]     cmd_set_s;\nwire [31:0]     cmd_arg_s;\nwire [31:0]     argument_reg;\nwire [15:0]     cmd_setting_reg;\nwire [15:0]     status_reg;\nwire [31:0]     cmd_resp_1;\nwire [7:0]      software_reset_reg;\nwire [15:0]     time_out_reg;\nwire [15:0]     normal_int_status_reg;\nwire [15:0]     error_int_status_reg;\nwire [15:0]     normal_int_signal_enable_reg;\nwire [15:0]     error_int_signal_enable_reg;\nwire [7:0]      clock_divider;\nwire [15:0]     Bd_Status_reg;\nwire [7:0]      Bd_isr_reg;\nwire [7:0]      Bd_isr_enable_reg;\nwire            bd_isr_reset;\nwire            normal_isr_reset;\nwire            error_isr_reset;\nwire [31:0]     dat_in_m_tx_bd;\nwire [31:0]     dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(write_req_s),\n    .data_read(~write_req_s),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(int_ack),\n    .cmd_out(sd_cmd_out_o),\n    .req_out(sd_cmd_oe_o),\n    .ack_out(),\n    .req_in(sd_cmd_dat_i),\n    .ack_in(),\n    .cmd_in(sd_cmd_dat_i),\n    .serial_status(),\n    .card_detect(card_detect)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(sd_clk_o_pad),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(sd_cmd_out_o),\n    .REQ_IN(sd_cmd_oe_o),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(),\n    .REQ_OUT(sd_cmd_oe_o),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t()\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(Bd_Status_reg[15:8]),\n    .ack_i_s_tx(),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(Bd_Status_reg[7:0]),\n    .ack_i_s_rx(),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(),\n    .card_status(status_reg[4:0]),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(Bd_Status_reg[15:8]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(Bd_Status_reg[7:0]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\nassign m_wb_sel_o = 4'b1111;\n\nassign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) != 0;\nassign int_b = (error_int_status_reg & error_int_signal_enable_reg) != 0;\nassign int_c = (Bd_isr_reg & Bd_isr_enable_reg) != 0;\n\nendmodule\n```", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 15, "code": "module sdc_controller(\n    // Wishbone interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Master Wishbone interface\n    output [31:0] m_wb_adr_o,\n    output [3:0]  m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n\n    // SDC interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n\n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n// Internal signals\nreg [31:0] argument_reg;\nreg [15:0] cmd_setting_reg;\nreg [15:0] status_reg;\nreg [31:0] cmd_resp_1;\nreg [7:0] software_reset_reg;\nreg [15:0] time_out_reg;\nreg [15:0] normal_int_status_reg;\nreg [15:0] error_int_status_reg;\nreg [15:0] normal_int_signal_enable_reg;\nreg [15:0] error_int_signal_enable_reg;\nreg [7:0] clock_divider;\nreg [15:0] bd_status_reg;\nreg [7:0] bd_isr_reg;\nreg [7:0] bd_isr_enable_reg;\nreg bd_isr_reset;\nreg normal_isr_reset;\nreg error_isr_reset;\nreg [31:0] dat_in_m_tx_bd;\nreg [31:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .bd_status_reg(bd_status_reg),\n    .bd_isr_reg(bd_isr_reg),\n    .bd_isr_enable_reg(bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(),\n    .data_write(),\n    .data_read(),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(),\n    .go_idle_o(),\n    .cmd_out(),\n    .req_out(),\n    .ack_out(),\n    .req_in(),\n    .ack_in(),\n    .cmd_in(),\n    .serial_status(),\n    .card_detect()\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(sd_clk_o_pad),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(),\n    .REQ_IN(),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(sd_cmd_oe_o),\n    .REQ_OUT(),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t()\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(),\n    .ack_i_s_tx(),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(),\n    .ack_i_s_rx(),\n    .cmd_busy(),\n    .we_ack(),\n    .cmd_tsf_err(),\n    .card_status(),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(),\n    .dat_in_m(),\n    .free_bd(),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(),\n    .dat_in_m(),\n    .free_bd(),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(),\n    .m_wb_bte_o(),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(),\n    .m_wb_bte_o(),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\n// Assign outputs\nassign m_wb_sel_o = 4'b1111;\n\n// Interrupt logic\nassign int_a = normal_int_status_reg & normal_int_signal_enable_reg;\nassign int_b = error_int_status_reg & error_int_signal_enable_reg;\nassign int_c = bd_isr_reg & bd_isr_enable_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 16, "code": "module sdc_controller(\n    // Wishbone Interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Master Wishbone Interface\n    output [31:0] m_wb_adr_o,\n    output [3:0]  m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n\n    // SDC Interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n\n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c,\n\n    // Card detect\n    input         card_detect\n);\n\n// Internal signals\nwire            we_m_tx_bd;\nwire            we_m_rx_bd;\nwire            new_cmd;\nwire            we_ack;\nwire            int_ack;\nwire            cmd_int_busy;\nwire            int_busy;\nwire            write_req_s;\nwire [15:0]     cmd_set_s;\nwire [31:0]     cmd_arg_s;\nwire [31:0]     argument_reg;\nwire [15:0]     cmd_setting_reg;\nwire [15:0]     status_reg;\nwire [31:0]     cmd_resp_1;\nwire [7:0]      software_reset_reg;\nwire [15:0]     time_out_reg;\nwire [15:0]     normal_int_status_reg;\nwire [15:0]     error_int_status_reg;\nwire [15:0]     normal_int_signal_enable_reg;\nwire [15:0]     error_int_signal_enable_reg;\nwire [7:0]      clock_divider;\nwire [15:0]     Bd_Status_reg;\nwire [7:0]      Bd_isr_reg;\nwire [7:0]      Bd_isr_enable_reg;\nwire            bd_isr_reset;\nwire            normal_isr_reset;\nwire            error_isr_reset;\nwire [31:0]     dat_in_m_tx_bd;\nwire [31:0]     dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(write_req_s),\n    .data_read(~write_req_s),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(int_ack),\n    .cmd_out(sd_cmd_out_o),\n    .req_out(sd_cmd_oe_o),\n    .ack_out(),\n    .req_in(),\n    .ack_in(),\n    .cmd_in(sd_cmd_dat_i),\n    .serial_status(),\n    .card_detect(card_detect)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(sd_clk_o_pad),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(sd_cmd_out_o),\n    .REQ_IN(sd_cmd_oe_o),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(sd_cmd_oe_o),\n    .REQ_OUT(),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t()\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(Bd_Status_reg[15:8]),\n    .ack_i_s_tx(),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(Bd_Status_reg[7:0]),\n    .ack_i_s_rx(),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(),\n    .card_status(status_reg[4:0]),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(Bd_Status_reg[15:8]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(Bd_Status_reg[7:0]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\n// Master Wishbone Interface Control\nassign m_wb_sel_o = 4'b1111;\n\nalways @(*) begin\n    if (start_tx_fifo) begin\n        m_wb_adr_o = u_sd_fifo_tx_filler.m_wb_adr_o;\n        m_wb_we_o = u_sd_fifo_tx_filler.m_wb_we_o;\n        m_wb_dat_o = u_sd_fifo_tx_filler.m_wb_dat_o;\n        m_wb_cyc_o = u_sd_fifo_tx_filler.m_wb_cyc_o;\n        m_wb_stb_o = u_sd_fifo_tx_filler.m_wb_stb_o;\n        m_wb_cti_o = u_sd_fifo_tx_filler.m_wb_cti_o;\n        m_wb_bte_o = u_sd_fifo_tx_filler.m_wb_bte_o;\n    end else if (start_rx_fifo) begin\n        m_wb_adr_o = u_sd_fifo_rx_filler.m_wb_adr_o;\n        m_wb_we_o = u_sd_fifo_rx_filler.m_wb_we_o;\n        m_wb_dat_o = u_sd_fifo_rx_filler.m_wb_dat_o;\n        m_wb_cyc_o = u_sd_fifo_rx_filler.m_wb_cyc_o;\n        m_wb_stb_o = u_sd_fifo_rx_filler.m_wb_stb_o;\n        m_wb_cti_o = u_sd_fifo_rx_filler.m_wb_cti_o;\n        m_wb_bte_o = u_sd_fifo_rx_filler.m_wb_bte_o;\n    end else begin\n        m_wb_adr_o = 32'b0;\n        m_wb_we_o = 1'b0;\n        m_wb_dat_o = 32'b0;\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n        m_wb_cti_o = 3'b0;\n        m_wb_bte_o = 2'b0;\n    end\nend\n\n// Register Update\nalways @(*) begin\n    if (cmd_int_busy) begin\n        status_reg[0] = 1'b1;\n    end else begin\n        status_reg[0] = STATUS_REG[0];\n    end\n    status_reg[15:1] = STATUS_REG[15:1];\n    status_reg[1] = CIDAT;\n    normal_int_status_reg = NORMAL_INT_REG;\n    error_int_status_reg = ERR_INT_REG;\n    Bd_isr_reg = Dat_Int_Status;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 17, "code": "module sdc_controller(\n    // Wishbone interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Master Wishbone interface\n    output [31:0] m_wb_adr_o,\n    output [3:0]  m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n\n    // SDC interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n\n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c,\n\n    // Card detect\n    input         card_detect\n);\n\n// Internal signals\nwire            we_m_tx_bd;\nwire            we_m_rx_bd;\nwire            new_cmd;\nwire            we_ack;\nwire            int_ack;\nwire            cmd_int_busy;\nwire            int_busy;\nwire            write_req_s;\nwire [15:0]     cmd_set_s;\nwire [31:0]     cmd_arg_s;\nwire [31:0]     argument_reg;\nwire [15:0]     cmd_setting_reg;\nwire [15:0]     status_reg;\nwire [31:0]     cmd_resp_1;\nwire [7:0]      software_reset_reg;\nwire [15:0]     time_out_reg;\nwire [15:0]     normal_int_status_reg;\nwire [15:0]     error_int_status_reg;\nwire [15:0]     normal_int_signal_enable_reg;\nwire [15:0]     error_int_signal_enable_reg;\nwire [7:0]      clock_divider;\nwire [15:0]     Bd_Status_reg;\nwire [7:0]      Bd_isr_reg;\nwire [7:0]      Bd_isr_enable_reg;\nwire            bd_isr_reset;\nwire            normal_isr_reset;\nwire            error_isr_reset;\nwire [31:0]     dat_in_m_tx_bd;\nwire [31:0]     dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(write_req_s),\n    .data_read(~write_req_s),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(int_ack),\n    .cmd_out(sd_cmd_out_o),\n    .req_out(sd_cmd_oe_o),\n    .ack_out(sd_cmd_oe_o),\n    .req_in(sd_cmd_dat_i),\n    .ack_in(sd_cmd_dat_i),\n    .cmd_in(sd_cmd_dat_i),\n    .serial_status(status_reg),\n    .card_detect(card_detect)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(sd_clk_o_pad),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(sd_cmd_out_o),\n    .REQ_IN(sd_cmd_oe_o),\n    .ACK_IN(sd_cmd_oe_o),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(sd_cmd_oe_o),\n    .REQ_OUT(sd_cmd_oe_o),\n    .STATUS(status_reg),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t()\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(Bd_Status_reg[15:8]),\n    .ack_i_s_tx(we_m_tx_bd),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(Bd_Status_reg[7:0]),\n    .ack_i_s_rx(we_m_rx_bd),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(),\n    .card_status(status_reg[4:0]),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(dat_in_m_tx_bd),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(sd_dat_out_o),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(Bd_Status_reg[7:0]),\n    .re_s(we_m_rx_bd),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(Bd_Status_reg[15:8]),\n    .re_s(we_m_tx_bd),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(sd_dat_out_o),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\nassign m_wb_sel_o = 4'b1111;\n\n// Interrupt logic\nassign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) != 0;\nassign int_b = (error_int_status_reg & error_int_signal_enable_reg) != 0;\nassign int_c = (Bd_isr_reg & Bd_isr_enable_reg) != 0;\n\n// Register update logic\nassign cmd_int_busy = (cmd_int_busy && !int_ack) || new_cmd;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 18, "code": "module sdc_controller(\n    // Wishbone interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Master Wishbone interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n\n    // SDC interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n\n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n// Internal signals\nwire            we_m_tx_bd;\nwire            we_m_rx_bd;\nwire            new_cmd;\nwire            we_ack;\nwire            int_ack;\nwire            cmd_int_busy;\nwire            int_busy;\nwire            write_req_s;\nwire [15:0]     cmd_set_s;\nwire [31:0]     cmd_arg_s;\nwire [31:0]     argument_reg;\nwire [15:0]     cmd_setting_reg;\nwire [15:0]     status_reg;\nwire [31:0]     cmd_resp_1;\nwire [7:0]      software_reset_reg;\nwire [15:0]     time_out_reg;\nwire [15:0]     normal_int_status_reg;\nwire [15:0]     error_int_status_reg;\nwire [15:0]     normal_int_signal_enable_reg;\nwire [15:0]     error_int_signal_enable_reg;\nwire [7:0]      clock_divider;\nwire [15:0]     Bd_Status_reg;\nwire [7:0]      Bd_isr_reg;\nwire [7:0]      Bd_isr_enable_reg;\nwire            bd_isr_reset;\nwire            normal_isr_reset;\nwire            error_isr_reset;\nwire [31:0]     dat_in_m_tx_bd;\nwire [31:0]     dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(write_req_s),\n    .data_read(~write_req_s),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(int_ack),\n    .cmd_out(sd_cmd_out_o),\n    .req_out(sd_cmd_oe_o),\n    .ack_out(sd_cmd_oe_o),\n    .req_in(sd_cmd_dat_i),\n    .ack_in(sd_cmd_dat_i),\n    .cmd_in(sd_cmd_dat_i),\n    .serial_status(sd_cmd_dat_i),\n    .card_detect(sd_cmd_dat_i)\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(wb_clk_i),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(sd_cmd_out_o),\n    .REQ_IN(sd_cmd_oe_o),\n    .ACK_IN(sd_cmd_dat_i),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(sd_cmd_oe_o),\n    .REQ_OUT(sd_cmd_oe_o),\n    .STATUS(serial_status),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t(st_dat_t)\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(Bd_Status_reg[15:8]),\n    .ack_i_s_tx(ack_i_s_tx),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(Bd_Status_reg[7:0]),\n    .ack_i_s_rx(ack_i_s_rx),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(cmd_tsf_err),\n    .card_status(card_status),\n    .tx_empt(tx_empt),\n    .tx_full(tx_full),\n    .rx_full(rx_full),\n    .busy_n(busy_n),\n    .transm_complete(transm_complete),\n    .crc_ok(crc_ok),\n    .Dat_Int_Status_rst(Dat_Int_Status_rst),\n    .transfer_type(transfer_type),\n    .re_s_tx(re_s_tx),\n    .a_cmp_tx(a_cmp_tx),\n    .re_s_rx(re_s_rx),\n    .a_cmp_rx(a_cmp_rx),\n    .we_req(we_req),\n    .d_write(d_write),\n    .d_read(d_read),\n    .cmd_arg(cmd_arg),\n    .cmd_set(cmd_set),\n    .start_tx_fifo(start_tx_fifo),\n    .start_rx_fifo(start_rx_fifo),\n    .sys_adr(sys_adr),\n    .ack_transfer(ack_transfer),\n    .Dat_Int_Status(Dat_Int_Status),\n    .CIDAT(CIDAT)\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(dat_in_m_tx_bd),\n    .start_dat(start_dat),\n    .ack_transfer(ack_transfer),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(rd),\n    .data_out(sd_dat_out_o),\n    .we(we),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(busy_n),\n    .transm_complete(transm_complete),\n    .crc_ok(crc_ok)\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(Bd_Status_reg[15:8]),\n    .re_s(re_s_tx),\n    .ack_o_s(ack_i_s_tx),\n    .a_cmp(a_cmp_tx),\n    .dat_out_s(dat_out_s)\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(Bd_Status_reg[7:0]),\n    .re_s(re_s_rx),\n    .ack_o_s(ack_i_s_rx),\n    .a_cmp(a_cmp_rx),\n    .dat_out_s(dat_out_s)\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(start_tx_fifo),\n    .adr(sys_adr),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(sd_dat_out_o),\n    .rd(re_s_tx),\n    .empty(tx_empt),\n    .fe(tx_full)\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(start_rx_fifo),\n    .adr(sys_adr),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(re_s_rx),\n    .full(rx_full)\n);\n\n// Master Wishbone interface control\nassign m_wb_sel_o = 4'b1111;\nassign m_wb_cyc_o = (start_tx_fifo) ? u_sd_fifo_tx_filler.m_wb_cyc_o : (start_rx_fifo) ? u_sd_fifo_rx_filler.m_wb_cyc_o : 1'b0;\nassign m_wb_stb_o = (start_tx_fifo) ? u_sd_fifo_tx_filler.m_wb_stb_o : (start_rx_fifo) ? u_sd_fifo_rx_filler.m_wb_stb_o : 1'b0;\nassign m_wb_cti_o = (start_tx_fifo) ? u_sd_fifo_tx_filler.m_wb_cti_o : (start_rx_fifo) ? u_sd_fifo_rx_filler.m_wb_cti_o : 3'b000;\nassign m_wb_bte_o = (start_tx_fifo) ? u_sd_fifo_tx_filler.m_wb_bte_o : (start_rx_fifo) ? u_sd_fifo_rx_filler.m_wb_bte_o : 2'b00;\nassign m_wb_we_o = (start_tx_fifo) ? u_sd_fifo_tx_filler.m_wb_we_o : (start_rx_fifo) ? u_sd_fifo_rx_filler.m_wb_we_o : 1'b0;\nassign m_wb_adr_o = (start_tx_fifo) ? u_sd_fifo_tx_filler.m_wb_adr_o : (start_rx_fifo) ? u_sd_fifo_rx_filler.m_wb_adr_o : 32'd0;\nassign m_wb_dat_o = (start_tx_fifo) ? u_sd_fifo_tx_filler.m_wb_dat_o : (start_rx_fifo) ? u_sd_fifo_rx_filler.m_wb_dat_o : 32'd0;\n\n// Register update\nassign cmd_int_busy = (new_cmd) ? 1'b1 : (int_ack) ? 1'b0 : cmd_int_busy;\nassign Bd_Status_reg[15:8] = (we_m_tx_bd) ? Bd_Status_reg[15:8] - 1 : (a_cmp_tx) ? Bd_Status_reg[15:8] + 1 : Bd_Status_reg[15:8];\nassign Bd_Status_reg[7:0] = (we_m_rx_bd) ? Bd_Status_reg[7:0] - 1 : (a_cmp_rx) ? Bd_Status_reg[7:0] + 1 : Bd_Status_reg[7:0];\nassign status_reg[0] = (cmd_int_busy) ? 1'b1 : STATUS_REG[0];\nassign status_reg[15:1] = STATUS_REG[15:1];\nassign status_reg[1] = (CIDAT) ? 1'b1 : 1'b0;\nassign normal_int_status_reg = NORMAL_INT_REG;\nassign error_int_status_reg = ERR_INT_REG;\nassign Bd_isr_reg = Dat_Int_Status;\nassign Bd_isr_enable_reg = Bd_isr_enable_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 19, "code": "module sdc_controller(\n    // Wishbone interface\n    input         wb_clk_i,\n    input         wb_rst_i,\n    input  [3:0]  wb_sel_i,\n    input  [31:0] wb_dat_i,\n    output [31:0] wb_dat_o,\n    input  [7:0]  wb_adr_i,\n    input         wb_we_i,\n    input         wb_cyc_i,\n    input         wb_stb_i,\n    output        wb_ack_o,\n\n    // Master Wishbone interface\n    output [31:0] m_wb_adr_o,\n    output        m_wb_sel_o,\n    output        m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input  [31:0] m_wb_dat_i,\n    output        m_wb_cyc_o,\n    output        m_wb_stb_o,\n    input         m_wb_ack_i,\n    output [2:0]  m_wb_cti_o,\n    output [1:0]  m_wb_bte_o,\n\n    // SDC interface\n    input         sd_cmd_dat_i,\n    output        sd_cmd_out_o,\n    output        sd_cmd_oe_o,\n    input  [3:0]  sd_dat_dat_i,\n    output [3:0]  sd_dat_out_o,\n    output        sd_dat_oe_o,\n    output        sd_clk_o_pad,\n    input         sd_clk_i_pad,\n\n    // Interrupts\n    output        int_a,\n    output        int_b,\n    output        int_c\n);\n\n// Internal signals\nwire            we_m_tx_bd;\nwire            we_m_rx_bd;\nwire            new_cmd;\nwire            we_ack;\nwire            int_ack;\nwire            cmd_int_busy;\nwire            int_busy;\nwire            write_req_s;\nwire [15:0]     cmd_set_s;\nwire [31:0]     cmd_arg_s;\nwire [31:0]     argument_reg;\nwire [15:0]     cmd_setting_reg;\nwire [15:0]     status_reg;\nwire [31:0]     cmd_resp_1;\nwire [7:0]      software_reset_reg;\nwire [15:0]     time_out_reg;\nwire [15:0]     normal_int_status_reg;\nwire [15:0]     error_int_status_reg;\nwire [15:0]     normal_int_signal_enable_reg;\nwire [15:0]     error_int_signal_enable_reg;\nwire [7:0]      clock_divider;\nwire [15:0]     Bd_Status_reg;\nwire [7:0]      Bd_isr_reg;\nwire [7:0]      Bd_isr_enable_reg;\nwire            bd_isr_reset;\nwire            normal_isr_reset;\nwire            error_isr_reset;\nwire [31:0]     dat_in_m_tx_bd;\nwire [31:0]     dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb(\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider(\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(write_req_s),\n    .data_read(~write_req_s),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(int_ack),\n    .cmd_out(sd_cmd_out_o),\n    .req_out(sd_cmd_oe_o),\n    .ack_out(),\n    .req_in(),\n    .ack_in(),\n    .cmd_in(sd_cmd_dat_i),\n    .serial_status(),\n    .card_detect()\n);\n\nsd_cmd_serial_host u_sd_cmd_serial_host(\n    .SD_CLK_IN(sd_clk_o_pad),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(sd_cmd_out_o),\n    .REQ_IN(sd_cmd_oe_o),\n    .ACK_IN(),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(sd_cmd_oe_o),\n    .REQ_OUT(),\n    .STATUS(),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t()\n);\n\nsd_data_master u_sd_data_master(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(Bd_Status_reg[15:8]),\n    .ack_i_s_tx(),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(Bd_Status_reg[7:0]),\n    .ack_i_s_rx(),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(),\n    .card_status(),\n    .tx_empt(),\n    .tx_full(),\n    .rx_full(),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok(),\n    .Dat_Int_Status_rst(),\n    .transfer_type(),\n    .re_s_tx(),\n    .a_cmp_tx(),\n    .re_s_rx(),\n    .a_cmp_rx(),\n    .we_req(),\n    .d_write(),\n    .d_read(),\n    .cmd_arg(),\n    .cmd_set(),\n    .start_tx_fifo(),\n    .start_rx_fifo(),\n    .sys_adr(),\n    .ack_transfer(),\n    .Dat_Int_Status(),\n    .CIDAT()\n);\n\nsd_data_serial_host u_sd_data_serial_host(\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(),\n    .start_dat(),\n    .ack_transfer(),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(),\n    .data_out(),\n    .we(),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(),\n    .transm_complete(),\n    .crc_ok()\n);\n\nrx_bd u_rx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(Bd_Status_reg[7:0]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\ntx_bd u_tx_bd(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(Bd_Status_reg[15:8]),\n    .re_s(),\n    .ack_o_s(),\n    .a_cmp(),\n    .dat_out_s()\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(),\n    .rd(),\n    .empty(),\n    .fe()\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler(\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(),\n    .adr(),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(),\n    .full()\n);\n\n// Assign outputs\nassign m_wb_sel_o = 4'b1111;\n\n// Interrupt logic\nassign int_a = normal_int_status_reg & normal_int_signal_enable_reg;\nassign int_b = error_int_status_reg & error_int_signal_enable_reg;\nassign int_c = Bd_isr_reg & Bd_isr_enable_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 20, "code": "module sdc_controller(\n    // Wishbone interface\n    input  wire            wb_clk_i,\n    input  wire            wb_rst_i,\n    input  wire    [3:0]   wb_sel_i,\n    input  wire   [31:0]   wb_dat_i,\n    output wire   [31:0]   wb_dat_o,\n    input  wire    [7:0]   wb_adr_i,\n    input  wire            wb_we_i,\n    input  wire            wb_cyc_i,\n    input  wire            wb_stb_i,\n    output wire            wb_ack_o,\n\n    // Master Wishbone interface\n    output wire   [31:0]   m_wb_adr_o,\n    output wire            m_wb_sel_o,\n    output wire            m_wb_we_o,\n    output wire   [31:0]   m_wb_dat_o,\n    input  wire   [31:0]   m_wb_dat_i,\n    output wire            m_wb_cyc_o,\n    output wire            m_wb_stb_o,\n    input  wire            m_wb_ack_i,\n    output wire            m_wb_cti_o,\n    output wire            m_wb_bte_o,\n\n    // SDC interface\n    input  wire            sd_cmd_dat_i,\n    output wire            sd_cmd_out_o,\n    output wire            sd_cmd_oe_o,\n    input  wire    [3:0]   sd_dat_dat_i,\n    output wire    [3:0]   sd_dat_out_o,\n    output wire            sd_dat_oe_o,\n    output wire            sd_clk_o_pad,\n\n    // Interrupts\n    output wire            int_a,\n    output wire            int_b,\n    output wire            int_c,\n\n    // Card detect\n    input  wire            card_detect\n);\n\n    // Internal signals\n    wire            we_m_tx_bd;\n    wire            we_m_rx_bd;\n    wire            new_cmd;\n    wire            we_ack;\n    wire            int_ack;\n    wire            cmd_int_busy;\n    wire            int_busy;\n    wire            write_req_s;\n    wire    [15:0]  cmd_set_s;\n    wire    [31:0]  cmd_arg_s;\n    wire    [31:0]  argument_reg;\n    wire    [15:0]  cmd_setting_reg;\n    wire    [15:0]  status_reg;\n    wire    [31:0]  cmd_resp_1;\n    wire     [7:0]  software_reset_reg;\n    wire    [15:0]  time_out_reg;\n    wire    [15:0]  normal_int_status_reg;\n    wire    [15:0]  error_int_status_reg;\n    wire    [15:0]  normal_int_signal_enable_reg;\n    wire    [15:0]  error_int_signal_enable_reg;\n    wire     [7:0]  clock_divider;\n    wire    [15:0]  Bd_Status_reg;\n    wire     [7:0]  Bd_isr_reg;\n    wire     [7:0]  Bd_isr_enable_reg;\n    wire            bd_isr_reset;\n    wire            normal_isr_reset;\n    wire            error_isr_reset;\n    wire    [31:0]  dat_in_m_tx_bd;\n    wire    [31:0]  dat_in_m_rx_bd;\n\n    // Instantiate sd_controller_wb\n    sd_controller_wb u_sd_controller_wb(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Instantiate sd_clock_divider\n    sd_clock_divider u_sd_clock_divider(\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // Instantiate sd_cmd_master\n    sd_cmd_master u_sd_cmd_master(\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(write_req_s),\n        .data_read(~write_req_s),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(cmd_set_s),\n        .go_idle_o(int_ack),\n        .cmd_out(sd_cmd_out_o),\n        .req_out(sd_cmd_oe_o),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(sd_cmd_dat_i),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n\n    // Instantiate sd_cmd_serial_host\n    sd_cmd_serial_host u_sd_cmd_serial_host(\n        .SD_CLK_IN(wb_clk_i),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_set_s),\n        .CMD_IN(sd_cmd_out_o),\n        .REQ_IN(sd_cmd_oe_o),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(sd_cmd_out_o),\n        .ACK_OUT(),\n        .REQ_OUT(sd_cmd_oe_o),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n\n    // Instantiate sd_data_master\n    sd_data_master u_sd_data_master(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(Bd_Status_reg[15:8]),\n        .ack_i_s_tx(),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(Bd_Status_reg[7:0]),\n        .ack_i_s_rx(),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(),\n        .card_status(status_reg[4:0]),\n        .tx_empt(),\n        .tx_full(),\n        .rx_full(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok(),\n        .Dat_Int_Status_rst(),\n        .transfer_type(),\n        .re_s_tx(),\n        .a_cmp_tx(),\n        .re_s_rx(),\n        .a_cmp_rx(),\n        .we_req(),\n        .d_write(),\n        .d_read(),\n        .cmd_arg(),\n        .cmd_set(),\n        .start_tx_fifo(),\n        .start_rx_fifo(),\n        .sys_adr(),\n        .ack_transfer(),\n        .Dat_Int_Status(),\n        .CIDAT()\n    );\n\n    // Instantiate sd_data_serial_host\n    sd_data_serial_host u_sd_data_serial_host(\n        .sd_clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .data_in(),\n        .start_dat(),\n        .ack_transfer(),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(),\n        .data_out(),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok()\n    );\n\n    // Instantiate tx_bd\n    sd_bd u_tx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(Bd_Status_reg[15:8]),\n        .re_s(),\n        .ack_o_s(),\n        .a_cmp(),\n        .dat_out_s()\n    );\n\n    // Instantiate rx_bd\n    sd_bd u_rx_bd(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(Bd_Status_reg[7:0]),\n        .re_s(),\n        .ack_o_s(),\n        .a_cmp(),\n        .dat_out_s()\n    );\n\n    // Instantiate sd_fifo_tx_filler\n    sd_fifo_tx_filler u_sd_fifo_tx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(),\n        .adr(),\n        .sd_clk(wb_clk_i),\n        .dat_o(),\n        .rd(),\n        .empty(),\n        .fe()\n    );\n\n    // Instantiate sd_fifo_rx_filler\n    sd_fifo_rx_filler u_sd_fifo_rx_filler(\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(),\n        .adr(),\n        .sd_clk(wb_clk_i),\n        .dat_i(sd_dat_dat_i),\n        .wr(),\n        .full()\n    );\n\n    // Assign m_wb_sel_o\n    assign m_wb_sel_o = 4'b1111;\n\n    // Assign int_a, int_b, int_c\n    assign int_a = normal_int_status_reg[0];\n    assign int_b = error_int_status_reg[0];\n    assign int_c = Bd_isr_reg[0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 20, "code": "// sd_clock_divider module\nmodule sd_clock_divider(\n    input           CLK,     // input clock signal\n    input   [7:0]   DIVIDER, // division ratio\n    input           RST,     // asynchronous reset signal\n    output          SD_CLK   // output clock signal\n);\n\nreg [7:0] counter; // counter to divide the clock\n\nalways @ (posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 8'd0; // reset counter to 0\n        SD_CLK <= 1'b0;  // reset output clock to 0\n    end else begin\n        if (counter == DIVIDER) begin\n            counter <= 8'd0; // reset counter to 0\n            SD_CLK <= ~SD_CLK; // toggle output clock\n        end else begin\n            counter <= counter + 8'd1; // increment counter\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
