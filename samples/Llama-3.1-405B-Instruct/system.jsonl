{"task": "sdc_controller", "codeid": 1, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 2, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals and variables\nlogic [7:0] reg_data;\n\n// Sequential logic (registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic (assign output)\nalways_comb begin\n    data_out = reg_data;\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 3, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] reg_data;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'b0;\n    end else begin\n       _data <= data_in;\n    end\nend\n\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 4, "code": "module example_module(\n    input  logic        clk,\n    input  logic        rst_n,\n    input  logic [7:0]  data_in,\n    output logic [7:0]  data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 5, "code": "// Top-level module declaration\nmodule hardware_module(\n    // Input ports\n    input  logic clk,          // Clock signal\n    input  logic rst_n,        // Active-low reset\n    input  logic [7:0] data_in, // 8-bit input data\n    // Output ports\n    output logic [7:0] data_out // 8-bit output data\n);\n\n// Internal signals and variables\nlogic [7:0] internal_reg;\n\n// Combinational logic\nalways_comb begin\n    data_out = internal_reg;\nend\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_reg <= 8'd0; // Reset to zero\n    end else if (clk) begin\n        internal_reg <= data_in; // Capture input on rising clock edge\n    end\nend\n\nendmodule : hardware_module", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 6, "code": "// Define the module\nmodule example_module(\n    input  logic clk,       // Clock signal\n    input  logic reset_n,   // Active-low reset\n    input  logic [7:0] data_in, // 8-bit input data\n    output logic [7:0] data_out // 8-bit output data\n);\n\n// Internal signals\nlogic [7:0] reg_data; // 8-bit registered data\n\n// Sequential logic\nalways_ff @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        // Reset condition\n        reg_data <= 8'd0;\n    end else begin\n        // Normal operation\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = reg_data;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 7, "code": "module example_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals and registers\nlogic [7:0] internal_reg;\n\n// Sequential logic (registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_reg <= 8'd0; // Reset to zero\n    end else begin\n        internal_reg <= data_in; // Capture input data\n    end\nend\n\n// Combinational logic (assign output)\nalways_comb begin\n    data_out = internal_reg; // Assign registered value to output\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 8, "code": "// Define the module (replace with your actual module name and ports)\nmodule my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Declare internal signals (if any)\nlogic [7:0] internal_reg;\n\n// Always block for sequential logic (e.g., register)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'd0; // Reset value\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Continuous assignment (if needed)\nassign data_out = internal_reg;\n\n// Combinational logic (if needed)\n// always_comb begin\n//     // Example: data_out = data_in + 1;\n// end\n\nendmodule : my_module\n// Alternative example: A simple 8-bit counter\nmodule counter(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] count_out\n);\n\nlogic [7:0] count_reg;\n\n_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count_reg <= 8'd0;\n    end else begin\n        count_reg <= count_reg + 8'd1;\n    end\nend\n\nassign count_out = count_reg;\n\nendmodule : counter", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 9, "code": "// Module Description: [Enter brief description of the module's functionality]\n\nmodule [ModuleName] (  // Replace with actual module name and ports\n    input  logic       clk,           // Clock input\n    input  logic       rst_n,         // Active-low reset\n    input  logic [3:0] data_in,       // 4-bit input data\n    output logic [7:0] data_out       // 8-bit output data\n);\n\n// Internal signals and variables\nlogic [7:0] internal_reg; // 8-bit internal register\n\n// Combinational logic\nalways_comb begin\n    case (data_in)\n        4'b0000: data_out = 8'b00000000;\n        4'b0001: data_out = 8'b00000001;\n        4'b0010: data_out = 8'b00000010;\n        4'b0011: data_out = 8'b00000011;\n        4'b0100: data_out = 8'b00000100;\n        4'b0101: data_out = 8'b00000101;\n        4'b0110: data_out = 8'b00000110;\n        4'b0111: data_out = 8'b00000111;\n        4'b1000: data_out = 8'b00001000;\n        4'b1001: data_out = 8'b00001001;\n        'b1010: data_out = 8'b00001010;\n        4'b1011: data_out = 8'b00001011;\n        4'b1100: data_out = 8'b00001100;\n        4'b1101: data_out = 8'b00001101;\n        4'b1110: data_out = 8'b00001110;\n        4'b1111: data_out = 8'b00001111;\n        default: data_out = 8'b00000000; // Default case\n    endcase\nend\n\n// Sequential logic (if any)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'b0;\n    end else begin\n        internal_reg <= data_out; // Example sequential operation\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 10, "code": "// Define a simple AND gate module\nmodule and_gate(\n    input  logic a,\n    input  logic b,\n    output logic result\n);\n    assign result = a && b;\nendmodule\n\n// Define a simple D Flip-Flop module\nmodule d_flipflop(\n    input  logic clk,    // Clock signal\n    input  logic reset,  // Active-high reset\n    input  logic d,      // Data input\n    output logic q       // Data output\n);\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\nendmodule\n\n// Define a 2-to-1 Multiplexer module\nmodule mux2to1(\n    input  logic sel,     // Select line\n    input  logic a,       // Input 0\n    input  logic b,       // Input 1\n    output logic result   // Output\n);\n    assign result = sel ? b : a;\nendmodule\n\n// Define a 4-bit Adder module\nmodule adder4bit(\n    input  logic [3:0] a,\n    input  logic [3:0] b,\n    output logic [3:0] sum,\n    output logic        carry\n);\n    assign {carry, sum} = a + b;\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 11, "code": "module example_module(\n  input  logic clk,\n  input  logic rst_n,\n  input  logic [7:0] data_in,\n  output logic [70] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n  if (!rst_n) begin\n    data_out <= 8'd0;\n  end else begin\n    data_out <= data_in;\n  end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 12, "code": "module example_module(\n    input       clk,\n    input       rst_n,\n    input       en,\n    output      [7:0] data_out\n);\n\nreg [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else if (en) begin\n        data_reg <= data_reg + 1'b1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 13, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 14, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_reg;\n\n// Sequential logic (registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_reg <= 80;\n    end else begin\n        internal_reg <= data_in;\n    end\nend\n\n// Combinatorial logic (output assignment)\nalways_comb begin\n    data_out = internal_reg;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 15, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n)\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 16, "code": "// Example Verilog Module (Replace with actual description)\nmodule example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals (if any)\nlogic [7:0] reg_data;\n\n// Sequential logic (if any)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nalways_comb begin\n    data_out = reg_data;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 17, "code": "// Verilog Module Example\nmodule example_module(\n    input  logic clk,    // Clock signal\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0]  data_in,  // 8-bit input data\n    output logic [7:0]  data_out  // 8-bit output data\n);\n\n// Internal signals and variables\nlogic [7:0] internal_reg;\n\n// Combinational logic\nalways_comb begin\n    data_out = internal_reg;\nend\n\n// Sequential logic (flip-flop)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_reg <= 8'd0;  // Reset to zero\n    end else begin\n        internal_reg <= data_in;  // Load data_in on positive clock edge\n    end\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 18, "code": "// Define a module named my_module with no inputs or outputs\nmodule my_module();\n\n    // Local variables\n    reg [7:0] data;\n    wire [7:0] result;\n\n    // Instantiate another module (e.g., adder)\n    adder inst1(\n        .in1(data), \n        .in2(8'b00000001), \n        .out(result)\n    );\n\n    // Example logic\n    initial begin\n        data = 8'b00000000;\n        #10 data = 8'b11111111;\n    end    // Continuous assignment\n    assign result = data + 1'b1;\n\nendmodule\n\n// Example of another module (e.g., an adder)\nmodule adder(\n    input [7:0] in1,\n    input [7:0] in2,\n    output [7:0] out\n);\n\n    assign out = in1 + in2;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 19, "code": "// Module Definition\nmodule my_module(\n    input  logic clk,  // Clock input\n    input  logic rst_n, // Active-low reset\n    input  logic [7:0] data_in,  // 8-bit input data\n    output logic [7:0] data_out  // 8-bit output data\n);\n\n// Internal Signals\nlogic [7:0] reg_data; // 8-bit register for data storage\n\n// Combinational Logic\nalways_comb begin\n    data_out = reg_data;\nend\n\n// Sequential Logic (Clock-Driven)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // Reset condition: Clear the register\n        reg_data <= 8'd0;\n    end else begin\n        // Normal operation: Update the register with input data\n        reg_data <= data_in;\n    end\nend\n\nendmodule : my_module", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 20, "code": "// Example Verilog Module (Replace with your actual design)\nmodule my_module(\n    input clk,     // Clock signal\n    input reset_n, // Active-low reset\n    input [7:0] data_in, // 8-bit input data\n    output [7:0] data_out // 8-bit output data\n);\n\nreg [7:0] internal_data;\n\nalways @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n        internal_data <= 0;\n    end else begin\n        internal_data <= data_in;\n    end\nend\n\nassign data_out = internal_data;\n\nendmodule\n[Your Verilog code here]", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 1, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [:0] key,\n    input127:0]_in,\n    output127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    wire [7:0] sbox_out[0:15];\n    wire [31:0] rkey[0:3];\n\n    // Instantiate S-Box modules\n    genvar i;\n    generate\n        for (i = 0; i < 16; i++) begin\n            aes_sbox sbox_inst (\n                .a(text_in_r[8*i +: 8]),\n                .b(sbox_out[i])\n            );\n        end\n    endgenerate\n\n    // Instantiate key expansion module\n    aes_key_expand_128 key_expand (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(rkey[0]),\n        .wo_1(rkey[1]),\n        .wo_2(rkey[2]),\n        .wo_3(rkey[3])\n    );\n\n    // Main operation logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            dcnt <= 4'b1101; // Initial round count 11 (10 rounds + initial)\n            text_in_r <= 128'd0;\n            ld_r <= 'b0;\n            <= 1'b;\n        end else begin\n            if (ld && !ld_r) begin // Load data\n                text_in_r <= text_in;\n                ld_r <= 1'b1;\n                dcnt <= 4'b1101;\n            end else if (ld_r && dcnt != 4'b0000) begin\n                // Perform round operations\n                if (dcnt != 4'b0001) begin // Rounds 1-9\n                    // SubBytes\n                    for (int j = 0; j < ; j++) begin                        sa[j / 4][j % 4] <= sbox_out[j];\n                    end\n\n                    // ShiftRows (hardcoded shifts)\n                    sa[1][0] <= sa[1][1];\n                    sa[1][1] <= sa[1][2];\n                    sa[1][2] <= sa[1][3];\n                    sa[1][3] <= sa[1][0];\n\n                    sa[2][0] <= sa[2][2];\n                    sa[2][1] <= sa[2][3];\n                    sa[2][2] <= sa[2][0];\n                    sa[2][3] <= sa[2][1];\n\n                    sa[3][0] <= sa[3][3];\n                    sa[3][1] <= sa[3][0];\n                    sa[3][2 <= sa[3][1                    sa[3][3] <=[3][2];\n\n // MixColumns (only rounds 1-9)\n                    for (int k = 0; k < 4; k++) begin\n                        reg [7:0] col[0:3];\n                        col[0] <= (sa[k][0] << 1) ^ (sa[k][1] << 1) ^ sa[k][2] ^ sa[k][3];\n                        col[1] <= (sa[k][1] << 1) ^ (sa[k][2] << 1) ^ sa[k][3] ^ sa[k][0];\n                        col[2] <= (sa[k][2] << 1) ^ (sa[k][3] << 1) ^ sa[k][0] ^ sa[k][1];\n                        col[3] <= (sa[k][3] << 1) ^ (sa[k][0] << 1) ^ sa[k][1] ^ sa[k][2];\n                        sa[k][0] <= col[0];\n                        sa[k][1] <= col[1];\n                        sa[k][2] <= col[2];\n                        sa[k][3] <= col[3];\n                    end\n\n                    // AddRoundKey\n                    for (int m = 0; m < 16; m++) begin\n                        sa[m / 4][m % 4] <= sa[m / 4][m % 4] ^ rkey[m % 4][8*(m / 4) +: 8];\n                    end\n                end else begin // Final round (round 10)\n                    // SubBytes\n                    for (int j = 0; j < 16; j++) begin\n                        sa[j / 4][j % 4] <= sbox_out[j];\n                    end\n\n                    // ShiftRows (same as above)\n                    sa[1][0] <= sa[1][1];\n                    sa[1][1] <= sa[1][2];\n                    sa[1][2] <= sa[1][3];\n                    sa[1][3] <= sa[1][0];\n\n                    sa[2][0] <= sa[2][2];\n                    sa[2][1] <= sa[2][3];\n                    sa[2][2] <= sa[2][0];\n                    sa[2][3] <= sa[2][1];\n\n                    sa[3][0] <= sa[3][3];\n                    sa[3][1] <= sa[3][0];\n                    sa[3][2] <= sa[3][1];\n                    sa[3][3] <= sa[3][2];\n\n                    // AddRoundKey (no MixColumns in final round)\n                    for (int m = 0; m < 16; m++) begin\n                        sa[m / 4][m % 4] <= sa[m / 4][m % 4] ^ rkey[m % 4][8*(m / 4) +: 8];\n                    end\n                end\n\n                // Update output\n                for (int n = 0; n < 16; n++) begin\n                    text_out[8*n +: 8] <= sa[n / 4][n % 4];\n                end\n\n                dcnt <= dcnt - 1'b1;\n            end\n\n            if (!ld && dcnt == 4'b0000) begin\n                done <= 1'b1;\n            end else begin\n                done <= 10;\n            end\n        end\n    end\n\nendmodule\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w[0:3];\n    reg [3:0] rcnt;\n    [7:0] sbox_out[0:3];\n\n    // Instantiate S-Box modules\n    genvar i;\n    generate\n        for (i = 0; i < 4; i++) begin\n            aes_sbox sbox_inst (\n                .a(w[i][23:16]),\n                .b(sbox_out[i])\n            );\n        end\n    endgenerate\n\n    // Main operation logic\n    always @(posedge clk) begin\n        if (kld) begin\n            // Initial key loading\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 4'b0000;\n            wo_0 <= w[0];\n            wo_1 <= w[1];\n            wo_2 <= w[2];\n            wo_3 <= w[3];\n        end else if (!kld && rcnt < 10) begin\n            // Key expansion\n            w[0] <= w[0] ^ (sbox_out[0] << 24) ^ (sbox_out[1] << 16) ^ (sbox_out[2] << 8) ^ sbox_out[3];\n            w[1] <= w[1] ^ w[0];\n            w[2] <= w[2] ^ w[1];\n            w[3] <= w[3] ^ w[2];\n            rcnt <= rcnt + 1'b1;\n            wo_0 <= w[0];\n            wo_1 <= w[1];\n            wo_2 <= w[2];\n            wo_3 <= w[3];\n        end\n    end\n\nendmodule\n// aes_sbox module (using lookup table)\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox[256];\n\n    initial begin\n        // Initialize S-box values (example entries)\n        sbox[0x00] = 8'h63; // Substitution for 0x00\n        sbox[0x01] = 8'h7c;\n        sbox[0x02] = 8'h77;\n        sbox[0x03] = 8'h7b;\n        // ... Add all 256 entries (simplified here)\n        // In practice, use a script or tool to generate the complete S-box\n        sbox[0xff] = 8'h16; // Substitution for 0xFF\n    end\n\n    assign b = sbox[a];\n\nendmodule\n// aes_rcon module (simplified round constant generator)\nmodule aes_rcon(\n    input clk    input kld,\n    output [31:0] out\n    reg [3:0] rcnt;\n    initial out = 32'h01000000; // Initial value\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01000000;\n        end else if (!kld) begin\n            rcnt <= rcnt + 1'b1;\n            case (rcnt)\n                4'b0000: out <= 32'h01000000;\n                4'b0001: out <= 32'h02000000;\n                4'b0010: out <= 32'h04000000;\n                4'b0011: out <= 32'h08000000;\n                4'b0100: out <= 32'h10000000;\n                4'b0101: out <= 32'h20000000;\n                4'b0110: out <= 32'h40000000;\n                4'b0111: out <= 32'h80000000;\n                4'b1000: out <= 32'h1b000000;\n                4'b1001: out <= 32'h36000000;\n                default: out <= 32'h00000000;\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 2, "code": "// aes_cipher_top Module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [3:0][3:0][7:0] sa; // 4x4 state matrix (column-major)\n    reg [3:0] dcnt; // Round counter (4-bit)\n    reg ld_r; // Load operation flag\n    reg [127:0] text_out; // Output ciphertext buffer\n\n    // Submodules instantiation\n    aes_key_expand_128 key_expand(\n        .clk(clk),\n        .kld(ld_r),\n        .key(key),\n        .wo_0(),\n        .wo_1(),\n        .wo_2(),\n        .wo_3()\n    );\n\n    // Internal signals (for debugging)\n    wire [7:0] sbox_out;\n    aes_sbox sbox_inst(.a(sa[0][0]), .b(sbox_out));\n\n    // Main logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            text_in_r <= 128'd0;\n            sa <= '{default: 8'd0};\n            dcnt <= 4'd11; // Initial round counter: 10 rounds + 1\n            ld_r <= 1'b0;\n            done <= 1'b0;\n            text_out <= 128'd0;\n        end else begin\n            // Initial round loading\n            if (ld) begin\n                text_in_r <= text_in;\n                ld_r <= 1'b1;\n            end\n            \n            if (ld_r) begin\n                // Initial round key addition\n                {sa[0][0], sa[1][0], sa[2][0], sa[3][0]} <= text_in_r[127:96] ^ key[127:96];\n                {sa[0][1], sa[1][1], sa[2][1], sa[3][1]} <= text_in_r[95:64] ^ key[95:64];\n                {sa[0][2], sa[1][2], sa[2][2], sa[3][2]} <= text_in_r[63:32] ^ key[63:32];\n                {sa[0][3], sa[1][3], sa[2][3], sa[3][3]} <= text_in_r[31:0] ^ key[31:0];\n                dcnt <= 4'd10; // Decrement for next round\n                ld_r <= 1'b0;\n            end else if (dcnt > 0) begin\n                // Round transformations\n                if (dcnt < 4'd10) begin\n                    // SubBytes\n                    for (int i=0; i<4; i++) begin\n                        for (int j=0; j<4; j++) begin\n                            sa[i][j] <= sbox(sbox_inst.b);\n                        end\n                    end\n                end else begin\n                    // ShiftRows\n                    // MixColumns (for rounds 1-9)\n                    // AddRoundKey (for all rounds)\n                end\n                dcnt <= dcnt - 1'b1;\n            end else begin\n                Final round (noColumns)\n                if (done == 1'b0) begin\n                    // Output formatting\n                    {text_out[127:96], text_out[95:64], text_out[63:32], text_out[31:0]} <= \n                        {sa[0][0], sa[1][0], sa[2][0], sa[3][0]}, \n                        {sa[0][1], sa[1][1], sa[2][1], sa[3][1]}, \n                        {sa[0][2], sa[1][2], sa[2][2], sa[3][2]}, \n                        {sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                    done <= 1'b1;\n                end\n            end\n        end\n    end\n\n    // S-box function (for SubBytes)\n    function [7:0] sbox;\n        input [7:0] in;\n        begin\n            // Implement S-box lookup table (256 entries)\n            // For simplicity, this is omitted and you would use a case statement\n            // or a ROM/LUT implementation in an actual design.\n            sbox = 8'd0; // Placeholder (replace with actual S-box logic)\n end\n    endfunction\n\nendmodule\n\n// aes_key_expand_128 Module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w[43:0]; // Expanded key words\n    reg [3:0] rcnt; // Round counter\n\n    aes_rcon rcon_inst(\n        .clk(clk),\n        .kld(kld),\n        .out()\n    );\n\n    aes_sbox sbox_inst(.a(), .b());\n\n    always @(posedge clk) begin\n        if (kld) begin\n            // Load initial key\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 4'd0;\n        end else begin\n            // Expand key\n            w[4] <= w[0] ^ (sbox(w[3][7:0]) << 24) ^ (sbox(w[3][15:8]) << 16) ^ (sbox(w[3][23:16]) << 8) ^ sbox(w[3][31:24]);\n            for (int i=5; i<=43; i++) begin\n                w[i] <= w[i-4] ^ w[i-1];\n            end\n            rcnt <= rcnt + 1'b1;\n        end\n    end\n\n    assign wo_0 = w[rcnt];\n    assign wo_1 = w[rcnt+1];\n    assign wo_2 = w[rcnt+2];\n    assign wo_3 = w[rcnt+3];\n\nendmodule\n\n// aes_sbox Module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table (256 entries)\n    // This is omitted for brevity and would be implemented as:\n    // case (a)\n    //     8'd0: b = 8'd63; // 0x00 -> 0x63\n    //     8'd1: b = 8'd16; // 0x01 -> 0x10\n    //     ...\n    //     8'd255: b = 8'd16; // 0xFF -> 0x10\n    // endcase\n\n    assign b = 8'd0; // Placeholder (replace with actual S-box logic)\n\nendmodule\n\n// aes_rcon Module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt; // Round counter\n    reg [7:0] rcon_val; // Round constant value\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'd0;\n            rcon_val <= 8'd1; // Initial value for RC[1]\n        end else begin\n            if (rcnt < 10) begin\n                rcnt <= rcnt + 1'b1;\n                rcon_val <= rcon_val << 1; // Multiply by 02 in GF(2^8)\n                if (rcon_val[7]) begin\n                    rcon_val <= (rcon_val & 8'h7F) ^ 8'h11b; // Reduction\n                end\n            end\n        end\n    end\n\n    assign out = {rcon_val, 24'd0};\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 3, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg ld_r;\nreg [127:0] text_out_r;\nwire done_comb;\n\n// Submodules\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(ld_r),\n    .key(key),\n    .wo_0(key0),\n    .wo_1(key1),\n    .wo_2(key2),\n    .wo_3(key3)\n);\n\n// Control logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        dcnt <= 4'b1101; // 11 in decimal (10 rounds + initial round)\n        ld_r <= 1'b0;\n        done <= 1'b0;\n        text_out <= 128'd0;\n    end else if (ld) begin\n        ld_r <= 1'b1;\n    end else begin\n        ld_r <= 1'b0;\n        if (ld_r) begin\n            text_in_r <= text_in;\n            dcnt <= 4'b1101; // Reset to initial value\n            done <= 1'b0;\n        end else if (dcnt > 4'b0000) begin\n            // Perform a round operation\n            dcnt <= dcnt - 4'b0001;\n            if (dcnt == 4'b0000) begin\n                done <= 1'b1;\n            end\n        end else begin\n            done <= 1'b1;\n        end\n    end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        text_in_r <= 128'd0;\n    end else if (ld) begin\n        text_in_r <= text_in;\n        // Initialize state matrix from input\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= text_in_r[i*32 + j*8 +: 8];\n            end\n        end\n    end else begin\n        // Perform round transformations here\n        if (ld_r) begin\n            // Initial round key addition\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ key[i*32 + j*8 +: 8];\n                end\n            end\n        end else if (dcnt > 0) begin\n            // SubBytes, ShiftRows, MixColumns, AddRoundKey\n            if (dcnt != 4'b0000) begin\n                // Perform MixColumns if not final round\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        // MixColumns implementation\n                        sa[i][j] <= mix_columns(sa[i][j], sa[(i+1)%4][j], sa[(i+2)%4][j], sa[(i+3)%4][j]);\n                    end\n                end\n            end\n            // AddRoundKey\n            for (int i = ; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ key[(dcnt-1)*4 + i*32 + j*8 +: 8];\n                end\n            end\n        end else begin\n            // Final round: SubBytes, ShiftRows, AddRoundKey\n            // Prepare output data\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out_r[i*32 + j*8 +: 8] <= sa[i][j];\n                end\n            end\n        end\n    end\nend\n\nassign text_out = text_out_r;\nassign done_comb = done;\n\n// AddRoundKey implementation\nfunction [7:0] add_round_key;\n    input [7:0] state_byte;\n    input [7:0] round_key_byte;\n    add_round_key = state_byte ^ round_key_byte;\nendfunction\n\n// MixColumns implementation\nfunction [7:0] mix_columns;\n    [7:0] s0, s1, s2, s3;\n    reg [7:0] out0, out1, out2, out3;\n    out0 = (s0 << 1) ^ s1 ^ s2 ^ s3;\n    out1 = s0 ^ (s1 << 1) ^ s2 ^ s3;\n    out2 = s0 s1 ^ (s2 << 1) ^ s3;\n    out3 = s0 ^ s1 ^ s2 ^ (s3 << 1);\n    mix_columns = {out0, out1, out2, out3};\nendfunction\n\nendmodule\n\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [3:0] rcnt;\nreg [31:0] w_reg[0:3];\n\n// Submodules\naes_rcon rcon(\n    .clk(clk),\n    .kld(kld),\n    .out(rcon_out)\n);\n\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 4'd0;\n        w_reg[0] <= key[127:96];\n        w_reg[1] <= key[95:64];\n        w_reg[2] <= key[63:32];\n        w_reg[3] <= key[31:0];\n    end else begin\n        rcnt <= rcnt + 4'd1;\n        w_reg[0] <= w_reg[3] ^ aes_sbox(w_reg[1][7:0]) ^ aes_sbox(w_reg[1][15:8]) ^ aes_sbox(w_reg[1][23:16]) ^ aes_sbox(w_reg[1][31:24]) ^ rcon_out;\n        w_reg[1] <= w_reg[0];\n        w_reg[2] <= w_reg[1];\n        w_reg[3] <= w_reg[2];\n    end\nend\n\nassign wo_0 = w_reg[0];\nassign wo_1 = w_reg[1];\nassign wo_2 = w_reg[2];\nassign wo_3 = w_reg[3];\n\nendmodule\n\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n// S-box lookup table implementation\nreg [7:0] sbox[0:255];\ninteger i;\ninitial begin\n    // Initialize S-box values here\n    for (i = 0; i < 256; i++) begin\n        // Implement S-box logic here\n        if (i == 0) sbox[i] = 8'd99; // Example, replace with actual S-box logic\n        else sbox[i] = i; // Placeholder\n    end\nend\n\nalways @(a) begin\n    b = sbox[a];\nend\n\nendmodule\n\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [7:0] rcon_out;\n\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 4'd0;\n        rcon_out <= 8'd1;\n    end else if (rcnt < 4'd9) begin\n        rcnt <= rcnt + 4'd1;\n        rcon_out <= rcon_out << 1;\n        if (rcon_out[7]) begin\n            rcon_out <= (rcon_out & 8'd11110000) ^ 8'd01100011;\n        end\n    end\nend\n\nassign out = {rcon_out, 24'd0};\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 4, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [0:3][0:3][7:0] sa;\nreg [3:0] dcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Internal signals\nwire [31:0] wo_0, wo_1, wo_2, wo_3;\nwire [7:0] sbox_out [0:15];\n\n// Instantiate submodules\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(ld),\n    .key(key),\n    .wo_0(wo_0),\n    .wo_1(wo_1),\n    .wo_2(wo_2),\n    .wo_3(wo_3)\n);\n\n// S-box array\ngenvar i;\ngenerate\n    for (i = 0; i < 16; i++) begin : sbox_array\n        aes_sbox sbox_inst(\n            .a(sa[i / 4][i % 4]),\n            .b(sbox_out[i])\n        );\n    end\nendgenerate\n\n// State machine logic\nalways @(*) begin\n    case(dcnt)\n        4'b0000: // Initial round\n            if (ld) begin\n                text_in_r = text_in;\n                dcnt = 4'b1010;\n            end\n        4'b1010: // Standard rounds (1-9)\n            if (ld_r) begin\n                // SubBytes\n                for (int i = 0; i < 16; i++) begin\n                    sa[i / 4][i % 4] = sbox_out[i];\n                end\n                \n                // ShiftRows\n                // MixColumns (except final round)\n                // AddRoundKey\n                dcnt = dcnt - 1;\n                if (dcnt == 0) begin\n                    dcnt = 4'b1000; // Final round\n                end\n            end\n        4'b1000: // Final round (round 10)\n            begin\n                // SubBytes\n                // ShiftRows\n                // AddRoundKey (no MixColumns)\n                dcnt = 4'b1111; // Done state\n            end\n        4'b1111: // Done state\n            done = 1'b1;\n        default: dcnt = 4'b0000;\n    endcase\nend\n\n// Data loading\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        ld_r <= 1'b0;\n    end else begin\n        ld_r <= ld;\n    end\nend\n\n// Output generation\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        text_out <= 128'd0;\n    end else if (dcnt == 4'b1111) begin\n        text_out <= {sa[0], sa[1], sa[2], sa[3]};\n    end\nend\n\nendmodule\n\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [31:0] w0, w1, w2, w3;\nreg [31:0] temp;\n\n// Round counter\nreg [3:0] rcnt;\n\n// S-box array\nwire [7:0] sbox_out [0:3];\ngenvar j;\ngenerate\n    for (j = 0; j < 4; j++) begin : sbox_array_key\n        aes_sbox sbox_inst(\n            .a(temp[8 * j +: 8]),\n            .b(sbox_out[j])\n        );\n    end\nendgenerate\n\n// Round constant generation\naes_rcon rcon_inst(\n    .clk(clk),\n    .kld(kld),\n    .out(rcon_out)\n);\n\n// Key loading\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        w0 <= key[127:96];\n        w1 <= key[95:64];\n        w2 <= key[63:32];\n        w3 <= key[31:0];\n        rcnt <= 4'b0000;\n    end\nend\n\n// Key expansion\nalways @(posedge clk) begin\n    if (!kld) begin\n        case(rcnt)\n            4'b0000: begin\n                temp = w3;\n                // RotWord\n                temp = {temp[24:0], temp[31:24]};\n                // SubWord\n                temp = {sbox_out[3], sbox_out[2], sbox_out[1], sbox_out[0]};\n                // XOR with round constant\n                temp = temp ^ rcon_out;\n                w0 <= w0 ^ temp;\n                w1 <= w1 ^ w0;\n                w2 <= w2 ^ w1;\n                w3 <= w3 ^ w2;\n                rcnt <= rcnt + 1;\n            end\n            default: begin\n                w0 <= w0 ^ w1;\n                w1 <= w1 ^ w2;\n                w2 <= w2 ^ w3;\n                w3 <= w3 ^ w0;\n                rcnt <= rcnt + 1;\n                if (rcnt == 9) begin\n                    rcnt <= 4'b1111;\n                end\n            end\n        endcase\n    end\nend\n\nassign wo_0 = w0;\nassign wo_1 = w1;\nassign wo_2 = w2;\nassign wo_3 = w3;\n\nendmodule\n\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table for S-box\nreg [7:0] sbox [0:255];\n\ninitial begin\n    // Initialize S-box values (omitted for brevity)\n    // This would load the actual S-box data into the sbox array\nend\n\nalways @(*) begin\n    b = sbox[a];\nend\n\nendmodule\n\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon_out;\n\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 4'b0000;\n        rcon_out <= 32'h01_00_00_00;\n    end else begin\n        if (rcnt < 10) begin\n            // Update round constant\n            // This would implement the GF(2^8) multiplication\n            rcnt <= rcnt + 1;\n            rcon_out <= {rcon_out[23:0], rcon_out[31:24]} ^ (rcnt == 4'b1001 ? 32'h1b_00_00_00 : 32'h00_00_00_00);\n        end\n    end\nend\n\nassign out = rcon_out;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 5, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input           clk,\n    input           rst,\n    input           ld,\n    output          done,\n    input   [127:0] key,\n    input   [127:0] text_in,\n    output  [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [3:0][3:0][7:0] sa;\n    reg [3:0] dcnt;\n    reg           ld_r;\n    reg [127:0] text_out;\n\n    // Submodules instantiation\n    aes_key_expand_128 key_expand(\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0( ),\n        .wo_1( ),\n        .wo_2( ),\n        .wo_3( )\n    );\n\n    // Main logic implementation\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            // Reset state\n            dcnt <= 4'd11;\n            ld_r <= 1'b0;\n            done <= 1'b0;\n            text_in_r <= 128'd0;\n            text_out <= 128'd0;\n            sa <= '{default: 8'd0};\n        end else if (ld) begin\n            // Initial round key addition\n            text_in_r <= text_in;\n            ld_r <= 1'b1;\n            dcnt <= 4'd11;\n        end else if (ld_r && (dcnt != 4'd0)) begin\n            // Perform round operations\n            case (dcnt)\n                // Rounds 1-9 (including MixColumns)\n                4'd11, 4'd10, 4'd9, 4'd8, 4'd7, 4'd6, 4'd5, 4'd4, 4'd3, 4'd2: begin\n                    // SubBytes, ShiftRows, MixColumns, AddRoundKey\n                    // (Implementation of these operations)\n                    dcnt <= dcnt - 4'd1;\n                end\n                // Final round (no MixColumns)\n                4'd1: begin\n                    // SubBytes, ShiftRows, AddRoundKey\n                    // (Implementation of these operations)\n                    dcnt <= 4'd0;\n                end\n                default: begin\n                    // Done state\n                    done <= 1'b1;\n                    text_out <= {sa[3][3], sa[2][3], sa[1][3], sa[0][3],\n                                 sa[3][2], sa[][2], sa[1][2], sa[0][2],\n                                 sa[3][1], sa[2][1], sa[1][1], sa[0][1],\n                                 sa[3][0], sa[2][0], sa[1][0], sa[0][0]};\n                end\n            endcase\n        end else if (!ld && (dcnt == 4'd0)) begin\n            // Idle state\n            done <= 1'b0;\n        end\n    end\n\nendmodule : aes_cipher_top\n\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input           clk,\n    input           kld,\n    input   [127:0] key,\n    output  [31:0] wo_0,\n    output  [31:0] wo_1,\n    output  [31:0] wo_2,\n    output  [31:0] wo_3\n);\n\n    reg [31:0] w[43:0];\n\n    // Round constant submodule\n    aes_rcon rcon(\n        .clk(clk),\n        .kld(kld),\n        .out(rcon_val)\n    );\n\n    wire [7:0] rcon_val;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            // Initialize first four words\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n        end else begin\n            // Key expansion\n            w[4] <= w[0] ^ ({8'd0, aes_sbox(w[1][7:0])}, aes_sbox(w[1][15:8]), aes_sbox(w[1][23:16]), aes_sbox(w[1][31:24])) ^ {24'd0, rcon_val};\n            w[5] <= w[1] ^ w[4];\n            w[6] <= w[2] ^ w[5];\n            w[7] <= w[3] ^ w[6];\n            // ... (Expand up to w[43])\n        end\n    end\n\n    assign wo_0 = w[0];\n    assign wo_1 = w[1];\n    assign wo_2 = w[2];\n    assign wo_3 = w[3];\n\nendmodule : aes_key_expand_128\n\n\n// aes_sbox module\nmodule aes_sbox(\n    input   [7:0] a,\n    output  [7:0] b\n);\n\n    // S-box lookup table (256 entries)\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box values (example, actual values not shown)\n        // sbox[0] = 8'd63; // 0x00 -> 0x63\n        // sbox[255] = 8'd16; // 0xFF -> 0x16\n        // ... (Populate all 256 entries)\n    end\n\n    assign b = sbox[a];\n\nendmodule : aes_sbox\n\n\n// aes_rcon module\nmodule aes_rcon(\n    input   clk,\n    input   kld,\n    output  [31:0] out\n);\n\n    reg [31:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            // Reset counter on key load\n            rcnt <= 32'd1;\n        end else if (!kld) begin\n            // Increment counter\n            rcnt <= rcnt << 1;\n            if (rcnt[7]) begin\n                rcnt <= (rcnt ^ 32'h11b) & 32'hff000000;\n            end\n        end\n    end\n\n    assign out = {30'd0, rcnt[7:0]};\n\nendmodule : aes_rcon", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 6, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    // Registers\n    reg [127:0] text_in_r;\n    reg [3:0][7:0] sa [0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // Submodules\n    aes_key_expand_128 key_expand(\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(),\n        .wo_1(),\n        .wo_2(),\n        .wo_3()\n    );\n\n    // Control logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            // Reset state\n            dcnt <= 11; // Initial round counter value\n            ld_r <= 0;\n            done <= 0;\n            text_in_r <= 0;\n            text_out <= 0;\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= 0;\n                end\n            end\n        end else begin\n            if (ld) begin\n                // Load operation\n                text_in_r <= text_in;\n                ld_r <= 1;\n                dcnt <= 11;\n            end else if (ld_r) begin\n                // Encryption process\n                if (dcnt == 10) begin\n                    // Final round\n                    // Perform SubBytes, ShiftRows, AddRoundKey\n                    // ...\n                    dcnt <= 0;\n                    done <= 1;\n                    text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                                 sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                                 sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                                 sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                end else begin\n                    // Regular rounds\n                    if (dcnt > 0) begin\n                        // Perform SubBytes, ShiftRows, MixColumns, AddRoundKey\n                        // ...\n                        dcnt <= dcnt - 1;\n                    end else begin\n                        ld_r <= 0;\n                    end\n                end\n            end else if (done) begin\n                // Encryption complete\n                done <= 0;\n            end\n        end\n    end\n\n    // Initial round key addition (example)\n    always @(*) begin\n        if (ld) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= text_in_r[i * 32 + j * 8 +: 8] ^ key[i * 32 + j * 8 +: 8];\n                end\n            end\n        end\n    end\n\n    // SubBytes: Use aes_sbox submodule (not shown for brevity)\n    // ShiftRows: Implement row shifting\n    // MixColumns: Implement matrix multiplication in GF(2^8)\n    // AddRoundKey: XOR with round key\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    // Registers\n    reg [3:0] rcnt;\n    reg [31:0] w [0:3];\n\n    // Submodules\n    aes_rcon rcon(\n        .clk(clk),\n        .kld(kld),\n        .out()\n    );\n\n    // S-box for key expansion\n    aes_sbox sbox[3:0] (\n        .a(),\n        .b()\n    );\n\n    // Key loading operation\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 0;\n        end else if (rcnt < 10) begin\n            // Expand key\n            w[0] <= w[3] ^ sbox[0].b;\n            w[1] <= w[0] ^ sbox[1].b;\n            w[2] <= w[1] ^ sbox[2].b;\n            w[3] <= w[2] ^ sbox[3].b;\n            rcnt <= rcnt + 1;\n        end\n    end\n\n    assign wo_0 = w[0];\n    assign wo_1 = w[1];\n    assign wo_2 = w[2];\n    assign wo_3 = w[3];\n\n    // Implement SubWord and Rcon operations using sbox and rcon modules\n    // ...\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // Implement S-box lookup table (not shown for brevity)\n    // ...\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    // Registers\n    reg [3:0] rcnt;\n\n    // Round constant generation\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n        end else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n        end\n    end\n\n    // Output round constant based on rcnt\n    always @(*) begin\n        case (rcnt)\n            0: out <= 32'h01_00_00_00;\n            1: out <= 32'h02_00_00_00;\n            2: out <= 32'h04_00_00_00;\n            // ... implement other round constants\n            default: out <= 32'h00_00_00_00;\n        endcase\n    end\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 7, "code": "module aes_cipher_top(\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [3:0][7:0] sa[3:0][3:0]; // 4x4 state matrix\nreg [3:0] dcnt; // Round counter (initial value: 11 for 10 rounds)\nreg ld_r; // Load operation flag\nreg [127:0] text_out_r; // Output buffer\n\n// Submodules\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(ld),\n    .key(key),\n    .wo_0(round_key[0]),\n    .wo_1(round_key[1]),\n    .wo_2(round_key[2]),\n    .wo_3(round_key[3])\n);\n\n// Round key storage (4 words of 32 bits each)\nwire [31:0] round_key[3:0];\n\n// S-box for SubBytes transformation\naes_sbox sbox[15:0] (\n    .a(sa[0][0][7:0]),\n    .b()\n);\n\n// Control logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        text_in_r <= 0;\n        sa <= 0;\n        dcnt <= 11;\n        ld_r <= 0;\n        done <= 0;\n    end else if (ld) begin\n        text_in_r <= text_in;\n        dcnt <= 11;\n        ld_r <= 1;\n        done <= 0;\n    end else if (ld_r && dcnt > 0) begin\n        // Perform round operations\n        if (dcnt == 1) begin\n            // Final round (no MixColumns)\n            // SubBytes, ShiftRows, AddRoundKey\n            dcnt <= 0;\n        end else begin\n            // Normal rounds (SubBytes, ShiftRows, MixColumns, AddRoundKey)\n            dcnt <= dcnt - 1;\n        end\n    end else if (dc == 0) begin\n        done <= 1;\n        text_out_r <= text_out;\n    end\nend\n\n// Map text_in to state matrix in column-major order\nalways @(posedge clk) begin\n    if (ld) begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= text_in_r[i * 32 + j * 8 +: 8];\n            end\n end\n    end\n\n\n// Convert state matrix to output in column-major order\nalways @(posedge clk) begin\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            text_out_r[i * 32 + j * 8 +: 8] <= sa[i][j];\n        end\n    end\nend\n\nassign text_out = text_out_r;\n\nendmodule\nmodule aes_key_expand_128(\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output wire [31:0] wo_0,\n    output wire [31:0] wo_1,\n    output wire [31:0] wo_2,\n    output wire [31:0] wo_3\n);\n\nreg [31:0] w[43:0]; // Key expansion buffer (128 bits * 11 rounds)\nreg [3:0] rcnt; // Round counter (initial value: 0)\n\n// Round constant generator\naes_rcon rcon(\n    .clk(clk),\n    .kld(kld),\n    .out(round_const)\n);\n\nwire [31:0] round_const; // Round constant (32-bit, only upper byte valid)\n\n// SubBytes module for key expansion\naes_sbox subword[3:0] (\n    .a(),\n    .b()\n);\n\n// Key loading operation\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 0;\n        w[0] <= key[127:96];\n        w[1] <= key[95:64];\n        w[2] <= key[63:32];\n        w[3] <= key[31:0];\n        wo_0 <= key[127:96];\n        wo_1 <= key[95:64];\n        wo_2 <= key[63:32];\n        wo_3 <= key[31:0];\n    end else begin\n        rcnt <= rcnt + 1;\n        w[rcnt+3] <= w[rcnt-1] ^ subword[3].b ^ subword[2].b ^ subword[1].b ^ subword[0].b ^ round_const;\n        wo_0 <= w[rcnt];\n        wo_1 <= w[rcnt+1];\n        wo_2 <= w[rcnt+2];\n        wo_3 <= w[rcnt+3];\n    end\nend\n\n// SubWord transformation\nalways @(*) begin\n    subword[0].a <= w[rcnt][7:0];\n    subword[1].a <= w[rcnt][15:8];\n    subword[2].a <= w[rcnt][23:16];\n    subword[3].a <= w[rcnt][31:24];\nend\n\nendmodule\nmodule aes_sbox(\n    input wire [7:0] a,\n    output reg [7:0] b\n);\n\n// S-box lookup table (256 entries, 8-bit each)\nreg [7:0] sbox[255:0];\n\n// Initialize S-box (omitted for brevity, typically initialized in design)\n// Example initialization\ninitial begin\n    // Standard AES S-box values (256 entries)\n    sbox[0] = 8'h63; // Replace with actual S-box values\n    sbox[1] = 8'h7c;\n    sbox[2] = 8'h77;\n    // ... 254 more entries ...\n    sbox[255] = 8'hf2;\nend\n\nalways @(*) begin\n    b <= sbox[a];\nend\n\nendmodule\nmodule aes_rcon(\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\nreg [3:0] rcnt; // Round counter (0-9)\nreg [7:0] rconst; // Round constant (only upper byte is valid)\n\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 0;\n        rconst <= 8'h01; // Initial round constant\n    end else begin\n        rcnt <= rcnt + 1;\n        if (rcnt == 10) begin\n            rconst <= 8'h1b; // RC[9] = 0x1b (special case)\n        end else if (rcnt == 11) begin\n            rconst <= 8'h36; // RC[10] = 0x36 (special case)\n        end else begin\n            // Multiply by 02 in GF(2^8)\n            rconst <= (rconst << 1) ^ (rconst[0] ? 8'h1b : 0);\n        end\n    end\nend\n\nalways @(*) begin\n    out <= {24'h00_00_00_00, rconst}; // Only MSB changes\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 8, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [3:0][7:0] sa[3:0];\nreg3:0] dcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Submodules\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(ld),\n    .key(key),\n    .wo_0(),\n    .wo_1(),\n    .wo_2(),\n    .wo_3()\n);\n\n// State machine logic\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        dcnt <= 11; // Initialize round counter\n        ld_r <= 0;\n    end else if (ld) begin\n        text_in_r <= text_in; // Load input text\n        ld_r <= 1;\n    end else begin\n        case (dcnt)\n            11: begin // Initial round key addition\n                // Perform initial round key addition\n                sa <= text_in_r ^ key;\n                dcnt <= dcnt - 1;\n            end\n            [0:10]: begin // Standard rounds\n                if (dcnt > 0) begin // Rounds 1-9 (MixColumns included)\n                    // Perform SubBytes, ShiftRows, MixColumns, AddRoundKey\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= aes_sbox(sa[i][j]);\n                        end\n                    end\n                    // ShiftRows implementation\n                    // MixColumns implementation\n                    // AddRoundKey implementation\n                end else begin // Final round (Round 10)\n                    // Perform SubBytes, ShiftRows, AddRoundKey (no MixColumns)\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= aes_sbox(sa[i][j]);\n                       \n                    end\n                    // ShiftRows implementation\n                    // AddRoundKey implementation\n                    dcnt <= 0; // Mark as done\n                end\n                dcnt <= dcnt - 1;\n            end\n            default: begin\n                text_out <= text_in_r;\n                done <= 1'b1;\n            end\n        endcase\n    end\nend\n\n// S-box module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n    reg [7:0] b;\n    always @(a) begin\n        case (a)\n            8'h00: b = 8'h63;\n            8'h01: b = 8'h7c;\n            8'h02: b = 8'h77;\n            // ... Add all S-box mappings\n            8'hff: b = 8'h16;\n            default: b = 8'h00;\n        endcase\n    end\nendmodule\n\n// Key expansion module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n    // Registers\n    reg [31:0] w[43:0];\n    reg [1:0] rcnt;\n\n    // Round constant module\n    aes_rcon rcon(\n        .clk(clk),\n        .kld(kld),\n        .out()\n    );\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 0;\n        end else begin\n            if (rcnt == 0) begin\n                w[4] <= w[0] ^ aes_sbox(w[1][7:0]) ^ aes_sbox(w[1][15:8]) ^ aes_sbox(w[1][23:16]) ^ aes_sbox(w[1][31:24]);\n                w[5] <= w[4] ^ aes_sbox(w[2][7:0]) ^ aes_sbox(w[2][15:8]) ^ aes_sbox(w[2][23:16]) ^ aes_sbox(w[2][31:24]);\n                // ... Implement full key expansion logic\n            end\n            rcnt <= rcnt + 1;\n        end\n    end\n\n    assign wo_0 = w[0];\n    assign wo_1 = w[1];\n    assign wo_2 = w[2];\n    assign wo_3 = w[3];\nendmodule\n\n// Round constant module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n    reg [3:0] rcnt;\n    reg [31:0] out;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else begin\n            rcnt <= rcnt + 1;\n            case (rcnt)\n                0: out <= 32'h01_00_00_00;\n                1: out <= 32'h02_00_00_00;\n                2: out <= 32'h04_00_00_00;\n                3: out <= 32'h08_00_00_00;\n                4: out <= 32'h10_00_00_00;\n                5: out <= 32'h20_00_00_00;\n                6: out <= 32'h40_00_00_00;\n                7: out <= 32'h80_00_00_00;\n                8: out <= 32'h1b_00_00_00;\n                9: out <= 32'h36_00_00_00;\n                default: out <= 32'h00_00_00_00;\n            endcase\n        end\n    end\nendmodule\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 9, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input               clk,\n    input               rst,\n    input               ld,\n    output              done,\n    input  [127:0]      key,\n    input  [127:0]      text_in,\n    output [127:0]      text_out\n);\n\n// Internal signals and registers\nreg [127:0] text_in_r;\nreg [3:0][3:0][7:0] sa;\nreg [3:0] dcnt;\nreg               ld_r;\nreg [127:0] text_out;\n\n// Round key wires (from key expansion module)\nwire [127:0] round_key;\n\n// Instantiate key expansion module\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(ld),\n    .key(key),\n    .wo_0(round_key[31:0]),\n    .wo_1(round_key[63:32]),\n    .wo_2(round_key[95:64]),\n    .wo_3(round_key[127:96])\n);\n\n// Main control logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        text_in_r <= 128'd0;\n        sa <= '{default: '0};\n        dcnt <= 4'd11;\n        ld_r <= 1'b0;\n        text_out <= 128'd0;\n        done <= 1'b0;\n    end else if (ld) begin\n        // Load initial data\n        text_in_r <= text_in;\n        ld_r <= 1'b1;\n        dcnt <= 4'd11;\n        done <= 1'b0;\n    end else if (ld_r) begin\n        // Perform AES rounds\n        if (dcnt == 4'd0) begin\n            // Final round\n            text_out <= final_round(sa);\n            done <= 1'b1;\n            ld_r <= 1'b0;\n        end else begin\n            // Standard round\n            sa <= round_transform(sa, round_key);\n            dcnt <= dcnt - 1'b1;\n        end\n    end\nend\n\n// Initial round key addition\nalways @(*) begin\n    if (ld && !rst) begin\n        // Load data into state matrix\n        for (int i = 0; i < 16; i++) begin\n            sa[i / 4][i % 4] = text_in[i * 8 +: 8] ^ round_key[i * 8 +: 8];\n        end\n    end else if (!ld && !rst) begin\n        // Keep current state\n        sa <= sa;\n    end else begin\n        // Reset state\n        sa <= '{default: '0};\n    end\nend\n\n// Final round transformation\nfunction [127:0] final_round;\n    input [3:0][3:0][7:0] state;\n    reg [127:0] result;\n    reg [3:0][3:0][7:0] shifted_state;\n    \n    begin\n        // Perform ShiftRows\n        shifted_state = shift_rows(state);\n        \n        // Perform AddRoundKey (last round)\n        for (int i = 0; i < 16; i++) begin\n            result[i * 8 +: 8] = shifted_state[i / 4][i % 4];\n        end\n        \n        final_round = result;\n    end\nendfunction\n\n// Round transformation (SubBytes, ShiftRows, MixColumns, AddRoundKey)\nfunction [3:0][3:0][7:0] round_transform;\n    input [3:0][3:0][7:0] state;\n    input [127:0] round_key;\n    reg [3:0][3:0][7:0] result;\n    \n    begin\n        // SubBytes\n        result sub_bytes(state);\n        \n        //Rows\n        result = shift_rows(result);\n        \n        // MixColumns (except final round)\n        result = mix_columns(result);\n        \n        // AddRoundKey\n        for (int i = 0; i < 16; i++) begin\n            result[i / 4][i % 4] = result[i / 4][i % 4] ^ round_key[i * 8 +: 8];\n        end\n        \n        round_transform = result;\n    end\nendfunction\n\n// SubBytes transformation\nfunction [3:0][3:0][7:0] sub_bytes;\n    input [3:0][3:0][7:0] state;\n    reg [3:0][3:0][7:0] result;\n    \n    begin\n        for (int i = 0; i < 16; i++) begin\n            result[i / 4][i % 4] = aes_sbox::sbox_lookup(state[i / 4][i % 4]);\n        end\n        \n        sub_bytes = result;\n    end\nendfunction\n\n// ShiftRows transformation\nfunction [3:0][3:0][7:0] shift_rows;\n    input [3:0][3:0][7:0] state;\n    reg [3:0][3:0][7:0] result;\n    reg [7:0] temp_row [3:0];\n    \n    begin\n        // Copy rows\n        for (int i = 0; i < 4; i++) begin\n            temp_row[i] = state[i][0];\n        end\n        \n        // Shift rows\n        result[0] = '{state[0][0], state[0][1], state[0][2], state[0][3]};\n        result[1] = '{state[1][1], state[1][2], state[1][3], state[1][0]};\n        result[2] = '{state[2][2], state[2][3], state[2][0], state[2][1]};\n        result[3] = '{state[3][3], state[3][0], state[3][1], state[3][2]};\n        \n        shift_rows = result;\n    end\nendfunction\n\n// MixColumns transformation\nfunction [3:0][3:0][7:0] mix_columns;\n    input [3:0][3:0][7:0] state;\n    reg [3:0][3:0][7:0] result;\n    reg [7:0] temp [4];\n    \n    begin\n        for (int col = 0; col < 4; col++) begin\n            temp[0] = xtime(state[0][col], 2) ^ xtime(state[1][col], 3) ^ state[2][col] ^ state[3][col];\n            temp[1] = state[0][col] ^ xtime(state[1][col], 2) ^ xtime(state[2][col], 3) ^ state[3][col];\n            temp[2] = state[0][col] ^ state[1][col] ^ xtime(state[2][col], 2) ^ xtime(state[3][col], 3);\n            temp[3] = xtime(state[0][col], 3) ^ state[1][col] ^ state[2][col] ^ xtime(state[3][col], 2);\n            \n            for (int row = 0; row < 4; row++) begin\n                result[row][col] = temp[row];\n            end\n        end\n        \n        mix_columns = result;\n    end\nendfunction\n\n// xtime function for MixColumns\nfunction [7:0] xtime;\n    input [7:0] in_byte;\n    reg [7:0] out_byte;\n    \n    begin\n        out_byte = (in_byte << 1) ^ ((in_byte[7] && 8'h1b) ? 8'h1b : 8'h00);\n        xtime = out_byte;\n    end\nendfunction\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input               clk,\n    input               kld,\n    input  [127:0]      key,\n    output [31:0]       wo_0,\n    output [31:0]       wo_1,\n    output [31:0]       wo_2,\n    output [31:0]       wo_3\n);\n\n// Internal registers\nreg [31:0] w_0, w_1, w_2, w_3;\nreg [3:0] rcnt;\n\n// Round constant module\naes_rcon round_const(\n    .clk(clk),\n    .kld(kld),\n    .out(round_const_val)\n);\n\nwire [31:0] round_const_val;\n\n// Main control logic\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        // Initial key loading\n        w_0 <= key[127:96];\n        w_1 <= key[95:64];\n        w_2 <= key[63:32];\n        w_3 <= key[31:0];\n        rcnt <= 4'd0;\n    end else begin\n        // Key expansion\n        reg [31:0] temp;\n        temp = w_1;\n        if (rcnt[1:0] == 2'b00) begin\n            // SubWord and RotWord\n            temp = aes_sbox::sbox_lookup(temp[7:0]) << 24 |\n                   aes_sbox::sbox_lookup(temp[15:8]) << 16 |\n                   aes_sbox::sbox_lookup(temp[23:16]) << 8  |\n                   aes_sbox::sbox_lookup(temp[31:24]);\n            temp = temp ^ round_const_val;\n        end\n        \n        w_0 <= w_0 ^ temp;\n        w_1 <= w_1 ^ w_0;\n        w_2 <= w_2 ^ w_1;\n        w_3 <= w_3 ^ w_2;\n        rcnt <= rcnt + 1'b1;\n    end\nend\n\n// Output assignments\nalways @(*) begin\n    wo_0 = w_0;\n    wo_1 = w_1;\n    wo_2 = w_2;\n    wo_3 = w_3;\nend\n\nendmodule\n\n// aes_sbox module (same for key expansion and cipher)\nmodule aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n// Use lookup table or logic implementation\n// Here we assume a lookup table implementation\nreg [7:0] b;\n\nalways @(*) begin\n    case (a)\n        8'h00: b = 8'h63;\n        8'h01: b = 8'h7c;\n        8'h02: b = 8'h77;\n        // ... (rest of S-box entries)\n        8'xff: b = 8'h16;\n        default: b = 8'h00; // Invalid input case\n    endcaseend\n\nendmodule\n\n// aescon module\nmodule_rcon(\n                  clk,\n    input               kld,\n    output [31:0]       out\n);\n\n// Internal counter\nreg [3:0] rcnt;\n\n// Output register\nreg [31:0] out_reg;\n\n// Round constant lookup\nreg [31:0] rcon_val;\n\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 4'd0;\n        out_reg <= 32'h01000000;\n    end else begin\n        rcnt <= rcnt + 1'b1;\n        out_reg <= {32'd0, rcon_val};\n    end\nend\n\n// Round constant calculation\nalways @(*) begin\n    case (rcnt)\n        4'd0: rcon_val = 8'h01;\n        4'd1: rcon_val = 8'h02;\n        4'd2: rcon_val = 8'h04;\n        4'd3: rcon_val = 8'h08;\n        4'd4: rcon_val = 8'h10;\n        4'd5: rcon_val = 8'h20;\n        4'd6: rcon_val = 8'h40;\n        4'd7: rcon_val = 8'h80;\n        4'd8: rcon_val = 8'h1b;\n        4'd9: rcon_val = 8'h36;\n        default: rcon_val = 8'h00; // Invalid case\n    endcase\nend\n\nassign out = out_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 10, "code": "// aes_cipher_top.v\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg127:0] text\n);\n\nreg127:0]_in_r;\nreg [3:0][30][7:0] sa;\nreg [3:0] dcnt;\nreg ld_r;\nwire [3:0][7:0] round_key;\n\n// Instantiate submodules\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(ld),\n    .key(key),\n    .wo_0(round_key[0]),\n    .wo_1(round_key[1]),\n    .wo_2(round_key[2]),\n    .wo_3(round_key[3])\n);\n\n// Main logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        done <= 0;\n        dcnt <= 4'd11;\n        ld_r <= 0;\n        text_in_r <= 0;\n        sa <= 0;\n        text_out <= 0;\n    end else if (ld) begin\n        // Load initial data\n        text_in_r <= text_in;\n        ld_r <= 1;\n        dcnt <= 4'd11;\n        done <= 0;\n    end else if (ld_r && (dcnt > 4'd0)) begin\n        // Perform encryption rounds\n        if (dcnt == 4'd11) begin\n            // Initial round key addition\n            for (int i = 0; i < 16; i++) begin\n                sa[i / 4][i % 4] <= text_in_r[i*8 +: 8] ^ round_key[i % 4][7:0];\n            end\n            dcnt <= dcnt - 1;\n        end else if (dcnt < 4'd11 && dcnt > 4'd1) begin\n            // Standard rounds (SubBytes, ShiftRows, MixColumns, AddRoundKey)\n            // Implement these operations using the sa matrix\n            // For brevity, these operations are not fully expanded here\n            // but would involve calling appropriate functions/submodules\n            dcnt <= dcnt - 1;\n        end else if (dcnt == 4'd1) begin\n            // Final round (SubBytes, ShiftRows, AddRoundKey)\n            // Implement final round operations\n            dcnt <= dcnt - 1;\n        end\n    end else if (dcnt == 0) begin\n        // Encryption complete, generate output\n        for (int i = 0; i < 16; i++) begin\n            text_out[i*8 +: 8] <= sa[i % 4][i / 4][7:0];\n        end\n        done <= 1;\n    end\nend\n\nendmodule\n\n// aes_key_expand_128.v\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\nreg [3:0] rcnt;\nwire [7:0] round_constant;\nreg [31:0] w0, w1, w2, w3;\n\n// Instantiate aes_rcon submodule\naes_rcon rcon(\n    .clk(clk),\n    .kld(kld),\n    .out(round_constant)\n);\n\n// Main logic\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        // Initialize first four words from input key\n        wo_0 <= key[127:96];\n        wo_1 <= key[95:64];\n        wo_2 <= key[63:32];\n        wo_3 <= key[31:0];\n        rcnt <= 0;\n    end else begin\n        // Key expansion logic\n        w0 <= wo_3 ^ aes_sbox(round_constant ^ wo_1[7:0], wo_1[15:8], wo_1[23:16], wo_1[31:24]);\n        w1 <= wo_0 ^ aes_sbox(round_constant ^ wo_2[7:0], wo_2[15:8], wo_2[23:16], wo_2[31:24]);\n        w2 <= wo_1 ^ aes_sbox(round_constant ^ wo_3[7:0], wo_3[15:8], wo_3[23:16], wo_3[31:24]);\n        w3 <= wo_2 ^ aes_sbox(round_constant ^ wo_0[7:0], wo_0[15:8], wo_0[23:16], wo_0[31:24]);\n        wo_0 <= w0;\n        wo_1 <= w1;\n        wo_2 <= w2;\n        wo_3 <= w3;\n        rcnt <= rcnt + 1;\n    end\nend\n\nfunction [7:0] aes_sbox;\n    input [7:0] byte;\n    // Implement S-box lookup table here\n    // For brevity, this is not fully expanded\n    // but would involve a lookup table or logic implementation\nendfunction\n\nendmodule\n\n// aes_sbox.v\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n// Implement S-box lookup table or logic\n// For brevity, this is not fully expanded\nreg [7:0] b;\nalways @(a) begin\n    // Implement S-box transformation logic here\n    // For example (simplified):\n    case(a)\n        8'd0: b <= 8'd63;\n        8'd255: b <= 8'd16;\n        default: b <= 0; // Placeholder for other values\n    endcase\nend\n\nendmodule\n\n// aes_rcon.v\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [31:0] rcnt;\nalways @(posedge clk posedge kld) begin\n    if (kld) begin\n        rcnt <= 0;\n        out <= 32'h01_00_00_00; // Initial round constant\n    end else begin\n        rcnt <= rcnt + 1;\n        case(rcnt)\n            1: out <= 32'h02_00_00_00;\n            2: out <= 32'h04_00_00_00;\n            3: out <= 32'h08_00_00_00;\n            4: out <= 32'h10_00_00_00;\n            5: out <= 32'h20_00_00_00;\n            6: out <= 32'h40_00_00_00;\n            7: out <= 32'h80_00_00_00;\n            8: out <= 32'h1b_00_00_00;\n            9: out <= 32'h36_00_00_00;\n            default: out <= 32'h00_00_00_00;\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 11, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input           clk,\n    input           rst,\n    input           ld,\n    output          done,\n    input   [127:0] key,\n    input   [127:0] text_in,\n    output  [127:0] text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [3:0][3:0][7:0] sa; // State matrix in column-major order\nreg [3:0] dcnt;          // Round counter (initial value 11)\nreg           ld_r;      // Load operation flag\nreg [127:0]   text_out;  // Output ciphertext\n\n// Submodules\naes_key_expand_128 key_exp(\n    .clk(clk),\n    .kld(ld),\n    .key(key),\n    .wo_0(),\n    .wo_1(),\n    .wo_2(),\n    .wo_3()\n);\n\n// Main logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        text_in_r <= 128'd0;\n        sa <= '{default: 8'd0};\n        dcnt <= 4'd11;\n        ld_r <= 1'd0;\n        text_out <= 128'd0;\n        done <= 1'd0;\n    end else if (ld) begin\n        // Initialize with input data\n        text_in_r <= text_in;\n        ld_r <= 1'd1;\n    end else if (ld_r) begin\n        // Perform encryption rounds\n        if (dcnt == 4'd0) begin\n            // Final round (no MixColumns)\n            // ShiftRows and AddRoundKey\n            done <= 1'd1;\n            text_out <= final_round(text_in_r, key);\n            ld_r <= 1'd0;\n        end else begin\n            // Standard round\n            dcnt <= dcnt - 4'd1;\n            text_in_r <= round_operation(text_in_r, key,cnt);\n        end\n    endend\n\n// Final round function (ShiftRows + AddRoundKey)\nfunction [127:0] final_round;\n    input [127:0] data;\n    input [127:0] key;\n    reg [127:0] result;\n    begin\n        // Apply ShiftRows transformation\n        result = shift_rows(data);\n        // Apply AddRoundKey with final round key\n        result = result ^ key;\n        final_round = result;\n    end\nendfunction\n\n// Standard round operation (SubBytes + ShiftRows + MixColumns + AddRoundKey)\nfunction [127:0] round_operation;\n    input [127:0] data;\n    input [127:0] key;\n    input [3:0] round;\n    reg [127:0] result;\n    begin\n        // SubBytes\n        result = sub_bytes(data);\n        // ShiftRows\n        result = shift_rows(result);\n        // MixColumns (except final round)\n        if (round != 4'd1)\n            result = mix_columns);\n        // AddRound\n        result = result ^ key;\n        round_operation = result;\n    end\nendfunction\n\n// SubBytes transformation (S-box lookup)\nfunction [127:0] sub_bytes;\n    input [127:0] data;\n    reg [127:0] result;\n    reg [7:0] temp;\n    integer i;\n    begin\n        result = 128'd0;\n        for (i = 0; i < 16; i++) begin\n            temp = data[8*(i+1)-1 : 8*i];\n            result[8*(i+1)-1 : 8*i] = aes_sbox(temp);\n        end\n        sub_bytes = result;\n    end\nendfunction\n\n// ShiftRows transformation\nfunction [127:0] shift_rows;\n    input [127:0] data;\n    reg [127:0] result;\n    reg [7:0] temp;\n    integer i, j;\n    begin\n        result = 128'd0;\n        for (i = 0; i < 4; i++) begin\n            for (j = 0; j < 4; j++) begin\n                temp = data[8*(4*i+j+1)-1 : 8*(4*i+j)];\n                result[8*(4*i+(j+i)%4+1)-1 : 8*(4*i+(j+i)%4)] = temp;\n            end\n        end\n        shift_rows = result;\n    end\nendfunction\n\n// MixColumns transformation\nfunction [127:0] mix_columns;\n    input [127:0] data;\n    reg [127:0] result;\n    reg [7:0] col[3:0];\n    integer i;\n    begin\n        result = 128'd0;\n        for (i = 0; i < 4; i++) begin\n            col[0] = data[8*(4*i+1)-1 : 8*(4*i)];\n            col[1] = data[8*(4*i+2)-1 : 8*(4*i+1)];\n            col[2] = data[8*(4*i+3)-1 : 8*(4*i+2)];\n            col[3] = data[8*(4*i+4)-1 : 8*(4*i+3)];\n            \n            result[8*(4*i+1)-1 : 8*(4*i)] = mix_column(col[0], col[1], col[2], col[3]);\n        end\n        mix_columns = result;\n    end\nendfunction\n\n// MixColumns single column calculation\nfunction [7:0] mix_column;\n    input [7:0] a, b, c, d;\n    begin\n        mix_column = \n            (xtime(a) ^ xtime(b) ^ c ^ d);\n    end\nendfunction\n\n// Multiplication by 2 in GF(2^8)\nfunction [7:0] xtime;\n    input [7:0] x;\n    begin\n        if (x[7]) begin\n            xtime = {x[6:0], 1'd0} ^ 8'h1b;\n        end else begin\n            xtime = {x[6:0], 1'd0};\n        end\n    end\nendfunction\n\n// S-box lookup function (aes_sbox)\nfunction [7:0] aes_sbox;\n    input [7:0] in_byte;\n    reg [7:0] out_byte;\n    reg [7:0] sbox_table[0:255];\n    begin\n        // Initialize S-box table (precomputed values)\n        // Replace with actual S-box values\n        sbox_table[0] = 8'd63; // Example entry for input 0x00\n        // ... other entries ...\n        out_byte = sbox_table[in_byte];\n        aes_sbox = out_byte;\n    end\nendfunction\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input           clk,\n    input           kld,\n    input   [127:0] key,\n    output  [31:0]  wo_0,\n    output  [31:0]  wo_1,\n    output  [31:0]  wo_2,\n    output  [31:0]  wo_3\n);\n\n// Registers\nreg [31:0] w[0:3];    // Four 32-bit words\nreg [3:0] rcnt;       // Round counter\n\n// Submodules\naes_rcon rcon(\n    .clk(clk),\n    .kld(kld),\n    .out(rcon_value)\n);\n\n// Main logic\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        // Initialize words from input key\n        w[0] <= key[127:96];\n        w[1] <= key[95:64];\n        w[2] <= key[63:32];\n        w[3] <= key[31:0];\n        rcnt <= 4'd0;\n    end else begin\n        // Generate next round key words\n        if (rcnt == 4'd10) begin\n            rcnt <= 4'd0; // Reset counter after 10 rounds\n        end else begin\n            rcnt <= rcnt + 4'd1;\n            w[0] <= generate_word(w[0], w[1], rcnt);\n            w[1] <= w[0];\n            w[2] <= w[1];\n            w[3] <= w[2];\n        end\n    end\nend\n\n// Output assignments\nassign wo_0 = w[0];\nassign wo_1 = w[1];\nassign wo_2 = w[2];\nassign wo_3 = w[3];\n\n// Generate next word in sequence\nfunction [31:0] generate_word;\n    input [31:0] prev_word;\n    input [31:0] curr_word;\n    input [3:0] round;\n    reg [31:0] result;\n    begin\n        // RC[i] = 02 * RC[i-1] (in GF(2^))\n        result = {rcon_value[:0], 24'd0};\n        if (round == 4'd1 || round == 4'd2 || round == 4'd3 || round == 4'd4) begin\n            // Special case for first word of each round\n            result = sub_word(rot_word(curr_word)) ^ result;\n        end else begin\n            // Regular word generation\n            result = prev_word ^ curr_word;\n        end\n        generate_word = result;\n    end\nendfunction\n\n// Rotate word (left cyclic shift)\nfunction [31:0] rot_word;\n    input [31:0] word;\n    begin\n        rot_word = {word[23:0], word[31:24]};\n    end\nendfunction\n\n// Substitute bytes (S-box)\nfunction [31:0] sub_word;\n    input [31:0] word;\n    reg [31:0] result;\n    reg [7:0] temp;\n    integer i;\n    begin\n        result = 32'd0;\n        for (i = 0; i < 4; i++) begin\n            temp = word[8*(i+1)-1 : 8*i];\n            result[8*(i+1)-1 : 8*i] = aes_sbox(temp);\n        end\n        sub_word = result;\n    end\nendfunction\n\nendmodule\n\n// aes_sbox module (S-box lookup table)\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n// S-box lookup table (precomputed)\nreg [7:0] sbox_table[0:255];\nalways @(a) begin\n    b = sbox_table[a];\nend\ninitial begin\n    // Initialize S-box table (precomputed values)\n    // Replace with actual S-box values\n    sbox_table[0] = 8'd63; // Example entry for input 0x00\n    // ... other entries ...\nend\n\nendmodule\n\n// aes_rcon module (round constant generator)\nmodule aes_rcon(\n    input           clk,\n    input           kld,\n    output  [31:0]  out\n);\n\n// Registers\nreg [3:0] rcnt;\nreg [31:0] rcon_value;\n\n// Main logic\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 4'd0;\n        rcon_value <= 32'h01000000; // RC[1] = 01\n    end else if (rcnt == 4'd9) begin\n        // Maximum value reached\n        rcon_value <= 32'd0;\n    end else begin\n        rcnt <= rcnt + 4'd1;\n        rcon_value <= {rcon_value[23:0], 1'd0} ^ (rcnt == 4'd8 ? 8'h1b : 8'd0);\n    end\nend\n\nassign out = rcon_value;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 12, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Internal registers\nreg [127:0] text_in_r;\nreg [3:0][3:0][7:0] sa; // State matrix (4x4 bytes)\nreg [3:0] dcnt;          // Round counter (4 bits)\nreg ld_r;                // Load flag\nreg [127:0] text_out_r;  // Output register\n\n// Instantiate key expansion module\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(ld),\n    .key(key),\n    .wo_0(),\n    .wo_1(),\n    .wo_2(),\n    .wo_3()\n);\n\n// Internal round key (128 bits)\nwire [127:0] round_key;\n\n// State machine\nreg [1:0] state;\nlocalparam IDLE = 2'b00,\n          INIT_ROUND = 2'b01,\n          ROUND_OP = 2'b10,\n          FINAL_ROUND = 2'b11;\n\n// SubBytes module (instantiates 16 S-boxes)\nwire [3:0][3:0][7:0] sbox_out;\naes_sbox_subbytes sbox(\n    .sa_in(sa),\n    .sa_out(sbox_out)\n);\n\n// ShiftRows module\nwire [3:0][3:0][7:0] shift_rows_out;\naes_shift_rows shift_rows(\n    .sa_in(sbox_out),\n    .sa_out(shift_rows_out)\n);\n\n// MixColumns module\nwire [3:0][3:0][7:0] mix_cols_out;\naes_mix_columns mix_cols(\n    .sa_in(shift_rows_out),\n    .sa_out(mix_cols_out)\n);\n\n// AddRoundKey module\nwire [3:0][3:0][7:0] add_key_out;\naes_add_round_key add_key(\n    .sa_in(mix_cols_out),\n    .round_key(round_key),\n    .sa_out(add_key_out)\n);\n\n// Output logic\nassign text_out = text_out_r;\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (ld) begin\n                state = INIT_ROUND;\n            end else begin\n                state = IDLE;\n            end\n        end\n        INIT_ROUND: begin\n            state = ROUND_OP;\n        end\n        ROUND_OP: begin\n            if (dcnt == 0) begin\n                state = FINAL_ROUND;\n            end else begin\n                state = ROUND_OP;\n            end\n        end\n        FINAL_ROUND: begin\n            state = IDLE;\n        end\n        default: state = IDLE;\n    endcase\nend\n\n// Main logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset state\n        state <= IDLE;\n        dcnt <= 4'b1011; // 11 (0xB) for 10 rounds + initial round\n        ld_r <= 0;\n        text_in_r <= 128'b0;\n        text_out_r <= 128'b0;\n        sa <= '{default: 8'b0};\n    end else begin\n        case (state)\n            IDLE: begin\n                if (ld) begin\n                    text_in_r <= text_in;\n                    ld_r <= 1;\n                end\n            end\n            INIT_ROUND: begin\n                // Initial key addition\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= text_in_r[8*(i*4+j)+:8] ^ key[8*(i*4+j)+:8];\n                    end\n                end\n                dcnt <= dcnt - 1;\n            end\n            ROUND_OP: begin\n                // Standard round operations\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= add_key_out[i][j];\n                    end\n                end\n                dcnt <= dcnt - 1;\n            end\n            FINAL_ROUND: begin\n                // Final round (no MixColumns)\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        text_out_r[8*(i*4+j)+:8] <= add_key_out[i][j];\n                    end\n                end\n                done <= 1;\n            end\n            default: begin\n                // Do nothing\n            end\n        endcase\n    end\nend\n\nendmodule\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n// Internal registers\nreg [31:0] w0, w1, w2, w3;\nreg [31:0] temp;\nreg [1:0] state;\n\n// Instantiate S-box\nwire [7:0] sbox_out;\naes_sbox sbox(\n    .a(temp[7:0]),\n    .b(sbox_out)\n);\n\n// Instantiate Rcon module\nwire [31:0] rcon_out;\naes_rcon rcon(\n    .clk(clk),\n    .kld(kld),\n    .out(rcon_out)\n);\n\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        // Initial key loading\n        w0 <= key[127:96];\n        w1 <= key[95:64];\n        w2 <= key[63:32];\n        w3 <= key[31:0];\n    end else begin\n        // Key expansion process\n        temp <= w3; // Store w3 in temp\n        \n        // S-box substitution and rotation\n        for (int i = 0; i < 4; i++) begin\n            temp <= {sbox_out, temp[23:8]};\n        end\n        \n        // XOR with Rcon\n        temp <= temp ^ rcon_out;\n        \n        // Update next words\n        w0 <= w0 ^ temp;\n        w1 <= w1 ^ w0;\n        w2 <= w2 ^ w1;\n        w3 <= w3 ^ w2;\n    end\nend\n\nassign wo_0 = w0;\nassign wo_1 = w1;\nassign wo_2 = w2;\nassign wo_3 = w3;\n\nendmodule\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n// S-box lookup table (256x8 bits)\nreg [7:0] sbox_memory [0:255];\n\n// Initialize S-box at startup (example values)\ninitial begin\n    sbox_memory[0x00] = 8'h63;\n    sbox_memory[0x01] = 8'h7c;\n    sbox_memory[0x02] = 8'h77;\n    sbox_memory[0x03] = 8'h7b;\n    // ... (add all 256 entries)\n    sbox_memory[0xff] = 8'h16;\nend\n\n// Combinational logic\nalways @(*) begin\n    b = sbox_memory[a];\nend\n\nendmodule\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n// Internal round counter\nreg [3:0] rcnt;\n\n// Output register\nreg [31:0] out_reg;\n\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 0;\n        out_reg <= 32'h01000000; // Initial Rcon value\n    end else begin\n        // Increment counter\n        rcnt <= rcnt + 1;\n        \n        // Generate Rcon value (only MSB changes)\n        case (rcnt)\n            0: out_reg <= 32'h01000000;\n            1: out_reg <= 32'h02000000;\n            2: out_reg <= 32'h04000000;\n            3: out_reg <= 32'h08000000;\n            4: out_reg <= 32'h10000000;\n            5: out_reg <= 32'h20000000;\n            6: out_reg <= 32'h40000000;\n            7: out_reg <= 32'h80000000;\n            8: out_reg <= 32'h1b000000;\n            9: out_reg <= 32'h36000000;\n            default: out_reg <= 32'h00000000;\n        endcase\n    end\nend\n\nassign out = out_reg;\n\nendmodule\nmodule aes_sbox_subbytes(\n    input [3:0][3:0][7:0] sa_in,\n    output [3:0][3:0][7:0] sa_out\n);\n\n// Instantiate 16 S-box modules\nwire [7:0] sbox_out [3:0][3:0];\nfor (genvar i = 0; i < 4; i++) begin\n    for (genvar j = 0; j < 4; j++) begin\n        aes_sbox sbox(\n            .a(sa_in[i][j]),\n            .b(sbox_out[i][j])\n        );\n    end\nend\n\n// Assign outputs\nalways @(*) begin\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa_out[i][j] = sbox_out[i][j];\n        end\n    end\nend\n\nendmodule\nmodule aes_shift_rows(\n    input [3:0][3:0][7:0] sa_in,\n    output [3:0][3:0][7:0] sa_out\n);\n\n// Hardwired row shifting\nalways @(*) begin\n    // Row 0: no shift\n    sa_out[0] = sa_in[0];\n    \n    // Row 1: shift 1 byte\n    sa_out[1][0] = sa_in[1][1];\n    sa_out[1][1] = sa_in[1][2];\n    sa_out[1][2] = sa_in[1][3];\n    sa_out[1][3] = sa_in[1][0];\n    \n    // Row 2: shift 2 bytes\n    sa_out[2][0] = sa_in[2][2];\n    sa_out[2][1] = sa_in[2][3];\n    sa_out[2][2] = sa_in[2][0];\n    sa_out[2][3] = sa_in[2][1];\n    \n    // Row 3: shift 3 bytes\n    sa_out[3][0] = sa_in[3][3];\n    sa_out[3][1] = sa_in[3][0];\n    sa_out[3][2] = sa_in[3][1];\n    sa_out[3][3] = sa_in[3][2];\nend\n\nendmodule\nmodule aes_mix_columns(\n    input [3:0][3:0][7:0] sa_in,\n    output [3:0][3:0][7:0] sa_out\n);\n\n// MixColumns transformation matrix\nreg [7:0] matrix [4];\nreg [7:0] result [4];\nreg [7:0] temp;\n\nalways @(*) begin\n    for (int i = 0; i < 4; i++) begin\n        result[i] <= 8'b0;\n        for (int j = 0; j < 4; j++) begin\n            case (j)\n                0: matrix[j] <= 8'h02; // 2*x\n                1: matrix[j] <= 8'h03; // 3*x\n                2: matrix[j] <= 8'h01; // x\n                3: matrix[j] <= 8'h01; // x\n                default: matrix[j] <= 8'b0;\n            endcase\n            \n            // Perform finite field multiplication\n            if (matrix[j] == 8'h01) begin\n                result[i] <= result[i] ^ sa_in[i][j];\n            end else if (matrix[j] == 8'h02) begin\n                result[i] <= result[i] ^ (sa_in[i][j] << 1);\n                if (sa_in[i][j][7]) begin\n                    result[i] <= result[i] ^ 8'h11b; // Reduction polynomial\n                end\n            end else if (matrix[j] == 8'h03) begin\n                result[i] <= result[i] ^ (sa_in[i][j] << 1);\n                if (sa_in[i][j][7]) begin\n                    result[i] <= result[i] ^ 8'h11b;\n                end\n                result[i] <= result[i] ^ sa_in[i][j];\n            end\n        end\n    end\nend\n\nassign sa_out = result;\n\nendmodule\nmodule aes_add_round_key(\n    input [3:0][3:0][7:0] sa_in,\n    input [127:0] round_key,\n    output [3:0][3:0][7:0] sa_out\n);\n\n// XOR with round key (column-major order)\nalways @(*) begin\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa_out[i][j] <= sa_in[i][j] ^ round_key[8*(i*4+j)+:8];\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 13, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [3:0][3:0][7:0] sa;\nreg [3:0] dcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Submodules\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(ld),\n    .key(key),\n    .wo_0(),\n    .wo_1(),\n    .wo_2(),\n    .wo_3()\n);\n\n// Control logic\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        text_in_r <= 128'd0;\n        sa <= '{default: '0};\n        dcnt <= 11; // Initial round counter (10 rounds + 1)\n        ld_r <= 1'b0;\n        text_out <= 128'd0;\n    end else if (ld) begin\n        // Initial state\n        text_in_r <= text;\n        ld_r <= 'b1;\n    end if (ld) begin\n        // Encryption process\n        case (dcnt)\n            11: begin // Initial round\n                // AddRoundKey with initial key\n                for (int i = 0; i < 16; i++) begin\n                    sa[i / 4][i % 4] <= text_in_r[8 * i +: 8] ^ key_expand.wo_0[8 * i +: 8];\n                end\n                dcnt <= 10;\n            end\n            10: begin // Standard\n                // SubBytes\n                for (int i = 0; i < 16; i++) begin\n                    sa[i / 4][i % 4] <= aes_sbox(sa[i / 4][i % 4]);\n                end\n                // ShiftRows\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][(j + i) % 4] <= sa[i][j];\n                    end\n                end\n                // MixColumns\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        // GF(2^8) matrix multiplication\n                        sa[i][j] <= (sa[i][j] ^ sa[(i + ) % 4][j]) ^ \n                                     (sa[(i + 2) % 4][j] << 1) ^ \n                                     (sa[(i + 3) % 4][j] << 3);\n                    end\n                end\n                // AddRoundKey\n                for (int i = 0; i < 16; i++) begin\n                    sa[i / 4][i % 4] <= sa[i / 4][i % 4] ^ key_expand.wo_0[8 * i +: 8];\n                end\n                dcnt <= dcnt - 1;\n            end\n            1: begin // Final round\n                // SubBytes\n                for (int i = 0; i < 16; i++) begin\n                    sa[i / 4][i % 4] <= aes_sbox(sa[i / 4][i % 4]);\n                end\n                // ShiftRows\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][(j + i) % 4] <= sa[i][j];\n                    end\n                end\n                // AddRoundKey\n                for (int i = 0; i < 16; i++) begin\n                    sa[i / 4][i % 4] <= sa[i / 4][i % 4] ^ key_expand.wo_0[8 * i +: 8];\n                end\n                dcnt <= 0;\n            end\n            0: begin // Done\n                // Final output\n                for (int i = 0; i < 16; i++)\n                    text_out8 * i + 8] <=[i / 4][i % 4];\n                end\n                <= 1'b1;\n            end        endcase\n end\nend\n\n// Done signal logic\nalways @(ge clk) begin    if (dcnt 0) begin        done <= 1'b1;\n    end else begin\n        done <= 10;\n    endend\n\n// Instantiate-box module\nfunction7:0] aesbox;\n    input7:0]_byte;\n    // Lookup implementation (simplified)\n    case (in_byte)\n       8'h00: aes_sbox = 8'h63;\n        8'h01: aes_sbox = 8'h7c;\n        // ... Add all S-box entries\n        8'ff: aes_sbox = 8'h16;\n        default: aes_sbox = 8'h00;\n    endcase\nendfunction\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [31:0] wo_0_r;\nreg [31:0] wo_1_r;\nreg [31:0] wo_2_r;\nreg [31:0] wo_3_r;\nreg [31:0] temp;\nreg [3:0] rcnt;\n\n// Instantiate aes_rcon module\naes_rcon rcon(\n    .clk(clk),\n    .kld(kld),\n    .out(rcnt)\n);\n\n// Key expansion process\nalways @(posedge clk or negedge kld) begin\n    if (!kld) begin\n        // Initial values\n        wo_0_r <= key[127:96];\n        wo_1_r <= key[95:64];\n        wo_2_r <= key[63:32];\n        wo_3_r <= key[31:0];\n        rcnt <= 0;\n    end else begin\n        // Expand key words\n        case (rcnt)\n            0: begin\n               _0_r <= wo_1_r;\n                wo_1_r <= wo_2_r;\n                wo_2_r <= wo_3_r;\n                wo_3_r <= wo_0_r;\n            end\n            1: begin\n                temp <= aes_sbox(wo_1_r[7:0]) << 24 |\n                        aes_sbox(wo_1_r[15:8]) << 16 |\n                        aes_sbox(wo_1_r[23:16]) << 8 |\n                        aes_sbox(wo_1_r[31:24]);\n                wo_0_r <= wo_3_r ^ temp ^ (rcnt << 24);\n                wo_1_r <= wo_0_r;\n                wo_2_r <= wo_1_r;\n                wo_3_r <= wo_2_r;\n            end\n            default: begin\n                wo_0_r <= wo_3_r ^ wo_0_r;\n                wo_1_r <= wo_0_r;\n                wo_2_r <= wo_1_r;\n                wo_3_r <= wo_2_r;\n            end\n        endcase\n        rcnt <= rcnt + 1;\n    end\nend\n\nassign wo_0 = wo_0_r;\nassign wo_1 = wo__r;\nassign wo_2 = wo_2_r;\nassign wo_3 = wo_3_r;\n\n// Instantiate S-box module\nfunction [7:0] aes_sbox;\n    input [7:0] in_byte;\n    // Lookup table implementation (simplified)\n    case (in_byte)\n        8'h00: aes_sbox = 8'h63;\n        8'h01: aes_sbox = 8'h7c;\n        // ... Add all S-box entries\n        8'ff: aes_sbox = 8'h16;\n        default: aes_sbox = 8'h00;\n    endcase\nendfunction\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table implementation (simplified)\nalways @(a) begin\n    case (a)\n        8'h00: b = 8'h63;\n        8'h01: b = 8'h7c;\n        // ... Add all S-box entries\n        8'ff: b = 8'h16;\n        default: b = 8'h00;\n    endcase\nend\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\n\n// Round counter\nalways @(posedge clk or negedge kld) begin\n    if (!kld) begin\n        rcnt <= 0;\n    end else begin\n        rcnt <= rcnt + 1;\n    end\nend\n\n// Round constant logic\nalways @(rcnt) begin\n    case (rcnt)\n        0: out <= 32'h01_00_00_00;\n        1: out <= 32'h02_00_00_00;\n        2: out <= 32'h04_00_00_00;\n        3: out <= 32'h08_00_00_00;\n        4: out <= 32'h10_00_00_00;\n        5: out <= 32'h20_00_00_00;\n        6: out <= 32'h40_00_00_00;\n        7: out <= 32'h80_00_00_00;\n        8: out <= 32'h1b_00_00_00;\n        9: out <= 32'h36_00_00_00;\n        default: out <= 32'h00_00_00_00;\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 14, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input               clk,\n    input               rst,\n    input               ld,\n    output              done,\n    input   [127:0]     key,\n    input   [127:0]     text_in,\n    output  [127:0]     text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [3:0][7:0] sa[3:0];\nreg [3:0] dcnt;\nreg               ld_r;\nreg [127:0] text_out;\n\n// Internal signals\nreg [3:0][7:0] sa_temp[3:0];\nreg [3:0][7:0] round_key[3:0];\nreg [3:0] dcnt_next;\n\n// Key expansion module\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(ld),\n    .key(key),\n    .wo_0(round_key[0]),\n    .wo_1(round_key[1]),\n    .wo_2(round_key[2]),\n    .wo_3(round_key[3])\n);\n\n// S-box modules (4x4)\nreg [3:0][7:0] sbox_out[3:0];\ngenvar i, j;\nfor (i = 0; i < 4; i++) begin: sbox_row\n    for (j = 0; j < 4; j++) begin: sbox_col\n        aes_sbox sbox_inst(\n            .a(sa[i][j]),\n            .b(sbox_out[i][j])\n        );\n    end\nend\n\n// Main logic\nalways_comb begin\n    // Default assignments\n    dcnt_next = dcnt;\n    text_out = text_out;\n    done = 0;\n    \n    if (ld) begin\n        // Load data and initial key\n        text_in_r = text_in;\n        dcnt = 4'd11; // 10 rounds + initial round\n        ld_r = 1'b1;\n        done = 0;\n    end else if (ld_r && (dcnt > 0)) begin\n        // Perform encryption rounds\n        dcnt_next = dcnt - 1;\n        if (dcnt == 4'd1) begin\n            // Final round (no MixColumns)\n            sa_temp[0][0] = sbox_out[0][0] ^ round_key[0][0];\n            sa_temp[0][1] = sbox_out[0][1] ^ round_key[0][1];\n            sa_temp[0][2] = sbox_out[0][2] ^ round_key[0][2];\n            sa_temp[0][3] = sbox_out[0][3] ^ round_key[0][3];\n            \n            sa_temp[1][0] = sbox_out[1][1] ^ round_key[1][0];\n            sa_temp[1][1] = sbox_out[1][2] ^ round_key[1][1];\n            sa_temp[1][2] = sbox_out[1][3] ^ round_key[1][2];\n            sa_temp[1][3] = sbox_out[1][0] ^ round_key[1][3];\n            \n            sa_temp[2][0] = sbox_out[2][2] ^ round_key[2][0];\n            sa_temp[2][1] = sbox_out[2][3] ^ round_key[2][1];\n            sa_temp[2][2] = sbox_out[2][0] ^ round_key[2][2];\n            sa_temp[2][3] = sbox_out[2][1] ^ round_key[2][3];\n            \n            sa_temp[3][0] = sbox_out[3][3] ^ round_key[3][0];\n            sa_temp[3][1] = sbox_out[3][0] ^ round_key[3][1];\n            sa_temp[3][2] = sbox_out[3][1] ^ round_key[3][2];\n            sa_temp[3][3] = sbox_out[3][2] ^ round_key[3][3];\n        end else begin\n            // Standard round operations\n            // SubBytes\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_temp[i][j] = sbox_out[i][j];\n                end\n            end\n            \n            // ShiftRows\n            sa_temp[0][0] = sbox_out[0][0];\n            sa_temp[0][1] = sbox_out[0][1];\n            sa_temp[0][2] = sbox_out[0][2];\n            sa_temp[0][3] = sbox_out[0][3];\n            \n            sa_temp[1][0] = sbox_out[1][1];\n            sa_temp[1][1] = sbox_out[1][2];\n            sa_temp[1][2] = sbox_out[1][3];\n            sa_temp[1][3] = sbox_out[1][0];\n            \n            sa_temp[2][0] = sbox_out[2][2];\n            sa_temp[2][1] = sbox_out[2][3];\n            sa_temp[2][2] = sbox_out[2][0];\n            sa_temp[2][3] = sbox_out[2][1];\n            \n            sa_temp[3][0] = sbox_out[3][3];\n            sa_temp[3][1] = sbox_out[3][0];\n            sa_temp[3][2] = sbox_out[3][1];\n            sa_temp[3][3] = sbox_out[3][2];\n            \n            // MixColumns\n            // (omitted for brevity)\n            \n            // AddRoundKey\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa_temp[i][j] ^= round_key[i][j];\n                end\n            end\n        end\n        \n        // Convert state matrix to output\n        text_out[127:120] = {sa_temp[0][3], sa_temp[1][3], sa_temp[2][3], sa_temp[3][3]};\n        text_out[119:112] = {sa_temp[0][2], sa_temp[1][2], sa_temp[2][2], sa_temp[3][2]};\n        text_out[111:104] = {sa_temp[0][1], sa_temp[1][1], sa_temp[2][1], sa_temp[3][1]};\n        text_out[103:96]  = {sa_temp[0][0], sa_temp[1][0], sa_temp[2][0], sa_temp[3][0]};\n        \n        if (dcnt_next == 0) begin\n            done = 1'b1;\n        end\n    end\nend\n\n// Sequential logic\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        text_in_r <= 128'd0;\n        sa <= '{default: 8'd0};\n        dcnt <= 4'd0;\n        ld_r <= 1'b0;\n        text_out <= 128'd0;\n    end else begin\n        text_in_r <= (ld ? text_in : text_in_r);\n        sa <= sa_temp;\n        dcnt <= dcnt_next;\n        ld_r <= (ld ? 1'b1 : (dcnt != 0) ? 1'b1 : 1'b0);\n        text_out <= text_out;\n    end\nend\n\nendmodule : aes_cipher_top\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input               clk,\n    input               kld,\n    input   [127:0]     key,\n    output  [31:0]      wo_0,\n    output  [31:0]      wo_1,\n    output  [31:0]      wo_2,\n    output  [31:0]      wo_3\n);\n\nreg [3:0][7:0] round_key[3:0];\nreg [3:0] rcnt;\nreg [3:0][7:0] temp_word;\n\n// Key loading\nalways_ff @(posedge clk) begin\n    if (kld) begin\n        round_key[0] <= key[127:120];\n        round_key[1] <= key[119:112];\n        round_key[2] <= key[111:104];\n        round_key[3] <= key[103:96];\n        rcnt <= 4'd0;\n    end else begin\n        // Perform key expansion\n        if (rcnt < 10) begin\n            // Calculate new word\n            temp_word <= round_key[3];\n            \n            // RotWord\n            {temp_word[3], temp_word[2], temp_word[1], temp_word[0]} <= {round_key[3][24:31], round_key[3][16:23], round_key[3][8:15], round_key[3][0:7]};\n            \n            // SubWord\n            for (int i = 0; i < 4; i++) begin\n                temp_word[i] <= aes_sbox(temp_word[i]);\n            end\n            \n            // Rcon\n            if (rcnt == 0) begin\n                temp_word[0] <= temp_word[0] ^ 8'd1;\n            end else if (rcnt == 1) begin\n                temp_word[0] <= temp_word[0] ^ 8'd2;\n            end else if (rcnt == 2) begin\n                temp_word[0] <= temp_word[0] ^ 8'd4;\n            end else if (rcnt == 3) begin\n                temp_word[0] <= temp_word[0] ^ 8'd8;\n            end else if (rcnt == 4) begin\n                temp_word[0] <= temp_word[0] ^ 8'd10;\n            end else if (rcnt == 5) begin\n                temp_word[0] <= temp_word[0] ^ 8'd20;\n            end else if (rcnt == 6) begin\n                temp_word[0] <= temp_word[0] ^ 8'd40;\n            end else if (rc == 7) begin\n                temp_word[0] <= temp_word[0] ^ 8'd80;\n            end else if (rcnt == 8) begin\n                temp_word[0] <= temp_word[0] ^ 8'd1B;\n            end else if (rcnt == 9) begin\n                temp_word[0] <= temp_word[0] ^ 'd36;\n            end\n            \n            // XOR with previous word\n            round_key[0] <= round_key[0] ^ temp_word;\n            round_key[1] <= round_key[1] ^ round_key[0];\n            round_key[2] <= round_key[2] ^ round_key[1];\n            round_key[3] <= round_key[3] ^ round_key[2];\n            \n            rcnt <= rcnt + 1;\n        end\n    end\nend\n\n// Output assignment\nalways_comb begin\n    wo_0 = {round_key[0][24:31], round_key[0][16:23], round_key[0][8:15], round_key[0][0:7]};\n    wo_1 = {round_key[1][24:31], round_key[1][16:23], round_key[1][8:15], round_key[1][0:7]};\n    wo_2 = {round_key[2][24:31], round_key[2][16:23], round[2][8:15], round_key[2][0:7]};\n    wo_3 = {round_key[3][24:31], round_key[3][16:23], round_key[3][8:15], round_key[3][0:7]};\nend\n\nendmodule : aes_key_expand_128\n\n// aes_sbox module\nmodule aes_sbox(\n    input   [7:0] a,\n    output  [7:0] b\n);\n\n// S-box lookup table (simplified for brevity)\nreg [7:0] b;\n\nalways_comb begin\n    case(a)\n        8'd0: b = 8'd63;\n        8'd1: b = 8'd7c;\n        8'd2: b = 8'd77;\n        8'd3: b = 8'd7b;\n        // ... add remaining S-box entries\n        default: b = 8'd00;\n    endcase\nend\n\nendmodule : aes_sbox\n\n// aes_rcon module\nmodule aes_rcon(\n    input               clk,\n    input               kld,\n    output  [31:0]      out\n);\n\nreg [3:0] rcnt;\nreg [31:0] out_reg;\n\nalways_ff @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 4'd0;\n        out_reg <= 32'h01000000;\n    end else begin\n        rcnt <= rcnt + 1;\n        out_reg <= 32'd0;\n    end\nend\n\nalways_comb begin\n    if (rcnt == 0) begin\n        out = 32'h01000000;\n    end else if (rcnt == 1) begin\n        out = 32'h02000000;\n    end else if (rcnt == 2) begin\n        out = 32'h04000000;\n    end else if (rcnt == 3) begin\n        out = 32'h08000000;\n    end else if (rcnt == 4) begin\n        out = 32'h10000000;\n    end else if (rcnt == 5) begin\n        out = 32'h20000000;\n    end else if (rcnt == 6) begin\n        out = 32'h40000000;\n    end else if (rcnt == 7) begin\n        out = 32'h80000000;\n    end else if (rcnt == 8) begin\n        out = 32'h1B000000;\n    end else if (rcnt == 9) begin\n        out = 32'h36000000;\n    end else begin\n        out = 32'd0;\n    end\nend\n\nendmodule : aes_rcon", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 15, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    // Registers\n    reg [127:0] text_in_r;\n    reg [3:0][3:0][7:0] sa;\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    // Submodules\n    aes_key_expand_128 key_expand(\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(),\n        .wo_1(),\n        .wo_2(),\n        .wo_3()\n    );\n\n    // Control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            dcnt <= 11; // Initial round counter value\n            ld_r <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            if (ld) begin\n                // Load input data\n                text_in_r <= text_in;\n                ld_r <= 1'b1;\n            end else if (ld_r) begin\n                // Perform initial round key addition\n                text_out <= text_in_r ^ key;\n                dcnt <= dcnt - 1;\n                ld_r <= 1'b0;\n            end else if (dcnt > 0) begin\n                // Perform standard rounds\n                if (dcnt == 1) begin\n                    // Final round (no MixColumns)\n                    text_out <= final_round(text_out);\n                    done <= 1'b1;\n                end else begin\n                    text_out <= round_operation(text_out);\n                    dcnt <= dcnt - 1;\n                end\n            end\n        end\n    end\n\n    // SubBytes, ShiftRows, MixColumns, AddRoundKey functions\n    function [127:0] sub_bytes;\n        // S-box substitution for each byte\n    endfunction\n\n    function [127:0] shift_rows;\n        // Row shifting operation\n    endfunction\n\n    function [127:0] mix_columns;\n        // Column mixing operation\n    endfunction\n\n    function [127:0] add_round_key;\n        // Round key addition\n    endfunction\n\n    function [127:0] final_round;\n        // Final round operation (no MixColumns)\n    endfunction\n\n    function [127:0] round_operation;\n        // Standard round operation\n    endfunction\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    // Registers\n    reg [31:0] w0, w1, w2, w3;\n    reg [3:0] rcnt;\n\n    // S-box submodule\n    aes_sbox sbox(\n        .a(),\n        .b()\n    );\n\n    // Round constant submodule\n    aes_rcon rcon(\n        .clk(clk),\n        .kld(kld),\n        .out()\n    );\n\n    // Key loading logic\n    always @(posedge clk or posedge kld) begin\n        if (kld) begin\n            w0 <= key[127:96];\n            w1 <= key[95:64];\n            w2 <= key[63:32];\n            w3 <= key[31:0];\n            rcnt <= 0;\n        end else begin\n            // Perform key expansion\n            if (rcnt < 10) begin\n                // Calculate next round key\n                w0 <= w0 ^ sbox.out ^ rcon.out;\n                w1 <= w0;\n                w2 <= w1;\n                w3 <= w2;\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\n    // Output assignments\n    assign wo_0 = w0;\n    assign wo_1 = w1;\n    assign wo_2 = w2;\n    assign wo_3 = w3;\n\nendmodule\n\n// aes_sbox module (S-box lookup table implementation)\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] b;\n\n    // S-box lookup table (256 entries)\n    always @(*) begin\n        case (a)\n            8'h00: b = 8'h63; // Example value for 0x00\n            8'h01: b = 8'h7c;\n            // Add all 256 entries of the S-box\n            // ...\n            default: b = 8'h00;\n        endcase\n    end\n\nendmodule\n\n// aes_rcon module (round constant generation)\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [31:0] out;\n    reg [3:0] rcnt;\n\n    always @(posedge clk or posedge kld) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01000000; // Initial round constant\n        end else begin\n            if (rcnt < 10) begin\n                // Generate next round constant\n                if (rcnt == 0) begin\n                    out <= 32'h01000000; // RC[0]\n                end else if (rcnt == 1) begin\n                    out <= 32'h02000000; // RC[1]\n                end else if (rcnt == 2) begin\n                    out <= 32'h04000000; // RC[2]\n                end\n                // Add all 10 round constants\n                // ...\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 16, "code": "// aes_cipher_top.v\nmodule aes_cipher_top(\n    input               clk,\n    input               rst,\n    input               ld,\n    output              done,\n    input       [127:0] key,\n    input       [127:0] text_in,\n    output      [127:0] text_out\n);\n\n// Internal registers\nreg [127:0] text_in_r;\nreg [3:0][3:0][7:0] sa;\nreg [3:0] dcnt;\nreg               ld_r;\nreg [127:0] text_out;\n\n// Key expansion module instance\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(ld),\n    .key(key),\n    .wo_0(),\n    .wo_1(),\n    .wo_2(),\n    .wo_3()\n);\n\n// Main state machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        text_in_r <= 128'd0;\n        sa <= '{default: '0};\n        dcnt <= 4'd11;\n        ld_r <= 1'd0;\n        text_out <= 128'd0;\n    end else if (ld) begin\n        // Initial round key addition\n        text_in_r <= text_in;\n        dcnt <= 4'd11;\n        ld_r <= 1'd1;\n    end else if (ld_r == 1'd1) begin\n        // Perform encryption rounds\n        if (dcnt > 4'd0) begin\n            // Standard rounds (1-9)\n            // SubBytes\n            for (int i = 0; i < 16; i++) begin\n                sa[i / 4][i % 4] <= aes_sbox(sa[i / 4][i % 4]);\n            end\n            \n            // ShiftRows\n            // Row 1 shift left 1\n            {sa[1][1], sa[1][0], sa[1][3], sa[1][2]} <= {sa[1][0], sa[1][1], sa[1][2], sa[1][3]};\n            // Row 2 shift left 2\n            {sa[2][2], sa[2][3], sa[2][0], sa[2][1]} <= {sa[2][0], sa[2][1], sa[2][2], sa[2][3]};\n            // Row 3 shift left 3\n            {sa[3][3], sa[3][0], sa[3][1], sa[3][2]} <= {sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n            \n            // MixColumns (except final round)\n            // Column mixing implementation\n            for (int col = 0; col < 4; col++) begin\n                byte out0, out1, out2, out3;\n                out0 = (sa[0][col] << 1) ^ (sa[1][col] << 1) ^ sa[2][col] ^ sa[3][col];\n                out1 = sa[0][col] ^ (sa[1][col] << 1) ^ (sa[2][col] << 1) ^ sa[3][col];\n                out2 = sa[0][col] ^ sa[1][col] ^ (sa[2][col] << 1) ^ (sa[3][col] << 1);\n                out3 = sa[0][col] ^ sa[1][col] ^ sa[2][col] ^ (sa[3][col] << 1);\n                {sa[0][col], sa[1][col], sa[2][col], sa[3][col]} <= {out0, out1, out2, out3};\n            end\n            \n            // AddRoundKey\n            // XOR with round key (from key_expand module)\n            for (int i = 0; i < 16; i++) begin\n                sa[i / 4][i % 4] <= sa[i / 4][i % 4] ^ key_expand.wo_0[i * 8 +: 8];\n            end\n            \n            dcnt <= dcnt - 1'd1;\n        end else begin\n            // Final round (Round 10)\n            // SubBytes\n            for (int i = 0; i < 16; i++) begin\n                sa[i / 4][i % 4] <= aes_sbox(sa[i / 4][i % 4]);\n            end\n            \n            // ShiftRows\n            // Row 1 shift left 1\n            {sa[1][1], sa[1][0], sa[1][3], sa[1][2]} <= {sa[1][0], sa[1][1], sa[1][2], sa[1][3]};\n            // Row 2 shift left 2\n            {sa[2][2], sa[2][3], sa[2][0], sa[2][1]} <= {sa[2][0], sa[2][1], sa[2][2], sa[2][3]};\n            // Row 3 shift left 3\n            {sa[3][3], sa[3][0], sa[3][1], sa[3][2]} <= {sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n            \n            // AddRoundKey\n            // XOR with final round key\n            for (int i = 0; i < 16; i++) begin\n                sa[i / 4][i % 4] <= sa[i / 4][i % 4] ^ key_expand.wo_0[i * 8 +: 8];\n            end\n            \n            // Final output formation\n            for (int i = 0; i < 16; i++) begin\n                text_out[i * 8 +: 8] <= sa[i / 4][i % 4];\n            end\n            \n            done <= 1'd1;\n        end\n    end else if (done) begin\n        // Reset to idle state after encryption\n        done <= 1'd0;\n        ld_r <= 1'd0;\n    end else begin\n        // Idle state\n        ld_r <= 1'd0;\n        done <= 1'd0;\n    end\nend\n\n// Instantiate S-box module\naes_sbox sbox();\n\nendmodule\n\n// aes_key_expand_128.v\nmodule aes_key_expand_128(\n    input               clk,\n    input               kld,\n    input       [127:0] key,\n    output      [31:0] wo_0,\n    output      [31:0] wo_1,\n    output      [31:0] wo_2,\n    output      [31:0] wo_3\n);\n\n// Internal registers\nreg [31:0] w0, w1, w2, w3;\nreg [3:0] rcnt;\n\n// Key loading logic\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        w0 <= key[127:96];\n        w1 <= key[95:64];\n        w2 <= key[63:32];\n        w3 <= key[31:0];\n        rcnt <= 4'd0;\n    end else begin\n        // Expand key\n        byte sbox_out;\n        rcnt <= rcnt + 1'd1;\n        \n        // RotWord and SubWord\n        byte temp[3:0];\n        temp[0] <= w3[23:16];\n        temp[1] <= w3[15:8];\n        temp[2] <= w3[7:0];\n        temp[3] <= w2[23:16];\n        \n        for (int i = 0; i < 4; i++) begin\n            sbox_out = aes_sbox(temp[i]);\n            temp[i] <= sbox_out;\n        end\n        \n        // Rcon XOR\n        temp[0] <= temp[0] ^ (rcnt == 4'd1) ? 8'd01 :\n                         (rcnt == 4'd2) ? 8'd02 :\n                         (rcnt == 4'd3) ? 8'd04 :\n                         (rcnt == 4'd4) ? 8'd08 :\n                         (rcnt == 4'd5) ? 8'd10 :\n                         (rcnt == 4'd6) ? 8'd20 :\n                         (rcnt == 4'd7) ? 8'd40 :\n                         (rcnt == 4'd8) ? 8'd80 :\n                         (rcnt == 4'd9) ? 8'd1B : 8'd00;\n        \n        // Update w0\n        w0 <= w0 ^ (temp[0] << 24) ^ (temp[1] << 16) ^ (temp[2] << 8) ^ temp[3];\n        \n        // Update w1, w2, w3\n        w1 <= w0;\n        w2 <= w1;\n        w3 <= w2;\n    end\nend\n\n// Assign outputs\nassign wo_0 = w0;\nassign wo_1 = w1;\nassign wo_2 = w2;\nassign wo_3 = w3;\n\n// Instantiate S-box module\naes_sbox sbox();\n\nendmodule\n\n// aes_sbox.v\nmodule aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table implementation (256 entries)\nreg [7:0] sbox_table[0:255];\n\n// Initialize S-box table\ninitial begin\n    // Fill S-box lookup table (omitted for brevity)\n    // Example entry: sbox_table[0] = 8'd63;  // 0x00 -> 0x63\n    // ... (256 entries)\nend\n\n// Assign output from lookup table\nassign b = sbox_table[a];\n\nendmodule\n\n// aes_rcon.v\nmodule aes_rcon(\n    input   clk,\n    input   kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\n// Round constant generation\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 4'd0;\n        rcon <= 32'd1;\n    end else begin\n        rcnt <= rcnt + 1'd1;\n        if (rcnt < 4'd10) begin\n            rcon <= {rcon[23:0], rcon[31] ^ (rcon[7] & rcnt[0])};\n        end else begin\n            rcon <= 32'd0;\n        end\n    end\nend\n\nassign out = rcon;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 17, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\nreg [127:0] text_in_r;\nreg [3:0][3:0][7:0] sa;\nreg [3:0] dcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Submodules\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(ld),\n    .key(key),\n    .wo_0(),\n    .wo_1(),\n    .wo_2(),\n    .wo_3()\n);\n\n// Control logic\nalways @(posedge clk) begin\n    if (rst) begin\n        text_in_r <= 128'd0;\n        sa <= '{default: 8'd0};\n        dcnt <= 4'd0;\n        ld_r <= 1'b0;\n        text_out <= 128'd0;\n        done <= 1'b0;\n    end else if (ld) begin\n        text_in_r <= text_in;\n        ld_r <= 1'b1;\n        dcnt <= 4'd11;\n        done <= 1'b0;\n    end else if (ld_r && dcnt >= 4'd0) begin\n        // Perform round operations\n        if (dcnt > 4'd0) begin\n            // Standard round operations (1-9)\n            // SubBytes, ShiftRows, MixColumns, AddRoundKey\n        end else if (dcnt == 4'd0) begin\n            // Final round (10)\n            // SubBytes, ShiftRows, AddRoundKey\n            done <= 1'b1;\n        end\n        dcnt <= dcnt - 1'b1;\n    end\nend\n\n// Assign text_out after final round\nassign text_out = (done) ? text_in_r : 128'd0;\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [31:0] w0, w1, w2, w3;\nreg [3:0] rcnt;\n\n// Round constant generator\naes_rcon rcon(\n    .clk(clk),\n    .kld(kld),\n    .out()\n);\n\n// Key loading logic\nalways @(posedge clk) begin\n    if (kld) begin\n        w0 <= key[127:96];\n        w1 <= key[95:64];\n        w2 <= key[63:32];\n        w3 <= key[31:0];\n        rcnt <= 4'd0;\n    end else if (rcnt <= 4'd9) begin\n        // Perform key expansion\n        // w[i] = w[i-4] ^ T(w[i-1]) when i mod 4 = 0\n        // w[i] = w[i-4] ^ w[i-1] otherwise\n        rcnt <= rcnt + 1'b1;\n    end\nend\n\nassign wo_0 = w0;\nassign wo_1 = w1;\nassign wo_2 = w2;\nassign wo_3 = w3;\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n// S-box lookup table (256 entries)\nreg [7:0] sbox[0:255];\n\n// Initialize S-box values (256 entries)\ninitial begin\n    // S-box initialization (256 entries)\n    sbox[0] = 8'd99;\n    sbox[1] = 8'd124;\n    sbox[2] = 8'd119;\n    // ... (remaining 253 entries)\nend\n\nassign b = sbox[a];\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 4'd0;\n        out <= 32'h01000000;\n    end else if (rcnt <= 4'd9) begin\n        rcnt <= rcnt + 1'b1;\n        // Generate round constant based on rcnt\n        case (rcnt)\n            4'd0: out <= 32'h01000000;\n            4'd1: out <= 32'h02000000;\n            4'd2: out <= 32'h04000000;\n            4'd3: out <= 32'h08000000;\n            4'd4: out <= 32'h10000000;\n            4'd5: out <= 32'h20000000;\n            4'd6: out <= 32'h40000000;\n            4'd7: out <= 32'h80000000;\n            4'd8: out <= 32'h1B000000; // 0x1B in GF(2^8)\n            4'd9: out <= 32'h36000000; // 0x36 in GF(2^8)\n            default: out <= 32'd0;\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 18, "code": "// aes_cipher_top module\nmodule aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [3:0][3:0][7:0] sa;\n    reg [3:0] dcnt;\n    reg ld_r;\n    reg [127:0] text_out_r;\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n    aes_key_expand_128 key_expand(\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            dcnt <= 4'd0;\n            ld_r <= 1'b0;\n            done <= 1'b0;\n            text_in_r <= {128{1'b0}};\n            text_out_r <= {128{1'b0}};\n            sa <= '{default: '0};\n        end else begin\n            if(ld && !ld_r) begin // Initial load\n                text_in_r <= text_in;\n                dcnt <= 4'd11;\n                ld_r <= 1'b1;\n                // Initial round key addition\n                for(int i = 0; i < 4; i++) begin\n                    for(int j = 0; j < 4; j++) begin\n                        sa[i][j] <= text_in[127 - (i * 32 + j * 8 +: 8)] ^ wo_0[31 - (j * 8 +: 8)];\n                    end\n                end\n            end else if(dcnt > 4'd0) begin\n                // Perform round operations\n                if(dcnt == 4'd11) begin // Final round\n                    // SubBytes\n                    for(int i = 0; i < 4; i++) begin\n                        for(int j = 0; j < 4; j++) begin\n                            aes_sbox sbox_inst(\n                                .a(sa[i][j]),\n                                .b(sa[i][j])\n                            );\n                        end\n end\n                    // ShiftRows\n                    // ShiftRows operation here\n                    // AddRoundKey (final round key)\n                    for(int i = 0; i < 4; i++) begin\n                        for(int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ (wo_0[31 - (j * 8 +: 8)]);\n                        end\n                    end\n                end else begin // Normal rounds\n                    // SubBytes\n                    for(int i = 0; i < 4; i++) begin\n                        for(int j = 0; j < 4; j++) begin\n                            aes_sbox sbox_inst(\n                                .a(sa[i][j]),\n                                .b(sa[i][j])\n                            );\n                        end\n                    end\n                    // ShiftRows\n                    // Implement ShiftRows operation here\n                    // MixColumns\n                    // Implement MixColumns operation here\n                    // AddRoundKey\n                    for(int i = 0; i < 4; i++) begin\n                        for(int j = 0; j < 4; j++) begin\n                            sa[i][j] <= sa[i][j] ^ (wo_0[31 - (j * 8 +: 8)]);\n                        end\n                    end\n                end\n                dcnt <= dcnt - 1;\n            end else if(dcnt == 4'd0) begin // Finalization\n                // Output formatting\n                for(int i = 0; i < 4; i++) begin\n                    for(int j = 0; j < 4; j++) begin\n                        text_out_r[127 - (i * 32 + j * 8 +: 8)] <= sa[i][j];\n                    end\n                end\n                done <= 1'b1;\n            end\n        end\n    end\n\n    assign text_out = text_out_r;\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0]_2,\n    output [31:0] wo_3\n);\n\n    reg [:0] w_reg[0:3];\n    wire [7:0] sbox_out;\n    aes_sbox sbox_inst(\n        .a(),\n        .b(sbox_out)\n    );\n    aes_rcon rcon_inst(\n        .clk(clk),\n        .kld(kld),\n        .out()\n    );\n\n    always @(posedge clk) begin\n        if(kld) begin\n            w_reg[0] <= key[127:96];\n            w_reg[1] <= key[95:64];\n            w_reg[2] <= key[63:32];\n            w_reg[3] <= key[31:0];\n        end else begin\n            w_reg[0] <= w_reg[3] ^ (sbox_inst.b ^ rcon_inst.out);\n            w_reg[1] <= w_reg[0];\n            w_reg[2] <= w_reg[1];\n            w_reg[3] <= w_reg[2];\n        end\n    end\n\n    assign wo_0 = w_reg[0];\n    assign wo_1 = w_reg[1];\n    assign wo_2 = w_reg[2];\n    assign wo_3 = w_reg[3];\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // Implement S-box lookup table here\n    // Example:\n    reg [7:0] sbox[256];\n    always @(*) begin\n        b = sbox[a];\n    end\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    reg [3:0] rcnt;\n    always @(posedge clk) begin\n        if(kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else begin\n            rcnt <= rcnt + 1;\n            // Implement round constant generation logic here\n            // Example:\n            case(rcnt)\n                0: out <= 32'h01_00_00_00;\n                1: out <= 32'h02_00_00_00;\n                2: out <= 32'h04_00_00_00;\n                // ... add more cases for other round constants\n                default: out <= 32'h00_00_00_00;\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 19, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Internal Registers\nreg [127:0] text_in_r;\nreg [3:0][3:0][7:0] sa;\nreg [3:0] dcnt;\nreg ld_r;\nreg [127:0] text_out_reg;\n\n// Submodules\naes_key_expand_128 key_expander(\n    .clk(clk),\n    .kld(ld),\n    .key(key),\n    .wo_0(sa[0][0][31:0]),\n    .wo_1(sa[0][1][31:0]),\n    .wo_2(sa[0][2][31:0]),\n    .wo_3(sa[0][3][31:0])\n);\n\n// Main Logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        dcnt <= 4'b1101; // 11 in decimal (10 rounds + initial round)\n        ld_r <= 1'b0;\n        text_in_r <= 128'd0;\n        text_out_reg <= 128'd0;\n        done <= 1'b0;\n    end else if (ld) begin\n        text_in_r <= text_in;\n        dcnt <= 4'b1101; // Reset round counter\n        ld_r <= 1'b1;\n        done <= 1'b0;\n    end else if (ld_r) begin\n        // Perform encryption rounds\n        if (dcnt > 0) begin\n            // SubBytes\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= aes_sbox(sa[i][j]);\n                end\n            end\n\n            // ShiftRows\n            for (int i = 1; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][(j + i) % 4] <= sa[i][j];\n                end\n            end\n\n            // MixColumns (except final round)\n            if (dcnt != 1) begin\n                for (int j = 0; j < 4; j++) begin\n                    byte temp[4];\n                    for (int k = 0; k < 4; k++) begin\n                        temp[k] = sa[k][j];\n                    end\n                    {sa[0][j], sa[1][j], sa[2][j], sa[3][j]} <=\n                        mix_columns(temp);\n                end\n            end\n\n            // AddRoundKey\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ sa[0][i][31:0];\n                end\n            end\n\n            dcnt <= dcnt - 1;\n        end else if (dcnt == 0) begin\n            // Final round\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= aes_sbox(sa[i][j]);\n                end\n            end\n\n            // ShiftRows\n            for (int i = 1; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][(j + i) % 4] <= sa[i][j];\n                end\n            end\n\n            // AddRoundKey\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ sa[0][i][31:0];\n                end\n            end\n\n            // Generate output\n            text_out_reg <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                             sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                             sa[0][2], sa[1][2],[2][2], sa[32],\n                             sa[0][3 sa[1][3], sa[2][3], sa[3][3]};\n            done <= 1'b1;\n            ld_r <= 1'b0;\n        end\n   \nend\n\nassign text_out = text_out_reg;\n\nfunction [7:0] aes_sbox;\n    input [7:0] in_byte;\n    reg [7:0] out_byte;\n    // S-box table implementation (simplified for brevity)\n    out_byte = in_byte ^ 8'h63; // Example substitution\n    aes_sbox = out_byte;\nendfunction\n\nfunction [31:0] mix_columns;\n    input byte in_col[4];\n    reg [31:0] out_col;\n    // Finite field multiplication and XOR operations\n    out_col = {in_col[0] ^ in_col[1] ^ in_col[2] ^ in_col[3],\n               in_col[0] ^ in_col[1] ^ in_col[2] ^ in_col[3],\n               in_col[0] ^ in_col[1] ^ in_col[2] ^ in_col[3],\n               in_col[0] ^ in_col[1] ^ in_col[2] ^ in_col[3]};\n    mix_columns = out_col;\nendfunction\n\nendmodule\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output31:0] wo_0,\n    output [:0] wo1,\n    output [:0] wo_2,\n    output [310] wo_\n);\n\nreg [3:0] rcnt;\nreg [31:0] w[4:0];\n\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 4'd0;\n        w[0] <= key[127:96];\n        w[1] <= key[95:64];\n        w[2] <= key[63:32];\n        w[3] <= key[31:0];\n    end else begin\n        if (rcnt < 10) begin\n            byte temp_1, temp_2, temp_3;\n            temp_1 = w[3][7:0];\n            temp_2 = w[3][15:8];\n            temp_3 = w[3][23:16];\n            \n            w[4] <= {w[0][7:0] ^ aes_sbox(temp_1) ^ rcon[rcnt],\n                     w[0][15:8] ^ aes_sbox(temp_2) ^ rcon[rcnt],\n                     w[0][23:16] ^ aes_sbox(temp_3) ^ rcon[rcnt],\n                     w[0][31:24] ^ aes_sbox(w[3][31:24]) ^ rcon[rcnt]};\n            \n            w[1] <= w[1] ^ w[4];\n            w[2] <= w[2] ^ w[1];\n            w[3] <= w[3] ^ w[2];\n            \n            rcnt <= rcnt + 1;\n        end\n    end\nend\n\nassign wo_0 = w[0];\nassign wo_1 = w[1];\nassign wo_2 = w[2];\nassign wo_3 = w[3];\n\nreg [7:0] rcon[10];\ninitial begin\n    rcon[0] = 8'h01;\n    rcon[1] = 8'h02;\n    rcon[2] = 8'h04;\n    rcon[3] = 8'h08;\n    rcon[4] = 8'h10;\n    rcon[5] = 8'h20;\n    rcon[6] = 'h40;\n   con[7] = 8'h80;\n    rcon[8] = 8'h1b;\n    rcon[9] = 8'h36;\nend\n\nfunction [7:0] aes_sbox;\n    input [7:0] in_byte;\n    reg [7:0] out_byte;\n    // S-box table implementation (simplified for brevity)\n    out_byte = in_byte ^ 8'h63; // Example substitution\n    aes_sbox = out_byte;\nendfunction\n\nendmodule\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n// Implement S-box lookup table (omitted for brevity)\n// Example implementation:\nassign b = a ^ 8'h63;\n\nendmodule\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [7:0] rcon[10];\n\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 4'd0;\n        out <= 32'h01000000;\n    end else begin\n        out <= {rcon[rcnt], 24'd0};\n        rcnt <= rcnt + 1;\n    end\nend\n\ninitial begin\n    rcon[0] = 8'h01;\n    rcon[1] = 8'h02;\n    rcon[2] = 8'h04;\n    rcon[3] = 8'h08;\n    rcon[4] = 8'h10;\n    rcon[5] = 8'h20;\n    rcon[6] = 8'h40;\n    rcon[7] = 8'h80;\n    rcon[8] = 8'h1b;\n    rcon[9] = 8'h36;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 20, "code": "module aes_cipher_top(\n    input clk,\n    input rst,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [3:0][3:0][7:0] sa; // State matrix (4x4)\nreg [3:0] dcnt; // Round counter (4 bits)\nreg ld_r; // Load flag\nreg [127:0] text_out_r; // Output ciphertext\n\n// Submodule instances\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(ld),\n    .key(key),\n    .wo_0(round_key_0),\n    .wo_1(round_key_1),\n    .wo_2(round_key_2),\n    .wo_3(round_key_3)\n);\nwire [31:0] round_key_0, round_key_1, round_key_2, round_key_3;\n\n// Internal round key concatenation\nwire [127:0] round_key = {round_key_3, round_key_2, round_key_1, round_key_0};\n\n// Main logic\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        // Reset state\n        dcnt <= 4'd11; // 10 rounds + initial round\n        ld_r <= 1'b0;\n        done <= 1'b0;\n        text_in_r <= 128'd0;\n        sa <= '{default: 8'd0};\n        text_out_r <= 128'd0;\n    end else if (ld) begin\n        // Load data\n        text_in_r <= text_in;\n        ld <= 1'b1;\n        dcnt <= 4'd11;\n        done <= 1'b0;\n        // Initial round key addition\n        for (int i = 0; i < 16; i++) begin\n            sa[i / 4][i % 4] <= text_in[i*8 +: 8] ^ round_key[i*8 +: 8];\n        end\n    end else if (dcnt > 4'd0) begin\n        // Encryption rounds\n        if (ld_r) begin\n            // Perform transformations\n            // SubBytes\n            for (int i = 0; i < 16; i++) begin\n                // S-box substitution (assuming aes_sbox module is defined)\n                sa[i / 4][i % 4] <= aes_sbox(sa[i / 4][i % 4]);\n            end\n            \n            // ShiftRows\n            for (int i = 0; i < 4; i++) begin\n                // Row shifting (hardcoded for this example)\n                case (i)\n                    1: {sa[i][3], sa[i][2], sa[i][1], sa[i][0]} <= {sa[i][1], sa[i][2], sa[i][3], sa[i][0]};\n                    2: {sa[i][3], sa[i][2], sa[i][1], sa[i][0]} <= {sa[i][2], sa[i][3], sa[i][0], sa[i][1]};\n                    3: {sa[i][3], sa[i][2], sa[i][1], sa[i][0]} <= {sa[i][3], sa[i][0], sa[i][1], sa[i][2]};\n                    default: ; // No shift for row 0\n                endcase\n            end\n            \n            // MixColumns (except final round)\n            if (dcnt > 4'd1) begin\n                reg [3:0][7:0] new_sa;\n                for (int j = 0; j < 4; j++) begin\n                    new_sa[0] <= aes_mixcolumn(sa[0][j], sa[1][j], sa[2][j], sa[3][j]);\n                    new_sa[1] <= aes_mixcolumn(sa[1][j], sa[2][j], sa[3][j], sa[0][j]);\n                    new_sa[2] <= aes_mixcolumn(sa[2][j], sa[3][j], sa[0][j], sa[1][j]);\n                    new_sa[3] <= aes_mixcolumn(sa[3][j], sa[0][j], sa[1][j], sa[2][j]);\n                end\n                sa <= new_sa;\n            end\n            \n            // AddRoundKey\n            for (int i = 0; i < 16; i++) begin\n                sa[i / 4][i % 4] <= sa[i / 4][i % 4] ^ round_key[i*8 +: 8];\n            end\n            \n            dcnt <= dcnt - 4'd1;\n            ld_r <= 1'b0;\n        end\n    end else if (dcnt == 4'd0) begin\n        // Final round (no MixColumns)\n        // SubBytes\n        for (int i = 0; i < 16; i++) begin\n            sa[i / 4][i % 4] <= aes_sbox(sa[i / 4][i % 4]);\n        end\n        \n        // ShiftRows\n        for (int i = 0; i < 4; i++) begin\n            case (i)\n                1: {sa[i][3], sa[i][2], sa[i][1], sa[i][0]} <= {sa[i][1], sa[i][2], sa[i][3], sa[i][0]};\n                2: {sa[i][3], sa[i][2], sa[i][1], sa[i][0]} <= {sa[i][2], sa[i][3], sa[i][0], sa[i][1]};\n                3: {sa[i][3], sa[i][2], sa[i][1], sa[i][0]} <= {sa[i][3], sa[i][0], sa[i][1], sa[i][2]};\n                default: ; // No shift for row 0\n            endcase\n        end\n        \n        // AddRoundKey\n        for (int i = 0; i < 16; i++) begin\n            sa[i / 4][i % 4] <= sa[i / 4][i % 4] ^ round_key[i*8 +: 8];\n        end\n        \n        // Set final output\n        for (int i = 0; i < 16; i++) begin\n            text_out_r[8*i +: 8] <= sa[i / 4][i % 4];\n        end\n        \n        done <= 1'b1;\n    end\nend\n\nassign text_out = text_out_r;\n\n// Submodules (instances shown above, definitions omitted for brevity)\n// aes_key_expand_128, aes_sbox, aes_mixcolumn would be defined separately\nendmodule\n\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n// Implementation omitted for brevity\nendmodule\n\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n// Implementation omitted for brevity\nendmodule\n\nfunction [7:0] aes_mixcolumn(\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d\n);\n// Implementation omitted for brevity\nendfunction", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 1, "code": "// AES Inverse Cipher Top Module\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Internal Registers\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb[10:0];\nreg [3:0] kcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Key Expansion Module\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(kb[10]),\n    .wo_1(kb[9]),\n    .wo_2(kb[8]),\n    .wo_3(kb[7])\n);\n\n// Inverse S-box Modules (16 instances)\naes_inv_sbox us[0:15] (\n    .a({sa[0][0], sa[1][0], sa[2][0], sa[3][0]}),\n    .b({sa[0][1], sa[1][1], sa[2][1], sa[3][1]})\n);\n\n// Control Logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        dcnt <= 0;\n        kcnt 4'hA;\n        ld_r <= 0;\n        done <= 0;\n    end else begin\n        if (kld)\n            kcnt <=4'hA        end else if (ld) begin\n            ld_r <= 1;\n        end else if (ld_r &&cnt == 4'd11) begin\n            done <= 1;\n        end else if (ld_r && dcnt != 4'd11) begin\n            dcnt <= dcnt + 1;\n        end else begin\n            ld_r <= 0;\n        end\n    end\nend\n\n// Key Loading Logic\nalways @(posedge clk) begin\n    if (kld) begin\n        kb[10] <= key[127:96];\n        kb[9] <= key[95:64];\n        kb[8] <= key[63:32];\n        kb[7] <= key[31:0];\n    end else begin\n        if (kcnt != 0) begin\n            kb[kcnt-1] <= kb[kcnt-1] ^ kb[kcnt];\n            kcnt <= kcnt - 1;\n        end\n    end\nend\n\n// Initial Data Loading\nalways @(posedge clk) begin\n    if (ld) begin\n        text_in_r <= text_in;\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[j][i] <= text_in_r[(i*32) + (j*8) + 7 : (i*32) + (j*8)];\n            end\n        end\n    end\nend\n\n// Round Transformations\nalways @(posedge clk) begin\n    if (ld_r) begin\n        // InvSubBytes\n        for (int i = 0; i < 16; i++) begin\n            us[i].a <= {sa[i%4][i/4]};\n            sa[i%4][i/4] <= us[i].b;\n        end\n        \n        // InvShiftRows\n        // Row 1: Cyclic right shift by 3 bytes\n        {sa[1][0], sa[1][1], sa[1][2], sa[1][3]} <= {sa[1][3], sa[1][0], sa[1][1], sa[1][2]};\n        // Row 2: Cyclic right shift by 2 bytes\n        {sa[2][0], sa[2][1], sa[2][2], sa[2][3]} <= {sa[2][2], sa[2][3], sa2][0], sa2][1]};\n        // Row 3: Cyclic right shift by 1 byte\n        {sa[3][0], sa[3][1], sa[3][2], sa[3][3]} <= {sa[3][1], sa[3][2], sa[3][3], sa[3][0]};\n        \n        // InvMixColumns (for rounds 1-9)\n        if (dcnt != 4'd11) begin\n            // Column mixing operation (GF(2^8) multiplication)\n            for (int col = 0; col < 4; col++) begin\n                reg [7:0] s0, s1, s2, s3, out0, out1, out2, out3;\n                s0 = sa[0][col];\n                s1 = sa[1][col];\n                s2 = sa[2][col];\n                s3 = sa[3][col];\n                \n                out0 = (pmul_e(s0) ^ pmul_b(s1) ^ pmul_d(s2) ^ pmul_9(s3));\n                out1 = (pmul_9(s0) ^ pmul_e(s1) ^ pmul_b(s2) ^ pmul_d(s3));\n                out2 = (pmul_d(s0) ^ pmul_9(s1) ^ pmul_e(s2) ^ pmul_b(s3));\n                out3 = (pmul_b(s0) ^ pmul_d(s1) ^ pmul_9(s2) ^ pmul_e(s3));\n                \n                sa[0][col] <= out0;\n                sa[1][col] <= out1;\n                sa[2][col] <= out2;\n                sa[3][col] <= out3;\n            end\n        end\n        \n        // AddRoundKey\n        for (int i = 0; i < 16; i++) begin\n            sa[i%4][i/4] <= sa[i%4][i/4] ^ kb[dcnt][i*8 + 7 : i*8];\n        end\n    end\nend\n\n// Output Generation\nalways @(posedge clk) begin\n    if (done) begin\n        for (int i = 0; i < 16; i++) begin\n            text_out[(i*8) + 7 : (i*8)] <= sa[i%4][i/4];\n        end\n    end\nend\n\n//(2^8)lication Functions\n reg [7:0] pmul_e;\n    input [7:0] x;\n    pmul_e = x ^ (x<<1) ^ (x<<2) ^ (x<<3);\nendfunction\n\nfunction reg [7:0] pmul_b;\n    input [7:0] x;\n    pmul_b = x ^ (x<<2) ^ (x<<3) ^ (x<<4);\nendfunction\n\nfunction reg [7:0] pmul_d;\n    input [7:0] x;\n    pmul_d = x ^ (x<<1) ^ (x<<2) ^ (x<<5);\nendfunction\n\nfunction reg [7:0] pmul_9;\n    input [7:0] x;\n    pmul_9 = x ^ (x<<1) ^ (x<<3) ^ (x<<4);\nendfunction\n\nendmodule\n\n// Inverse S-Box Module\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox[0:255];\n    \n    // Initialize lookup table (pre-computed inverse S-box values)\n    initial begin\n        inv_sbox[0] = 8'h52;\n        inv_sbox[1] = 8'h09;\n        inv_sbox[2] = 8'h4a;\n        // ... (rest of the 256 entries)\n        inv_sbox[255] = 8'h7d;\n    end\n    \n    assign b = inv_sbox[a];\nendmodule\n\n// Key Expansion Module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n    // Internal registers\n    reg [31:0] w[0:43];\n    reg [3:0] rcnt;\n    \n    // S-box module for key expansion\n    aes_sbox sbox(\n        .a(w[1][7:0]),\n        .b(w[1][7:0])\n    );\n    \n    // Round constant generation\n    aes_rcon rcon(\n        .clk(clk),\n        .kld(kld),\n        .out(rcnt)\n    );\n    \n    // Key loading logic\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 4'h1;\n        end else begin\n            if (rcnt != 0) begin\n                w[rcnt] <= w[rcnt-1] ^ sbox.b ^ (rcnt == 4'h1 ? rcnt : 8'h00);\n                rcnt <= rcnt - 1;\n            end\n        end\n    end\n    \n    assign wo_0 = w[4];\n    assign wo_1 = w[5];\n    assign wo_2 = w[6];\n    assign wo_3 = w[7];\nendmodule\n\n// S-Box Module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n    // S-box lookup table\n    reg [7:0] sbox[0:255];\n    \n    // Initialize lookup table (pre-computed S-box values)\n    initial begin\n        sbox[0] = 8'h63;\n        sbox[1] = 8'h7c;\n        sbox[2] = 8'h77;\n        // ... (rest of the 256 entries)\n        sbox[255] = 8'h34;\n    end\n    \n    assign b = sbox[a];\nendmodule\n\n// Round Constant Generation\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n    reg [3:0] rcnt;\n    reg [7:0] rcon_val[0:9];\n    \n    initial begin\n        rcon_val[0] = 8'h01;\n        rcon_val[1] = 8'h02;\n        rcon_val[2] = 8'h04;\n        // ... (rest of the 10 entries)\n        rcon_val[9] = 8'h36;\n    end\n    \n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'h0;\n            out <= {24'h00, rcon_val[0]};\n        end else begin\n            if (rcnt != 4'h9) begin\n                rcnt <= rcnt + 1;\n                out <= {24'h00, rcon_val[rcnt]};\n            end\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 2, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Internal signals and registers\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb[10:0];\nreg [3:0] kcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Submodules\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(kb[10]),\n    .wo_1(kb[9]),\n    .wo_2(kb[8]),\n    .wo_3(kb[7])\n);\n\n// 16 parallel inverse S-box instances\naes_inv_sbox us00(.a(sa[0][0]), .b(sa[0][0]));\naes_inv_sbox us01(.a(sa[0][1]), .b(sa[0][1]));\n// ... (similarly for us02-us33)\n\n// State machine logic and round operations\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset state initialization\n        text_in_r <= 128'd0;\n        sa <= '{default: 8'd0};\n        dcnt <= 4'd0;\n        kb <= '{default: 128'd0};\n        kcnt <= 4'hA;\n        ld_r <= 1'b0;\n        text_out <= 128'd0;\n        done <= 1'b0;\n    end else begin\n        // Key load and data load handling\n        if (kld) begin\n            kcnt <= 4'hA;\n            kb[10] <= key[127:96];\n            kb[9] <= key[95:64];\n            kb[8] <= key[63:32];\n            kb[7] <= key[31:0];\n        end else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1'b1;\n        end else begin\n            // Round operations\n            if (ld_r) begin\n                // Initial key addition\n                if (dcnt == 1 begin\n                    // InvShiftRows, InvSubBytes, AddRoundKey (for the first round)\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= text_in_r[(i * 32) + (j * 8) +: 8] ^ kb[dcnt - 1][(i * 32) + (j * 8) +: 8];\n                        end\n                    end\n                    dcnt <= dcnt + 1;\n                end else if (dcnt < 10) begin                    // Standard rounds\n // InvShiftRows, InvSubBytes, AddRound, InvMixColumns\n                    dcnt <= dcnt + 1;\n                end else if (dcnt == 10) begin\n                    // Final round (no InvMixColumns)\n                    dcnt <= dcnt + 1;\n                end else if (dcnt == 11) begin\n                    // Final round output and state reset\n                    text_out <= {>>{sa}};\n                    done <= 1'b1;\n                    ld_r <= 1'b0;\n                end\n            end\n        end\n    end\nend\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n// Internal signals and registers\nreg [31:0] w[43:0]; // 44 words (11 rounds + initial key)\nreg [3:0] rcnt;\n\n// Submodules\naes_sbox sbox;\naes_rcon rcon;\n\n// Key expansion logic\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        // Initial key loading\n        w[0] <= key[127:96];\n        w[1] <= key[95:64];\n        w[2] <= key[63:32];\n        w[3] <= key[31:0];\n        rcnt <= 4'd1;\n    end else begin\n        // Key expansion rounds\n        if (rcnt < 11) begin\n            if (rcnt % 4 == 0) begin\n                // Special round handling\n                w[rcnt + 4] <= w[rcnt] ^ sbox.out ^ rcon.out;\n            end else begin\n                // Regular round handling\n                w[rcnt + 4] <= w[rcnt] ^ w[rcnt - 1];\n            end\n            rcnt <= rcnt + 1;\n        end\n    end\nend\n\n// Output assignments\nassign wo_0 = w[rcnt];\nassign wo_1 = w[rcnt + 1];\nassign wo_2 = w[rcnt + 2];\nassign wo_3 = w[rcnt + 3];\n\nendmodule\n\n// aes_sbox module (S-box implementation)\nmodule aes_sbox(\n    input [7:0] a,\n    [7:0] b\n);\n\n// Lookup table implementation (256 entries)\nreg [7:0] sbox[0:255];\n\ninitial begin\n    // Initialize S-box values (example entries, complete table needed)\n    sbox[0] = 8'h63; // 0x00 -> 0x63\n    sbox[1] = 8'h7c; // 0x01 ->0x7c\n // ... (complete table omitted brevity)\n    s[255] = 8'h7; // 0 -> 0x7\nend\n\nalways @(a) begin\n    b <= sbox[a];\nend\n\nendmodule\n\n// aes_rcon module (Round Constant generation)\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n// Internal signals and registers\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\n// Round constant generation logic\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 4'd1;\n        rcon <= 32'h01000000; // Initial round constant RC[1] = 0x01\n    end else begin\n        if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            rcon <= {rcon[23:0], rcon[31:24] ^ (rcnt == 9 ? 32'h1b000000 : 32'h02000000)};\n        end\n    end\nend\n\nassign out = rcon;\n\nendmodule\n\n// aes_inv_sbox module (Inverse S-box implementation)\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table implementation (256 entries)\nreg [7:0] inv_sbox[0:255];\n\ninitial begin\n    // Initialize Inverse S-box values (example entries, complete table needed)\n    inv_sbox[0] = 8'h52; // 0x00 -> 0x52\n    inv_sbox[63] = 8'h00; // 0x63 -> 0x00\n    // ... (complete table omitted for brevity)\n    inv_sbox[255] = 8'h7d; // 0xFF -> 0x7d\nend\n\nalways @(a) begin\n    b <= inv_sbox[a];\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 3, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Internal signals\nreg [127:0] text_in_r;\nreg [3:0][7:0] sa[3:0];\nreg [3:0] dcnt;\nreg [10:0][127:0] kb;\nreg [3:0] kcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Submodule instances\naes_key_expand_128 key_expander(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(kb[10]),\n    .wo_1(kb[9]),\n    .wo_2(kb[8]),\n    .wo_3(kb[7])\n);\n\n// Inverse SubBytes modules (16 instances)\naes_inv_sbox us00(sa[0][0], us00_out);\naes_inv_sbox us01(sa[0][1], us01_out);\naes_inv_sbox us02(sa[0][2], us02_out);\naes_inv_sbox us03(sa[0][3], us03_out);\naes_inv_sbox us10(sa[1][0], us10_out);\naes_inv_sbox us11(sa[1][1], us11_out);\naes_inv_sbox us12(sa[1][2], us12_out);\naes_inv_sbox us13(sa[1][3], us13_out);\naes_inv_sbox us20(sa[2][0], us20_out);\naes_inv_sbox us21(sa[2][1], us21_out);\naes_inv_sbox us22(sa[2][2], us22_out);\naes_inv_sbox us23(sa[2][3], us23_out);\naes_inv_sbox us30(sa[3][0], us30_out);\naes_inv_sbox us31(sa[3][1], us31_out);\naes_inv_sbox us32(sa[3][2], us32_out);\naes_inv_sbox us33(sa[3][3], us33_out);\n\n// Control logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        dcnt <= 0;\n        kcnt <= 10;\n        ld_r <= 0;\n        done <= 0;\n    end else if (ld) begin\n        dcnt <= 1;\n        ld_r <= 1;\n        done <= 0;\n    end else if (ld_r && dcnt == 11) begin\n        done <= 1;\n        ld_r <= 0;\n    end else if (ld_r && dcnt < 11) begin\n        dcnt <= dcnt + 1;\n    end\nend\n\n// Key loading logic\nalways @(posedge clk) begin    if (kld begin\n       cnt <= 10;\n end else if (kcnt > 0) begin\n        kcnt <= kcnt - 1;\n    end\nend\n\n// State matrix initialization\nalways @(posedge clk) begin\n    if (ld) begin\n        text_in_r <= text_in;\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= text_in_r[127 - (i * 32 + j * 8):128 - (i * 32 + j * 8 + 8)];\n            end\n        end\n    end\nend\n\n// AddRoundKey logic\nalways @(posedge clk) begin\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa[i][j] <= sa[i][j] ^ kb[dcnt][i * 32 + j * 8 +: 8];\n        end\n    end\nend\n\n// Inverse ShiftRows logic\nalways @(posedge clk) begin\n    case (dcnt)\n        1: begin // Row 1\n            sa[1][1] <= sa[1][0];\n            sa[1][2] <= sa[1][1];\n            sa[1][3] <= sa[1][2];\n            sa[1][0] <= sa[1][3];\n        end\n        2: begin // Row 2\n            sa[2][2] <= sa[2][0];\n            sa[2][0] <= sa[2][1];\n            sa[2][1] <= sa[2][2];\n            sa[2][3] <= sa[2][1];\n        end\n        3: begin // Row 3\n            sa[3][3] <= sa[3][0];\n            sa[3][0] <= sa[3][1];\n            sa[3][1] <= sa[3][2];\n            sa[3][2] <= sa[3][3];\n        end\n        default: ; // No shift for Row 0\n    endcase\nend\n\n// Inverse SubBytes results\nwire [3:0][7:0] us00_out, us01_out, us02_out, us03_out;\nwire [3:0][7:0] us10_out, us11_out, us12_out, us13_out;\nwire [3:0][7:0] us20_out, us21_out, us22_out, us23_out;\nwire [3:0][7:0] us30_out, us31_out, us32_out, us33_out;\n\n// Combine Inverse SubBytes results\nalways @(posedge clk) begin\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            case (i)\n                0: sa[i][j] <= (j == 0) ? us00_out : (j == 1) ? us01_out : (j == 2) ? us02_out : us03_out;\n                1: sa[i][j] <= (j == 0) ? us10_out : (j == 1) ? us11_out : (j == 2) ? us12_out : us13_out;\n                2: sa[i][j] <= (j == ) ? us20_out : (j == 1) ? us21_out : (j == 2) ? us22_out : us23_out;\n                3: sa[i][j] <= (j == 0) ? us30_out : (j == 1) ? us31_out : (j == 2) ? us32_out : us33_out;\n                default: sa[i][j] <= 8'd0;\n            endcase\n        end\n    end\nend\n\n// Final output mapping\nalways @(posedge clk) begin\n    if (done) begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                text_out[127 - (i * 32 + * 8):128 - ( * 32 + j 8 +8)] <= sa[i][j];\n            end\n        end\n    end\nend\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n// Internal signals\nreg [31:0] w[43:0];\nreg [3:0] rcnt;\n\n// Round constant module instance\naes_rcon rcon(\n    .clk(clk),\n    .kld(kld),\n    .out(rcon_out)\n);\n\n// Control logic\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        w[0] <= key[127:96];\n        w[1] <= key[95:64];\n        w[2] <= key[63:32];\n        w[3] <= key[31:0];\n    end else if (rcnt < 10) begin\n        if (rcnt % 4 == 0) begin\n           [rcnt + 4] <= w[rcnt] ^ (RotWord(w[rcnt + 1]) ^ SubWord(w[rcnt + 1]) ^ rcon_out);\n        end else begin\n            w[rcnt + 4] <= w[rcnt] ^ w[rcnt + 1];\n        end\n        rcnt <= rcnt + 1;\n    end\nend\n\n// Output assignments\nassign wo_0 = w[4];\nassign wo_1 = w[5];\nassign wo_2 = w[6];\nassign wo_3 = w[7];\n\n// RotWord function\nfunction [31:0] RotWord(input [31:0] word);\n    RotWord = {word[7:0], word[31:8]};\nendfunction\n\n// SubWord function (using S-box)\nfunction [31:0] SubWord(input [31:0] word);\n    SubWord = {sbox(word[31:24]), sbox(word[23:16]), sbox(word[15:8]), sbox(word[7:0])};\nendfunction\n\n// S-box module instance for SubWord\naes_sbox sbox(\n    .a(word[31:24]),\n    .b(sbox_out)\n);\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table implementation (256x8 bits)\n// Example entry (incomplete, full table needed)\nreg [7:0] rom[255:0];\ninitial begin\n rom[0] = 8'h52; // 0x00 -> 0x52\n    rom[99] = 8'h00; // 0x63 -> 0x00\n    // ... Fill in all 256 entries ...\nend\n\nassign b = rom[a];\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n// Internal signals\nreg [3:0] rcnt;\nreg [31:0] rcon_out;\n\n// Control logic\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n        rcon_out <= 32'h01_00_00_00;\n    end else if (rcnt < 10) begin\n        rcnt <= rcnt + 1;\n        rcon_out <= {rcon_out[23:0], rcon_out[31:24]} ^ (rcnt == 9 ? 32'h1B_00_00_00 : 32'h02_00_00_00);\n    end\nend\n\n// Output assignment\nassign out = rcon_out;\n\nendmodule\n\n// aes_inv_sbox module\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table implementation (256x8 bits)\n// Example entry (incomplete, full table needed)\nreg [7:0] rom[255:0];\ninitial begin\n    rom[0] = 8'h52; // 0x00 -> 0x52\n    rom[99] = 8'h00; // 0x63 -> 0x00\n    // ... Fill in all 256 entries ...\nend\n\nassign b = rom[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 4, "code": "// aes_inv_cipher_top module implementation\nmodule aes_inv_cipher_top(\n    input   clk,          // Clock signal\n    input   rst,          // Reset signal\n    input   kld,          // Key load enable\n    input   ld,           // Load enable\n    output  done,         // Decryption complete\n    input   [127:0] key,  // Input key\n    input   [127:0] text_in,  // Input ciphertext\n    output  [127:0] text_out // Output plaintext\n);\n\nreg [127:0] text_in_r;   // Temporary storage register for input ciphertext\nreg [7:0] sa[0:3][0:3];   // 4x4 state matrix registers\nreg [3:0] dcnt;           // Round counter register\nreg [127:0] kb[10:0];     // Key schedule buffer (reverse order)\nreg [3:0] kcnt;           // Key buffer counter (initialize to 10)\nreg ld_r;                // Load operation flag\nreg [127:0] text_out_r;   // Output register (plaintext result)\nwire [127:0] sa_ark;      //Round key addition result\n\n// Submodules instantiation\naes_key_expand_128 key_expand_module(\n    .clk(clk),\n    .kldld),\n    .key(key),\n    .wo_0(kb[10]),\n    .wo_1(kb[9]),\n    .wo_2(kb[8]),\n    .wo_3(kb[7])\n);\n\n// 16 parallel inverse S-box modules\naes_inv_sbox us_box[15:0] (\n    .a({sa[0][0], sa[1][0], sa[2][0], sa[3][0]}), .b({sa[0][0], sa[1][0], sa[2][0], sa[3][0]})\n);\n\n// Key buffer loading logic\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        kcnt <= 10;\n    end else if (kld) begin\n        kcnt <= 10;\n    end else if (kcnt > 0) begin\n        kcnt <= kcnt - 1;\n    end\nend\n\n// State machine control logic\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        dcnt <= 0;\n        ld_r <= 0;\n        done <= 0;\n    end else if (ld) begin\n        dcnt <= 1;\n        ld_r <= 1;\n        done <= 0;\n    end else if (ld_r && (dcnt < 11)) begin\n        dcnt <= dcnt + 1;\n    end else if (dcnt == 11) begin\n        dcnt <= 0;\n        ld_r <= 0;\n        done <= 1;\n    end\nend\n\n// Initial data loading\nalways @(posedge clk) begin\n    if (ld) begin\n        text_in_r <= text_in;\n        // Initialize state matrix from input\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= text_in_r[(i * 32) + (j * 8) +: 8];\n            end\n        end\n    end\nend\n\n// Round operations\nalways @(posedge clk) begin\n    // Initial round key addition (round 0)\n    if (ld_r && (dcnt == 1)) begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i][j] ^ kb[10][(i * 8) + (j * 8) +: 8];\n            end\n        end\n    end\n    \n    // Standard rounds (1-9) and final round (10)\n    if (ld_r && (dcnt > 1 && dcnt < 11)) begin\n        // InvShiftRows\n        sa[1][0] <= sa[1][1];\n        sa[1][1] <= sa[1][2];\n        sa[1][2] <= sa[1][3];\n        sa[1][3] <= sa[1][0];\n        \n        sa[2][0] <= sa[2][2];\n        sa[2][1] <= sa[2][3];\n        sa[2][2] <= sa[2][0];\n        sa[2][3] <= sa[2][1];\n        \n        sa[3][0] <= sa[3][3];\n        sa[3][1] <= sa[3][0];\n        sa[3][2] <= sa[3][1];\n        sa[3][3] <= sa[3][2];\n        \n        // InvSubBytes (16 parallel S-boxes)\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= us_box[i*4 + j].b;\n            end\n        end\n        \n        // AddRoundKey\n        if (dcnt < 10) begin\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ kb[10 - dcnt][(i * 8) + (j * 8) +: 8];\n                end\n            end\n        end else begin\n            // Final round (no InvMixColumns)\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ kb[10 - dcnt][(i * 8) + (j * 8) +: 8];\n                end\n            end\n        end\n    end\nend\n\n// Output mapping\nalways @(posedge clk) begin\n    if (done) begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                text_out_r[(i * 32) + (j * 8) +: 8] <= sa[i][j];\n            end\n        end\n    end\nend\n\nassign text_out = text_out_r;\nassign done = (dcnt == 11 && !ld);\n\nendmodule\n\n// aes_key_expand_128 module implementation\nmodule aes_key_expand_128(\n    input   clk,          // Clock signal\n    input   kld,          // Key load enable\n    input   [127:0] key,  // Input initial key\n    output  [31:0] wo_0,  // Output round key word 0\n    output  [31:0] wo_1,  // Output round key word 1\n    output  [31:0] wo_2,  // Output round key word 2\n    output  [31:0] wo_3   // Output round key word 3\n);\n\n// Implementation details omitted for brevity\n\nendmodule\n\n// aes_sbox module implementation\nmodule aes_sbox(\n    input   [7:0] a,      // Input byte\n    output  [7:0] b       // Substituted byte\n);\n\n// Implementation details omitted for brevity\n\nendmodule\n\n// aes_rcon module implementation\nmodule aes_rcon(\n    input   clk,          // System clock\n    input   kld,          // Key load signal (active high)\n    output  [31:0] out    // Round constant value\n);\n\n// Implementation details omitted for brevity\n\nendmodule\n\n// aes_inv_sbox module implementation\nmodule aes_inv_sbox(\n    input   [7:0] a,      // Input byte\n    output  [7:0] b       // Substituted byte\n);\n\n// Implementation details omitted for brevity\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 5, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input               clk,\n    input               rst,\n    input               kld,\n    input               ld,\n    output              done,\n    input      [127:0]  key,\n    input      [127:0]  text_in,\n    output     [127:0]  text_out\n);\n\n// Internal signals\nreg [127:0] text_in_r;\nreg [3:0][7:0] sa[3:0][3:0]; // State matrix\nreg [3:0] dcnt;              // Round counter\nreg [10:0][127:0] kb;        // Key buffer\nreg [3:0] kcnt;              // Key buffer counter\nreg ld_r;                    // Load flag\nreg [127:0] text_out_r;      // Output register\n\n// Submodule instances\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(kb[10]),\n    .wo_1(kb[9]),\n    .wo_2(kb[8]),\n    .wo_3(kb[7])\n);\n\n// Inverse S-box instances\naes_inv_sbox us[3:0][3:0] (\n    .a(sa[3:0][3:0]),\n    .b()\n);\n\n// Main logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset state\n        text_in_r <= 128'd0;\n        sa <= '{default: 8'd0};\n        dcnt <= 4'd0;\n        kb <= '{default: 128'd0};\n        kcnt <= 4'd10;\n        ld_r <= 1'b0;\n        text_out_r <= 128'd0;\n    end else begin\n        // Key loading\n        if (kld) begin\n            kb[10] <= key;\n            kcnt <= 4'd9;\n        end else if (kcnt > 4'd0) begin\n            // Key expansion\n            kb[kcnt - 1] <= kb[kcnt] ^ aes_key_expand_128.wk[kcnt - 1];\n            kcnt <= kcnt - 1'b1;\n        end\n        \n        // Data loading\n        if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1'b1;\n        end\n        \n        // Decryption process\n        if (ld_r) begin\n            case (dcnt)\n                4'd0: begin\n                    // Initial round key addition\n                    for (int i = 0; i < 4; i++) begin\n                        for (int j = 0; j < 4; j++) begin\n                            sa[i][j] <= text_in_r[8*(i*4 + j) +: 8] ^ kb[10][8*(i*4 + j) +: 8];\n                        end\n                    end\n                    dcnt <= dcnt + 1'b1;\n                end\n                4'd1: begin\n                    // InvMixColumns\n                    // ... (implementation omitted for brevity)\n                    dcnt <= dcnt + 1'b1;\n                end\n                // ... other rounds (implementation omitted)\n                4'd10: begin\n                    // Final round\n                    done <= 1'b1;\n                end\n            endcase\n        end\n    end\nend\n\n// Output assignment\nassign text_out = text_out_r;\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input               clk,\n    input               kld,\n    input      [127:0]  key,\n    output     [31:0]   wo_0,\n    output     [31:0]   wo_1,\n    output     [31:0]   wo_2,\n    output     [31:0]   wo_3\n);\n\n// Internal signals\nreg [3:0] kcnt;\nreg [127:0] wk[3:0];\nreg [127:0] key_reg;\n\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        key_reg <= key;\n        kcnt <= 4'd10;\n    end else if (kcnt > 4'd0) begin\n        // Key expansion logic (omitted for brevity)\n        kcnt <= kcnt - 1'b1;\n    end\nend\n\nassign wo_0 = wk[0];\nassign wo_1 = wk[1];\nassign wo_2 = wk[2];\nassign wo_3 = wk[3];\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input   [7:0] a,\n    output  [7:0] b\n);\n\n// S-box lookup table (omitted for brevity)\nreg [7:0] sbox [0:255];\n\nalways @(a) begin\n    b <= sbox[a];\nend\n\nendmodule\n\n// aes_inv_sbox module\nmodule aes_inv_sbox(\n    input   [7:0] a,\n    output  [7:0] b\n);\n\n// Inverse S-box lookup table (omitted for brevity)\nreg [7:0] inv_sbox [0:255];\n\nalways @(a) begin\n    b <= inv_sbox[a];\nend\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input   clk,\n    input   kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 4'd0;\n        rcon <= 32'd1;\n    end else begin\n        rcnt <= rcnt + 1'b1;\n        rcon <= {rcon[23:0], rcon[31:24] ^ (rcnt == 4'd8 ? 32'd1 : 32'd0)};\n    end\nend\n\nassign out = (rcnt == 4'd10) ? 32'd0 : {24'd0, rcon[7:0]};\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 6, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output wire [127:0] text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb[10:0];\nreg [3:0] kcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Submodules\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(kb[10]),\n    .wo_1(kb[9]),\n    .wo_2(kb[8]),\n    .wo_3(kb[7])\n);\n\n// Inverse S-box instances\naes_inv_sbox us00(.a(sa[0][0]), .b(sa_ark[0]));\naes_inv_sbox us01(.a(sa[0][1]), .b(sa_ark[1]));\n// ... (similarly for us02-us33)\n\n// Control logic and round transformations\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset state\n        text_in_r <= 128'd0;\n        sa <= '{default: 8'd0};\n        dcnt <= 4'd0;\n        kb <= '{default: 128'd0};\n        kcnt <= 4'ha;\n        ld_r <= 1'b0;\n        text_out <= 128'd0;\n        done <= 1'b0;\n    end else begin\n        // Key loading\n        if (kld) begin\n            kcnt <= 4'ha;\n        end else if (kcnt > 0) begin\n            kcnt <= kcnt - 1'b1;\n        end\n\n        // Data loading\n        if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1'b1;\n            dcnt <= 4'd1;\n        end\n\n        // Decryption process\n        if (ld_r) begin\n            // InvShiftRows\n            // InvSubBytes\n            // AddRoundKey\n            // InvMixColumns (except final round)\n            if (dcnt < 10) begin\n                dcnt <= dcnt + 1'b1;\n            end else begin\n                text_out <= sa_ark;\n                done <= 1'b1;\n                ld_r <= 1'b0;\n            end\n        end\n    end\nend\n\n// Output mapping\nalways_comb begin\n    text_out = '{default: 1'b0};\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            text_out[(i * 32) + (j * 8) +: 8] = sa[i][j];\n        end\n    end\nend\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n// Registers\nreg [31:0] w0, w1, w2, w3;\nreg [3:0] rcnt;\n\n// Submodules\naes_rcon rcon(.clk(clk), .kld(kld), .out(rcon_out));\n\n// Control logic\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 4'd0;\n        w0 <= key[127:96];\n        w1 <= key[95:64];\n        w2 <= key[63:32];\n        w3 <= key[31:0];\n    end else begin\n        rcnt <= rcnt + 1'b1;\n        w0 <= w3 ^ aes_sbox(w1) ^ rcon_out;\n        w1 <= w0;\n        w2 <= w1;\n        w3 <= w2;\n    end\nend\n\nassign wo_0 = w0;\nassign wo_1 = w1;\nassign wo_2 = w2;\nassign wo_3 = w3;\n\nendmodule\n\n// aes_inv_sbox module\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] b;\n\nalways_comb begin\n    // Inverse S-box lookup table implementation (simplified example)\n    case (a)\n        8'h63: b = 8'h00;\n        8'h00: b = 8'h52;\n        8'hFF: b = 8'h7D;\n        // ... (Add all 256 entries of the inverse S-box lookup table)\n        default: b = 8'd0;\n    endcase\nend\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\nreg [31:0] out;\n\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        out <= 32'h01_00_00_00; // RC[1] = 0x01\n    end else begin\n        // Implement round constant generation logic\n        // Example: out <= {23'd0, 8'h02} (for RC[2] = 0x02)\n        // ... (Implement the full round constant sequence)\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 7, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input         clk,\n    input         rst,\n    input         kld,\n    input         ld,\n    output        done,\n    input  [127:0] key,\n    input  [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [7:0] sa[3:0][3:0];\nreg [3:0] dcnt;\nreg [127:0] kb[10:0];\nreg [3:0] kcnt;\nreg        ld_r;\nreg [127:0] text_out;\n\n// Wires\nwire [31:0] wk0, wk1, wk2, wk3;\nwire [31:0] w0, w1, w2, w3;\nwire [7:0] sa_ark[3:0][3:0];\nwire [7:0] sa_next[3:0][3:0];\n\n// Submodules\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(wk0),\n    .wo_1(wk1),\n    .wo_2(wk2),\n    .wo_3(wk3)\n);\n\n// 16 parallel inverse S-boxes\ngenvar i, j;\ngenerate\n    for (i = 0; i < 4; i++) begin\n        for (j = 0; j < 4; j++) begin\n            aes_inv_sbox sbox(\n                .a(sa[i][j]),\n                .b(sa_ark[i][j])\n            );\n        end\n    end\nendgenerate\n\n// Main logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset state\n        text_in_r <= 128'd0;\n        dcnt <= 4'd0;\n        kcnt <= 4'ha;\n        ld_r <= 1'b0;\n        text_out <= 128'd0;\n        done <= 1'b0;\n    end else if (kld) begin\n        // Key loading state\n        kcnt <= 4'ha;\n    end else if (ld) begin\n        // Data loading state\n        text_in_r <= text_in;\n        ld_r <= 1'b1;\n    end else begin\n        // Decryption process\n        case (dcnt)\n            4'd0: begin\n                // Initial round key addition\n                text_in_r <= text_in ^ key;\n                dcnt <= dcnt + 1;\n            end\n            4'd1: begin\n                // Standard rounds (InvSubBytes, InvShiftRows, InvMixColumns, AddRoundKey)\n                // InvSubBytes\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa_ark[i][j]; // From S-box output\n                    end\n                end\n                // InvShiftRows\n                sa[0][1] <= sa[1][1];\n                sa[][2] <= sa[2][2];\n                sa[0][3] <= sa[3][3];\n                sa[1][0] <= sa[0][0];\n                sa[1][1] <= sa[1][0];\n                sa[1][2] <= sa[2][1];\n                sa[1][3] <= sa[3][2];\n                sa[2][0] <= sa[0][0];\n                sa[2][1] <= sa[1][0];\n                sa[2][2] <= sa[2][0];\n                sa[2][3] <= sa[3][1];\n                sa[3][0] <= sa[0][0];\n                sa[3][1] <= sa[1][0];\n                sa[3][2] <= sa[2][0];\n                sa[3][3] <= sa[3][0];\n                // InvMixColumns\n                for (int i = 0; i < 4; i++) begin\n                    sa_next[i][0] <= (sa[i][0] ^ sa[i][1] ^ sa[i][2] ^ sa[i][3]) ^ (sa[i][0] << 1) ^ (sa[i][1] << 3) ^ (sa[i][2] << 5) ^ (sa[i][3] << 7);\n                    sa_next[i][1] <= (sa[i][0] ^ sa[i][1] ^ sa[i][2] ^ sa[i][3]) ^ (sa[i][0] << 3) ^ (sa[i][1] << 5) ^ (sa[i][2] << 7) ^ (sa[i][3] << 1);\n                    sa_next[i][2] <= (sa[i][0] ^ sa[i][1] ^ sa[i][2] ^ sa[i][3]) ^ (sa[i][0] << 5) ^ (sa[i][1] << 7) ^ (sa[i][2] << 1) ^ (sa[i][3] << 3);\n                    sa_next[i][3] <= (sa[i][0] ^ sa[i][1] ^ sa[i][2] ^ sa[i][3]) ^ (sa[i][0] << 7) ^ (sa[i][1] << 1) ^ (sa[i][2] << 3) ^ (sa[i][3] << 5);\n                end\n                // AddRoundKey\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa_next[i][j] ^ kb[dcnt + i][8*j +: 8];\n                    end\n                end\n                dcnt <= dcnt + 1;\n            end\n            4'd9: begin\n                // Final round (InvSubBytes, InvShiftRows, AddRoundKey)\n                // InvSubBytes (same as before)\n                // InvShiftRows (same as before)\n                // AddRoundKey\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= sa_ark[i][j] ^ kb[10 + i][8*j +: 8];\n                    end\n                end\n                // Output mapping\n                for (int i = 0; i < 16; i++) begin\n                    text_out[8*i +: 8] <= sa[i/4][i%4];\n                end\n                done <= 1'b1;\n            end\n            default: dcnt <= dcnt + 1;\n        endcase\n    end\nend\n\n// Key buffer loading logic\nalways @(posedge clk) begin\n    if (ld) begin\n kcnt <= 4ha;\n        kb10] <= {wk, wk2, wk, wk0};\n    end else if (kcnt > 0) begin\n        kb[kcnt - 1] <= {wk3, wk2, wk1, wk0};\n        kcnt <= kcnt - 1;\n    end\nend\n\n// Key retrieval\nalways @(posedge clk) begin\n    case (dcnt)\n        4'd0: begin\n            w0 <= kb[0][31:0];\n            w1 <= kb[1][31:0];\n            w2 <= kb[2][31:0];\n            w3 <= kb[3][31:0];\n        end\n        4'd1: begin\n            w0 <= kb[4][31:0];\n            w1 <= kb[5][31:0];\n            w2 <= kb[6][31:0];\n            w3 <= kb[7][31:0];\n        end\n        4'd2: begin\n            w0 <= kb[8][31:0];\n            w1 <= kb[9][31:0];\n            w2 <= kb[10][31:0];\n            w3 <= kb[0][31:0];\n        end\n        4'd9: begin\n            w0 <= kb[9][31:0];\n            w1 <= kb[8][31:0];\n            w2 <= kb[7][31:0];\n            w3 <= kb[6][31:0];\n        end\n        default: begin\n            w0 <= kb[dcnt + 4][31:0];\n            w1 <= kb[dcnt + 5][31:0];\n            w2 <= kb[dcnt + 6][31:0];\n            w3 <= kb[dcnt + 7][31:0];\n        end\n    endcase\nend\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input  clk,\n    input  kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [31:0] rcon_reg;\n\n// Submodules\naes_rcon rcon(\n    .clk(clk),\n    .kld(kld),\n    .out(rcon_reg)\n);\n\n// S-box module\naes_sbox sbox();\n\n// Main logic\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        // Initial key loading\n        wo_0 <= key[127:96];\n        wo_1 <= key[95:64];\n        wo_2 <= key[63:32];\n        wo_3 <= key[31:0];\n    end else begin\n        // Key expansion\n        wo_0 <= wo_0 ^ (sbox.out ^ rcon_reg);\n        wo_1 <= wo_1 ^ (sbox.out ^ rcon_reg);\n        wo_2 <= wo_2 ^ (sbox.out ^ rcon_reg);\n        wo_3 <= wo_3 ^ (sbox.out ^ rcon_reg);\n    end\nend\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table implementation\n// (Actual lookup table values would be included here)\n\nendmodule\n\n// aes_inv_sbox module\nmodule aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table implementation\n// (Actual lookup table values would be included here)\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input  clk,\n    input  kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt;\n\n// Main logic\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 4'd0;\n        out <= 32'hd0100000; // Initial round constant\n    end else if (rcnt < 4'd9) begin\n        rcnt <= rcnt + 1;\n        out <= {out[23:0], out[31] ^ out[30]} ^ (rcnt[0] ? 32'h00000001 : 32'd0);\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 8, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Internal signals and registers\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb[10:0];\nreg [3:0] kcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Instantiate submodules\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(kb[0]),\n    .wo_1(kb[1]),\n    .wo_2(kb[2]),\n    .wo_3(kb[3])\n);\n\n// Inverse S-box instances\naes_inv_sbox us00(.a(sa[0][0]), .b(sa[0][0]));\naes_inv_sbox us01(.a(sa[0][1]), .b(sa[0][1]));\n// ... (similar instantiations for us02-us33)\n\n// Control logic and datapath implementation\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        // Reset logic\n        dcnt <= 0;\n        kcnt <= 4'hA;\n        ld_r <= 0;\n        done <= 0;\n        // Initialize other registers as needed\n    end else begin\n        // Key loading stage\n        if (kld) begin\n            kcnt <= kcnt - 1;\n            // Update key schedule buffer\n        end\n        \n        // Data loading stage\n        if (ld) begin\n            // Load input ciphertext into text_in_r\n            text_in_r <= text_in;\n            ld_r <= 1;\n        end\n        \n        // Decryption rounds\n        if (ld_r && !done) begin\n            // InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns\n            // Implement round transformations here based on dcnt value\n            dcnt <= dcnt + 1;\n            \n            if (dcnt == 10) begin\n                // Final completion\n                done <= 1;\n                text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                              sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                              sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                              sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n            end\n        end\n    end\nend\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [3:0] rcnt;\nreg [31:0] rcon;\n\n// Instantiate aes_rcon submodule\naes_rcon rcon_gen(.clk(clk), .kld(kld), .out(rcon));\n\nalways @(posedge clk or negedge kld) begin\n    if (!kld) begin\n        // Reset round counter\n        rcnt <= 0;\n        // Initialize output round keys from input key\n        wo_0 <= key[127:96];\n        wo_1 <= key[95:64];\n        wo_2 <= key[63:32];\n        wo_3 <= key[31:0];\n    end else begin\n        // Update round keys based on previous values and rcon\n        // Implement key expansion logic here\n        // Example for wo_0:\n        wo_0 <= wo_0 ^ (rcnt == 0 ? (rcon ^ wo_1) : wo_1);\n        // Similar logic for wo_1, wo_2, wo_3\n    end\nend\n\nendmodule\n\n// aes_sbox module (for reference, inverse is similar)\nmodule aes_sbox(input [7:0] a, output [7:0] b);\n\n// Lookup table implementation (example)\nreg [7:0] b;\nalways @(*) begin\n    case(a)\n        8'h00: b = 8'h63;\n        8'h01: b = 8'h7c;\n        8'h02: b = 8'h77;\n        // ... (all 256 entries)\n        8'hff: b = 8'h7d;\n        default: b = 8'h00; // Handle invalid cases\n    endcase\nend\n\nendmodule\n\n// aes_inv_sbox module\nmodule aes_inv_sbox(input [7:0] a, output [7:0] b);\n\n// Lookup table implementation (example)\nreg [7:0] b;\nalways @(*) begin\n    case(a)\n        8'h00: b = 8'h52;\n        8'h63: b = 8'h00;\n        8'h7c: b = 8'h01;\n        // ... (all 256 entries)\n        8'h7d: b = 8'hff;\n        default: b = 8'h00; // Handle invalid cases\n    endcase\nend\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(input clk, input kld, output [31:0] out);\n\nreg [3:0] rcnt;\nreg [7:0] rcon;\n\nalways @(posedge clk or negedge kld) begin\n    if (!kld) begin\n        rcnt <= 0;\n        rcon <= 8'h01;\n    end else begin\n        rcnt <= rcnt + 1;\n        rcon <= rcnt[0] ? (rcon << 1) ^ 8'h11 : (rcon << 1);\n    end\nend\n\nassign out = {24'd0, rcon};\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 9, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input           clk,\n    input           rst,\n    input           kld,     // Key load enable\n    input           ld,      // Data load enable\n    output          done,    // Decryption complete\n    input  [127:0]  key,     // Input key\n    input  [127:0]  text_in, // Input ciphertext\n    output [127:0]  text_out // Output plaintext\n);\n\n    reg [127:0] text_in_r; // Temporary storage for input ciphertext\n    reg [7:0]    sa[3:0][3:0]; // 4x4 state matrix registers\n    reg [3:0]    dcnt;      // Round counter\n    reg [127:0]  kb[10:0];   // Key schedule buffer (reverse order)\n    reg [3:0]    kcnt;      // Key buffer counter\n    reg           ld_r;     // Load operation flag\n    reg [127:0]  text_out;  // Output plaintext register\n\n    // Submodules instantiation\n    aes_key_expand_128 key_expand(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(kb[10]),\n        .wo_1(kb[9]),\n        .wo_2(kb[8]),\n        .wo_3(kb[7])\n    );\n\n    aes_inv_sbox us[15:0] (\n        .a(sa[3][3]),\n        .b()\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset state\n            dcnt <= 0;\n            kcnt <= 10;\n            ld_r <= 0;\n            done <= 0;\n        end else begin\n            // Key loading state\n            if (kld) begin\n                kcnt <= kcnt - 1;\n                if (kcnt == 0) begin\n                    kcnt <= 10;\n                    ld_r <= 0;\n                    done <= 0;\n                end\n            end\n\n            // Data loading state\n            if (ld) begin\n                ld_r <= 1;\n                text_in_r <= text;\n                dcnt <= 1;\n                done <= 0;\n            end\n\n            // Decryption process\n            if (ld_r && !done) begin\n                case (dcnt)\n                    1: begin // Initial round key addition\n                        // Implement InvShiftRows and InvSubBytes here\n                        dcnt <= dcnt + 1;\n                    end\n                    [2:10]: begin // Standard rounds\n                        // Implement InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns\n                        dcnt <= dcnt + 1;\n                    end\n                    11: begin // Final round (no InvMixColumns)\n                        // Implement InvShiftRows, InvSubBytes, AddRoundKey\n                        done <= 1;\n                        dcnt <= 0;\n                        ld_r <= 0;\n                    end\n                endcase\n            end\n        end\n    end\n\n    // Output mapping process\n    always @(*) begin\n        text_out = {sa[3][0], sa[2][0], sa[1][0], sa[0][0],\n                    sa[3][1], sa[2][1], sa[1][1], sa[0][1],\n                    sa[3][2], sa[2][2], sa[1][2], sa[0][2],\n                    sa[3][3], sa[2][3], sa[1][3], sa[0][3]};\n    end\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input           clk,\n    input           kld,\n    input  [127:0]  key,\n    output [31:0]   wo_0,\n    output [31:0]   wo_1,\n    output [31:0]   wo_2,\n    output [31:0]   wo_3\n);\n\n    reg [31:0] w[43:0]; // Round key buffer\n\n    // Submodules instantiation\n    aes_rcon rcon(\n        .clk(clk),\n        .kld(kld),\n        .out(w[1][7:0])\n    );\n\n    aes_sbox sbox[3:0] (\n        .a(w[0][31:24]),\n        .b()\n    );\n\n    always @(posedge clk or posedge kld) begin\n        if (kld) begin\n            // Initialize first four words from the input key\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n        end else begin\n            // Expand subsequent round keys\n            for (int i = 4; i < 44; i++) begin\n                if (i % 4 == 0) begin\n                    w[i] <= {sbox[0].b, sbox[1].b, sbox[2].b, sbox[3].b} ^ {w[i-4][31:24], w[i-4][23:16], w[i-4][15:8], w[i-4][7:0]} ^ {rcon.out, 24'd0};\n                end else begin\n                    w[i] <= w[i-1] ^ w[i-4];\n                end\n            end\n        end\n    end\n\n    assign wo_0 = w[4];\n    assign wo_1 = w[5];\n    assign wo_2 = w[6];\n    assign wo_3 = w[7];\n\nendmodule\n\n// aes_inv_sbox module (Inverse S-box)\nmodule aes_inv_sbox(\n    input  [7:0]   a,\n    output [7:0]   b\n);\n\n    // Lookup table implementation (256x8 bits)\n    reg [7:0] inv_sbox[255:0];\n\n    // Initialize the lookup table with inverse S-box values\n    initial begin\n        // Precomputed inverse S-box values\n        inv_sbox[0] = 8'd52; // 0x00 -> 0x52\n        inv_sbox[99] = 8'd00; // 0x63 -> 0x00\n        inv_sbox[255] = 8'd125; // 0xFF -> 0x7D\n        // ... other 253 entries ...\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule\n\n// aes_sbox module (S-box)\nmodule aes_sbox(\n    input  [7:0]   a,\n    output [7:0]   b\n);\n\n    // Lookup table implementation (256x8 bits)\n    reg [7:0] sbox[255:0];\n\n    // Initialize the lookup table with S-box values\n    initial begin\n        // Precomputed S-box values\n        sbox[0] = 8'd63; // 0x00 -> 0x63\n        sbox[99] = 8'd0; // 0x63 -> 0x00\n        sbox[255] = 8'd123; // 0xFF -> 0x7D\n        // ... other 253 entries ...\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\n// aes_rcon module (Round constant generator)\nmodule aes_rcon(\n    input           clk,\n    input           kld,\n    output [31:0]   out\n);\n\n    reg [3:0] rcnt; // Round counter\n    reg [7:0] rcon_val; // Round constant value\n\n    always @(posedge clk or posedge kld) begin\n        if (kld) begin\n            rcnt <= 0;\n            rcon_val <= 8'd1; // Initial round constant\n        end else begin\n            if (rcnt < 10) begin\n                rcnt <= rcnt + 1;\n                rcon_val <= rcon_val << 1; // Multiply by 2 in GF(2^8)\n                if (rcon_val[7]) begin\n                    rcon_val <= rcon_val ^ 8'd11b; // XOR with irreducible polynomial\n                end\n            end\n        end\n    end\n\n    assign out = {24'd0, rcon_val};\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 10, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input        clk,\n    input        rst,\n    input        kld,\n    input        ld,\n    output       done,\n    input  [127:0] key,\n    input  [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [7:0] sa [0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb [0:10];\nreg [3:0] kcnt;\nreg        ld_r;\nreg [127:0] text_out;\n\n// Submodule instances\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(kb[10][31:0]),\n    .wo_1(kb[10][63:32    .wo_2(kb[10][95:64]),\n    .wo_3(kb10][127:96);\n\n// Inverse S-box modules16 parallel instances)\naes_inv_s u00(.a(sa[00]), .(sa_00));\naes_sbox u01(.a(sa[0][1]), .(sa_01));\naes_invbox u02(.a(sa[0][2]), .b(sa_02));\naes_inv_sbox u03(.a(sa[0][3]), .b(sa_03));\naes_inv_sbox u10(.a(sa[1][0]), .b(sa_10));\naes_inv_sbox u11(.a(sa[1][1]), .b(sa_11));\naes_inv_sbox u12(.a(sa[1][2]), .b(sa_12));\naes_inv_sbox u13(.a(sa[1][3]), .b(sa_13));\naes_inv_sbox u20(.a(sa[2][0]), .b(sa_20));\naes_inv_sbox u21(.a(sa[2][1]), .b(sa_21));\naes_inv_sbox u22(.a(sa[2][2]), .b(sa_22));\naes_inv_sbox u23(.a(sa[2][3]), .b(sa_23));\naes_inv_sbox u30(.a(sa[3][0]), .b(sa_30));\naes_inv_sbox u31(.a(sa[3][1]), .b(sa_31));\naes_inv_sbox u32(.a(sa[3][2]), .b(sa_32));\naes_inv_sbox u33(.a(sa[3][3]), .b(sa_33));\n\n// Combinational logic for InvShiftRows, InvMixColumns, AddRoundKey\n// (Implementation details omitted for brevity)\n\n// Sequential logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset state\n        text_in_r <= 128'd0;\n        dcnt <= 4'd0;\n        kcnt <= 4'ha;\n        ld_r <= 1'b0;\n        text_out <= 128'd0;\n        done <= 1'b0;\n    end else if (ld) begin\n        // Load state\n        text_in_r <= text_in;\n        ld_r <= 1'b1;\n    end else begin\n        // Run state\n        case (dcnt)\n            4'd0: begin\n                // Initial round key addition\n                dcnt <= dcnt + 4'd1;\n            end\n            4'd1: begin\n                // Standard rounds\n                dcnt <= dcnt + 4'd1;\n                // InvSubBytes, InvShiftRows, InvMixColumns, AddRoundKey\n                // (Implementation details omitted)\n            end\n            4'd11: begin\n                // Final round\n                dcnt <= 4'd0;\n                done <= 1'b1;\n                text_out <= sa_ark; // Final output assignment\n            end\n        endcase\n    end\nend\n\n// Key loading and expansion logic\nalways @(posedge clk) begin\n    if (kld) begin\n        // Key load and expansion\n        kcnt <= 4'd0;\n        kb[10] <= key;\n    end else if (kcnt != 4'd0) begin\n        // Generate subsequent round keys\n        kcnt <= kcnt - 4'd1;\n        // (Implementation details omitted)\n    end\nend\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input        clk,\n    input        kld,\n    input  [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\nreg [31:0] w0, w1, w2, w3;\n\n// Key loading\nalways @(posedge clk) begin\n    if (kld) begin\n        w0 <= key[31:0];\n        w1 <= key[63:32];\n        w2 <= key[95:64];\n        w3 <= key[127:96];\n    end else begin\n        // Key expansion (Implementation details omitted)\n    end\nend\n\nassign wo_0 = w0;\nassign wo_1 = w1;\nassign wo_2 = w2;\nassign wo_3 = w3;\n\nendmodule\n\n// aes_inv_sbox module\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] b;\n\nalways @(*) begin\n    case (a)\n        8'd0:   b = 8'd52;\n        8'd63:  b = 8'd0;\n        8'd255: b = 8'd125;\n        default: b = 8'd0; // Placeholder for lookup table implementation\n    endcase\nend\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\nreg [7:0] b;\n\nalways @(*) begin\n    case (a)\n        8'd0:   b = 8'd63;\n        8'd52:  b = 8'd0;\n        8'd125: b = 8'd255;\n        default: b = 8'd0; // Placeholder for lookup table implementation\n    endcase\nend\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input        clk,\n    input        kld,\n    output [31:0] out\n);\n\nreg [31:0] out;\n\nalways @(posedge clk) begin\n    if (kld) begin\n        out <= 32'h01000000;\n    end else begin\n        // Round constant generation (Implementation details omitted)\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 11, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input  wire clk,\n    input  wire rst,\n    input  wire kld,\n    input  wire ld,\n    output wire done,\n    input  wire [127:0] key,\n    input  wire [127:0] text_in,\n    output wire [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[3:0][3:0];\n    reg [3:0] dcnt;\n    reg [10:0][127:0] kb;\n    reg [3:0] kcnt;\n    reg ld_r;\n    \n    // Submodules instantiation\n    aes_key_expand_128 key_expand(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(kb[10][31:0]),\n        .wo_1(kb[10][63:32]),\n        .wo_2(kb[10][95:64]),\n        .wo_3(kb[10][127:96])\n    );\n    \n    aes_inv_sbox inv_sbox[15:0] (\n        .a(sa[3:0][3:0][7:0]),\n        .b()\n    );\n    \n    // ... (other submodule instantiations like aes_rcon, aes_sbox if needed)\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset logic\n            dcnt <= 4'd0;\n            kcnt <= 4'hA;\n        end else if (kld) begin\n            // Key loading\n            kcnt <= kcnt == 4'h0 ? 4'hA : kcnt - 4'd1;\n        end else if (ld) begin\n            // Initial loading\n            dcnt <= 4'd1;\n        end else if (done) begin\n            // Decryption complete\n            dcnt <= 4'd0;\n        end else begin\n            // Decryption process\n            dcnt <= dcnt + 4'd1;\n        end\n    end\n    \n    // ... (other logic for key scheduling, state transformations, etc.)\n    \nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input  wire clk,\n    input  wire kld,\n    input  wire [127:0] key,\n    output wire [31:0] wo_0,\n    output wire [31:0] wo_1,\n    output wire [31:0] wo_2,\n    output wire [31:0] wo_3\n);\n\n    // Key expansion logic implementation\n    // ... (omitted for brevity)\n    \nendmodule\n\n// aes_inv_sbox module\nmodule aes_inv_sbox(\n    input  wire [7:0] a,\n    output wire [7:0] b\n);\n    \n    // Inverse S-box lookup table implementation\n    // ... (omitted for brevity)\n    \nendmodule\n\n// aes_sbox module (if needed, same structure as aes_inv_sbox)\n// aes_rcon module (if needed, same structure as key_expand)", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 12, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n// Internal signals and registers\nreg [127:0] text_in_r;\nreg [3:0][7:0] sa[0:3];\nreg [3:0] dcnt;\nreg [10:0][127:0] kb;\nreg [3:0] kcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Submodules\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(kb[10]),\n    .wo_1(kb[9]),\n    .wo_2(kb[8]),\n    .wo_3(kb[7])\n);\n\n// Inverse S-box modules\naes_inv_sbox inv_sbox00(.a(sa[0][0]), .b(sa[0][0]));\naes_inv_sbox inv_sbox01(.a(sa[0][1]), .b(sa[0][1]));\n// ... (16 instances)\n\n// Other inverse modules (InvShiftRows, InvMixColumns, AddRoundKey) - logic not shown for brevity\n\n// Control logic and state machine implementation\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset state\n        dcnt <= 0;\n        kcnt <= 10;\n        done <= 0;\n        ld_r <= 0;\n    end else begin\n        // State transitions and operations\n        // Key loading\n        if (kld) begin\n            kcnt <= kcnt - 1;\n            // Update key buffer\n        end\n        \n        // Data loading and decryption process\n        if (ld) begin\n            ld_r <= 1;\n            text_in_r <= text_in;\n            // Initialize state matrix from input\n        end\n        \n        // rounds\n        if (ld && !done) begin\n            // InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns (for non-final rounds)\n            // Update state matrix and round counter\n            dcnt <= dcnt + 1;\n            if (dcnt == 11) begin\n                done <= 1;\n                text_out <= text_out; // Output final plaintext\n            end\n        end\n        \n        // Reset load flag when done\n        if (done) begin\n            ld_r <= 0;\n        end\n    end\nend\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n// Internal registers\nreg [31:0] w0, w1, w2, w3;\nreg [3:0] rcnt;\n\n// Round constant module\naes_rcon rcon(\n    .clk(clk),\n    .kld(kld),\n .out(rcnt)\n);\n\n// S-box module\naes_sbox sbox(\n    .a(w1[7:0]),\n    .b(w1[7:0])\n);\n\n// Key expansion logic\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        // Reset\n        w0 <= key[127:96];\n        w1 <= key[95:64];\n        w2 <= key[63:32];\n        w3 <= key[31:0];\n        rcnt <= 1;\n    end else begin\n        // Expand key\n        if (rcnt == 10) begin\n            // Last round key\n            wo_0 <= w0;\n            wo_1 <= w1;\n            wo_2 <= w2;\n            wo_3 <= w3;\n        end else begin\n            // Intermediate rounds\n            w0 <= w0 ^ sbox.b ^ rcnt;\n            w1 <= w1 ^ w0;\n            w2 <= w2 ^ w1;\n            w3 <= w3 ^ w2;\n            rcnt <= rcnt + 1;\n        end\n    end\nend\n\nalways_comb begin\n    wo_0 = w0;\n    wo_1 = w1;\n    wo_2 = w2;\n    wo_3 = w3;\nend\n\nendmodule\n\n// aes_sbox module\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table implementation\nalways_comb begin\n    case (a)\n        8'h00: b = 8'h52;\n        8'h01: b = 8'h9a;\n        // ... (256 entries)\n        8'hff: b = 8'h7d;\n        default: b = 8'h00;\n    endcase\nend\n\nendmodule\n\n// aes_inv_sbox module\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table implementation\nalways_comb begin\n    case (a)\n        8'h00: b = 8'h00;\n        8'h01: b = 8'h38;\n        // ... (256 entries)\n        8'hff: b = 8'h00;\n        default: b = 8'h00;\n    endcase\nend\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n// Round counter\nreg [3:0] rcnt;\n\n// Reset logic\nalways @(posedge clk or posedge kld) begin\n    if (kld) begin\n        rcnt <= 1;\n    end else begin\n        rcnt <= rcnt + 1;\n    end\nend\n\n// Generate round constants\nalways_comb begin\n    case (nt)\n        1: out = 32'h01000000;\n        2: out = 32'h02000000;\n        3: out = 32'h04000000;\n        // ... (10 cases)\n        10: out = 32'h36000000;\n        default: out = 32'h00000000;\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 13, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb;\n    reg [3:0] kcnt;\n    reg ld_r;\n    reg [127:0] text_out;\n\n    wire [7:0] us00, us01, us02, us03;\n    wire [7:0] us10, us11, us12, us13;\n    wire [7:0] us20, us21, us22, us23;\n    wire [7:0] us30, us31, us32, us33;\n    \n    wire [127:0] wk0, wk1, wk2, wk3;\n\n    // Instantiate key expansion module\n    aes_key_expand_128 key_expand(\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0[31:0]),\n        .wo_1(wk0[63:32]),\n        .wo_2(wk0[95:64]),\n        .wo_3(wk0[127:96])\n    );\n\n    // Instantiate inverse S-box modules\n    aes_inv_sbox inv_sbox00(.a[0][0]), .b(us00));\n    aes_inv_sbox inv_sbox01(.a(sa[0][1]), .b(us01));\n    aes_inv_sbox inv_sbox02(.a(sa[0][2]), .b(us02));\n    aes_inv_sbox inv_sbox03(.a(sa[0][3]), .b(us03));\n    \n    aes_inv_sbox inv_sbox10(.a(sa[1][0]), .b(us10));\n    aes_inv_sbox inv_sbox11(.a(sa[1][1]), .b(us11));\n    aes_inv_sbox inv_sbox12(.a(sa[1][2]), .b(us12));\n    aes_inv_sbox inv_sbox13(.a(sa[1][3]), .b(us13));\n    \n    aes_inv_sbox inv_sbox20(.a(sa[2][0]), .b(us));\n    aes_inv_sbox inv_sbox21(.a(sa[2][1]), .b(us21));\n    aes_inv_sbox inv_sbox22(.a(sa[2][2]), .b(us22));\n    aes_inv_sbox inv_sbox23(.a(sa[2][3]), .b(us23));\n    \n    aes_inv_sbox inv_sbox30(.a(sa[3][0]), .b(us30));\n    aes_inv_sbox inv_sbox31(.a(sa[3][1]), .b(us31));\n    aes_inv_sbox inv_sbox32(.a(sa[3][2]), .(us32));\n aes_inv_sbox inv_sbox33(.a(sa[3][3]), .b(us33));\n    \n    // Finite state machine and control logic\n    always @(posedge clk or posedge) begin\n        (rst)\n            // Initialize registers\n text_in_r <= 1280;\n           cnt <= 4'd;\n            k <= 4'h;\n            ld_r <= 1'b0;\n            text_out <= 128'd0;\n            kb <= 128'd0;\n        end else begin\n            // FSM transitions and operations\n            // Omitted for brevity (implement FSM logic here)\n        end\n    end\n\n    // Output assignment\n    assign done = (dcnt == 4'd11 && ld_r == 1'b0);\n    assign text_out = text_out;\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    // Key expansion logic (omitted for brevity)\n    // Implement key expansion based on AES specification\nendmodule\n\n// aes_sbox module (for completeness)\nmodule aes_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // S-box lookup table (omitted for brevity)\n    // Implement using case statement or ROM\nendmodule\n\n// aes_inv_sbox module\nmodule aes_inv_sbox(\n    input [7:0] a,\n    output [7:0] b\n);\n\n    // Inverse S-box lookup table (omitted for brevity)\n    // Implement using case statement or ROM\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input clk,\n    input kld,\n    output [31:0] out\n);\n\n    // Round constant generation logic (omitted for brevity)\n    // Implement based on AES specification\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 14, "code": "// aes_inv_cipher_top.v\nmodule aes_inv_cipher_top(\n    input   clk,\n    input   rst,\n    input   kld,  // Key load enable\n    input   ld,   // Data load enable\n    output  done, // Decryption complete\n    input   [127:0] key, // 128-bit input key\n    input   [127:0] text_in, // 128-bit ciphertext input\n    output  [127:0] text_out  // 128-bit plaintext output\n);\n\n// Registers\nreg [127:0] text_in_r; // Temporary storage for input ciphertext\nreg [7:0] sa[3:0][3:0]; // 4x4 state matrix registers (column-major order)\nreg [3:0] dcnt; // Round counter (0-10)\nreg [127:0] kb[10:0]; // Key schedule buffer (11 round keys)\nreg [3:0] kcnt; // Key buffer counter (initially 10)\nreg ld_r; // Load operation flag\nreg [127:0] text_out; // Output plaintext register\n\n// Internal signals\nwire [7:0] sa_ark[3:0][3:0]; // After round key addition\nwire [7:0] sa_next[3:0][3:0]; // Next state matrix\nwire [31:0] wo_0, wo_1, wo_2, wo_3; // Output from key expansion module\n\n// Instantiate key expansion module\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(wo_0),\n    .wo_1(wo_1),\n    .wo_2(wo_2),\n    .wo_3(wo_3)\n);\n\n// Key buffer loading\nalways @(posedge clk or posedge rst) begin\n    if(rst) begin\n        kcnt <= 10;\n        kb[10] <= {wo_3, wo_2, wo_1, wo_0}; // Initial round key\n    end else if(kld) begin\n        kcnt <= 10;\n        kb[10] <= {wo_3, wo_2, wo_1, wo_0};\n    end else if(kcnt > 0) begin\n        kb[kcnt-1] <= kb[kcnt] ^ {wo_3, wo_2, wo_1, wo_0};\n        kcnt <= kcnt - 1;\n    end\nend\n\n// Control logic\nalways @(posedge clk or posedge rst) begin\n    if(rst) begin\n        ld_r <= 0;\n        dcnt <= 0;\n        done <= 0;\n    end else if(ld) begin\n        ld_r <= 1;\n        dcnt <= 1;\n        done <= 0;\n    end else if(ld_r && (dcnt == 11)) begin\n        done <= 1;\n        ld_r <= 0;\n    end else if(ld_r) begin\n        dcnt <= dcnt + 1;\n    end\nend\n\n// Initial data loading and round key addition\nalways @(posedge clk) begin\n    if(ld) begin\n        // Load input plaintext into state matrix in column-major order\n        for(int i = 0; i < 16; i++) begin\n            sa[i/4][i%4] <= text_in[i*8 +: 8];\n        end\n        // XOR with initial round key (kb[0])\n        for(int i = 0; i < 16; i++) begin\n            sa[i/4][i%4] <= sa[i/4][i%4] ^ kb[0][i*8 +: 8];\n        end\n    end\nend\n\n// Inverse round transformations\nalways @(posedge clk) begin\n    // InvShiftRows (only for dcnt > 1)\n    if(ld_r && (dcnt > 1)) begin\n        // Row 1: Cyclic right shift by 3 bytes\n        {sa[1][3], sa[1][2], sa[1][1], sa[1][0]} <= {sa[1][0], sa[1][1], sa[1][2], sa[1][3]};\n        // Row 2: Cyclic right shift by 2 bytes\n        {sa[2][2], sa[2][3], sa[2][0], sa[2][1]} <= {sa[2][0], sa[2][1], sa[2][2], sa[2][3]};\n        // Row 3: Cyclic right shift by 1 byte\n        {sa[3][1], sa[3][0], sa[3][3], sa[3][2]} <= {sa[3][0], sa[3][1], sa[3][2], sa[3][3]};\n    end\n    \n    // InvSubBytes (all rounds)\n    for(int i = 0; i < 16; i++) begin\n        sa_next[i/4][i%4] <= aes_inv_sbox(sa[i/4][i%4]);\n    end\n    \n    // InvMixColumns (all rounds except last)\n    if(ld_r && (dcnt < 11)) begin\n        for(int col = 0; col < 4; col++) begin\n            {sa_next[0][col], sa_next[1][col], sa_next[2][col], sa_next[3][col]} <=\n            {pmul_e(sa[0][col], 2'b01) ^ pmul_b(sa[1][col], 2'b01) ^ pmul_d(sa[2][col], 2'b01) ^ pmul_9(sa[3][col], 2'b01),\n             pmul_9(sa[0][col], 2'b01) ^ pmul_e(sa[1][col], 2'b01) ^ pmul_b(sa[2][col], 2'b01) ^ pmul_d(sa[3][col], 2'b01),\n             pmul_d(sa[0][col], 2'b01) ^ pmul_9(sa[1][col], 2'b01) ^ pmul_e(sa[2][col], 2'b01) ^ pmul_b(sa[3][col], 2'b01),\n             pmul_b(sa[0][col], 2'b01) ^ pmul_d(sa[1][col], 2'b01) ^ pmul_9(sa[2][col], 2'b01) ^ pmul_e(sa[3][col], 2'b01)};\n        end\n    end\n    \n    // AddRoundKey (all rounds)\n    for(int i = 0; i < 16; i++) begin\n        sa[i/4][i%4] <= sa_next[i/4][i%4] ^ kb[10 - dcnt + 1][i*8 +: 8];\n    end\nend\n\n// Output mapping\nalways @(posedge clk) begin\n    if(done) begin\n        // Map final state matrix to output register in column-major order\n        for(int i = 0; i < 16; i++) begin\n            text_out[i*8 +: 8] <= sa[i/4][i%4];\n        end\n    end\nend\n\n// Instantiate 16 inverse S-box modules\nwire [7:0] us00, us01, us02, us03;\nwire [7:0] us10, us11, us12, us13;\nwire [7:0] us20, us21, us22, us23;\nwire [7:0] us30, us31, us32, us33;\n\naes_inv_sbox s00(.a(sa[0][0]), .b(us00));\naes_inv_sbox s01(.a(sa[0][1]), .b(us01));\naes_inv_sbox s02(.a(sa[0][2]), .b(us02));\naes_inv_sbox s03(.a(sa[0][3]), .b(us03));\naes_inv_sbox s10(.a(sa[1][0]), .b(us10));\naes_inv_sbox s11(.a(sa[1][1]), .b(us11));\naes_inv_sbox s12(.a(sa[1][2]), .b(us12));\naes_inv_sbox s13(.a(sa[1][3]), .b(us13));\naes_inv_sbox s20(.a(sa[2][0]), .b(us20));\naes_inv_sbox s21(.a(sa[2][1]), .b(us21));\naes_inv_sbox s22(.a(sa[2][2]), .b(us22));\naes_inv_sbox s23(.a(sa[2][3]), .b(us23));\naes_inv_sbox s30(.a(sa[3][0]), .b(us30));\naes_inv_sbox s31(.a(sa[3][1]), .b(us31));\naes_inv_sbox s32(.a(sa[3][2]), .b(us32));\naes_inv_sbox s33(.a(sa[3][3]), .b(us33));\n\nendmodule\n// aes_key_expand_128.v\nmodule aes_key_expand_128(\n    input   clk,\n    input   kld,\n    input   [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n// Registers\nreg [31:0] w[43:0]; // Key schedule buffer\n\n// Key loading\nalways @(posedge clk or posedge kld) begin\n    if(kld) begin\n        w[0] <= key[127:96];\n        w[1] <= key[95:64];\n        w[2] <= key[63:32];\n        w[3] <= key[31:0];\n    end else begin\n        for(int i = 4; i < 44; i++) begin\n            if(i % 4 == 0) begin\n                w[i] <= {w[i-4][23:0], aes_sbox(w[i-4][7:0]), w[i-4][31:8]} ^ aes_rcon(i/4 - 1);\n            end else begin\n                w[i] <= w[i-4] ^ w[i-1];\n            end\n        end\n    end\nend\n\n// Output assignments\nassign wo_0 = w[0];\nassign wo_1 = w[1];\nassign wo_2 = w[2];\nassign wo_3 = w[3];\n\nendmodule\n// aes_sbox.v\nmodule aesbox(\n    input   [:0], // Input byte\n output [70] b  // Substituted byte\n// Lookup table\nreg [7:] b;\n\n @(*) begin\n    case)\n        8'h00: b = 863;\n        8'h01: b = 8'h7c;\n        8'h02: b = 8'h77;\n        // ... (all 256 possible input values)\n        8'hfe: b = 8'h6a;\n        8'hff: b = 8'h7d;\n        default: b = 8'h;\n    end\nend\n\nendmodule\n// aes_invbox.v\nmodule_inv_sbox    input   [:0], // Input byte\n    output7:0 b  // Substituted byte);\n\n// Lookup table implementation\nreg [7:0] b;\n\nalways @(*) begin\n    case(a)\n        8'h00: b = 8'h52;\n        8'h01: b = 8'h09;\n        8'h02: b =8'h4a        // ... (all 256 possible input values)\n        8'h63: b = 8'h00;\n        8'h7d: b = 8'hff;\n        default: b = 8'h00;\n    endcase\nend\n\nendmodule\n// aes_rcon.v\nmodule aes_rcon(\n    input   clk,\n    input   kld,\n    output [31:0] out\n);\n\n// Registers\nreg [31:0] out;\n\n// Counter logic\nalways @(posedge clk or posedge kld) begin\n    if(kld) begin\n        out <= 32'h01_00_00_00;\n    end else begin\n        // Round constant generation based on counter value\n        out <= {32'b0, 1'b1, {(out[7] ^ out[4] ^ out[5] ^ out[6] ^ 1'b1)}};\n    end\nend\n\nendmodule\n// Helper functions for GF(2^8) multiplication\nfunction [7:0] pmul_2;\n    input [7:0] a;\n    pmul_2 = (a << 1) ^ (a[7] ? 8'h1b : 8'h00);\nendfunction\n\nfunction [7:0] pmul_4;\n    input [7:0] a;\n    pm_4 = pmul2(pmul_2(a));\nendfunction\n\nfunction [7:0] pmul_8;\n    input [7:0] a;\n    pmul_8 = pmul_2(pmul_4(a));\nendfunction\n\nfunction [7:0] pmul_9;\n    input [7:0] a;\n    pmul_9 = pmul_8(a) ^ a;\nendfunction\n\nfunction [7:0] pmul_b;\n    input [7:0] a;\n    pmul_b = pmul_2(pmul_8(a));\nendfunction\n\nfunction [7:0] pmul_d;\n    input [7:0] a;\n    pmul_d = pmul_2(pmul_b(a));\nendfunction\n\nfunction [7:0] pmul_e;\n    input [7:0] a;\n    pmul_e = pmul_2(pmul_d(a));\nendfunction", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 15, "code": "module aes_inv_cipher_top(\n    input clk,\n    input rst,\n    input kld,    // Key load enable\n    input ld,     // Load enable\n    output done,  // Decryption complete\n    input [127:0] key,    // Input key\n    input [127:0] text_in, // Input ciphertext\n    output [127:0] text_out // Output plaintext\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [7:0] sa[3:0][3:0];\nreg [3:0] dcnt;    // Round counter\nreg [127:0] kb[10:0]; // Key schedule buffer\nreg [3:0] kcnt;    // Key buffer counter\nreg ld_r;          // Load operation flag\nreg [127:0] text_out;\n\n// Submodule instances\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(kb[10]),\n    .wo_1(kb[9]),\n    .wo_2(kb[8]),\n    .wo_3(kb[7])\n);\n\n// Inverse S-box instances\naes_inv_sbox us00(.a(sa[0][0]), .b(sa_ark[0][0]));\naes_inv_sbox us01(.a(sa[0][1]), .b(sa_ark[0][1]));\naes_inv_sbox us02(.a(sa[0][2]), .b(sa_ark[0][2]));\naes_inv_sbox us03(.a(sa[0][3]), .b(sa_ark[0][3]));\naes_inv_sbox us10(.a(sa[1][0]), .b(sa_ark[1][0]));\naes_inv_sbox us11(.a(sa[1][1]), .b(sa_ark[1][1]));\naes_inv_sbox us12(.a(sa[1][2]), .b(sa_ark[1][2]));\naes_inv_sbox us13(.a(sa[1][3]), .b(sa_ark[1][3]));\naes_inv_sbox us20(.a(sa[2][0]), .b(sa_ark[2][0]));\naes_inv_sbox us21(.a(sa[2][1]), .b(sa_ark[2][1]));\naes_inv_sbox us22(.a(sa[2][2]), .b(sa_ark[2][2]));\naes_inv_sbox us23(.a(sa[2][3]), .b(sa_ark[2][3]));\naes_inv_sbox us30(.a(sa[3][0]), .b(sa_ark[3][0]));\naes_inv_sbox us31(.a(sa[3][1]), .b(sa_ark[3][1]));\naes_inv_sbox us32(.a(sa[3][2]), .b(sa_ark[3][2]));\naes_inv_sbox us33(.a(sa[3][3]), .b(sa_ark[3][3]));\n\n// Internal wires\nwire [7:0] sa_ark[3:0][3:0]; // After AddRoundKey\nwire [7:0] sa_nxt[3:0][3:0]; // After InvMixColumns\n\n// State machine\nalways @(posedge clk) begin\n    if (rst) begin\n        dcnt <= 0;\n        kcnt <= 4'hA;\n        ld_r <= 1'b0;\n        done <= 1'b0;\n    end else begin\n        case (dcnt)\n            4'd0: begin // IDLE\n                if (ld) begin\n                    dcnt <= 4'd1;\n                    ld_r <= 1'b1;\n                end\n            end\n            4'd1: begin // InitialRound\n                if (ld_r) begin\n                    dcnt <= 4'd2;\n                    ld_r <= 1'b0;\n                end\n           \n            4'd2: begin // StandardRound\n                dcnt <= dcnt + 4'd1;\n                if (dcnt == 4'd10) begin\n                    dcnt <= 4'd11;\n                end\n            end\n            4'd11: begin // FinalRound\n                done <= 1'b1;\n            end\n        endcase\n    end\nend\n\n// Key loading logic\nalways @(posedge clk) begin\n    if (rst || kld) begin\n        kcnt <= 4'hA;\n    end else if (kcnt != 4'h0) begin\n        kcnt <= kcnt - 4'd1;\n    end\nend\n\n// Key buffer loading\nalways @(posedge clk) begin\n    if (rst || kld) begin\n        kb[10] <= key[127:96];\n        kb[9] <= key[95:64];\n        kb[8] <= key[63:32];\n        kb[7] <= key[31:0];\n    end else if (kcnt != 4'h0) begin\n        kb[10] <= kb[9];\n        kb[9] <= kb[8];\n        kb[8] <= kb[7];\n        kb[7] <= kb[6];\n        kb[6] <= kb[5];\n        kb[5] <= kb[4];\n        kb[4] <= kb[3];\n        kb[3] <= kb[2];\n        kb[2] <= kb[1];\n        kb[1] <= kb[0];\n        kb[0] <= {key[31:0], key[31]};\n    end\nend\n\n// Initial data loading\nalways @(posedge clk) begin\n    if (ld) begin\n        text_in_r <= text_in;\n    end\nend\n\n// State matrix initialization\nalways @(posedge clk) begin\n    if (ld_r) begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= text_in_r[((j * 4) + i) * 8 +: 8];\n            end\n        end\n // Initial AddRoundKey        for (int i = 0; < 4; i++) begin            for (int j = 0; j 4; j++) begin\n                sa[i][j] <= sa[i][j] ^ kb[10][((j * 4) + i) * 8 +: 8];\n            end\n        end\n    end\nend\n\n// Inverse Shift Rows\nalways @(posedge clk) begin\n    if (dcnt > 1 && dcnt < 11) begin\n        for (int i = 1; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa[i][(j - i + 4) % 4];\n            end\n        end\n    end\nend\n\n// Inverse SubBytes\n// (Handled by aes_inv_sbox instances)\n\n// AddRoundKey\nalways @(posedge clk) begin\n    for (int i = 0; i < 4; i++) begin\n        for (int j = 0; j < 4; j++) begin\n            sa_ark[i][j] <= sa[i][j] ^ kb[dcnt][((j * 4) + i) * 8 +: 8];\n        end\n    end\nend\n\n// Inverse MixColumns (except final round)\nalways @(posedge clk) begin\n    if (dcnt != 11) begin\n        // Column 0\n        sa_nxt[0][0] <= pmul_e(sa_ark[0][0]) ^ pmul_b(sa_ark[1][0]) ^ pmul_d(sa_ark[2][0]) ^ pmul_9(sa_ark[3][0]);\n        sa_nxt[1][0] <= pmul_9(sa_ark[0][0]) ^ pmul_e(sa_ark[1][0]) ^ pmul_b(sa_ark[2][0]) ^ pmul_d(sa_ark[3][0]);\n        sa_nxt[2][0] <= pmul_d(sa_ark[0][0]) ^ pmul_9(sa_ark[1][0]) ^ pmul_e(sa_ark[2][0]) ^ pmul_b(sa_ark[3][0]);\n        sa_nxt[3][0] <= pmul_b(sa_ark[0][0]) ^ pmul_d(sa_ark[1][0]) ^ pmul_9(sa_ark[2][0]) ^ pmul_e(sa_ark[3][0]);\n        \n        // ... Other columns (similar implementation)\n    end\nend\n\n// State matrix update\nalways @(posedge clk) begin\n    if (dcnt != 11 && dcnt != 1) begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                sa[i][j] <= sa_nxt[i][j];\n            end\n        end\n    end\nend\n\n// Final output generation\nalways @(posedge clk) begin\n    if (dcnt == 11) begin\n        for (int i = 0; i < 4; i++) begin\n            for (int j = 0; j < 4; j++) begin\n                text_out[((j * 4) + i) * 8 +: 8] <= sa[i][j];\n            end\n        end\n    end\nend\n\n// Multiplication functions for GF(2^8)\nfunction [7:0] pmul_e;\n    input [7:0] a;\n    pmul_e = (a << 1) ^ (a & 8'h01 ? 8'h1B : 8'h00);\nendfunction\n\nfunction [7:0] pmul_b;\n    input [7:0] a;\n    pmul_b = (a << 1) ^ (a & 8'h01 ? 8'h1B : 8'h00) ^ (a << 2) ^ (a & 8'h02 ? 8'h1B : 8'h00);\nendfunction\n\nfunction [7:0] pmul_d;\n    input [7:0] a;\n    pmul_d = (a << 1) ^ (a & 8'h01 ? 8'h1B : 8'h00) ^ (a << 3) ^ (a & 8'h08 ? 8'h1B : 8'h00);\nendfunction\n\nfunction [7:0] pmul_9;\n    input [7:0] a;\n    pmul_9 = (a << 1) ^ (a & 8'h01 ? 8'h1B : 8'h00) ^ (a << 2) ^ (a & 8'h02 ? 8'h1B : 8'h00) ^ (a << 3) ^ (a & 8'h08 ? 8'h1B : 8'h00);\nendfunction\n\nendmodule\nmodule aes_key_expand_128(\n    input clk,\n    input kld,    // Key load enable\n    input [127:0] key,    // Input initial key\n    output [31:0] wo_0,   // Output round key word 0\n    output [31:0] wo_1,   // Output round key word 1\n    output [31:0] wo_2,   // Output round key word 2\n    output [31:0] wo_3    // Output round key word 3\n);\n\n// Registers\nreg [31:0] w[43:0]; // 44 round keys (11 rounds + initial key)\n\n// Submodule instances\naes_rcon rcon(\n    .clk(clk),\n    .kld(kld),\n    .out(rcon_val)\n);\n\n// S-box module\naes_sbox sbox(\n    .a(temp_byte),\n    .b(sbox_out)\n);\n\n// Internal wires\nwire [7:0] rcon_val;  // Round constant value\nwire [7:0] temp_byte; // Temporary byte for S-box\nwire [7:0] sbox_out;  // Output from S-box\n\n// Key loading logic\nalways @(posedge clk) begin\n    if (kld) begin\n        w[0] <= key[127:96];\n        w[1] <= key[95:64];\n        w[2] <= key[63:32];\n        w[3] <= key[31:0];\n    end\nend\n\n// Key expansion logic\nalways @(posedge clk) begin\n    if (!kld) begin\n        for (int i = 4; i < 44; i++) begin\n            if (i % 4 == 0) begin\n                temp_byte <= w[i-1][7:0];\n                w[i] <= {sbox_out, w[i-1][23:8], w[i-1][15:0], w[i-1][7:0]} ^ {8'h00, 8'h00, 8'h00, rcon_val};\n            end else begin\n                w[i] <= w[i-1] ^ w[i-4];\n            end\n        end\n    end\nend\n\n// Output assignments\nassign wo_0 = w[0];\nassign wo_1 = w[1];\nassign wo_2 = w[2];\nassign wo_3 = w[3];\n\nendmodule\nmodule aes_inv_sbox(\n    input [7:0] a,  // Input byte\n    output [7:0] b  // Substituted byte\n);\n\n// ROM implementation (256x8 bits)\nreg [7:0] inv_sbox_rom[256];\n\nalways @(*) begin\n    b = inv_sbox_rom[a];\nend\n\n// Initialize Inverse S-box ROM (static values)\ninitial begin\n    // Inverse S-box values (precomputed)\n    // For example:\n    inv_sbox_rom[8'h63] = 8'h00; // 0x63 -> 0x00\n    // ... Other values ...\nend\n\nendmodule\nmodule aes_rcon(\n    input clk,\n    input kld,    // Key load signal\n    output [31:0] out // Round constant value\n);\n\n// Registers\nreg [3:0] rcnt; // Round counter\n\n// Internal wires\nreg [7:0] rcon_val; // 8-bit round constant\n\n// Round constant generation\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 4'h0;\n        rcon_val <= 8'h01;\n end else if (nt < 4'h9) begin\n        rcnt <= rcnt + 4'd1;\n        rcon_val <= (rcon_val << 1) ^ (rcon_val[0] ? 8'h1B : 8'h00);\n    end\nend\n\n// Output assignment\nassign out = {32'h00, rcon_val};\n\nendmodule\nmodule aes_sbox(\n    input [7:0] a,  // Input byte\n    output [7:0] b  // Substituted byte\n);\n\n// ROM implementation (256x8 bits)\nreg [7:0] sbox_rom[256];\n\nalways @(*) begin\n    b = sbox_rom[a];\nend\n\n// Initialize S-box ROM (static values)\ninitial begin\n    // Standard S-box values (precomputed)\n    // For example:\n    sbox_rom[8'h00] = 8'h63; // 0x00 -> 0x63\n    // ... Other values ...\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 16, "code": "module aes_inv_cipher_top(clk, rst, kld, ld, done, key, text_in, text_out);\n\nparameter STATE_WIDTH = 128;\nparameter KEY_WIDTH = 128;\nparameter ROUND_COUNT = 10;\n\ninput clk;\ninput rst;\ninput kld;\ninput ld;\noutput reg done;\ninput [KEY_WIDTH-1:0] key;\ninput [STATE_WIDTH-1:0] text_in;\noutput reg [STATE_WIDTH-1:0] text_out;\n\n// Registers\nreg [STATE_WIDTH-1:0] text_in_r;\nreg [3:0][7:0] sa[3:0];\nreg [3:0] dcnt;\nreg [10:0][31:0] kb;\nreg [3:0] kcnt;\nreg ld_r;\nreg [STATE_WIDTH-1:0] text_out_r;\n\n// Internal signals\nwire [31:0] w0, w1, w2, w3;\nwire [3:0][7:0] sa_ark;\nwire [3:0][7:0] sa_next;\n\n// Submodules\naes_key_expand_128 key_expand(clk, kld, key, w3, w2, w1, w0);\naes_inv_sbox u00(sa[0][0], sa_ark[0][0]);\naes_inv_sbox u01(sa[0][1], sa_ark[0][1]);\naes_inv_sbox u02(sa[0][2], sa_ark[0][2]);\naes_inv_sbox u03(sa[0][3], sa_ark[0][3]);\n// ... (16 instances for each state matrix element)\naes_inv_sbox u33(sa[3][3], sa_ark[3][3]);\n\n// State matrix assignment\nalways @(*) begin\n    sa_ark[0] = {kbdcnt][24-:8], kb[dcnt][16-:8], kb[dcnt][8-:8], kb[dcnt][0+:8]};\n    sa_ark[1] = {kb[dcnt][88-:8], kb[dcnt][80-:8], kb[dcnt][72-:8], kb[dcnt][64-:8]};\n    sa_ark[2] = {kb[dcnt][152-:8], kb[dcnt][144-:8], kb[dcnt][136-:8], kb[dcnt][128-:8]};\n    sa_ark[3] = {kb[dcnt+1][24-:8], kb[dcnt+1][16-:8], kb[dcnt+1][8-:8], kb[dcnt+1][0+:8]};\n    \n    // InvShiftRows\n    sa_next[0] = sa_ark[0];\n    sa_next[1] = {sa_ark[1][7-:8], sa_ark[1][15-:8], sa_ark[1][23-:8], sa_ark[1][31-:8]};\n    sa_next[2] = {sa_ark[2][15-:8], sa_ark[2][23-:8], sa_ark[2][31-:8], sa_ark[2][7-:8]};\n    sa_next[3] = {sa_ark[3][23-:8], sa_ark[3][31-:8], sa_ark[3][7-:8], sa_ark[3][15-:8]};\n    \n    // InvMixColumns (apply only for rounds < 10)\n    if (dcnt < ROUND_COUNT) begin\n        sa_next[0] = pmul_e(sa_next[0]) ^ pmul_b(sa_next[1]) ^ pmul_d(sa_next[2]) ^ pmul_9(sa_next[3]);\n        sa_next[1] = pmul_9(sa_next[0]) ^ pmul_e(sa_next[1]) ^ pmul_b(sa_next[2]) ^ pmul_d(sa_next[3]);\n        sa_next[2] = pmul_d(sa_next[0]) ^ pmul_9(sa_next[1]) ^ pmul_e(sa_next[2]) ^ pmul_b(sa_next[3]);\n        sa_next[3] = pmul_b(sa_next[0]) ^ pmul_d(sa_next[1]) ^ pmul_9(sa_next[2]) ^ pmul_e(sa_next[3]);\n    end\nend\n\n// Main FSM\nalways @(posedge clk) begin\n    if (rst) begin\n        text_in_r <= 0;\n        sa <= '{default: 0};\n        dcnt <= 0;\n        kb <= '{default: 0};\n        kcnt <= 4'hA;\n        ld_r <= 0;\n        done <= 0;\n        text_out <= 0;\n    end else if (kld) begin\n        kb[10] <= {w3, w2, w1, w0};\n        if (kcnt > 0) begin\n            kcnt <= kcnt - 1;\n            kb[kcnt] <= {w3, w2, w1, w0};\n        end\n    end else if (ld) begin\n        text_in_r <= text_in;\n        dcnt <= 1;\n        ld_r <= 1;\n        done <= 0;\n    end else if (ld_r) begin\n        // Initial round key addition\n        {sa[0], sa[1], sa[2], sa[3]} <= text_in_r ^ kb[10];\n        // Main decryption loop\n        if (dcnt < ROUND_COUNT) begin\n            dcnt <= dcnt + 1;\n            {sa[0], sa[1], sa[2], sa[3]} <= sa_next;\n        end else begin\n            text_out <= {sa[0], sa[1], sa[2], sa[3]};\n            done <= 1;\n            ld_r <= 0;\n        end\n    end\nend\n\n// GF(2^8) multiplication functions (precomputed)\nfunction [7:0] pmul_e;\n    input [7:0] in;\n    // Implement 0E multiplication in GF(2^8)\n    pmul_e = (in << 4) ^ (in << 1) ^ (in >> 3) ^ (in >> 4);\nendfunction\n\nfunction [7:0] pmul_b;\n    input [7:0] in;\n    // Implement 0B multiplication in GF(2^8)\n    pmul_b = (in << 3) ^ (in << 2) ^ (in >> 2) ^ (in >> 5);\nendfunction\n\nfunction [7:0] pmul_d;\n    input [7:0] in;\n    // Implement 0D multiplication in GF(2^8)\n    pmul_d = (in << 2) ^ (in << 1) ^ (in >> 1) ^ (in >> 6);\nendfunction\n\nfunction [7:0] pmul_9;\n    input [7:0] in;\n    // Implement 09 multiplication in GF(2^8)\n    pmul_9 = (in << 1) ^ (in >> 7);\nendfunction\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 1, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 2, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 3, "code": "// Example Verilog Module\nmodule example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] internal_data;\n\n// Combinational logic\nalways_comb begin\n    internal_data = data_in + 1;\nend\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= internal_data;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 17, "code": "// aes_inv_cipher_top module\nmodule aes_inv_cipher_top(\n    input     clk,          // Clock signal\n    input     rst,          // Reset signal\n    input     kld,          // Key load enable\n    input     ld,           // Load enable\n    output    done,         // Decryption complete\n    input     [127:0] key,  // Input key\n    input     [127:0] text_in, // Input ciphertext\n    output    [127:0] text_out // Output plaintext\n);\n\n// Internal registers\nreg [127:0] text_in_r;\nreg [7:0] sa[3:0][3:0]; // 4x4 state matrix\nreg [3:0] dcnt;         // Round counter\nreg [127:0] kb[10:0];   // Key schedule buffer\nreg [3:0] kcnt;         // Key buffer counter\nreg ld_r;               // Load operation flag\nreg [127:0] text_out;   // Output buffer\n\n// Submodule instances\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(kb[10]),\n    .wo_1(kb[9]),\n    .wo_2(kb[8]),\n    .wo_3(kb[7])\n);\n\n// Parallel inverse S-box modules\naes_inv_sbox us00(.a(sa[0][0]), .b(sa[0][0]));\naes_inv_sbox us01(.a(sa[0][1]), .b(sa[0][1]));\n// ... (16 instances for all state matrix positions)\naes_inv_sbox us33(.a(sa[3][3]), .b(sa[3][3]));\n\n// Control logic\nalways @(posedge clk) begin\n    if (rst) begin\n        // Reset state\n        dcnt <= 0;\n        kcnt <= 4'hA;\n        ld_r <= 0;\n        done <= 0;\n    end else if (kld) begin\n        // Key load state\n        kcnt <= kcnt - 1;\n        if (kcnt == 0) begin\n            kcnt <= 4'hA;\n        end\n    end else if (ld) begin\n        // Initial load\n        ld_r <= 1;\n        text_in_r <= text_in;\n        dcnt <= 1;\n    end else if (ld_r) begin\n        // Initial round key addition\n        ld_r <= 0;\n        dcnt <= dcnt + 1;\n    end else if (dcnt < 11) begin\n        // Standard rounds\n        dcnt <= dcnt + 1;\n    end else if (dcnt == 11) begin\n        // Final round\n        done <= 1;\n    end else begin\n        // Idle state\n        done <= 0;\n    end\nend\n\n// Data path logic\nalways @(*) begin\n    // InvShiftRows (example for row 1)\n    sa[1][0] = sa[3][0];\n    sa[1][1] = sa[0][1];\n    sa[1][2] = sa[1][2];\n    sa[1][3] = sa[2][3];\n    \n    // InvSubBytes (16 parallel S-boxes)\n    // Each S-box replaces its corresponding state matrix element\n    \n    // AddRoundKey (example for one byte)\n    sa[0][0] = sa[0][0] ^ kb[dcnt][7:0];\n    \n    // InvMixColumns (for non-final rounds)\n    // Requires GF(2^8) multiplication operations (not shown)\n    \n    // Output mapping (column-major to text_out)\n    text_out[127:120] = sa[0][0];\n    text_out[119:112] = sa[1][0];\n    text_out[111:104] = sa[2][0];\n    text_out[103:96] = sa[3][0];\n    // ... (similar mapping for other columns)\nend\n\nendmodule\n\n// aes_key_expand_128 module\nmodule aes_key_expand_128(\n    input     clk,          // Clock signal\n    input     kld,          // Key load enable\n    input     [127:0] key,  // Input initial key\n    output    [31:0] wo_0,  // Output round key word 0\n    output    [31:0] wo_1,  // Output round key word 1\n    output    [31:0] wo_2,  // Output round key word 2\n    output    [31:0] wo_3   // Output round key word 3\n);\n\n// Registers for key expansion\nreg [31:0] w[43:0];\n\n// Control logic\nalways @(posedge clk) begin\n    if (kld) begin\n        // Load initial key words\n        w[0] <= key[127:96];\n        w[1] <= key[95:64];\n        w[2] <= key[63:32];\n        w[3] <= key[31:0];\n    end else begin\n        // Expand key\n        w[4] <= w[0] ^ SubWord(RotWord(w[3])) ^ Rcon[0];\n        w[5] <= w[1] ^ w[4];\n        w[6] <= w[2] ^ w[5];\n        w[7] <= w[3] ^ w[6];\n        // ... (similar for other words)\n    end\nend\n\n// Output assignments\nassign wo_0 = w[0];\nassign wo_1 = w[1];\nassign wo_2 = w[2];\nassign wo_3 = w[3];\n\n// Submodules (example for RotWord and SubWord)\nfunction [31:0] RotWord(input [31:0] word);\n    RotWord = {word[7:0], word[31:8]};\nendfunction\n\nfunction [31:0] SubWord(input [31:0] word);\n    SubWord = {Sbox(word[7:0]), Sbox(word[15:8]), Sbox(word[23:16]), Sbox(word[31:24])};\nendfunction\n\nfunction [7:0] Sbox(input [7:0] byte);\n    // Implementation of S-box lookup table\nendfunction\n\nfunction [7:0] Rcon(input [7:0] round);\n    // Implementation of round constant generation\nendfunction\n\nendmodule\n\n// aes_inv_sbox module (lookup table implementation)\nmodule aes_inv_sbox(\n    input  [7:0] a,  // Input byte\n    output [7:0] b   // Substituted byte\n);\n\nreg [7:0] b;\n\n// Lookup table for inverse S-box (256 entries)\nalways @(*) begin\n    case (a)\n        8'h00: b = 8'h52;\n        8'h01: b = 8'h86;\n        8'h02: b = 8'h43;\n        // ... (similar cases for all 256 possible input values)\n        8'hFF: b = 8'h7D;\n        default: b = 8'h00;\n    endcase\nend\n\nendmodule\n\n// aes_rcon module\nmodule aes_rcon(\n    input     clk,  // Clock signal\n    input     kld,  // Key load enable\n    output    [31:0] out // Round constant value\n);\n\nreg [3:0] rcnt; // Round counter\nreg [31:0] out_reg;\n\n// Round constants (precomputed)\nreg [7:0] Rcon[9:0];\n\ninitial begin\n    Rcon[0] = 8'h01;\n    Rcon[1] = 8'h02;\n    Rcon[2] = 8'h04;\n    Rcon[3] = 8'h08;\n    Rcon[4] = 8'h10;\n    Rcon[5] = 8'h20;\n    Rcon[6] = 8'h40;\n    Rcon[7] = 8'h80;\n    Rcon[8] = 8'h1B;\n    Rcon[9] = 8'h36;\nend\n\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 0;\n    end else if (rcnt < 10) begin\n        rcnt <= rcnt + 1;\n    end\nend\n\nalways @(*) begin\n    if (rcnt < 10) begin\n        out_reg = {32'h00, Rcon[rcnt]};\n    end else begin\n        out_reg = 32'h00000000;\n    end\nend\n\nassign out = out_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 4, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule\nmodule counter_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [3:0] count_out\n);\n\nlogic [3:0] count;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 4'd0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nassign count_out = count;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 18, "code": "module aes_inv_cipher_top(\n    input            clk,\n    input            rst,\n    input            kld,\n    input            ld,\n    output           done,\n    input    [127:0] key,\n    input    [127:0] text_in,\n    output   [127:0] text_out\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb[10:0];\nreg [3:0] kcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Submodules\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(kb[10]),\n    .wo_1(kb[9]),\n    .wo_2(kb[8]),\n    .wo_3(kb[7])\n);\n\n// 16 parallel aes_inv_sbox instances\naes_inv_sbox us00(.a(sa[0][0]), .b(sa[0][0]));\naes_inv_sbox us01(.a(sa[0][1]), .b(sa[0][1]));\naes_inv_sbox us02(.a(sa[0][2]), .b(sa[0][2]));\naes_inv_sbox us03(.a(sa[0][3]), .b(sa[0][3]));\naes_inv_sbox us10(.a(sa[1][0]), .b(sa[1][0]));\naes_inv_sbox us11(.a(sa[1][1]), .b(sa[1][1]));\naes_inv_sbox us12(.a(sa[1][2]), .b(sa[1][2]));\naes_inv_sbox us13(.a(sa[1][3]), .b(sa[1][3]));\naes_inv_sbox us20(.a(sa[2][0]), .b(sa[2][0]));\naes_inv_sbox us21(.a(sa[2][1]), .b(sa[2][1]));\naes_inv_sbox us22(.a(sa[2][2]), .b(sa[2][2]));\naes_inv_sbox us23(.a(sa[2][3]), .b(sa[2][3]));\naes_inv_sbox us30(.a(sa[3][0]), .b(sa[3][0]));\naes_inv_sbox us31(.a(sa[3][1]), .b(sa[3][1]));\naes_inv_sbox us32(.a(sa[3][2]), .b(sa[3][2]));\naes_inv_sbox us33(.a(sa[3][3]), .b(sa[3][3]));\n\n// State Machine Logic\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        text_in_r <= 128'd0;\n        dcnt <= 4'd0;\n        kcnt <= 4'hA;\n        ld_r <= 1'b0;\n        text_out <= 128'd0;\n        done <= 1'b0;\n    end else begin\n        // State transitions and operations\n        // (Implementation details omitted for brevity)\n    end\nend\n\n// Output logic\nalways @(*) begin\n    // (Implementation details omitted for brevity)\nend\n\nendmodule\n\nmodule aes_key_expand_128(\n    input            clk,\n    input            kld,\n    input    [127:0] key,\n    output   [31:0] wo_0,\n    output   [31:0] wo_1,\n    output   [31:0] wo_2,\n    output   [31:0] wo_3\n);\n\n// Registers\nreg [31:0] w[0:3];\nreg [3:0] rcnt;\n\n// Submodules\naes_sbox sbox(.a(w[1][7:0]), .b(w[1][7:0]));\naes_rcon rcon(.clk(clk), .kld(kld), .out(rcnt));\n\n// Key expansion logic\nalways @(posedge clk or negedge kld) begin\n    if (!kld) begin\n        w[0] <= key[127:96];\n        w[1] <= key[95:64];\n        w[2] <= key[63:32];\n        w[3] <= key[31:0];\n        rcnt <= 4'd0;\n    end else if (rcnt <= 9) begin\n        w[0] <= w[3] ^ sbox.b ^ (rcnt ? 32'h00000001 : 32'h00000002);\n        w[1] <= w[0];\n        w[2] <= w[1];\n        w[3] <= w[2];\n        rcnt <= rcnt + 1;\n    end\nend\n\nassign wo_0 = w[0];\nassign wo_1 = w[1];\nassign wo_2 = w[2];\nassign wo_3 = w[3];\n\nendmodule\n\nmodule aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table implementation (sbox values)\nreg [7:0] b;\nalways @(*) begin\n    case (a)\n        8'h00: b = 8'h63;\n        8'h01: b = 8'h7c;\n        8'h02: b = 8'h77;\n        // ... (remaining S-box mappings omitted for brevity)\n        default: b = 8'h00;\n    endcase\nend\n\nendmodule\n\nmodule aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table implementation (inverse sbox values)\nreg [7:0] b;\nalways @(*) begin\n    case (a)\n        8'h63: b = 8'h00;\n        8'h7c: b = 8'h01;\n        8'h77: b = 8'h02;\n        // ... (remaining inverse S-box mappings omitted for brevity)\n        default: b = 8'h00;\n    endcase\nend\n\nendmodule\n\nmodule aes_rcon(\n    input            clk,\n    input            kld,\n    output   [31:0] out\n);\n\n// Registers\nreg [3:0] rcnt;\n\n// Round constant generation\nalways @(posedge clk or negedge kld) begin\n    if (!kld) begin\n        rcnt <= 4'd0;\n        out <= 32'h01000000;\n    end else begin\n        rcnt <= rcnt + 1;\n        case (rcnt)\n            4'd1: out <= 32'h02000000;\n            4'd2: out <= 32'h04000000;\n            4'd3: out <= 32'h08000000;\n            4'd4: out <= 32'h10000000;\n            4'd5: out <= 32'h20000000;\n            4'd6: out <= 32'h40000000;\n            4'd7: out <= 32'h80000000;\n            4'd8: out <= 32'h1b000000;\n            4'd9: out <= 32'h36000000;\n            default: out <= 32'h00000000;\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 5, "code": "// Example Verilog Module (Replace with actual design specifications)\nmodule example_module(\n    input  logic clk,        // Clock signal\n    input  logic rst_n,      // Active-low reset\n    input  logic [7:0] data_in, // 8-bit input data\n    output logic [7:0] data_out // 8-bit output data\n);\n\n// Internal signals and registers\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0; // Reset to zero\n    end else begin\n        reg_data <= data_in; // Capture input data on rising clock edge\n    end\nend\n\n// Combinational logic\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 6, "code": "// Define the module with inputs and outputs\nmodule example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals and registers\nlogic [7:0] data_reg;\n\n// Sequential logic (registers)\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_in;\n    end\nend\n\n// Combinational logic\nalways_comb begin\n    data_out = data_reg;\nend\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 7, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_reg + 8'd1;\n    end\nend\n\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 19, "code": "module aes_inv_cipher_top(\n    input           clk,\n    input           rst,\n    input           kld,    // Key load enable\n    input           ld,     // Data load enable\n    output          done,   // Decryption complete\n    input   [127:0] key,    // Input key\n    input   [127:0] text_in, // Input ciphertext\n    output  [127:0] text_out // Output plaintext\n);\n\n// Registers\nreg [127:0] text_in_r;\nreg [7:0] sa[0:3][0:3];\nreg [3:0] dcnt;\nreg [127:0] kb[10:0];\nreg [3:0] kcnt;\nreg ld_r;\nreg [127:0] text_out;\n\n// Key expansion module\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(kb[10]),\n    .wo_1(kb[9]),\n    .wo_2(kb[8]),\n    .wo_3(kb[7])\n);\n\n// Inverse S-box modules\naes_inv_sbox us00(.a(sa[0][0]), .b(sa_00));\naes_inv_sbox us01(.a(sa[0][1]), .b(sa_01));\naes_inv_sbox us02(.a(sa[0][2]), .b(sa_02));\naes_inv_sbox us03(.a(sa[0][3]), .b(sa_03));\naes_inv_sbox us10(.a(sa[1][0]), .b(sa_10));\naes_inv_sbox us11(.a(sa[1][1]), .b(sa_11));\naes_inv_sbox us12(.a(sa[1][2]), .b(sa_12));\naes_inv_sbox us13(.a(sa[1][3]), .b(sa_13));\naes_inv_sbox us20(.a(sa[2][0]), .b(sa_20));\naes_inv_sbox us21(.a(sa[2][1]), .b(sa_21));\naes_inv_sbox us22(.a(sa[2][2]), .b(sa_22));\naes_inv_sbox us23(.a(sa[2][3]), .b(sa_23));\naes_inv_sbox us30(.a(sa[3][0]), .b(sa_30));\naes_inv_sbox us31(.a(sa[3][1]), .b(sa_31));\naes_inv_sbox us32(.a(sa[3][2]), .b(sa_32));\naes_inv_sbox us33(.a(sa[3][3]), .b(sa_33));\n\n// Wires\nwire [7:0] sa_00, sa_01, sa_02, sa_03, sa_10, sa_11, sa_12, sa_13, sa_20, sa_21, sa_22, sa_23, sa_30, sa_31, sa_32, sa_33;\nwire [7:0] sa_ark[0:3][0:3]; // After round key addition\nwire [7:0] sa_nxt[0:3][0:3]; // After InvMixColumns\n\n// State transition\nalways @(*) begin\n    case (nt)\n        4'd0: begin // IDLE\n            if (ld) begin\n                // Initial round key addition\n                for (int i = 0; i < 4; i++) begin\n                    for (int j = 0; j < 4; j++) begin\n                        sa[i][j] <= text_in_r[(i * 32) + (j * 8) +: 8] ^ kb[dcnt][((3 - i) * 32) + (j * 8) +: 8];\n                    end\n                end\n                dcnt <= dcnt + 1;\n            end\n        end\n        4'd1: begin // InitialRound\n            // InvSubBytes\n            sa[0][0] <= sa_00;\n            sa[0][1] <= sa_01;\n            sa[0][2] <= sa_02;\n            sa[0][3] <= sa_03;\n            sa[1][0] <= sa_10;\n            sa[1][1] <= sa_11;\n            sa[1][2] <= sa_12;\n            sa[1][3] <= sa_13;\n            sa[2][0] <= sa_20;\n            sa[2][1] <= sa_21;\n            sa[2][2] <= sa_22;\n            sa[2][3] <= sa_23;\n            sa[3][0] <= sa_30;\n            sa[3][1] <= sa_31;\n            sa[3][2] <= sa_32;\n            sa[3][3] <= sa_33;\n\n            // InvShiftRows\n            // Row 1: Right shift by 3 bytes\n            sa[1][0] <= sa[1][3];\n            sa[1][1] <= sa[1][0];\n            sa[1][2] <= sa[1][1];\n            sa[1][3] <= sa[1][2];\n\n            // Row 2: Right shift by 2 bytes\n            sa[2][0] <= sa[2][2];\n            sa[2][1] <= sa[2][3];\n            sa[2][2] <= sa[2][0];\n            sa[2][3] <= sa[2][1];\n\n            // Row 3: Right shift by 1 byte\n            sa[3][0] <= sa[3][1];\n            sa[3][1] <= sa[3][2];\n            sa[3][2] <= sa[3][3];\n            sa[3][3] <= sa[3][0];\n\n            dcnt <= dcnt + 1;\n        end\n        4'd2: begin // StandardRound\n            // InvMixColumns\n            // Column-wise operation\n            for (int j = 0; j < 4; j++) begin\n                sa_nxt[0][j] <= pmul_e(sa[0][j]) ^ pmul_b(sa[1][j]) ^ pmul_d(sa[2][j]) ^ pmul_9(sa[3][j]);\n                sa_nxt[1][j] <= pmul_9(sa[0][j]) ^ pmul_e(sa[1][j]) ^ pmul_b(sa[2][j]) ^ pmul_d(sa[3][j]);\n                sa_nxt[2][j] <= pmul_d(sa[0][j]) ^ pmul_9(sa[1][j]) ^ pmul_e(sa[2][j]) ^ pmul_b(sa[3][j]);\n                sa_nxt[3][j] <= pmul_b(sa[0][j]) ^ pmul_d(sa[1][j]) ^ pmul_9(sa[2][j]) ^ pmul_e(sa[3][j]);\n            end\n\n            // AddRoundKey\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa_nxt[i][j] ^ kb[10 - dcnt][((3 - i) * 32) + (j * 8) +: 8];\n                end\n            end\n\n            dcnt <=cnt + 1;\n        end\n        4'd11: begin // FinalRound\n            // AddRoundKey (final round)\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    sa[i][j] <= sa[i][j] ^ kb[10 - dcnt][((3 - i) * 32) + (j * 8) +: 8];\n                end\n            end\n\n            // Output mapping\n            for (int i = 0; i < 4; i++) begin\n                for (int j = 0; j < 4; j++) begin\n                    text_out[(i * 32) + (j * 8) +: 8] <= sa[i][j];\n                end\n            end\n\n            done <=1'b1;\n            dcnt <= 4'd0;\n        end\n        default: dcnt <= 4'd0;\n    endcase\nend\n\n// Key expansion logic\nalways @(posedge clk) begin\n    if (rst) begin\n        kcnt <= 4'd10;\n    end else if (kld) begin\n        kcnt <= 4'd10;\n    end else if (kcnt > 4'd0) begin\n        kcnt <= kcnt - 1'b1;\n        kb[kcnt] <= kb[kcnt + 1] ^ (kcnt == 4'd1 ? {8'd0, 8'd0, 8'd0, 8'd0} : (kcnt[0] ? {8'd0, 8'd0, 8'd0, 8'd0} : {8'd0, 8'd0, 8'd0, 8'd1}));\n    end\nend\n\n// Initial data loading\nalways @(posedge clk) begin\n    if (rst) begin\n        text_in_r <= 128'd0;\n        ld_r <= 1'b0;\n    end else if (ld) begin\n        text_in_r <= text_in;\n        ld_r <= 1'b1;\n    end else begin\n        ld_r <= 1'b0;\n    end\nend\n\n// Done signal\nalways @(posedge clk) begin\n    if (rst) begin\n        done <= 1'b0;\n    end else if (dcnt == 4'd11) begin\n        done <= 1'b1;\n    end else begin\n        done <= 1'b0;\n    end\nend\n\n// GF(2^8) multiplication functions\nfunction [7:0] pmul_e; // 0xE (14)\n    input [7:0] a;\n    pmul_e = (a << 1) ^ (a[0] ? 8'h1b : 8'h00);\nendfunction\n\nfunction [7:0] pmul_b; // 0xB (11)\n    input [7:0] a;\n    pmul_b = (a << 3) ^ (a[0] ? 8'h1b : 8'h00);\nendfunction\n\nfunction [7:0] pmul_d; // 0xD (13)\n    input [7:0] a;\n    pmul_d = (a << 2) ^ (a[0] ? 8'h1b : 8'h00);\nendfunction\n\nfunction [7:0] pmul_9; // 0x9 (9)\n    input [7:0] a;\n    pmul_9 = (a << 4) ^ (a[0] ? 8'h1b : 8'h00);\nendfunction\n\nendmodule\n\nmodule aes_key_expand_128(\n    input           clk,\n    input           kld,    // Key load enable\n    input   [127:0] key,    // Input key\n    output  [31:0] wo_0,    // Output round key word 0\n    output  [31:0] wo_1,    // Output round key word 1\n    output  [31:0] wo_2,    // Output round key word 2\n    output  [31:0] wo_3     // Output round key word 3\n);\n\nreg [31:0] w[0:3];\nreg [3:0] rcnt;\n\naes_rcon rcon(\n    .clk(clk),\n    .kld(kld),\n    .out(rcon_out)\n);\n\nwire [31:0] rcon_out;\n\n// Wires\nwire [31:0] temp;\n\nalways @(*) begin\n    case (rcnt)\n        4'd0: wo_0 <= key[127:96];\n        4'd1: wo_0 <= w[0];\n        4'd2: wo_0 <= w[1];\n        4'd3: wo_0 <= w[2];\n        4'd4: wo_0 <= w[3];\n        4'd5: wo_0 <= w[0];\n        4'd6: wo_0 <= w[1];\n        4'd7: wo_0 <= w[2];\n        4'd8: wo_0 <= w[3];\n        4'd9: wo_0 <= w[0];\n        4'd10: wo_0 <= key[31:0];\n        default: wo_0 <= 32'd0;\n    endcase\n\n    case (rcnt)\n        4'd0: wo_1 <= key[95:64];\n        4'd1: wo_1 <= w[1];\n        4'd2: wo_1 <= w[2];\n        4'd3: wo_1 <= w[3];\n        4'd4: wo_1 <= w[0];\n        4'd5: wo_1 <= w[1];\n        4'd6: wo_1 <= w[2];\n        4'd7: wo_1 <= w[3];\n        4'd8: wo_1 <= w[0];\n        4'd9: wo_1 <= w[1];\n        4'd10: wo_1 <= key[63:32];\n        default: wo_1 <= 32'd0;\n    endcase\n\n    case (rcnt)\n        4'd0: wo_2 <= key[63:32];\n        4'd1: wo_2 <= w[2];\n        4'd2: wo_2 <= w[3];\n        4'd3: wo_2 <= w[0];\n        4'd4: wo_2 <= w[1];\n        4'd5: wo_2 <= w[2];\n        4'd6: wo_2 <= w[3];\n        4'd7: wo_2 <= w[0];\n        4'd8: wo_2 <= w[1];\n        4'd9: wo_2 <= w[2];\n        4'd10: wo_2 <= key[31:0];\n        default: wo_2 <= 32'd0;\n    endcase\n\n    case (rcnt)\n        4'd0: wo_3 <= key[31:0];\n        4'd1: wo_3 <= w[3];\n        4'd2: wo_3 <= w[0];\n        4'd3: wo_3 <= w[1];\n        4'd4: wo_3 <= w[2];\n        4'd5: wo_3 <= w[3];\n        4'd6: wo_3 <= w[0];\n        4'd7: wo_3 <= w[1];\n        4'd8: wo_3 <= w[2];\n        4'd9: wo_3 <= w[3];\n        4'd10: wo_3 <= key[31:0];\n        default: wo_3 <= 32'd0;\n    endcase\n\n    // Key expansion logic\n    temp = (rcnt == 4'd0) ? {8'd0, 8'd0, 8'd0, 8'd0} : (rcnt[0] ? {8'd0, 8'd0, 8'd0, 8'd0} : {8'd0, 8'd0, 8'd0, 8'd1});\n    w[0] <= w[3] ^ aes_sbox(w[0]) ^ rcon_out;\n    w[1] <= w[0];\n    w[2] <= w[1];\n    w[3] <= w[2];\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        rcnt <= 4'd0;\n    end else if (kld) begin\n        rcnt <= 4'd0;\n    end else if (rcnt < 4'd10) begin\n        rcnt <= rcnt + 1'b1;\n    end\nend\n\nendmodule\n\nmodule aes_sbox(\n    input   [7:0] a,\n    output  [7:0] b\n);\n\nreg [7:0] b;\n\nalways @(*) begin    case (a)\n       8'd0:   b = 8'd52;\n        8'd1:   b = 8'd80;\n        8'd2:   b = 8'd9;\n        8'd3:   b = 8'd98;\n        // ... (Complete all 256 entries)\n        default: b = 8'd0;\n    endcase\nend\n\nendmodule\n\nmodule aes_inv_sbox(\n    input   [7:0] a,\n    output  [7:0] b\n);\n\nreg [7:0] b;\n\nalways @(*) begin\n    case (a)\n        8'd0:   b = 8'd52;\n        8'd1:   b = 8'd80;\n        8'd2:   b = 8'd9;\n        8'd3:   b = 8'd98;\n        // ... (Complete all 256 entries)\n        default: b = 8'd0;\n    endcase\nend\n\nendmodule\n\nmodule aes_rcon(\n    input           clk,\n    input           kld,\n    output  [31:0] out\n);\n\nreg [31:0] out;\nreg [3:0] rcnt;\n\nalways @(*) begin\n    out = (rcnt == 4'd0) ? 32'h01_00_00_00 :\n          (rcnt == 4'd1) ? 32'h02_00_00_00 :\n          (rcnt == 4'd2) ? 32'h04_00_00_00 :\n          (rcnt == 4'd3) ? 32'h08_00_00_00 :\n          (rcnt == 4'd4) ? 32'h10_00_00_00 :\n          (rcnt == 4'd5) ? 32'h20_00_00_00 :\n          (rcnt == 4'd6) ? 32'h40_00_00_00 :\n          (rcnt == 4'd7) ? 32'h80_00_00_00 :\n          (rcnt == 4'd8) ? 32'h1b_00_00_00 :\n          (rcnt == 4'd9) ? 32'h36_00_00_00 :\n                           32'd0;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        rcnt <= 4'd0;\n    end else if (kld) begin\n        rcnt <= 4'd0;\n    end else if (rcnt < 4'd9) begin\n        rcnt <= rcnt + 1'b1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 8, "code": "module example_module(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\n// Internal signals and variables\nreg [7:0] data_reg;\n\n// Always block for sequential logic (registers)\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_in;\n    end\nend\n\n// Continuous assignment for combinational logic\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 9, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= 8'b0;\n    end else\n        data_out data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 10, "code": "// Example Verilog Module (Replace with actual content if provided)\nmodule example_module(\n    input   logic   clk,          // Clock input\n    input   logic   rst_n,        // Active-low reset\n    input   logic   [3:0]  data_in, // 4-bit input data\n    output  logic   [7:0]  data_out // 8-bit output data\n);\n\n// Internal signals\nlogic [70] internal_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        internal_reg <= 8'b0;\n    end else begin\n        internal_reg <= {internal_reg[6:0], data_in[0]};\n    end\nend\n\nassign data_out = internal_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 20, "code": "module aes_inv_cipher_top(\n    input           clk,\n    input           rst,\n    input           kld,\n    input           ld,\n    output          done,\n    input   [127:0] key,\n    input   [127:0] text_in,\n    output  [127:0] text_out\n);\n\n// Internal signals\nreg [127:0] text_in_r;\nreg [3:0][7:0] sa [0:3]; // 4x4 state matrix registers\nreg [3:0] dcnt;          // Round counter\nreg [10:0][127:0] kb;   // Key buffer (11 round keys)\nreg [3:0] kcnt;          // Key buffer counter (initial value 0xA)\nreg ld_r;                // Load operation flag\nreg [127:0] text_out;    // Output register\n\n// Submodule instances\naes_key_expand_128 key_expand(\n    .clk(clk),\n    .kld(kld),\n    .key(key),\n    .wo_0(kb[10][31:0]),\n    .wo_1(kb[10][63:32]),\n    .wo_2(kb[10][95:64]),\n    .wo_3(kb[10][127:96])\n);\n\n// Key expansion process\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        kcnt <= 4'd10; // Initialize key buffer counter\n        kb[10] <= '0;\n    end else if (kld) begin\n        kcnt <= 4'd10;\n        kb[10] <= key;\n    end else if (kcnt > 4'd0) begin\n        kcnt <= kcnt - 1;\n        kb[kcnt] <= kb[kcnt + 1];\n    end\nend\n\n// Main control logic\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        dcnt <= 4'd0;\n        ld_r <= 1'b0;\n        done <= 1'b0;\n    end else begin\n        // IDLE state\n        if (ld) begin\n            ld_r <= 1'b1;\n            dcnt <= 4'd1;\n            text_in_r <= text_in;\n            done <= 1'b0;\n        // Decryption process\n        end else if (ld_r) begin\n            case (dcnt)\n                4'd1: begin // Initial round key addition\n                    // Perform initial AddRoundKey\n                    dcnt <= dcnt + 1;\n                end\n                4'd2: begin // Standard rounds\n                    // InvSubBytes, InvShiftRows, InvMixColumns, AddRoundKey\n                    dcnt <= dcnt + 1;\n                end\n                4'd11: begin // Final round\n                    // InvSubBytes, InvShiftRows, AddRoundKey\n                    done <= 1'b1;\n                    ld_r <= 1'b0;\n                end\n            endcase\n        end\n    end\nend\n\n// Output mapping\nalways @(posedge clk) begin\n    if (done) begin\n        // Map output from state matrix to text_out\n        // Column-major order (reverse of input mapping)\n        text_out[127:120] <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0]};\n        text_out[119:112] <= {sa[0][1], sa[1][1], sa[2][1], sa[3][1]};\n        text_out[111:104] <= {sa[0][2], sa[1][2], sa[2][2], sa[3][2]};\n        text_out[103:96]  <= {sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n    end\nend\n\n// Round transformations (invocations of submodules)\n// InvShiftRows, InvSubBytes, InvMixColumns, AddRoundKey\n// (Implementation details omitted for brevity)\n\nendmodule\nmodule aes_key_expand_128(\n    input           clk,\n    input           kld,\n    input   [127:0] key,\n    output  [31:0] wo_0,\n    output  [31:0] wo_1,\n    output  [31:0] wo_2,\n    output  [31:0] wo_3\n);\n\nreg [31:0] w[43:0]; // Key schedule buffer\nreg [3:0] rcnt;     // Round counter for key expansion\n\n// Key loading process\nalways @(posedge clk or negedge kld) begin\n    if (!kld) begin\n        w[0] <= key[31:0];\n        w[1] <= key[63:32];\n        w[2] <= key[95:64];\n        w[3] <= key[127:96];\n        rcnt <= 4'd0;\n    end\nend\n\n// Key expansion process\nalways @(posedge clk) begin\n    if (rcnt < 4'd10) begin\n        w[rcnt + 4] <= w[rcnt] ^ w[rcnt + 1];\n        w[rcnt + 5] <= w[rcnt + 4] ^ w[rcnt + 2];\n        w[rcnt + 6] <= w[rcnt + 5] ^ w[rcnt + 3];\n        rcnt <= rcnt + 1;\n    end\nend\n\n// Output assignment\nassign wo_0 = w[0];\nassign wo_1 = w[1];\nassign wo_2 = w[2];\nassign wo_3 = w[3];\n\nendmodule\nmodule aes_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table implementation (256 x 8-bit entries)\nreg [7:0] rom[0:255];\n\n// Initialize ROM with S-box values (omitted for brevity)\n// ...\n\nalways @(a) begin\n    b <= rom[a];\nend\n\nendmodule\nmodule aes_inv_sbox(\n    input  [7:0] a,\n    output [7:0] b\n);\n\n// Lookup table implementation (256 x 8-bit entries)\nreg [7:0] inv_rom[0:255];\n\n// Initialize inverse S-box values (omitted for brevity)\n// ...\n\nalways @(a) begin\n    b <= inv_rom[a];\nend\n\nendmodule\nmodule aes_rcon(\n    input   clk,\n    input   kld,\n    output [31:0] out\n);\n\nreg [3:0] rcnt; // Round counter\nreg [70] rcon; // Round constant (only MSB is valid)\n\n// Round constant calculation\nalways @(posedge clk) begin\n    if (kld) begin\n        rcnt <= 4'd0;\n        rcon <= 8'd1;\n    end else if (rcnt < 4'd10) begin\n        rcnt <= rcnt + 1;\n        rcon <= rcon << 1 ^ 8'd11; // XOR with polynomial if MSB is set\n    end\nend\n\n// Output formatting (only MSB is valid)\nassign out = {rcon, 24'd0};\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 11, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [7:0] data_out\n);\n\n    logic [7:0] data_reg;\n\n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_reg <= 8'd0;\n        end else begin\n            data_reg <= data_reg + 1;\n        end\n    end\n\n    assign data_out = data_reg;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 12, "code": "module example_module(\n    input  logic        clk,       // Clock signal\n    input  logic        rst_n,     // Active-low reset\n    input  logic [7:0]  data_in,   // 8-bit input data\n    output logic [7:0]  data_out   // 8-bit data\n);\n\nlogic [7:0] data_reg;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;         // Reset to zero\n    end else begin\n        data_reg <= data_in;      // Capture input data on rising clock edge\n    end\nend\n\nassign data_out = data_reg;       // Continuous assignment to outputendmodule: example_module", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 13, "code": "// Define the module as requested\nmodule example_module(\n    // Declare input and output ports\n    input logic clk, \n    input logic rst_n, \n    input logic [7:0] data_in, \n    output logic [7:0] data_out\n);\n\n// Internal signals if needed\n// logic [7:0] internal_data;\n\n// Describe the module's functionality\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        // Reset condition\n        data_out <= 8'b0;\n    end else begin\n        // Normal operation (e.g., pass input to output)\n        data_out <= data_in;\n    end\nend\n\n// Additional logic if needed\n// always_comb begin\n//     // Combinatorial logic\n//     internal_data = data_in + 8'b1;\n// end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 14, "code": "module your_module_name(\n    input  logic clk,  // Clock input\n    input  logic rst_n,  // Active-low reset\n    input  logic [7:0] data_in,  // 8-bit input data\n    output logic [7:0] data_out,  // 8-bit output data\n    input  logic valid_in,  // Input data valid signal\n    output logic valid_out  // Output data valid signal\n);\n\n// Example sequential logic (registers)\nlogic [7:0] internal_data;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        internal_data <= 8'd0;\n    end else if (valid_in) begin\n        internal_data <= data_in;\n    end\nend\n\n// Example combinational logic\nalways_comb begin\n    data_out = internal_data;  // Pass-through example\n    valid_out = valid_in;  // Pass-through example\nend\n\n// Optional: Additional logic as needed\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 15, "code": "module example_module(input  wire clk,\n                     input  wire rst_n,\n                     input  wire [7:0] data_in,\n                     output wire [7:0] data_out);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 16, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        data_out <= '0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 17, "code": "module example_module(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\n// Internal signals\nreg [7:0] data_reg;\n\n// Sequential logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_reg <= 8'd0;\n    end else begin\n        data_reg <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = data_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 18, "code": "module example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= '0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = reg_data;\n\nendmodule : example_module", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 19, "code": "// Example Verilog Module (Replace with your actual design)\nmodule example_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\n// Internal signals\nlogic [7:0] reg_data;\n\n// Sequential logic\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        reg_data <= 8'd0;\n    end else begin\n        reg_data <= data_in;\n    end\nend\n\n// Combinational logic\nassign data_out = reg_data;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 20, "code": "module my_module(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data_in,\n    output logic [7:0] data_out\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 8'd0;\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule\nmodule counter(\n    input  logic clk,\n    input  logic rst_n,\n    output logic [3:0] count\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 4'd0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule\nmodule mux2to1(\n    input  logic [7:0] data0,\n    input  logic [7:0] data1,\n    input  logic sel,\n    output logic [7:0] data_out\n);\n\nalways_comb begin\n    if (sel) begin\n        data_out = data1;\n    end else begin\n        data_out = data0;\n    end\nend\n\nendmodule\nmodule dff(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] d,\n    output logic [7:0] q\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        q <= 8'd0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\nmodule adder(\n    input  logic [7:0] a,\n    input  logic [7:0] b,\n    output logic [7:0] sum\n);\n\nalways_comb begin\n    sum = a + b;\nend\n\nendmodule\nmodule fsm_example(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic start,\n    output logic [1:0] state,\n    output logic done\n);\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        state <= 2'd0;\n        done <= 1'd0;\n    end else if (start) begin\n        case (state)\n            2'd0: state <= 2'd1;\n            2'd1: state <= 2'd2;\n            2'd2: state <= 2'd3;\n            2'd3: begin\n                state <= 2'd0;\n                done <= 1'd1;\n            end\n        endcase\n    end else begin\n        state <= state;\n        done <= 1'd0;\n    end\nend\n\nendmodule\nmodule uart_tx(\n    input  logic clk,\n    input  logic rst_n,\n    input  logic [7:0] data,\n    input  logic tx_start,\n    output logic tx,\n    output logic tx_busy\n);\n\nlogic [3:0] bit_cnt;\nlogic [7:0] shift_reg;\nlogic [12:0] baud_cnt;\n\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        tx <= 1'd1;\n        tx_busy <= 1'd0;\n        bit_cnt <= 4'd0;\n        shift_reg <= 8'd0;\n        baud_cnt <= 13'd0;\n    end else if (tx_start && !tx_busy) begin\n        tx_busy <= 1'd1;\n        shift_reg <= {1'd1, data, 1'd0}; // Start bit + data + stop bit\n        bit_cnt <= 4'd0;\n        baud_cnt <= 13'd0;\n    end else if (tx_busy) begin\n        if (baud_cnt == 13'd0) begin\n            baud_cnt <= 13'd1639; // 9600 baud at 16MHz clock (16x oversampling)\n            tx <= shift_reg[0];\n            shift_reg <= shift_reg >> 1;\n            bit_cnt <= bit_cnt + 1;\n            if (bit_cnt == 4'd10) begin // 1 start + 8 data + 1 stop\n                tx_busy <= 1'd0;\n            end\n        end else begin\n            baud_cnt <= baud_cnt - 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
