{"task": "sd_clock_divider", "codeid": 1, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK <= ~SD_CLK;\n            end else begin\n                counter <= counter + 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 1, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:12], CRC[11] ^ inv, CRC[10:5], CRC[4] ^ inv, CRC[3:1], inv};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 2, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 2, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter >= DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1'b1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // For ACTEL synthesis, use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    assign SD_CLK = SD_CLK_O;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 3, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:12], CRC[11] ^ inv, CRC[10:5], CRC[4] ^ inv, CRC[3:1], inv};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 4, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 5, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 3, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    // Assuming CLKINT is a specific cell for ACTEL synthesis\n    CLKINT clkint_inst (.A(SD_CLK_O), .Y(SD_CLK));\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 4, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'd0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'd0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Specific backend version handling\n    wire CLKINT;\n    assign CLKINT = SD_CLK_O;\n    assign SD_CLK = CLKINT;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 5, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'd0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'd0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 8'd1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    CLKINT clkint_inst (.A(SD_CLK_O), .Y(SD_CLK));\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 6, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter >= DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    CLKINT clkint_inst (\n        .A(SD_CLK_O),\n        .Y(SD_CLK)\n    );\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 7, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    CLKINT clkint_inst (\n        .A(SD_CLK_O),\n        .Y(SD_CLK)\n    );\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 8, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    // This section is left for ACTEL specific implementation\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 1, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        wire inv = BITVAL ^ CRC[6];\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 9, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    // Assuming CLKINT is a specific clock buffer or module in ACTEL\n    CLKINT clk_buffer (\n        .A(SD_CLK_O),\n        .Y(SD_CLK)\n    );\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 10, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    // Assuming CLKINT is a specific construct for ACTEL synthesis\n    CLKINT u_clkint (.A(SD_CLK_O), .Y(SD_CLK));\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 2, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        wire inv = BITVAL ^ CRC[6];\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 11, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1'b1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // For ACTEL synthesis, use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    assign SD_CLK = SD_CLK_O;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 12, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1'b1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Assuming CLKINT is a specific clock buffer used in ACTEL synthesis\n    CLKINT clk_buffer (.A(SD_CLK_O), .Y(SD_CLK));\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 13, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    // This part would be specific to ACTEL synthesis tools and may require additional constructs\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 14, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter >= DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1'b1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    // Assuming CLKINT is a specific feature for ACTEL synthesis\n    // This is a placeholder for the actual implementation\n    assign SD_CLK = SD_CLK_O; // Replace with actual CLKINT usage\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 15, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    // Assuming CLKINT is a specific buffer or logic for ACTEL synthesis\n    assign SD_CLK = SD_CLK_O; // Placeholder for actual ACTEL specific logic\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 16, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter >= DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // ACTEL specific logic\n    wire CLKINT;\n    assign CLKINT = SD_CLK_O;\n    assign SD_CLK = CLKINT;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_counter;\n    reg [BD_WIDTH-1:0] read_counter;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && (free_bd > 0)) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_counter <= write_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_counter == 1) || (RAM_MEM_WIDTH == 16 && write_counter == 3)) begin\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_counter <= read_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && read_counter == 1) || (RAM_MEM_WIDTH == 16 && read_counter == 3)) begin\n                    ack_o_s <= 1;\n                    read_counter <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_count;\n    reg [BD_WIDTH-1:0] read_count;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    wire new_bw;\n    assign new_bw = (RAM_MEM_WIDTH == 32) ? (write_count == 1) : (write_count == 3);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n                write_count <= write_count + 1;\n                if (new_bw) begin\n                    free_bd <= free_bd - 1;\n                    write_count <= 0;\n                end\n            end\n\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n                read_count <= read_count + 1;\n                if (RAM_MEM_WIDTH == 16) begin\n                    ack_o_s <= 1;\n                end\n                if ((RAM_MEM_WIDTH == 32 && read_count == 1) || (RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                    read_count <= 0;\n                end\n            end else begin\n                ack_o_s <= 0;\n            end\n\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_count;\n    reg [BD_WIDTH-1:0] read_count;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    wire new_bw;\n    assign new_bw = (RAM_MEM_WIDTH == 32) ? (write_count == 1) : (write_count == 3);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            ack_o_s <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_count <= write_count + 1;\n                if (new_bw) begin\n                    free_bd <= free_bd - 1;\n                    write_count <= 0;\n                end\n            end\n\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_count <= read_count + 1;\n                if (RAM_MEM_WIDTH == 16) begin\n                    ack_o_s <= 1;\n                end\n                if ((RAM_MEM_WIDTH == 32 && read_count == 1) || (RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                    read_count <= 0;\n                end\n            end else begin\n                ack_o_s <= 0;\n            end\n\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n\n            if (m_wr_pnt == BD_SIZE) begin\n                m_wr_pnt <= 0;\n            end\n            if (s_rd_pnt == BD_SIZE) begin\n                s_rd_pnt <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 17, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    wire CLKINT;\n    assign CLKINT = SD_CLK_O;\n    assign SD_CLK = CLKINT;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_count;\n    reg [BD_WIDTH-1:0] read_count;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    wire new_bw;\n    assign new_bw = (RAM_MEM_WIDTH == 32) ? (write_count == 1) : (write_count == 3);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            last_a_cmp <= 0;\n            ack_o_s <= 0;\n        end else begin\n            if (we_m && (free_bd > 0)) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_count <= write_count + 1;\n                if (new_bw) begin\n                    free_bd <= free_bd - 1;\n                    write_count <= 0;\n                end\n            end\n\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_count <= read_count + 1;\n                if (RAM_MEM_WIDTH == 16) begin\n                    ack_o_s <= 1;\n                end\n                if ((RAM_MEM_WIDTH == 32 && read_count == 1) || (RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                    read_count <= 0;\n                end\n            end else begin\n                ack_o_s <= 0;\n            end\n\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n\n            if (m_wr_pnt == BD_SIZE) begin\n                m_wr_pnt <= 0;\n            end\n            if (s_rd_pnt == BD_SIZE) begin\n                s_rd_pnt <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_counter;\n    reg [BD_WIDTH-1:0] read_counter;\n    reg last_a_cmp;\n    reg new_bw;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_counter <= write_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_counter == 1) || (RAM_MEM_WIDTH == 16 && write_counter == 3)) begin\n                    new_bw <= 1;\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_counter <= read_counter + 1;\n                if (RAM_MEM_WIDTH == 16) begin\n                    ack_o_s <= 1;\n                end\n                if ((RAM_MEM_WIDTH == 32 && read_counter == 1) || (RAM_MEM_WIDTH == 16 && read_counter == 3)) begin\n                    read_counter <= 0;\n                end\n            end else begin\n                ack_o_s <= 0;\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n\n            // Circular Operation\n            if (m_wr_pnt == BD_SIZE) begin\n                m_wr_pnt <= 0;\n            end\n            if (s_rd_pnt == BD_SIZE) begin\n                s_rd_pnt <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_counter;\n    reg [BD_WIDTH-1:0] read_counter;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    wire new_bw;\n    assign new_bw = (RAM_MEM_WIDTH == 32) ? (write_counter == 1) : (write_counter == 3);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            ack_o_s <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n                write_counter <= write_counter + 1;\n                if (new_bw) begin\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n                read_counter <= read_counter + 1;\n                if (RAM_MEM_WIDTH == 16) begin\n                    ack_o_s <= 1;\n                end\n                if ((RAM_MEM_WIDTH == 32 && read_counter == 1) || (RAM_MEM_WIDTH == 16 && read_counter == 3)) begin\n                    read_counter <= 0;\n                end\n            end else begin\n                ack_o_s <= 0;\n            end\n\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_count;\n    reg [BD_WIDTH-1:0] read_count;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_count <= write_count + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_count == 1) || (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                    free_bd <= free_bd - 1;\n                    write_count <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_count <= read_count + 1;\n                if ((RAM_MEM_WIDTH == 32 && read_count == 1) || (RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                    ack_o_s <= 1;\n                    read_count <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n\n            // Circular Operation\n            if (m_wr_pnt == BD_SIZE) begin\n                m_wr_pnt <= 0;\n            end\n            if (s_rd_pnt == BD_SIZE) begin\n                s_rd_pnt <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Internal signals\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_counter;\n    reg [BD_WIDTH-1:0] read_counter;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    wire new_bw;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_counter <= write_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_counter == 1) || (RAM_MEM_WIDTH == 16 && write_counter == 3)) begin\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_counter <= read_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && read_counter == 1) || (RAM_MEM_WIDTH == 16 && read_counter == 3)) begin\n                    ack_o_s <= 1;\n                    read_counter <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n\n            // Circular Operation\n            if (m_wr_pnt == BD_SIZE) begin\n                m_wr_pnt <= 0;\n            end\n            if (s_rd_pnt == BD_SIZE) begin\n                s_rd_pnt <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_counter;\n    reg [BD_WIDTH-1:0] read_counter;\n    reg last_a_cmp;\n\n    // Memory for buffer descriptors\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_counter <= write_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_counter == 1) || (RAM_MEM_WIDTH == 16 && write_counter == 3)) begin\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_counter <= read_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && read_counter == 1) || (RAM_MEM_WIDTH == 16 && read_counter == 3)) begin\n                    ack_o_s <= 1;\n                    read_counter <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full;\n    wire fifo_empty;\n\n    sd_rx_fifo u_sd_rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (!wb_free && m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_counter;\n    reg [BD_WIDTH-1:0] read_counter;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    wire new_bw;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            last_a_cmp <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_counter <= write_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_counter == 1) || (RAM_MEM_WIDTH == 16 && write_counter == 3)) begin\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_counter <= read_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && read_counter == 1) || (RAM_MEM_WIDTH == 16 && read_counter == 3)) begin\n                    ack_o_s <= 1;\n                    read_counter <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n\n            // Circular Operation\n            if (m_wr_pnt == BD_SIZE) begin\n                m_wr_pnt <= 0;\n            end\n            if (s_rd_pnt == BD_SIZE) begin\n                s_rd_pnt <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_counter;\n    reg [BD_WIDTH-1:0] read_counter;\n    reg last_a_cmp;\n    reg new_bw;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_counter <= write_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_counter == 1) || (RAM_MEM_WIDTH == 16 && write_counter == 3)) begin\n                    new_bw <= 1;\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_counter <= read_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && read_counter == 1) || (RAM_MEM_WIDTH == 16 && read_counter == 3)) begin\n                    ack_o_s <= 1;\n                    read_counter <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n\n            // Circular Operation\n            if (m_wr_pnt == BD_SIZE) begin\n                m_wr_pnt <= 0;\n            end\n            if (s_rd_pnt == BD_SIZE) begin\n                s_rd_pnt <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_counter;\n    reg [BD_WIDTH-1:0] read_counter;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_counter <= write_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_counter == 1) || (RAM_MEM_WIDTH == 16 && write_counter == 3)) begin\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_counter <= read_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && read_counter == 1) || (RAM_MEM_WIDTH == 16 && read_counter == 3)) begin\n                    ack_o_s <= 1;\n                    read_counter <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n\n            // Circular Operation\n            if (m_wr_pnt == BD_SIZE) begin\n                m_wr_pnt <= 0;\n            end\n            if (s_rd_pnt == BD_SIZE) begin\n                s_rd_pnt <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_counter;\n    reg [BD_WIDTH-1:0] read_counter;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    wire new_bw;\n    assign new_bw = (RAM_MEM_WIDTH == 32) ? (write_counter == 1) : (write_counter == 3);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n                write_counter <= write_counter + 1;\n                if (new_bw) begin\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n                read_counter <= read_counter + 1;\n                if (RAM_MEM_WIDTH == 16) begin\n                    ack_o_s <= 1;\n                end\n                if ((RAM_MEM_WIDTH == 32 && read_counter == 1) || (RAM_MEM_WIDTH == 16 && read_counter == 3)) begin\n                    read_counter <= 0;\n                end\n            end else begin\n                ack_o_s <= 0;\n            end\n\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 1, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:31]; // Array to hold register values\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg <= 32'h0000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                    end\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0000; // Controller Setting\n                    8'h20: wb_dat_o <= 32'h0200; // Block Size\n                    8'h24: wb_dat_o <= 32'h000f; // Power Control\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0000; // Capability\n                    8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n            if (we_m_rx_bd || we_m_tx_bd) begin\n                int_ack <= 1'b1;\n                we_m_rx_bd <= 1'b0;\n                we_m_tx_bd <= 1'b0;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b00;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b00;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Operations\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 0;\n            complete <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            STATUS_REG <= 0;\n            status <= 0;\n            cmd_out <= 0;\n            settings <= 0;\n            response_size <= 0;\n            req_out <= 0;\n            index_check_enable <= 0;\n            ack_out <= 0;\n            Watchdog_Cnt <= 0;\n            go_idle_o <= 0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1;\n                        NORMAL_INT_REG[15] <= 1;\n                        if (ack_in_int) complete <= 1;\n                        go_idle_o <= 1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1;\n                        if (dat_ava) begin\n                            complete <= 1;\n                            NORMAL_INT_REG[15] <= 0;\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1;\n                                NORMAL_INT_REG[15] <= 1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1;\n                                NORMAL_INT_REG[15] <= 1;\n                            end\n                            NORMAL_INT_REG[0] <= 1;\n                            if (response_size != 0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b00;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b00;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Transitions\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM State Operation\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable;\n    reg CRC_check_enable;\n    reg [7:0] status;\n    reg req_in_int, ack_in_int;\n    reg [1:0] WORD_SELECT;\n    reg [5:0] CMDI;\n    reg CICE, CRCE;\n    reg [1:0] RTS;\n    reg dat_ava, crc_valid;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_in_int <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_in_int <= req_in;\n            ack_in_int <= ack_in;\n        end\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Operation\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 3, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        wire inv = BITVAL ^ CRC[6];\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 2, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:15];\nreg [15:0] reg_file_16 [0:15];\nreg [7:0] reg_file_8 [0:15];\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 0;\n        we_m_tx_bd <= 0;\n        we_m_rx_bd <= 0;\n        new_cmd <= 0;\n        we_ack <= 0;\n        int_ack <= 1;\n        cmd_int_busy <= 0;\n        int_busy <= 0;\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n        dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n    end else begin\n        if (wb_cyc_i && wb_stb_i && ~wb_ack_o) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h34: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                        int_ack <= 1;\n                        we_m_rx_bd <= 0;\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                        int_ack <= 1;\n                        we_m_tx_bd <= 0;\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h00000000;\n                    8'h20: wb_dat_o <= 32'h00000200;\n                    8'h24: wb_dat_o <= 32'h0000000f;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000;\n                    8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 3, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\nreg [15:0] int_status_reg;\nreg [15:0] err_status_reg;\nreg [7:0] soft_reset_reg;\nreg [15:0] timeout_reg;\nreg [15:0] norm_int_en_reg;\nreg [15:0] err_int_en_reg;\nreg [7:0] clk_div_reg;\nreg [7:0] bd_isr_en_reg;\nreg [RAM_MEM_WIDTH-1:0] bd_rx_reg;\nreg [RAM_MEM_WIDTH-1:0] bd_tx_reg;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h34: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1'b1;\n                        dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        int_ack <= 1'b0;\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1'b1;\n                        dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        int_ack <= 1'b0;\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 32'h00000000;\n                    8'h20: wb_dat_o <= 32'h00000200;\n                    8'h24: wb_dat_o <= 32'h0000000F;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000;\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 6, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 1, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen instantiation\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b10)\n                    next_state = READ_WAIT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                end\n                WRITE_DAT: begin\n                    // Logic for writing data\n                end\n                WRITE_CRC: begin\n                    // Logic for writing CRC\n                end\n                WRITE_BUSY: begin\n                    // Logic for write busy state\n                end\n                READ_WAIT: begin\n                    // Logic for read wait state\n                end\n                READ_DAT: begin\n                    // Logic for reading data\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 4, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Internal registers\n    reg [15:0] controller_setting_reg;\n    reg [15:0] block_size_reg;\n    reg [7:0] power_control_reg;\n    reg [15:0] capabilities_reg;\n\n    // Reset and clock logic\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers to their default values\n            argument_reg <= 32'h00000000;\n            cmd_setting_reg <= 16'h0000;\n            software_reset_reg <= 8'h00;\n            time_out_reg <= 16'h0000;\n            normal_int_signal_enable_reg <= 16'h0000;\n            error_int_signal_enable_reg <= 16'h0000;\n            clock_divider <= 8'h00;\n            Bd_isr_enable_reg <= 8'h00;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            wb_ack_o <= 1'b0;\n        end else begin\n            // Handle write operations\n            if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                    end\n                    default: ;\n                endcase\n            end\n\n            // Handle read operations\n            if (wb_stb_i && wb_cyc_i && !wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= {16'h0000, controller_setting_reg};\n                    8'h20: wb_dat_o <= {16'h0000, block_size_reg};\n                    8'h24: wb_dat_o <= {24'h000000, power_control_reg};\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= {16'h0000, capabilities_reg};\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h00000000;\n                endcase\n            end\n\n            // Acknowledge logic\n            if (wb_stb_i && wb_cyc_i && !wb_ack_o) begin\n                wb_ack_o <= 1'b1;\n            end else begin\n                wb_ack_o <= 1'b0;\n            end\n\n            // Reset ISR reset signals\n            if (normal_isr_reset) normal_isr_reset <= 1'b0;\n            if (error_isr_reset) error_isr_reset <= 1'b0;\n            if (Bd_isr_reset) Bd_isr_reset <= 1'b0;\n\n            // Reset write enable signals\n            if (we_m_rx_bd) we_m_rx_bd <= 1'b0;\n            if (we_m_tx_bd) we_m_tx_bd <= 1'b0;\n\n            // Reset int_ack\n            if (!int_ack) int_ack <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 7, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:12], CRC[11] ^ inv, CRC[10:5], CRC[4] ^ inv, CRC[3:1], inv};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 2, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter IDLE = 6'b000001;\n    parameter WRITE_DAT = 6'b000010;\n    parameter WRITE_CRC = 6'b000100;\n    parameter WRITE_BUSY = 6'b001000;\n    parameter READ_WAIT = 6'b010000;\n    parameter READ_DAT = 6'b100000;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 1'b0;\n            ack_q <= 1'b0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10) next_state = WRITE_DAT;\n                else if (start_dat == 2'b01) next_state = READ_WAIT;\n                else next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = WRITE_CRC;\n                else next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000) next_state = WRITE_BUSY;\n                else next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int) next_state = IDLE;\n                else next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0]) next_state = READ_DAT;\n                else next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = IDLE;\n                else next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT) q_start_bit <= 1'b0;\n            else q_start_bit <= 1'b1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 32'b0;\n            write_buf_1 <= 32'b0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'b0;\n            rd <= 1'b0;\n            last_din <= 4'b0;\n            crc_c <= 5'b0;\n            crc_in <= {SD_BUS_W{1'b0}};\n            DAT_dat_o <= {SD_BUS_W{1'b0}};\n            crc_status <= 3'b111;\n            crc_s <= 3'b0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            data_out <= {SD_BUS_W{1'b0}};\n            crc_ok <= 1'b0;\n            busy_int <= 1'b0;\n            data_send_index <= 3'b0;\n            out_buff_ptr <= 1'b0;\n            in_buff_ptr <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1'b1;\n                    crc_en <= 1'b0;\n                    transf_cnt <= 11'b0;\n                    rd <= 1'b0;\n                    we <= 1'b0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    crc_ok <= 1'b0;\n                end\n                WRITE_DAT: begin\n                    // Logic for WRITE_DAT state\n                end\n                WRITE_CRC: begin\n                    // Logic for WRITE_CRC state\n                end\n                WRITE_BUSY: begin\n                    // Logic for WRITE_BUSY state\n                end\n                READ_WAIT: begin\n                    // Logic for READ_WAIT state\n                end\n                READ_DAT: begin\n                    // Logic for READ_DAT state\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 5, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n// Internal registers\nreg [31:0] reg_argument;\nreg [15:0] reg_cmd_setting;\nreg [7:0] reg_software_reset;\nreg [15:0] reg_time_out;\nreg [15:0] reg_normal_int_status;\nreg [15:0] reg_error_int_status;\nreg [15:0] reg_normal_int_signal_enable;\nreg [15:0] reg_error_int_signal_enable;\nreg [7:0] reg_clock_divider;\nreg [7:0] reg_Bd_isr_enable;\n\n// Reset and clock logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        reg_argument <= 32'h00000000;\n        reg_cmd_setting <= 16'h0000;\n        reg_software_reset <= 8'h00;\n        reg_time_out <= 16'h0000;\n        reg_normal_int_status <= 16'h0000;\n        reg_error_int_status <= 16'h0000;\n        reg_normal_int_signal_enable <= 16'h0000;\n        reg_error_int_signal_enable <= 16'h0000;\n        reg_clock_divider <= 8'h00;\n        reg_Bd_isr_enable <= 8'h00;\n        wb_ack_o <= 1'b0;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n    end else begin\n        // Register write logic\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: reg_argument <= wb_dat_i;\n                8'h04: reg_cmd_setting <= wb_dat_i[15:0];\n                8'h28: reg_software_reset <= wb_dat_i[7:0];\n                8'h2C: reg_time_out <= wb_dat_i[15:0];\n                8'h30: reg_normal_int_status <= wb_dat_i[15:0];\n                8'h34: reg_error_int_status <= wb_dat_i[15:0];\n                8'h38: reg_normal_int_signal_enable <= wb_dat_i[15:0];\n                8'h3C: reg_error_int_signal_enable <= wb_dat_i[15:0];\n                8'h4C: reg_clock_divider <= wb_dat_i[7:0];\n                8'h58: reg_Bd_isr_enable <= wb_dat_i[7:0];\n                8'h60, 8'h80: begin\n                    we_m_rx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                    int_ack <= 1'b1;\n                    we_m_rx_bd <= 1'b0;\n                end\n            endcase\n            wb_ack_o <= 1'b1;\n        end else if (wb_stb_i && wb_cyc_i && !wb_we_i) begin\n            // Register read logic\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= reg_argument;\n                8'h04: wb_dat_o <= {16'h0000, reg_cmd_setting};\n                8'h08: wb_dat_o <= {16'h0000, status_reg};\n                8'h0C: wb_dat_o <= cmd_resp_1;\n                8'h1C: wb_dat_o <= 16'h0000;\n                8'h20: wb_dat_o <= 16'h0200;\n                8'h24: wb_dat_o <= 8'h0F;\n                8'h28: wb_dat_o <= {24'h000000, reg_software_reset};\n                8'h2C: wb_dat_o <= {16'h0000, reg_time_out};\n                8'h30: wb_dat_o <= {16'h0000, reg_normal_int_status};\n                8'h34: wb_dat_o <= {16'h0000, reg_error_int_status};\n                8'h38: wb_dat_o <= {16'h0000, reg_normal_int_signal_enable};\n                8'h3C: wb_dat_o <= {16'h0000, reg_error_int_signal_enable};\n                8'h48: wb_dat_o <= 16'h0000;\n                8'h4C: wb_dat_o <= {24'h000000, reg_clock_divider};\n                8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                8'h58: wb_dat_o <= {24'h000000, reg_Bd_isr_enable};\n            endcase\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 6, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\n// Internal registers\nreg [31:0] bd_rx_reg;\nreg [31:0] bd_tx_reg;\n\n// Reset and clock logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        wb_ack_o <= 1'b0;\n    end else begin\n        // Control logic\n        cmd_int_busy <= (wb_stb_i && wb_cyc_i && wb_we_i && (wb_adr_i == 8'h00 || wb_adr_i == 8'h04));\n        int_busy <= (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h04);\n        new_cmd <= (wb_stb_i && wb_cyc_i && wb_we_i && wb_adr_i == 8'h00);\n        we_ack <= write_req_s;\n\n        // Wishbone acknowledge logic\n        if (wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack) begin\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n\n        // Register write logic\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                8'h28: software_reset_reg <= wb_dat_i[7:0];\n                8'h2c: time_out_reg <= wb_dat_i[15:0];\n                8'h30: normal_isr_reset <= 1'b1;\n                8'h34: error_isr_reset <= 1'b1;\n                8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h4c: clock_divider <= wb_dat_i[7:0];\n                8'h54: Bd_isr_reset <= 1'b1;\n                8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                8'h60: begin\n                    we_m_rx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_rx_bd <= wb_dat_i[15:0];\n                        dat_in_m_rx_bd <= wb_dat_i[31:16];\n                    end\n                end\n                8'h80: begin\n                    we_m_tx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_tx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_tx_bd <= wb_dat_i[15:0];\n                        dat_in_m_tx_bd <= wb_dat_i[31:16];\n                    end\n                end\n                default: ;\n            endcase\n        end\n\n        // Register read logic\n        if (wb_stb_i && wb_cyc_i && ~wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= argument_reg;\n                8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                8'h08: wb_dat_o <= {16'h0000, status_reg};\n                8'h0c: wb_dat_o <= cmd_resp_1;\n                8'h1c: wb_dat_o <= 16'h0000;\n                8'h20: wb_dat_o <= 16'h0200;\n                8'h24: wb_dat_o <= 8'h0f;\n                8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                8'h48: wb_dat_o <= 16'h0000;\n                8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                default: wb_dat_o <= 32'h00000000;\n            endcase\n        end\n\n        // Reset acknowledge signals\n        if (wb_ack_o) begin\n            int_ack <= 1'b1;\n            we_m_rx_bd <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM State Operations\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in_int)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0)\n                                RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in_int)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0)\n                                RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg ack_in_int, req_in_int;\n    reg [1:0] req_q, ack_q;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM State Operation\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in_int) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State encoding\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg req_in_int, ack_in_int;\n    reg [1:0] req_q, ack_q;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 3, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter IDLE = 6'b000001;\n    parameter WRITE_DAT = 6'b000010;\n    parameter WRITE_CRC = 6'b000100;\n    parameter WRITE_BUSY = 6'b001000;\n    parameter READ_WAIT = 6'b010000;\n    parameter READ_DAT = 6'b100000;\n\n    // CRC_16_gen\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 1'b0;\n            ack_q <= 1'b0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10) begin\n                    next_state = WRITE_DAT;\n                end else if (start_dat == 2'b01) begin\n                    next_state = READ_WAIT;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = WRITE_CRC;\n                end else begin\n                    next_state = WRITE_DAT;\n                end\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000) begin\n                    next_state = WRITE_BUSY;\n                end else begin\n                    next_state = WRITE_CRC;\n                end\n            end\n            WRITE_BUSY: begin\n                if (!busy_int) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = WRITE_BUSY;\n                end\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 1'b0) begin\n                    next_state = READ_DAT;\n                end else begin\n                    next_state = READ_WAIT;\n                end\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = READ_DAT;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else if (!DAT_dat_i[0] && state == READ_WAIT) begin\n            q_start_bit <= 1'b0;\n        end else begin\n            q_start_bit <= 1'b1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 32'b0;\n            write_buf_1 <= 32'b0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'b0;\n            rd <= 1'b0;\n            last_din <= 4'b0;\n            crc_c <= 5'b0;\n            crc_in <= {SD_BUS_W{1'b0}};\n            DAT_dat_o <= {SD_BUS_W{1'b0}};\n            crc_status <= 3'b111;\n            crc_s <= 3'b0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            data_out <= {SD_BUS_W{1'b0}};\n            crc_ok <= 1'b0;\n            busy_int <= 1'b0;\n            data_send_index <= 3'b0;\n            out_buff_ptr <= 1'b0;\n            in_buff_ptr <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1'b1;\n                    crc_en <= 1'b0;\n                    transf_cnt <= 11'b0;\n                    rd <= 1'b0;\n                    we <= 1'b0;\n                    busy_n <= 1'b1;\n                    transm_complete <= 1'b0;\n                end\n                WRITE_DAT: begin\n                    // Write data logic\n                end\n                WRITE_CRC: begin\n                    // Write CRC logic\n                end\n                WRITE_BUSY: begin\n                    // Write busy logic\n                end\n                READ_WAIT: begin\n                    // Read wait logic\n                end\n                READ_DAT: begin\n                    // Read data logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg complete, index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in_int)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (dat_ava) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 0)\n                                RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001;\n    localparam SETUP = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b00;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b00;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Operation\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0;\n\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CMD_SET_REG[3];\n                    settings[6:0] <= response_size;\n\n                    Watchdog_Cnt <= 16'b0;\n                end\n\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in_int)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            NORMAL_INT_REG[0] <= 1'b1;\n\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0;\n\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CMD_SET_REG[3];\n                    settings[6:0] <= response_size;\n\n                    Watchdog_Cnt <= 16'b0;\n                    STATUS_REG[0] <= 1'b1;\n                end\n\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in_int)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            NORMAL_INT_REG[0] <= 1'b1;\n\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 4, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter IDLE = 6'd0, WRITE_DAT = 6'd1, WRITE_CRC = 6'd2, WRITE_BUSY = 6'd3, READ_WAIT = 6'd4, READ_DAT = 6'd5;\n\n    // CRC_16_gen submodule instantiation\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 1'b0;\n            ack_q <= 1'b0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO block\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b10)\n                    next_state = READ_WAIT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else if (!DAT_dat_i[0] && state == READ_WAIT) begin\n            q_start_bit <= 1'b0;\n        end else begin\n            q_start_bit <= 1'b1;\n        end\n    end\n\n    // FSM_SEQ block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 32'b0;\n            write_buf_1 <= 32'b0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'b0;\n            rd <= 1'b0;\n            last_din <= 4'b0;\n            crc_c <= 5'b0;\n            crc_in <= {SD_BUS_W{1'b0}};\n            DAT_dat_o <= {SD_BUS_W{1'b0}};\n            crc_status <= 3'b111;\n            crc_s <= 3'b0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            data_out <= {SD_BUS_W{1'b0}};\n            crc_ok <= 1'b0;\n            busy_int <= 1'b0;\n            data_send_index <= 3'b0;\n            out_buff_ptr <= 1'b0;\n            in_buff_ptr <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1'b1;\n                    crc_en <= 1'b0;\n                    transf_cnt <= 11'b0;\n                    rd <= 1'b0;\n                    we <= 1'b0;\n                    busy_n <= 1'b1;\n                    transm_complete <= 1'b0;\n                    crc_ok <= 1'b0;\n                end\n                WRITE_DAT: begin\n                    // Logic for writing data\n                end\n                WRITE_CRC: begin\n                    // Logic for CRC generation\n                end\n                WRITE_BUSY: begin\n                    // Logic for handling busy state\n                end\n                READ_WAIT: begin\n                    // Logic for preparing read\n                end\n                READ_DAT: begin\n                    // Logic for reading data\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Transitions\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM State Operations\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done;\n    reg rec_done;\n    reg rec_failed;\n    reg tx_cycle;\n    reg rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done;\n    reg trans_failed;\n    reg internal_transm_complete;\n    reg transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end else begin\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_tx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_tx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    end else begin\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_rx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_rx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0]) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done;\n    reg rec_done;\n    reg rec_failed;\n    reg tx_cycle;\n    reg rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg trans_done;\n    reg trans_failed;\n    reg internal_transm_complete;\n    reg transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                        cmd_set <= CMD24;\n                        tx_cycle <= 1;\n                    end\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                        case (transfer_type)\n                            2'b00: cmd_set <= CMD17;\n                            2'b01: cmd_set <= ACMD13;\n                            default: cmd_set <= ACMD51;\n                        endcase\n                        rx_cycle <= 1;\n                    end\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) begin\n                            rec_failed <= 1;\n                        end else if (card_status[0] || (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else if (rx_cycle) begin\n                            a_cmp_rx <= 1;\n                        end\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 0;\n                    d_write <= 0;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ: Sequential logic for state transitions\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO: Combinational logic for next state determination\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY)\n                    next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY)\n                    next_state = GET_RX_BD;\n                else\n                    next_state = IDLE;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full)\n                    next_state = SEND_CMD;\n                else\n                    next_state = GET_TX_BD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1)\n                    next_state = SEND_CMD;\n                else\n                    next_state = GET_RX_BD;\n            end\n            SEND_CMD: begin\n                if (send_done)\n                    next_state = RECIVE_CMD;\n                else\n                    next_state = SEND_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done)\n                    next_state = DATA_TRANSFER;\n                else if (rec_failed)\n                    next_state = SEND_CMD;\n                else\n                    next_state = RECIVE_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done)\n                    next_state = IDLE;\n                else if (trans_failed)\n                    next_state = STOP;\n                else\n                    next_state = DATA_TRANSFER;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done)\n                    next_state = IDLE;\n                else\n                    next_state = STOP_SEND;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM_OUT: Output logic based on current state\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                            else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                            else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                            else if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                            else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    else if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) rec_failed <= 1;\n                        else if (card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) rec_done <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && tx_empt) trans_failed <= 1;\n                    else if (rx_cycle && rx_full) trans_failed <= 1;\n                    if (transm_complete) begin\n                        if (crc_ok) trans_done <= 1;\n                        else trans_failed <= 1;\n                    end\n                    if (trans_done || trans_failed) begin\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        else if (rx_cycle) a_cmp_rx <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    resend_try_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                            else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                            else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                            else if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                            else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    else if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) rec_failed <= 1;\n                        else if (card_status[0] == 1 || (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) rec_done <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && tx_empt) trans_failed <= 1;\n                    else if (rx_cycle && rx_full) trans_failed <= 1;\n                    if (transm_complete) begin\n                        if (crc_ok) trans_done <= 1;\n                        else trans_failed <= 1;\n                    end\n                    if (trans_done || trans_failed) begin\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        else if (rx_cycle) a_cmp_rx <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt == RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 4, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        wire inv = BITVAL ^ CRC[6];\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    CIDAT <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                        ack_transfer <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 18, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Specific backend version logic for ACTEL\n    wire SD_CLK_INT;\n    assign SD_CLK_INT = SD_CLK_O;\n    assign SD_CLK = SD_CLK_INT;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 5, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 6, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 7, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            wire inv = BITVAL ^ CRC[6];\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 8, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            wire inv = BITVAL ^ CRC[6];\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 8, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM Outputs\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                            else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                            else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                            else if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                            else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    else if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) rec_failed <= 1;\n                        else if (card_status[0] == 1 || card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6) rec_done <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) trans_done <= 1;\n                    else if (rx_cycle && !rx_full) trans_done <= 1;\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        else if (rx_cycle) a_cmp_rx <= 1;\n                    end else if (!crc_ok) trans_failed <= 1;\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY)\n                    next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY)\n                    next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1)\n                    next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1)\n                    next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done)\n                    next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done)\n                    next_state = DATA_TRANSFER;\n                else if (rec_failed)\n                    next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done)\n                    next_state = IDLE;\n                else if (trans_failed)\n                    next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0)\n                                sys_adr <= dat_in_tx;\n                            else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0)\n                                sys_adr[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 1)\n                                sys_adr[31:16] <= dat_in_tx;\n                            else if (bd_cnt == 2)\n                                cmd_arg[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0)\n                                sys_adr <= dat_in_rx;\n                            else if (bd_cnt == 1)\n                                cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0)\n                                sys_adr[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 1)\n                                sys_adr[31:16] <= dat_in_rx;\n                            else if (bd_cnt == 2)\n                                cmd_arg[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 3)\n                                cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    if (transfer_type == 2'b00)\n                        cmd_set <= CMD17;\n                    else if (transfer_type == 2'b01)\n                        cmd_set <= ACMD13;\n                    else\n                        cmd_set <= ACMD51;\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle)\n                        d_write <= 1;\n                    else\n                        d_read <= 1;\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                            we_req <= 0;\n                        end\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle)\n                        start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt)\n                        trans_done <= 1;\n                    else if (rx_cycle && !rx_full)\n                        trans_done <= 1;\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT)\n                        Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                            we_req <= 0;\n                        end\n                    end\n                end\n            endcase\n            if (Dat_Int_Status_rst)\n                Dat_Int_Status <= 0;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 7, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\n// Internal registers\nreg [31:0] argument_reg_int;\nreg [15:0] cmd_setting_reg_int;\nreg [7:0] software_reset_reg_int;\nreg [15:0] time_out_reg_int;\nreg [15:0] normal_int_signal_enable_reg_int;\nreg [15:0] error_int_signal_enable_reg_int;\nreg [7:0] clock_divider_int;\nreg [7:0] Bd_isr_enable_reg_int;\n\n// Reset logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        argument_reg_int <= 32'h00000000;\n        cmd_setting_reg_int <= 16'h0000;\n        software_reset_reg_int <= 8'h00;\n        time_out_reg_int <= 16'h0000;\n        normal_int_signal_enable_reg_int <= 16'h0000;\n        error_int_signal_enable_reg_int <= 16'h0000;\n        clock_divider_int <= 8'h00;\n        Bd_isr_enable_reg_int <= 8'h00;\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end else begin\n        // Wishbone write operation\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg_int <= wb_dat_i;\n                8'h04: cmd_setting_reg_int <= wb_dat_i[15:0];\n                8'h28: software_reset_reg_int <= wb_dat_i[7:0];\n                8'h2C: time_out_reg_int <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg_int <= wb_dat_i[15:0];\n                8'h3C: error_int_signal_enable_reg_int <= wb_dat_i[15:0];\n                8'h4C: clock_divider_int <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg_int <= wb_dat_i[7:0];\n                8'h60: begin\n                    we_m_rx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                    int_ack <= 1'b1;\n                    we_m_rx_bd <= 1'b0;\n                end\n                8'h80: begin\n                    we_m_tx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_tx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                    int_ack <= 1'b1;\n                    we_m_tx_bd <= 1'b0;\n                end\n                default: ;\n            endcase\n            wb_ack_o <= 1'b1;\n        end else if (wb_stb_i && wb_cyc_i && !wb_we_i) begin\n            // Wishbone read operation\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= argument_reg_int;\n                8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg_int};\n                8'h08: wb_dat_o <= {16'h0000, status_reg};\n                8'h0C: wb_dat_o <= cmd_resp_1;\n                8'h1C: wb_dat_o <= 16'h0000; // Controller Setting\n                8'h20: wb_dat_o <= 16'h0200; // Block Size\n                8'h24: wb_dat_o <= 8'h0F; // Power Control\n                8'h28: wb_dat_o <= {24'h000000, software_reset_reg_int};\n                8'h2C: wb_dat_o <= {16'h0000, time_out_reg_int};\n                8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg_int};\n                8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg_int};\n                8'h48: wb_dat_o <= 16'h0000; // Capability\n                8'h4C: wb_dat_o <= {24'h000000, clock_divider_int};\n                8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg_int};\n                default: wb_dat_o <= 32'h00000000;\n            endcase\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n\n        // Control logic\n        if (write_req_s) begin\n            we_ack <= 1'b1;\n        end else begin\n            we_ack <= 1'b0;\n        end\n\n        if (cmd_set_s != 16'h0000 || cmd_arg_s != 32'h00000000) begin\n            cmd_int_busy <= 1'b1;\n            int_busy <= 1'b1;\n            new_cmd <= 1'b1;\n        end else begin\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            new_cmd <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 9, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n// Internal wire for inversion calculation\nwire inv;\n\n// Calculate the inversion bit\nassign inv = BITVAL ^ CRC[15];\n\n// Sequential logic for CRC calculation\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Reset CRC to zero\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        // Update CRC based on input bit and current CRC value\n        CRC <= {CRC[14:0], 1'b0}; // Shift left\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[5] <= CRC[4] ^ inv;\n        CRC[0] <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 9, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        wire inv = BITVAL ^ CRC[6];\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b00;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b00;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Operation\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_counter;\n    reg [BD_WIDTH-1:0] read_counter;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    wire new_bw;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_counter <= write_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_counter == 1) || (RAM_MEM_WIDTH == 16 && write_counter == 3)) begin\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_counter <= read_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && read_counter == 1) || (RAM_MEM_WIDTH == 16 && read_counter == 3)) begin\n                    ack_o_s <= 1;\n                    read_counter <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 10, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            wire inv = BITVAL ^ CRC[6];\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 10, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM states\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode command settings\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39];\n                            In_Buff <= {In_Buff[38:0], 1'b0};\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39];\n                            In_Buff <= {In_Buff[38:0], 1'b0};\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff <= {Out_Buff[38:0], cmd_dat_i};\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= {CRC_IN[5:0], cmd_dat_i};\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write ? 2'b01 : 2'b00);\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            we <= 9'd0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            first <= 1'b1;\n        end else begin\n            reset_tx_fifo <= 1'b0;\n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + {23'd0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cti_o <= 3'b000;\n                    m_wb_bte_o <= 2'b00;\n                end\n\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    offset <= offset + 9'd1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'd0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done;\n    reg rec_done;\n    reg rec_failed;\n    reg tx_cycle;\n    reg rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state;\n    reg [8:0] next_state;\n    reg trans_done;\n    reg trans_failed;\n    reg internal_transm_complete;\n    reg transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end else begin\n                    next_state = GET_TX_BD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end else begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state = RECIVE_CMD;\n                end else begin\n                    next_state = SEND_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state = SEND_CMD;\n                end else begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state = IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state = STOP;\n                end else begin\n                    next_state = DATA_TRANSFER;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = STOP_SEND;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] == 1 && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        a_cmp_tx <= 1;\n                        a_cmp_rx <= 1;\n                        ack_transfer <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                default: begin\n                    // Default case to handle unexpected states\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 11, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:12], CRC[11] ^ inv, CRC[10:5], CRC[4] ^ inv, CRC[3:1], inv};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full, fifo_empty;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 12, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    // Calculate the inversion bit\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational Logic for Next State\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential Logic for State Update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Output Logic Based on FSM State\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39];\n                            In_Buff <= {In_Buff[38:0], 1'b0};\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39];\n                            In_Buff <= {In_Buff[38:0], 1'b0};\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff <= {Out_Buff[38:0], cmd_dat_i};\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= {CRC_IN[5:0], cmd_dat_i};\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write) ? 2'b01 : 2'b00;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 5, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen submodule instantiation\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO block\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b10)\n                    next_state = READ_WAIT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0)\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                    crc_ok <= 0;\n                end\n                WRITE_DAT: begin\n                    // Logic for WRITE_DAT state\n                end\n                WRITE_CRC: begin\n                    // Logic for WRITE_CRC state\n                end\n                WRITE_BUSY: begin\n                    // Logic for WRITE_BUSY state\n                end\n                READ_WAIT: begin\n                    // Logic for READ_WAIT state\n                end\n                READ_DAT: begin\n                    // Logic for READ_DAT state\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_counter;\n    reg [BD_WIDTH-1:0] read_counter;\n    reg last_a_cmp;\n    reg new_bw;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_counter <= write_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_counter == 1) || \n                    (RAM_MEM_WIDTH == 16 && write_counter == 3)) begin\n                    new_bw <= 1;\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_counter <= read_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && read_counter == 1) || \n                    (RAM_MEM_WIDTH == 16 && read_counter == 3)) begin\n                    ack_o_s <= 1;\n                    read_counter <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n\n            // Circular Operation\n            if (m_wr_pnt == BD_SIZE) begin\n                m_wr_pnt <= 0;\n            end\n            if (s_rd_pnt == BD_SIZE) begin\n                s_rd_pnt <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 8, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register addresses\n    localparam ARGUMENT_ADDR = 8'h00;\n    localparam CMD_SETTING_ADDR = 8'h04;\n    localparam STATUS_ADDR = 8'h08;\n    localparam RESPONSE_ADDR = 8'h0C;\n    localparam SOFTWARE_RESET_ADDR = 8'h28;\n    localparam TIMEOUT_ADDR = 8'h2C;\n    localparam NORMAL_INT_STATUS_ADDR = 8'h30;\n    localparam ERROR_INT_STATUS_ADDR = 8'h34;\n    localparam NORMAL_INT_ENABLE_ADDR = 8'h38;\n    localparam ERROR_INT_ENABLE_ADDR = 8'h3C;\n    localparam CLOCK_DIVIDER_ADDR = 8'h4C;\n    localparam BD_STATUS_ADDR = 8'h50;\n    localparam BD_ISR_ADDR = 8'h54;\n    localparam BD_ISR_ENABLE_ADDR = 8'h58;\n    localparam BD_RX_ADDR = 8'h60;\n    localparam BD_TX_ADDR = 8'h80;\n\n    // Internal signals\n    reg [31:0] reg_file [0:255]; // Register file for storing configuration registers\n\n    // Reset logic\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers to their default values\n            argument_reg <= 32'h00000000;\n            cmd_setting_reg <= 16'h0000;\n            software_reset_reg <= 8'h00;\n            time_out_reg <= 16'h0000;\n            normal_int_signal_enable_reg <= 16'h0000;\n            error_int_signal_enable_reg <= 16'h0000;\n            clock_divider <= 8'h00;\n            Bd_isr_enable_reg <= 8'h00;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            int_ack <= 1'b1;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            wb_ack_o <= 1'b0;\n        end else begin\n            // Register write logic\n            if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n                case (wb_adr_i)\n                    ARGUMENT_ADDR: begin\n                        argument_reg <= wb_dat_i;\n                        new_cmd <= 1'b1;\n                    end\n                    CMD_SETTING_ADDR: begin\n                        cmd_setting_reg <= wb_dat_i[15:0];\n                        cmd_int_busy <= 1'b1;\n                    end\n                    SOFTWARE_RESET_ADDR: begin\n                        software_reset_reg <= wb_dat_i[7:0];\n                    end\n                    TIMEOUT_ADDR: begin\n                        time_out_reg <= wb_dat_i[15:0];\n                    end\n                    NORMAL_INT_ENABLE_ADDR: begin\n                        normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    ERROR_INT_ENABLE_ADDR: begin\n                        error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    CLOCK_DIVIDER_ADDR: begin\n                        clock_divider <= wb_dat_i[7:0];\n                    end\n                    BD_ISR_ENABLE_ADDR: begin\n                        Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    end\n                    BD_RX_ADDR: begin\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                    end\n                    BD_TX_ADDR: begin\n                        we_m_tx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                    end\n                    default: ;\n                endcase\n            end\n\n            // Register read logic\n            if (wb_stb_i && wb_cyc_i && ~wb_we_i) begin\n                case (wb_adr_i)\n                    ARGUMENT_ADDR: wb_dat_o <= argument_reg;\n                    CMD_SETTING_ADDR: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    STATUS_ADDR: wb_dat_o <= {16'h0000, status_reg};\n                    RESPONSE_ADDR: wb_dat_o <= cmd_resp_1;\n                    SOFTWARE_RESET_ADDR: wb_dat_o <= {24'h000000, software_reset_reg};\n                    TIMEOUT_ADDR: wb_dat_o <= {16'h0000, time_out_reg};\n                    NORMAL_INT_STATUS_ADDR: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    ERROR_INT_STATUS_ADDR: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    NORMAL_INT_ENABLE_ADDR: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    ERROR_INT_ENABLE_ADDR: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    CLOCK_DIVIDER_ADDR: wb_dat_o <= {24'h000000, clock_divider};\n                    BD_STATUS_ADDR: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    BD_ISR_ADDR: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    BD_ISR_ENABLE_ADDR: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h00000000;\n                endcase\n            end\n\n            // Acknowledge logic\n            if (wb_stb_i && wb_cyc_i) begin\n                wb_ack_o <= 1'b1;\n            end else begin\n                wb_ack_o <= 1'b0;\n            end\n\n            // Control logic\n            if (write_req_s) begin\n                we_ack <= 1'b1;\n            end else begin\n                we_ack <= 1'b0;\n            end\n\n            if (cmd_int_busy) begin\n                int_busy <= 1'b1;\n            end else begin\n                int_busy <= 1'b0;\n            end\n\n            if (we_m_rx_bd || we_m_tx_bd) begin\n                int_ack <= 1'b0;\n            end else begin\n                int_ack <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 11, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        wire inv = BITVAL ^ CRC[6];\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 9, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\nreg [15:0] int_status_reg;\nreg [15:0] err_status_reg;\nreg [7:0] bd_isr_reg;\nreg [7:0] bd_isr_enable_reg;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        int_ack <= 1'b1;\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h54: bd_isr_reg <= wb_dat_i[7:0];\n                    8'h58: bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60, 8'h80: begin\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                        int_ack <= 1'b1;\n                        we_m_rx_bd <= 1'b0;\n                    end\n                endcase\n                wb_ack_o <= 1'b1;\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 32'h00000000;\n                    8'h20: wb_dat_o <= 32'h00000200;\n                    8'h24: wb_dat_o <= 32'h0000000F;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000;\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM states\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Ack_internal_in <= 0;\n            q1 <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs based on FSM state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write ? 2'b01 : 2'b00);\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC module instantiation\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 12, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            wire inv = BITVAL ^ CRC[6];\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 10, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [15:0] controller_setting_reg;\nreg [15:0] block_size_reg;\nreg [7:0] power_control_reg;\nreg [15:0] capabilities_reg;\n\n// Internal signals\nreg [31:0] bd_rx_reg;\nreg [31:0] bd_tx_reg;\nreg [15:0] normal_int_status_reg_internal;\nreg [15:0] error_int_status_reg_internal;\nreg [7:0] data_int_status_reg;\nreg [7:0] data_int_enable_reg;\n\n// Reset and clock logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 0;\n        we_m_tx_bd <= 0;\n        we_m_rx_bd <= 0;\n        new_cmd <= 0;\n        we_ack <= 0;\n        int_ack <= 1;\n        cmd_int_busy <= 0;\n        int_busy <= 0;\n        argument_reg <= 0;\n        cmd_setting_reg <= 0;\n        software_reset_reg <= 0;\n        time_out_reg <= 0;\n        normal_int_signal_enable_reg <= 0;\n        error_int_signal_enable_reg <= 0;\n        clock_divider <= 0;\n        Bd_isr_enable_reg <= 0;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n        dat_in_m_tx_bd <= 0;\n        dat_in_m_rx_bd <= 0;\n        controller_setting_reg <= 0;\n        block_size_reg <= 16'h0200;\n        power_control_reg <= 8'h0F;\n        capabilities_reg <= 0;\n        bd_rx_reg <= 0;\n        bd_tx_reg <= 0;\n        normal_int_status_reg_internal <= 0;\n        error_int_status_reg_internal <= 0;\n        data_int_status_reg <= 0;\n        data_int_enable_reg <= 0;\n    end else begin\n        // Control logic\n        if (wb_stb_i && wb_cyc_i) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_int_status_reg_internal <= wb_dat_i[15:0];\n                    8'h34: error_int_status_reg_internal <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h54: data_int_status_reg <= wb_dat_i[7:0];\n                    8'h58: data_int_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'b0, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= {16'b0, controller_setting_reg};\n                    8'h20: wb_dat_o <= {16'b0, block_size_reg};\n                    8'h24: wb_dat_o <= {24'b0, power_control_reg};\n                    8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'b0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= {16'b0, capabilities_reg};\n                    8'h4C: wb_dat_o <= {24'b0, clock_divider};\n                    8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n        end\n\n        // Additional control logic\n        if (write_req_s) begin\n            we_ack <= 1;\n        end else begin\n            we_ack <= 0;\n        end\n\n        if (cmd_set_s != 0 || cmd_arg_s != 0) begin\n            cmd_int_busy <= 1;\n        end else begin\n            cmd_int_busy <= 0;\n        end\n\n        if (wb_adr_i == 8'h04) begin\n            int_busy <= 1;\n        end else begin\n            int_busy <= 0;\n        end\n\n        if (wb_adr_i == 8'h00) begin\n            new_cmd <= 1;\n        end else begin\n            new_cmd <= 0;\n        end\n\n        if (we_m_rx_bd || we_m_tx_bd) begin\n            int_ack <= 0;\n        end else begin\n            int_ack <= 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 13, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            wire inv = BITVAL ^ CRC[6];\n            CRC[6:1] <= CRC[5:0];\n            CRC[0] <= inv;\n            CRC[3] <= CRC[2] ^ inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 14, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            wire inv = BITVAL ^ CRC[6];\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 11, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:15];\nreg [1:0] bd_write_state;\nreg [RAM_MEM_WIDTH-1:0] bd_data_temp;\n\nlocalparam BD_IDLE = 2'b00;\nlocalparam BD_WRITE_LOWER = 2'b01;\nlocalparam BD_WRITE_UPPER = 2'b10;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        bd_write_state <= BD_IDLE;\n    end else begin\n        if (wb_stb_i && wb_cyc_i) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60, 8'h80: begin\n                        case (bd_write_state)\n                            BD_IDLE: begin\n                                we_m_rx_bd <= (wb_adr_i == 8'h60);\n                                we_m_tx_bd <= (wb_adr_i == 8'h80);\n                                bd_data_temp <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                                bd_write_state <= (RAM_MEM_WIDTH == 16) ? BD_WRITE_LOWER : BD_IDLE;\n                                int_ack <= 1'b0;\n                            end\n                            BD_WRITE_LOWER: begin\n                                bd_data_temp <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                                bd_write_state <= BD_WRITE_UPPER;\n                            end\n                            BD_WRITE_UPPER: begin\n                                bd_write_state <= BD_IDLE;\n                                int_ack <= 1'b1;\n                                we_m_rx_bd <= 1'b0;\n                                we_m_tx_bd <= 1'b0;\n                            end\n                        endcase\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 32'h00000000;\n                    8'h20: wb_dat_o <= 32'h00000200;\n                    8'h24: wb_dat_o <= 32'h0000000F;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000;\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= ~wb_ack_o;\n        end else begin\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            Bd_isr_reset <= 1'b0;\n        end\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (write_req_s) begin\n        we_ack <= 1'b1;\n    end else begin\n        we_ack <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s != 16'h0000 || cmd_arg_s != 32'h00000000) begin\n        new_cmd <= 1'b1;\n    end else begin\n        new_cmd <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s != 16'h0000) begin\n        cmd_int_busy <= 1'b1;\n    end else begin\n        cmd_int_busy <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && wb_adr_i == 8'h04) begin\n        int_busy <= 1'b1;\n    end else begin\n        int_busy <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 15, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Acknowledge Signal Synchronization\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // Request Signal Synchronization\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n        end\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Operation\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in_int)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0)\n                                RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State encoding\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State transitions\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM State operation\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            ERR_INT_REG[1] <= 1'b0;\n            NORMAL_INT_REG[15] <= 1'b0;\n            NORMAL_INT_REG[0] <= 1'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0;\n\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n\n                    Watchdog_Cnt <= 16'b0;\n                end\n\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n\n                        if (dat_ava) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            NORMAL_INT_REG[0] <= 1'b1;\n\n                            if (response_size != 7'b0)\n                                RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_count;\n    reg [BD_WIDTH-1:0] read_count;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    wire new_bw;\n    wire a_cmp_rising_edge;\n\n    assign new_bw = (RAM_MEM_WIDTH == 32) ? (write_count == 2) : (write_count == 4);\n    assign a_cmp_rising_edge = a_cmp && !last_a_cmp;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            last_a_cmp <= 0;\n            ack_o_s <= 0;\n        end else begin\n            last_a_cmp <= a_cmp;\n\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n                write_count <= write_count + 1;\n                if (new_bw) begin\n                    free_bd <= free_bd - 1;\n                    write_count <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n                read_count <= read_count + 1;\n                if (RAM_MEM_WIDTH == 16) begin\n                    ack_o_s <= 1;\n                end\n                if ((RAM_MEM_WIDTH == 32 && read_count == 1) || (RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                    read_count <= 0;\n                end\n            end else begin\n                ack_o_s <= 0;\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp_rising_edge) begin\n                free_bd <= free_bd + 1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_Enable, CRC_OUT, CRC_Check_On, Crc_Buffering, CRC_Valid;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state, next_state;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in;\n    reg q1, Ack_internal_in;\n\n    // FSM_COMBO: Combinational Logic for Next State\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential Logic for State Update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Ack_internal_in <= 0;\n            q1 <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage Outputs and Internal Counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) CRC_OUT <= CRC_VAL[Cmd_Cnt - 10];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                        if (Cmd_Cnt > 9) CRC_OUT <= CRC_VAL[Cmd_Cnt - 10];\n                        st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[Cmd_Cnt - Response_Size] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: FSM_ACK <= 1;\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_count;\n    reg [BD_WIDTH-1:0] read_count;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    wire new_bw;\n    assign new_bw = (RAM_MEM_WIDTH == 32) ? (write_count == 2) : (write_count == 4);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            ack_o_s <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_count <= write_count + 1;\n                if (new_bw) begin\n                    free_bd <= free_bd - 1;\n                    write_count <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_count <= read_count + 1;\n                if (RAM_MEM_WIDTH == 16) begin\n                    ack_o_s <= 1;\n                end\n                if ((RAM_MEM_WIDTH == 32 && read_count == 1) || (RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                    read_count <= 0;\n                end\n            end else begin\n                ack_o_s <= 0;\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 12, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:15];\nreg [15:0] reg_file_16 [0:15];\nreg [7:0] reg_file_8 [0:15];\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg <= 32'h0000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h34: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60, 8'h80: begin\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                        int_ack <= 1'b1;\n                        we_m_rx_bd <= 1'b0;\n                    end\n                endcase\n                wb_ack_o <= 1'b1;\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0000;\n                    8'h20: wb_dat_o <= 32'h0200;\n                    8'h24: wb_dat_o <= 32'h000f;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0000;\n                    8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (write_req_s) begin\n        we_ack <= 1'b1;\n    end else begin\n        we_ack <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s != 16'h0000 || cmd_arg_s != 32'h0000) begin\n        new_cmd <= 1'b1;\n    end else begin\n        new_cmd <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done;\n    reg rec_done;\n    reg rec_failed;\n    reg tx_cycle;\n    reg rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state;\n    reg [8:0] next_state;\n    reg trans_done;\n    reg trans_failed;\n    reg internal_transm_complete;\n    reg transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end else begin\n                    next_state = GET_TX_BD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end else begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state = RECIVE_CMD;\n                end else begin\n                    next_state = SEND_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state = SEND_CMD;\n                end else begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state = IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state = STOP;\n                end else begin\n                    next_state = DATA_TRANSFER;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = STOP_SEND;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state = IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end else begin\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_tx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_tx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    end else begin\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_rx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_rx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) begin\n                            rec_failed <= 1;\n                        end else if (card_status[0] == 1 || card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6) begin\n                            rec_done <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                        ack_transfer <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt == RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg req_in_int, ack_in_int;\n    reg [1:0] req_q, ack_q;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 2'b00;\n            ack_in_int <= 1'b0;\n            req_q <= 2'b00;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            ERR_INT_REG[1] <= 1'b0;\n            NORMAL_INT_REG[15] <= 1'b0;\n            NORMAL_INT_REG[0] <= 1'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                    STATUS_REG[0] <= 1'b1;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n        end\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Operation\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0;\n\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CMD_SET_REG[3];\n                    settings[6:0] <= response_size;\n\n                    Watchdog_Cnt <= 16'b0;\n                end\n\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in_int)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            NORMAL_INT_REG[0] <= 1'b1;\n\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 13, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\n// Internal registers\nreg [31:0] reg_file [0:15];\nreg [15:0] reg_file_16 [0:15];\nreg [7:0] reg_file_8 [0:15];\n\n// Reset and Clock\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n    end else begin\n        // Register Write\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                8'h28: software_reset_reg <= wb_dat_i[7:0];\n                8'h2c: time_out_reg <= wb_dat_i[15:0];\n                8'h30: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h34: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h4c: clock_divider <= wb_dat_i[7:0];\n                8'h54: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                8'h60: begin\n                    we_m_rx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                    int_ack <= 1'b1;\n                    we_m_rx_bd <= 1'b0;\n                end\n                8'h80: begin\n                    we_m_tx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_tx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                    int_ack <= 1'b1;\n                    we_m_tx_bd <= 1'b0;\n                end\n                default: ;\n            endcase\n            wb_ack_o <= 1'b1;\n        end else if (wb_stb_i && wb_cyc_i) begin\n            // Register Read\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= argument_reg;\n                8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                8'h08: wb_dat_o <= {16'h0000, status_reg};\n                8'h0c: wb_dat_o <= cmd_resp_1;\n                8'h1c: wb_dat_o <= 32'h00000000; // Controller Setting\n                8'h20: wb_dat_o <= 32'h00000200; // Block Size\n                8'h24: wb_dat_o <= 32'h0000000f; // Power Control\n                8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                8'h48: wb_dat_o <= 32'h00000000; // Capability\n                8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                default: wb_dat_o <= 32'h00000000;\n            endcase\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n\n        // Control Logic\n        cmd_int_busy <= (wb_adr_i == 8'h00 || wb_adr_i == 8'h04) && wb_stb_i && wb_cyc_i;\n        int_busy <= (wb_adr_i == 8'h00) && wb_stb_i && wb_cyc_i;\n        new_cmd <= (wb_adr_i == 8'h00) && wb_stb_i && wb_cyc_i;\n        we_ack <= write_req_s;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done;\n    reg rec_done;\n    reg rec_failed;\n    reg tx_cycle;\n    reg rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg trans_done;\n    reg trans_failed;\n    reg internal_transm_complete;\n    reg transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0]) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        if (transm_complete && crc_ok) begin\n                            trans_done <= 1;\n                            a_cmp_tx <= 1;\n                        end\n                    end else if (rx_cycle && !rx_full) begin\n                        if (transm_complete && crc_ok) begin\n                            trans_done <= 1;\n                            a_cmp_rx <= 1;\n                        end\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM states\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational logic for next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential logic for state update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs based on FSM state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_inst (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) CRC_OUT <= CRC_VAL[6];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write ? 2'b01 : 2'b00);\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                        if (Cmd_Cnt > 9) CRC_OUT <= CRC_VAL[6];\n                        if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write ? 2'b01 : 2'b00);\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[Cmd_Cnt - Response_Size] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write ? 2'b01 : 2'b00);\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_inst (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 6, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen submodule instantiation\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 1'b0;\n            ack_q <= 1'b0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'b000000: begin // IDLE\n                if (start_dat == 2'b10) next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b01) next_state = 6'b000100; // READ_WAIT\n                else next_state = 6'b000000; // IDLE\n            end\n            6'b000001: begin // WRITE_DAT\n                if (transf_cnt == BIT_BLOCK) next_state = 6'b000010; // WRITE_CRC\n                else next_state = 6'b000001; // WRITE_DAT\n            end\n            6'b000010: begin // WRITE_CRC\n                if (crc_status == 3'b000) next_state = 6'b000011; // WRITE_BUSY\n                else next_state = 6'b000010; // WRITE_CRC\n            end\n            6'b000011: begin // WRITE_BUSY\n                if (!busy_int) next_state = 6'b000000; // IDLE\n                else next_state = 6'b000011; // WRITE_BUSY\n            end\n            6'b000100: begin // READ_WAIT\n                if (!DAT_dat_i[0]) next_state = 6'b000101; // READ_DAT\n                else next_state = 6'b000100; // READ_WAIT\n            end\n            6'b000101: begin // READ_DAT\n                if (transf_cnt == BIT_BLOCK_REC) next_state = 6'b000000; // IDLE\n                else next_state = 6'b000101; // READ_DAT\n            end\n            default: next_state = 6'b000000; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else begin\n            if (!DAT_dat_i[0] && state == 6'b000100) q_start_bit <= 1'b0;\n            else q_start_bit <= 1'b1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 32'b0;\n            write_buf_1 <= 32'b0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'b0;\n            rd <= 1'b0;\n            last_din <= 4'b0;\n            crc_c <= 5'b0;\n            crc_in <= {SD_BUS_W{1'b0}};\n            DAT_dat_o <= {SD_BUS_W{1'b0}};\n            crc_status <= 3'b111;\n            crc_s <= 3'b0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            data_out <= {SD_BUS_W{1'b0}};\n            crc_ok <= 1'b0;\n            busy_int <= 1'b0;\n            data_send_index <= 3'b0;\n            out_buff_ptr <= 1'b0;\n            in_buff_ptr <= 1'b0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1'b1;\n                    crc_en <= 1'b0;\n                    transf_cnt <= 11'b0;\n                    rd <= 1'b0;\n                    we <= 1'b0;\n                    busy_n <= 1'b1;\n                    transm_complete <= 1'b0;\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                end\n                6'b000001: begin // WRITE_DAT\n                    if (transf_cnt < BIT_BLOCK) begin\n                        if (transf_cnt[2:0] == 3'b000) begin\n                            if (out_buff_ptr) sd_data_out <= write_buf_1;\n                            else sd_data_out <= write_buf_0;\n                            out_buff_ptr <= ~out_buff_ptr;\n                        end\n                        last_din <= sd_data_out[31:28];\n                        crc_in <= sd_data_out[31:28];\n                        DAT_dat_o <= last_din;\n                        sd_data_out <= {sd_data_out[27:0], 4'b0};\n                        transf_cnt <= transf_cnt + 1;\n                    end\n                    crc_en <= 1'b1;\n                end\n                6'b000010: begin // WRITE_CRC\n                    crc_en <= 1'b0;\n                    if (crc_c < 5'd16) begin\n                        crc_c <= crc_c + 1;\n                        crc_s <= crc_out[crc_c*16 +: 3];\n                    end else begin\n                        crc_status <= crc_s;\n                        crc_rst <= 1'b0;\n                    end\n                end\n                6'b000011: begin // WRITE_BUSY\n                    if (!DAT_dat_i[0]) begin\n                        busy_int <= 1'b0;\n                        transm_complete <= 1'b1;\n                        crc_ok <= (crc_status == 3'b000);\n                    end else begin\n                        busy_int <= 1'b1;\n                    end\n                end\n                6'b000100: begin // READ_WAIT\n                    crc_rst <= 1'b0;\n                    crc_en <= 1'b1;\n                    DAT_oe_o <= 1'b0;\n                end\n                6'b000101: begin // READ_DAT\n                    if (transf_cnt < BIT_BLOCK_REC) begin\n                        data_out <= DAT_dat_i;\n                        crc_in <= DAT_dat_i;\n                        transf_cnt <= transf_cnt + 1;\n                        we <= 1'b1;\n                    end else begin\n                        we <= 1'b0;\n                        crc_en <= 1'b0;\n                        if (crc_out == {16*SD_BUS_W{1'b0}}) crc_ok <= 1'b1;\n                        else crc_ok <= 1'b0;\n                        transm_complete <= 1'b1;\n                        busy_n <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done;\n    reg rec_done;\n    reg rec_failed;\n    reg tx_cycle;\n    reg rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg trans_done;\n    reg trans_failed;\n    reg internal_transm_complete;\n    reg transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && tx_empt) begin\n                        trans_failed <= 1;\n                    end else if (rx_cycle && rx_full) begin\n                        trans_failed <= 1;\n                    end else if (transm_complete && crc_ok) begin\n                        trans_done <= 1;\n                        ack_transfer <= 1;\n                    end\n                    if (tx_cycle) begin\n                        a_cmp_tx <= 1;\n                    end else if (rx_cycle) begin\n                        a_cmp_rx <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    parameter INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    parameter NCR = 2;\n    parameter SEND_SIZE = 48;\n    parameter SIZE = 10;\n    parameter CONTENT_SIZE = 40;\n    parameter Read_Delay = 7;\n    parameter EIGHT_PAD = 8;\n\n    // FSM States\n    parameter INIT = 10'b0000000001;\n    parameter IDLE = 10'b0000000010;\n    parameter WRITE_WR = 10'b0000000100;\n    parameter DLY_WR = 10'b0000001000;\n    parameter READ_WR = 10'b0000010000;\n    parameter DLY_READ = 10'b0000100000;\n    parameter ACK_WR = 10'b0001000000;\n    parameter WRITE_WO = 10'b0010000000;\n    parameter DLY_WO = 10'b0100000000;\n    parameter ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational Logic for Next State\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential Logic for State Update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Ack_internal_in <= 0;\n            q1 <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage Outputs and Internal Counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) CRC_OUT <= CRC_VAL[6];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                        if (Cmd_Cnt > 9) CRC_OUT <= CRC_VAL[6];\n                        st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write ? 2'b01 : 2'b00);\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_inst (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    if (Dat_Int_Status_rst) begin\n                        Dat_Int_Status <= 0;\n                    end\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                        if (bd_cnt >= READ_CYCLE - 1) begin\n                            cmd_set <= CMD24;\n                            tx_cycle <= 1;\n                        end\n                    end\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                        if (bd_cnt >= READ_CYCLE - 1) begin\n                            case (transfer_type)\n                                2'b00: cmd_set <= CMD17;\n                                2'b01: cmd_set <= ACMD13;\n                                default: cmd_set <= ACMD51;\n                            endcase\n                            rx_cycle <= 1;\n                        end\n                    end\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                        ack_transfer <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n    \n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering == 1) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) begin\n                                CRC_OUT <= CRC_VAL[6];\n                            end\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[6];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering == 1) begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= CRC_VAL[6];\n                        end\n                        if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[6];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_instance (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational Logic for Next State\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential Logic for State Update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage Outputs and Internal Counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                        if (Cmd_Cnt > 9) CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[Cmd_Cnt - Response_Size] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    reg last_a_cmp;\n    reg new_bw;\n    reg [1:0] write_count;\n    reg [1:0] read_count;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            last_a_cmp <= 0;\n            new_bw <= 0;\n            ack_o_s <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_count <= write_count + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_count == 1) || (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                    new_bw <= 1;\n                    free_bd <= free_bd - 1;\n                    write_count <= 0;\n                end\n            end else begin\n                new_bw <= 0;\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_count <= read_count + 1;\n                if (RAM_MEM_WIDTH == 16) begin\n                    ack_o_s <= 1;\n                end\n                if ((RAM_MEM_WIDTH == 32 && read_count == 1) || (RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                    read_count <= 0;\n                end\n            end else begin\n                ack_o_s <= 0;\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n\n            // Circular Operation\n            if (m_wr_pnt == BD_SIZE) begin\n                m_wr_pnt <= 0;\n            end\n            if (s_rd_pnt == BD_SIZE) begin\n                s_rd_pnt <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full, fifo_empty;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (!wb_free && m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            reset_tx_fifo <= 1'b0;\n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + {offset, 2'b00};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cti_o <= 3'b000;\n                    m_wb_bte_o <= 2'b00;\n                end\n\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational Logic for Next State\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential Logic for State Update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage Outputs and Internal Counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_inst (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM states\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational logic for next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential logic for state update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN and prepare command\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and internal counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) begin\n                                CRC_OUT <= CRC_VAL[6];\n                            end\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                        if (Cmd_Cnt > 9) begin\n                            CRC_OUT <= CRC_VAL[6];\n                        end\n                        if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[Cmd_Cnt - Response_Size] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC module instantiation\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full, fifo_empty;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (!wb_free && m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 14, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:15]; // Register file for storing configuration registers\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n    end else begin\n        // Default assignments\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n\n        // Wishbone interface logic\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1'b1;\n                        dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        int_ack <= 1'b0;\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1'b1;\n                        dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        int_ack <= 1'b0;\n                    end\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 32'h00000000; // Controller settings not used\n                    8'h20: wb_dat_o <= 32'h00000200; // Block size hardcoded to 512\n                    8'h24: wb_dat_o <= 32'h0000000F; // Power control hardcoded to 3.3V\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000; // Capability register not used\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1'b1;\n        end\n\n        // Control logic\n        if (write_req_s) begin\n            we_ack <= 1'b1;\n        end\n\n        if (cmd_set_s != 16'h0000 || cmd_arg_s != 32'h00000000) begin\n            cmd_int_busy <= 1'b1;\n            int_busy <= 1'b1;\n            new_cmd <= 1'b1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 16, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full, fifo_empty;\n\n    sd_rx_fifo u_sd_rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + {23'd0, offset};\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 19, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    // This section would be specific to ACTEL synthesis tools\n    // Assuming a hypothetical CLKINT block usage\n    CLKINT clkint_inst (\n        .A(SD_CLK_O),\n        .Y(SD_CLK)\n    );\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done;\n    reg rec_done;\n    reg rec_failed;\n    reg tx_cycle;\n    reg rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done;\n    reg trans_failed;\n    reg internal_transm_complete;\n    reg transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY)\n                    next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY)\n                    next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1)\n                    next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1)\n                    next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done)\n                    next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done)\n                    next_state = DATA_TRANSFER;\n                else if (rec_failed)\n                    next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done)\n                    next_state = IDLE;\n                else if (trans_failed)\n                    next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0)\n                                sys_adr <= dat_in_tx;\n                            else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0)\n                                sys_adr[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 1)\n                                sys_adr[31:16] <= dat_in_tx;\n                            else if (bd_cnt == 2)\n                                cmd_arg[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0)\n                                sys_adr <= dat_in_rx;\n                            else if (bd_cnt == 1)\n                                cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0)\n                                sys_adr[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 1)\n                                sys_adr[31:16] <= dat_in_rx;\n                            else if (bd_cnt == 2)\n                                cmd_arg[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 3)\n                                cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle)\n                        d_write <= 1;\n                    else if (rx_cycle)\n                        d_read <= 1;\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                            we_req <= 0;\n                        end\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle)\n                        start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt)\n                        trans_done <= 1;\n                    else if (rx_cycle && !rx_full)\n                        trans_done <= 1;\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                        trans_done <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT)\n                        Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                            we_req <= 0;\n                        end\n                    end\n                end\n            endcase\n            if (Dat_Int_Status_rst)\n                Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 7, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'b000000: // IDLE\n                if (start_dat == 2'b01)\n                    next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b10)\n                    next_state = 6'b000101; // READ_WAIT\n                else\n                    next_state = 6'b000000; // IDLE\n            6'b000001: // WRITE_DAT\n                if (transf_cnt == BIT_BLOCK)\n                    next_state = 6'b000010; // WRITE_CRC\n                else\n                    next_state = 6'b000001; // WRITE_DAT\n            6'b000010: // WRITE_CRC\n                if (crc_status == 3'b000)\n                    next_state = 6'b000011; // WRITE_BUSY\n                else\n                    next_state = 6'b000010; // WRITE_CRC\n            6'b000011: // WRITE_BUSY\n                if (!busy_int)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000011; // WRITE_BUSY\n            6'b000101: // READ_WAIT\n                if (!DAT_dat_i[0])\n                    next_state = 6'b000110; // READ_DAT\n                else\n                    next_state = 6'b000101; // READ_WAIT\n            6'b000110: // READ_DAT\n                if (transf_cnt == BIT_BLOCK_REC)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000110; // READ_DAT\n            default:\n                next_state = 6'b000000; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else if (!DAT_dat_i[0] && state == 6'b000101) begin\n            q_start_bit <= 0;\n        end else begin\n            q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                    crc_ok <= 0;\n                end\n                6'b000001: begin // WRITE_DAT\n                    // Write data logic\n                end\n                6'b000010: begin // WRITE_CRC\n                    // Write CRC logic\n                end\n                6'b000011: begin // WRITE_BUSY\n                    // Write busy logic\n                end\n                6'b000101: begin // READ_WAIT\n                    // Read wait logic\n                end\n                6'b000110: begin // READ_DAT\n                    // Read data logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 13, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    // Calculate the inverse bit\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            // Reset CRC to zero\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            // Update CRC based on the input bit and current CRC value\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full, fifo_empty;\n\n    sd_rx_fifo u_sd_rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 8, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin: CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 1'b0;\n            ack_q <= 1'b0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO Block\n    always @(*) begin\n        case (state)\n            6'b000000: begin // IDLE\n                if (start_dat == 2'b10)\n                    next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b01)\n                    next_state = 6'b000100; // READ_WAIT\n                else\n                    next_state = 6'b000000; // IDLE\n            end\n            6'b000001: begin // WRITE_DAT\n                if (transf_cnt == BIT_BLOCK)\n                    next_state = 6'b000010; // WRITE_CRC\n                else\n                    next_state = 6'b000001; // WRITE_DAT\n            end\n            6'b000010: begin // WRITE_CRC\n                if (crc_status == 3'b000)\n                    next_state = 6'b000011; // WRITE_BUSY\n                else\n                    next_state = 6'b000010; // WRITE_CRC\n            end\n            6'b000011: begin // WRITE_BUSY\n                if (!busy_int)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000011; // WRITE_BUSY\n            end\n            6'b000100: begin // READ_WAIT\n                if (DAT_dat_i[0] == 1'b0)\n                    next_state = 6'b000101; // READ_DAT\n                else\n                    next_state = 6'b000100; // READ_WAIT\n            end\n            6'b000101: begin // READ_DAT\n                if (transf_cnt == BIT_BLOCK_REC)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000101; // READ_DAT\n            end\n            default: next_state = 6'b000000; // Default to IDLE\n        endcase\n    end\n\n    // START_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else if (!DAT_dat_i[0] && state == 6'b000100) begin\n            q_start_bit <= 1'b0;\n        end else begin\n            q_start_bit <= 1'b1;\n        end\n    end\n\n    // FSM_SEQ Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 32'b0;\n            write_buf_1 <= 32'b0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'b0;\n            rd <= 1'b0;\n            last_din <= 4'b0;\n            crc_c <= 5'b0;\n            crc_in <= {SD_BUS_W{1'b0}};\n            DAT_dat_o <= {SD_BUS_W{1'b0}};\n            crc_status <= 3'b111;\n            crc_s <= 3'b0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            data_out <= {SD_BUS_W{1'b0}};\n            crc_ok <= 1'b0;\n            busy_int <= 1'b0;\n            data_send_index <= 3'b0;\n            out_buff_ptr <= 1'b0;\n            in_buff_ptr <= 1'b0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1'b1;\n                    crc_en <= 1'b0;\n                    transf_cnt <= 11'b0;\n                    rd <= 1'b0;\n                    we <= 1'b0;\n                    busy_n <= 1'b1;\n                    transm_complete <= 1'b0;\n                end\n                6'b000001: begin // WRITE_DAT\n                    // Logic for writing data\n                end\n                6'b000010: begin // WRITE_CRC\n                    // Logic for CRC generation\n                end\n                6'b000011: begin // WRITE_BUSY\n                    // Logic for busy state\n                end\n                6'b000100: begin // READ_WAIT\n                    // Logic for read wait\n                end\n                6'b000101: begin // READ_DAT\n                    // Logic for reading data\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 15, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:15];\nreg [15:0] reg_file_16 [0:15];\nreg [7:0] reg_file_8 [0:15];\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        argument_reg <= 32'h0;\n        cmd_setting_reg <= 16'h0;\n        software_reset_reg <= 8'h0;\n        time_out_reg <= 16'h0;\n        normal_int_signal_enable_reg <= 16'h0;\n        error_int_signal_enable_reg <= 16'h0;\n        clock_divider <= 8'h0;\n        Bd_isr_enable_reg <= 8'h0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end else begin\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60, 8'h80: begin\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                    end\n                    default: ;\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0;\n                    8'h20: wb_dat_o <= 32'h200;\n                    8'h24: wb_dat_o <= 32'hf;\n                    8'h28: wb_dat_o <= {24'h0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0;\n                    8'h4c: wb_dat_o <= {24'h0, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h0;\n                endcase\n            end\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n            if (Bd_isr_reset) Bd_isr_reset <= 1'b0;\n            if (normal_isr_reset) normal_isr_reset <= 1'b0;\n            if (error_isr_reset) error_isr_reset <= 1'b0;\n            if (we_m_rx_bd) begin\n                we_m_rx_bd <= 1'b0;\n                int_ack <= 1'b1;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 16, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\nreg [15:0] bd_rx_reg;\nreg [15:0] bd_tx_reg;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 0;\n        we_m_tx_bd <= 0;\n        we_m_rx_bd <= 0;\n        new_cmd <= 0;\n        we_ack <= 0;\n        int_ack <= 1;\n        cmd_int_busy <= 0;\n        int_busy <= 0;\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n        dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n    end else begin\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1;\n                    8'h34: error_isr_reset <= 1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else begin\n                            bd_rx_reg <= wb_dat_i[15:0];\n                            dat_in_m_rx_bd <= {bd_rx_reg, wb_dat_i[15:0]};\n                        end\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                        end else begin\n                            bd_tx_reg <= wb_dat_i[15:0];\n                            dat_in_m_tx_bd <= {bd_tx_reg, wb_dat_i[15:0]};\n                        end\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 32'h00000000;\n                    8'h20: wb_dat_o <= 32'h00000200;\n                    8'h24: wb_dat_o <= 32'h0000000F;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000;\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n            if (we_m_rx_bd || we_m_tx_bd) begin\n                int_ack <= 1;\n                we_m_rx_bd <= 0;\n                we_m_tx_bd <= 0;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 14, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Operation\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                    STATUS_REG[0] <= 1'b1;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 20, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter >= DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    CLKINT clkint_inst (\n        .A(SD_CLK_O),\n        .Y(SD_CLK)\n    );\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 17, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        wire inv = BITVAL ^ CRC[6];\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 15, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    // Calculate the inversion bit\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5]  <= CRC[4] ^ inv;\n            CRC[0]  <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 16, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 17, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 17, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\nreg [15:0] bd_rx_reg;\nreg [15:0] bd_tx_reg;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 0;\n        we_m_tx_bd <= 0;\n        we_m_rx_bd <= 0;\n        new_cmd <= 0;\n        we_ack <= 0;\n        int_ack <= 1;\n        cmd_int_busy <= 0;\n        int_busy <= 0;\n        argument_reg <= 32'h0000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n        dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n    end else begin\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1;\n                    8'h34: error_isr_reset <= 1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        bd_rx_reg <= wb_dat_i[15:0];\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            int_ack <= 1;\n                            we_m_rx_bd <= 0;\n                        end\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        bd_tx_reg <= wb_dat_i[15:0];\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            int_ack <= 1;\n                            we_m_tx_bd <= 0;\n                        end\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 16'h0000;\n                    8'h20: wb_dat_o <= 16'h0200;\n                    8'h24: wb_dat_o <= 8'h0F;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 16'h0000;\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n            if (normal_isr_reset) normal_isr_reset <= 0;\n            if (error_isr_reset) error_isr_reset <= 0;\n            if (Bd_isr_reset) Bd_isr_reset <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 18, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 19, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 18, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            wire inv = BITVAL ^ CRC[6];\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 20, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:12], CRC[11] ^ inv, CRC[10:5], CRC[4] ^ inv, CRC[3:1], inv};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 19, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            wire inv = BITVAL ^ CRC[6];\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 20, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            wire inv = BITVAL ^ CRC[6];\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full, fifo_empty;\n\n    sd_rx_fifo u_sd_rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (!wb_free && m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr + 1;\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n            q <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr + 1;\n        end\n    end\n\n    // Status update\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n            mem_empt <= 0;\n        end else begin\n            full <= (wptr[FIFO_TX_MEM_ADR_SIZE-1:0] == rptr[FIFO_TX_MEM_ADR_SIZE-1:0]) && (wptr[FIFO_TX_MEM_ADR_SIZE] != rptr[FIFO_TX_MEM_ADR_SIZE]);\n            empty <= (wptr == rptr);\n            mem_empt <= wptr - rptr;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            we <= 9'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            reset_tx_fifo <= 1'b0;\n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end else if (delay) begin\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            we <= 9'd0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else begin\n            reset_tx_fifo <= 1'b0;\n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + {23'd0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cti_o <= 3'b010;\n                    m_wb_bte_o <= 2'b00;\n                end\n\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    offset <= offset + 9'd1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'd0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full;\n    wire fifo_empty;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + {offset, 2'b00};\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_cti_o <= 3'b010;\n                m_wb_bte_o <= 2'b00;\n                wb_free <= 1'b0;\n            end else if (!wb_free && m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full, fifo_empty;\n\n    sd_rx_fifo fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_adr_o <= adr + offset;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done;\n    reg rec_done;\n    reg rec_failed;\n    reg tx_cycle;\n    reg rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done;\n    reg trans_failed;\n    reg internal_transm_complete;\n    reg transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end else begin\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_tx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_tx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    end else begin\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_rx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_rx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) begin\n                            rec_failed <= 1;\n                        end else if (card_status[0] == 1 || (card_status[4:1] >= 4 && card_status[4:1] <= 6)) begin\n                            rec_done <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && tx_empt) begin\n                        trans_failed <= 1;\n                    end else if (rx_cycle && rx_full) begin\n                        trans_failed <= 1;\n                    end\n                    if (transm_complete) begin\n                        if (crc_ok) begin\n                            trans_done <= 1;\n                        end else begin\n                            trans_failed <= 1;\n                        end\n                    end\n                    if (trans_done || trans_failed) begin\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else if (rx_cycle) begin\n                            a_cmp_rx <= 1;\n                        end\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full, fifo_empty;\n\n    sd_rx_fifo u_sd_rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            reset_tx_fifo <= 1'b0;\n            if (!fe && !m_wb_ack_i && ackd) begin\n                m_wb_adr_o <= adr + {23'b0, offset};\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_we_o <= 1'b0;\n                m_wb_cti_o <= 3'b0;\n                m_wb_bte_o <= 2'b0;\n            end\n            if (m_wb_ack_i) begin\n                din <= m_wb_dat_i;\n                wr_tx <= 1'b1;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                delay <= 1'b1;\n            end else if (delay) begin\n                offset <= offset + 1'b1;\n                ackd <= ~ackd;\n                wr_tx <= 1'b0;\n                delay <= 1'b0;\n            end\n        end else begin\n            reset_tx_fifo <= 1'b1;\n            offset <= 9'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rclk,\n    input rst,\n    input rd,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n\n    // Write logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr + 1;\n        end\n    end\n\n    // Read logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n            q <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr + 1;\n        end\n    end\n\n    // Full and empty flag logic\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n            mem_empt <= 0;\n        end else begin\n            full <= (wptr[FIFO_TX_MEM_ADR_SIZE-1:0] == rptr[FIFO_TX_MEM_ADR_SIZE-1:0]) && (wptr[FIFO_TX_MEM_ADR_SIZE] != rptr[FIFO_TX_MEM_ADR_SIZE]);\n            empty <= (wptr == rptr);\n            mem_empt <= wptr - rptr;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full, fifo_empty;\n\n    sd_rx_fifo u_sd_rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_cti_o <= 3'b000;\n                m_wb_bte_o <= 2'b00;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // Initialization and state management\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            we <= 9'd0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n        end else begin\n            reset_tx_fifo <= 1'b0;\n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + {23'd0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cti_o <= 3'b000;\n                    m_wb_bte_o <= 2'b00;\n                end\n\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    offset <= offset + 9'd1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'd0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rclk,\n    input rst,\n    input rd,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr + 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr + 1;\n        end\n    end\n\n    always @(*) begin\n        full = (wptr[FIFO_TX_MEM_ADR_SIZE] != rptr[FIFO_TX_MEM_ADR_SIZE]) &&\n               (wptr[FIFO_TX_MEM_ADR_SIZE-1:0] == rptr[FIFO_TX_MEM_ADR_SIZE-1:0]);\n        empty = (wptr == rptr);\n        mem_empt = wptr - rptr;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // Asynchronous reset\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else begin\n            full <= (adr_i == adr_o - 1) && ft;\n            empty <= (adr_o == adr_i) && !ft;\n            mem_empt <= (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            we <= 9'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            reset_tx_fifo <= 1'b0;\n            if (!fe && !m_wb_ack_i && ackd) begin\n                m_wb_adr_o <= adr + {23'b0, offset};\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_we_o <= 1'b0;\n                ackd <= 1'b0;\n            end\n            if (m_wb_ack_i) begin\n                din <= m_wb_dat_i;\n                wr_tx <= 1'b1;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                delay <= 1'b1;\n            end\n            if (delay) begin\n                offset <= offset + 1'b1;\n                ackd <= 1'b1;\n                wr_tx <= 1'b0;\n                delay <= 1'b0;\n            end\n        end else begin\n            reset_tx_fifo <= 1'b1;\n            offset <= 9'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // Initialization and reset logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            we <= 9'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            reset_tx_fifo <= 1'b0;\n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cti_o <= 3'b010;\n                    m_wb_bte_o <= 2'b00;\n                end\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                if (delay) begin\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(rst)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            we <= 9'd0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            reset_tx_fifo <= 1'b0;\n            if (!fe && !m_wb_ack_i && ackd) begin\n                m_wb_adr_o <= adr + {23'd0, offset};\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_we_o <= 1'b0;\n                m_wb_cti_o <= 3'b000;\n                m_wb_bte_o <= 2'b00;\n            end\n            if (m_wb_ack_i) begin\n                din <= m_wb_dat_i;\n                wr_tx <= 1'b1;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                delay <= 1'b1;\n            end\n            if (delay) begin\n                offset <= offset + 9'd1;\n                ackd <= ~ackd;\n                wr_tx <= 1'b0;\n                delay <= 1'b0;\n            end\n        end else begin\n            reset_tx_fifo <= 1'b1;\n            offset <= 9'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full, fifo_empty;\n\n    sd_rx_fifo u_sd_rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_cti_o <= 3'b000;\n                m_wb_bte_o <= 2'b00;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n    reg [31:0] sys_adr;\n    reg [31:0] cmd_arg;\n    reg [15:0] cmd_set;\n    reg CIDAT;\n    reg [7:0] Dat_Int_Status;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end else begin\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_tx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_tx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                    bd_cnt <= bd_cnt + 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    end else begin\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_rx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_rx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                    bd_cnt <= bd_cnt + 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) begin\n                            rec_failed <= 1;\n                        end else if (card_status[0] == 1 || card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6) begin\n                            rec_done <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                        ack_transfer <= 1;\n                    end else if (!crc_ok) begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i == adr_o - 1)\n                full <= 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            empty <= 1;\n            q <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i)\n                empty <= 1;\n            full <= 0;\n        end\n    end\n\n    always @(*) begin\n        if (adr_i == adr_o)\n            empty = 1;\n        else\n            empty = 0;\n\n        if (adr_i == adr_o - 1)\n            full = 1;\n        else\n            full = 0;\n\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    output reg [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                if (adr_i == adr_o - 1)\n                    full <= 1;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i - 1)\n                empty <= 1;\n        end\n    end\n\n    // Full and empty flag management\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else begin\n            if (adr_i == adr_o)\n                empty <= 1;\n            else\n                empty <= 0;\n\n            if (adr_i == adr_o - 1)\n                full <= 1;\n            else\n                full <= 0;\n        end\n    end\n\n    // Memory empty space calculation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 2'b11;\n        end else begin\n            mem_empt <= FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg req_in_int, ack_in_int;\n    reg [39:0] cmd_out_next;\n    reg [15:0] settings_next;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_in_int <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_in_int <= req_in;\n            ack_in_int <= ack_in;\n        end\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(rst)\n    );\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            reset_tx_fifo <= 1'b0;\n            if (!fe && !m_wb_ack_i && ackd) begin\n                m_wb_adr_o <= adr + {23'b0, offset};\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_we_o <= 1'b0;\n                m_wb_cti_o <= 3'b000;\n                m_wb_bte_o <= 2'b00;\n            end\n            if (m_wb_ack_i) begin\n                din <= m_wb_dat_i;\n                wr_tx <= 1'b1;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                delay <= 1'b1;\n            end\n            if (delay) begin\n                offset <= offset + 1'b1;\n                ackd <= ~ackd;\n                wr_tx <= 1'b0;\n                delay <= 1'b0;\n            end\n        end else begin\n            reset_tx_fifo <= 1'b1;\n            offset <= 9'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // Instantiate the sd_rx_fifo sub-module\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Initialization on reset\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            // Data reception and transfer process\n            if (!empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_cti_o <= 3'b000; // Classic cycle\n                m_wb_bte_o <= 2'b00;  // Linear burst\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            // Disabled state handling\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // Reset logic\n    always @(posedge rst or posedge wclk or posedge rclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_o <= 0;\n            we <= 8'h1;\n            tmp <= 32'b0;\n            ft <= 0;\n            full <= 0;\n            empty <= 1;\n        end else begin\n            // Write operation\n            if (wr && !full) begin\n                tmp <= {tmp[27:0], d};\n                we <= {we[6:0], we[7]};\n                if (we == 8'h80) begin\n                    ram[adr_i] <= tmp;\n                    adr_i <= adr_i + 1;\n                    ft <= 1;\n                end\n            end\n\n            // Read operation\n            if (rd && !empty) begin\n                q <= ram[adr_o];\n                adr_o <= adr_o + 1;\n            end\n\n            // Full and Empty flag logic\n            full <= (adr_i == adr_o - 1);\n            empty <= (adr_o == adr_i);\n\n            // Memory empty space\n            mem_empt <= (adr_i - adr_o) >> 5;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we == 8'h80) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i == adr_o - 1)\n                full <= 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i)\n                empty <= 1;\n        end\n    end\n\n    always @(*) begin\n        if (adr_i == adr_o)\n            empty = 1;\n        else\n            empty = 0;\n\n        if (adr_i == adr_o - 1)\n            full = 1;\n        else\n            full = 0;\n\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // Instantiate the sd_rx_fifo sub-module\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    // State machine for controlling the data reception and transfer\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Initialization on reset\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end else if (en) begin\n            // Data Reception and Transfer Process\n            reset_rx_fifo <= 1'b0;\n            if (!empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            // Disabled State Handling\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i + 1 == adr_o) full <= 1;\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i) empty <= 1;\n        end\n    end\n\n    // Full and Empty flags\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else begin\n            if (adr_i == adr_o) begin\n                empty <= 1;\n                full <= 0;\n            end else if (adr_i + 1 == adr_o) begin\n                full <= 1;\n                empty <= 0;\n            end else begin\n                full <= 0;\n                empty <= 0;\n            end\n        end\n    end\n\n    // Memory empty space calculation\n    always @(*) begin\n        if (adr_i >= adr_o) begin\n            mem_empt = FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\n        end else begin\n            mem_empt = adr_o - adr_i;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i == adr_o - 1) full <= 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i) empty <= 1;\n        end\n    end\n\n    always @(*) begin\n        if (adr_i == adr_o) begin\n            empty = 1;\n            full = 0;\n        end else if (adr_i == adr_o - 1) begin\n            full = 1;\n            empty = 0;\n        end else begin\n            full = 0;\n            empty = 0;\n        end\n    end\n\n    always @(*) begin\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rclk,\n    input wire rst,\n    input wire rd,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n\n    // Write domain logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin_next <= wptr_bin + 1;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= (wptr_bin_next >> 1) ^ wptr_bin_next;\n        end\n    end\n\n    // Read domain logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr_bin_next <= rptr_bin + 1;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= (rptr_bin_next >> 1) ^ rptr_bin_next;\n        end\n    end\n\n    // Full and empty flag logic\n    always @(*) begin\n        full = (wptr_gray == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (wptr_gray == rptr_gray);\n    end\n\n    // FIFO occupancy calculation\n    always @(*) begin\n        mem_empt = adr_i - adr_o;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // Asynchronous reset\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                if (adr_i + 1 == adr_o) full <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i) empty <= 1;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 2'b11;\n        end else begin\n            mem_empt <= (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n        end\n    end\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            empty <= 1;\n        end else if (wr && !full) begin\n            empty <= 0;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n        end else if (rd && !empty) begin\n            full <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    // Write logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin_next <= wptr_bin + 1;\n            wptr_gray_next <= (wptr_bin_next >> 1) ^ wptr_bin_next;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr_bin_next <= rptr_bin + 1;\n            rptr_gray_next <= (rptr_bin_next >> 1) ^ rptr_bin_next;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Full and empty logic\n    always @(*) begin\n        full = (wptr_gray == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (wptr_gray == rptr_gray);\n    end\n\n    // FIFO occupancy\n    always @(*) begin\n        mem_empt = wptr_bin - rptr_bin;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full;\n    wire fifo_empty;\n\n    sd_rx_fifo u_sd_rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + {offset, 2'b00};\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_cti_o <= 3'b000;\n                m_wb_bte_o <= 2'b00;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 9, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter IDLE = 6'b000001;\n    parameter WRITE_DAT = 6'b000010;\n    parameter WRITE_CRC = 6'b000100;\n    parameter WRITE_BUSY = 6'b001000;\n    parameter READ_WAIT = 6'b010000;\n    parameter READ_DAT = 6'b100000;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO Block\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                end\n                WRITE_DAT: begin\n                    // Logic for WRITE_DAT state\n                end\n                WRITE_CRC: begin\n                    // Logic for WRITE_CRC state\n                end\n                WRITE_BUSY: begin\n                    // Logic for WRITE_BUSY state\n                end\n                READ_WAIT: begin\n                    // Logic for READ_WAIT state\n                end\n                READ_DAT: begin\n                    // Logic for READ_DAT state\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            we <= 9'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            reset_tx_fifo <= 1'b0;\n            if (!fe && !m_wb_ack_i && ackd) begin\n                m_wb_adr_o <= adr + {23'b0, offset};\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_we_o <= 1'b0;\n                m_wb_cti_o <= 3'b0;\n                m_wb_bte_o <= 2'b0;\n            end\n            if (m_wb_ack_i) begin\n                din <= m_wb_dat_i;\n                wr_tx <= 1'b1;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                delay <= 1'b1;\n            end\n            if (delay) begin\n                offset <= offset + 1'b1;\n                ackd <= ~ackd;\n                wr_tx <= 1'b0;\n                delay <= 1'b0;\n            end\n        end else begin\n            reset_tx_fifo <= 1'b1;\n            offset <= 9'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 10, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen instantiation\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'b000001: begin // IDLE\n                if (start_dat == 2'b01)\n                    next_state = 6'b000010; // WRITE_DAT\n                else if (start_dat == 2'b10)\n                    next_state = 6'b001000; // READ_WAIT\n                else\n                    next_state = 6'b000001; // IDLE\n            end\n            6'b000010: begin // WRITE_DAT\n                if (transf_cnt == SD_BUS_W)\n                    next_state = 6'b000100; // WRITE_CRC\n                else\n                    next_state = 6'b000010; // WRITE_DAT\n            end\n            6'b000100: begin // WRITE_CRC\n                if (crc_status == 3'b111)\n                    next_state = 6'b000011; // WRITE_BUSY\n                else\n                    next_state = 6'b000100; // WRITE_CRC\n            end\n            6'b000011: begin // WRITE_BUSY\n                if (!busy_int)\n                    next_state = 6'b000001; // IDLE\n                else\n                    next_state = 6'b000011; // WRITE_BUSY\n            end\n            6'b001000: begin // READ_WAIT\n                if (DAT_dat_i[0] == 0)\n                    next_state = 6'b010000; // READ_DAT\n                else\n                    next_state = 6'b001000; // READ_WAIT\n            end\n            6'b010000: begin // READ_DAT\n                if (transf_cnt == SD_BUS_W)\n                    next_state = 6'b000001; // IDLE\n                else\n                    next_state = 6'b010000; // READ_DAT\n            end\n            default: next_state = 6'b000001; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == 6'b001000)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000001; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000001: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                    crc_ok <= 0;\n                end\n                6'b000010: begin // WRITE_DAT\n                    if (transf_cnt < SD_BUS_W) begin\n                        if (out_buff_ptr == 0) begin\n                            sd_data_out <= write_buf_0;\n                        end else begin\n                            sd_data_out <= write_buf_1;\n                        end\n                        DAT_dat_o <= last_din;\n                        crc_in <= last_din;\n                        crc_en <= 1;\n                        transf_cnt <= transf_cnt + 1;\n                        if (transf_cnt == 28) begin\n                            out_buff_ptr <= ~out_buff_ptr;\n                        end\n                    end\n                end\n                6'b000100: begin // WRITE_CRC\n                    crc_en <= 0;\n                    crc_rst <= 0;\n                    crc_status <= crc_out[15:0] == crc_out[31:16] ? 3'b111 : 3'b000;\n                end\n                6'b000011: begin // WRITE_BUSY\n                    transm_complete <= 1;\n                    crc_ok <= (crc_status == 3'b111);\n                    busy_int <= DAT_dat_i[0];\n                end\n                6'b001000: begin // READ_WAIT\n                    crc_rst <= 0;\n                    crc_en <= 1;\n                    DAT_oe_o <= 0;\n                    busy_int <= 1;\n                end\n                6'b010000: begin // READ_DAT\n                    data_out <= DAT_dat_i;\n                    crc_in <= DAT_dat_i;\n                    transf_cnt <= transf_cnt + 1;\n                    if (transf_cnt == SD_BUS_W) begin\n                        crc_ok <= (crc_out[15:0] == crc_out[31:16]);\n                        transm_complete <= 1;\n                        busy_n <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            we <= 9'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            reset_tx_fifo <= 1'b0;\n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cti_o <= 3'b0;\n                    m_wb_bte_o <= 2'b0;\n                end\n\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i + 1 == adr_o) full <= 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i) empty <= 1;\n        end\n    end\n\n    always @(*) begin\n        if (adr_i == adr_o) begin\n            if (ft) begin\n                full = 1;\n                empty = 0;\n            end else begin\n                full = 0;\n                empty = 1;\n            end\n        end else begin\n            full = 0;\n            empty = 0;\n        end\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] count;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            count <= count + 1;\n            if (count == 3) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                count <= 0;\n                if (adr_i + 1 == adr_o) begin\n                    full <= 1;\n                end\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            empty <= 1;\n            q <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i) begin\n                empty <= 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        if (adr_i == adr_o) begin\n            empty = 1;\n            full = 0;\n        end else if ((adr_i + 1) == adr_o) begin\n            full = 1;\n            empty = 0;\n        end else begin\n            full = 0;\n            empty = 0;\n        end\n    end\n\n    always @(*) begin\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                if (adr_i == adr_o - 1) full <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i) empty <= 1;\n        end\n    end\n\n    always @(*) begin\n        if (adr_i == adr_o) begin\n            empty = 1;\n            full = 0;\n        end else if (adr_i == adr_o - 1) begin\n            full = 1;\n            empty = 0;\n        end else begin\n            full = 0;\n            empty = 0;\n        end\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // Instantiate the sd_rx_fifo sub-module\n    sd_rx_fifo u_sd_rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Initialization on reset\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            // Data reception and transfer process\n            if (!empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_adr_o <= adr + {23'd0, offset};\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_cti_o <= 3'b000;\n                m_wb_bte_o <= 2'b00;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            // Disabled state handling\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001;\n    localparam SETUP = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg req_q, req_in_int, ack_q, ack_in_int;\n    reg CCRCE, EI, CC;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111) debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 1'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= req_in;\n            req_in_int <= req_q;\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD) next_state = SETUP;\n                else next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int) next_state = EXECUTE;\n                else next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete) next_state = IDLE;\n                else next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Operation\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            CCRCE <= 1'b0;\n            EI <= 1'b0;\n            CC <= 1'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        EI <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            EI <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                EI <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                EI <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 1, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules instantiation and connections go here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n\n    // Write pointer management\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= (wptr_bin_next >> 1) ^ wptr_bin_next;\n        end\n    end\n\n    // Read pointer management\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= (rptr_bin_next >> 1) ^ rptr_bin_next;\n        end\n    end\n\n    // Full and empty flag management\n    always @(*) begin\n        wptr_bin_next = adr_i + 1;\n        rptr_bin_next = adr_o + 1;\n        full = (wptr_gray == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (wptr_gray == rptr_gray);\n        mem_empt = adr_i - adr_o;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Initialization on reset\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            if (en) begin\n                reset_tx_fifo <= 1'b0;\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    // Start Wishbone read transaction\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n\n                if (m_wb_ack_i) begin\n                    // Wishbone acknowledges\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    // Next clock cycle after acknowledgment\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Disabled state handling\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // Asynchronous reset\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_o <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n            empty <= 1;\n        end else begin\n            // Write operation\n            if (wr && !full) begin\n                tmp <= {tmp[27:0], d};\n                we <= {we[6:0], we[7]};\n                if (we == 8'h80) begin\n                    ram[adr_i] <= tmp;\n                    adr_i <= adr_i + 1;\n                    ft <= 1;\n                end\n            end\n\n            // Full flag logic\n            if (adr_i == adr_o - 1)\n                full <= 1;\n            else\n                full <= 0;\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else begin\n            if (rd && !empty) begin\n                q <= ram[adr_o];\n                adr_o <= adr_o + 1;\n            end\n\n            // Empty flag logic\n            if (adr_o == adr_i)\n                empty <= 1;\n            else\n                empty <= 0;\n        end\n    end\n\n    // Memory empty space calculation\n    always @(*) begin\n        if (adr_i >= adr_o)\n            mem_empt = FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\n        else\n            mem_empt = adr_o - adr_i;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 2, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    \n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    \n    // Card Detect\n    input wire card_detect,\n    \n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    \n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [7:0] Bd_isr_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] Bd_isr_enable_reg;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg)\n);\n\nsd_cmd_master sd_cmd_master_inst (\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .card_detect(card_detect),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg)\n);\n\nsd_data_master sd_data_master_inst (\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg)\n);\n\nsd_cmd_serial_host sd_cmd_serial_host_inst (\n    .SD_CLK_IN(wb_clk_i),\n    .RST_IN(wb_rst_i),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .cmd_out_o(sd_cmd_out_o),\n    .cmd_oe_o(sd_cmd_oe_o)\n);\n\nsd_data_serial_host sd_data_serial_host_inst (\n    .sd_clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .DAT_dat_i(sd_dat_dat_i),\n    .DAT_dat_o(sd_dat_out_o),\n    .DAT_oe_o(sd_dat_oe_o)\n);\n\nsd_clock_divider sd_clock_divider_inst (\n    .CLK(wb_clk_i),\n    .DIVIDER(8'd0), // Example divider value\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\n// Interrupt logic\nassign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\nassign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\nassign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 3, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb u_sd_controller_wb (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional sub-modules would be instantiated here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 18, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:63]; // Register file to store configuration registers\n\n// Reset and Clock\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end else begin\n        // Handle register writes\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                8'h28: software_reset_reg <= wb_dat_i[7:0];\n                8'h2C: time_out_reg <= wb_dat_i[15:0];\n                8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h3C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h4C: clock_divider <= wb_dat_i[7:0];\n                8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                8'h60, 8'h80: begin\n                    we_m_rx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                    int_ack <= 1'b1;\n                    we_m_rx_bd <= 1'b0;\n                end\n                default: ;\n            endcase\n        end\n\n        // Handle register reads\n        if (wb_stb_i && wb_cyc_i && !wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= argument_reg;\n                8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                8'h08: wb_dat_o <= {16'h0000, status_reg};\n                8'h0C: wb_dat_o <= cmd_resp_1;\n                8'h1C: wb_dat_o <= 32'h00000000; // Controller Setting\n                8'h20: wb_dat_o <= 32'h00000200; // Block Size\n                8'h24: wb_dat_o <= 32'h0000000F; // Power Control\n                8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                8'h48: wb_dat_o <= 32'h00000000; // Capability\n                8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                default: wb_dat_o <= 32'h00000000;\n            endcase\n        end\n\n        // Acknowledge logic\n        wb_ack_o <= wb_cyc_i & wb_stb_i & ~wb_ack_o & int_ack;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rclk,\n    input wire rst,\n    input wire rd,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin_next <= wptr_bin + 1;\n            wptr_gray_next <= (wptr_bin_next >> 1) ^ wptr_bin_next;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr_bin_next <= rptr_bin + 1;\n            rptr_gray_next <= (rptr_bin_next >> 1) ^ rptr_bin_next;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Full and empty status\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n        end else begin\n            full <= (wptr_gray_next == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            empty <= 1;\n        end else begin\n            empty <= (wptr_gray == rptr_gray);\n        end\n    end\n\n    // FIFO occupancy\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 0;\n        end else begin\n            mem_empt <= wptr_bin - rptr_bin;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            we <= 9'd0;\n            din <= 32'd0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            reset_tx_fifo <= 1'b0;\n            if (!fe && !m_wb_ack_i && ackd) begin\n                m_wb_adr_o <= adr + {23'd0, offset};\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_we_o <= 1'b0;\n                m_wb_cti_o <= 3'b010;\n                m_wb_bte_o <= 2'b00;\n            end\n            if (m_wb_ack_i) begin\n                din <= m_wb_dat_i;\n                wr_tx <= 1'b1;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                delay <= 1'b1;\n            end\n            if (delay) begin\n                offset <= offset + 9'd1;\n                ackd <= ~ackd;\n                wr_tx <= 1'b0;\n                delay <= 1'b0;\n            end\n        end else begin\n            reset_tx_fifo <= 1'b1;\n            offset <= 9'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i == adr_o - 1)\n                full <= 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i - 1)\n                empty <= 1;\n            full <= 0;\n        end\n    end\n\n    always @* begin\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    // Write logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Pointer increment and gray code conversion\n    always @* begin\n        wptr_bin_next = wptr_bin + (wr && !full);\n        rptr_bin_next = rptr_bin + (rd && !empty);\n        wptr_gray_next = (wptr_bin_next >> 1) ^ wptr_bin_next;\n        rptr_gray_next = (rptr_bin_next >> 1) ^ rptr_bin_next;\n    end\n\n    // Full and empty flag logic\n    always @* begin\n        full = (wptr_gray == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE], rptr_gray[FIFO_TX_MEM_ADR_SIZE-1:0]});\n        empty = (wptr_gray == rptr_gray);\n        mem_empt = wptr_bin - rptr_bin;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // Instantiate the sd_rx_fifo sub-module\n    sd_rx_fifo u_sd_rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Initialization on reset\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            // Data reception and transfer process\n            if (!empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_adr_o <= adr + {23'd0, offset};\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_cti_o <= 3'b000;\n                m_wb_bte_o <= 2'b00;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                // Wishbone write transaction completion\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            // Disabled state handling\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[0]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i == adr_o - 1)\n                full <= 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i - 1)\n                empty <= 1;\n        end\n    end\n\n    always @(*) begin\n        if (adr_i == adr_o)\n            empty = 1;\n        else\n            empty = 0;\n\n        if (adr_i == adr_o - 1)\n            full = 1;\n        else\n            full = 0;\n\n        mem_empt = (adr_i - adr_o) >> 5;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_counter;\n    reg [BD_WIDTH-1:0] read_counter;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    wire new_bw;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_counter <= write_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_counter == 1) || (RAM_MEM_WIDTH == 16 && write_counter == 3)) begin\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_counter <= read_counter + 1;\n                if ((RAM_MEM_WIDTH == 32 && read_counter == 1) || (RAM_MEM_WIDTH == 16 && read_counter == 3)) begin\n                    ack_o_s <= 1;\n                    read_counter <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n\n            // Circular Operation\n            if (m_wr_pnt == BD_SIZE) m_wr_pnt <= 0;\n            if (s_rd_pnt == BD_SIZE) s_rd_pnt <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    // Write domain logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read domain logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Pointer management\n    always @(*) begin\n        wptr_bin_next = wptr_bin + (wr && !full);\n        rptr_bin_next = rptr_bin + (rd && !empty);\n        wptr_gray_next = (wptr_bin_next >> 1) ^ wptr_bin_next;\n        rptr_gray_next = (rptr_bin_next >> 1) ^ rptr_bin_next;\n    end\n\n    // Full and empty status\n    always @(*) begin\n        full = (wptr_gray == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (wptr_gray == rptr_gray);\n        mem_empt = wptr_bin - rptr_bin;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State Machine and Control Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            we <= 9'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            reset_tx_fifo <= 1'b0;\n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cti_o <= 3'b010; // Incrementing burst\n                    m_wb_bte_o <= 2'b00;  // Linear burst\n                end\n\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    // Write domain logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read domain logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Binary to Gray conversion\n    always @* begin\n        wptr_bin_next = wptr_bin + (wr && !full);\n        rptr_bin_next = rptr_bin + (rd && !empty);\n        wptr_gray_next = (wptr_bin_next >> 1) ^ wptr_bin_next;\n        rptr_gray_next = (rptr_bin_next >> 1) ^ rptr_bin_next;\n    end\n\n    // Full and empty flag logic\n    always @* begin\n        full = (wptr_gray == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (wptr_gray == rptr_gray);\n        mem_empt = wptr_bin - rptr_bin;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                if (adr_i + 1 == adr_o) full <= 1;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i) empty <= 1;\n        end\n    end\n\n    // Full and Empty flag management\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else begin\n            if (adr_i == adr_o) begin\n                if (we[7]) full <= 1;\n                else empty <= 1;\n            end else begin\n                full <= 0;\n                empty <= 0;\n            end\n        end\n    end\n\n    // Memory empty space calculation\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 2'b11;\n        end else begin\n            mem_empt <= (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    // Write clock domain logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read clock domain logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Binary to Gray conversion\n    always @* begin\n        wptr_bin_next = wptr_bin + (wr && !full);\n        rptr_bin_next = rptr_bin + (rd && !empty);\n        wptr_gray_next = (wptr_bin_next >> 1) ^ wptr_bin_next;\n        rptr_gray_next = (rptr_bin_next >> 1) ^ rptr_bin_next;\n    end\n\n    // Full and empty flag generation\n    always @* begin\n        full = (wptr_gray == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (wptr_gray == rptr_gray);\n        mem_empt = wptr_bin - rptr_bin;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full, fifo_empty;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_cti_o <= 3'b000;\n                m_wb_bte_o <= 2'b00;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full, fifo_empty;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (!wb_free && m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 4, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules would be instantiated here following the same pattern\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 11, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter IDLE = 6'b000001;\n    parameter WRITE_DAT = 6'b000010;\n    parameter WRITE_CRC = 6'b000100;\n    parameter WRITE_BUSY = 6'b001000;\n    parameter READ_WAIT = 6'b010000;\n    parameter READ_DAT = 6'b100000;\n\n    // CRC_16_gen instantiation\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == BLOCK_SIZE)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == BLOCK_SIZE)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                    crc_ok <= 0;\n                end\n                WRITE_DAT: begin\n                    // Implement WRITE_DAT logic\n                end\n                WRITE_CRC: begin\n                    // Implement WRITE_CRC logic\n                end\n                WRITE_BUSY: begin\n                    // Implement WRITE_BUSY logic\n                end\n                READ_WAIT: begin\n                    // Implement READ_WAIT logic\n                end\n                READ_DAT: begin\n                    // Implement READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    // Write domain logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read domain logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Gray code conversion\n    always @(*) begin\n        wptr_bin_next = wptr_bin + (wr && !full);\n        wptr_gray_next = (wptr_bin_next >> 1) ^ wptr_bin_next;\n        rptr_bin_next = rptr_bin + (rd && !empty);\n        rptr_gray_next = (rptr_bin_next >> 1) ^ rptr_bin_next;\n    end\n\n    // Full and empty status\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n        end else begin\n            full <= (wptr_gray_next == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE], rptr_gray[FIFO_TX_MEM_ADR_SIZE-1:0]});\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            empty <= 1;\n        end else begin\n            empty <= (rptr_gray_next == wptr_gray);\n        end\n    end\n\n    // FIFO occupancy\n    always @(*) begin\n        mem_empt = wptr_bin - rptr_bin;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 12, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 1'b0;\n            ack_q <= 1'b0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO Block\n    always @(*) begin\n        case (state)\n            6'd0: begin // IDLE\n                if (start_dat == 2'b01) next_state = 6'd1; // WRITE_DAT\n                else if (start_dat == 2'b10) next_state = 6'd4; // READ_WAIT\n                else next_state = 6'd0; // IDLE\n            end\n            6'd1: begin // WRITE_DAT\n                if (transf_cnt == BIT_BLOCK) next_state = 6'd2; // WRITE_CRC\n                else next_state = 6'd1; // WRITE_DAT\n            end\n            6'd2: begin // WRITE_CRC\n                if (crc_status == 3'b000) next_state = 6'd3; // WRITE_BUSY\n                else next_state = 6'd2; // WRITE_CRC\n            end\n            6'd3: begin // WRITE_BUSY\n                if (!busy_int) next_state = 6'd0; // IDLE\n                else next_state = 6'd3; // WRITE_BUSY\n            end\n            6'd4: begin // READ_WAIT\n                if (!DAT_dat_i[0]) next_state = 6'd5; // READ_DAT\n                else next_state = 6'd4; // READ_WAIT\n            end\n            6'd5: begin // READ_DAT\n                if (transf_cnt == BIT_BLOCK_REC) next_state = 6'd0; // IDLE\n                else next_state = 6'd5; // READ_DAT\n            end\n            default: next_state = 6'd0; // Default to IDLE\n        endcase\n    end\n\n    // START_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else if (!DAT_dat_i[0] && state == 6'd4) begin\n            q_start_bit <= 1'b0;\n        end else begin\n            q_start_bit <= 1'b1;\n        end\n    end\n\n    // FSM_SEQ Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'd0; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 32'b0;\n            write_buf_1 <= 32'b0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'b0;\n            rd <= 1'b0;\n            last_din <= 4'b0;\n            crc_c <= 5'b0;\n            crc_in <= {SD_BUS_W{1'b0}};\n            DAT_dat_o <= {SD_BUS_W{1'b0}};\n            crc_status <= 3'b111;\n            crc_s <= 3'b0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            data_out <= {SD_BUS_W{1'b0}};\n            crc_ok <= 1'b0;\n            busy_int <= 1'b0;\n            data_send_index <= 3'b0;\n            out_buff_ptr <= 1'b0;\n            in_buff_ptr <= 1'b0;\n        end else begin\n            case (state)\n                6'd0: begin // IDLE\n                    crc_rst <= 1'b1;\n                    crc_en <= 1'b0;\n                    transf_cnt <= 11'b0;\n                    rd <= 1'b0;\n                    crc_c <= 5'b0;\n                    crc_in <= {SD_BUS_W{1'b0}};\n                    DAT_dat_o <= {SD_BUS_W{1'b0}};\n                    crc_status <= 3'b111;\n                    crc_s <= 3'b0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= {SD_BUS_W{1'b0}};\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'b0;\n                    out_buff_ptr <= 1'b0;\n                    in_buff_ptr <= 1'b0;\n                end\n                6'd1: begin // WRITE_DAT\n                    // Implement WRITE_DAT logic\n                end\n                6'd2: begin // WRITE_CRC\n                    // Implement WRITE_CRC logic\n                end\n                6'd3: begin // WRITE_BUSY\n                    // Implement WRITE_BUSY logic\n                end\n                6'd4: begin // READ_WAIT\n                    // Implement READ_WAIT logic\n                end\n                6'd5: begin // READ_DAT\n                    // Implement READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    // Write logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Pointer increment and gray code conversion\n    always @(*) begin\n        wptr_bin_next = wptr_bin + (wr && !full);\n        rptr_bin_next = rptr_bin + (rd && !empty);\n        wptr_gray_next = (wptr_bin_next >> 1) ^ wptr_bin_next;\n        rptr_gray_next = (rptr_bin_next >> 1) ^ rptr_bin_next;\n    end\n\n    // Full and empty flag logic\n    always @(*) begin\n        full = (wptr_gray_next == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (wptr_gray == rptr_gray);\n        mem_empt = wptr_bin - rptr_bin;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(rst)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Initialization on reset\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            if (en) begin\n                reset_tx_fifo <= 1'b0;\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    // Start Wishbone read transaction\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n\n                if (m_wb_ack_i) begin\n                    // Wishbone acknowledges\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    // Delay handling\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                // Disabled state handling\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rclk,\n    input wire rst,\n    input wire rd,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    // Write Pointer Management\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin_next = wptr_bin + 1;\n            wptr_gray_next = (wptr_bin_next >> 1) ^ wptr_bin_next;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read Pointer Management\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr_bin_next = rptr_bin + 1;\n            rptr_gray_next = (rptr_bin_next >> 1) ^ rptr_bin_next;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Full and Empty Status\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n        end else begin\n            full <= (wptr_gray_next == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE], rptr_gray[FIFO_TX_MEM_ADR_SIZE-1:0]});\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            empty <= 1;\n        end else begin\n            empty <= (wptr_gray == rptr_gray);\n        end\n    end\n\n    // FIFO Occupancy\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 0;\n        end else begin\n            mem_empt <= wptr_bin - rptr_bin;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 13, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen submodule instantiation\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO block\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01) begin\n                    next_state = WRITE_DAT;\n                end else if (start_dat == 2'b10) begin\n                    next_state = READ_WAIT;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = WRITE_CRC;\n                end else begin\n                    next_state = WRITE_DAT;\n                end\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000) begin\n                    next_state = WRITE_BUSY;\n                end else begin\n                    next_state = WRITE_CRC;\n                end\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = WRITE_BUSY;\n                end\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0) begin\n                    next_state = READ_DAT;\n                end else begin\n                    next_state = READ_WAIT;\n                end\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = READ_DAT;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else if (!DAT_dat_i[0] && state == READ_WAIT) begin\n            q_start_bit <= 0;\n        end else begin\n            q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                    crc_ok <= 0;\n                end\n                WRITE_DAT: begin\n                    // Implement WRITE_DAT logic\n                end\n                WRITE_CRC: begin\n                    // Implement WRITE_CRC logic\n                end\n                WRITE_BUSY: begin\n                    // Implement WRITE_BUSY logic\n                end\n                READ_WAIT: begin\n                    // Implement READ_WAIT logic\n                end\n                READ_DAT: begin\n                    // Implement READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    // Write logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Pointer binary to gray conversion\n    always @(*) begin\n        wptr_bin_next = wptr_bin + (wr && !full);\n        rptr_bin_next = rptr_bin + (rd && !empty);\n        wptr_gray_next = (wptr_bin_next >> 1) ^ wptr_bin_next;\n        rptr_gray_next = (rptr_bin_next >> 1) ^ rptr_bin_next;\n    end\n\n    // Full and empty status\n    always @(*) begin\n        full = (wptr_gray == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (wptr_gray == rptr_gray);\n        mem_empt = wptr_bin - rptr_bin;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(rst)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            if (en) begin\n                reset_tx_fifo <= 1'b0;\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                if (delay) begin\n                    offset <= offset + 9'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != 0) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != 0) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state = IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                        if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end else if (RAM_MEM_WIDTH == 16) begin\n                        if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                        if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                        if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                        if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                        if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                    end else if (RAM_MEM_WIDTH == 16) begin\n                        if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                        if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                        if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                        if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) rec_failed <= 1;\n                        else if (card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) rec_done <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && tx_empt) trans_failed <= 1;\n                    if (rx_cycle && rx_full) trans_failed <= 1;\n                    if (transm_complete) begin\n                        if (crc_ok) trans_done <= 1;\n                        else trans_failed <= 1;\n                    end\n                    if (trans_done || trans_failed) begin\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt == RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_counter;\n    reg [BD_WIDTH-1:0] read_counter;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n    wire new_bw;\n    assign new_bw = (write_counter == ((RAM_MEM_WIDTH == 32) ? 2 : 4));\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            last_a_cmp <= 0;\n            ack_o_s <= 0;\n        end else begin\n            if (we_m && (free_bd > 0)) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n                write_counter <= write_counter + 1;\n                if (new_bw) begin\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n                read_counter <= read_counter + 1;\n                if (RAM_MEM_WIDTH == 16) begin\n                    ack_o_s <= 1;\n                end\n                if (read_counter == ((RAM_MEM_WIDTH == 32) ? 2 : 4)) begin\n                    read_counter <= 0;\n                end\n            end else begin\n                ack_o_s <= 0;\n            end\n\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 32'b0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i == adr_o - 1) full <= 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 32'b0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i) empty <= 1;\n        end\n    end\n\n    always @(*) begin\n        if (rst) begin\n            mem_empt = 2'b11;\n        end else begin\n            mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else begin\n            if (adr_i == adr_o) begin\n                empty <= 1;\n                full <= 0;\n            end else if (adr_i == adr_o - 1) begin\n                full <= 1;\n                empty <= 0;\n            end else begin\n                full <= 0;\n                empty <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 14, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter IDLE = 6'b000001;\n    parameter WRITE_DAT = 6'b000010;\n    parameter WRITE_CRC = 6'b000100;\n    parameter WRITE_BUSY = 6'b001000;\n    parameter READ_WAIT = 6'b010000;\n    parameter READ_DAT = 6'b100000;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 1'b0;\n            ack_q <= 1'b0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO Block\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10) begin\n                    next_state = WRITE_DAT;\n                end else if (start_dat == 2'b01) begin\n                    next_state = READ_WAIT;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = WRITE_CRC;\n                end else begin\n                    next_state = WRITE_DAT;\n                end\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000) begin\n                    next_state = WRITE_BUSY;\n                end else begin\n                    next_state = WRITE_CRC;\n                end\n            end\n            WRITE_BUSY: begin\n                if (!busy_int) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = WRITE_BUSY;\n                end\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0]) begin\n                    next_state = READ_DAT;\n                end else begin\n                    next_state = READ_WAIT;\n                end\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = READ_DAT;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else if (!DAT_dat_i[0] && state == READ_WAIT) begin\n            q_start_bit <= 1'b0;\n        end else begin\n            q_start_bit <= 1'b1;\n        end\n    end\n\n    // FSM_SEQ Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 32'b0;\n            write_buf_1 <= 32'b0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'b0;\n            rd <= 1'b0;\n            last_din <= 4'b0;\n            crc_c <= 5'b0;\n            crc_in <= {SD_BUS_W{1'b0}};\n            DAT_dat_o <= {SD_BUS_W{1'b0}};\n            crc_status <= 3'b111;\n            crc_s <= 3'b0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            data_out <= {SD_BUS_W{1'b0}};\n            crc_ok <= 1'b0;\n            busy_int <= 1'b0;\n            data_send_index <= 3'b0;\n            out_buff_ptr <= 1'b0;\n            in_buff_ptr <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1'b1;\n                    crc_en <= 1'b0;\n                    transf_cnt <= 11'b0;\n                    rd <= 1'b0;\n                    crc_c <= 5'b0;\n                    crc_in <= {SD_BUS_W{1'b0}};\n                    DAT_dat_o <= {SD_BUS_W{1'b0}};\n                    crc_status <= 3'b111;\n                    crc_s <= 3'b0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= {SD_BUS_W{1'b0}};\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'b0;\n                    out_buff_ptr <= 1'b0;\n                    in_buff_ptr <= 1'b0;\n                end\n                WRITE_DAT: begin\n                    // Implement WRITE_DAT state logic\n                end\n                WRITE_CRC: begin\n                    // Implement WRITE_CRC state logic\n                end\n                WRITE_BUSY: begin\n                    // Implement WRITE_BUSY state logic\n                end\n                READ_WAIT: begin\n                    // Implement READ_WAIT state logic\n                end\n                READ_DAT: begin\n                    // Implement READ_DAT state logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 5, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    \n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    \n    // SDC IO\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional sub-modules would be instantiated here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[0]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i == adr_o - 1)\n                full <= 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i - 1)\n                empty <= 1;\n        end\n    end\n\n    always @(*) begin\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else begin\n            if (adr_i == adr_o)\n                empty <= 1;\n            else\n                empty <= 0;\n\n            if (adr_i == adr_o - 1)\n                full <= 1;\n            else\n                full <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    // Write logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i[FIFO_TX_MEM_ADR_SIZE-1:0]] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin_next = wptr_bin + 1;\n            wptr_gray_next = (wptr_bin_next >> 1) ^ wptr_bin_next;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-1:0]];\n            adr_o <= adr_o + 1;\n            rptr_bin_next = rptr_bin + 1;\n            rptr_gray_next = (rptr_bin_next >> 1) ^ rptr_bin_next;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Full and empty logic\n    always @(*) begin\n        full = (wptr_gray == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (wptr_gray == rptr_gray);\n        mem_empt = wptr_bin - rptr_bin;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // Asynchronous reset\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_o <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n            empty <= 1;\n        end else begin\n            // Write operation\n            if (wr && !full) begin\n                tmp <= {tmp[27:0], d};\n                we <= {we[6:0], 1'b1};\n                if (we == 8'h80) begin\n                    ram[adr_i] <= tmp;\n                    adr_i <= adr_i + 1;\n                    we <= 8'h1;\n                    ft <= 1;\n                end\n            end\n\n            // Full flag logic\n            if (adr_i == adr_o - 1) begin\n                full <= 1;\n            end else begin\n                full <= 0;\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else begin\n            // Read operation\n            if (rd && !empty) begin\n                q <= ram[adr_o];\n                adr_o <= adr_o + 1;\n            end\n\n            // Empty flag logic\n            if (adr_o == adr_i) begin\n                empty <= 1;\n            end else begin\n                empty <= 0;\n            end\n        end\n    end\n\n    // Memory empty space calculation\n    always @(*) begin\n        if (adr_i >= adr_o) begin\n            mem_empt = FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\n        end else begin\n            mem_empt = adr_o - adr_i;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 6, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules would be instantiated here following the same pattern\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39];\n                            CRC_OUT <= In_Buff[39];\n                            In_Buff <= {In_Buff[38:0], 1'b0};\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39];\n                            CRC_OUT <= In_Buff[39];\n                            In_Buff <= {In_Buff[38:0], 1'b0};\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff <= {Out_Buff[38:0], cmd_dat_i};\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= {CRC_IN[5:0], cmd_dat_i};\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                if (adr_i + 1 == adr_o) full <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i) empty <= 1;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 2'b11;\n        end else begin\n            if (adr_i == adr_o) begin\n                empty <= 1;\n                full <= 0;\n                mem_empt <= 2'b11;\n            end else if (adr_i > adr_o) begin\n                empty <= 0;\n                full <= (adr_i - adr_o == FIFO_RX_MEM_DEPTH);\n                mem_empt <= (adr_i - adr_o < 2) ? 2'b00 : 2'b01;\n            end else begin\n                empty <= 0;\n                full <= (adr_o - adr_i == 1);\n                mem_empt <= (adr_o - adr_i < 2) ? 2'b00 : 2'b01;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 15, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen instance\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 1'b0;\n            ack_q <= 1'b0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'd0: begin // IDLE\n                if (start_dat == 2'b01)\n                    next_state = 6'd1; // WRITE_DAT\n                else if (start_dat == 2'b10)\n                    next_state = 6'd4; // READ_WAIT\n                else\n                    next_state = 6'd0; // IDLE\n            end\n            6'd1: begin // WRITE_DAT\n                if (transf_cnt == BIT_BLOCK)\n                    next_state = 6'd2; // WRITE_CRC\n                else\n                    next_state = 6'd1; // WRITE_DAT\n            end\n            6'd2: begin // WRITE_CRC\n                if (crc_status == 3'b000)\n                    next_state = 6'd3; // WRITE_BUSY\n                else\n                    next_state = 6'd2; // WRITE_CRC\n            end\n            6'd3: begin // WRITE_BUSY\n                if (!busy_int)\n                    next_state = 6'd0; // IDLE\n                else\n                    next_state = 6'd3; // WRITE_BUSY\n            end\n            6'd4: begin // READ_WAIT\n                if (DAT_dat_i[0] == 1'b0)\n                    next_state = 6'd5; // READ_DAT\n                else\n                    next_state = 6'd4; // READ_WAIT\n            end\n            6'd5: begin // READ_DAT\n                if (transf_cnt == BIT_BLOCK_REC)\n                    next_state = 6'd0; // IDLE\n                else\n                    next_state = 6'd5; // READ_DAT\n            end\n            default: next_state = 6'd0; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else begin\n            if (!DAT_dat_i[0] && state == 6'd4)\n                q_start_bit <= 1'b0;\n            else\n                q_start_bit <= 1'b1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'd0; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 32'b0;\n            write_buf_1 <= 32'b0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'b0;\n            rd <= 1'b0;\n            last_din <= 4'b0;\n            crc_c <= 5'b0;\n            crc_in <= {SD_BUS_W{1'b0}};\n            DAT_dat_o <= {SD_BUS_W{1'b0}};\n            crc_status <= 3'b111;\n            crc_s <= 3'b0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            data_out <= {SD_BUS_W{1'b0}};\n            crc_ok <= 1'b0;\n            busy_int <= 1'b0;\n            data_send_index <= 3'b0;\n            out_buff_ptr <= 1'b0;\n            in_buff_ptr <= 1'b0;\n        end else begin\n            case (state)\n                6'd0: begin // IDLE\n                    crc_rst <= 1'b1;\n                    crc_en <= 1'b0;\n                    transf_cnt <= 11'b0;\n                    rd <= 1'b0;\n                    we <= 1'b0;\n                    busy_n <= 1'b1;\n                    transm_complete <= 1'b0;\n                end\n                6'd1: begin // WRITE_DAT\n                    // Logic for WRITE_DAT state\n                end\n                6'd2: begin // WRITE_CRC\n                    // Logic for WRITE_CRC state\n                end\n                6'd3: begin // WRITE_BUSY\n                    // Logic for WRITE_BUSY state\n                end\n                6'd4: begin // READ_WAIT\n                    // Logic for READ_WAIT state\n                end\n                6'd5: begin // READ_DAT\n                    // Logic for READ_DAT state\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    wire [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_sync, rptr_bin_sync;\n\n    // Write pointer management\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read pointer management\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Write pointer next value calculation\n    always @* begin\n        wptr_bin_next = wptr_bin + (wr && !full);\n        wptr_gray_next = (wptr_bin_next >> 1) ^ wptr_bin_next;\n        adr_i = wptr_bin[FIFO_TX_MEM_ADR_SIZE-1:0];\n    end\n\n    // Read pointer next value calculation\n    always @* begin\n        rptr_bin_next = rptr_bin + (rd && !empty);\n        rptr_gray_next = (rptr_bin_next >> 1) ^ rptr_bin_next;\n        adr_o = rptr_bin[FIFO_TX_MEM_ADR_SIZE-1:0];\n    end\n\n    // Synchronize pointers between clock domains\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            rptr_bin_sync <= 0;\n        end else begin\n            rptr_bin_sync <= rptr_bin;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            wptr_bin_sync <= 0;\n        end else begin\n            wptr_bin_sync <= wptr_bin;\n        end\n    end\n\n    // Full and empty flag management\n    always @* begin\n        full = (wptr_gray_next == {~rptr_gray_sync[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray_sync[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (wptr_gray_sync == rptr_gray);\n    end\n\n    // FIFO occupancy calculation\n    always @* begin\n        mem_empt = wptr_bin[FIFO_TX_MEM_ADR_SIZE-1:0] - rptr_bin[FIFO_TX_MEM_ADR_SIZE-1:0];\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            we <= 9'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            if (en) begin\n                reset_tx_fifo <= 1'b0;\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cti_o <= 3'b0;\n                    m_wb_bte_o <= 2'b0;\n                end\n\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode command settings\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 16, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en, crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int, ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter IDLE = 6'b000001;\n    parameter WRITE_DAT = 6'b000010;\n    parameter WRITE_CRC = 6'b000100;\n    parameter WRITE_BUSY = 6'b001000;\n    parameter READ_WAIT = 6'b010000;\n    parameter READ_DAT = 6'b100000;\n\n    // CRC_16_gen instance\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 1'b0;\n            ack_q <= 1'b0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 1'b0)\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT)\n                q_start_bit <= 1'b0;\n            else\n                q_start_bit <= 1'b1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 32'b0;\n            write_buf_1 <= 32'b0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'b0;\n            rd <= 1'b0;\n            last_din <= 4'b0;\n            crc_c <= 5'b0;\n            crc_in <= {SD_BUS_W{1'b0}};\n            DAT_dat_o <= {SD_BUS_W{1'b0}};\n            crc_status <= 3'b111;\n            crc_s <= 3'b0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            data_out <= {SD_BUS_W{1'b0}};\n            crc_ok <= 1'b0;\n            busy_int <= 1'b0;\n            data_send_index <= 3'b0;\n            out_buff_ptr <= 1'b0;\n            in_buff_ptr <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1'b1;\n                    crc_en <= 1'b0;\n                    transf_cnt <= 11'b0;\n                    rd <= 1'b0;\n                    crc_status <= 3'b111;\n                    crc_s <= 3'b0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= {SD_BUS_W{1'b0}};\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'b0;\n                    out_buff_ptr <= 1'b0;\n                    in_buff_ptr <= 1'b0;\n                end\n                WRITE_DAT: begin\n                    // Logic for WRITE_DAT state\n                end\n                WRITE_CRC: begin\n                    // Logic for WRITE_CRC state\n                end\n                WRITE_BUSY: begin\n                    // Logic for WRITE_BUSY state\n                end\n                READ_WAIT: begin\n                    // Logic for READ_WAIT state\n                end\n                READ_DAT: begin\n                    // Logic for READ_DAT state\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 7, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input wire card_detect\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Other sub-modules instantiation and interconnections go here...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 8, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire cmd_int_busy;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider sd_clock_divider_inst (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master sd_cmd_master_inst (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(),\n        .data_write(),\n        .data_read(),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(),\n        .NORMAL_INT_REG(),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host sd_cmd_serial_host_inst (\n        .SD_CLK_IN(sd_clk_o_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n\n    sd_data_master sd_data_master_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(),\n        .tx_full(),\n        .rx_full(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok(),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(),\n        .re_s_tx(),\n        .a_cmp_tx(),\n        .re_s_rx(),\n        .a_cmp_rx(),\n        .we_req(),\n        .d_write(),\n        .d_read(),\n        .cmd_arg(),\n        .cmd_set(),\n        .start_tx_fifo(),\n        .start_rx_fifo(),\n        .sys_adr(),\n        .ack_transfer(),\n        .Dat_Int_Status(),\n        .CIDAT()\n    );\n\n    // Additional logic for interrupts\n    assign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) ? 1'b1 : 1'b0;\n    assign int_b = (error_int_status_reg & error_int_signal_enable_reg) ? 1'b1 : 1'b0;\n    assign int_c = (Bd_isr_reg & Bd_isr_enable_reg) ? 1'b1 : 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 17, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen submodule instantiation\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO block\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01) next_state = WRITE_DAT;\n                else if (start_dat == 2'b10) next_state = READ_WAIT;\n                else next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = WRITE_CRC;\n                else next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000) next_state = WRITE_BUSY;\n                else next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int) next_state = IDLE;\n                else next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0) next_state = READ_DAT;\n                else next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = IDLE;\n                else next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT) q_start_bit <= 0;\n            else q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                    crc_ok <= 0;\n                end\n                WRITE_DAT: begin\n                    // Logic for writing data\n                end\n                WRITE_CRC: begin\n                    // Logic for CRC generation\n                end\n                WRITE_BUSY: begin\n                    // Logic for busy state\n                end\n                READ_WAIT: begin\n                    // Logic for read wait\n                end\n                READ_DAT: begin\n                    // Logic for reading data\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 9, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    \n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    \n    // SDC IO\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider sd_clock_divider_inst (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master sd_cmd_master_inst (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(),\n        .data_write(),\n        .data_read(),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(),\n        .NORMAL_INT_REG(),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host sd_cmd_serial_host_inst (\n        .SD_CLK_IN(sd_clk_o_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n\n    sd_data_master sd_data_master_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(),\n        .we_ack(),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(),\n        .tx_full(),\n        .rx_full(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok(),\n        .Dat_Int_Status_rst(),\n        .transfer_type(),\n        .re_s_tx(),\n        .a_cmp_tx(),\n        .re_s_rx(),\n        .a_cmp_rx(),\n        .we_req(),\n        .d_write(),\n        .d_read(),\n        .cmd_arg(),\n        .cmd_set(),\n        .start_tx_fifo(),\n        .start_rx_fifo(),\n        .sys_adr(),\n        .ack_transfer(),\n        .Dat_Int_Status(),\n        .CIDAT()\n    );\n\n    sd_data_serial_host sd_data_serial_host_inst (\n        .sd_clk(sd_clk_o_pad),\n        .rst(wb_rst_i),\n        .data_in(),\n        .start_dat(),\n        .ack_transfer(),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(),\n        .data_out(sd_dat_out_o),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok()\n    );\n\n    // Additional logic for interrupts and other functionalities\n    assign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) ? 1'b1 : 1'b0;\n    assign int_b = (error_int_status_reg & error_int_signal_enable_reg) ? 1'b1 : 1'b0;\n    assign int_c = (Bd_isr_reg & Bd_isr_enable_reg) ? 1'b1 : 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 18, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen submodule instantiation\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[i*16 +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO block\n    always @(*) begin\n        case (state)\n            6'b000000: begin // IDLE\n                if (start_dat == 2'b10) next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b01) next_state = 6'b000100; // READ_WAIT\n                else next_state = 6'b000000; // IDLE\n            end\n            6'b000001: begin // WRITE_DAT\n                if (transf_cnt == BIT_BLOCK) next_state = 6'b000010; // WRITE_CRC\n                else next_state = 6'b000001; // WRITE_DAT\n            end\n            6'b000010: begin // WRITE_CRC\n                if (crc_status == 3'b000) next_state = 6'b000011; // WRITE_BUSY\n                else next_state = 6'b000010; // WRITE_CRC\n            end\n            6'b000011: begin // WRITE_BUSY\n                if (busy_int == 0) next_state = 6'b000000; // IDLE\n                else next_state = 6'b000011; // WRITE_BUSY\n            end\n            6'b000100: begin // READ_WAIT\n                if (DAT_dat_i[0] == 0) next_state = 6'b000101; // READ_DAT\n                else next_state = 6'b000100; // READ_WAIT\n            end\n            6'b000101: begin // READ_DAT\n                if (transf_cnt == BIT_BLOCK_REC) next_state = 6'b000000; // IDLE\n                else next_state = 6'b000101; // READ_DAT\n            end\n            default: next_state = 6'b000000; // IDLE\n        endcase\n    end\n\n    // START_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else if (!DAT_dat_i[0] && state == 6'b000100) begin\n            q_start_bit <= 0;\n        end else begin\n            q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                end\n                6'b000001: begin // WRITE_DAT\n                    if (transf_cnt < BIT_BLOCK) begin\n                        if (transf_cnt[4:0] == 5'b11100) begin\n                            out_buff_ptr <= ~out_buff_ptr;\n                            sd_data_out <= (out_buff_ptr) ? write_buf_1 : write_buf_0;\n                        end\n                        last_din <= sd_data_out[31:28];\n                        crc_in <= sd_data_out[31:28];\n                        DAT_dat_o <= last_din;\n                        sd_data_out <= {sd_data_out[27:0], 4'b0};\n                        transf_cnt <= transf_cnt + 1;\n                    end\n                end\n                6'b000010: begin // WRITE_CRC\n                    if (crc_c < 5'd16) begin\n                        crc_c <= crc_c + 1;\n                    end else begin\n                        crc_status <= crc_out[15:13];\n                        crc_s <= crc_out[15:13];\n                    end\n                end\n                6'b000011: begin // WRITE_BUSY\n                    if (DAT_dat_i[0] == 0) begin\n                        busy_int <= 0;\n                        transm_complete <= 1;\n                        crc_ok <= (crc_s == 3'b010);\n                    end else begin\n                        busy_int <= 1;\n                    end\n                end\n                6'b000100: begin // READ_WAIT\n                    crc_rst <= 0;\n                    crc_en <= 1;\n                    DAT_oe_o <= 0;\n                    transf_cnt <= 0;\n                    crc_c <= 0;\n                end\n                6'b000101: begin // READ_DAT\n                    if (transf_cnt < BIT_BLOCK_REC) begin\n                        data_out <= DAT_dat_i;\n                        crc_in <= DAT_dat_i;\n                        transf_cnt <= transf_cnt + 1;\n                        we <= 1;\n                    end else begin\n                        we <= 0;\n                        crc_ok <= (crc_out == DAT_dat_i);\n                        transm_complete <= 1;\n                        busy_n <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 10, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n\n    // Instantiate sub-modules\n    sd_controller_wb u_sd_controller_wb (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional sub-modules would be instantiated here following the same pattern\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 11, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // Card Detect\n    input wire card_detect,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [31:0] cmd_resp_1;\n    wire [15:0] status_reg;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional sub-modules would be instantiated here...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 19, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 0;\n        we_m_tx_bd <= 0;\n        we_m_rx_bd <= 0;\n        new_cmd <= 0;\n        we_ack <= 0;\n        int_ack <= 1;\n        cmd_int_busy <= 0;\n        int_busy <= 0;\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n        dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n    end else begin\n        if (wb_cyc_i && wb_stb_i && ~wb_ack_o) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1;\n                    8'h34: error_isr_reset <= 1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h00000000;\n                    8'h20: wb_dat_o <= 32'h00000200;\n                    8'h24: wb_dat_o <= 32'h0000000f;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000;\n                    8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n            int_ack <= 1;\n            we_m_rx_bd <= 0;\n            we_m_tx_bd <= 0;\n            Bd_isr_reset <= 0;\n            normal_isr_reset <= 0;\n            error_isr_reset <= 0;\n        end\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (write_req_s) begin\n        we_ack <= 1;\n    end else begin\n        we_ack <= 0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s != 16'h0000 || cmd_arg_s != 32'h00000000) begin\n        new_cmd <= 1;\n    end else begin\n        new_cmd <= 0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s != 16'h0000) begin\n        cmd_int_busy <= 1;\n    end else begin\n        cmd_int_busy <= 0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (wb_adr_i == 8'h04 && wb_we_i) begin\n        int_busy <= 1;\n    end else begin\n        int_busy <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + {23'b0, offset};\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // Asynchronous reset\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 32'b0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i == adr_o - 1)\n                full <= 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 32'b0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i)\n                empty <= 1;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 2'b11;\n        end else begin\n            if (adr_i == adr_o) begin\n                if (ft)\n                    empty <= 0;\n                else\n                    empty <= 1;\n                full <= 0;\n            end else if (adr_i > adr_o) begin\n                mem_empt <= (adr_i - adr_o) < 2 ? 2'b01 : 2'b00;\n                full <= (adr_i - adr_o) == FIFO_RX_MEM_DEPTH - 1;\n                empty <= 0;\n            end else begin\n                mem_empt <= (FIFO_RX_MEM_DEPTH - adr_o + adr_i) < 2 ? 2'b01 : 2'b00;\n                full <= (FIFO_RX_MEM_DEPTH - adr_o + adr_i) == FIFO_RX_MEM_DEPTH - 1;\n                empty <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rclk,\n    input wire rst,\n    input wire rd,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Full and empty status\n    always @(*) begin\n        full = (wptr_gray_next == {~rptr_gray[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (wptr_gray == rptr_gray);\n        mem_empt = wptr_bin - rptr_bin;\n    end\n\n    // Gray code conversion\n    always @(*) begin\n        wptr_bin_next = wptr_bin + (wr && !full);\n        rptr_bin_next = rptr_bin + (rd && !empty);\n        wptr_gray_next = (wptr_bin_next >> 1) ^ wptr_bin_next;\n        rptr_gray_next = (rptr_bin_next >> 1) ^ rptr_bin_next;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 12, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // Card Detect\n    input wire card_detect,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules would be instantiated here...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] adr_i_gray, adr_o_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] adr_i_gray_sync, adr_o_gray_sync;\n\n    // Gray code conversion\n    function [FIFO_TX_MEM_ADR_SIZE:0] bin2gray;\n        input [FIFO_TX_MEM_ADR_SIZE:0] bin;\n        bin2gray = bin ^ (bin >> 1);\n    endfunction\n\n    // Gray code to binary conversion\n    function [FIFO_TX_MEM_ADR_SIZE:0] gray2bin;\n        input [FIFO_TX_MEM_ADR_SIZE:0] gray;\n        integer i;\n        begin\n            gray2bin[FIFO_TX_MEM_ADR_SIZE] = gray[FIFO_TX_MEM_ADR_SIZE];\n            for (i = FIFO_TX_MEM_ADR_SIZE-1; i >= 0; i = i - 1)\n                gray2bin[i] = gray2bin[i+1] ^ gray[i];\n        end\n    endfunction\n\n    // Write logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_i_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i[FIFO_TX_MEM_ADR_SIZE-1:0]] <= d;\n            adr_i <= adr_i + 1;\n            adr_i_gray <= bin2gray(adr_i + 1);\n        end\n    end\n\n    // Read logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            adr_o_gray <= 0;\n            q <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o[FIFO_TX_MEM_ADR_SIZE-1:0]];\n            adr_o <= adr_o + 1;\n            adr_o_gray <= bin2gray(adr_o + 1);\n        end\n    end\n\n    // Synchronize gray pointers across clock domains\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_o_gray_sync <= 0;\n        end else begin\n            adr_o_gray_sync <= adr_o_gray;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_i_gray_sync <= 0;\n        end else begin\n            adr_i_gray_sync <= adr_i_gray;\n        end\n    end\n\n    // Full and empty flag logic\n    always @(*) begin\n        full = (adr_i_gray == {~adr_o_gray_sync[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], adr_o_gray_sync[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (adr_i_gray_sync == adr_o_gray);\n    end\n\n    // FIFO occupancy calculation\n    always @(*) begin\n        mem_empt = adr_i - adr_o;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 13, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // Card Detect\n    input wire card_detect,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n\n    // Interrupts\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules instantiation and connections would go here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            we <= 9'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            reset_tx_fifo <= 1'b0;\n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cti_o <= 3'b000;\n                    m_wb_bte_o <= 2'b00;\n                end\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                if (delay) begin\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo sub-module\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            we <= 9'd0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else begin\n            reset_tx_fifo <= 1'b0;\n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + {23'd0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cti_o <= 3'b000;\n                    m_wb_bte_o <= 2'b00;\n                end\n\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    offset <= offset + 9'd1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'd0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 14, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    \n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    \n    // SDC IO\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules would be instantiated here following similar patterns\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin, rptr_bin;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_next, rptr_bin_next;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_next, rptr_gray_next;\n\n    wire [FIFO_TX_MEM_ADR_SIZE:0] wptr_bin_sync, rptr_bin_sync;\n\n    // Write Pointer Management\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            wptr_bin <= wptr_bin_next;\n            wptr_gray <= wptr_gray_next;\n        end\n    end\n\n    // Read Pointer Management\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            rptr_bin <= rptr_bin_next;\n            rptr_gray <= rptr_gray_next;\n        end\n    end\n\n    // Write Pointer Next Calculation\n    always @* begin\n        wptr_bin_next = wptr_bin + (wr && !full);\n        wptr_gray_next = (wptr_bin_next >> 1) ^ wptr_bin_next;\n        adr_i = wptr_bin[FIFO_TX_MEM_ADR_SIZE-1:0];\n    end\n\n    // Read Pointer Next Calculation\n    always @* begin\n        rptr_bin_next = rptr_bin + (rd && !empty);\n        rptr_gray_next = (rptr_bin_next >> 1) ^ rptr_bin_next;\n        adr_o = rptr_bin[FIFO_TX_MEM_ADR_SIZE-1:0];\n    end\n\n    // Synchronize Write Pointer to Read Clock Domain\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_sync1, wptr_gray_sync2;\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            wptr_gray_sync1 <= 0;\n            wptr_gray_sync2 <= 0;\n        end else begin\n            wptr_gray_sync1 <= wptr_gray;\n            wptr_gray_sync2 <= wptr_gray_sync1;\n        end\n    end\n\n    // Synchronize Read Pointer to Write Clock Domain\n    reg [FIFO_TX_MEM_ADR_SIZE:0] rptr_gray_sync1, rptr_gray_sync2;\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            rptr_gray_sync1 <= 0;\n            rptr_gray_sync2 <= 0;\n        end else begin\n            rptr_gray_sync1 <= rptr_gray;\n            rptr_gray_sync2 <= rptr_gray_sync1;\n        end\n    end\n\n    // Convert Gray Code to Binary\n    function [FIFO_TX_MEM_ADR_SIZE:0] gray_to_bin;\n        input [FIFO_TX_MEM_ADR_SIZE:0] gray;\n        integer i;\n        begin\n            gray_to_bin[FIFO_TX_MEM_ADR_SIZE] = gray[FIFO_TX_MEM_ADR_SIZE];\n            for (i = FIFO_TX_MEM_ADR_SIZE-1; i >= 0; i = i - 1) begin\n                gray_to_bin[i] = gray_to_bin[i+1] ^ gray[i];\n            end\n        end\n    endfunction\n\n    assign wptr_bin_sync = gray_to_bin(wptr_gray_sync2);\n    assign rptr_bin_sync = gray_to_bin(rptr_gray_sync2);\n\n    // Full and Empty Flags\n    always @* begin\n        full = (wptr_gray_next == {~rptr_bin_sync[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_bin_sync[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (wptr_bin_sync == rptr_bin_sync);\n        mem_empt = wptr_bin_sync - rptr_bin_sync;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n    \n    // FSM states\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational logic for next state\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = INIT;\n            end\n        endcase\n    end\n\n    // FSM_SEQ: Sequential logic for state update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Ack_internal_in <= 0;\n            q1 <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= {CRC_IN[5:0], cmd_dat_i};\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                            if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                            if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                            if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                            if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        if (transm_complete && crc_ok) begin\n                            trans_done <= 1;\n                            a_cmp_tx <= 1;\n                        end else if (!crc_ok) begin\n                            trans_failed <= 1;\n                        end\n                    end else if (rx_cycle && !rx_full) begin\n                        if (transm_complete && crc_ok) begin\n                            trans_done <= 1;\n                            a_cmp_rx <= 1;\n                        end else if (!crc_ok) begin\n                            trans_failed <= 1;\n                        end\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt == RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 19, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 1'b0;\n            ack_q <= 1'b0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO Block\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01) begin\n                    next_state = WRITE_DAT;\n                end else if (start_dat == 2'b10) begin\n                    next_state = READ_WAIT;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = WRITE_CRC;\n                end else begin\n                    next_state = WRITE_DAT;\n                end\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000) begin\n                    next_state = WRITE_BUSY;\n                end else begin\n                    next_state = WRITE_CRC;\n                end\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 1'b0) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = WRITE_BUSY;\n                end\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 1'b0) begin\n                    next_state = READ_DAT;\n                end else begin\n                    next_state = READ_WAIT;\n                end\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = READ_DAT;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // START_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else if (!DAT_dat_i[0] && state == READ_WAIT) begin\n            q_start_bit <= 1'b0;\n        end else begin\n            q_start_bit <= 1'b1;\n        end\n    end\n\n    // FSM_SEQ Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 32'b0;\n            write_buf_1 <= 32'b0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'b0;\n            rd <= 1'b0;\n            last_din <= 4'b0;\n            crc_c <= 5'b0;\n            crc_in <= {SD_BUS_W{1'b0}};\n            DAT_dat_o <= {SD_BUS_W{1'b0}};\n            crc_status <= 3'b111;\n            crc_s <= 3'b0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            data_out <= {SD_BUS_W{1'b0}};\n            crc_ok <= 1'b0;\n            busy_int <= 1'b0;\n            data_send_index <= 3'b0;\n            out_buff_ptr <= 1'b0;\n            in_buff_ptr <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1'b1;\n                    crc_en <= 1'b0;\n                    transf_cnt <= 11'b0;\n                    rd <= 1'b0;\n                    we <= 1'b0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                end\n                WRITE_DAT: begin\n                    // Logic for WRITE_DAT state\n                end\n                WRITE_CRC: begin\n                    // Logic for WRITE_CRC state\n                end\n                WRITE_BUSY: begin\n                    // Logic for WRITE_BUSY state\n                end\n                READ_WAIT: begin\n                    // Logic for READ_WAIT state\n                end\n                READ_DAT: begin\n                    // Logic for READ_DAT state\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 15, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input wire card_detect\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider sd_clock_divider_inst (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master sd_cmd_master_inst (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(ERR_INT_REG),\n        .NORMAL_INT_REG(NORMAL_INT_REG),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(settings),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host sd_cmd_serial_host_inst (\n        .SD_CLK_IN(sd_clk_o_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(settings),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_out),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(cmd_in),\n        .ACK_OUT(ack_in),\n        .REQ_OUT(req_in),\n        .STATUS(serial_status),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t(st_dat_t)\n    );\n\n    sd_data_master sd_data_master_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(cmd_tsf_err),\n        .card_status(card_status),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n\n    sd_data_serial_host sd_data_serial_host_inst (\n        .sd_clk(sd_clk_o_pad),\n        .rst(wb_rst_i),\n        .data_in(dat_in_m_tx_bd),\n        .start_dat(st_dat_t),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(rd),\n        .data_out(sd_dat_out_o),\n        .we(we),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(sd_dat_out_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n\n    rx_bd rx_bd_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_i_s_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s_rx)\n    );\n\n    tx_bd tx_bd_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(free_tx_bd),\n        .re_s(re_s_tx),\n        .ack_o_s(ack_i_s_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s(dat_out_s_tx)\n    );\n\n    sd_fifo_tx_filler sd_fifo_tx_filler_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o_pad),\n        .dat_o(dat_out_s_tx),\n        .rd(rd),\n        .empty(tx_empt),\n        .fe(tx_full)\n    );\n\n    sd_fifo_rx_filler sd_fifo_rx_filler_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o_pad),\n        .dat_i(sd_dat_out_o),\n        .wr(we),\n        .full(rx_full)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 16, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider sd_clock_divider_inst (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master sd_cmd_master_inst (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(),\n        .data_write(),\n        .data_read(),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(),\n        .NORMAL_INT_REG(),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host sd_cmd_serial_host_inst (\n        .SD_CLK_IN(sd_clk_o_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n\n    sd_data_master sd_data_master_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(),\n        .we_ack(),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(),\n        .tx_full(),\n        .rx_full(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok(),\n        .Dat_Int_Status_rst(),\n        .transfer_type(),\n        .re_s_tx(),\n        .a_cmp_tx(),\n        .re_s_rx(),\n        .a_cmp_rx(),\n        .we_req(),\n        .d_write(),\n        .d_read(),\n        .cmd_arg(),\n        .cmd_set(),\n        .start_tx_fifo(),\n        .start_rx_fifo(),\n        .sys_adr(),\n        .ack_transfer(),\n        .Dat_Int_Status(),\n        .CIDAT()\n    );\n\n    sd_data_serial_host sd_data_serial_host_inst (\n        .sd_clk(sd_clk_o_pad),\n        .rst(wb_rst_i),\n        .data_in(),\n        .start_dat(),\n        .ack_transfer(),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(),\n        .data_out(sd_dat_out_o),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok()\n    );\n\n    rx_bd rx_bd_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(),\n        .dat_in_m(),\n        .free_bd(),\n        .re_s(),\n        .ack_o_s(),\n        .a_cmp(),\n        .dat_out_s()\n    );\n\n    tx_bd tx_bd_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(),\n        .dat_in_m(),\n        .free_bd(),\n        .re_s(),\n        .ack_o_s(),\n        .a_cmp(),\n        .dat_out_s()\n    );\n\n    sd_fifo_tx_filler sd_fifo_tx_filler_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(),\n        .adr(),\n        .sd_clk(sd_clk_o_pad),\n        .dat_o(),\n        .rd(),\n        .empty(),\n        .fe()\n    );\n\n    sd_fifo_rx_filler sd_fifo_rx_filler_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(),\n        .adr(),\n        .sd_clk(sd_clk_o_pad),\n        .dat_i(sd_dat_dat_i),\n        .wr(),\n        .full()\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 20, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter IDLE = 6'b000001;\n    parameter WRITE_DAT = 6'b000010;\n    parameter WRITE_CRC = 6'b000100;\n    parameter WRITE_BUSY = 6'b001000;\n    parameter READ_WAIT = 6'b010000;\n    parameter READ_DAT = 6'b100000;\n\n    // CRC_16_gen submodule instantiation\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 1'b0;\n            ack_q <= 1'b0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO block\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b10)\n                    next_state = READ_WAIT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT)\n                q_start_bit <= 1'b0;\n            else\n                q_start_bit <= 1'b1;\n        end\n    end\n\n    // FSM_SEQ block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 32'b0;\n            write_buf_1 <= 32'b0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'b0;\n            rd <= 1'b0;\n            last_din <= 4'b0;\n            crc_c <= 5'b0;\n            crc_in <= {SD_BUS_W{1'b0}};\n            DAT_dat_o <= {SD_BUS_W{1'b0}};\n            crc_status <= 3'b111;\n            crc_s <= 3'b0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            data_out <= {SD_BUS_W{1'b0}};\n            crc_ok <= 1'b0;\n            busy_int <= 1'b0;\n            data_send_index <= 3'b0;\n            out_buff_ptr <= 1'b0;\n            in_buff_ptr <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1'b1;\n                    crc_en <= 1'b0;\n                    transf_cnt <= 11'b0;\n                    rd <= 1'b0;\n                    we <= 1'b0;\n                    busy_n <= 1'b1;\n                    transm_complete <= 1'b0;\n                end\n                WRITE_DAT: begin\n                    if (transf_cnt < SD_BUS_W) begin\n                        if (out_buff_ptr == 1'b0) begin\n                            sd_data_out <= write_buf_0;\n                        end else begin\n                            sd_data_out <= write_buf_1;\n                        end\n                        DAT_dat_o <= last_din;\n                        crc_in <= last_din;\n                        crc_en <= 1'b1;\n                        if (transf_cnt == 28) begin\n                            out_buff_ptr <= ~out_buff_ptr;\n                        end\n                        transf_cnt <= transf_cnt + 1;\n                    end\n                end\n                WRITE_CRC: begin\n                    crc_en <= 1'b0;\n                    crc_rst <= 1'b0;\n                    crc_status <= crc_out[15:0] == DAT_dat_i[15:0] ? 3'b000 : 3'b111;\n                end\n                WRITE_BUSY: begin\n                    transm_complete <= 1'b1;\n                    crc_ok <= (crc_status == 3'b000);\n                    busy_int <= DAT_dat_i[0];\n                end\n                READ_WAIT: begin\n                    crc_rst <= 1'b0;\n                    crc_en <= 1'b1;\n                    DAT_oe_o <= 1'b0;\n                    busy_n <= 1'b0;\n                end\n                READ_DAT: begin\n                    if (transf_cnt < SD_BUS_W) begin\n                        data_out <= DAT_dat_i;\n                        crc_in <= DAT_dat_i;\n                        transf_cnt <= transf_cnt + 1;\n                        we <= 1'b1;\n                    end else begin\n                        we <= 1'b0;\n                        crc_ok <= (crc_out[15:0] == DAT_dat_i[15:0]);\n                        transm_complete <= 1'b1;\n                        busy_n <= 1'b1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 17, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input wire card_detect\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb u_sd_controller_wb (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider u_sd_clock_divider (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master u_sd_cmd_master (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(),\n        .data_write(),\n        .data_read(),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(),\n        .NORMAL_INT_REG(),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host u_sd_cmd_serial_host (\n        .SD_CLK_IN(sd_clk_o_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n\n    sd_data_master u_sd_data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(),\n        .we_ack(),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(),\n        .tx_full(),\n        .rx_full(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok(),\n        .Dat_Int_Status_rst(),\n        .transfer_type(),\n        .re_s_tx(),\n        .a_cmp_tx(),\n        .re_s_rx(),\n        .a_cmp_rx(),\n        .we_req(),\n        .d_write(),\n        .d_read(),\n        .cmd_arg(),\n        .cmd_set(),\n        .start_tx_fifo(),\n        .start_rx_fifo(),\n        .sys_adr(),\n        .ack_transfer(),\n        .Dat_Int_Status(),\n        .CIDAT()\n    );\n\n    sd_data_serial_host u_sd_data_serial_host (\n        .sd_clk(sd_clk_o_pad),\n        .rst(wb_rst_i),\n        .data_in(),\n        .start_dat(),\n        .ack_transfer(),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(),\n        .data_out(sd_dat_out_o),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok()\n    );\n\n    rx_bd u_rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(),\n        .re_s(),\n        .ack_o_s(),\n        .a_cmp(),\n        .dat_out_s()\n    );\n\n    tx_bd u_tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(),\n        .re_s(),\n        .ack_o_s(),\n        .a_cmp(),\n        .dat_out_s()\n    );\n\n    sd_fifo_tx_filler u_sd_fifo_tx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(),\n        .adr(),\n        .sd_clk(sd_clk_o_pad),\n        .dat_o(),\n        .rd(),\n        .empty(),\n        .fe()\n    );\n\n    sd_fifo_rx_filler u_sd_fifo_rx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(),\n        .adr(),\n        .sd_clk(sd_clk_o_pad),\n        .dat_i(sd_dat_dat_i),\n        .wr(),\n        .full()\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 8'b0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[8 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[8 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Ack_internal_in <= 0;\n            q1 <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode command settings\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) CRC_OUT <= CRC_VAL[6];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                        if (Cmd_Cnt > 9) CRC_OUT <= CRC_VAL[6];\n                        st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_inst (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 18, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input wire card_detect\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider sd_clock_divider_inst (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master sd_cmd_master_inst (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(),\n        .data_write(),\n        .data_read(),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(),\n        .NORMAL_INT_REG(),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host sd_cmd_serial_host_inst (\n        .SD_CLK_IN(sd_clk_o_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n\n    sd_data_master sd_data_master_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(),\n        .we_ack(),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(),\n        .tx_full(),\n        .rx_full(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok(),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(),\n        .re_s_tx(),\n        .a_cmp_tx(),\n        .re_s_rx(),\n        .a_cmp_rx(),\n        .we_req(),\n        .d_write(),\n        .d_read(),\n        .cmd_arg(),\n        .cmd_set(),\n        .start_tx_fifo(),\n        .start_rx_fifo(),\n        .sys_adr(),\n        .ack_transfer(),\n        .Dat_Int_Status(),\n        .CIDAT()\n    );\n\n    // Additional sub-modules instantiation and connections can be added here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 19, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Module instantiations\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider sd_clock_divider_inst (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master sd_cmd_master_inst (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(),\n        .data_write(),\n        .data_read(),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host sd_cmd_serial_host_inst (\n        .SD_CLK_IN(sd_clk_o_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n\n    sd_data_master sd_data_master_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(),\n        .we_ack(),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(),\n        .tx_full(),\n        .rx_full(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok(),\n        .Dat_Int_Status_rst(),\n        .transfer_type(),\n        .re_s_tx(),\n        .a_cmp_tx(),\n        .re_s_rx(),\n        .a_cmp_rx(),\n        .we_req(),\n        .d_write(),\n        .d_read(),\n        .cmd_arg(),\n        .cmd_set(),\n        .start_tx_fifo(),\n        .start_rx_fifo(),\n        .sys_adr(),\n        .ack_transfer(),\n        .Dat_Int_Status(),\n        .CIDAT()\n    );\n\n    sd_data_serial_host sd_data_serial_host_inst (\n        .sd_clk(sd_clk_o_pad),\n        .rst(wb_rst_i),\n        .data_in(),\n        .start_dat(),\n        .ack_transfer(),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(),\n        .data_out(sd_dat_out_o),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok()\n    );\n\n    rx_bd rx_bd_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(),\n        .dat_in_m(),\n        .free_bd(),\n        .re_s(),\n        .ack_o_s(),\n        .a_cmp(),\n        .dat_out_s()\n    );\n\n    tx_bd tx_bd_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(),\n        .dat_in_m(),\n        .free_bd(),\n        .re_s(),\n        .ack_o_s(),\n        .a_cmp(),\n        .dat_out_s()\n    );\n\n    sd_fifo_tx_filler sd_fifo_tx_filler_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(),\n        .adr(),\n        .sd_clk(sd_clk_o_pad),\n        .dat_o(),\n        .rd(),\n        .empty(),\n        .fe()\n    );\n\n    sd_fifo_rx_filler sd_fifo_rx_filler_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(),\n        .adr(),\n        .sd_clk(sd_clk_o_pad),\n        .dat_i(sd_dat_dat_i),\n        .wr(),\n        .full()\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 20, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input wire card_detect\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider sd_clock_divider_inst (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master sd_cmd_master_inst (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(),\n        .data_write(),\n        .data_read(),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host sd_cmd_serial_host_inst (\n        .SD_CLK_IN(sd_clk_o_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n\n    sd_data_master sd_data_master_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(),\n        .we_ack(),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(),\n        .tx_full(),\n        .rx_full(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok(),\n        .Dat_Int_Status_rst(),\n        .transfer_type(),\n        .re_s_tx(),\n        .a_cmp_tx(),\n        .re_s_rx(),\n        .a_cmp_rx(),\n        .we_req(),\n        .d_write(),\n        .d_read(),\n        .cmd_arg(),\n        .cmd_set(),\n        .start_tx_fifo(),\n        .start_rx_fifo(),\n        .sys_adr(),\n        .ack_transfer(),\n        .Dat_Int_Status(),\n        .CIDAT()\n    );\n\n    sd_data_serial_host sd_data_serial_host_inst (\n        .sd_clk(sd_clk_o_pad),\n        .rst(wb_rst_i),\n        .data_in(),\n        .start_dat(),\n        .ack_transfer(),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(),\n        .data_out(sd_dat_out_o),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok()\n    );\n\n    rx_bd rx_bd_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(),\n        .dat_in_m(),\n        .free_bd(),\n        .re_s(),\n        .ack_o_s(),\n        .a_cmp(),\n        .dat_out_s()\n    );\n\n    tx_bd tx_bd_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(),\n        .dat_in_m(),\n        .free_bd(),\n        .re_s(),\n        .ack_o_s(),\n        .a_cmp(),\n        .dat_out_s()\n    );\n\n    sd_fifo_tx_filler sd_fifo_tx_filler_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(),\n        .adr(),\n        .sd_clk(sd_clk_o_pad),\n        .dat_o(),\n        .rd(),\n        .empty(),\n        .fe()\n    );\n\n    sd_fifo_rx_filler sd_fifo_rx_filler_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(),\n        .adr(),\n        .sd_clk(sd_clk_o_pad),\n        .dat_i(sd_dat_dat_i),\n        .wr(),\n        .full()\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end else begin\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_tx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_tx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                    bd_cnt <= bd_cnt + 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                        end\n                    end else begin\n                        if (bd_cnt == 0) begin\n                            sys_adr[15:0] <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[31:16] <= dat_in_rx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[15:0] <= dat_in_rx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                    bd_cnt <= bd_cnt + 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] == 1 && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational logic for next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential logic for state update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode settings and command\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 20, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Internal registers\n    reg [31:0] reg_file [0:15];\n    reg [1:0] bd_write_state;\n    reg [RAM_MEM_WIDTH-1:0] bd_data;\n\n    // Address decoding\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            argument_reg <= 32'h0000;\n            cmd_setting_reg <= 16'h0000;\n            software_reset_reg <= 8'h00;\n            time_out_reg <= 16'h0000;\n            normal_int_signal_enable_reg <= 16'h0000;\n            error_int_signal_enable_reg <= 16'h0000;\n            clock_divider <= 8'h00;\n            Bd_isr_enable_reg <= 8'h00;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            bd_write_state <= 2'b00;\n        end else begin\n            // Default values\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n\n            if (wb_cyc_i & wb_stb_i & ~wb_ack_o) begin\n                if (wb_we_i) begin\n                    // Write operation\n                    case (wb_adr_i)\n                        8'h00: argument_reg <= wb_dat_i;\n                        8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                        8'h28: software_reset_reg <= wb_dat_i[7:0];\n                        8'h2C: time_out_reg <= wb_dat_i[15:0];\n                        8'h30: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                        8'h34: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                        8'h4C: clock_divider <= wb_dat_i[7:0];\n                        8'h54: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                        8'h60, 8'h80: begin\n                            if (bd_write_state == 2'b00) begin\n                                bd_data <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                                bd_write_state <= 2'b01;\n                                int_ack <= 1'b0;\n                                if (wb_adr_i == 8'h60) we_m_rx_bd <= 1'b1;\n                                else we_m_tx_bd <= 1'b1;\n                            end else if (bd_write_state == 2'b01) begin\n                                bd_data <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                                bd_write_state <= 2'b10;\n                            end else if (bd_write_state == 2'b10) begin\n                                int_ack <= 1'b1;\n                                bd_write_state <= 2'b00;\n                            end\n                        end\n                        default: ;\n                    endcase\n                end else begin\n                    // Read operation\n                    case (wb_adr_i)\n                        8'h00: wb_dat_o <= argument_reg;\n                        8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                        8'h08: wb_dat_o <= {16'h0000, status_reg};\n                        8'h0C: wb_dat_o <= cmd_resp_1;\n                        8'h1C: wb_dat_o <= 32'h0000;\n                        8'h20: wb_dat_o <= 32'h0200;\n                        8'h24: wb_dat_o <= 32'h000F;\n                        8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                        8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                        8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                        8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                        8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                        8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                        8'h48: wb_dat_o <= 32'h0000;\n                        8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                        8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                        8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                        8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                        default: wb_dat_o <= 32'h0000;\n                    endcase\n                end\n                wb_ack_o <= 1'b1;\n            end\n\n            // Control logic\n            if (write_req_s) we_ack <= 1'b1;\n            if (cmd_set_s != 16'h0000 || cmd_arg_s != 32'h0000) new_cmd <= 1'b1;\n            if (cmd_set_s != 16'h0000) cmd_int_busy <= 1'b1;\n            if (cmd_arg_s != 32'h0000) int_busy <= 1'b1;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done;\n    reg rec_done;\n    reg rec_failed;\n    reg tx_cycle;\n    reg rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state;\n    reg [8:0] next_state;\n    reg trans_done;\n    reg trans_failed;\n    reg internal_transm_complete;\n    reg transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) begin\n                            rec_failed <= 1;\n                        end else if (card_status[0] == 1 || (card_status[4:1] >= 4 && card_status[4:1] <= 6)) begin\n                            rec_done <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        if (transm_complete && crc_ok) begin\n                            trans_done <= 1;\n                            a_cmp_tx <= 1;\n                        end\n                    end else if (rx_cycle && !rx_full) begin\n                        if (transm_complete && crc_ok) begin\n                            trans_done <= 1;\n                            a_cmp_rx <= 1;\n                        end\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n    localparam INIT = 10'b0000000001, IDLE = 10'b0000000010, WRITE_WR = 10'b0000000100,\n               DLY_WR = 10'b0000001000, READ_WR = 10'b0000010000, DLY_READ = 10'b0000100000,\n               ACK_WR = 10'b0001000000, WRITE_WO = 10'b0010000000, DLY_WO = 10'b0100000000,\n               ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state, next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinatorial logic for next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential logic for state update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and internal counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            if (Cmd_Cnt > 9) CRC_OUT <= CRC_VAL[6];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                        if (Cmd_Cnt > 9) CRC_OUT <= CRC_VAL[6];\n                        if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[Cmd_Cnt - Response_Size] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write) ? 2'b01 : 2'b00;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC module instantiation\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational Logic for Next State\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = Write_Read ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential Logic for State Update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage Outputs and Internal Counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[8 - Cmd_Cnt];\n                            st_dat_t <= block_read ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[8 - Cmd_Cnt];\n                            st_dat_t <= block_read ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write ? 2'b01 : 2'b00);\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_inst (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM states\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode settings and command\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and internal counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= {CRC_IN[5:0], cmd_dat_i};\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write ? 2'b01 : 2'b00);\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC computation module\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
