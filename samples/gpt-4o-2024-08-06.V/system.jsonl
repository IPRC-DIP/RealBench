{"task": "sdc_controller", "codeid": 1, "code": "module SD_BD (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    input wire re_s,\n    input wire a_cmp,\n    output reg free_bd,\n    output reg ack_o_s,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Define the BD memory\n    reg [RAM_MEM_WIDTH-1:0] bd_memory [0:BD_SIZE-1];\n\n    // State machine states\n    typedef enum reg [1:0] {\n        IDLE,\n        WRITE,\n        READ\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State machine logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        // Default assignments\n        next_state = current_state;\n        ack_o_s = 0;\n        free_bd = 0;\n        dat_out_s = 0;\n\n        case (current_state)\n            IDLE: begin\n                if (we_m && free_bd > 0) begin\n                    next_state = WRITE;\n                end else if (re_s) begin\n                    next_state = READ;\n                end\n            end\n\n            WRITE: begin\n                // Write logic\n                bd_memory[a_cmp] = dat_in_m;\n                ack_o_s = 1;\n                next_state = IDLE;\n            end\n\n            READ: begin\n                // Read logic\n                dat_out_s = bd_memory[a_cmp];\n                ack_o_s = 1;\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 2, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals and registers\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider sd_clock_divider_inst (\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(software_reset_reg[0]),\n    .SD_CLK(sd_clk_o_pad)\n);\n\n// Additional logic and connections\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 3, "code": "module SD_BD (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    input wire re_s,\n    input wire a_cmp,\n    output reg free_bd,\n    output reg ack_o_s,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Define the BD memory\n    reg [RAM_MEM_WIDTH-1:0] bd_memory [0:BD_SIZE-1];\n\n    // State machine states\n    typedef enum reg [1:0] {\n        IDLE,\n        WRITE,\n        READ\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State machine logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        // Default values\n        next_state = current_state;\n        free_bd = 0;\n        ack_o_s = 0;\n        dat_out_s = 0;\n\n        case (current_state)\n            IDLE: begin\n                if (we_m && free_bd > 0) begin\n                    next_state = WRITE;\n                end else if (re_s) begin\n                    next_state = READ;\n                end\n            end\n\n            WRITE: begin\n                // Write logic\n                if (a_cmp) begin\n                    bd_memory[0] <= dat_in_m; // Example write operation\n                    ack_o_s <= 1;\n                    next_state = IDLE;\n                end\n            end\n\n            READ: begin\n                // Read logic\n                dat_out_s <= bd_memory[0]; // Example read operation\n                ack_o_s <= 1;\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 4, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg)\n);\n\nsd_cmd_master u_sd_cmd_master (\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(wb_we_i),\n    .data_write(wb_we_i),\n    .data_read(wb_we_i),\n    .ARG_REG(wb_dat_i),\n    .CMD_SET_REG(wb_dat_i[13:0]),\n    .TIMEOUT_REG(wb_dat_i[15:0]),\n    .STATUS_REG(normal_int_status_reg),\n    .RESP_1_REG(wb_dat_o),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(wb_rst_i),\n    .NORMAL_INT_RST(wb_rst_i),\n    .settings(wb_dat_i[15:0]),\n    .go_idle_o(sd_cmd_out_o),\n    .cmd_out(sd_cmd_out_o),\n    .req_out(sd_cmd_oe_o),\n    .ack_out(sd_cmd_oe_o),\n    .req_in(sd_cmd_dat_i),\n    .ack_in(sd_cmd_dat_i),\n    .cmd_in(sd_cmd_dat_i),\n    .serial_status(sd_cmd_dat_i),\n    .card_detect(card_detect)\n);\n\nsd_data_master u_sd_data_master (\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(wb_dat_i),\n    .free_tx_bd(wb_dat_i[15:0]),\n    .ack_i_s_tx(wb_ack_o),\n    .dat_in_rx(wb_dat_i),\n    .free_rx_bd(wb_dat_i[15:0]),\n    .ack_i_s_rx(wb_ack_o),\n    .cmd_busy(wb_we_i),\n    .we_ack(wb_ack_o),\n    .cmd_tsf_err(wb_we_i),\n    .card_status(wb_dat_i[4:0]),\n    .tx_empt(wb_we_i),\n    .tx_full(wb_we_i),\n    .rx_full(wb_we_i),\n    .busy_n(wb_we_i),\n    .transm_complete(wb_we_i),\n    .crc_ok(wb_we_i),\n    .Dat_Int_Status_rst(wb_rst_i),\n    .transfer_type(wb_dat_i[1:0])\n);\n\nsd_fifo_tx_filler u_sd_fifo_tx_filler (\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(wb_we_i),\n    .adr(wb_adr_i),\n    .sd_clk(sd_clk_i_pad),\n    .dat_o(wb_dat_o),\n    .rd(wb_we_i),\n    .empty(wb_we_i),\n    .fe(wb_we_i)\n);\n\nsd_fifo_rx_filler u_sd_fifo_rx_filler (\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(wb_we_i),\n    .adr(wb_adr_i),\n    .sd_clk(sd_clk_i_pad),\n    .dat_i(wb_dat_i),\n    .wr(wb_we_i),\n    .full(wb_we_i)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 5, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals and logic here\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 6, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals and registers\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider sd_clock_divider_inst (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master sd_cmd_master_inst (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(settings),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host sd_cmd_serial_host_inst (\n        .SD_CLK_IN(sd_clk_o_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(settings),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_out),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(cmd_in),\n        .ACK_OUT(ack_in),\n        .REQ_OUT(req_in),\n        .STATUS(serial_status),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t(st_dat_t)\n    );\n\n    sd_data_master sd_data_master_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(dat_in_m_tx_bd),\n        .free_tx_bd(free_tx_bd),\n        .ack_i_s_tx(ack_i_s_tx),\n        .dat_in_rx(dat_in_m_rx_bd),\n        .free_rx_bd(free_rx_bd),\n        .ack_i_s_rx(ack_i_s_rx),\n        .cmd_busy(cmd_int_busy),\n        .we_ack(we_ack),\n        .cmd_tsf_err(cmd_tsf_err),\n        .card_status(card_status),\n        .tx_empt(tx_empt),\n        .tx_full(tx_full),\n        .rx_full(rx_full),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok),\n        .Dat_Int_Status_rst(bd_isr_reset),\n        .transfer_type(transfer_type),\n        .re_s_tx(re_s_tx),\n        .a_cmp_tx(a_cmp_tx),\n        .re_s_rx(re_s_rx),\n        .a_cmp_rx(a_cmp_rx),\n        .we_req(we_req),\n        .d_write(d_write),\n        .d_read(d_read),\n        .cmd_arg(cmd_arg),\n        .cmd_set(cmd_set),\n        .start_tx_fifo(start_tx_fifo),\n        .start_rx_fifo(start_rx_fifo),\n        .sys_adr(sys_adr),\n        .ack_transfer(ack_transfer),\n        .Dat_Int_Status(Dat_Int_Status),\n        .CIDAT(CIDAT)\n    );\n\n    sd_data_serial_host sd_data_serial_host_inst (\n        .sd_clk(sd_clk_o_pad),\n        .rst(wb_rst_i),\n        .data_in(data_in),\n        .start_dat(start_dat),\n        .ack_transfer(ack_transfer),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(rd),\n        .data_out(sd_dat_out_o),\n        .we(sd_dat_oe_o),\n        .DAT_oe_o(DAT_oe_o),\n        .DAT_dat_o(DAT_dat_o),\n        .busy_n(busy_n),\n        .transm_complete(transm_complete),\n        .crc_ok(crc_ok)\n    );\n\n    rx_bd rx_bd_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_rx_bd),\n        .dat_in_m(dat_in_m_rx_bd),\n        .free_bd(free_rx_bd),\n        .re_s(re_s_rx),\n        .ack_o_s(ack_i_s_rx),\n        .a_cmp(a_cmp_rx),\n        .dat_out_s(dat_out_s_rx)\n    );\n\n    tx_bd tx_bd_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(we_m_tx_bd),\n        .dat_in_m(dat_in_m_tx_bd),\n        .free_bd(free_tx_bd),\n        .re_s(re_s_tx),\n        .ack_o_s(ack_i_s_tx),\n        .a_cmp(a_cmp_tx),\n        .dat_out_s(dat_out_s_tx)\n    );\n\n    sd_fifo_tx_filler sd_fifo_tx_filler_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_tx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o_pad),\n        .dat_o(dat_o_tx),\n        .rd(rd_tx),\n        .empty(empty_tx),\n        .fe(fe_tx)\n    );\n\n    sd_fifo_rx_filler sd_fifo_rx_filler_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(start_rx_fifo),\n        .adr(sys_adr),\n        .sd_clk(sd_clk_o_pad),\n        .dat_i(dat_i_rx),\n        .wr(wr_rx),\n        .full(full_rx)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 7, "code": "module SD_BD (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    input wire re_s,\n    input wire a_cmp,\n    output wire free_bd,\n    output wire ack_o_s,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Define parameters\n    parameter RAM_MEM_WIDTH = 32;\n    parameter BD_SIZE = 16;\n\n    // Internal signals\n    reg [RAM_MEM_WIDTH-1:0] bd_memory [0:BD_SIZE-1];\n    reg [BD_SIZE-1:0] free_bd_count;\n    reg ack_o_s_reg;\n    reg [RAM_MEM_WIDTH-1:0] dat_out_s_reg;\n\n    // Write operation\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd_count <= BD_SIZE;\n            ack_o_s_reg <= 0;\n        end else if (we_m && free_bd_count > 0) begin\n            bd_memory[a_cmp] <= dat_in_m;\n            free_bd_count <= free_bd_count - 1;\n            ack_o_s_reg <= 1;\n        end else begin\n            ack_o_s_reg <= 0;\n        end\n    end\n\n    // Read operation\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            dat_out_s_reg <= 0;\n        end else if (re_s) begin\n            dat_out_s_reg <= bd_memory[a_cmp];\n        end\n    end\n\n    // Output assignments\n    assign free_bd = (free_bd_count > 0);\n    assign ack_o_s = ack_o_s_reg;\n    assign dat_out_s = dat_out_s_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 8, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals and registers\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules instantiation and logic\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 9, "code": "module SD_BD (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    input wire re_s,\n    input wire a_cmp,\n    output wire free_bd,\n    output wire ack_o_s,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Define the BD memory\n    reg [RAM_MEM_WIDTH-1:0] bd_memory [0:BD_SIZE-1];\n\n    // State machine states\n    typedef enum logic [1:0] {\n        IDLE,\n        WRITE,\n        READ\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State machine logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    always_comb begin\n        next_state = current_state;\n        case (current_state)\n            IDLE: begin\n                if (we_m && free_bd > 0) begin\n                    next_state = WRITE;\n                end else if (re_s) begin\n                    next_state = READ;\n                end\n            end\n            WRITE: begin\n                // Write logic\n                next_state = IDLE; // Transition back to IDLE after write\n            end\n            READ: begin\n                // Read logic\n                next_state = IDLE; // Transition back to IDLE after read\n            end\n        endcase\n    end\n\n    // Output logic\n    assign free_bd = /* logic to determine free_bd */;\n    assign ack_o_s = /* logic to determine ack_o_s */;\n    assign dat_out_s = /* logic to determine dat_out_s */;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 10, "code": "// Verilog code for the sdc_controller module\n\nmodule sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals and registers\n// Define internal signals and registers here\n\n// Instantiate sub-modules\n// Instantiate sd_controller_wb, sd_cmd_master, sd_data_master, sd_cmd_serial_host, tx_bd, rx_bd, sd_fifo_tx_filler, sd_fifo_rx_filler\n\n// Logic for interfacing and control\n// Define logic for interfacing and control here\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 11, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\nwire we_m_tx_bd;\nwire we_m_rx_bd;\nwire new_cmd;\nwire we_ack;\nwire int_ack;\nwire cmd_int_busy;\nwire int_busy;\nwire write_req_s;\nwire [15:0] cmd_set_s;\nwire [31:0] cmd_arg_s;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Other sub-modules instantiation...\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 12, "code": "module sdc_controller(\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals and registers\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider (\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\n// Additional logic and connections\nassign m_wb_adr_o = (start_tx_fifo) ? tx_m_wb_adr_o : (start_rx_fifo) ? rx_m_wb_adr_o : 32'b0;\nassign m_wb_sel_o = 1'b1;\nassign m_wb_we_o = (start_tx_fifo) ? tx_m_wb_we_o : (start_rx_fifo) ? rx_m_wb_we_o : 1'b0;\nassign m_wb_dat_o = (start_tx_fifo) ? tx_m_wb_dat_o : 32'b0;\nassign m_wb_cyc_o = (start_tx_fifo) ? tx_m_wb_cyc_o : (start_rx_fifo) ? rx_m_wb_cyc_o : 1'b0;\nassign m_wb_stb_o = (start_tx_fifo) ? tx_m_wb_stb_o : (start_rx_fifo) ? rx_m_wb_stb_o : 1'b0;\nassign m_wb_cti_o = (start_tx_fifo) ? tx_m_wb_cti_o : (start_rx_fifo) ? rx_m_wb_cti_o : 1'b0;\nassign m_wb_bte_o = (start_tx_fifo) ? tx_m_wb_bte_o : (start_rx_fifo) ? rx_m_wb_bte_o : 1'b0;\n\n// Interrupt logic\nassign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) ? 1'b1 : 1'b0;\nassign int_b = (error_int_status_reg & error_int_signal_enable_reg) ? 1'b1 : 1'b0;\nassign int_c = (Bd_isr_reg & Bd_isr_enable_reg) ? 1'b1 : 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 13, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules and logic here...\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 14, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals and registers\nwire we_m_tx_bd, we_m_rx_bd, new_cmd, we_ack, int_ack, cmd_int_busy, int_busy;\nwire write_req_s;\nwire [15:0] cmd_set_s;\nwire [31:0] cmd_arg_s;\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset, normal_isr_reset, error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd, dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\nsd_clock_divider u_sd_clock_divider (\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\n// Additional logic and connections\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 15, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals and registers\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider sd_clock_divider_inst (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // Additional logic and connections as needed\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 16, "code": "module SD_BD (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    input wire re_s,\n    input wire a_cmp,\n    output reg free_bd,\n    output reg ack_o_s,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Define the RAM memory\n    reg [RAM_MEM_WIDTH-1:0] bd_memory [0:BD_SIZE-1];\n\n    // State machine states\n    typedef enum reg [1:0] {\n        IDLE,\n        WRITE,\n        READ\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (we_m && free_bd > 0) begin\n                    next_state = WRITE;\n                end else if (re_s) begin\n                    next_state = READ;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITE: begin\n                next_state = IDLE; // Assume write completes in one cycle\n            end\n            READ: begin\n                next_state = IDLE; // Assume read completes in one cycle\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= 0;\n            ack_o_s <= 0;\n            dat_out_s <= 0;\n        end else begin\n            case (current_state)\n                WRITE: begin\n                    bd_memory[a_cmp] <= dat_in_m;\n                    free_bd <= free_bd - 1;\n                    ack_o_s <= 1;\n                end\n                READ: begin\n                    dat_out_s <= bd_memory[a_cmp];\n                    ack_o_s <= 1;\n                end\n                default: begin\n                    ack_o_s <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 17, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n    // Internal signals and logic here\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 18, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals and registers\nreg [31:0] internal_reg;\nwire [31:0] data_out;\nwire [31:0] data_in;\nwire [7:0] address;\nwire write_enable;\nwire read_enable;\n\n// Assignments\nassign data_out = internal_reg;\nassign data_in = wb_dat_i;\nassign address = wb_adr_i;\nassign write_enable = wb_we_i;\nassign read_enable = ~wb_we_i;\n\n// Wishbone interface logic\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        internal_reg <= 32'b0;\n        wb_ack_o <= 1'b0;\n    end else if (wb_cyc_i && wb_stb_i) begin\n        if (write_enable) begin\n            internal_reg <= data_in;\n            wb_ack_o <= 1'b1;\n        end else if (read_enable) begin\n            wb_dat_o <= data_out;\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end else begin\n        wb_ack_o <= 1'b0;\n    end\nend\n\n// Master Wishbone interface logic\nassign m_wb_adr_o = address;\nassign m_wb_sel_o = wb_sel_i[0];\nassign m_wb_we_o = write_enable;\nassign m_wb_dat_o = data_out;\nassign m_wb_cyc_o = wb_cyc_i;\nassign m_wb_stb_o = wb_stb_i;\nassign m_wb_cti_o = 1'b0;\nassign m_wb_bte_o = 1'b0;\n\n// SDC IO logic\nassign sd_cmd_out_o = sd_cmd_dat_i;\nassign sd_cmd_oe_o = 1'b1;\nassign sd_dat_out_o = sd_dat_dat_i;\nassign sd_dat_oe_o = 1'b1;\nassign sd_clk_o_pad = sd_clk_i_pad;\n\n// Interrupt logic\nassign int_a = card_detect;\nassign int_b = card_detect;\nassign int_c = card_detect;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 19, "code": "// sdc_controller.v\n\nmodule sdc_controller (\n    // Wishbone Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals and logic here\n\nendmodule\n// sd_controller_wb.v\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire we_m_tx_bd,\n    output wire we_m_rx_bd,\n    output wire new_cmd,\n    output wire we_ack,\n    output wire int_ack,\n    output wire cmd_int_busy,\n    output wire int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output wire [7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output wire [7:0] Bd_isr_enable_reg,\n    output wire bd_isr_reset,\n    output wire normal_isr_reset,\n    output wire error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n// Internal signals and logic here\n\nendmodule\n// sd_clock_divider.v\n\nmodule sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output wire SD_CLK\n);\n\n// Internal signals and logic here\n\nendmodule\n// sd_cmd_master.v\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [4:0] ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire req_out,\n    output wire ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n// Internal signals and logic here\n\nendmodule\n// sd_cmd_serial_host.v\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output wire [39:0] CMD_OUT,\n    output wire ACK_OUT,\n    output wire REQ_OUT,\n    output wire [7:0] STATUS,\n    output wire cmd_oe_o,\n    output wire cmd_out_o,\n    output wire [1:0] st_dat_t\n);\n\n// Internal signals and logic here\n\nendmodule\n// sd_data_master.v\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output wire re_s_tx,\n    output wire a_cmp_tx,\n    output wire re_s_rx,\n    output wire a_cmp_rx,\n    output wire we_req,\n    output wire d_write,\n    output wire d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire start_tx_fifo,\n    output wire start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire ack_transfer,\n    output wire [7:0] Dat_Int_Status,\n    output wire CIDAT\n);\n\n// Internal signals and logic here\n\nendmodule\n// sd_data_serial_host.v\n\nmodule sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n// Internal signals and logic here\n\nendmodule\n// sd_fifo_tx_filler.v\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n// Internal signals and logic here\n\nendmodule\n// sd_fifo_rx_filler.v\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full\n);\n\n// Internal signals and logic here\n\nendmodule\n// sd_rx_fifo.v\n\nmodule sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output wire [31:0] q,\n    input wire rd,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\n// Internal signals and logic here\n\nendmodule\n// sd_tx_fifo.v\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output wire [31:0] q,\n    input wire rd,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\n// Internal signals and logic here\n\nendmodule\n// sd_bd.v\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output wire ack_o_s,\n    input wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal signals and logic here\n\nendmodule\n// sd_crc_16.v\n\nmodule sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output wire [15:0] CRC\n);\n\n// Internal signals and logic here\n\nendmodule\n// sd_crc_7.v\n\nmodule sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output wire [6:0] CRC\n);\n\n// Internal signals and logic here\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 20, "code": "module sdc_controller(\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Instantiate sub-modules here\n\nendmodule\nmodule sd_controller_wb(\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire we_m_tx_bd,\n    output wire we_m_rx_bd,\n    output wire new_cmd,\n    output wire we_ack,\n    output wire int_ack,\n    output wire cmd_int_busy,\n    output wire int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output wire [31:0] argument_reg,\n    output wire [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output wire [7:0] software_reset_reg,\n    output wire [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output wire [15:0] normal_int_signal_enable_reg,\n    output wire [15:0] error_int_signal_enable_reg,\n    output wire [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output wire [7:0] Bd_isr_enable_reg,\n    output wire bd_isr_reset,\n    output wire normal_isr_reset,\n    output wire error_isr_reset,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n// Implement module logic here\n\nendmodule\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output wire SD_CLK\n);\n\n// Implement clock division logic here\n\nendmodule\nmodule sd_cmd_master(\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output wire [15:0] STATUS_REG,\n    output wire [31:0] RESP_1_REG,\n    output wire [4:0] ERR_INT_REG,\n    output wire [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output wire [15:0] settings,\n    output wire go_idle_o,\n    output wire [39:0] cmd_out,\n    output wire req_out,\n    output wire ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n// Implement module logic here\n\nendmodule\nmodule sd_cmd_serial_host(\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output wire [39:0] CMD_OUT,\n    output wire ACK_OUT,\n    output wire REQ_OUT,\n    output wire [7:0] STATUS,\n    output wire cmd_oe_o,\n    output wire cmd_out_o,\n    output wire [1:0] st_dat_t\n);\n\n// Implement module logic here\n\nendmodule\nmodule sd_data_master(\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output wire re_s_tx,\n    output wire a_cmp_tx,\n    output wire re_s_rx,\n    output wire a_cmp_rx,\n    output wire we_req,\n    output wire d_write,\n    output wire d_read,\n    output wire [31:0] cmd_arg,\n    output wire [15:0] cmd_set,\n    output wire start_tx_fifo,\n    output wire start_rx_fifo,\n    output wire [31:0] sys_adr,\n    output wire ack_transfer,\n    output wire [7:0] Dat_Int_Status,\n    output wire CIDAT\n);\n\n// Implement module logic here\n\nendmodule\nmodule sd_data_serial_host(\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output wire rd,\n    output wire [SD_BUS_W-1:0] data_out,\n    output wire we,\n    output wire DAT_oe_o,\n    output wire [SD_BUS_W-1:0] DAT_dat_o,\n    output wire busy_n,\n    output wire transm_complete,\n    output wire crc_ok\n);\n\n// Implement module logic here\n\nendmodule\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output wire [31:0] dat_o,\n    input wire rd,\n    output wire empty,\n    output wire fe\n);\n\n// Implement module logic here\n\nendmodule\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full\n);\n\n// Implement module logic here\n\nendmodule\nmodule sd_rx_fifo(\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    output wire [31:0] q,\n    input wire rd,\n    output wire full,\n    output wire empty,\n    output wire [1:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\n// Implement FIFO logic here\n\nendmodule\nmodule sd_tx_fifo(\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output wire [31:0] q,\n    input wire rd,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\n// Implement FIFO logic here\n\nendmodule\nmodule sd_bd(\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output wire [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output wire ack_o_s,\n    input wire a_cmp,\n    output wire [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Implement buffer descriptor logic here\n\nendmodule\nmodule sd_crc_16(\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output wire [15:0] CRC\n);\n\n// Implement CRC-16 logic here\n\nendmodule\nmodule sd_crc_7(\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output wire [6:0] CRC\n);\n\n// Implement CRC-7 logic here\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 1, "code": "module aes_cipher_top (\n    input clk,\n    input rst,\n    input ld,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg done,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n    aes_key_expand_128 key_expander (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            dcnt <= 4'hB;\n            ld_r <= 1'b0;\n            done <= 1'b0;\n            text_out <= 128'b0;\n        end else begin\n            ld_r <= ld;\n            if (ld_r) begin\n                text_in_r <= text_in;\n                dcnt <= 4'hB;\n                done <= 1'b0;\n            end else if (dcnt != 0) begin\n                dcnt <= dcnt - 1;\n                if (dcnt == 1) begin\n                    done <= 1'b1;\n                    text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                                 sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                                 sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                                 sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                end\n            end\n        end\n    end\n\n    // SubBytes, ShiftRows, MixColumns, AddRoundKey logic here\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w [0:43];\n    reg [3:0] rcon;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcon <= 4'h1;\n        end else begin\n            // Key expansion logic here\n        end\n    end\n\n    assign wo_0 = w[0];\n    assign wo_1 = w[1];\n    assign wo_2 = w[2];\n    assign wo_3 = w[3];\n\nendmodule\n\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // S-box initialization here\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'h0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 9) begin\n            rcnt <= rcnt + 1;\n            // RCON logic here\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 2, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n    aes_key_expand_128 key_expand (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    // State machine states\n    localparam IDLE = 0, INIT_ROUND = 1, ROUND_OP = 2, FINAL_ROUND = 3, DONE = 4;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = ld ? INIT_ROUND : IDLE;\n            INIT_ROUND: next_state = ROUND_OP;\n            ROUND_OP: next_state = (dcnt == 4'd1) ? FINAL_ROUND : ROUND_OP;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            ld_r <= 0;\n            dcnt <= 4'd11;\n            done <= 0;\n        end else begin\n            ld_r <= ld;\n            if (state == INIT_ROUND) begin\n                dcnt <= 4'd10;\n            end else if (state == ROUND_OP || state == FINAL_ROUND) begin\n                dcnt <= dcnt - 1;\n            end\n            if (state == DONE) begin\n                done <= 1;\n            end else begin\n                done <= 0;\n            end\n        end\n    end\n\n    // Data path logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            text_in_r <= 128'b0;\n            text_out <= 128'b0;\n        end else if (ld_r) begin\n            text_in_r <= text_in;\n        end else if (state == INIT_ROUND || state == ROUND_OP || state == FINAL_ROUND) begin\n            // Implement SubBytes, ShiftRows, MixColumns, AddRoundKey here\n            // Update sa matrix and text_out accordingly\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    reg [31:0] w [0:43];\n    integer i;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n        end else begin\n            for (i = 4; i < 44; i = i + 1) begin\n                if (i % 4 == 0) begin\n                    w[i] <= w[i-4] ^ aes_sbox(w[i-1]) ^ aes_rcon(i/4);\n                end else begin\n                    w[i] <= w[i-4] ^ w[i-1];\n                end\n            end\n        end\n    end\n\n    always @(*) begin\n        wo_0 = w[40];\n        wo_1 = w[41];\n        wo_2 = w[42];\n        wo_3 = w[43];\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    reg [7:0] sbox [0:255];\n    initial begin\n        // Initialize S-box values\n    end\n    assign b = sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n    reg [3:0] rcnt;\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'b0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 4'd9) begin\n            rcnt <= rcnt + 1;\n            out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1B_00_00_00 : 32'h00_00_00_00);\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 3, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n    aes_key_expand_128 key_expander (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            dcnt <= 4'hB;\n            ld_r <= 0;\n            text_out <= 128'h0;\n        end else begin\n            ld_r <= ld;\n            if (ld_r) begin\n                text_in_r <= text_in;\n                // Initial round key addition\n                {sa[0][0], sa[1][0], sa[2][0], sa[3][0]} <= text_in_r[127:96] ^ wo_0;\n                {sa[0][1], sa[1][1], sa[2][1], sa[3][1]} <= text_in_r[95:64] ^ wo_1;\n                {sa[0][2], sa[1][2], sa[2][2], sa[3][2]} <= text_in_r[63:32] ^ wo_2;\n                {sa[0][3], sa[1][3], sa[2][3], sa[3][3]} <= text_in_r[31:0] ^ wo_3;\n                dcnt <= 4'hA;\n            end else if (dcnt != 0) begin\n                // Perform round operations\n                // SubBytes, ShiftRows, MixColumns, AddRoundKey\n                // Final round does not include MixColumns\n                dcnt <= dcnt - 1;\n            end else begin\n                done <= 1;\n                text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                             sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                             sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                             sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n            end\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\n    reg [31:0] w [0:43];\n    integer i;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            {w[0], w[1], w[2], w[3]} <= key;\n            for (i = 4; i < 44; i = i + 1) begin\n                if (i % 4 == 0) begin\n                    w[i] <= w[i-4] ^ aes_sbox(w[i-1]) ^ aes_rcon(i/4);\n                end else begin\n                    w[i] <= w[i-4] ^ w[i-1];\n                end\n            end\n        end\n    end\n\n    always @(*) begin\n        wo_0 = w[40];\n        wo_1 = w[41];\n        wo_2 = w[42];\n        wo_3 = w[43];\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output reg [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box values\n        // S-box values should be filled here\n    end\n\n    always @(*) begin\n        b = sbox[a];\n    end\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 9) begin\n            rcnt <= rcnt + 1;\n            out <= {out[23:0], 8'h00} ^ (out[31] ? 32'h1B_00_00_00 : 32'h00_00_00_00);\n        end else begin\n            out <= 32'h00_00_00_00;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 4, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n    aes_key_expand_128 key_expand (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            ld_r <= 0;\n            dcnt <= 4'hB;\n            text_out <= 128'h0;\n        end else begin\n            ld_r <= ld;\n            if (ld_r) begin\n                text_in_r <= text_in;\n                // Initial round key addition\n                {sa[0][0], sa[1][0], sa[2][0], sa[3][0]} <= text_in_r[127:96] ^ {wo_0};\n                {sa[0][1], sa[1][1], sa[2][1], sa[3][1]} <= text_in_r[95:64] ^ {wo_1};\n                {sa[0][2], sa[1][2], sa[2][2], sa[3][2]} <= text_in_r[63:32] ^ {wo_2};\n                {sa[0][3], sa[1][3], sa[2][3], sa[3][3]} <= text_in_r[31:0] ^ {wo_3};\n                dcnt <= 4'hA;\n            end else if (dcnt != 0) begin\n                // Perform AES round operations\n                // SubBytes, ShiftRows, MixColumns, AddRoundKey\n                dcnt <= dcnt - 1;\n            end else begin\n                // Final round\n                // SubBytes, ShiftRows, AddRoundKey\n                text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                             sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                             sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                             sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                done <= 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\n    reg [31:0] w [0:43];\n    reg [3:0] rcon;\n    wire [31:0] temp;\n\n    aes_sbox sbox0 (.a(temp[23:16]), .b(temp[31:24]));\n    aes_sbox sbox1 (.a(temp[15:8]), .b(temp[23:16]));\n    aes_sbox sbox2 (.a(temp[7:0]), .b(temp[15:8]));\n    aes_sbox sbox3 (.a(temp[31:24]), .b(temp[7:0]));\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcon <= 4'h1;\n        end else begin\n            w[4] <= w[0] ^ temp ^ {rcon, 24'h0};\n            w[5] <= w[1] ^ w[4];\n            w[6] <= w[2] ^ w[5];\n            w[7] <= w[3] ^ w[6];\n            rcon <= {rcon[2:0], rcon[3]};\n        end\n    end\n\n    assign temp = {w[3][23:0], w[3][31:24]};\n\n    always @(*) begin\n        wo_0 = w[4];\n        wo_1 = w[5];\n        wo_2 = w[6];\n        wo_3 = w[7];\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box with predefined values\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7c; // ... fill in the rest\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'h0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 4'h9) begin\n            rcnt <= rcnt + 1;\n            out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1b_00_00_00 : 32'h0);\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 5, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    // State encoding\n    localparam IDLE = 3'b000,\n               INIT_ROUND = 3'b001,\n               ROUND_OP = 3'b010,\n               FINAL_ROUND = 3'b011,\n               DONE = 3'b100;\n\n    reg [2:0] state, next_state;\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = ld ? INIT_ROUND : IDLE;\n            INIT_ROUND: next_state = ROUND_OP;\n            ROUND_OP: next_state = (dcnt == 4'd1) ? FINAL_ROUND : ROUND_OP;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            text_out <= 128'b0;\n            dcnt <= 4'd11;\n            ld_r <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (ld) begin\n                        text_in_r <= text_in;\n                        ld_r <= 1;\n                    end\n                end\n                INIT_ROUND: begin\n                    // Initial AddRoundKey\n                    // Load input data into state matrix\n                    // Set round counter\n                    dcnt <= 4'd10;\n                end\n                ROUND_OP: begin\n                    // Perform SubBytes, ShiftRows, MixColumns, AddRoundKey\n                    dcnt <= dcnt - 1;\n                end\n                FINAL_ROUND: begin\n                    // Perform SubBytes, ShiftRows, AddRoundKey\n                    text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                                 sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                                 sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                                 sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                end\n                DONE: begin\n                    done <= 1;\n                end\n            endcase\n        end\n    end\n\n    // SubBytes, ShiftRows, MixColumns, AddRoundKey implementations\n    // ...\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    reg [31:0] w [0:43];\n    reg [3:0] rcon;\n\n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcon <= 4'h1;\n        end else begin\n            // Key expansion algorithm\n            // ...\n        end\n    end\n\n    // Output round keys\n    always @(posedge clk) begin\n        wo_0 <= w[0];\n        wo_1 <= w[1];\n        wo_2 <= w[2];\n        wo_3 <= w[3];\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box values\n        // ...\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'd0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 4'd10) begin\n            rcnt <= rcnt + 1;\n            // Update out with next round constant\n            // ...\n        end else begin\n            out <= 32'h00_00_00_00;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 6, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    // Submodules\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    // State Machine\n    typedef enum reg [2:0] {\n        IDLE,\n        INIT_ROUND,\n        ROUND_OP,\n        FINAL_ROUND,\n        DONE\n    } state_t;\n    state_t state, next_state;\n\n    // State Transition\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = ld ? INIT_ROUND : IDLE;\n            INIT_ROUND: next_state = ROUND_OP;\n            ROUND_OP: next_state = (dcnt == 4'd1) ? FINAL_ROUND : ROUND_OP;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            text_out <= 0;\n            dcnt <= 4'd11;\n            ld_r <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (ld) begin\n                        text_in_r <= text_in;\n                        ld_r <= 1;\n                    end\n                end\n                INIT_ROUND: begin\n                    // Initial Round Key Addition\n                    // Load input data into state matrix\n                    // AddRoundKey operation\n                    dcnt <= 4'd10;\n                end\n                ROUND_OP: begin\n                    // Perform SubBytes, ShiftRows, MixColumns, AddRoundKey\n                    dcnt <= dcnt - 1;\n                end\n                FINAL_ROUND: begin\n                    // Perform SubBytes, ShiftRows, AddRoundKey\n                    text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                                 sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                                 sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                                 sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                end\n                DONE: begin\n                    done <= 1;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    reg [31:0] w [0:43];\n    integer i;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n        end else begin\n            for (i = 4; i < 44; i = i + 1) begin\n                if (i % 4 == 0)\n                    w[i] <= w[i-4] ^ subword(rotword(w[i-1])) ^ rcon(i/4);\n                else\n                    w[i] <= w[i-4] ^ w[i-1];\n            end\n        end\n    end\n\n    function [31:0] rotword(input [31:0] word);\n        rotword = {word[23:0], word[31:24]};\n    endfunction\n\n    function [31:0] subword(input [31:0] word);\n        subword = {sbox(word[31:24]), sbox(word[23:16]), sbox(word[15:8]), sbox(word[7:0])};\n    endfunction\n\n    function [7:0] sbox(input [7:0] byte);\n        // S-box lookup table\n        // ...\n    endfunction\n\n    function [31:0] rcon(input integer i);\n        // Round constant lookup\n        // ...\n    endfunction\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    reg [7:0] sbox [0:255];\n    initial begin\n        // Initialize S-box values\n        // ...\n    end\n    assign b = sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 9) begin\n            rcnt <= rcnt + 1;\n            out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1b_00_00_00 : 32'h00_00_00_00);\n        end else begin\n            out <= 32'h00_00_00_00;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 7, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n    aes_key_expand_128 key_expander (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            text_in_r <= 128'b0;\n            text_out <= 128'b0;\n            dcnt <= 4'b1011;\n            ld_r <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            if (ld) begin\n                text_in_r <= text_in;\n                dcnt <= 4'b1011;\n                ld_r <= 1'b1;\n            end else if (ld_r) begin\n                // Initial Round\n                // AddRoundKey\n                // Load state matrix\n                // ...\n                ld_r <= 1'b0;\n            end else if (dcnt != 4'b0000) begin\n                // Perform Round Operations\n                // SubBytes, ShiftRows, MixColumns, AddRoundKey\n                // ...\n                dcnt <= dcnt - 1;\n            end else begin\n                // Final Round\n                // SubBytes, ShiftRows, AddRoundKey\n                // ...\n                done <= 1'b1;\n                text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                             sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                             sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                             sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n            end\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\n    reg [31:0] w [0:43];\n    wire [31:0] temp;\n    wire [31:0] rcon;\n\n    aes_rcon rcon_gen (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    aes_sbox sbox_u0 (.a(temp[23:16]), .b(temp[31:24]));\n    aes_sbox sbox_u1 (.a(temp[15:8]), .b(temp[23:16]));\n    aes_sbox sbox_u2 (.a(temp[7:0]), .b(temp[15:8]));\n    aes_sbox sbox_u3 (.a(temp[31:24]), .b(temp[7:0]));\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n        end else begin\n            w[4] <= w[0] ^ temp ^ rcon;\n            w[5] <= w[1] ^ w[4];\n            w[6] <= w[2] ^ w[5];\n            w[7] <= w[3] ^ w[6];\n            // Continue key expansion...\n        end\n    end\n\n    assign temp = {w[3][23:0], w[3][31:24]};\n\n    always @(*) begin\n        wo_0 = w[40];\n        wo_1 = w[41];\n        wo_2 = w[42];\n        wo_3 = w[43];\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box with values\n        // ...\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'b0000;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 4'b1010) begin\n            rcnt <= rcnt + 1;\n            case (rcnt)\n                4'b0000: out <= 32'h01_00_00_00;\n                4'b0001: out <= 32'h02_00_00_00;\n                4'b0010: out <= 32'h04_00_00_00;\n                4'b0011: out <= 32'h08_00_00_00;\n                4'b0100: out <= 32'h10_00_00_00;\n                4'b0101: out <= 32'h20_00_00_00;\n                4'b0110: out <= 32'h40_00_00_00;\n                4'b0111: out <= 32'h80_00_00_00;\n                4'b1000: out <= 32'h1B_00_00_00;\n                4'b1001: out <= 32'h36_00_00_00;\n                default: out <= 32'h00_00_00_00;\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 8, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n    aes_key_expand_128 key_expand (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    // State machine states\n    localparam IDLE = 3'b000,\n               INIT_ROUND = 3'b001,\n               ROUND_OP = 3'b010,\n               FINAL_ROUND = 3'b011,\n               DONE = 3'b100;\n\n    reg [2:0] state, next_state;\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = ld ? INIT_ROUND : IDLE;\n            INIT_ROUND: next_state = ROUND_OP;\n            ROUND_OP: next_state = (dcnt == 4'd1) ? FINAL_ROUND : ROUND_OP;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic and operations\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            dcnt <= 4'd11;\n            ld_r <= 0;\n            text_out <= 128'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (ld) begin\n                        text_in_r <= text_in;\n                        ld_r <= 1;\n                    end\n                end\n                INIT_ROUND: begin\n                    // Initial AddRoundKey\n                    {sa[0][0], sa[1][0], sa[2][0], sa[3][0]} <= text_in_r[127:96] ^ wo_0;\n                    {sa[0][1], sa[1][1], sa[2][1], sa[3][1]} <= text_in_r[95:64] ^ wo_1;\n                    {sa[0][2], sa[1][2], sa[2][2], sa[3][2]} <= text_in_r[63:32] ^ wo_2;\n                    {sa[0][3], sa[1][3], sa[2][3], sa[3][3]} <= text_in_r[31:0] ^ wo_3;\n                    dcnt <= 4'd10;\n                end\n                ROUND_OP: begin\n                    // Perform SubBytes, ShiftRows, MixColumns, AddRoundKey\n                    // (Implementation of these operations is omitted for brevity)\n                    dcnt <= dcnt - 1;\n                end\n                FINAL_ROUND: begin\n                    // Perform SubBytes, ShiftRows, AddRoundKey\n                    // (Implementation of these operations is omitted for brevity)\n                    text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                                 sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                                 sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                                 sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                end\n                DONE: begin\n                    done <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\n    reg [31:0] w [0:43];\n    reg [3:0] rcnt;\n\n    aes_rcon rcon (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon_out)\n    );\n\n    aes_sbox sbox0 (.a(w[rcnt-1][23:16]), .b(sbox_out[31:24]));\n    aes_sbox sbox1 (.a(w[rcnt-1][15:8]), .b(sbox_out[23:16]));\n    aes_sbox sbox2 (.a(w[rcnt-1][7:0]), .b(sbox_out[15:8]));\n    aes_sbox sbox3 (.a(w[rcnt-1][31:24]), .b(sbox_out[7:0]));\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 4'd4;\n        end else if (rcnt < 44) begin\n            if (rcnt % 4 == 0) begin\n                w[rcnt] <= w[rcnt-4] ^ sbox_out ^ rcon_out;\n            end else begin\n                w[rcnt] <= w[rcnt-4] ^ w[rcnt-1];\n            end\n            rcnt <= rcnt + 1;\n        end\n    end\n\n    always @(*) begin\n        wo_0 = w[rcnt-4];\n        wo_1 = w[rcnt-3];\n        wo_2 = w[rcnt-2];\n        wo_3 = w[rcnt-1];\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box with predefined values\n        // (Values are omitted for brevity)\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1b : 32'h00);\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 9, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n    aes_key_expand_128 key_expand (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    // State machine states\n    localparam IDLE = 0, INIT_ROUND = 1, ROUND_OP = 2, FINAL_ROUND = 3, DONE = 4;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            done <= 0;\n            dcnt <= 4'b1011; // 11 in decimal\n        end else begin\n            state <= next_state;\n            if (state == DONE) done <= 1;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = ld ? INIT_ROUND : IDLE;\n            INIT_ROUND: next_state = ROUND_OP;\n            ROUND_OP: next_state = (dcnt == 4'b0001) ? FINAL_ROUND : ROUND_OP;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (state == INIT_ROUND) begin\n            text_in_r <= text_in;\n            // Initial AddRoundKey\n            // Load input data into state matrix\n            // AddRoundKey operation\n        end else if (state == ROUND_OP || state == FINAL_ROUND) begin\n            // Perform SubBytes, ShiftRows, MixColumns (if ROUND_OP), AddRoundKey\n            // Update state matrix\n            dcnt <= dcnt - 1;\n        end else if (state == DONE) begin\n            // Output final ciphertext\n            text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                         sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                         sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                         sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0, wo_1, wo_2, wo_3\n);\n\n    reg [31:0] w [0:43];\n    reg [3:0] rcnt;\n\n    aes_rcon rcon (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon_out)\n    );\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 0;\n        end else begin\n            if (rcnt < 10) begin\n                w[4*rcnt+4] <= w[4*rcnt] ^ rcon_out ^ SubWord(RotWord(w[4*rcnt+3]));\n                w[4*rcnt+5] <= w[4*rcnt+1] ^ w[4*rcnt+4];\n                w[4*rcnt+6] <= w[4*rcnt+2] ^ w[4*rcnt+5];\n                w[4*rcnt+7] <= w[4*rcnt+3] ^ w[4*rcnt+6];\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        wo_0 = w[4*rcnt];\n        wo_1 = w[4*rcnt+1];\n        wo_2 = w[4*rcnt+2];\n        wo_3 = w[4*rcnt+3];\n    end\n\n    function [31:0] RotWord(input [31:0] word);\n        RotWord = {word[23:0], word[31:24]};\n    endfunction\n\n    function [31:0] SubWord(input [31:0] word);\n        SubWord = {aes_sbox(word[31:24]), aes_sbox(word[23:16]), aes_sbox(word[15:8]), aes_sbox(word[7:0])};\n    endfunction\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output reg [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box values\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7c; // ... fill in all values\n    end\n\n    always @(*) begin\n        b = sbox[a];\n    end\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            out <= {out[23:0], 8'h00} ^ (out[31] ? 32'h1b_00_00_00 : 32'h00_00_00_00);\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 10, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    // State encoding\n    localparam IDLE = 3'b000, INIT_ROUND = 3'b001, ROUND_OP = 3'b010, FINAL_ROUND = 3'b011, DONE = 3'b100;\n    reg [2:0] state, next_state;\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = ld ? INIT_ROUND : IDLE;\n            INIT_ROUND: next_state = ROUND_OP;\n            ROUND_OP: next_state = (dcnt == 4'h1) ? FINAL_ROUND : ROUND_OP;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic and operations\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            dcnt <= 4'hB;\n            text_out <= 128'b0;\n        end else begin\n            case (state)\n                INIT_ROUND: begin\n                    text_in_r <= text_in;\n                    // Initial AddRoundKey\n                    {sa[0][0], sa[1][0], sa[2][0], sa[3][0]} <= text_in[127:96] ^ wo_0;\n                    {sa[0][1], sa[1][1], sa[2][1], sa[3][1]} <= text_in[95:64] ^ wo_1;\n                    {sa[0][2], sa[1][2], sa[2][2], sa[3][2]} <= text_in[63:32] ^ wo_2;\n                    {sa[0][3], sa[1][3], sa[2][3], sa[3][3]} <= text_in[31:0] ^ wo_3;\n                end\n                ROUND_OP: begin\n                    // Perform SubBytes, ShiftRows, MixColumns, AddRoundKey\n                    // Decrement round counter\n                    dcnt <= dcnt - 1;\n                end\n                FINAL_ROUND: begin\n                    // Perform SubBytes, ShiftRows, AddRoundKey\n                    // No MixColumns\n                    done <= 1;\n                    text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0], sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                                 sa[0][2], sa[1][2], sa[2][2], sa[3][2], sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                end\n                DONE: begin\n                    done <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0, wo_1, wo_2, wo_3\n);\n\n    reg [31:0] w [0:43];\n    reg [3:0] rcon;\n    wire [31:0] temp;\n    wire [31:0] rcon_val;\n\n    aes_rcon rcon_gen (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon_val)\n    );\n\n    aes_sbox sbox_u0 (.a(temp[23:16]), .b(temp[31:24]));\n    aes_sbox sbox_u1 (.a(temp[15:8]), .b(temp[23:16]));\n    aes_sbox sbox_u2 (.a(temp[7:0]), .b(temp[15:8]));\n    aes_sbox sbox_u3 (.a(temp[31:24]), .b(temp[7:0]));\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcon <= 4'h1;\n        end else begin\n            w[4] <= w[0] ^ temp ^ rcon_val;\n            w[5] <= w[4] ^ w[1];\n            w[6] <= w[5] ^ w[2];\n            w[7] <= w[6] ^ w[3];\n            rcon <= rcon + 1;\n        end\n    end\n\n    assign temp = {w[3][23:0], w[3][31:24]};\n\n    always @(*) begin\n        wo_0 = w[4];\n        wo_1 = w[5];\n        wo_2 = w[6];\n        wo_3 = w[7];\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box with precomputed values\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7c; // ... fill in the rest\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'h0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 4'hA) begin\n            rcnt <= rcnt + 1;\n            case (rcnt)\n                4'h0: out <= 32'h01_00_00_00;\n                4'h1: out <= 32'h02_00_00_00;\n                4'h2: out <= 32'h04_00_00_00;\n                4'h3: out <= 32'h08_00_00_00;\n                4'h4: out <= 32'h10_00_00_00;\n                4'h5: out <= 32'h20_00_00_00;\n                4'h6: out <= 32'h40_00_00_00;\n                4'h7: out <= 32'h80_00_00_00;\n                4'h8: out <= 32'h1B_00_00_00;\n                4'h9: out <= 32'h36_00_00_00;\n                default: out <= 32'h00_00_00_00;\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 11, "code": "module aes_cipher_top (\n    input clk,\n    input rst,\n    input ld,\n    output reg done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg [127:0] text_out\n);\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n    aes_key_expand_128 key_expander (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            dcnt <= 4'hB;\n            ld_r <= 0;\n        end else begin\n            ld_r <= ld;\n            if (ld_r) begin\n                text_in_r <= text_in;\n                // Initial AddRoundKey\n                // Load text_in_r to state matrix sa\n                // Perform AddRoundKey with initial key\n                dcnt <= 4'hB;\n            end else if (dcnt != 0) begin\n                // Perform SubBytes, ShiftRows, MixColumns, AddRoundKey\n                dcnt <= dcnt - 1;\n            end else begin\n                // Final round operations\n                done <= 1;\n                text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                             sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                             sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                             sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n            end\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    reg [31:0] w [0:43];\n    reg [3:0] rcnt;\n    wire [31:0] rcon_out;\n\n    aes_rcon rcon (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon_out)\n    );\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 0;\n        end else if (rcnt < 10) begin\n            w[4*rcnt+4] <= w[4*rcnt] ^ rcon_out ^ {w[4*rcnt+3][23:0], w[4*rcnt+3][31:24]};\n            w[4*rcnt+5] <= w[4*rcnt+1] ^ w[4*rcnt+4];\n            w[4*rcnt+6] <= w[4*rcnt+2] ^ w[4*rcnt+5];\n            w[4*rcnt+7] <= w[4*rcnt+3] ^ w[4*rcnt+6];\n            rcnt <= rcnt + 1;\n        end\n    end\n\n    always @(*) begin\n        wo_0 = w[4*rcnt];\n        wo_1 = w[4*rcnt+1];\n        wo_2 = w[4*rcnt+2];\n        wo_3 = w[4*rcnt+3];\n    end\nendmodule\n\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    reg [7:0] sbox [0:255];\n    initial begin\n        // Initialize S-box values\n        // Example: sbox[0] = 8'h63; sbox[1] = 8'h7c; ...\n    end\n    assign b = sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n    reg [3:0] rcnt;\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            case (rcnt)\n                4'h0: out <= 32'h02_00_00_00;\n                4'h1: out <= 32'h04_00_00_00;\n                4'h2: out <= 32'h08_00_00_00;\n                4'h3: out <= 32'h10_00_00_00;\n                4'h4: out <= 32'h20_00_00_00;\n                4'h5: out <= 32'h40_00_00_00;\n                4'h6: out <= 32'h80_00_00_00;\n                4'h7: out <= 32'h1B_00_00_00;\n                4'h8: out <= 32'h36_00_00_00;\n                default: out <= 32'h00_00_00_00;\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 12, "code": "module aes_cipher_top (\n    input clk,\n    input rst,\n    input ld,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg done,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n    aes_key_expand_128 key_expand (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            dcnt <= 4'b1011;\n            ld_r <= 0;\n        end else begin\n            ld_r <= ld;\n            if (ld_r) begin\n                text_in_r <= text_in;\n                dcnt <= 4'b1011;\n                done <= 0;\n            end else if (dcnt != 0) begin\n                // Perform AES operations here\n                dcnt <= dcnt - 1;\n            end else begin\n                done <= 1;\n                text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                             sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                             sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                             sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n            end\n        end\n    end\n\n    // SubBytes, ShiftRows, MixColumns, AddRoundKey logic to be implemented\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w [0:43];\n    reg [3:0] rcon;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcon <= 4'b0001;\n        end else begin\n            // Key expansion logic\n        end\n    end\n\n    assign wo_0 = w[0];\n    assign wo_1 = w[1];\n    assign wo_2 = w[2];\n    assign wo_3 = w[3];\n\nendmodule\n\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box values\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 9) begin\n            rcnt <= rcnt + 1;\n            // Update out with next round constant\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 13, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n    aes_key_expand_128 key_expand (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            dcnt <= 4'hB;\n            ld_r <= 0;\n            text_out <= 128'h0;\n        end else begin\n            ld_r <= ld;\n            if (ld_r) begin\n                text_in_r <= text_in;\n                dcnt <= 4'hB;\n            end else if (dcnt != 0) begin\n                // Perform AES operations here\n                dcnt <= dcnt - 1;\n            end else begin\n                text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                             sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                             sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                             sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                done <= 1;\n            end\n        end\n    end\n\n    // SubBytes, ShiftRows, MixColumns, AddRoundKey operations go here\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\n    reg [31:0] w [0:43];\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 0;\n        end else if (rcnt < 10) begin\n            // Key expansion logic\n            rcnt <= rcnt + 1;\n        end\n    end\n\n    always @* begin\n        wo_0 = w[rcnt * 4];\n        wo_1 = w[rcnt * 4 + 1];\n        wo_2 = w[rcnt * 4 + 2];\n        wo_3 = w[rcnt * 4 + 3];\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box values\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            // Update out with the next round constant\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 14, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    // State machine states\n    typedef enum reg [2:0] {\n        IDLE,\n        INIT_ROUND,\n        ROUND_OP,\n        FINAL_ROUND,\n        DONE\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = ld ? INIT_ROUND : IDLE;\n            INIT_ROUND: next_state = ROUND_OP;\n            ROUND_OP: next_state = (dcnt == 4'd1) ? FINAL_ROUND : ROUND_OP;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output and internal register logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            text_out <= 0;\n            text_in_r <= 0;\n            dcnt <= 4'd11;\n            ld_r <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (ld) begin\n                        text_in_r <= text_in;\n                        ld_r <= 1;\n                    end\n                end\n                INIT_ROUND: begin\n                    // Initial round key addition\n                    {sa[0][0], sa[1][0], sa[2][0], sa[3][0]} <= text_in_r[127:96] ^ {wo_0};\n                    {sa[0][1], sa[1][1], sa[2][1], sa[3][1]} <= text_in_r[95:64] ^ {wo_1};\n                    {sa[0][2], sa[1][2], sa[2][2], sa[3][2]} <= text_in_r[63:32] ^ {wo_2};\n                    {sa[0][3], sa[1][3], sa[2][3], sa[3][3]} <= text_in_r[31:0] ^ {wo_3};\n                    dcnt <= 4'd10;\n                end\n                ROUND_OP: begin\n                    // Perform SubBytes, ShiftRows, MixColumns, AddRoundKey\n                    // Update state matrix sa and decrement dcnt\n                    dcnt <= dcnt - 1;\n                end\n                FINAL_ROUND: begin\n                    // Perform SubBytes, ShiftRows, AddRoundKey\n                    // Update text_out\n                    done <= 1;\n                end\n                DONE: begin\n                    done <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\n    reg [31:0] w [0:43];\n    integer i;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n        end else begin\n            for (i = 4; i < 44; i = i + 1) begin\n                if (i % 4 == 0)\n                    w[i] <= w[i-4] ^ aes_sbox(w[i-1]) ^ aes_rcon(i/4);\n                else\n                    w[i] <= w[i-4] ^ w[i-1];\n            end\n        end\n    end\n\n    always @(*) begin\n        wo_0 = w[40];\n        wo_1 = w[41];\n        wo_2 = w[42];\n        wo_3 = w[43];\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box values\n        // Example: sbox[0] = 8'h63;\n        // Fill in the rest of the S-box values\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'd0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 4'd10) begin\n            rcnt <= rcnt + 1;\n            out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1b_00_00_00 : 32'h00_00_00_00);\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 15, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            dcnt <= 4'hB;\n            ld_r <= 0;\n        end else begin\n            ld_r <= ld;\n            if (ld_r) begin\n                text_in_r <= text_in;\n                // Load input data into state matrix\n                {sa[0][0], sa[1][0], sa[2][0], sa[3][0]} <= text_in_r[127:96];\n                {sa[0][1], sa[1][1], sa[2][1], sa[3][1]} <= text_in_r[95:64];\n                {sa[0][2], sa[1][2], sa[2][2], sa[3][2]} <= text_in_r[63:32];\n                {sa[0][3], sa[1][3], sa[2][3], sa[3][3]} <= text_in_r[31:0];\n                // Initial round key addition\n                {sa[0][0], sa[1][0], sa[2][0], sa[3][0]} <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0]} ^ wo_0;\n                {sa[0][1], sa[1][1], sa[2][1], sa[3][1]} <= {sa[0][1], sa[1][1], sa[2][1], sa[3][1]} ^ wo_1;\n                {sa[0][2], sa[1][2], sa[2][2], sa[3][2]} <= {sa[0][2], sa[1][2], sa[2][2], sa[3][2]} ^ wo_2;\n                {sa[0][3], sa[1][3], sa[2][3], sa[3][3]} <= {sa[0][3], sa[1][3], sa[2][3], sa[3][3]} ^ wo_3;\n                dcnt <= 4'hA;\n            end else if (dcnt != 0) begin\n                // Perform AES round operations\n                // SubBytes, ShiftRows, MixColumns, AddRoundKey\n                // Final round does not include MixColumns\n                dcnt <= dcnt - 1;\n            end else begin\n                done <= 1;\n                // Output the final ciphertext\n                text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                             sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                             sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                             sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n            end\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\n    reg [31:0] w [0:43];\n    reg [3:0] rcnt;\n\n    aes_rcon rcon (\n        .clk(clk),\n        .kld(kld),\n        .out(w[0])\n    );\n\n    always @(posedge clk) begin\n        if (kld) begin\n            {w[0], w[1], w[2], w[3]} <= key;\n            rcnt <= 0;\n        end else begin\n            if (rcnt < 10) begin\n                w[4*rcnt+4] <= w[4*rcnt] ^ aes_sbox(w[4*rcnt+3][23:16]) ^ w[4*rcnt+3][31:24] ^ rcon(rcnt);\n                w[4*rcnt+5] <= w[4*rcnt+1] ^ w[4*rcnt+4];\n                w[4*rcnt+6] <= w[4*rcnt+2] ^ w[4*rcnt+5];\n                w[4*rcnt+7] <= w[4*rcnt+3] ^ w[4*rcnt+6];\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\n    assign {wo_0, wo_1, wo_2, wo_3} = {w[4*rcnt], w[4*rcnt+1], w[4*rcnt+2], w[4*rcnt+3]};\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box with predefined values\n        // Example: sbox[0] = 8'h63; sbox[1] = 8'h7c; ...\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1b_00_00_00 : 32'h00_00_00_00);\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 16, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] round_key [0:3];\n    aes_key_expand_128 key_expand (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(round_key[0]),\n        .wo_1(round_key[1]),\n        .wo_2(round_key[2]),\n        .wo_3(round_key[3])\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            dcnt <= 4'hB;\n            ld_r <= 0;\n            text_out <= 128'b0;\n        end else begin\n            ld_r <= ld;\n            if (ld_r) begin\n                text_in_r <= text_in;\n                // Initial round key addition\n                // Load input data into state matrix\n                // Set round counter\n                dcnt <= 4'hB;\n            end else if (dcnt != 0) begin\n                // Perform round operations\n                // SubBytes, ShiftRows, MixColumns, AddRoundKey\n                dcnt <= dcnt - 1;\n            end else begin\n                // Final round\n                // Skip MixColumns\n                // Set done signal\n                done <= 1;\n                text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                             sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                             sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                             sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n            end\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\n    reg [31:0] w [0:43];\n    reg [3:0] rcnt;\n    wire [31:0] rcon;\n\n    aes_rcon rcon_gen (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 0;\n        end else begin\n            if (rcnt < 10) begin\n                w[4*rcnt+4] <= w[4*rcnt] ^ rcon ^ {w[4*rcnt+3][23:0], w[4*rcnt+3][31:24]};\n                w[4*rcnt+5] <= w[4*rcnt+1] ^ w[4*rcnt+4];\n                w[4*rcnt+6] <= w[4*rcnt+2] ^ w[4*rcnt+5];\n                w[4*rcnt+7] <= w[4*rcnt+3] ^ w[4*rcnt+6];\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        wo_0 = w[4*rcnt];\n        wo_1 = w[4*rcnt+1];\n        wo_2 = w[4*rcnt+2];\n        wo_3 = w[4*rcnt+3];\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box values\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7c; sbox[8'h02] = 8'h77; sbox[8'h03] = 8'h7b;\n        // ... (initialize all 256 values)\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 9) begin\n            rcnt <= rcnt + 1;\n            out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1b_00_00_00 : 32'h00_00_00_00);\n        end else begin\n            out <= 32'h00_00_00_00;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 17, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n    // Internal registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    // Submodules\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n    aes_key_expand_128 key_expander (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    // State machine states\n    typedef enum reg [2:0] {\n        IDLE,\n        INIT_ROUND,\n        ROUND_OP,\n        FINAL_ROUND,\n        DONE\n    } state_t;\n    state_t state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = ld ? INIT_ROUND : IDLE;\n            INIT_ROUND: next_state = ROUND_OP;\n            ROUND_OP: next_state = (dcnt == 4'd1) ? FINAL_ROUND : ROUND_OP;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output and internal register logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            text_out <= 0;\n            text_in_r <= 0;\n            dcnt <= 4'd11;\n            ld_r <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (ld) begin\n                        text_in_r <= text_in;\n                        ld_r <= 1;\n                    end\n                end\n                INIT_ROUND: begin\n                    // Initial round key addition\n                    // Load input data into state matrix\n                    // Set round counter\n                    dcnt <= 4'd10;\n                end\n                ROUND_OP: begin\n                    // Perform SubBytes, ShiftRows, MixColumns, AddRoundKey\n                    dcnt <= dcnt - 1;\n                end\n                FINAL_ROUND: begin\n                    // Perform SubBytes, ShiftRows, AddRoundKey\n                    text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                                 sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                                 sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                                 sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                end\n                DONE: begin\n                    done <= 1;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    // Internal registers\n    reg [31:0] w [0:3];\n    wire [31:0] rcon_out;\n    wire [7:0] sbox_out [0:3];\n\n    // Submodules\n    aes_rcon rcon (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon_out)\n    );\n\n    aes_sbox sbox0 (.a(w[3][23:16]), .b(sbox_out[0]));\n    aes_sbox sbox1 (.a(w[3][15:8]), .b(sbox_out[1]));\n    aes_sbox sbox2 (.a(w[3][7:0]), .b(sbox_out[2]));\n    aes_sbox sbox3 (.a(w[3][31:24]), .b(sbox_out[3]));\n\n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n        end else begin\n            w[0] <= w[0] ^ {sbox_out[3], sbox_out[2], sbox_out[1], sbox_out[0]} ^ rcon_out;\n            w[1] <= w[1] ^ w[0];\n            w[2] <= w[2] ^ w[1];\n            w[3] <= w[3] ^ w[2];\n        end\n    end\n\n    // Output assignment\n    always @(*) begin\n        wo_0 = w[0];\n        wo_1 = w[1];\n        wo_2 = w[2];\n        wo_3 = w[3];\n    end\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output reg [7:0] b\n);\n    // S-box lookup table\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box values\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7c; sbox[8'h02] = 8'h77; sbox[8'h03] = 8'h7b;\n        // ... (initialize all 256 values)\n        sbox[8'hfc] = 8'hd7; sbox[8'hfd] = 8'hab; sbox[8'hfe] = 8'h76; sbox[8'hff] = 8'hca;\n    end\n\n    always @(*) begin\n        b = sbox[a];\n    end\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'd0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 4'd9) begin\n            rcnt <= rcnt + 1;\n            case (rcnt)\n                4'd0: out <= 32'h02_00_00_00;\n                4'd1: out <= 32'h04_00_00_00;\n                4'd2: out <= 32'h08_00_00_00;\n                4'd3: out <= 32'h10_00_00_00;\n                4'd4: out <= 32'h20_00_00_00;\n                4'd5: out <= 32'h40_00_00_00;\n                4'd6: out <= 32'h80_00_00_00;\n                4'd7: out <= 32'h1b_00_00_00;\n                4'd8: out <= 32'h36_00_00_00;\n                default: out <= 32'h00_00_00_00;\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 18, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n    wire [7:0] subbytes_out [0:3][0:3];\n\n    aes_key_expand_128 key_expand (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    genvar i, j;\n    generate\n        for (i = 0; i < 4; i = i + 1) begin : row\n            for (j = 0; j < 4; j = j + 1) begin : col\n                aes_sbox sbox (\n                    .a(sa[i][j]),\n                    .b(subbytes_out[i][j])\n                );\n            end\n        end\n    endgenerate\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            dcnt <= 4'hB;\n            ld_r <= 1'b0;\n            done <= 1'b0;\n        end else if (ld) begin\n            text_in_r <= text_in;\n            ld_r <= 1'b1;\n            dcnt <= 4'hB;\n        end else if (ld_r) begin\n            if (dcnt == 4'h0) begin\n                done <= 1'b1;\n                text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                             sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                             sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                             sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                ld_r <= 1'b0;\n            end else begin\n                // Perform AES round operations\n                // SubBytes, ShiftRows, MixColumns, AddRoundKey\n                // Update state matrix sa\n                dcnt <= dcnt - 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\n    reg [31:0] w [0:43];\n    reg [3:0] rcon;\n    wire [31:0] temp;\n    wire [7:0] sbox_out [0:3];\n\n    aes_rcon rcon_gen (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    genvar i;\n    generate\n        for (i = 0; i < 4; i = i + 1) begin : sbox_gen\n            aes_sbox sbox (\n                .a(temp[8*i +: 8]),\n                .b(sbox_out[i])\n            );\n        end\n    endgenerate\n\n    assign temp = {sbox_out[1], sbox_out[2], sbox_out[3], sbox_out[0]} ^ {rcon, 24'h0};\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n        end else begin\n            w[4] <= w[0] ^ temp;\n            w[5] <= w[1] ^ w[4];\n            w[6] <= w[2] ^ w[5];\n            w[7] <= w[3] ^ w[6];\n            // Continue key expansion\n        end\n        wo_0 <= w[0];\n        wo_1 <= w[1];\n        wo_2 <= w[2];\n        wo_3 <= w[3];\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box with precomputed values\n        // sbox[0] = 8'h63; sbox[1] = 8'h7c; ...\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'h0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 4'h9) begin\n            rcnt <= rcnt + 1;\n            out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1b_00_00_00 : 32'h0);\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 1, "code": "module aes_inv_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire kld,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n\n    wire [31:0] wk0, wk1, wk2, wk3;\n    wire [7:0] us00, us01, us02, us03;\n    wire [7:0] us10, us11, us12, us13;\n    wire [7:0] us20, us21, us22, us23;\n    wire [7:0] us30, us31, us32, us33;\n\n    aes_key_expand_128 key_expand (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox us00_inst (.a(sa[0][0]), .b(us00));\n    aes_inv_sbox us01_inst (.a(sa[0][1]), .b(us01));\n    aes_inv_sbox us02_inst (.a(sa[0][2]), .b(us02));\n    aes_inv_sbox us03_inst (.a(sa[0][3]), .b(us03));\n    aes_inv_sbox us10_inst (.a(sa[1][0]), .b(us10));\n    aes_inv_sbox us11_inst (.a(sa[1][1]), .b(us11));\n    aes_inv_sbox us12_inst (.a(sa[1][2]), .b(us12));\n    aes_inv_sbox us13_inst (.a(sa[1][3]), .b(us13));\n    aes_inv_sbox us20_inst (.a(sa[2][0]), .b(us20));\n    aes_inv_sbox us21_inst (.a(sa[2][1]), .b(us21));\n    aes_inv_sbox us22_inst (.a(sa[2][2]), .b(us22));\n    aes_inv_sbox us23_inst (.a(sa[2][3]), .b(us23));\n    aes_inv_sbox us30_inst (.a(sa[3][0]), .b(us30));\n    aes_inv_sbox us31_inst (.a(sa[3][1]), .b(us31));\n    aes_inv_sbox us32_inst (.a(sa[3][2]), .b(us32));\n    aes_inv_sbox us33_inst (.a(sa[3][3]), .b(us33));\n\n    // State machine and control logic here...\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\n    // Key expansion logic here...\n\nendmodule\n\nmodule aes_inv_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] inv_sbox [0:255];\n\n    initial begin\n        // Initialize inv_sbox with precomputed values\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'd0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 4'd9) begin\n            rcnt <= rcnt + 1;\n            // Update out based on rcnt\n        end\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize sbox with precomputed values\n    end\n\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 19, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    // State encoding\n    localparam IDLE = 3'b000,\n               INIT_ROUND = 3'b001,\n               ROUND_OP = 3'b010,\n               FINAL_ROUND = 3'b011,\n               DONE = 3'b100;\n\n    reg [2:0] state, next_state;\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = ld ? INIT_ROUND : IDLE;\n            INIT_ROUND: next_state = ROUND_OP;\n            ROUND_OP: next_state = (dcnt == 4'd1) ? FINAL_ROUND : ROUND_OP;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic and operations\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            text_out <= 0;\n            dcnt <= 4'd11;\n            ld_r <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (ld) begin\n                        text_in_r <= text_in;\n                        ld_r <= 1;\n                    end\n                end\n                INIT_ROUND: begin\n                    // Initial round key addition\n                    // Load text_in_r to state matrix sa\n                    // AddRoundKey operation\n                    dcnt <= 4'd10;\n                end\n                ROUND_OP: begin\n                    // Perform SubBytes, ShiftRows, MixColumns, AddRoundKey\n                    dcnt <= dcnt - 1;\n                end\n                FINAL_ROUND: begin\n                    // Perform SubBytes, ShiftRows, AddRoundKey\n                    // Skip MixColumns\n                    text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                                 sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                                 sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                                 sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                end\n                DONE: begin\n                    done <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    reg [31:0] w [0:3];\n    reg [3:0] rcnt;\n\n    // Key loading and expansion\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 0;\n        end else begin\n            if (rcnt < 10) begin\n                // Key expansion logic\n                // RotWord, SubWord, Rcon XOR\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        wo_0 = w[0];\n        wo_1 = w[1];\n        wo_2 = w[2];\n        wo_3 = w[3];\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box values\n        // Example: sbox[0] = 8'h63;\n    end\n\n    assign b = sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            // Rcon generation logic\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_cipher_top", "codeid": 20, "code": "module aes_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg ld_r;\n\n    wire [31:0] wo_0, wo_1, wo_2, wo_3;\n\n    aes_key_expand_128 key_expand (\n        .clk(clk),\n        .kld(ld),\n        .key(key),\n        .wo_0(wo_0),\n        .wo_1(wo_1),\n        .wo_2(wo_2),\n        .wo_3(wo_3)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            dcnt <= 4'hB;\n            ld_r <= 0;\n        end else begin\n            ld_r <= ld;\n            if (ld_r) begin\n                text_in_r <= text_in;\n                // Load input data into state matrix\n                {sa[0][0], sa[1][0], sa[2][0], sa[3][0]} <= text_in[127:96];\n                {sa[0][1], sa[1][1], sa[2][1], sa[3][1]} <= text_in[95:64];\n                {sa[0][2], sa[1][2], sa[2][2], sa[3][2]} <= text_in[63:32];\n                {sa[0][3], sa[1][3], sa[2][3], sa[3][3]} <= text_in[31:0];\n                // Initial round key addition\n                {sa[0][0], sa[1][0], sa[2][0], sa[3][0]} <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0]} ^ wo_0;\n                {sa[0][1], sa[1][1], sa[2][1], sa[3][1]} <= {sa[0][1], sa[1][1], sa[2][1], sa[3][1]} ^ wo_1;\n                {sa[0][2], sa[1][2], sa[2][2], sa[3][2]} <= {sa[0][2], sa[1][2], sa[2][2], sa[3][2]} ^ wo_2;\n                {sa[0][3], sa[1][3], sa[2][3], sa[3][3]} <= {sa[0][3], sa[1][3], sa[2][3], sa[3][3]} ^ wo_3;\n                dcnt <= 4'hA;\n            end else if (dcnt != 0) begin\n                // Perform round operations\n                // SubBytes, ShiftRows, MixColumns, AddRoundKey\n                // (Implement these operations here)\n                dcnt <= dcnt - 1;\n            end else begin\n                // Final round\n                // SubBytes, ShiftRows, AddRoundKey\n                // (Implement these operations here)\n                text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                             sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                             sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                             sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                done <= 1;\n            end\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    reg [31:0] w [0:43];\n    reg [3:0] rcnt;\n\n    aes_rcon rcon (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon_out)\n    );\n\n    aes_sbox sbox0 (.a(w[rcnt-1][23:16]), .b(sbox_out[31:24]));\n    aes_sbox sbox1 (.a(w[rcnt-1][15:8]), .b(sbox_out[23:16]));\n    aes_sbox sbox2 (.a(w[rcnt-1][7:0]), .b(sbox_out[15:8]));\n    aes_sbox sbox3 (.a(w[rcnt-1][31:24]), .b(sbox_out[7:0]));\n\n    always @(posedge clk or posedge kld) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 4'h1;\n        end else if (rcnt < 11) begin\n            w[rcnt*4] <= w[(rcnt-1)*4] ^ sbox_out ^ rcon_out;\n            w[rcnt*4+1] <= w[(rcnt-1)*4+1] ^ w[rcnt*4];\n            w[rcnt*4+2] <= w[(rcnt-1)*4+2] ^ w[rcnt*4+1];\n            w[rcnt*4+3] <= w[(rcnt-1)*4+3] ^ w[rcnt*4+2];\n            rcnt <= rcnt + 1;\n        end\n    end\n\n    always @(*) begin\n        wo_0 = w[rcnt*4];\n        wo_1 = w[rcnt*4+1];\n        wo_2 = w[rcnt*4+2];\n        wo_3 = w[rcnt*4+3];\n    end\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    reg [7:0] sbox [0:255];\n    initial begin\n        // Initialize S-box with predefined values\n        // (Fill in the S-box values here)\n    end\n    assign b = sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n    reg [3:0] rcnt;\n    always @(posedge clk or posedge kld) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1B_00_00_00 : 32'h00_00_00_00);\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 2, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output reg done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg [127:0] text_out\n);\n    // Internal registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n\n    // Submodule instances\n    aes_key_expand_128 key_expander (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox us00 (.a(sa[0][0]), .b(sub[0][0]));\n    aes_inv_sbox us01 (.a(sa[0][1]), .b(sub[0][1]));\n    aes_inv_sbox us02 (.a(sa[0][2]), .b(sub[0][2]));\n    aes_inv_sbox us03 (.a(sa[0][3]), .b(sub[0][3]));\n    aes_inv_sbox us10 (.a(sa[1][0]), .b(sub[1][0]));\n    aes_inv_sbox us11 (.a(sa[1][1]), .b(sub[1][1]));\n    aes_inv_sbox us12 (.a(sa[1][2]), .b(sub[1][2]));\n    aes_inv_sbox us13 (.a(sa[1][3]), .b(sub[1][3]));\n    aes_inv_sbox us20 (.a(sa[2][0]), .b(sub[2][0]));\n    aes_inv_sbox us21 (.a(sa[2][1]), .b(sub[2][1]));\n    aes_inv_sbox us22 (.a(sa[2][2]), .b(sub[2][2]));\n    aes_inv_sbox us23 (.a(sa[2][3]), .b(sub[2][3]));\n    aes_inv_sbox us30 (.a(sa[3][0]), .b(sub[3][0]));\n    aes_inv_sbox us31 (.a(sa[3][1]), .b(sub[3][1]));\n    aes_inv_sbox us32 (.a(sa[3][2]), .b(sub[3][2]));\n    aes_inv_sbox us33 (.a(sa[3][3]), .b(sub[3][3]));\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset logic\n            dcnt <= 4'd0;\n            kcnt <= 4'd10;\n            ld_r <= 1'b0;\n            done <= 1'b0;\n            text_out <= 128'd0;\n        end else begin\n            // State transitions and operations\n            case (state)\n                IDLE: begin\n                    if (kld) state <= KEY_LOAD;\n                    else if (ld) state <= INITIAL_ROUND;\n                end\n                KEY_LOAD: begin\n                    // Key loading logic\n                end\n                INITIAL_ROUND: begin\n                    // Initial round logic\n                end\n                STANDARD_ROUND: begin\n                    // Standard round logic\n                end\n                FINAL_ROUND: begin\n                    // Final round logic\n                end\n                DONE: begin\n                    done <= 1'b1;\n                    state <= IDLE;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n    // Key expansion logic\nendmodule\n\nmodule aes_inv_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // Inverse S-box logic\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output [31:0] out\n);\n    // Round constant generation logic\nendmodule\n\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // S-box logic\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 3, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg done,\n    output reg [127:0] text_out\n);\n    // Internal signals and registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    wire [127:0] sa_ark, sa_next;\n    wire [31:0] wk0, wk1, wk2, wk3;\n\n    // Key expansion module\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    // Inverse S-box instances\n    aes_inv_sbox us00 (.a(sa[0][0]), .b(sa_ark[127:120]));\n    aes_inv_sbox us01 (.a(sa[0][1]), .b(sa_ark[119:112]));\n    aes_inv_sbox us02 (.a(sa[0][2]), .b(sa_ark[111:104]));\n    aes_inv_sbox us03 (.a(sa[0][3]), .b(sa_ark[103:96]));\n    aes_inv_sbox us10 (.a(sa[1][0]), .b(sa_ark[95:88]));\n    aes_inv_sbox us11 (.a(sa[1][1]), .b(sa_ark[87:80]));\n    aes_inv_sbox us12 (.a(sa[1][2]), .b(sa_ark[79:72]));\n    aes_inv_sbox us13 (.a(sa[1][3]), .b(sa_ark[71:64]));\n    aes_inv_sbox us20 (.a(sa[2][0]), .b(sa_ark[63:56]));\n    aes_inv_sbox us21 (.a(sa[2][1]), .b(sa_ark[55:48]));\n    aes_inv_sbox us22 (.a(sa[2][2]), .b(sa_ark[47:40]));\n    aes_inv_sbox us23 (.a(sa[2][3]), .b(sa_ark[39:32]));\n    aes_inv_sbox us30 (.a(sa[3][0]), .b(sa_ark[31:24]));\n    aes_inv_sbox us31 (.a(sa[3][1]), .b(sa_ark[23:16]));\n    aes_inv_sbox us32 (.a(sa[3][2]), .b(sa_ark[15:8]));\n    aes_inv_sbox us33 (.a(sa[3][3]), .b(sa_ark[7:0]));\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            dcnt <= 4'b0;\n            kcnt <= 4'b1010;\n            ld_r <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            // State transitions and operations\n            // ...\n        end\n    end\n\n    // Round transformations\n    // InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns\n    // ...\n\n    // Final output generation\n    always @(posedge clk) begin\n        if (done) begin\n            text_out <= sa_ark;\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n    // Internal signals and registers\n    reg [31:0] w [0:43];\n    reg [3:0] rcon;\n\n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcon <= 4'b0001;\n        end else begin\n            // Key expansion algorithm\n            // ...\n        end\n    end\n\n    assign wo_0 = w[40];\n    assign wo_1 = w[41];\n    assign wo_2 = w[42];\n    assign wo_3 = w[43];\nendmodule\n\nmodule aes_inv_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox [0:255];\n\n    initial begin\n        // Initialize inverse S-box values\n        // ...\n    end\n\n    assign b = inv_sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'b0000;\n            out <= 32'h01000000;\n        end else if (rcnt < 4'b1010) begin\n            rcnt <= rcnt + 1;\n            // Generate round constant\n            // ...\n        end\n    end\nendmodule\n\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // S-box lookup table\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box values\n        // ...\n    end\n\n    assign b = sbox[a];\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 4, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output reg done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg [127:0] text_out\n);\n    // Registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n\n    // Submodules\n    wire [31:0] wk0, wk1, wk2, wk3;\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    wire [7:0] us [0:3][0:3];\n    genvar i, j;\n    generate\n        for (i = 0; i < 4; i = i + 1) begin : row\n            for (j = 0; j < 4; j = j + 1) begin : col\n                aes_inv_sbox inv_sbox (\n                    .a(sa[i][j]),\n                    .b(us[i][j])\n                );\n            end\n        end\n    endgenerate\n\n    // State Machine\n    typedef enum reg [2:0] {\n        IDLE,\n        KEY_LOAD,\n        KEY_EXPANSION,\n        KEY_STORED,\n        INITIAL_ROUND,\n        STANDARD_ROUND,\n        FINAL_ROUND,\n        DONE\n    } state_t;\n\n    state_t state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (kld) ? KEY_LOAD : (ld) ? INITIAL_ROUND : IDLE;\n            KEY_LOAD: next_state = KEY_EXPANSION;\n            KEY_EXPANSION: next_state = (kcnt == 0) ? KEY_STORED : KEY_EXPANSION;\n            KEY_STORED: next_state = (ld) ? INITIAL_ROUND : KEY_STORED;\n            INITIAL_ROUND: next_state = STANDARD_ROUND;\n            STANDARD_ROUND: next_state = (dcnt == 10) ? FINAL_ROUND : STANDARD_ROUND;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Control Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 4'hA;\n            ld_r <= 0;\n            done <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    dcnt <= 0;\n                    kcnt <= 4'hA;\n                    ld_r <= 0;\n                    done <= 0;\n                end\n                KEY_LOAD: begin\n                    kcnt <= kcnt - 1;\n                end\n                INITIAL_ROUND: begin\n                    dcnt <= dcnt + 1;\n                    ld_r <= 1;\n                end\n                STANDARD_ROUND: begin\n                    dcnt <= dcnt + 1;\n                end\n                FINAL_ROUND: begin\n                    done <= 1;\n                end\n            endcase\n        end\n    end\n\n    // Data Path\n    always @(posedge clk) begin\n        if (ld_r) begin\n            text_in_r <= text_in;\n            // Initial round key addition\n            // Map input to state matrix\n        end else if (state == STANDARD_ROUND || state == FINAL_ROUND) begin\n            // Perform InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns\n        end\n    end\n\n    // Output Logic\n    always @(posedge clk) begin\n        if (state == DONE) begin\n            text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                         sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                         sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                         sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    // Key expansion logic\n    // ...\n\nendmodule\n\nmodule aes_inv_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox [0:255];\n    initial begin\n        // Initialize inv_sbox with values\n    end\n    assign b = inv_sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n    reg [3:0] rcnt;\n    always @(posedge clk or posedge kld) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else begin\n            rcnt <= rcnt + 1;\n            // Update out based on rcnt\n        end\n    end\nendmodule\n\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // S-box lookup table\n    reg [7:0] sbox [0:255];\n    initial begin\n        // Initialize sbox with values\n    end\n    assign b = sbox[a];\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 5, "code": "module aes_inv_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire kld,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n    // Internal registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n\n    // Submodules\n    wire [31:0] wk0, wk1, wk2, wk3;\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    wire [7:0] us00, us01, us02, us03;\n    wire [7:0] us10, us11, us12, us13;\n    wire [7:0] us20, us21, us22, us23;\n    wire [7:0] us30, us31, us32, us33;\n\n    aes_inv_sbox inv_sbox00 (.a(sa[0][0]), .b(us00));\n    aes_inv_sbox inv_sbox01 (.a(sa[0][1]), .b(us01));\n    aes_inv_sbox inv_sbox02 (.a(sa[0][2]), .b(us02));\n    aes_inv_sbox inv_sbox03 (.a(sa[0][3]), .b(us03));\n    aes_inv_sbox inv_sbox10 (.a(sa[1][0]), .b(us10));\n    aes_inv_sbox inv_sbox11 (.a(sa[1][1]), .b(us11));\n    aes_inv_sbox inv_sbox12 (.a(sa[1][2]), .b(us12));\n    aes_inv_sbox inv_sbox13 (.a(sa[1][3]), .b(us13));\n    aes_inv_sbox inv_sbox20 (.a(sa[2][0]), .b(us20));\n    aes_inv_sbox inv_sbox21 (.a(sa[2][1]), .b(us21));\n    aes_inv_sbox inv_sbox22 (.a(sa[2][2]), .b(us22));\n    aes_inv_sbox inv_sbox23 (.a(sa[2][3]), .b(us23));\n    aes_inv_sbox inv_sbox30 (.a(sa[3][0]), .b(us30));\n    aes_inv_sbox inv_sbox31 (.a(sa[3][1]), .b(us31));\n    aes_inv_sbox inv_sbox32 (.a(sa[3][2]), .b(us32));\n    aes_inv_sbox inv_sbox33 (.a(sa[3][3]), .b(us33));\n\n    // State machine\n    typedef enum reg [2:0] {\n        IDLE,\n        KEY_LOAD,\n        KEY_EXPANSION,\n        KEY_STORED,\n        INITIAL_ROUND,\n        STANDARD_ROUND,\n        FINAL_ROUND,\n        DONE\n    } state_t;\n\n    state_t state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (kld) ? KEY_LOAD : (ld) ? INITIAL_ROUND : IDLE;\n            KEY_LOAD: next_state = KEY_EXPANSION;\n            KEY_EXPANSION: next_state = (kcnt == 0) ? KEY_STORED : KEY_EXPANSION;\n            KEY_STORED: next_state = (ld) ? INITIAL_ROUND : KEY_STORED;\n            INITIAL_ROUND: next_state = STANDARD_ROUND;\n            STANDARD_ROUND: next_state = (dcnt == 10) ? FINAL_ROUND : STANDARD_ROUND;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 4'hA;\n            ld_r <= 0;\n            done <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    dcnt <= 0;\n                    kcnt <= 4'hA;\n                    ld_r <= 0;\n                    done <= 0;\n                end\n                KEY_LOAD: begin\n                    // Load key\n                end\n                KEY_EXPANSION: begin\n                    // Expand key\n                end\n                KEY_STORED: begin\n                    // Store key\n                end\n                INITIAL_ROUND: begin\n                    // Initial round operations\n                end\n                STANDARD_ROUND: begin\n                    // Standard round operations\n                end\n                FINAL_ROUND: begin\n                    // Final round operations\n                end\n                DONE: begin\n                    done <= 1;\n                end\n            endcase\n        end\n    end\n\n    // Data path logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            text_in_r <= 0;\n            text_out <= 0;\n        end else begin\n            if (ld) begin\n                text_in_r <= text_in;\n            end\n            if (done) begin\n                text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                             sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                             sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                             sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n            end\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    // Internal registers\n    reg [31:0] w[0:43];\n    reg [3:0] rcnt;\n\n    // Submodules\n    wire [31:0] rcon_out;\n    aes_rcon rcon (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon_out)\n    );\n\n    wire [7:0] sbox_out[0:3];\n    aes_sbox sbox0 (.a(w[rcnt][23:16]), .b(sbox_out[0]));\n    aes_sbox sbox1 (.a(w[rcnt][15:8]), .b(sbox_out[1]));\n    aes_sbox sbox2 (.a(w[rcnt][7:0]), .b(sbox_out[2]));\n    aes_sbox sbox3 (.a(w[rcnt][31:24]), .b(sbox_out[3]));\n\n    // Key expansion logic\n    always @(posedge clk or posedge kld) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 0;\n        end else begin\n            if (rcnt < 10) begin\n                w[4*rcnt+4] <= w[4*rcnt] ^ {sbox_out[3], sbox_out[0], sbox_out[1], sbox_out[2]} ^ rcon_out;\n                w[4*rcnt+5] <= w[4*rcnt+1] ^ w[4*rcnt+4];\n                w[4*rcnt+6] <= w[4*rcnt+2] ^ w[4*rcnt+5];\n                w[4*rcnt+7] <= w[4*rcnt+3] ^ w[4*rcnt+6];\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        wo_0 = w[4*rcnt];\n        wo_1 = w[4*rcnt+1];\n        wo_2 = w[4*rcnt+2];\n        wo_3 = w[4*rcnt+3];\n    end\n\nendmodule\n\nmodule aes_inv_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox [0:255];\n    initial begin\n        inv_sbox[8'h00] = 8'h52; inv_sbox[8'h01] = 8'h09; inv_sbox[8'h02] = 8'h6a; inv_sbox[8'h03] = 8'hd5;\n        // ... (rest of the table)\n        inv_sbox[8'hfd] = 8'hd1; inv_sbox[8'hfe] = 8'hf8; inv_sbox[8'hff] = 8'h98;\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n    // Round constant table\n    reg [31:0] rcon [0:9];\n    initial begin\n        rcon[0] = 32'h01_00_00_00;\n        rcon[1] = 32'h02_00_00_00;\n        rcon[2] = 32'h04_00_00_00;\n        rcon[3] = 32'h08_00_00_00;\n        rcon[4] = 32'h10_00_00_00;\n        rcon[5] = 32'h20_00_00_00;\n        rcon[6] = 32'h40_00_00_00;\n        rcon[7] = 32'h80_00_00_00;\n        rcon[8] = 32'h1b_00_00_00;\n        rcon[9] = 32'h36_00_00_00;\n    end\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk or posedge kld) begin\n        if (kld) begin\n            rcnt <= 0;\n        end else if (rcnt < 9) begin\n            rcnt <= rcnt + 1;\n        end\n    end\n\n    always @(*) begin\n        out = rcon[rcnt];\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    // S-box lookup table\n    reg [7:0] sbox [0:255];\n    initial begin\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7c; sbox[8'h02] = 8'h77; sbox[8'h03] = 8'h7b;\n        // ... (rest of the table)\n        sbox[8'hfd] = 8'h16; sbox[8'hfe] = 8'hd4; sbox[8'hff] = 8'hc3;\n    end\n\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 6, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output reg done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg [127:0] text_out\n);\n    // Internal registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n\n    // Submodule instances\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox us00 (.a(sa[0][0]), .b(sa_sub[0][0]));\n    aes_inv_sbox us01 (.a(sa[0][1]), .b(sa_sub[0][1]));\n    aes_inv_sbox us02 (.a(sa[0][2]), .b(sa_sub[0][2]));\n    aes_inv_sbox us03 (.a(sa[0][3]), .b(sa_sub[0][3]));\n    aes_inv_sbox us10 (.a(sa[1][0]), .b(sa_sub[1][0]));\n    aes_inv_sbox us11 (.a(sa[1][1]), .b(sa_sub[1][1]));\n    aes_inv_sbox us12 (.a(sa[1][2]), .b(sa_sub[1][2]));\n    aes_inv_sbox us13 (.a(sa[1][3]), .b(sa_sub[1][3]));\n    aes_inv_sbox us20 (.a(sa[2][0]), .b(sa_sub[2][0]));\n    aes_inv_sbox us21 (.a(sa[2][1]), .b(sa_sub[2][1]));\n    aes_inv_sbox us22 (.a(sa[2][2]), .b(sa_sub[2][2]));\n    aes_inv_sbox us23 (.a(sa[2][3]), .b(sa_sub[2][3]));\n    aes_inv_sbox us30 (.a(sa[3][0]), .b(sa_sub[3][0]));\n    aes_inv_sbox us31 (.a(sa[3][1]), .b(sa_sub[3][1]));\n    aes_inv_sbox us32 (.a(sa[3][2]), .b(sa_sub[3][2]));\n    aes_inv_sbox us33 (.a(sa[3][3]), .b(sa_sub[3][3]));\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset logic\n            dcnt <= 0;\n            kcnt <= 4'hA;\n            ld_r <= 0;\n            done <= 0;\n        end else begin\n            // State transitions and operations\n            case (state)\n                IDLE: begin\n                    if (kld) state <= KEY_LOAD;\n                    else if (ld) state <= INITIAL_ROUND;\n                end\n                KEY_LOAD: begin\n                    // Key loading logic\n                    if (kcnt == 0) state <= KEY_STORED;\n                end\n                KEY_STORED: begin\n                    if (ld) state <= INITIAL_ROUND;\n                end\n                INITIAL_ROUND: begin\n                    // Initial round operations\n                    state <= STANDARD_ROUND;\n                end\n                STANDARD_ROUND: begin\n                    // Standard round operations\n                    if (dcnt == 10) state <= FINAL_ROUND;\n                end\n                FINAL_ROUND: begin\n                    // Final round operations\n                    state <= DONE;\n                end\n                DONE: begin\n                    done <= 1;\n                    state <= IDLE;\n                end\n            endcase\n        end\n    end\n\n    // Additional logic for transformations and key expansion\n    // ...\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n    // Key expansion logic\n    // ...\n\nendmodule\n\nmodule aes_inv_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox [0:255];\n    initial begin\n        // Initialize inv_sbox with precomputed values\n        // ...\n    end\n    assign b = inv_sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output [31:0] out\n);\n    reg [3:0] rcnt;\n    always @(posedge clk or posedge kld) begin\n        if (kld) rcnt <= 0;\n        else rcnt <= rcnt + 1;\n    end\n    assign out = (rcnt == 0) ? 32'h01_00_00_00 : (rcnt == 1) ? 32'h02_00_00_00 : // Continue for other constants\n                 (rcnt == 9) ? 32'h36_00_00_00 : 32'h00_00_00_00;\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 7, "code": "module aes_inv_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire kld,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n    // Internal signals and registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    wire [127:0] sa_ark;\n    wire [127:0] sa_next;\n\n    // Submodule instances\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(kb[0][127:96]),\n        .wo_1(kb[0][95:64]),\n        .wo_2(kb[0][63:32]),\n        .wo_3(kb[0][31:0])\n    );\n\n    aes_inv_sbox us00 (.a(sa[0][0]), .b(sa_ark[127:120]));\n    aes_inv_sbox us01 (.a(sa[0][1]), .b(sa_ark[119:112]));\n    aes_inv_sbox us02 (.a(sa[0][2]), .b(sa_ark[111:104]));\n    aes_inv_sbox us03 (.a(sa[0][3]), .b(sa_ark[103:96]));\n    aes_inv_sbox us10 (.a(sa[1][0]), .b(sa_ark[95:88]));\n    aes_inv_sbox us11 (.a(sa[1][1]), .b(sa_ark[87:80]));\n    aes_inv_sbox us12 (.a(sa[1][2]), .b(sa_ark[79:72]));\n    aes_inv_sbox us13 (.a(sa[1][3]), .b(sa_ark[71:64]));\n    aes_inv_sbox us20 (.a(sa[2][0]), .b(sa_ark[63:56]));\n    aes_inv_sbox us21 (.a(sa[2][1]), .b(sa_ark[55:48]));\n    aes_inv_sbox us22 (.a(sa[2][2]), .b(sa_ark[47:40]));\n    aes_inv_sbox us23 (.a(sa[2][3]), .b(sa_ark[39:32]));\n    aes_inv_sbox us30 (.a(sa[3][0]), .b(sa_ark[31:24]));\n    aes_inv_sbox us31 (.a(sa[3][1]), .b(sa_ark[23:16]));\n    aes_inv_sbox us32 (.a(sa[3][2]), .b(sa_ark[15:8]));\n    aes_inv_sbox us33 (.a(sa[3][3]), .b(sa_ark[7:0]));\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            dcnt <= 4'd0;\n            kcnt <= 4'd10;\n            ld_r <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            if (kld) begin\n                kcnt <= 4'd10;\n            end else if (ld) begin\n                ld_r <= 1'b1;\n                dcnt <= 4'd1;\n            end else if (ld_r) begin\n                if (dcnt == 4'd11) begin\n                    done <= 1'b1;\n                    ld_r <= 1'b0;\n                end else begin\n                    dcnt <= dcnt + 1'b1;\n                end\n            end\n        end\n    end\n\n    // Data path logic\n    always @(posedge clk) begin\n        if (ld) begin\n            text_in_r <= text_in;\n            sa[0][0] <= text_in[127:120];\n            sa[1][0] <= text_in[119:112];\n            sa[2][0] <= text_in[111:104];\n            sa[3][0] <= text_in[103:96];\n            sa[0][1] <= text_in[95:88];\n            sa[1][1] <= text_in[87:80];\n            sa[2][1] <= text_in[79:72];\n            sa[3][1] <= text_in[71:64];\n            sa[0][2] <= text_in[63:56];\n            sa[1][2] <= text_in[55:48];\n            sa[2][2] <= text_in[47:40];\n            sa[3][2] <= text_in[39:32];\n            sa[0][3] <= text_in[31:24];\n            sa[1][3] <= text_in[23:16];\n            sa[2][3] <= text_in[15:8];\n            sa[3][3] <= text_in[7:0];\n        end else if (ld_r) begin\n            // Perform InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns\n            // Update state matrix sa and text_out\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    // Internal signals and registers\n    reg [31:0] w [0:43];\n    reg [3:0] rcnt;\n    wire [31:0] rcon;\n\n    aes_rcon r0 (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    aes_sbox u0 (.a(w[3][23:16]), .b(w[4][31:24]));\n    aes_sbox u1 (.a(w[3][15:8]), .b(w[4][23:16]));\n    aes_sbox u2 (.a(w[3][7:0]), .b(w[4][15:8]));\n    aes_sbox u3 (.a(w[3][31:24]), .b(w[4][7:0]));\n\n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 4'd0;\n        end else begin\n            if (rcnt < 4'd10) begin\n                w[4] <= w[0] ^ rcon ^ {w[3][23:0], w[3][31:24]};\n                w[5] <= w[1] ^ w[4];\n                w[6] <= w[2] ^ w[5];\n                w[7] <= w[3] ^ w[6];\n                rcnt <= rcnt + 1'b1;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        wo_0 <= w[rcnt * 4];\n        wo_1 <= w[rcnt * 4 + 1];\n        wo_2 <= w[rcnt * 4 + 2];\n        wo_3 <= w[rcnt * 4 + 3];\n    end\nendmodule\n\nmodule aes_inv_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    reg [7:0] inv_sbox [0:255];\n\n    initial begin\n        // Initialize the inverse S-box lookup table\n        inv_sbox[8'h00] = 8'h52; inv_sbox[8'h01] = 8'h09; // ... fill in the rest\n    end\n\n    assign b = inv_sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'd0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 4'd10) begin\n            rcnt <= rcnt + 1'b1;\n            out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1B_00_00_00 : 32'h00_00_00_00);\n        end\n    end\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize the S-box lookup table\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7c; // ... fill in the rest\n    end\n\n    assign b = sbox[a];\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 8, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg done,\n    output reg [127:0] text_out\n);\n    // Internal registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n\n    // Submodule instances\n    aes_key_expand_128 key_expand (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(kb[0][127:96]),\n        .wo_1(kb[0][95:64]),\n        .wo_2(kb[0][63:32]),\n        .wo_3(kb[0][31:0])\n    );\n\n    aes_inv_sbox us00 (.a(sa[0][0]), .b(sa[0][0]));\n    aes_inv_sbox us01 (.a(sa[0][1]), .b(sa[0][1]));\n    aes_inv_sbox us02 (.a(sa[0][2]), .b(sa[0][2]));\n    aes_inv_sbox us03 (.a(sa[0][3]), .b(sa[0][3]));\n    aes_inv_sbox us10 (.a(sa[1][0]), .b(sa[1][0]));\n    aes_inv_sbox us11 (.a(sa[1][1]), .b(sa[1][1]));\n    aes_inv_sbox us12 (.a(sa[1][2]), .b(sa[1][2]));\n    aes_inv_sbox us13 (.a(sa[1][3]), .b(sa[1][3]));\n    aes_inv_sbox us20 (.a(sa[2][0]), .b(sa[2][0]));\n    aes_inv_sbox us21 (.a(sa[2][1]), .b(sa[2][1]));\n    aes_inv_sbox us22 (.a(sa[2][2]), .b(sa[2][2]));\n    aes_inv_sbox us23 (.a(sa[2][3]), .b(sa[2][3]));\n    aes_inv_sbox us30 (.a(sa[3][0]), .b(sa[3][0]));\n    aes_inv_sbox us31 (.a(sa[3][1]), .b(sa[3][1]));\n    aes_inv_sbox us32 (.a(sa[3][2]), .b(sa[3][2]));\n    aes_inv_sbox us33 (.a(sa[3][3]), .b(sa[3][3]));\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset logic\n            dcnt <= 4'd0;\n            kcnt <= 4'd10;\n            ld_r <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            // State transitions and operations\n            if (kld) begin\n                // Key loading logic\n                kcnt <= kcnt - 1;\n                if (kcnt == 0) begin\n                    // Key expansion complete\n                    ld_r <= 1'b1;\n                end\n            end else if (ld) begin\n                // Load input text\n                text_in_r <= text_in;\n                ld_r <= 1'b1;\n            end else if (ld_r) begin\n                // Decryption process\n                if (dcnt < 11) begin\n                    // Perform decryption round\n                    dcnt <= dcnt + 1;\n                end else begin\n                    // Decryption complete\n                    done <= 1'b1;\n                    text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                                 sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                                 sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                                 sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                    ld_r <= 1'b0;\n                end\n            end\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n    // Internal registers\n    reg [31:0] w[0:43];\n    reg [3:0] rcon;\n\n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            // Load initial key\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcon <= 4'h1;\n        end else begin\n            // Key expansion rounds\n            w[4] <= w[0] ^ {w[3][23:0], w[3][31:24]} ^ rcon;\n            w[5] <= w[1] ^ w[4];\n            w[6] <= w[2] ^ w[5];\n            w[7] <= w[3] ^ w[6];\n            rcon <= {rcon[2:0], rcon[3]};\n        end\n    end\n\n    // Output round keys\n    assign wo_0 = w[4];\n    assign wo_1 = w[5];\n    assign wo_2 = w[6];\n    assign wo_3 = w[7];\nendmodule\n\nmodule aes_inv_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox[0:255];\n\n    initial begin\n        // Initialize inverse S-box values\n        inv_sbox[8'h00] = 8'h52; inv_sbox[8'h01] = 8'h09; // ... continue for all 256 values\n    end\n\n    assign b = inv_sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n    // Round constant counter\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'd0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 9) begin\n            rcnt <= rcnt + 1;\n            out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1b_00_00_00 : 32'h00_00_00_00);\n        end\n    end\nendmodule\n\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // S-box lookup table\n    reg [7:0] sbox[0:255];\n\n    initial begin\n        // Initialize S-box values\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7c; // ... continue for all 256 values\n    end\n\n    assign b = sbox[a];\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 9, "code": "module aes_inv_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire kld,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n    // Internal registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n\n    // Submodules\n    wire [31:0] wk0, wk1, wk2, wk3;\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    wire [7:0] us00, us01, us02, us03, us10, us11, us12, us13;\n    wire [7:0] us20, us21, us22, us23, us30, us31, us32, us33;\n    aes_inv_sbox inv_sbox [15:0] (\n        .a({sa[0][0], sa[0][1], sa[0][2], sa[0][3], sa[1][0], sa[1][1], sa[1][2], sa[1][3],\n            sa[2][0], sa[2][1], sa[2][2], sa[2][3], sa[3][0], sa[3][1], sa[3][2], sa[3][3]}),\n        .b({us00, us01, us02, us03, us10, us11, us12, us13, us20, us21, us22, us23, us30, us31, us32, us33})\n    );\n\n    // State machine\n    typedef enum reg [2:0] {\n        IDLE,\n        KEY_LOAD,\n        KEY_EXPANSION,\n        KEY_STORED,\n        INITIAL_ROUND,\n        STANDARD_ROUND,\n        FINAL_ROUND,\n        DONE\n    } state_t;\n\n    state_t state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            dcnt <= 0;\n            kcnt <= 4'hA;\n            ld_r <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            if (ld) ld_r <= 1;\n            if (state == DONE) done <= 1;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: if (kld) next_state = KEY_LOAD;\n                  else if (ld) next_state = INITIAL_ROUND;\n            KEY_LOAD: next_state = KEY_EXPANSION;\n            KEY_EXPANSION: if (kcnt == 0) next_state = KEY_STORED;\n            KEY_STORED: if (ld) next_state = INITIAL_ROUND;\n            INITIAL_ROUND: next_state = STANDARD_ROUND;\n            STANDARD_ROUND: if (dcnt == 10) next_state = FINAL_ROUND;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n        endcase\n    end\n\n    // Key expansion and round transformations\n    always @(posedge clk) begin\n        if (state == KEY_LOAD) begin\n            kb[kcnt] <= {wk0, wk1, wk2, wk3};\n            kcnt <= kcnt - 1;\n        end else if (state == INITIAL_ROUND) begin\n            // Initial round key addition\n            // ...\n        end else if (state == STANDARD_ROUND) begin\n            // Standard round transformations\n            // ...\n        end else if (state == FINAL_ROUND) begin\n            // Final round transformations\n            // ...\n        end\n    end\n\n    // Output generation\n    always @(posedge clk) begin\n        if (state == DONE) begin\n            text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                         sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                         sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                         sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    // Internal registers\n    reg [31:0] w [3:0];\n    reg [3:0] rcon;\n\n    // S-box and Rcon submodules\n    wire [31:0] rcon_out;\n    aes_rcon rcon_module (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon_out)\n    );\n\n    wire [7:0] sbox_out [3:0];\n    aes_sbox sbox [3:0] (\n        .a({w[3][23:16], w[3][15:8], w[3][7:0], w[3][31:24]}),\n        .b({sbox_out[0], sbox_out[1], sbox_out[2], sbox_out[3]})\n    );\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcon <= 4'h1;\n        end else begin\n            w[0] <= w[0] ^ {sbox_out[0], sbox_out[1], sbox_out[2], sbox_out[3]} ^ rcon_out;\n            w[1] <= w[1] ^ w[0];\n            w[2] <= w[2] ^ w[1];\n            w[3] <= w[3] ^ w[2];\n            rcon <= rcon + 1;\n        end\n    end\n\n    always @(*) begin\n        wo_0 = w[0];\n        wo_1 = w[1];\n        wo_2 = w[2];\n        wo_3 = w[3];\n    end\n\nendmodule\n\nmodule aes_inv_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    reg [7:0] inv_sbox [0:255];\n\n    initial begin\n        // Initialize the inverse S-box table\n        inv_sbox[8'h00] = 8'h52; inv_sbox[8'h01] = 8'h09; // ...\n        // Fill in the rest of the table\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            out <= {out[23:0], 8'h00} ^ (out[31] ? 32'h1B_00_00_00 : 32'h00_00_00_00);\n        end\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize the S-box table\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7c; // ...\n        // Fill in the rest of the table\n    end\n\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 10, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg done,\n    output reg [127:0] text_out\n);\n    // Internal signals and registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    wire [31:0] wk0, wk1, wk2, wk3;\n    wire [7:0] us [0:3][0:3];\n\n    // Key Expansion Module\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    // Inverse S-box Modules\n    genvar i, j;\n    generate\n        for (i = 0; i < 4; i = i + 1) begin : row\n            for (j = 0; j < 4; j = j + 1) begin : col\n                aes_inv_sbox inv_sbox (\n                    .a(sa[i][j]),\n                    .b(us[i][j])\n                );\n            end\n        end\n    endgenerate\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset logic\n            dcnt <= 0;\n            kcnt <= 4'hA;\n            ld_r <= 0;\n            done <= 0;\n        end else begin\n            // State transitions and operations\n            case (dcnt)\n                0: begin\n                    if (kld) begin\n                        // Key loading\n                        kb[kcnt] <= {wk0, wk1, wk2, wk3};\n                        kcnt <= kcnt - 1;\n                        if (kcnt == 0) dcnt <= 1;\n                    end\n                end\n                1: begin\n                    if (ld) begin\n                        // Initial round\n                        text_in_r <= text_in;\n                        // Map input to state matrix\n                        // Perform AddRoundKey\n                        dcnt <= 2;\n                    end\n                end\n                2: begin\n                    // Standard rounds\n                    // Perform InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns\n                    if (dcnt == 10) dcnt <= 3;\n                end\n                3: begin\n                    // Final round\n                    // Perform InvShiftRows, InvSubBytes, AddRoundKey\n                    done <= 1;\n                    text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                                 sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                                 sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                                 sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n                    dcnt <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n    // Internal signals and registers\n    reg [31:0] w [0:43];\n    reg [3:0] rcnt;\n    wire [31:0] rcon;\n\n    // RCON Module\n    aes_rcon rcon_gen (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    // S-box Modules\n    aes_sbox sbox0 (.a(w[rcnt-1][23:16]), .b(wo_0[31:24]));\n    aes_sbox sbox1 (.a(w[rcnt-1][15:8]), .b(wo_0[23:16]));\n    aes_sbox sbox2 (.a(w[rcnt-1][7:0]), .b(wo_0[15:8]));\n    aes_sbox sbox3 (.a(w[rcnt-1][31:24]), .b(wo_0[7:0]));\n\n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            // Load initial key\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 4;\n        end else begin\n            // Key expansion\n            if (rcnt < 44) begin\n                if (rcnt % 4 == 0) begin\n                    w[rcnt] <= w[rcnt-4] ^ {wo_0[31:24], wo_0[23:16], wo_0[15:8], wo_0[7:0]} ^ rcon;\n                end else begin\n                    w[rcnt] <= w[rcnt-4] ^ w[rcnt-1];\n                end\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\n    assign wo_0 = w[rcnt-4];\n    assign wo_1 = w[rcnt-3];\n    assign wo_2 = w[rcnt-2];\n    assign wo_3 = w[rcnt-1];\nendmodule\n\nmodule aes_inv_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox [0:255];\n\n    initial begin\n        // Initialize the inverse S-box table\n        inv_sbox[8'h00] = 8'h52; inv_sbox[8'h01] = 8'h09; // ... fill in the rest\n        // ...\n        inv_sbox[8'hFF] = 8'h7D;\n    end\n\n    assign b = inv_sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n    // Round constant generation\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1B_00_00_00 : 32'h00_00_00_00);\n        end\n    end\nendmodule\n\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // S-box lookup table\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize the S-box table\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7C; // ... fill in the rest\n        // ...\n        sbox[8'hFF] = 8'h16;\n    end\n\n    assign b = sbox[a];\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 11, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output reg done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n\n    wire [31:0] wk0, wk1, wk2, wk3;\n    wire [7:0] us00, us01, us02, us03;\n    wire [7:0] us10, us11, us12, us13;\n    wire [7:0] us20, us21, us22, us23;\n    wire [7:0] us30, us31, us32, us33;\n\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox us00_inst (.a(sa[0][0]), .b(us00));\n    aes_inv_sbox us01_inst (.a(sa[0][1]), .b(us01));\n    aes_inv_sbox us02_inst (.a(sa[0][2]), .b(us02));\n    aes_inv_sbox us03_inst (.a(sa[0][3]), .b(us03));\n    aes_inv_sbox us10_inst (.a(sa[1][0]), .b(us10));\n    aes_inv_sbox us11_inst (.a(sa[1][1]), .b(us11));\n    aes_inv_sbox us12_inst (.a(sa[1][2]), .b(us12));\n    aes_inv_sbox us13_inst (.a(sa[1][3]), .b(us13));\n    aes_inv_sbox us20_inst (.a(sa[2][0]), .b(us20));\n    aes_inv_sbox us21_inst (.a(sa[2][1]), .b(us21));\n    aes_inv_sbox us22_inst (.a(sa[2][2]), .b(us22));\n    aes_inv_sbox us23_inst (.a(sa[2][3]), .b(us23));\n    aes_inv_sbox us30_inst (.a(sa[3][0]), .b(us30));\n    aes_inv_sbox us31_inst (.a(sa[3][1]), .b(us31));\n    aes_inv_sbox us32_inst (.a(sa[3][2]), .b(us32));\n    aes_inv_sbox us33_inst (.a(sa[3][3]), .b(us33));\n\n    // State machine and control logic implementation\n\nendmodule\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n\n    reg [31:0] w [0:43];\n    reg [3:0] rcon;\n    wire [31:0] temp;\n\n    aes_rcon rcon_inst (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    aes_sbox u0 (.a(temp[23:16]), .b(temp[31:24]));\n    aes_sbox u1 (.a(temp[15:8]), .b(temp[23:16]));\n    aes_sbox u2 (.a(temp[7:0]), .b(temp[15:8]));\n    aes_sbox u3 (.a(temp[31:24]), .b(temp[7:0]));\n\n    // Key expansion logic\n\nendmodule\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box values\n    end\n\n    assign b = sbox[a];\n\nendmodule\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk or posedge kld) begin\n        if (kld) begin\n            rcnt <= 4'd0;\n            out <= 32'h01_00_00_00;\n        end else begin\n            rcnt <= rcnt + 1;\n            // Update out based on rcnt\n        end\n    end\n\nendmodule\nmodule aes_inv_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n\n    reg [7:0] inv_sbox [0:255];\n\n    initial begin\n        // Initialize Inverse S-box values\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 12, "code": "module aes_inv_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire kld,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n    // Internal signals and registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n\n    // Submodule instances\n    aes_key_expand_128 key_expander (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox us00 (.a(sa[0][0]), .b(sa_sub[0][0]));\n    aes_inv_sbox us01 (.a(sa[0][1]), .b(sa_sub[0][1]));\n    aes_inv_sbox us02 (.a(sa[0][2]), .b(sa_sub[0][2]));\n    aes_inv_sbox us03 (.a(sa[0][3]), .b(sa_sub[0][3]));\n    aes_inv_sbox us10 (.a(sa[1][0]), .b(sa_sub[1][0]));\n    aes_inv_sbox us11 (.a(sa[1][1]), .b(sa_sub[1][1]));\n    aes_inv_sbox us12 (.a(sa[1][2]), .b(sa_sub[1][2]));\n    aes_inv_sbox us13 (.a(sa[1][3]), .b(sa_sub[1][3]));\n    aes_inv_sbox us20 (.a(sa[2][0]), .b(sa_sub[2][0]));\n    aes_inv_sbox us21 (.a(sa[2][1]), .b(sa_sub[2][1]));\n    aes_inv_sbox us22 (.a(sa[2][2]), .b(sa_sub[2][2]));\n    aes_inv_sbox us23 (.a(sa[2][3]), .b(sa_sub[2][3]));\n    aes_inv_sbox us30 (.a(sa[3][0]), .b(sa_sub[3][0]));\n    aes_inv_sbox us31 (.a(sa[3][1]), .b(sa_sub[3][1]));\n    aes_inv_sbox us32 (.a(sa[3][2]), .b(sa_sub[3][2]));\n    aes_inv_sbox us33 (.a(sa[3][3]), .b(sa_sub[3][3]));\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset logic\n            done <= 0;\n            dcnt <= 0;\n            kcnt <= 4'hA;\n            ld_r <= 0;\n        end else begin\n            // State transitions and operations\n            case (state)\n                IDLE: begin\n                    if (kld) state <= KEY_LOAD;\n                    else if (ld) state <= INITIAL_ROUND;\n                end\n                KEY_LOAD: begin\n                    // Key loading logic\n                    if (kcnt == 0) state <= KEY_STORED;\n                end\n                KEY_STORED: begin\n                    if (ld) state <= INITIAL_ROUND;\n                end\n                INITIAL_ROUND: begin\n                    // Initial round logic\n                    state <= STANDARD_ROUND;\n                end\n                STANDARD_ROUND: begin\n                    // Standard round logic\n                    if (dcnt == 10) state <= FINAL_ROUND;\n                end\n                FINAL_ROUND: begin\n                    // Final round logic\n                    state <= DONE;\n                end\n                DONE: begin\n                    done <= 1;\n                    state <= IDLE;\n                end\n            endcase\n        end\n    end\n\n    // Additional logic for transformations and key expansion\n    // ...\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output wire [31:0] wo_0,\n    output wire [31:0] wo_1,\n    output wire [31:0] wo_2,\n    output wire [31:0] wo_3\n);\n    // Internal signals and registers\n    reg [31:0] w [0:43];\n    reg [3:0] rcon;\n\n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            // Load initial key\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcon <= 1;\n        end else begin\n            // Key expansion process\n            // ...\n        end\n    end\n\n    // Output assignments\n    assign wo_0 = w[0];\n    assign wo_1 = w[1];\n    assign wo_2 = w[2];\n    assign wo_3 = w[3];\n\nendmodule\n\nmodule aes_inv_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox [0:255];\n\n    initial begin\n        // Initialize the inverse S-box table\n        // ...\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n    // Round constant generation logic\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 9) begin\n            rcnt <= rcnt + 1;\n            // Update round constant\n            // ...\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 13, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output reg done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg [127:0] text_out\n);\n    // Internal registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n\n    // Submodule instances\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox us00 (.a(sa[0][0]), .b(sa_sub[0][0]));\n    aes_inv_sbox us01 (.a(sa[0][1]), .b(sa_sub[0][1]));\n    aes_inv_sbox us02 (.a(sa[0][2]), .b(sa_sub[0][2]));\n    aes_inv_sbox us03 (.a(sa[0][3]), .b(sa_sub[0][3]));\n    aes_inv_sbox us10 (.a(sa[1][0]), .b(sa_sub[1][0]));\n    aes_inv_sbox us11 (.a(sa[1][1]), .b(sa_sub[1][1]));\n    aes_inv_sbox us12 (.a(sa[1][2]), .b(sa_sub[1][2]));\n    aes_inv_sbox us13 (.a(sa[1][3]), .b(sa_sub[1][3]));\n    aes_inv_sbox us20 (.a(sa[2][0]), .b(sa_sub[2][0]));\n    aes_inv_sbox us21 (.a(sa[2][1]), .b(sa_sub[2][1]));\n    aes_inv_sbox us22 (.a(sa[2][2]), .b(sa_sub[2][2]));\n    aes_inv_sbox us23 (.a(sa[2][3]), .b(sa_sub[2][3]));\n    aes_inv_sbox us30 (.a(sa[3][0]), .b(sa_sub[3][0]));\n    aes_inv_sbox us31 (.a(sa[3][1]), .b(sa_sub[3][1]));\n    aes_inv_sbox us32 (.a(sa[3][2]), .b(sa_sub[3][2]));\n    aes_inv_sbox us33 (.a(sa[3][3]), .b(sa_sub[3][3]));\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset logic\n            dcnt <= 4'b0;\n            kcnt <= 4'b1010;\n            ld_r <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            // State transitions and operations\n            case (state)\n                IDLE: begin\n                    if (kld) state <= KEY_LOAD;\n                    else if (ld) state <= INITIAL_ROUND;\n                end\n                KEY_LOAD: begin\n                    // Key loading logic\n                end\n                INITIAL_ROUND: begin\n                    // Initial round logic\n                end\n                STANDARD_ROUND: begin\n                    // Standard round logic\n                end\n                FINAL_ROUND: begin\n                    // Final round logic\n                end\n                DONE: begin\n                    done <= 1'b1;\n                    state <= IDLE;\n                end\n            endcase\n        end\n    end\n\n    // Additional logic for transformations and key expansion\n    // ...\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n    // Internal registers and logic\n    reg [31:0] w [0:43];\n    reg [3:0] rcon;\n    // Key expansion logic\n    // ...\n\nendmodule\n\nmodule aes_inv_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox [0:255];\n    initial begin\n        // Initialize inv_sbox with precomputed values\n    end\n    assign b = inv_sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output [31:0] out\n);\n    reg [3:0] rcnt;\n    // Rcon generation logic\n    // ...\n\nendmodule\n\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // S-box lookup table\n    reg [7:0] sbox [0:255];\n    initial begin\n        // Initialize sbox with precomputed values\n    end\n    assign b = sbox[a];\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 14, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output reg done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg [127:0] text_out\n);\n    // Registers and wires\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    wire [127:0] sa_ark, sa_next;\n    wire [31:0] wk0, wk1, wk2, wk3;\n    wire [7:0] us [0:3][0:3];\n\n    // Submodule instances\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    genvar i, j;\n    generate\n        for (i = 0; i < 4; i = i + 1) begin : row\n            for (j = 0; j < 4; j = j + 1) begin : col\n                aes_inv_sbox inv_sbox (\n                    .a(sa[i][j]),\n                    .b(us[i][j])\n                );\n            end\n        end\n    endgenerate\n\n    // State machine\n    typedef enum reg [2:0] {\n        IDLE,\n        KEY_LOAD,\n        KEY_EXPANSION,\n        KEY_STORED,\n        INITIAL_ROUND,\n        STANDARD_ROUND,\n        FINAL_ROUND,\n        DONE\n    } state_t;\n    state_t state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (kld) next_state = KEY_LOAD;\n                else if (ld) next_state = INITIAL_ROUND;\n                else next_state = IDLE;\n            end\n            KEY_LOAD: next_state = KEY_EXPANSION;\n            KEY_EXPANSION: next_state = (kcnt == 0) ? KEY_STORED : KEY_EXPANSION;\n            KEY_STORED: next_state = (ld) ? INITIAL_ROUND : KEY_STORED;\n            INITIAL_ROUND: next_state = STANDARD_ROUND;\n            STANDARD_ROUND: next_state = (dcnt == 10) ? FINAL_ROUND : STANDARD_ROUND;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 10;\n            ld_r <= 0;\n            done <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    dcnt <= 0;\n                    kcnt <= 10;\n                    ld_r <= 0;\n                    done <= 0;\n                end\n                KEY_LOAD: begin\n                    kcnt <= kcnt - 1;\n                end\n                INITIAL_ROUND: begin\n                    dcnt <= dcnt + 1;\n                end\n                STANDARD_ROUND: begin\n                    dcnt <= dcnt + 1;\n                end\n                FINAL_ROUND: begin\n                    done <= 1;\n                end\n                DONE: begin\n                    done <= 0;\n                end\n            endcase\n        end\n    end\n\n    // Data path logic\n    always @(posedge clk) begin\n        if (ld) begin\n            text_in_r <= text_in;\n            // Initial round key addition\n            sa[0][0] <= text_in[127:120] ^ wk0[31:24];\n            sa[1][0] <= text_in[95:88] ^ wk0[23:16];\n            sa[2][0] <= text_in[63:56] ^ wk0[15:8];\n            sa[3][0] <= text_in[31:24] ^ wk0[7:0];\n            sa[0][1] <= text_in[119:112] ^ wk1[31:24];\n            sa[1][1] <= text_in[87:80] ^ wk1[23:16];\n            sa[2][1] <= text_in[55:48] ^ wk1[15:8];\n            sa[3][1] <= text_in[23:16] ^ wk1[7:0];\n            sa[0][2] <= text_in[111:104] ^ wk2[31:24];\n            sa[1][2] <= text_in[79:72] ^ wk2[23:16];\n            sa[2][2] <= text_in[47:40] ^ wk2[15:8];\n            sa[3][2] <= text_in[15:8] ^ wk2[7:0];\n            sa[0][3] <= text_in[103:96] ^ wk3[31:24];\n            sa[1][3] <= text_in[71:64] ^ wk3[23:16];\n            sa[2][3] <= text_in[39:32] ^ wk3[15:8];\n            sa[3][3] <= text_in[7:0] ^ wk3[7:0];\n        end else if (state == STANDARD_ROUND || state == FINAL_ROUND) begin\n            // InvShiftRows\n            sa[1][0] <= sa[1][3];\n            sa[1][1] <= sa[1][0];\n            sa[1][2] <= sa[1][1];\n            sa[1][3] <= sa[1][2];\n            sa[2][0] <= sa[2][2];\n            sa[2][1] <= sa[2][3];\n            sa[2][2] <= sa[2][0];\n            sa[2][3] <= sa[2][1];\n            sa[3][0] <= sa[3][1];\n            sa[3][1] <= sa[3][2];\n            sa[3][2] <= sa[3][3];\n            sa[3][3] <= sa[3][0];\n            // InvSubBytes\n            sa[0][0] <= us[0][0];\n            sa[0][1] <= us[0][1];\n            sa[0][2] <= us[0][2];\n            sa[0][3] <= us[0][3];\n            sa[1][0] <= us[1][0];\n            sa[1][1] <= us[1][1];\n            sa[1][2] <= us[1][2];\n            sa[1][3] <= us[1][3];\n            sa[2][0] <= us[2][0];\n            sa[2][1] <= us[2][1];\n            sa[2][2] <= us[2][2];\n            sa[2][3] <= us[2][3];\n            sa[3][0] <= us[3][0];\n            sa[3][1] <= us[3][1];\n            sa[3][2] <= us[3][2];\n            sa[3][3] <= us[3][3];\n            // AddRoundKey\n            sa[0][0] <= sa[0][0] ^ wk0[31:24];\n            sa[1][0] <= sa[1][0] ^ wk0[23:16];\n            sa[2][0] <= sa[2][0] ^ wk0[15:8];\n            sa[3][0] <= sa[3][0] ^ wk0[7:0];\n            sa[0][1] <= sa[0][1] ^ wk1[31:24];\n            sa[1][1] <= sa[1][1] ^ wk1[23:16];\n            sa[2][1] <= sa[2][1] ^ wk1[15:8];\n            sa[3][1] <= sa[3][1] ^ wk1[7:0];\n            sa[0][2] <= sa[0][2] ^ wk2[31:24];\n            sa[1][2] <= sa[1][2] ^ wk2[23:16];\n            sa[2][2] <= sa[2][2] ^ wk2[15:8];\n            sa[3][2] <= sa[3][2] ^ wk2[7:0];\n            sa[0][3] <= sa[0][3] ^ wk3[31:24];\n            sa[1][3] <= sa[1][3] ^ wk3[23:16];\n            sa[2][3] <= sa[2][3] ^ wk3[15:8];\n            sa[3][3] <= sa[3][3] ^ wk3[7:0];\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (done) begin\n            text_out[127:120] <= sa[0][0];\n            text_out[95:88] <= sa[1][0];\n            text_out[63:56] <= sa[2][0];\n            text_out[31:24] <= sa[3][0];\n            text_out[119:112] <= sa[0][1];\n            text_out[87:80] <= sa[1][1];\n            text_out[55:48] <= sa[2][1];\n            text_out[23:16] <= sa[3][1];\n            text_out[111:104] <= sa[0][2];\n            text_out[79:72] <= sa[1][2];\n            text_out[47:40] <= sa[2][2];\n            text_out[15:8] <= sa[3][2];\n            text_out[103:96] <= sa[0][3];\n            text_out[71:64] <= sa[1][3];\n            text_out[39:32] <= sa[2][3];\n            text_out[7:0] <= sa[3][3];\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    // Registers and wires\n    reg [31:0] w [0:43];\n    reg [3:0] rcon;\n    wire [31:0] temp;\n    wire [31:0] rcon_out;\n\n    // Submodule instances\n    aes_rcon rcon_gen (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon_out)\n    );\n\n    aes_sbox u0 (.a(temp[23:16]), .b(temp[31:24]));\n    aes_sbox u1 (.a(temp[15:8]), .b(temp[23:16]));\n    aes_sbox u2 (.a(temp[7:0]), .b(temp[15:8]));\n    aes_sbox u3 (.a(temp[31:24]), .b(temp[7:0]));\n\n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcon <= 4'h1;\n        end else begin\n            w[4] <= w[0] ^ temp ^ rcon_out;\n            w[5] <= w[4] ^ w[1];\n            w[6] <= w[5] ^ w[2];\n            w[7] <= w[6] ^ w[3];\n            rcon <= rcon + 1;\n        end\n    end\n\n    assign temp = {w[3][23:0], w[3][31:24]};\n\n    always @(posedge clk) begin\n        wo_0 <= w[4];\n        wo_1 <= w[5];\n        wo_2 <= w[6];\n        wo_3 <= w[7];\n    end\nendmodule\n\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // S-box lookup table\n    reg [7:0] sbox [0:255];\n    initial begin\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7c; sbox[8'h02] = 8'h77; sbox[8'h03] = 8'h7b;\n        // ... (initialize all 256 entries)\n    end\n    assign b = sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n    // Round constant generation\n    reg [3:0] rcnt;\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else begin\n            rcnt <= rcnt + 1;\n            case (rcnt)\n                4'h0: out <= 32'h01_00_00_00;\n                4'h1: out <= 32'h02_00_00_00;\n                4'h2: out <= 32'h04_00_00_00;\n                4'h3: out <= 32'h08_00_00_00;\n                4'h4: out <= 32'h10_00_00_00;\n                4'h5: out <= 32'h20_00_00_00;\n                4'h6: out <= 32'h40_00_00_00;\n                4'h7: out <= 32'h80_00_00_00;\n                4'h8: out <= 32'h1b_00_00_00;\n                4'h9: out <= 32'h36_00_00_00;\n                default: out <= 32'h00_00_00_00;\n            endcase\n        end\n    end\nendmodule\n\nmodule aes_inv_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox [0:255];\n    initial begin\n        inv_sbox[8'h00] = 8'h52; inv_sbox[8'h01] = 8'h09; inv_sbox[8'h02] = 8'h6a; inv_sbox[8'h03] = 8'hd5;\n        // ... (initialize all 256 entries)\n    end\n    assign b = inv_sbox[a];\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 15, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg done,\n    output reg [127:0] text_out\n);\n    // Internal registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n\n    // Submodule instances\n    aes_key_expand_128 key_expander (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox us00 (.a(sa[0][0]), .b(sub00));\n    aes_inv_sbox us01 (.a(sa[0][1]), .b(sub01));\n    aes_inv_sbox us02 (.a(sa[0][2]), .b(sub02));\n    aes_inv_sbox us03 (.a(sa[0][3]), .b(sub03));\n    aes_inv_sbox us10 (.a(sa[1][0]), .b(sub10));\n    aes_inv_sbox us11 (.a(sa[1][1]), .b(sub11));\n    aes_inv_sbox us12 (.a(sa[1][2]), .b(sub12));\n    aes_inv_sbox us13 (.a(sa[1][3]), .b(sub13));\n    aes_inv_sbox us20 (.a(sa[2][0]), .b(sub20));\n    aes_inv_sbox us21 (.a(sa[2][1]), .b(sub21));\n    aes_inv_sbox us22 (.a(sa[2][2]), .b(sub22));\n    aes_inv_sbox us23 (.a(sa[2][3]), .b(sub23));\n    aes_inv_sbox us30 (.a(sa[3][0]), .b(sub30));\n    aes_inv_sbox us31 (.a(sa[3][1]), .b(sub31));\n    aes_inv_sbox us32 (.a(sa[3][2]), .b(sub32));\n    aes_inv_sbox us33 (.a(sa[3][3]), .b(sub33));\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset logic\n            done <= 0;\n            dcnt <= 0;\n            kcnt <= 4'hA;\n            ld_r <= 0;\n        end else begin\n            // State transitions and operations\n            // Implement the state machine logic here\n        end\n    end\n\n    // Additional logic for transformations and key expansion\n    // Implement InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns\n    // Implement key expansion buffer logic\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n    // Internal registers and wires\n    reg [31:0] w [0:43];\n    wire [31:0] temp;\n    wire [31:0] rcon;\n\n    aes_rcon r0 (.clk(clk), .kld(kld), .out(rcon));\n    aes_sbox u0 (.a(temp[23:16]), .b(sbox_out[31:24]));\n    aes_sbox u1 (.a(temp[15:8]), .b(sbox_out[23:16]));\n    aes_sbox u2 (.a(temp[7:0]), .b(sbox_out[15:8]));\n    aes_sbox u3 (.a(temp[31:24]), .b(sbox_out[7:0]));\n\n    always @(posedge clk) begin\n        if (kld) begin\n            // Load initial key\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n        end else begin\n            // Key expansion logic\n            // Implement the key expansion algorithm here\n        end\n    end\n\n    assign wo_0 = w[40];\n    assign wo_1 = w[41];\n    assign wo_2 = w[42];\n    assign wo_3 = w[43];\n\nendmodule\n\nmodule aes_inv_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox [0:255];\n\n    initial begin\n        // Initialize the inverse S-box table\n        // Fill in the table with appropriate values\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 9) begin\n            rcnt <= rcnt + 1;\n            // Update out with the next round constant\n        end\n    end\n\nendmodule\n\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // S-box lookup table\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize the S-box table\n        // Fill in the table with appropriate values\n    end\n\n    assign b = sbox[a];\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 16, "code": "module aes_inv_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire kld,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n    // Internal registers and wires\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    wire [127:0] sa_ark, sa_next;\n    wire [31:0] wk0, wk1, wk2, wk3;\n\n    // Key expansion module\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    // Inverse S-box instances\n    aes_inv_sbox us00 (.a(sa[0][0]), .b(sa_ark[127:120]));\n    aes_inv_sbox us01 (.a(sa[0][1]), .b(sa_ark[119:112]));\n    aes_inv_sbox us02 (.a(sa[0][2]), .b(sa_ark[111:104]));\n    aes_inv_sbox us03 (.a(sa[0][3]), .b(sa_ark[103:96]));\n    aes_inv_sbox us10 (.a(sa[1][0]), .b(sa_ark[95:88]));\n    aes_inv_sbox us11 (.a(sa[1][1]), .b(sa_ark[87:80]));\n    aes_inv_sbox us12 (.a(sa[1][2]), .b(sa_ark[79:72]));\n    aes_inv_sbox us13 (.a(sa[1][3]), .b(sa_ark[71:64]));\n    aes_inv_sbox us20 (.a(sa[2][0]), .b(sa_ark[63:56]));\n    aes_inv_sbox us21 (.a(sa[2][1]), .b(sa_ark[55:48]));\n    aes_inv_sbox us22 (.a(sa[2][2]), .b(sa_ark[47:40]));\n    aes_inv_sbox us23 (.a(sa[2][3]), .b(sa_ark[39:32]));\n    aes_inv_sbox us30 (.a(sa[3][0]), .b(sa_ark[31:24]));\n    aes_inv_sbox us31 (.a(sa[3][1]), .b(sa_ark[23:16]));\n    aes_inv_sbox us32 (.a(sa[3][2]), .b(sa_ark[15:8]));\n    aes_inv_sbox us33 (.a(sa[3][3]), .b(sa_ark[7:0]));\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset logic\n            dcnt <= 4'b0;\n            kcnt <= 4'hA;\n            ld_r <= 1'b0;\n            done <= 1'b0;\n            text_out <= 128'b0;\n        end else begin\n            // State transitions and operations\n            case (dcnt)\n                4'b0000: begin\n                    if (kld) begin\n                        // Key loading\n                        kcnt <= 4'hA;\n                    end else if (ld) begin\n                        // Data loading\n                        ld_r <= 1'b1;\n                        text_in_r <= text_in;\n                        dcnt <= dcnt + 1;\n                    end\n                end\n                4'b0001: begin\n                    // Initial round\n                    if (ld_r) begin\n                        // Load data into state matrix\n                        // AddRoundKey operation\n                        // Transition to next state\n                        dcnt <= dcnt + 1;\n                    end\n                end\n                4'b0010: begin\n                    // Standard round\n                    // InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns\n                    dcnt <= dcnt + 1;\n                end\n                4'b1010: begin\n                    // Final round\n                    // InvShiftRows, InvSubBytes, AddRoundKey\n                    done <= 1'b1;\n                    text_out <= sa_ark;\n                    dcnt <= 4'b0;\n                end\n                default: begin\n                    // Increment round counter\n                    dcnt <= dcnt + 1;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    // Internal registers and wires\n    reg [31:0] w [0:43];\n    reg [3:0] rcnt;\n    wire [31:0] rcon;\n\n    // RCON module\n    aes_rcon r0 (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    // S-box instances\n    aes_sbox u0 (.a(w[rcnt-1][23:16]), .b(w[rcnt][31:24]));\n    aes_sbox u1 (.a(w[rcnt-1][15:8]), .b(w[rcnt][23:16]));\n    aes_sbox u2 (.a(w[rcnt-1][7:0]), .b(w[rcnt][15:8]));\n    aes_sbox u3 (.a(w[rcnt-1][31:24]), .b(w[rcnt][7:0]));\n\n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            // Load initial key\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 4'b0;\n        end else begin\n            // Key expansion\n            if (rcnt < 4'd10) begin\n                if (rcnt % 4 == 0) begin\n                    w[rcnt+4] <= w[rcnt] ^ {w[rcnt+3][23:0], w[rcnt+3][31:24]} ^ rcon;\n                end else begin\n                    w[rcnt+4] <= w[rcnt] ^ w[rcnt+3];\n                end\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n\n    // Output round keys\n    always @(posedge clk) begin\n        wo_0 <= w[rcnt];\n        wo_1 <= w[rcnt+1];\n        wo_2 <= w[rcnt+2];\n        wo_3 <= w[rcnt+3];\n    end\nendmodule\n\nmodule aes_inv_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox [0:255];\n\n    initial begin\n        // Initialize inverse S-box values\n        inv_sbox[8'h00] = 8'h52; inv_sbox[8'h01] = 8'h09; // ... continue for all 256 values\n    end\n\n    assign b = inv_sbox[a];\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    // S-box lookup table\n    reg [7:0] sbox [0:255];\n\n    initial begin\n        // Initialize S-box values\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7c; // ... continue for all 256 values\n    end\n\n    assign b = sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n    // Round constant counter\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'b0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 4'd10) begin\n            rcnt <= rcnt + 1;\n            out <= {out[23:0], 8'h00} ^ (out[31] ? 32'h1b_00_00_00 : 32'h00_00_00_00);\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 17, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    output reg done,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg [127:0] text_out\n);\n    // Register and wire declarations\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    wire [127:0] sa_ark, sa_next;\n    wire [31:0] w0, w1, w2, w3;\n    \n    // Submodule instantiations\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(w0),\n        .wo_1(w1),\n        .wo_2(w2),\n        .wo_3(w3)\n    );\n\n    aes_inv_sbox us00 (.a(sa[0][0]), .b(sa_ark[127:120]));\n    aes_inv_sbox us01 (.a(sa[0][1]), .b(sa_ark[119:112]));\n    aes_inv_sbox us02 (.a(sa[0][2]), .b(sa_ark[111:104]));\n    aes_inv_sbox us03 (.a(sa[0][3]), .b(sa_ark[103:96]));\n    aes_inv_sbox us10 (.a(sa[1][0]), .b(sa_ark[95:88]));\n    aes_inv_sbox us11 (.a(sa[1][1]), .b(sa_ark[87:80]));\n    aes_inv_sbox us12 (.a(sa[1][2]), .b(sa_ark[79:72]));\n    aes_inv_sbox us13 (.a(sa[1][3]), .b(sa_ark[71:64]));\n    aes_inv_sbox us20 (.a(sa[2][0]), .b(sa_ark[63:56]));\n    aes_inv_sbox us21 (.a(sa[2][1]), .b(sa_ark[55:48]));\n    aes_inv_sbox us22 (.a(sa[2][2]), .b(sa_ark[47:40]));\n    aes_inv_sbox us23 (.a(sa[2][3]), .b(sa_ark[39:32]));\n    aes_inv_sbox us30 (.a(sa[3][0]), .b(sa_ark[31:24]));\n    aes_inv_sbox us31 (.a(sa[3][1]), .b(sa_ark[23:16]));\n    aes_inv_sbox us32 (.a(sa[3][2]), .b(sa_ark[15:8]));\n    aes_inv_sbox us33 (.a(sa[3][3]), .b(sa_ark[7:0]));\n\n    // State machine and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset logic\n            dcnt <= 4'b0;\n            kcnt <= 4'b1010;\n            ld_r <= 1'b0;\n            done <= 1'b0;\n            text_out <= 128'b0;\n        end else begin\n            // State transitions and operations\n            if (kld) begin\n                // Key loading logic\n                kcnt <= kcnt - 1;\n                if (kcnt == 0) begin\n                    // Key expansion complete\n                end\n            end else if (ld) begin\n                // Data loading logic\n                ld_r <= 1'b1;\n                text_in_r <= text_in;\n                // Initial round key addition\n            end else if (ld_r) begin\n                // Decryption rounds\n                if (dcnt < 10) begin\n                    // Standard rounds\n                    dcnt <= dcnt + 1;\n                end else begin\n                    // Final round\n                    done <= 1'b1;\n                    text_out <= sa_ark;\n                    ld_r <= 1'b0;\n                end\n            end\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n    // Register and wire declarations\n    reg [31:0] w [0:43];\n    reg [3:0] rcnt;\n    wire [31:0] temp;\n    \n    // S-box and Rcon instantiation\n    aes_sbox u0 (.a(temp[31:24]), .b(wo_0[31:24]));\n    aes_sbox u1 (.a(temp[23:16]), .b(wo_0[23:16]));\n    aes_sbox u2 (.a(temp[15:8]), .b(wo_0[15:8]));\n    aes_sbox u3 (.a(temp[7:0]), .b(wo_0[7:0]));\n    aes_rcon r0 (.clk(clk), .kld(kld), .out(temp));\n    \n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            // Load initial key\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 4'b0;\n        end else begin\n            // Key expansion\n            if (rcnt < 10) begin\n                w[4*rcnt+4] <= w[4*rcnt] ^ temp;\n                w[4*rcnt+5] <= w[4*rcnt+1] ^ w[4*rcnt+4];\n                w[4*rcnt+6] <= w[4*rcnt+2] ^ w[4*rcnt+5];\n                w[4*rcnt+7] <= w[4*rcnt+3] ^ w[4*rcnt+6];\n                rcnt <= rcnt + 1;\n            end\n        end\n    end\n    \n    assign wo_0 = w[4*rcnt];\n    assign wo_1 = w[4*rcnt+1];\n    assign wo_2 = w[4*rcnt+2];\n    assign wo_3 = w[4*rcnt+3];\nendmodule\n\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // S-box lookup table\n    reg [7:0] sbox [0:255];\n    \n    initial begin\n        // Initialize S-box values\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7c; // ... complete the table\n    end\n    \n    assign b = sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n    // Round constant generation\n    reg [3:0] rcnt;\n    \n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'b0;\n            out <= 32'h01_00_00_00;\n        end else begin\n            rcnt <= rcnt + 1;\n            case (rcnt)\n                4'h0: out <= 32'h01_00_00_00;\n                4'h1: out <= 32'h02_00_00_00;\n                4'h2: out <= 32'h04_00_00_00;\n                4'h3: out <= 32'h08_00_00_00;\n                4'h4: out <= 32'h10_00_00_00;\n                4'h5: out <= 32'h20_00_00_00;\n                4'h6: out <= 32'h40_00_00_00;\n                4'h7: out <= 32'h80_00_00_00;\n                4'h8: out <= 32'h1b_00_00_00;\n                4'h9: out <= 32'h36_00_00_00;\n                default: out <= 32'h00_00_00_00;\n            endcase\n        end\n    end\nendmodule\n\nmodule aes_inv_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox [0:255];\n    \n    initial begin\n        // Initialize Inverse S-box values\n        inv_sbox[8'h00] = 8'h52; inv_sbox[8'h01] = 8'h09; // ... complete the table\n    end\n    \n    assign b = inv_sbox[a];\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 18, "code": "module aes_inv_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire kld,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    wire [127:0] sa_ark;\n    wire [127:0] sa_next;\n    wire [31:0] wk0, wk1, wk2, wk3;\n\n    aes_key_expand_128 key_expand (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    aes_inv_sbox us00 (.a(sa[0][0]), .b(sa_ark[127:120]));\n    aes_inv_sbox us01 (.a(sa[0][1]), .b(sa_ark[119:112]));\n    aes_inv_sbox us02 (.a(sa[0][2]), .b(sa_ark[111:104]));\n    aes_inv_sbox us03 (.a(sa[0][3]), .b(sa_ark[103:96]));\n    aes_inv_sbox us10 (.a(sa[1][0]), .b(sa_ark[95:88]));\n    aes_inv_sbox us11 (.a(sa[1][1]), .b(sa_ark[87:80]));\n    aes_inv_sbox us12 (.a(sa[1][2]), .b(sa_ark[79:72]));\n    aes_inv_sbox us13 (.a(sa[1][3]), .b(sa_ark[71:64]));\n    aes_inv_sbox us20 (.a(sa[2][0]), .b(sa_ark[63:56]));\n    aes_inv_sbox us21 (.a(sa[2][1]), .b(sa_ark[55:48]));\n    aes_inv_sbox us22 (.a(sa[2][2]), .b(sa_ark[47:40]));\n    aes_inv_sbox us23 (.a(sa[2][3]), .b(sa_ark[39:32]));\n    aes_inv_sbox us30 (.a(sa[3][0]), .b(sa_ark[31:24]));\n    aes_inv_sbox us31 (.a(sa[3][1]), .b(sa_ark[23:16]));\n    aes_inv_sbox us32 (.a(sa[3][2]), .b(sa_ark[15:8]));\n    aes_inv_sbox us33 (.a(sa[3][3]), .b(sa_ark[7:0]));\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            dcnt <= 4'd0;\n            kcnt <= 4'd10;\n            ld_r <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            if (kld) begin\n                kcnt <= 4'd10;\n            end else if (ld) begin\n                ld_r <= 1'b1;\n                text_in_r <= text_in;\n                dcnt <= 4'd0;\n            end else if (ld_r) begin\n                if (dcnt == 4'd10) begin\n                    done <= 1'b1;\n                    ld_r <= 1'b0;\n                end else begin\n                    dcnt <= dcnt + 1'b1;\n                end\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (ld_r) begin\n            sa[0][0] <= text_in_r[127:120] ^ kb[dcnt][127:120];\n            sa[0][1] <= text_in_r[119:112] ^ kb[dcnt][119:112];\n            sa[0][2] <= text_in_r[111:104] ^ kb[dcnt][111:104];\n            sa[0][3] <= text_in_r[103:96] ^ kb[dcnt][103:96];\n            sa[1][0] <= text_in_r[95:88] ^ kb[dcnt][95:88];\n            sa[1][1] <= text_in_r[87:80] ^ kb[dcnt][87:80];\n            sa[1][2] <= text_in_r[79:72] ^ kb[dcnt][79:72];\n            sa[1][3] <= text_in_r[71:64] ^ kb[dcnt][71:64];\n            sa[2][0] <= text_in_r[63:56] ^ kb[dcnt][63:56];\n            sa[2][1] <= text_in_r[55:48] ^ kb[dcnt][55:48];\n            sa[2][2] <= text_in_r[47:40] ^ kb[dcnt][47:40];\n            sa[2][3] <= text_in_r[39:32] ^ kb[dcnt][39:32];\n            sa[3][0] <= text_in_r[31:24] ^ kb[dcnt][31:24];\n            sa[3][1] <= text_in_r[23:16] ^ kb[dcnt][23:16];\n            sa[3][2] <= text_in_r[15:8] ^ kb[dcnt][15:8];\n            sa[3][3] <= text_in_r[7:0] ^ kb[dcnt][7:0];\n        end\n    end\n\n    always @(posedge clk) begin\n        if (done) begin\n            text_out <= sa_ark;\n        end\n    end\n\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n\n    reg [31:0] w [0:43];\n    reg [3:0] rcnt;\n    wire [31:0] rcon;\n\n    aes_rcon rcon_inst (\n        .clk(clk),\n        .kld(kld),\n        .out(rcon)\n    );\n\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcnt <= 4'd0;\n        end else begin\n            if (rcnt < 4'd10) begin\n                w[4*rcnt+4] <= w[4*rcnt] ^ rcon ^ {w[4*rcnt+3][23:0], w[4*rcnt+3][31:24]};\n                w[4*rcnt+5] <= w[4*rcnt+1] ^ w[4*rcnt+4];\n                w[4*rcnt+6] <= w[4*rcnt+2] ^ w[4*rcnt+5];\n                w[4*rcnt+7] <= w[4*rcnt+3] ^ w[4*rcnt+6];\n                rcnt <= rcnt + 1'b1;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        wo_0 <= w[4*rcnt];\n        wo_1 <= w[4*rcnt+1];\n        wo_2 <= w[4*rcnt+2];\n        wo_3 <= w[4*rcnt+3];\n    end\n\nendmodule\n\nmodule aes_inv_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n\n    reg [7:0] inv_sbox [0:255];\n\n    initial begin\n        inv_sbox[8'h00] = 8'h52; inv_sbox[8'h01] = 8'h09; // ... fill in the rest\n        // ...\n        inv_sbox[8'hfe] = 8'h7d; inv_sbox[8'hff] = 8'h7d;\n    end\n\n    assign b = inv_sbox[a];\n\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 4'd0;\n            out <= 32'h01_00_00_00;\n        end else begin\n            if (rcnt < 4'd10) begin\n                rcnt <= rcnt + 1'b1;\n                out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1b : 32'h00);\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 19, "code": "module aes_inv_cipher_top (\n    input clk,\n    input rst,\n    input kld,\n    input ld,\n    input [127:0] key,\n    input [127:0] text_in,\n    output reg done,\n    output reg [127:0] text_out\n);\n    // Registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa [0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb [10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n\n    // Submodules\n    wire [31:0] wk0, wk1, wk2, wk3;\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    wire [7:0] us [0:3][0:3];\n    genvar i, j;\n    generate\n        for (i = 0; i < 4; i = i + 1) begin : row\n            for (j = 0; j < 4; j = j + 1) begin : col\n                aes_inv_sbox inv_sbox (\n                    .a(sa[i][j]),\n                    .b(us[i][j])\n                );\n            end\n        end\n    endgenerate\n\n    // State Machine\n    typedef enum reg [2:0] {\n        IDLE,\n        KEY_LOAD,\n        KEY_EXPANSION,\n        KEY_STORED,\n        INITIAL_ROUND,\n        STANDARD_ROUND,\n        FINAL_ROUND,\n        DONE\n    } state_t;\n    state_t state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (kld) ? KEY_LOAD : (ld) ? INITIAL_ROUND : IDLE;\n            KEY_LOAD: next_state = KEY_EXPANSION;\n            KEY_EXPANSION: next_state = (kcnt == 0) ? KEY_STORED : KEY_EXPANSION;\n            KEY_STORED: next_state = (ld) ? INITIAL_ROUND : KEY_STORED;\n            INITIAL_ROUND: next_state = STANDARD_ROUND;\n            STANDARD_ROUND: next_state = (dcnt == 10) ? FINAL_ROUND : STANDARD_ROUND;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Control Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            done <= 0;\n            dcnt <= 0;\n            kcnt <= 4'hA;\n            ld_r <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    dcnt <= 0;\n                    kcnt <= 4'hA;\n                    ld_r <= 0;\n                end\n                KEY_LOAD: begin\n                    // Load key into buffer\n                    kb[kcnt] <= {wk3, wk2, wk1, wk0};\n                    kcnt <= kcnt - 1;\n                end\n                INITIAL_ROUND: begin\n                    // Initial round operations\n                    ld_r <= 1;\n                    dcnt <= 1;\n                end\n                STANDARD_ROUND: begin\n                    // Standard round operations\n                    dcnt <= dcnt + 1;\n                end\n                FINAL_ROUND: begin\n                    // Final round operations\n                    done <= 1;\n                end\n            endcase\n        end\n    end\n\n    // Data Path\n    always @(posedge clk) begin\n        if (ld_r) begin\n            // Load data and perform initial AddRoundKey\n            text_in_r <= text_in;\n            // Map text_in to state matrix\n            {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n             sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n             sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n             sa[0][3], sa[1][3], sa[2][3], sa[3][3]} <= text_in ^ kb[10];\n        end else if (state == STANDARD_ROUND || state == FINAL_ROUND) begin\n            // Perform InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns\n            // Update state matrix\n        end\n    end\n\n    // Output Logic\n    always @(posedge clk) begin\n        if (state == DONE) begin\n            text_out <= {sa[0][0], sa[1][0], sa[2][0], sa[3][0],\n                         sa[0][1], sa[1][1], sa[2][1], sa[3][1],\n                         sa[0][2], sa[1][2], sa[2][2], sa[3][2],\n                         sa[0][3], sa[1][3], sa[2][3], sa[3][3]};\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input clk,\n    input kld,\n    input [127:0] key,\n    output [31:0] wo_0,\n    output [31:0] wo_1,\n    output [31:0] wo_2,\n    output [31:0] wo_3\n);\n    // Registers\n    reg [31:0] w [0:43];\n    reg [3:0] rcon;\n    reg [3:0] cnt;\n\n    // S-box instances\n    wire [7:0] subword [0:3];\n    aes_sbox u0 (.a(w[cnt-1][31:24]), .b(subword[0]));\n    aes_sbox u1 (.a(w[cnt-1][23:16]), .b(subword[1]));\n    aes_sbox u2 (.a(w[cnt-1][15:8]), .b(subword[2]));\n    aes_sbox u3 (.a(w[cnt-1][7:0]), .b(subword[3]));\n\n    // Rcon instance\n    aes_rcon r0 (.clk(clk), .kld(kld), .out(rcon));\n\n    // Key Expansion Logic\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            cnt <= 4;\n        end else if (cnt < 44) begin\n            if (cnt % 4 == 0) begin\n                w[cnt] <= w[cnt-4] ^ {subword[1], subword[2], subword[3], subword[0]} ^ {rcon, 24'h0};\n            end else begin\n                w[cnt] <= w[cnt-4] ^ w[cnt-1];\n            end\n            cnt <= cnt + 1;\n        end\n    end\n\n    assign wo_0 = w[cnt-4];\n    assign wo_1 = w[cnt-3];\n    assign wo_2 = w[cnt-2];\n    assign wo_3 = w[cnt-1];\nendmodule\n\nmodule aes_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    reg [7:0] sbox [0:255];\n    initial begin\n        // Initialize S-box values\n        sbox[8'h00] = 8'h63; sbox[8'h01] = 8'h7c; // ... fill in all values\n    end\n    assign b = sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input clk,\n    input kld,\n    output reg [31:0] out\n);\n    reg [3:0] rcnt;\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else if (rcnt < 10) begin\n            rcnt <= rcnt + 1;\n            out <= {out[30:0], 1'b0} ^ (out[31] ? 32'h1b : 32'h00);\n        end\n    end\nendmodule\n\nmodule aes_inv_sbox (\n    input [7:0] a,\n    output [7:0] b\n);\n    reg [7:0] inv_sbox [0:255];\n    initial begin\n        // Initialize Inverse S-box values\n        inv_sbox[8'h00] = 8'h52; inv_sbox[8'h01] = 8'h09; // ... fill in all values\n    end\n    assign b = inv_sbox[a];\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "aes_inv_cipher_top", "codeid": 20, "code": "module aes_inv_cipher_top (\n    input wire clk,\n    input wire rst,\n    input wire kld,\n    input wire ld,\n    output reg done,\n    input wire [127:0] key,\n    input wire [127:0] text_in,\n    output reg [127:0] text_out\n);\n    // Internal signals and registers\n    reg [127:0] text_in_r;\n    reg [7:0] sa[0:3][0:3];\n    reg [3:0] dcnt;\n    reg [127:0] kb[10:0];\n    reg [3:0] kcnt;\n    reg ld_r;\n    wire [127:0] sa_ark, sa_next;\n    wire [31:0] wk0, wk1, wk2, wk3;\n\n    // State machine states\n    typedef enum reg [2:0] {\n        IDLE,\n        KEY_LOAD,\n        KEY_EXPANSION,\n        KEY_STORED,\n        INITIAL_ROUND,\n        STANDARD_ROUND,\n        FINAL_ROUND,\n        DONE\n    } state_t;\n    state_t state, next_state;\n\n    // Key expansion module\n    aes_key_expand_128 key_expansion (\n        .clk(clk),\n        .kld(kld),\n        .key(key),\n        .wo_0(wk0),\n        .wo_1(wk1),\n        .wo_2(wk2),\n        .wo_3(wk3)\n    );\n\n    // Inverse S-box modules\n    aes_inv_sbox us00 (.a(sa[0][0]), .b(sa_ark[127:120]));\n    aes_inv_sbox us01 (.a(sa[0][1]), .b(sa_ark[119:112]));\n    aes_inv_sbox us02 (.a(sa[0][2]), .b(sa_ark[111:104]));\n    aes_inv_sbox us03 (.a(sa[0][3]), .b(sa_ark[103:96]));\n    aes_inv_sbox us10 (.a(sa[1][0]), .b(sa_ark[95:88]));\n    aes_inv_sbox us11 (.a(sa[1][1]), .b(sa_ark[87:80]));\n    aes_inv_sbox us12 (.a(sa[1][2]), .b(sa_ark[79:72]));\n    aes_inv_sbox us13 (.a(sa[1][3]), .b(sa_ark[71:64]));\n    aes_inv_sbox us20 (.a(sa[2][0]), .b(sa_ark[63:56]));\n    aes_inv_sbox us21 (.a(sa[2][1]), .b(sa_ark[55:48]));\n    aes_inv_sbox us22 (.a(sa[2][2]), .b(sa_ark[47:40]));\n    aes_inv_sbox us23 (.a(sa[2][3]), .b(sa_ark[39:32]));\n    aes_inv_sbox us30 (.a(sa[3][0]), .b(sa_ark[31:24]));\n    aes_inv_sbox us31 (.a(sa[3][1]), .b(sa_ark[23:16]));\n    aes_inv_sbox us32 (.a(sa[3][2]), .b(sa_ark[15:8]));\n    aes_inv_sbox us33 (.a(sa[3][3]), .b(sa_ark[7:0]));\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (kld) next_state = KEY_LOAD;\n                else if (ld) next_state = INITIAL_ROUND;\n                else next_state = IDLE;\n            end\n            KEY_LOAD: next_state = KEY_EXPANSION;\n            KEY_EXPANSION: next_state = (kcnt == 0) ? KEY_STORED : KEY_EXPANSION;\n            KEY_STORED: next_state = (ld) ? INITIAL_ROUND : KEY_STORED;\n            INITIAL_ROUND: next_state = STANDARD_ROUND;\n            STANDARD_ROUND: next_state = (dcnt == 10) ? FINAL_ROUND : STANDARD_ROUND;\n            FINAL_ROUND: next_state = DONE;\n            DONE: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            dcnt <= 0;\n            kcnt <= 10;\n            ld_r <= 0;\n            done <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    dcnt <= 0;\n                    kcnt <= 10;\n                    ld_r <= 0;\n                    done <= 0;\n                end\n                KEY_LOAD: begin\n                    kcnt <= kcnt - 1;\n                end\n                KEY_EXPANSION: begin\n                    kb[kcnt] <= {wk3, wk2, wk1, wk0};\n                end\n                INITIAL_ROUND: begin\n                    dcnt <= 1;\n                    ld_r <= 1;\n                end\n                STANDARD_ROUND: begin\n                    dcnt <= dcnt + 1;\n                    ld_r <= 0;\n                end\n                FINAL_ROUND: begin\n                    done <= 1;\n                end\n                DONE: begin\n                    done <= 0;\n                end\n            endcase\n        end\n    end\n\n    // Data path\n    always @(posedge clk) begin\n        if (ld_r) begin\n            text_in_r <= text_in;\n            sa[0][0] <= text_in[127:120] ^ kb[10][127:120];\n            sa[1][0] <= text_in[95:88] ^ kb[10][95:88];\n            sa[2][0] <= text_in[63:56] ^ kb[10][63:56];\n            sa[3][0] <= text_in[31:24] ^ kb[10][31:24];\n            sa[0][1] <= text_in[119:112] ^ kb[10][119:112];\n            sa[1][1] <= text_in[87:80] ^ kb[10][87:80];\n            sa[2][1] <= text_in[55:48] ^ kb[10][55:48];\n            sa[3][1] <= text_in[23:16] ^ kb[10][23:16];\n            sa[0][2] <= text_in[111:104] ^ kb[10][111:104];\n            sa[1][2] <= text_in[79:72] ^ kb[10][79:72];\n            sa[2][2] <= text_in[47:40] ^ kb[10][47:40];\n            sa[3][2] <= text_in[15:8] ^ kb[10][15:8];\n            sa[0][3] <= text_in[103:96] ^ kb[10][103:96];\n            sa[1][3] <= text_in[71:64] ^ kb[10][71:64];\n            sa[2][3] <= text_in[39:32] ^ kb[10][39:32];\n            sa[3][3] <= text_in[7:0] ^ kb[10][7:0];\n        end else begin\n            // InvShiftRows, InvSubBytes, AddRoundKey, InvMixColumns operations\n            // Update sa matrix with sa_next\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (done) begin\n            text_out <= {sa_ark[127:120], sa_ark[95:88], sa_ark[63:56], sa_ark[31:24],\n                         sa_ark[119:112], sa_ark[87:80], sa_ark[55:48], sa_ark[23:16],\n                         sa_ark[111:104], sa_ark[79:72], sa_ark[47:40], sa_ark[15:8],\n                         sa_ark[103:96], sa_ark[71:64], sa_ark[39:32], sa_ark[7:0]};\n        end\n    end\nendmodule\n\nmodule aes_key_expand_128 (\n    input wire clk,\n    input wire kld,\n    input wire [127:0] key,\n    output reg [31:0] wo_0,\n    output reg [31:0] wo_1,\n    output reg [31:0] wo_2,\n    output reg [31:0] wo_3\n);\n    // Internal signals and registers\n    reg [31:0] w[0:43];\n    reg [3:0] rcon;\n    wire [31:0] temp;\n\n    // S-box instances\n    aes_sbox u0 (.a(temp[31:24]), .b(temp[23:16]));\n    aes_sbox u1 (.a(temp[23:16]), .b(temp[15:8]));\n    aes_sbox u2 (.a(temp[15:8]), .b(temp[7:0]));\n    aes_sbox u3 (.a(temp[7:0]), .b(temp[31:24]));\n\n    // Key expansion logic\n    always @(posedge clk) begin\n        if (kld) begin\n            w[0] <= key[127:96];\n            w[1] <= key[95:64];\n            w[2] <= key[63:32];\n            w[3] <= key[31:0];\n            rcon <= 4'h1;\n        end else begin\n            w[4] <= w[0] ^ temp ^ {rcon, 24'h0};\n            w[5] <= w[1] ^ w[4];\n            w[6] <= w[2] ^ w[5];\n            w[7] <= w[3] ^ w[6];\n            // Continue key expansion for remaining words\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        wo_0 <= w[0];\n        wo_1 <= w[1];\n        wo_2 <= w[2];\n        wo_3 <= w[3];\n    end\nendmodule\n\nmodule aes_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    // S-box lookup table\n    reg [7:0] sbox [0:255];\n    initial begin\n        // Initialize S-box values\n    end\n\n    assign b = sbox[a];\nendmodule\n\nmodule aes_rcon (\n    input wire clk,\n    input wire kld,\n    output reg [31:0] out\n);\n    // Round constant logic\n    reg [3:0] rcnt;\n\n    always @(posedge clk) begin\n        if (kld) begin\n            rcnt <= 0;\n            out <= 32'h01_00_00_00;\n        end else begin\n            rcnt <= rcnt + 1;\n            // Update out based on rcnt\n        end\n    end\nendmodule\n\nmodule aes_inv_sbox (\n    input wire [7:0] a,\n    output wire [7:0] b\n);\n    // Inverse S-box lookup table\n    reg [7:0] inv_sbox [0:255];\n    initial begin\n        // Initialize inverse S-box values\n    end\n\n    assign b = inv_sbox[a];\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 1, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 2, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 3, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 4, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 5, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 6, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 7, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 8, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 9, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 10, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 11, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 12, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 13, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 14, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 15, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 16, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 17, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 18, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 19, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 20, "code": "Please reduce the length of the messages.", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
