{"task": "sd_clock_divider", "codeid": 1, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK <= ~SD_CLK;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 1, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:12], CRC[11] ^ inv, CRC[10:5], CRC[4] ^ inv, CRC[3:1], inv};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 2, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // In ACTEL specific synthesis, use SD_CLK_O as the output\n    assign SD_CLK = SD_CLK_O;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 3, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    CLKINT clkint_inst (.A(SD_CLK_O), .Y(SD_CLK));\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 2, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    // Calculate the inversion bit\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;  // Reset CRC to zero\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0};  // Shift left by 1\n            CRC[12] <= CRC[11] ^ inv;  // Update CRC[12]\n            CRC[5] <= CRC[4] ^ inv;    // Update CRC[5]\n            CRC[0] <= inv;             // Set CRC[0] to inv\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 3, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    // Calculate the inversion bit\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 4, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'd0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'd0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 8'd1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    assign SD_CLK = SD_CLK_O;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 5, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter >= DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    assign SD_CLK = SD_CLK_O;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 4, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    // Calculate the inversion bit\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1'b1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    CLKINT clkint_inst (.A(SD_CLK_O), .Y(SD_CLK));\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 7, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1'b1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    // This section is typically used for specific synthesis tools\n    // and may require additional vendor-specific instantiation\n    assign SD_CLK = SD_CLK_O;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 5, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:12], CRC[11] ^ inv, CRC[10:5], CRC[4] ^ inv, CRC[3:1], inv};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 8, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    wire CLKINT;\n    assign CLKINT = SD_CLK_O;\n    assign SD_CLK = CLKINT;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 6, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:12], CRC[11] ^ inv, CRC[10:5], CRC[4] ^ inv, CRC[3:1], inv};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 7, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:12], CRC[11] ^ inv, CRC[10:5], CRC[4] ^ inv, CRC[3:1], inv};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 8, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:12], CRC[11] ^ inv, CRC[10:5], CRC[4] ^ inv, CRC[3:1], inv};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 9, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    // Calculate the inversion bit\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'h0000;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left by 1\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 10, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:12], CRC[11] ^ inv, CRC[10:5], CRC[4] ^ inv, CRC[3:1], inv};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 11, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    // Calculate the inversion bit\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 9, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    wire CLKINT;\n    assign CLKINT = SD_CLK_O;\n    assign SD_CLK = CLKINT;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 10, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n`ifdef ACTEL\n    wire SD_CLK_O;\n    assign SD_CLK = SD_CLK_O;\n`endif\n\n    reg [7:0] counter;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK <= ~SD_CLK;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK_O = SD_CLK;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 12, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'h0000;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 11, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'd0;\n            SD_CLK <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'd0;\n                SD_CLK <= ~SD_CLK;\n            end else begin\n                counter <= counter + 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 13, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 14, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 12, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // ACTEL specific logic\n    wire CLKINT;\n    assign CLKINT = SD_CLK_O;\n    assign SD_CLK = CLKINT;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 13, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter >= DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1'b1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // For ACTEL specific synthesis\n    wire CLKINT;\n    assign CLKINT = SD_CLK_O;\n    assign SD_CLK = CLKINT;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 15, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:12], CRC[11] ^ inv, CRC[10:5], CRC[4] ^ inv, CRC[3:1], inv};\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 16, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 17, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 14, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1'b1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    // Assuming CLKINT is a specific clock buffer for ACTEL\n    CLKINT clkint_inst (.A(SD_CLK_O), .Y(SD_CLK));\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 18, "code": "module sd_crc_16 (\n    input wire BITVAL,    // Next input bit\n    input wire Enable,    // Enables CRC updating\n    input wire CLK,       // Current bit valid (Clock)\n    input wire RST,       // Initializes CRC value to zero\n    output reg [15:0] CRC // Current output CRC value\n);\n\n    wire inv;\n\n    // Calculate the inversion bit\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0; // Reset CRC to zero\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left by 1\n            CRC[12] <= CRC[11] ^ inv; // Update specific bits\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;            // Set LSB to inv\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 15, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter >= DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Specific backend version handling for ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    // This part would be specific to ACTEL synthesis tools\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 16, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    assign SD_CLK = SD_CLK_O;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 17, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'd0;\n            SD_CLK <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'd0;\n                SD_CLK <= ~SD_CLK;\n            end else begin\n                counter <= counter + 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 18, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Specific backend version for ACTEL\n    wire CLKINT;\n    assign CLKINT = SD_CLK_O;\n    assign SD_CLK = CLKINT;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 19, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'd0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'd0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    // This is a placeholder for ACTEL specific implementation\n    assign SD_CLK = SD_CLK_O; // Modify as per ACTEL requirements\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 19, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 20, "code": "module sd_crc_16 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 1, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 20, "code": "module sd_clock_divider (\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\n    reg [7:0] counter;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 8'b0;\n            SD_CLK_O <= 1'b0;\n        end else begin\n            if (counter == DIVIDER) begin\n                counter <= 8'b0;\n                SD_CLK_O <= ~SD_CLK_O;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n`ifdef SIM\n    assign SD_CLK = SD_CLK_O;\n`elsif ACTEL\n    // Specific backend version for ACTEL\n    // Use SD_CLK_O as the output and SD_CLK as the input for CLKINT\n    assign SD_CLK = SD_CLK_O;\n`else\n    assign SD_CLK = SD_CLK_O;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 2, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 3, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 4, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 5, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 6, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 7, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        wire inv = BITVAL ^ CRC[6];\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 8, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 9, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 10, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 11, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 12, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        wire inv = BITVAL ^ CRC[6];\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 13, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 14, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 15, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        wire inv = BITVAL ^ CRC[6];\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 16, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 17, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 18, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 1, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\nreg [15:0] bd_rx_reg;\nreg [15:0] bd_tx_reg;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 0;\n        we_m_tx_bd <= 0;\n        we_m_rx_bd <= 0;\n        new_cmd <= 0;\n        we_ack <= 0;\n        int_ack <= 1;\n        cmd_int_busy <= 0;\n        int_busy <= 0;\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n        dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n    end else begin\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h34: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        bd_rx_reg <= wb_dat_i[15:0];\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        bd_tx_reg <= wb_dat_i[15:0];\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h00000000;\n                    8'h20: wb_dat_o <= 32'h00000200;\n                    8'h24: wb_dat_o <= 32'h0000000f;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000;\n                    8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n            if (we_m_rx_bd || we_m_tx_bd) begin\n                int_ack <= 1;\n                we_m_rx_bd <= 0;\n                we_m_tx_bd <= 0;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 19, "code": "module sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 2, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:15];\nreg [15:0] reg_file_16 [0:15];\nreg [7:0] reg_file_8 [0:15];\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h34: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60, 8'h80: begin\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_rx_bd <= wb_dat_i[15:0];\n                            @(posedge wb_clk_i);\n                            dat_in_m_rx_bd <= wb_dat_i[31:16];\n                        end\n                        int_ack <= 1'b1;\n                        we_m_rx_bd <= 1'b0;\n                    end\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 32'h00000000; // Controller Setting\n                    8'h20: wb_dat_o <= 32'h00000200; // Block Size\n                    8'h24: wb_dat_o <= 32'h0000000F; // Power Control\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000; // Capability\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 3, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\nreg [15:0] bd_rx_reg;\nreg [15:0] bd_tx_reg;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 0;\n        we_m_tx_bd <= 0;\n        we_m_rx_bd <= 0;\n        new_cmd <= 0;\n        we_ack <= 0;\n        int_ack <= 1;\n        cmd_int_busy <= 0;\n        int_busy <= 0;\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n        dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n    end else begin\n        if (wb_cyc_i && wb_stb_i && ~wb_ack_o) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1;\n                    8'h34: error_isr_reset <= 1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        bd_rx_reg <= wb_dat_i[15:0];\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        bd_tx_reg <= wb_dat_i[15:0];\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 32'h00000000;\n                    8'h20: wb_dat_o <= 32'h00000200;\n                    8'h24: wb_dat_o <= 32'h0000000F;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000;\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n            if (we_m_rx_bd || we_m_tx_bd) begin\n                int_ack <= 1;\n                we_m_rx_bd <= 0;\n                we_m_tx_bd <= 0;\n            end\n            if (normal_isr_reset) normal_isr_reset <= 0;\n            if (error_isr_reset) error_isr_reset <= 0;\n            if (Bd_isr_reset) Bd_isr_reset <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 1, "code": "module fsm (\n    input wire clk,\n    input wire reset,\n    input wire New_CMD,\n    input wire ack_in_init,\n    input wire complete,\n    output reg [1:0] state\n);\n\n    // State encoding\n    localparam IDLE    = 2'b00;\n    localparam SETUP   = 2'b01;\n    localparam EXECUTE = 2'b10;\n\n    // State transition\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (New_CMD)\n                        state <= SETUP;\n                end\n                SETUP: begin\n                    if (ack_in_init)\n                        state <= EXECUTE;\n                end\n                EXECUTE: begin\n                    if (complete)\n                        state <= IDLE;\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 4, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:15]; // Register file\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        wb_ack_o <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n    end else begin\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h34: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                        int_ack <= 1'b1;\n                        we_m_rx_bd <= 1'b0;\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                        int_ack <= 1'b1;\n                        we_m_tx_bd <= 1'b0;\n                    end\n                endcase\n                wb_ack_o <= 1'b1;\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 32'h00000000; // Controller Setting\n                    8'h20: wb_dat_o <= 32'h00000200; // Block Size\n                    8'h24: wb_dat_o <= 32'h0000000F; // Power Control\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000; // Capability\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n\n        // Control Logic\n        cmd_int_busy <= (wb_adr_i == 8'h00 || wb_adr_i == 8'h04);\n        int_busy <= (wb_adr_i == 8'h00);\n        new_cmd <= (wb_adr_i == 8'h00);\n        we_ack <= write_req_s;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 5, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [15:0] controller_setting_reg;\nreg [15:0] block_size_reg;\nreg [7:0] power_control_reg;\nreg [15:0] capabilities_reg;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 0;\n        we_m_tx_bd <= 0;\n        we_m_rx_bd <= 0;\n        new_cmd <= 0;\n        we_ack <= 0;\n        int_ack <= 1;\n        cmd_int_busy <= 0;\n        int_busy <= 0;\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h34: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= {16'h0000, controller_setting_reg};\n                    8'h20: wb_dat_o <= {16'h0000, block_size_reg};\n                    8'h24: wb_dat_o <= {24'h000000, power_control_reg};\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= {16'h0000, capabilities_reg};\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n            if (we_m_rx_bd || we_m_tx_bd) begin\n                int_ack <= 1;\n                we_m_rx_bd <= 0;\n                we_m_tx_bd <= 0;\n            end\n        end\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (write_req_s) begin\n        we_ack <= 1;\n    end else begin\n        we_ack <= 0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s != 16'h0000 || cmd_arg_s != 32'h00000000) begin\n        new_cmd <= 1;\n    end else begin\n        new_cmd <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 6, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\nreg [15:0] bd_rx [0:1];\nreg [15:0] bd_tx [0:1];\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 0;\n        we_m_tx_bd <= 0;\n        we_m_rx_bd <= 0;\n        new_cmd <= 0;\n        we_ack <= 0;\n        int_ack <= 1;\n        cmd_int_busy <= 0;\n        int_busy <= 0;\n        argument_reg <= 32'h0000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n    end else begin\n        if (wb_cyc_i & wb_stb_i & ~wb_ack_o) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1;\n                    8'h34: error_isr_reset <= 1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            bd_rx[0] <= wb_dat_i[15:0];\n                            bd_rx[1] <= wb_dat_i[31:16];\n                        end else begin\n                            bd_rx[0] <= wb_dat_i[15:0];\n                            bd_rx[1] <= wb_dat_i[31:16];\n                        end\n                        int_ack <= 1;\n                        we_m_rx_bd <= 0;\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            bd_tx[0] <= wb_dat_i[15:0];\n                            bd_tx[1] <= wb_dat_i[31:16];\n                        end else begin\n                            bd_tx[0] <= wb_dat_i[15:0];\n                            bd_tx[1] <= wb_dat_i[31:16];\n                        end\n                        int_ack <= 1;\n                        we_m_tx_bd <= 0;\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h0000;\n                    8'h20: wb_dat_o <= 32'h0200;\n                    8'h24: wb_dat_o <= 32'h000f;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h0000;\n                    8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n        end\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (write_req_s) begin\n        we_ack <= 1;\n    end else begin\n        we_ack <= 0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s || cmd_arg_s) begin\n        new_cmd <= 1;\n    end else begin\n        new_cmd <= 0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s || cmd_arg_s) begin\n        cmd_int_busy <= 1;\n    end else begin\n        cmd_int_busy <= 0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (wb_adr_i == 8'h04) begin\n        int_busy <= 1;\n    end else begin\n        int_busy <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 7, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\nreg [15:0] bd_rx_reg, bd_tx_reg;\nreg [1:0] state;\n\nlocalparam IDLE = 2'b00;\nlocalparam WRITE = 2'b01;\nlocalparam READ = 2'b10;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        argument_reg <= 32'b0;\n        cmd_setting_reg <= 16'b0;\n        software_reset_reg <= 8'b0;\n        time_out_reg <= 16'b0;\n        normal_int_signal_enable_reg <= 16'b0;\n        error_int_signal_enable_reg <= 16'b0;\n        clock_divider <= 8'b0;\n        Bd_isr_enable_reg <= 8'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        state <= IDLE;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (wb_stb_i && wb_cyc_i) begin\n                    if (wb_we_i) begin\n                        state <= WRITE;\n                    end else begin\n                        state <= READ;\n                    end\n                end\n            end\n            WRITE: begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h34: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1'b1;\n                        bd_rx_reg <= wb_dat_i[15:0];\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            int_ack <= 1'b1;\n                            we_m_rx_bd <= 1'b0;\n                        end else begin\n                            dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                            int_ack <= 1'b1;\n                            we_m_rx_bd <= 1'b0;\n                        end\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1'b1;\n                        bd_tx_reg <= wb_dat_i[15:0];\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            int_ack <= 1'b1;\n                            we_m_tx_bd <= 1'b0;\n                        end else begin\n                            dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                            int_ack <= 1'b1;\n                            we_m_tx_bd <= 1'b0;\n                        end\n                    end\n                endcase\n                wb_ack_o <= 1'b1;\n                state <= IDLE;\n            end\n            READ: begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'b0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'b0; // Controller Setting\n                    8'h20: wb_dat_o <= 32'h0200; // Block Size\n                    8'h24: wb_dat_o <= 32'h000F; // Power Control\n                    8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'b0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'b0; // Capability\n                    8'h4c: wb_dat_o <= {24'b0, clock_divider};\n                    8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                endcase\n                wb_ack_o <= 1'b1;\n                state <= IDLE;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [`RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [`BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [`RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [`BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [`BD_WIDTH-1:0] write_count, read_count;\n    reg [`RAM_MEM_WIDTH-1:0] bd_mem [0:`BD_SIZE-1];\n    reg last_a_cmp;\n    reg [1:0] state, next_state;\n\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            free_bd <= (`RAM_MEM_WIDTH == 32) ? (`BD_SIZE >> 1) : (`BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        ack_o_s = 0;\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0) begin\n                    next_state = WRITE;\n                end else if (re_s) begin\n                    next_state = READ;\n                end\n            end\n            WRITE: begin\n                if (`RAM_MEM_WIDTH == 32) begin\n                    if (write_count == 1) begin\n                        next_state = IDLE;\n                        free_bd = free_bd - 1;\n                    end\n                end else begin\n                    if (write_count == 3) begin\n                        next_state = IDLE;\n                        free_bd = free_bd - 1;\n                    end\n                end\n            end\n            READ: begin\n                ack_o_s = (`RAM_MEM_WIDTH == 16);\n                if (`RAM_MEM_WIDTH == 32) begin\n                    if (read_count == 1) begin\n                        next_state = IDLE;\n                    end\n                end else begin\n                    if (read_count == 3) begin\n                        next_state = IDLE;\n                    end\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (state == WRITE) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % `BD_SIZE;\n            write_count <= write_count + 1;\n        end else if (state == READ) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % `BD_SIZE;\n            read_count <= read_count + 1;\n        end else begin\n            write_count <= 0;\n            read_count <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 8, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:15];\nreg [15:0] reg_file_16 [0:15];\nreg [7:0] reg_file_8 [0:15];\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to default values\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                        int_ack <= 1'b1;\n                        we_m_rx_bd <= 1'b0;\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                        int_ack <= 1'b1;\n                        we_m_tx_bd <= 1'b0;\n                    end\n                    default: ;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h00000000; // Controller Setting\n                    8'h20: wb_dat_o <= 32'h00000200; // Block Size\n                    8'h24: wb_dat_o <= 32'h0000000f; // Power Control\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000; // Capability\n                    8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h00000000;\n                endcase\n            end\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (write_req_s) begin\n        we_ack <= 1'b1;\n    end else begin\n        we_ack <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_arg_s != 32'h00000000) begin\n        new_cmd <= 1'b1;\n    end else begin\n        new_cmd <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s != 16'h0000) begin\n        cmd_int_busy <= 1'b1;\n    end else begin\n        cmd_int_busy <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && wb_adr_i == 8'h04) begin\n        int_busy <= 1'b1;\n    end else begin\n        int_busy <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 9, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\nreg [15:0] bd_rx [0:1];\nreg [15:0] bd_tx [0:1];\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 0;\n        we_m_tx_bd <= 0;\n        we_m_rx_bd <= 0;\n        new_cmd <= 0;\n        we_ack <= 0;\n        int_ack <= 1;\n        cmd_int_busy <= 0;\n        int_busy <= 0;\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n    end else begin\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1;\n                    8'h34: error_isr_reset <= 1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        bd_rx[0] <= wb_dat_i[15:0];\n                        bd_rx[1] <= wb_dat_i[31:16];\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        bd_tx[0] <= wb_dat_i[15:0];\n                        bd_tx[1] <= wb_dat_i[31:16];\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 32'h00000000;\n                    8'h20: wb_dat_o <= 32'h00000200;\n                    8'h24: wb_dat_o <= 32'h0000000F;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000;\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n            if (we_m_rx_bd || we_m_tx_bd) begin\n                int_ack <= 1;\n                we_m_rx_bd <= 0;\n                we_m_tx_bd <= 0;\n            end\n            if (normal_isr_reset) normal_isr_reset <= 0;\n            if (error_isr_reset) error_isr_reset <= 0;\n            if (Bd_isr_reset) Bd_isr_reset <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [`RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [`BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [`RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [`BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [`RAM_MEM_WIDTH-1:0] bd_mem [0:`BD_SIZE-1];\n    reg last_a_cmp;\n    reg [1:0] state, next_state;\n\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            free_bd <= (`RAM_MEM_WIDTH == 32) ? (`BD_SIZE >> 1) : (`BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            ack_o_s <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0) begin\n                    next_state <= WRITE;\n                end else if (re_s) begin\n                    next_state <= READ;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n\n            WRITE: begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                if ((`RAM_MEM_WIDTH == 32 && m_wr_pnt[0] == 1) || (`RAM_MEM_WIDTH == 16 && m_wr_pnt[1:0] == 3)) begin\n                    free_bd <= free_bd - 1;\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= WRITE;\n                end\n            end\n\n            READ: begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                ack_o_s <= (`RAM_MEM_WIDTH == 16);\n                if ((`RAM_MEM_WIDTH == 32 && s_rd_pnt[0] == 1) || (`RAM_MEM_WIDTH == 16 && s_rd_pnt[1:0] == 3)) begin\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= READ;\n                end\n            end\n\n            default: next_state <= IDLE;\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Internal registers and wires\n    reg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_count, read_count;\n    reg last_a_cmp;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    reg new_bw;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            last_a_cmp <= 0;\n            ack_o_s <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n                write_count <= write_count + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_count == 1) || (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                    new_bw <= 1;\n                    free_bd <= free_bd - 1;\n                    write_count <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n                read_count <= read_count + 1;\n                if ((RAM_MEM_WIDTH == 32 && read_count == 1) || (RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                    ack_o_s <= 1;\n                    read_count <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 10, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:15]; // Register file for storing configuration registers\n\n// Reset and Clock\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end else begin\n        // Register Write\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                8'h28: software_reset_reg <= wb_dat_i[7:0];\n                8'h2c: time_out_reg <= wb_dat_i[15:0];\n                8'h30: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h34: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h4c: clock_divider <= wb_dat_i[7:0];\n                8'h54: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                8'h60, 8'h80: begin\n                    we_m_rx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                    int_ack <= 1'b1;\n                    we_m_rx_bd <= 1'b0;\n                end\n                default: ;\n            endcase\n            wb_ack_o <= 1'b1;\n        end else if (wb_stb_i && wb_cyc_i) begin\n            // Register Read\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= argument_reg;\n                8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                8'h08: wb_dat_o <= {16'h0000, status_reg};\n                8'h0c: wb_dat_o <= cmd_resp_1;\n                8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                8'h30: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                8'h34: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                8'h54: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                default: wb_dat_o <= 32'h00000000;\n            endcase\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n\n        // Control Logic\n        cmd_int_busy <= (wb_adr_i == 8'h00 || wb_adr_i == 8'h04) ? 1'b1 : 1'b0;\n        int_busy <= (wb_adr_i == 8'h04) ? 1'b1 : 1'b0;\n        new_cmd <= (wb_adr_i == 8'h00) ? 1'b1 : 1'b0;\n        we_ack <= write_req_s ? 1'b1 : 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 11, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n    end else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        int_ack <= 1'b1;\n\n        // Handle write operations\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                8'h28: software_reset_reg <= wb_dat_i[7:0];\n                8'h2c: time_out_reg <= wb_dat_i[15:0];\n                8'h30: normal_isr_reset <= 1'b1;\n                8'h34: error_isr_reset <= 1'b1;\n                8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h4c: clock_divider <= wb_dat_i[7:0];\n                8'h54: Bd_isr_reset <= 1'b1;\n                8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                8'h60: begin\n                    we_m_rx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                end\n                8'h80: begin\n                    we_m_tx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_tx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                end\n            endcase\n            wb_ack_o <= 1'b1;\n        end\n\n        // Handle read operations\n        if (wb_stb_i && wb_cyc_i && !wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= argument_reg;\n                8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                8'h08: wb_dat_o <= {16'h0000, status_reg};\n                8'h0c: wb_dat_o <= cmd_resp_1;\n                8'h1c: wb_dat_o <= 32'h00000000; // Controller Setting\n                8'h20: wb_dat_o <= 32'h00000200; // Block Size\n                8'h24: wb_dat_o <= 32'h0000000f; // Power Control\n                8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                8'h48: wb_dat_o <= 32'h00000000; // Capability\n                8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n            endcase\n            wb_ack_o <= 1'b1;\n        end\n\n        // Control logic\n        cmd_int_busy <= (cmd_set_s != 16'h0000) || (cmd_arg_s != 32'h00000000);\n        int_busy <= (wb_adr_i == 8'h04);\n        new_cmd <= (cmd_arg_s != 32'h00000000);\n        we_ack <= write_req_s;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [`RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [`BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [`RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [`BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [`RAM_MEM_WIDTH-1:0] bd_mem [0:`BD_SIZE-1];\n    reg last_a_cmp;\n    reg [1:0] state, next_state;\n\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (`RAM_MEM_WIDTH == 32) ? (`BD_SIZE >> 1) : (`BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            state <= IDLE;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0) begin\n                    next_state <= WRITE;\n                end else if (re_s) begin\n                    next_state <= READ;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n            WRITE: begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                if ((`RAM_MEM_WIDTH == 32 && m_wr_pnt[0]) || (`RAM_MEM_WIDTH == 16 && m_wr_pnt[1:0] == 2'b11)) begin\n                    free_bd <= free_bd - 1;\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= WRITE;\n                end\n            end\n            READ: begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                if ((`RAM_MEM_WIDTH == 32 && s_rd_pnt[0]) || (`RAM_MEM_WIDTH == 16 && s_rd_pnt[1:0] == 2'b11)) begin\n                    ack_o_s <= 1;\n                    next_state <= IDLE;\n                end else begin\n                    ack_o_s <= (`RAM_MEM_WIDTH == 16);\n                    next_state <= READ;\n                end\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 12, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\nreg [15:0] bd_rx_buffer [0:BD_SIZE-1];\nreg [15:0] bd_tx_buffer [0:BD_SIZE-1];\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 0;\n        we_m_tx_bd <= 0;\n        we_m_rx_bd <= 0;\n        new_cmd <= 0;\n        we_ack <= 0;\n        int_ack <= 1;\n        cmd_int_busy <= 0;\n        int_busy <= 0;\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n    end else begin\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1;\n                    8'h34: error_isr_reset <= 1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else begin\n                            bd_rx_buffer[0] <= wb_dat_i[15:0];\n                            bd_rx_buffer[1] <= wb_dat_i[31:16];\n                        end\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                        end else begin\n                            bd_tx_buffer[0] <= wb_dat_i[15:0];\n                            bd_tx_buffer[1] <= wb_dat_i[31:16];\n                        end\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 32'h00000000;\n                    8'h20: wb_dat_o <= 32'h00000200;\n                    8'h24: wb_dat_o <= 32'h0000000F;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000;\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n            if (int_ack == 0) begin\n                int_ack <= 1;\n                we_m_rx_bd <= 0;\n                we_m_tx_bd <= 0;\n            end\n            if (normal_isr_reset) normal_isr_reset <= 0;\n            if (error_isr_reset) error_isr_reset <= 0;\n            if (Bd_isr_reset) Bd_isr_reset <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [`RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [`BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [`RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [`BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [`RAM_MEM_WIDTH-1:0] bd_mem [0:`BD_SIZE-1];\n    reg last_a_cmp;\n    reg [1:0] state, next_state;\n\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            free_bd <= (`RAM_MEM_WIDTH == 32) ? (`BD_SIZE >> 1) : (`BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            ack_o_s <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0) begin\n                    next_state <= WRITE;\n                end else if (re_s) begin\n                    next_state <= READ;\n                end else begin\n                    next_state <= IDLE;\n                end\n            end\n\n            WRITE: begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                if ((`RAM_MEM_WIDTH == 32 && m_wr_pnt[0] == 1) || \n                    (`RAM_MEM_WIDTH == 16 && m_wr_pnt[1:0] == 3)) begin\n                    free_bd <= free_bd - 1;\n                    next_state <= IDLE;\n                end else begin\n                    next_state <= WRITE;\n                end\n            end\n\n            READ: begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                if ((`RAM_MEM_WIDTH == 32 && s_rd_pnt[0] == 1) || \n                    (`RAM_MEM_WIDTH == 16 && s_rd_pnt[1:0] == 3)) begin\n                    ack_o_s <= 1;\n                    next_state <= IDLE;\n                end else begin\n                    ack_o_s <= 0;\n                    next_state <= READ;\n                end\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 13, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:15]; // Register file for storing configuration registers\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        wb_ack_o <= 1'b0;\n    end else begin\n        // Handle write operations\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                8'h28: software_reset_reg <= wb_dat_i[7:0];\n                8'h2c: time_out_reg <= wb_dat_i[15:0];\n                8'h30: normal_isr_reset <= 1'b1;\n                8'h34: error_isr_reset <= 1'b1;\n                8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h4c: clock_divider <= wb_dat_i[7:0];\n                8'h54: Bd_isr_reset <= 1'b1;\n                8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                8'h60, 8'h80: begin\n                    we_m_rx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                    int_ack <= 1'b1;\n                    we_m_rx_bd <= 1'b0;\n                end\n            endcase\n            wb_ack_o <= 1'b1;\n        end else if (wb_stb_i && wb_cyc_i && !wb_we_i) begin\n            // Handle read operations\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= argument_reg;\n                8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                8'h08: wb_dat_o <= {16'h0000, status_reg};\n                8'h0c: wb_dat_o <= cmd_resp_1;\n                8'h1c: wb_dat_o <= 32'h00000000; // Controller settings not used\n                8'h20: wb_dat_o <= 32'h00000200; // Block size hardcoded to 512\n                8'h24: wb_dat_o <= 32'h0000000f; // Power control hardcoded to 3.3V\n                8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                8'h48: wb_dat_o <= 32'h00000000; // Capability register not used\n                8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n            endcase\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n\n        // Control Logic\n        cmd_int_busy <= (wb_adr_i == 8'h00 || wb_adr_i == 8'h04);\n        int_busy <= (wb_adr_i == 8'h00);\n        new_cmd <= (wb_adr_i == 8'h00);\n        we_ack <= write_req_s;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 14, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:15];\nreg [15:0] reg_file_16 [0:15];\nreg [7:0] reg_file_8 [0:15];\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers to their default values\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        int_ack <= 1'b1;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n    end else begin\n        // Handle write operations\n        if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: argument_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                8'h28: software_reset_reg <= wb_dat_i[7:0];\n                8'h2c: time_out_reg <= wb_dat_i[15:0];\n                8'h30: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h34: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h4c: clock_divider <= wb_dat_i[7:0];\n                8'h54: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                8'h60: begin\n                    we_m_rx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                    int_ack <= 1'b1;\n                    we_m_rx_bd <= 1'b0;\n                end\n                8'h80: begin\n                    we_m_tx_bd <= 1'b1;\n                    int_ack <= 1'b0;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        dat_in_m_tx_bd <= wb_dat_i;\n                    end else begin\n                        dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                        dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                    end\n                    int_ack <= 1'b1;\n                    we_m_tx_bd <= 1'b0;\n                end\n                default: ;\n            endcase\n        end\n\n        // Handle read operations\n        if (wb_stb_i && wb_cyc_i && ~wb_we_i) begin\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= argument_reg;\n                8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                8'h08: wb_dat_o <= {16'h0000, status_reg};\n                8'h0c: wb_dat_o <= cmd_resp_1;\n                8'h1c: wb_dat_o <= 32'h00000000; // Controller settings not used\n                8'h20: wb_dat_o <= 32'h00000200; // Block size hardcoded to 512\n                8'h24: wb_dat_o <= 32'h0000000f; // Power control hardcoded to 3.3V\n                8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                8'h48: wb_dat_o <= 32'h00000000; // Capability register not used\n                8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                default: wb_dat_o <= 32'h00000000;\n            endcase\n        end\n\n        // Generate acknowledge signal\n        wb_ack_o <= wb_stb_i && wb_cyc_i && ~wb_ack_o && int_ack;\n\n        // Control logic\n        cmd_int_busy <= (wb_stb_i && wb_cyc_i && (wb_adr_i == 8'h00 || wb_adr_i == 8'h04));\n        int_busy <= (wb_stb_i && wb_cyc_i && wb_adr_i == 8'h04);\n        new_cmd <= (wb_stb_i && wb_cyc_i && wb_adr_i == 8'h00);\n        we_ack <= write_req_s;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 15, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:15];\nreg [15:0] reg_file_16 [0:15];\nreg [7:0] reg_file_8 [0:15];\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 0;\n        we_m_tx_bd <= 0;\n        we_m_rx_bd <= 0;\n        new_cmd <= 0;\n        we_ack <= 0;\n        int_ack <= 1;\n        cmd_int_busy <= 0;\n        int_busy <= 0;\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n    end else begin\n        if (wb_stb_i && wb_cyc_i) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1;\n                    8'h34: error_isr_reset <= 1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1;\n                        int_ack <= 0;\n                        dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1;\n                        int_ack <= 0;\n                        dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h00000000;\n                    8'h20: wb_dat_o <= 32'h00000200;\n                    8'h24: wb_dat_o <= 32'h0000000f;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000;\n                    8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n            if (we_m_rx_bd || we_m_tx_bd) begin\n                int_ack <= 1;\n                we_m_rx_bd <= 0;\n                we_m_tx_bd <= 0;\n            end\n        end\n    end\nend\n\nalways @(posedge write_req_s) begin\n    we_ack <= 1;\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_arg_s != 0) begin\n        new_cmd <= 1;\n        cmd_int_busy <= 1;\n    end else begin\n        new_cmd <= 0;\n        cmd_int_busy <= 0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [`RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [`BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [`RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [`BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [`RAM_MEM_WIDTH-1:0] bd_mem [0:`BD_SIZE-1];\n    reg [1:0] state, next_state;\n    reg last_a_cmp;\n\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            free_bd <= (`RAM_MEM_WIDTH == 32) ? (`BD_SIZE >> 1) : (`BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            ack_o_s <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        ack_o_s = 0;\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0) begin\n                    next_state = WRITE;\n                end else if (re_s) begin\n                    next_state = READ;\n                end\n            end\n            WRITE: begin\n                if (`RAM_MEM_WIDTH == 32) begin\n                    if (m_wr_pnt[0] == 1) begin\n                        free_bd = free_bd - 1;\n                        next_state = IDLE;\n                    end\n                end else begin\n                    if (m_wr_pnt[1:0] == 2'b11) begin\n                        free_bd = free_bd - 1;\n                        next_state = IDLE;\n                    end\n                end\n            end\n            READ: begin\n                ack_o_s = 1;\n                if (`RAM_MEM_WIDTH == 32) begin\n                    if (s_rd_pnt[0] == 1) begin\n                        next_state = IDLE;\n                    end\n                end else begin\n                    if (s_rd_pnt[1:0] == 2'b11) begin\n                        next_state = IDLE;\n                    end\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (state == WRITE && we_m) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n        end\n        if (state == READ && re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= s_rd_pnt + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 16, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [15:0] controller_setting_reg;\nreg [15:0] block_size_reg;\nreg [7:0] power_control_reg;\nreg [15:0] capabilities_reg;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n    end else begin\n        if (wb_stb_i && wb_cyc_i) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= {16'h0000, controller_setting_reg};\n                    8'h20: wb_dat_o <= {16'h0000, block_size_reg};\n                    8'h24: wb_dat_o <= {24'h000000, power_control_reg};\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= {16'h0000, capabilities_reg};\n                    8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            int_ack <= 1'b1;\n        end\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (write_req_s) begin\n        we_ack <= 1'b1;\n    end else begin\n        we_ack <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s != 16'h0000 || cmd_arg_s != 32'h00000000) begin\n        new_cmd <= 1'b1;\n    end else begin\n        new_cmd <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s != 16'h0000 || cmd_arg_s != 32'h00000000) begin\n        cmd_int_busy <= 1'b1;\n    end else begin\n        cmd_int_busy <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (wb_stb_i && wb_cyc_i && wb_adr_i == 8'h04) begin\n        int_busy <= 1'b1;\n    end else begin\n        int_busy <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    reg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [1:0] write_count, read_count;\n    reg last_a_cmp;\n\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        ack_o_s = 0;\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0) begin\n                    next_state = WRITE;\n                end else if (re_s) begin\n                    next_state = READ;\n                end\n            end\n            WRITE: begin\n                if (write_count == ((RAM_MEM_WIDTH == 32) ? 1 : 3)) begin\n                    next_state = IDLE;\n                end\n            end\n            READ: begin\n                if (read_count == ((RAM_MEM_WIDTH == 32) ? 1 : 3)) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (state == WRITE) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            write_count <= write_count + 1;\n            if (write_count == ((RAM_MEM_WIDTH == 32) ? 1 : 3)) begin\n                free_bd <= free_bd - 1;\n                write_count <= 0;\n            end\n        end else if (state == READ) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            read_count <= read_count + 1;\n            if (read_count == ((RAM_MEM_WIDTH == 32) ? 1 : 3)) begin\n                ack_o_s <= 1;\n                read_count <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [`RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [`BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [`RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Internal signals\n    reg [`BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [`BD_WIDTH-1:0] write_counter, read_counter;\n    reg last_a_cmp;\n    reg [`RAM_MEM_WIDTH-1:0] bd_mem [0:`BD_SIZE-1];\n    reg new_bw;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (`RAM_MEM_WIDTH == 32) ? (`BD_SIZE >> 1) : (`BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_counter <= 0;\n            read_counter <= 0;\n            last_a_cmp <= 0;\n            ack_o_s <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_counter <= write_counter + 1;\n                if ((`RAM_MEM_WIDTH == 32 && write_counter == 1) || \n                    (`RAM_MEM_WIDTH == 16 && write_counter == 3)) begin\n                    new_bw <= 1;\n                    free_bd <= free_bd - 1;\n                    write_counter <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_counter <= read_counter + 1;\n                if ((`RAM_MEM_WIDTH == 32 && read_counter == 1) || \n                    (`RAM_MEM_WIDTH == 16 && read_counter == 3)) begin\n                    ack_o_s <= 1;\n                    read_counter <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n\n            // Circular Operation\n            if (m_wr_pnt == `BD_SIZE) m_wr_pnt <= 0;\n            if (s_rd_pnt == `BD_SIZE) s_rd_pnt <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    // Internal signals\n    reg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    reg last_a_cmp;\n    reg [1:0] state, next_state;\n\n    // State encoding\n    localparam IDLE = 2'b00,\n               WRITE = 2'b01,\n               READ = 2'b10;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? BD_SIZE >> 1 : BD_SIZE >> 2;\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            state <= IDLE;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n        end\n    end\n\n    // State transition\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0)\n                    next_state = WRITE;\n                else if (re_s)\n                    next_state = READ;\n            end\n            WRITE: begin\n                if (we_m)\n                    next_state = IDLE;\n            end\n            READ: begin\n                if (re_s)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Write operation\n    always @(posedge clk) begin\n        if (state == WRITE && we_m) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            if (RAM_MEM_WIDTH == 32) begin\n                if (m_wr_pnt[0] == 1'b1) begin\n                    free_bd <= free_bd - 1;\n                end\n            end else begin\n                if (m_wr_pnt[1:0] == 2'b11) begin\n                    free_bd <= free_bd - 1;\n                end\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge clk) begin\n        if (state == READ && re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            if (RAM_MEM_WIDTH == 32) begin\n                if (s_rd_pnt[0] == 1'b1) begin\n                    ack_o_s <= 1;\n                end\n            end else begin\n                if (s_rd_pnt[1:0] == 2'b11) begin\n                    ack_o_s <= 1;\n                end\n            end\n        end else begin\n            ack_o_s <= 0;\n        end\n    end\n\n    // Release buffer descriptor\n    always @(posedge clk) begin\n        if (a_cmp && !last_a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 17, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] reg_file [0:15];\nreg [15:0] reg_file_16 [0:15];\nreg [7:0] reg_file_8 [0:15];\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n    end else begin\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_rx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                        int_ack <= 1'b1;\n                        we_m_rx_bd <= 1'b0;\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                        end else begin\n                            dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                            dat_in_m_tx_bd[31:16] <= wb_dat_i[31:16];\n                        end\n                        int_ack <= 1'b1;\n                        we_m_tx_bd <= 1'b0;\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 32'h00000000;\n                    8'h20: wb_dat_o <= 32'h00000200;\n                    8'h24: wb_dat_o <= 32'h0000000F;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000;\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (write_req_s) begin\n        we_ack <= 1'b1;\n    end else begin\n        we_ack <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s || cmd_arg_s) begin\n        new_cmd <= 1'b1;\n    end else begin\n        new_cmd <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (cmd_set_s || cmd_arg_s) begin\n        cmd_int_busy <= 1'b1;\n    end else begin\n        cmd_int_busy <= 1'b0;\n    end\nend\n\nalways @(posedge wb_clk_i) begin\n    if (wb_adr_i == 8'h04) begin\n        int_busy <= 1'b1;\n    end else begin\n        int_busy <= 1'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [`RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [`BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [`RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [`BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [`RAM_MEM_WIDTH-1:0] bd_mem [0:`BD_SIZE-1];\n    reg last_a_cmp;\n    reg [1:0] state, next_state;\n\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n\n    // State Transition\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0)\n                    next_state = WRITE;\n                else if (re_s)\n                    next_state = READ;\n                else\n                    next_state = IDLE;\n            end\n            WRITE: begin\n                if (/* write complete condition */)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE;\n            end\n            READ: begin\n                if (/* read complete condition */)\n                    next_state = IDLE;\n                else\n                    next_state = READ;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (`RAM_MEM_WIDTH == 32) ? (`BD_SIZE >> 1) : (`BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            // Write Buffer Descriptor\n            if (state == WRITE) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                if (/* complete BD write condition */) begin\n                    free_bd <= free_bd - 1;\n                    // Set new_bw high\n                end\n            end\n\n            // Read Buffer Descriptor\n            if (state == READ) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                if (`RAM_MEM_WIDTH == 16) begin\n                    ack_o_s <= 1;\n                end\n            end else begin\n                ack_o_s <= 0;\n            end\n\n            // Release Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    reg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [BD_WIDTH-1:0] write_count, read_count;\n    reg last_a_cmp;\n    wire a_cmp_rising_edge;\n\n    assign a_cmp_rising_edge = a_cmp & ~last_a_cmp;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            ack_o_s <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            last_a_cmp <= a_cmp;\n\n            // Write operation\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_count <= write_count + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_count == 1) || (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                    free_bd <= free_bd - 1;\n                    write_count <= 0;\n                end\n            end\n\n            // Read operation\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_count <= read_count + 1;\n                if ((RAM_MEM_WIDTH == 32 && read_count == 1) || (RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                    ack_o_s <= 1;\n                    read_count <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end else begin\n                ack_o_s <= 0;\n            end\n\n            // Release operation\n            if (a_cmp_rising_edge) begin\n                free_bd <= free_bd + 1;\n            end\n\n            // Circular operation\n            if (m_wr_pnt == BD_SIZE) m_wr_pnt <= 0;\n            if (s_rd_pnt == BD_SIZE) s_rd_pnt <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 18, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\nreg [31:0] bd_rx_reg;\nreg [31:0] bd_tx_reg;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 0;\n        we_m_tx_bd <= 0;\n        we_m_rx_bd <= 0;\n        new_cmd <= 0;\n        we_ack <= 0;\n        int_ack <= 1;\n        cmd_int_busy <= 0;\n        int_busy <= 0;\n        argument_reg <= 0;\n        cmd_setting_reg <= 0;\n        software_reset_reg <= 0;\n        time_out_reg <= 0;\n        normal_int_signal_enable_reg <= 0;\n        error_int_signal_enable_reg <= 0;\n        clock_divider <= 0;\n        Bd_isr_enable_reg <= 0;\n        Bd_isr_reset <= 0;\n        normal_isr_reset <= 0;\n        error_isr_reset <= 0;\n    end else begin\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1;\n                    8'h34: error_isr_reset <= 1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1;\n                        bd_rx_reg <= wb_dat_i;\n                        int_ack <= 0;\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1;\n                        bd_tx_reg <= wb_dat_i;\n                        int_ack <= 0;\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'b0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 16'b0;\n                    8'h20: wb_dat_o <= 16'h0200;\n                    8'h24: wb_dat_o <= 8'h0f;\n                    8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'b0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 16'b0;\n                    8'h4c: wb_dat_o <= {24'b0, clock_divider};\n                    8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1;\n        end else begin\n            wb_ack_o <= 0;\n            if (we_m_rx_bd || we_m_tx_bd) begin\n                int_ack <= 1;\n                we_m_rx_bd <= 0;\n                we_m_tx_bd <= 0;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 19, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\nreg [15:0] bd_rx_reg, bd_tx_reg;\nreg [1:0] bd_write_state;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        // Reset all registers and signals\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        bd_write_state <= 2'b00;\n    end else begin\n        // Default values\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: begin\n                        argument_reg <= wb_dat_i;\n                        new_cmd <= 1'b1;\n                    end\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2C: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4C: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            wb_ack_o <= 1'b1;\n                        end else begin\n                            case (bd_write_state)\n                                2'b00: begin\n                                    dat_in_m_rx_bd[15:0] <= wb_dat_i[15:0];\n                                    bd_write_state <= 2'b01;\n                                end\n                                2'b01: begin\n                                    dat_in_m_rx_bd[RAM_MEM_WIDTH-1:16] <= wb_dat_i[RAM_MEM_WIDTH-1:16];\n                                    wb_ack_o <= 1'b1;\n                                    bd_write_state <= 2'b00;\n                                end\n                            endcase\n                        end\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            wb_ack_o <= 1'b1;\n                        end else begin\n                            case (bd_write_state)\n                                2'b00: begin\n                                    dat_in_m_tx_bd[15:0] <= wb_dat_i[15:0];\n                                    bd_write_state <= 2'b01;\n                                end\n                                2'b01: begin\n                                    dat_in_m_tx_bd[RAM_MEM_WIDTH-1:16] <= wb_dat_i[RAM_MEM_WIDTH-1:16];\n                                    wb_ack_o <= 1'b1;\n                                    bd_write_state <= 2'b00;\n                                end\n                            endcase\n                        end\n                    end\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 32'h00000000; // Controller Setting\n                    8'h20: wb_dat_o <= 32'h00000200; // Block Size\n                    8'h24: wb_dat_o <= 32'h0000000F; // Power Control\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000; // Capability\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n                wb_ack_o <= 1'b1;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [`RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [`BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [`RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [`BD_WIDTH-1:0] m_wr_pnt;\n    reg [`BD_WIDTH-1:0] s_rd_pnt;\n    reg [`RAM_MEM_WIDTH-1:0] bd_mem [0:`BD_SIZE-1];\n    reg last_a_cmp;\n    reg [1:0] state, next_state;\n\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            free_bd <= (`RAM_MEM_WIDTH == 32) ? (`BD_SIZE >> 1) : (`BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            ack_o_s <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        ack_o_s = 0;\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0) begin\n                    next_state = WRITE;\n                end else if (re_s) begin\n                    next_state = READ;\n                end\n            end\n            WRITE: begin\n                if (`RAM_MEM_WIDTH == 32) begin\n                    if (m_wr_pnt[0] == 1) begin\n                        free_bd = free_bd - 1;\n                        next_state = IDLE;\n                    end\n                end else begin\n                    if (m_wr_pnt[1:0] == 2'b11) begin\n                        free_bd = free_bd - 1;\n                        next_state = IDLE;\n                    end\n                end\n            end\n            READ: begin\n                if (`RAM_MEM_WIDTH == 32) begin\n                    if (s_rd_pnt[0] == 1) begin\n                        next_state = IDLE;\n                    end\n                end else begin\n                    if (s_rd_pnt[1:0] == 2'b11) begin\n                        next_state = IDLE;\n                    end\n                    ack_o_s = 1;\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (state == WRITE) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n        end else if (state == READ) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= s_rd_pnt + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    reg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [1:0] write_count, read_count;\n    reg last_a_cmp;\n\n    // State encoding\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n    reg [1:0] state, next_state;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? BD_SIZE >> 1 : BD_SIZE >> 2;\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            state <= IDLE;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n        end\n    end\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0)\n                    next_state = WRITE;\n                else if (re_s)\n                    next_state = READ;\n                else\n                    next_state = IDLE;\n            end\n            WRITE: begin\n                if ((RAM_MEM_WIDTH == 32 && write_count == 1) || \n                    (RAM_MEM_WIDTH == 16 && write_count == 3))\n                    next_state = IDLE;\n                else\n                    next_state = WRITE;\n            end\n            READ: begin\n                if ((RAM_MEM_WIDTH == 32 && read_count == 1) || \n                    (RAM_MEM_WIDTH == 16 && read_count == 3))\n                    next_state = IDLE;\n                else\n                    next_state = READ;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Write operation\n    always @(posedge clk) begin\n        if (state == WRITE) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            write_count <= write_count + 1;\n            if ((RAM_MEM_WIDTH == 32 && write_count == 1) || \n                (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                free_bd <= free_bd - 1;\n                write_count <= 0;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge clk) begin\n        if (state == READ) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            read_count <= read_count + 1;\n            if (RAM_MEM_WIDTH == 16)\n                ack_o_s <= 1;\n            if ((RAM_MEM_WIDTH == 32 && read_count == 1) || \n                (RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                read_count <= 0;\n                ack_o_s <= 0;\n            end\n        end\n    end\n\n    // Release buffer descriptor\n    always @(posedge clk) begin\n        if (a_cmp && !last_a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [`RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [`BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [`RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [`BD_WIDTH-1:0] m_wr_pnt;\n    reg [`BD_WIDTH-1:0] s_rd_pnt;\n    reg [`RAM_MEM_WIDTH-1:0] bd_mem [0:`BD_SIZE-1];\n    reg last_a_cmp;\n\n    // State encoding\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n    reg [1:0] state, next_state;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (`RAM_MEM_WIDTH == 32) ? (`BD_SIZE >> 1) : (`BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            state <= IDLE;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n        end\n    end\n\n    // State transition\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0)\n                    next_state = WRITE;\n                else if (re_s)\n                    next_state = READ;\n                else\n                    next_state = IDLE;\n            end\n            WRITE: begin\n                if ((`RAM_MEM_WIDTH == 32 && m_wr_pnt[0]) || (`RAM_MEM_WIDTH == 16 && m_wr_pnt[1:0] == 2'b11))\n                    next_state = IDLE;\n                else\n                    next_state = WRITE;\n            end\n            READ: begin\n                if ((`RAM_MEM_WIDTH == 32 && s_rd_pnt[0]) || (`RAM_MEM_WIDTH == 16 && s_rd_pnt[1:0] == 2'b11))\n                    next_state = IDLE;\n                else\n                    next_state = READ;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Write operation\n    always @(posedge clk) begin\n        if (state == WRITE) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            if ((`RAM_MEM_WIDTH == 32 && m_wr_pnt[0]) || (`RAM_MEM_WIDTH == 16 && m_wr_pnt[1:0] == 2'b11)) begin\n                free_bd <= free_bd - 1;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge clk) begin\n        if (state == READ) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= s_rd_pnt + 1;\n            if (`RAM_MEM_WIDTH == 16) begin\n                ack_o_s <= 1;\n            end\n        end else begin\n            ack_o_s <= 0;\n        end\n    end\n\n    // Release buffer descriptor\n    always @(posedge clk) begin\n        if (a_cmp && !last_a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [`RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [`BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [`RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [`BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [`RAM_MEM_WIDTH-1:0] bd_mem [0:`BD_SIZE-1];\n    reg last_a_cmp;\n    reg [1:0] state, next_state;\n\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            free_bd <= (`RAM_MEM_WIDTH == 32) ? (`BD_SIZE >> 1) : (`BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        ack_o_s = 0;\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0) begin\n                    next_state = WRITE;\n                end else if (re_s) begin\n                    next_state = READ;\n                end\n            end\n            WRITE: begin\n                if (`RAM_MEM_WIDTH == 32) begin\n                    if (m_wr_pnt[0] == 1) begin\n                        free_bd = free_bd - 1;\n                        next_state = IDLE;\n                    end\n                end else begin\n                    if (m_wr_pnt[1:0] == 2'b11) begin\n                        free_bd = free_bd - 1;\n                        next_state = IDLE;\n                    end\n                end\n            end\n            READ: begin\n                ack_o_s = 1;\n                if (`RAM_MEM_WIDTH == 32) begin\n                    if (s_rd_pnt[0] == 1) begin\n                        next_state = IDLE;\n                    end\n                end else begin\n                    if (s_rd_pnt[1:0] == 2'b11) begin\n                        next_state = IDLE;\n                    end\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (state == WRITE && we_m) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n        end\n        if (state == READ && re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= s_rd_pnt + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [`RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [`BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [`RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [`BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [`BD_WIDTH-1:0] write_count, read_count;\n    reg last_a_cmp;\n    reg [`RAM_MEM_WIDTH-1:0] bd_mem [0:`BD_SIZE-1];\n\n    // State encoding\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n    reg [1:0] state, next_state;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            free_bd <= (`RAM_MEM_WIDTH == 32) ? (`BD_SIZE >> 1) : (`BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n        end\n    end\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0)\n                    next_state = WRITE;\n                else if (re_s)\n                    next_state = READ;\n                else\n                    next_state = IDLE;\n            end\n            WRITE: begin\n                if ((`RAM_MEM_WIDTH == 32 && write_count == 1) || (`RAM_MEM_WIDTH == 16 && write_count == 3))\n                    next_state = IDLE;\n                else\n                    next_state = WRITE;\n            end\n            READ: begin\n                if ((`RAM_MEM_WIDTH == 32 && read_count == 1) || (`RAM_MEM_WIDTH == 16 && read_count == 3))\n                    next_state = IDLE;\n                else\n                    next_state = READ;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Write operation\n    always @(posedge clk) begin\n        if (state == WRITE) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= m_wr_pnt + 1;\n            write_count <= write_count + 1;\n            if ((`RAM_MEM_WIDTH == 32 && write_count == 1) || (`RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                free_bd <= free_bd - 1;\n                write_count <= 0;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge clk) begin\n        if (state == READ) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= s_rd_pnt + 1;\n            read_count <= read_count + 1;\n            if (`RAM_MEM_WIDTH == 16)\n                ack_o_s <= 1;\n            if ((`RAM_MEM_WIDTH == 32 && read_count == 1) || (`RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                read_count <= 0;\n                ack_o_s <= 0;\n            end\n        end\n    end\n\n    // Release buffer descriptor\n    always @(posedge clk) begin\n        if (a_cmp && !last_a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode command settings\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and internal counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[6 - Cmd_Cnt];\n                            st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write ? 2'b01 : 2'b00);\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[6 - Cmd_Cnt];\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write ? 2'b01 : 2'b00);\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    parameter INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    parameter NCR = 2;\n    parameter SEND_SIZE = 48;\n    parameter SIZE = 10;\n    parameter CONTENT_SIZE = 40;\n    parameter Read_Delay = 7;\n    parameter EIGHT_PAD = 8;\n\n    // FSM states\n    parameter INIT = 10'b0000000001;\n    parameter IDLE = 10'b0000000010;\n    parameter WRITE_WR = 10'b0000000100;\n    parameter DLY_WR = 10'b0000001000;\n    parameter READ_WR = 10'b0000010000;\n    parameter DLY_READ = 10'b0000100000;\n    parameter ACK_WR = 10'b0001000000;\n    parameter WRITE_WO = 10'b0010000000;\n    parameter DLY_WO = 10'b0100000000;\n    parameter ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational logic for next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential logic for state transition\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39];\n                            In_Buff <= {In_Buff[38:0], 1'b0};\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39];\n                            In_Buff <= {In_Buff[38:0], 1'b0};\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff <= {Out_Buff[38:0], cmd_dat_i};\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= {CRC_IN[5:0], cmd_dat_i};\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [`RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [`BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [`RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [`BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [`BD_WIDTH-1:0] write_count, read_count;\n    reg last_a_cmp;\n    reg [`RAM_MEM_WIDTH-1:0] bd_mem [0:`BD_SIZE-1];\n\n    // State encoding\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n    reg [1:0] state, next_state;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            free_bd <= (`RAM_MEM_WIDTH == 32) ? (`BD_SIZE >> 1) : (`BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n        end\n    end\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0)\n                    next_state = WRITE;\n                else if (re_s)\n                    next_state = READ;\n                else\n                    next_state = IDLE;\n            end\n            WRITE: begin\n                if ((`RAM_MEM_WIDTH == 32 && write_count == 1) || \n                    (`RAM_MEM_WIDTH == 16 && write_count == 3))\n                    next_state = IDLE;\n                else\n                    next_state = WRITE;\n            end\n            READ: begin\n                if ((`RAM_MEM_WIDTH == 32 && read_count == 1) || \n                    (`RAM_MEM_WIDTH == 16 && read_count == 3))\n                    next_state = IDLE;\n                else\n                    next_state = READ;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Write operation\n    always @(posedge clk) begin\n        if (state == WRITE) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % `BD_SIZE;\n            write_count <= write_count + 1;\n            if ((`RAM_MEM_WIDTH == 32 && write_count == 1) || \n                (`RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                free_bd <= free_bd - 1;\n                write_count <= 0;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge clk) begin\n        if (state == READ) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % `BD_SIZE;\n            read_count <= read_count + 1;\n            if (`RAM_MEM_WIDTH == 16)\n                ack_o_s <= 1;\n            if ((`RAM_MEM_WIDTH == 32 && read_count == 1) || \n                (`RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                read_count <= 0;\n                ack_o_s <= 0;\n            end\n        end\n    end\n\n    // Release buffer descriptor\n    always @(posedge clk) begin\n        if (a_cmp && !last_a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [`RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [`BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [`RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [`BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [`RAM_MEM_WIDTH-1:0] bd_mem [0:`BD_SIZE-1];\n    reg [1:0] write_count, read_count;\n    reg last_a_cmp;\n\n    // State encoding\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n    reg [1:0] state, next_state;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (`RAM_MEM_WIDTH == 32) ? (`BD_SIZE >> 1) : (`BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            state <= IDLE;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n        end\n    end\n\n    // State transition\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0)\n                    next_state = WRITE;\n                else if (re_s)\n                    next_state = READ;\n                else\n                    next_state = IDLE;\n            end\n            WRITE: begin\n                if ((`RAM_MEM_WIDTH == 32 && write_count == 1) || \n                    (`RAM_MEM_WIDTH == 16 && write_count == 3))\n                    next_state = IDLE;\n                else\n                    next_state = WRITE;\n            end\n            READ: begin\n                if ((`RAM_MEM_WIDTH == 32 && read_count == 1) || \n                    (`RAM_MEM_WIDTH == 16 && read_count == 3))\n                    next_state = IDLE;\n                else\n                    next_state = READ;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Write operation\n    always @(posedge clk) begin\n        if (state == WRITE) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % `BD_SIZE;\n            write_count <= write_count + 1;\n            if ((`RAM_MEM_WIDTH == 32 && write_count == 1) || \n                (`RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                free_bd <= free_bd - 1;\n                write_count <= 0;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge clk) begin\n        if (state == READ) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % `BD_SIZE;\n            read_count <= read_count + 1;\n            if (`RAM_MEM_WIDTH == 16)\n                ack_o_s <= 1;\n            if ((`RAM_MEM_WIDTH == 32 && read_count == 1) || \n                (`RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                read_count <= 0;\n                ack_o_s <= 0;\n            end\n        end\n    end\n\n    // Release buffer descriptor\n    always @(posedge clk) begin\n        if (a_cmp && !last_a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM states\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = INIT;\n            end\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Ack_internal_in <= 0;\n            q1 <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering == 1) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering == 1) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - (Cmd_Cnt - 9)];\n                            CRC_OUT <= In_Buff[39 - (Cmd_Cnt - 9)];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC module instantiation\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 20, "code": "module sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n`include \"sd_defines.v\"\n\nreg [31:0] registers [0:15];\nreg [15:0] bd_rx_reg;\nreg [15:0] bd_tx_reg;\nreg [1:0] bd_write_state;\n\nlocalparam IDLE = 2'b00;\nlocalparam WRITE_LOWER = 2'b01;\nlocalparam WRITE_UPPER = 2'b10;\n\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 1'b0;\n        we_m_tx_bd <= 1'b0;\n        we_m_rx_bd <= 1'b0;\n        new_cmd <= 1'b0;\n        we_ack <= 1'b0;\n        int_ack <= 1'b1;\n        cmd_int_busy <= 1'b0;\n        int_busy <= 1'b0;\n        argument_reg <= 32'h00000000;\n        cmd_setting_reg <= 16'h0000;\n        software_reset_reg <= 8'h00;\n        time_out_reg <= 16'h0000;\n        normal_int_signal_enable_reg <= 16'h0000;\n        error_int_signal_enable_reg <= 16'h0000;\n        clock_divider <= 8'h00;\n        Bd_isr_enable_reg <= 8'h00;\n        Bd_isr_reset <= 1'b0;\n        normal_isr_reset <= 1'b0;\n        error_isr_reset <= 1'b0;\n        bd_write_state <= IDLE;\n    end else begin\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            if (wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: begin\n                        argument_reg <= wb_dat_i;\n                        new_cmd <= 1'b1;\n                    end\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h30: normal_isr_reset <= 1'b1;\n                    8'h34: error_isr_reset <= 1'b1;\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h54: Bd_isr_reset <= 1'b1;\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        we_m_rx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        bd_rx_reg <= wb_dat_i[15:0];\n                        bd_write_state <= WRITE_LOWER;\n                    end\n                    8'h80: begin\n                        we_m_tx_bd <= 1'b1;\n                        int_ack <= 1'b0;\n                        bd_tx_reg <= wb_dat_i[15:0];\n                        bd_write_state <= WRITE_LOWER;\n                    end\n                endcase\n            end else begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h1c: wb_dat_o <= 32'h00000000;\n                    8'h20: wb_dat_o <= 32'h00000200;\n                    8'h24: wb_dat_o <= 32'h0000000f;\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000;\n                    8'h4c: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                endcase\n            end\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n            new_cmd <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            Bd_isr_reset <= 1'b0;\n            case (bd_write_state)\n                WRITE_LOWER: begin\n                    if (RAM_MEM_WIDTH == 16) begin\n                        bd_write_state <= WRITE_UPPER;\n                    end else begin\n                        int_ack <= 1'b1;\n                        we_m_rx_bd <= 1'b0;\n                        we_m_tx_bd <= 1'b0;\n                        bd_write_state <= IDLE;\n                    end\n                end\n                WRITE_UPPER: begin\n                    int_ack <= 1'b1;\n                    we_m_rx_bd <= 1'b0;\n                    we_m_tx_bd <= 1'b0;\n                    bd_write_state <= IDLE;\n                end\n            endcase\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    parameter INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    parameter NCR = 2;\n    parameter SEND_SIZE = 48;\n    parameter SIZE = 10;\n    parameter CONTENT_SIZE = 40;\n    parameter Read_Delay = 7;\n    parameter EIGHT_PAD = 8;\n\n    // State Encoding\n    localparam INIT = 10'b0000000001,\n               IDLE = 10'b0000000010,\n               WRITE_WR = 10'b0000000100,\n               DLY_WR = 10'b0000001000,\n               READ_WR = 10'b0000010000,\n               DLY_READ = 10'b0000100000,\n               ACK_WR = 10'b0001000000,\n               WRITE_WO = 10'b0010000000,\n               DLY_WO = 10'b0100000000,\n               ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state, next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational Logic for Next State\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential Logic for State Update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage Outputs and Internal Counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9)\n                                CRC_OUT <= CRC_VAL[6];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                        if (Cmd_Cnt > 9)\n                            CRC_OUT <= CRC_VAL[6];\n                        st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111)\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[Cmd_Cnt - Response_Size] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write) ? 2'b01 : 2'b00;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    reg [BD_WIDTH-1:0] m_wr_pnt;\n    reg [BD_WIDTH-1:0] s_rd_pnt;\n    reg [1:0] write_count;\n    reg [1:0] read_count;\n    reg last_a_cmp;\n\n    // State encoding\n    localparam IDLE = 2'b00, WRITE = 2'b01, READ = 2'b10;\n    reg [1:0] state, next_state;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            state <= IDLE;\n            last_a_cmp <= 0;\n        end else begin\n            state <= next_state;\n            last_a_cmp <= a_cmp;\n        end\n    end\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (we_m && free_bd > 0)\n                    next_state = WRITE;\n                else if (re_s)\n                    next_state = READ;\n                else\n                    next_state = IDLE;\n            end\n            WRITE: begin\n                if ((RAM_MEM_WIDTH == 32 && write_count == 1) || \n                    (RAM_MEM_WIDTH == 16 && write_count == 3))\n                    next_state = IDLE;\n                else\n                    next_state = WRITE;\n            end\n            READ: begin\n                if ((RAM_MEM_WIDTH == 32 && read_count == 1) || \n                    (RAM_MEM_WIDTH == 16 && read_count == 3))\n                    next_state = IDLE;\n                else\n                    next_state = READ;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Write operation\n    always @(posedge clk) begin\n        if (state == WRITE) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            write_count <= write_count + 1;\n            if ((RAM_MEM_WIDTH == 32 && write_count == 1) || \n                (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                free_bd <= free_bd - 1;\n                write_count <= 0;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge clk) begin\n        if (state == READ) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            read_count <= read_count + 1;\n            if ((RAM_MEM_WIDTH == 32 && read_count == 1) || \n                (RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                ack_o_s <= 1;\n                read_count <= 0;\n            end else begin\n                ack_o_s <= 0;\n            end\n        end else begin\n            ack_o_s <= 0;\n        end\n    end\n\n    // Release buffer descriptor\n    always @(posedge clk) begin\n        if (a_cmp && !last_a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinatorial Logic for Next State\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential Logic for State Update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage Outputs and Internal Counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write) ? 2'b01 : 2'b00;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_inst (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam [9:0] INIT = 10'b0000000001,\n                     IDLE = 10'b0000000010,\n                     WRITE_WR = 10'b0000000100,\n                     DLY_WR = 10'b0000001000,\n                     READ_WR = 10'b0000010000,\n                     DLY_READ = 10'b0000100000,\n                     ACK_WR = 10'b0001000000,\n                     WRITE_WO = 10'b0010000000,\n                     DLY_WO = 10'b0100000000,\n                     ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_Enable, CRC_OUT, CRC_Check_On, Crc_Buffering, CRC_Valid;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state, next_state;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in;\n    reg q1, Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = (Write_Read) ? WRITE_WR : (Write_Only) ? WRITE_WO : IDLE;\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Ack_internal_in <= 0;\n            q1 <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode command settings\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and internal counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) CRC_OUT <= CRC_VAL[6];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) CRC_OUT <= CRC_VAL[6];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[Cmd_Cnt - Response_Size] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM states\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational logic for next state\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential logic for state update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs based on FSM state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) begin\n                                CRC_OUT <= CRC_VAL[6];\n                            end\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) begin\n                                CRC_OUT <= CRC_VAL[6];\n                            end\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[Cmd_Cnt - Response_Size] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write ? 2'b01 : 2'b00);\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_inst (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine Next State\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update Current State\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode Command\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage Outputs and Internal Counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Ack_internal_in <= 0;\n            q1 <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode command settings\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            Write_Read <= (SETTING_IN[6:0] > 0);\n            Write_Only <= (SETTING_IN[6:0] == 0);\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_inst (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode command settings\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and internal counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[Cmd_Cnt - Response_Size] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_inst (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_inst (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational Logic for Next State\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential Logic for State Update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage Outputs and Internal Counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) begin\n                                CRC_OUT <= CRC_VAL[6];\n                            end\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) begin\n                                CRC_OUT <= CRC_VAL[6];\n                            end\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[Cmd_Cnt - Response_Size] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM states\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode command settings\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and internal counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt > 1) begin\n                            cmd_out_o <= CRC_OUT;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt > 1) begin\n                            cmd_out_o <= CRC_OUT;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC module instantiation\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: State transition\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode command\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering == 1) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            if (Cmd_Cnt > 9) CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            CRC_OUT <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering == 1) begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                        if (Cmd_Cnt > 9) CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[Cmd_Cnt - Response_Size] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode command settings\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) st_dat_t <= 2'b11;\n                        else if (block_write) st_dat_t <= 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Ack_internal_in <= 0;\n            q1 <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode settings and command\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 9];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 9];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 9];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 9];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111)\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational logic for next state\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if (Delay_Cnt >= NCR && !cmd_dat_i)\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential logic for state transitions\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[Cmd_Cnt - Response_Size] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg index_check_enable, CRC_check_enable;\n    reg complete;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b00;\n            ack_q <= 2'b00;\n            req_in_int <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            ack_q <= {ack_q[0], ack_in};\n            req_in_int <= req_q[1];\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0;\n\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    \n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                    STATUS_REG[0] <= 1'b1;\n                end\n\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            NORMAL_INT_REG[0] <= 1'b1;\n\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Transition\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM State Operation\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg [1:0] CICMD;\n    reg CCRCE, EI, CC;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    reg ack_q, ack_in_int;\n    reg req_q, req_in_int;\n\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 1'b0;\n            ack_in_int <= 1'b0;\n            req_q <= 1'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n            req_q <= req_in;\n            req_in_int <= req_q;\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= 3'b001; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            3'b001: // IDLE\n                if (New_CMD)\n                    next_state = 3'b010; // SETUP\n                else\n                    next_state = 3'b001; // IDLE\n            3'b010: // SETUP\n                if (ack_in_int)\n                    next_state = 3'b100; // EXECUTE\n                else\n                    next_state = 3'b010; // SETUP\n            3'b100: // EXECUTE\n                if (complete)\n                    next_state = 3'b001; // IDLE\n                else\n                    next_state = 3'b100; // EXECUTE\n            default:\n                next_state = 3'b001; // IDLE\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            CCRCE <= 1'b0;\n            EI <= 1'b0;\n            CC <= 1'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                3'b001: begin // IDLE\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    CICMD <= 2'b00;\n\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n\n                3'b010: begin // SETUP\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CMD_SET_REG[3];\n                    settings[6:0] <= response_size;\n\n                    Watchdog_Cnt <= 16'b0;\n                    CICMD <= 2'b01;\n                end\n\n                3'b100: begin // EXECUTE\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        EI <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            EI <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                EI <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                EI <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Combinational Logic for Next State\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential Logic for State Update\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode SETTING_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage Outputs and Internal Counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt + 8];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt + 8];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_VAL[7 - Cmd_Cnt];\n                            st_dat_t <= (block_read) ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write) ? 2'b01 : 2'b00;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_inst (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State encoding\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (dat_ava) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 0)\n                                RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `ifdef SIM 2 `else 64 `endif;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO: Determine next state\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ: Update current state\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) state <= INIT;\n        else state <= next_state;\n    end\n\n    // REQ_SYNC: Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Req_internal_in <= 0;\n            q <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC: Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER: Decode command settings\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT: Manage outputs and counters\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39];\n                            In_Buff <= {In_Buff[38:0], 1'b0};\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[39];\n                            In_Buff <= {In_Buff[38:0], 1'b0};\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= block_read ? 2'b10 : 2'b00;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[39];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff <= {Out_Buff[38:0], cmd_dat_i};\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= {CRC_IN[5:0], cmd_dat_i};\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= (block_read && block_write) ? 2'b11 : (block_write ? 2'b01 : 2'b00);\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b00;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b00;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001;\n    localparam SETUP = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg CRC_check_enable, index_check_enable, complete;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b00;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b00;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg ack_in_int, req_in_int;\n    reg [1:0] req_q, ack_q;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in_int) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 20, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\n    wire inv;\n\n    assign inv = BITVAL ^ CRC[6];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 7'b0;\n        end else if (Enable) begin\n            CRC[0] <= inv;\n            CRC[1] <= CRC[0];\n            CRC[2] <= CRC[1];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[5] <= CRC[4];\n            CRC[6] <= CRC[5];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n    reg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\n    reg [1:0] write_count, read_count;\n    reg last_a_cmp;\n\n    // Initialization\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            free_bd <= (RAM_MEM_WIDTH == 32) ? BD_SIZE >> 1 : BD_SIZE >> 2;\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            write_count <= 0;\n            read_count <= 0;\n            ack_o_s <= 0;\n            last_a_cmp <= 0;\n        end else begin\n            // Writing Buffer Descriptor\n            if (we_m && free_bd > 0) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                write_count <= write_count + 1;\n                if ((RAM_MEM_WIDTH == 32 && write_count == 1) || (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                    free_bd <= free_bd - 1;\n                    write_count <= 0;\n                end\n            end\n\n            // Reading Buffer Descriptor\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                read_count <= read_count + 1;\n                if ((RAM_MEM_WIDTH == 32 && read_count == 1) || (RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                    ack_o_s <= 1;\n                    read_count <= 0;\n                end else begin\n                    ack_o_s <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            if (a_cmp && !last_a_cmp) begin\n                free_bd <= free_bd + 1;\n            end\n            last_a_cmp <= a_cmp;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg complete, index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b00;\n            ack_q <= 2'b00;\n            req_in_int <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            ack_q <= {ack_q[0], ack_in};\n            req_in_int <= req_q[1];\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete, index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg req_q, req_in_int, ack_q, ack_in_int;\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 1'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= req_in;\n            req_in_int <= req_q;\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (dat_ava) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0;\n\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                    STATUS_REG[0] <= 1'b1;\n                end\n\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            NORMAL_INT_REG[0] <= 1'b1;\n\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 12, "code": "module sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg complete, index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n    reg ack_in_int, req_in_int;\n    reg [1:0] ack_q, req_q;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (dat_ava) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 0)\n                                RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 13, "code": "module sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Registers and Wires\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg complete, CRC_check_enable, index_check_enable;\n    reg [7:0] status;\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n    reg [1:0] req_q, ack_q;\n    wire req_in_int = req_q[1];\n    wire ack_in_int = ack_q[1];\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            ack_q <= 2'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            ack_q <= {ack_q[0], ack_in};\n        end\n    end\n\n    // FSM State Transitions\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM State Operations\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    response_size <= (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) ? 7'b0101000 :\n                                     (CMD_SET_REG[1:0] == 2'b01) ? 7'b1111111 : 7'b0;\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (dat_ava) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 0)\n                                RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg ack_in_int, req_in_int;\n    reg [1:0] req_q, ack_q;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n\n            if (debounce == 4'b1111)\n                card_present <= 1'b1;\n            else\n                card_present <= 1'b0;\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            ack_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            ack_q <= {ack_q[0], ack_in};\n            req_in_int <= req_q[1];\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0;\n\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    \n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                    STATUS_REG[0] <= 1'b1;\n                end\n\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n\n                            NORMAL_INT_REG[0] <= 1'b1;\n\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 15, "code": "module sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001;\n    localparam SETUP = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n    reg CCRCE, EI, CC, CIE, CTE;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            CCRCE <= 1'b0;\n            EI <= 1'b0;\n            CC <= 1'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0;\n\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CMD_SET_REG[3];\n                    settings[6:0] <= response_size;\n\n                    Watchdog_Cnt <= 16'b0;\n                end\n\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        CTE <= 1'b1;\n                        EI <= 1'b1;\n                        if (ack_in)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            EI <= 1'b0;\n\n                            if (CRC_check_enable && !status[5]) begin\n                                CCRCE <= 1'b1;\n                                EI <= 1'b1;\n                            end\n\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                CIE <= 1'b1;\n                                EI <= 1'b1;\n                            end\n\n                            CC <= 1'b1;\n\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 16, "code": "module sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg index_check_enable, CRC_check_enable;\n    reg complete;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b00;\n            ack_q <= 2'b00;\n            req_in_int <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            ack_q <= {ack_q[0], ack_in};\n            req_in_int <= req_q[1];\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0)\n                                RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [6:0] response_size;\n    reg index_check_enable, CRC_check_enable;\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b0;\n            ack_q <= 2'b0;\n            req_in_int <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            ack_q <= {ack_q[0], ack_in};\n            req_in_int <= req_q[1];\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Transitions\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Register Update\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM State Operation\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    STATUS_REG[0] <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (dat_ava) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg ack_in_int, req_in_int;\n    reg [39:0] cmd_out_next;\n    reg [15:0] settings_next;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_in_int <= 1'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_in_int <= ack_in;\n            req_in_int <= req_in;\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out_next[39:38] <= 2'b01;\n                    cmd_out_next[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out_next[31:0] <= ARG_REG;\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings_next[14:13] <= CMD_SET_REG[7:6];\n                    settings_next[12] <= data_read;\n                    settings_next[11] <= data_write;\n                    settings_next[10:8] <= 3'b111;\n                    settings_next[7] <= CMD_SET_REG[3];\n                    settings_next[6:0] <= response_size;\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in)\n                            complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0)\n                                RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001;\n    localparam SETUP = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Registers\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg index_check_enable, CRC_check_enable;\n    reg [6:0] response_size;\n    reg complete;\n    reg [7:0] status;\n    reg [1:0] req_q, ack_q;\n    reg req_in_int, ack_in_int;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 2'b00;\n            req_in_int <= 1'b0;\n            ack_q <= 2'b00;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= {req_q[0], req_in};\n            req_in_int <= req_q[1];\n            ack_q <= {ack_q[0], ack_in};\n            ack_in_int <= ack_q[1];\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 7'b0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input wire CLK_PAD_IO,\n    input wire RST_PAD_I,\n    input wire New_CMD,\n    input wire data_write,\n    input wire data_read,\n    input wire [31:0] ARG_REG,\n    input wire [13:0] CMD_SET_REG,\n    input wire [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input wire ERR_INT_RST,\n    input wire NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input wire req_in,\n    input wire ack_in,\n    input wire [39:0] cmd_in,\n    input wire [7:0] serial_status,\n    input wire card_detect\n);\n\n    // State Definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Internal Signals\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg [15:0] Watchdog_Cnt;\n    reg [6:0] response_size;\n    reg index_check_enable, CRC_check_enable, complete;\n    reg [7:0] status;\n    reg req_q, req_in_int, ack_q, ack_in_int;\n    wire dat_ava = status[6];\n    wire crc_valid = status[5];\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n            end\n            card_present <= (debounce == 4'b1111);\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 1'b0;\n            req_in_int <= 1'b0;\n            ack_q <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= req_in;\n            req_in_int <= req_q;\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            CRC_check_enable <= 1'b0;\n            complete <= 1'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            STATUS_REG <= 16'b0;\n            status <= 8'b0;\n            cmd_out <= 40'b0;\n            settings <= 16'b0;\n            response_size <= 7'b0;\n            req_out <= 1'b0;\n            index_check_enable <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n            go_idle_o <= 1'b0;\n        end else begin\n            NORMAL_INT_REG[1] <= card_present;\n            NORMAL_INT_REG[2] <= ~card_present;\n            complete <= 1'b0;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    case (CMD_SET_REG[1:0])\n                        2'b10, 2'b11: response_size <= 7'b0101000;\n                        2'b01: response_size <= 7'b1111111;\n                        default: response_size <= 7'b0;\n                    endcase\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1;\n                        NORMAL_INT_REG[15] <= 1'b1;\n                        if (ack_in) complete <= 1'b1;\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (dat_ava) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0;\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1;\n                                NORMAL_INT_REG[15] <= 1'b1;\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1;\n                            if (response_size != 0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 1, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signal declarations\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter IDLE = 6'b000001;\n    parameter WRITE_DAT = 6'b000010;\n    parameter WRITE_CRC = 6'b000100;\n    parameter WRITE_BUSY = 6'b001000;\n    parameter READ_WAIT = 6'b010000;\n    parameter READ_DAT = 6'b100000;\n\n    // CRC_16_gen: Instantiate CRC module\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC: Synchronize ack_transfer\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO: Combinational logic for state transitions\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = WRITE_CRC;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 0)\n                    next_state = WRITE_BUSY;\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0)\n                    next_state = IDLE;\n            end\n            READ_WAIT: begin\n                if (q_start_bit == 0)\n                    next_state = READ_DAT;\n            end\n            READ_DAT: begin\n                if (transf_cnt >= BIT_BLOCK_REC)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // START_SYNC: Synchronize start bit detection\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAR_dat_i[0] && state == READ_WAIT)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ: Sequential logic for FSM state updates\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT: Output logic based on FSM state\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                end\n                WRITE_DAT: begin\n                    // Implement WRITE_DAT logic\n                end\n                WRITE_CRC: begin\n                    // Implement WRITE_CRC logic\n                end\n                WRITE_BUSY: begin\n                    // Implement WRITE_BUSY logic\n                end\n                READ_WAIT: begin\n                    // Implement READ_WAIT logic\n                end\n                READ_DAT: begin\n                    // Implement READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 2, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            6'b000000: begin // IDLE\n                if (start_dat == 2'b10)\n                    next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b01)\n                    next_state = 6'b000100; // READ_WAIT\n            end\n            6'b000001: begin // WRITE_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000010; // WRITE_CRC\n            end\n            6'b000010: begin // WRITE_CRC\n                if (crc_status == 0)\n                    next_state = 6'b000011; // WRITE_BUSY\n            end\n            6'b000011: begin // WRITE_BUSY\n                if (!busy_int)\n                    next_state = 6'b000000; // IDLE\n            end\n            6'b000100: begin // READ_WAIT\n                if (DAT_dat_i[0] == 0)\n                    next_state = 6'b000101; // READ_DAT\n            end\n            6'b000101: begin // READ_DAT\n                if (transf_cnt >= BIT_BLOCK_REC)\n                    next_state = 6'b000000; // IDLE\n            end\n            default: next_state = 6'b000000; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else if (!DAT_dat_i[0] & state == 6'b000100) begin\n            q_start_bit <= 0;\n        end else begin\n            q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                end\n                6'b000001: begin // WRITE_DAT\n                    // Logic for WRITE_DAT state\n                end\n                6'b000010: begin // WRITE_CRC\n                    // Logic for WRITE_CRC state\n                end\n                6'b000011: begin // WRITE_BUSY\n                    // Logic for WRITE_BUSY state\n                end\n                6'b000100: begin // READ_WAIT\n                    // Logic for READ_WAIT state\n                end\n                6'b000101: begin // READ_DAT\n                    // Logic for READ_DAT state\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 3, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @* begin\n        case (state)\n            6'b000000: begin // IDLE\n                if (start_dat == 2'b10)\n                    next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b01)\n                    next_state = 6'b000100; // READ_WAIT\n                else\n                    next_state = 6'b000000; // IDLE\n            end\n            6'b000001: begin // WRITE_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000010; // WRITE_CRC\n                else\n                    next_state = 6'b000001; // WRITE_DAT\n            end\n            6'b000010: begin // WRITE_CRC\n                if (crc_status == 0)\n                    next_state = 6'b000011; // WRITE_BUSY\n                else\n                    next_state = 6'b000010; // WRITE_CRC\n            end\n            6'b000011: begin // WRITE_BUSY\n                if (!busy_int)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000011; // WRITE_BUSY\n            end\n            6'b000100: begin // READ_WAIT\n                if (DAT_dat_i[0] == 0)\n                    next_state = 6'b000101; // READ_DAT\n                else\n                    next_state = 6'b000100; // READ_WAIT\n            end\n            6'b000101: begin // READ_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000101; // READ_DAT\n            end\n            default: next_state = 6'b000000; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == 6'b000100)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                end\n                6'b000001: begin // WRITE_DAT\n                    // Implement WRITE_DAT logic\n                end\n                6'b000010: begin // WRITE_CRC\n                    // Implement WRITE_CRC logic\n                end\n                6'b000011: begin // WRITE_BUSY\n                    // Implement WRITE_BUSY logic\n                end\n                6'b000100: begin // READ_WAIT\n                    // Implement READ_WAIT logic\n                end\n                6'b000101: begin // READ_DAT\n                    // Implement READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00, REQUEST = 2'b01, WRITE_FIFO = 2'b10, DELAY = 2'b11;\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic and state actions\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    reset_tx_fifo <= !en;\n                    if (en) begin\n                        m_wb_adr_o <= adr + offset;\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b1;\n                        m_wb_stb_o <= 1'b1;\n                        m_wb_cti_o <= 3'b0;\n                        m_wb_bte_o <= 2'b0;\n                    end else begin\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    if (m_wb_ack_i) begin\n                        din <= m_wb_dat_i;\n                        wr_tx <= 1'b1;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        delay <= 1'b1;\n                    end\n                end\n                WRITE_FIFO: begin\n                    wr_tx <= 1'b0;\n                    offset <= offset + 1;\n                    ackd <= ~ackd;\n                end\n                DELAY: begin\n                    delay <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n    wire [FIFO_TX_MEM_ADR_SIZE:0] wptr_next, rptr_next;\n    wire [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_sync, rptr_gray_sync;\n\n    // Write pointer increment and wrap-around\n    assign wptr_next = wptr + (wr & ~full);\n    assign wptr_gray = (wptr_next >> 1) ^ wptr_next;\n\n    // Read pointer increment and wrap-around\n    assign rptr_next = rptr + (rd & ~empty);\n    assign rptr_gray = (rptr_next >> 1) ^ rptr_next;\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            wptr <= 0;\n            adr_i <= 0;\n        end else if (wr & ~full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr_next;\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            rptr <= 0;\n            adr_o <= 0;\n            q <= 0;\n        end else if (rd & ~empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr_next;\n        end\n    end\n\n    // Full and empty status update\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            wptr_gray_sync <= 0;\n        end else begin\n            wptr_gray_sync <= wptr_gray;\n            full <= (wptr_next[FIFO_TX_MEM_ADR_SIZE-1:0] == rptr_gray_sync[FIFO_TX_MEM_ADR_SIZE-1:0]) &&\n                    (wptr_next[FIFO_TX_MEM_ADR_SIZE] != rptr_gray_sync[FIFO_TX_MEM_ADR_SIZE]);\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            empty <= 1;\n            rptr_gray_sync <= 0;\n        end else begin\n            rptr_gray_sync <= rptr_gray;\n            empty <= (wptr_gray_sync == rptr_gray);\n        end\n    end\n\n    // FIFO occupancy update\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 0;\n        end else begin\n            mem_empt <= wptr_next[FIFO_TX_MEM_ADR_SIZE-1:0] - rptr_next[FIFO_TX_MEM_ADR_SIZE-1:0];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 4, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter SD_BUS_W = 4;\n    parameter BIT_BLOCK = 512;\n    parameter CRC_OFF = 16;\n    parameter BIT_BLOCK_REC = 512;\n    parameter BIT_CRC_CYCLE = 16;\n    parameter LITTLE_ENDIAN = 0;\n    parameter BIG_ENDIAN = 1;\n    parameter SD_BUS_WIDTH_1 = 1;\n    parameter SD_BUS_WIDTH_4 = 4;\n\n    // CRC_16_gen\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'b000001: next_state = (start_dat == 2'b10) ? 6'b000010 : (start_dat == 2'b01) ? 6'b000100 : 6'b000001;\n            6'b000010: next_state = (transf_cnt >= BIT_BLOCK) ? 6'b001000 : 6'b000010;\n            6'b001000: next_state = (crc_status == 0) ? 6'b010000 : 6'b001000;\n            6'b010000: next_state = (busy_int == 0) ? 6'b000001 : 6'b010000;\n            6'b000100: next_state = (DAT_dat_i[0] == 0) ? 6'b100000 : 6'b000100;\n            6'b100000: next_state = (transf_cnt >= BIT_BLOCK) ? 6'b000001 : 6'b100000;\n            default: next_state = 6'b000001;\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            q_start_bit <= (!DAT_dat_i[0] & (state == 6'b000100)) ? 0 : 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000001;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000001: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                end\n                6'b000010: begin\n                    // WRITE_DAT logic\n                end\n                6'b001000: begin\n                    // WRITE_CRC logic\n                end\n                6'b010000: begin\n                    // WRITE_BUSY logic\n                end\n                6'b000100: begin\n                    // READ_WAIT logic\n                end\n                6'b100000: begin\n                    // READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 1, "code": "module sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    parameter FIFO_RX_MEM_DEPTH = 16; // Example depth\n    parameter FIFO_RX_MEM_ADR_SIZE = 4; // Example address size\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [31:0] tmp;\n    reg [2:0] byte_count;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            byte_count <= 0;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            byte_count <= byte_count + 1;\n            if (byte_count == 3) begin\n                ram[adr_i] <= {tmp[27:0], d};\n                adr_i <= adr_i + 1;\n                byte_count <= 0;\n                if (adr_i + 1 == adr_o) full <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i) empty <= 1;\n            full <= 0;\n        end\n    end\n\n    always @(*) begin\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            empty <= 1;\n            full <= 0;\n        end else begin\n            if (adr_i == adr_o) begin\n                empty <= 1;\n                full <= 0;\n            end else begin\n                empty <= 0;\n                full <= (adr_i + 1 == adr_o);\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 5, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1, sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'b000000: // IDLE\n                if (start_dat == 2'b10)\n                    next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b01)\n                    next_state = 6'b000100; // READ_WAIT\n                else\n                    next_state = 6'b000000; // IDLE\n            6'b000001: // WRITE_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000010; // WRITE_CRC\n                else\n                    next_state = 6'b000001; // WRITE_DAT\n            6'b000010: // WRITE_CRC\n                if (crc_status == 0)\n                    next_state = 6'b000011; // WRITE_BUSY\n                else\n                    next_state = 6'b000010; // WRITE_CRC\n            6'b000011: // WRITE_BUSY\n                if (!busy_int)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000011; // WRITE_BUSY\n            6'b000100: // READ_WAIT\n                if (DAR_dat_i[0] == 0)\n                    next_state = 6'b000101; // READ_DAT\n                else\n                    next_state = 6'b000100; // READ_WAIT\n            6'b000101: // READ_DAT\n                if (transf_cnt >= BIT_BLOCK_REC)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000101; // READ_DAT\n            default:\n                next_state = 6'b000000; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else if (!DAR_dat_i[0] && state == 6'b000100) begin\n            q_start_bit <= 0;\n        end else begin\n            q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                end\n                6'b000001: begin // WRITE_DAT\n                    if (transf_cnt < BIT_BLOCK) begin\n                        if (transf_cnt[4:0] == 0) begin\n                            if (out_buff_ptr == 0) begin\n                                sd_data_out <= write_buf_0;\n                                out_buff_ptr <= 1;\n                            end else begin\n                                sd_data_out <= write_buf_1;\n                                out_buff_ptr <= 0;\n                            end\n                        end\n                        last_din <= sd_data_out[31:28];\n                        crc_in <= sd_data_out[31:28];\n                        DAT_dat_o <= last_din;\n                        sd_data_out <= {sd_data_out[27:0], 4'b0};\n                        transf_cnt <= transf_cnt + 4;\n                        crc_en <= 1;\n                    end else begin\n                        crc_en <= 0;\n                    end\n                end\n                6'b000010: begin // WRITE_CRC\n                    crc_en <= 0;\n                    if (crc_c < 5) begin\n                        crc_s <= crc_out[crc_c*16 +: 3];\n                        crc_c <= crc_c + 1;\n                    end else begin\n                        crc_status <= crc_s;\n                        crc_c <= 0;\n                    end\n                end\n                6'b000011: begin // WRITE_BUSY\n                    if (!busy_int) begin\n                        transm_complete <= 1;\n                        crc_ok <= (crc_status == 0);\n                    end\n                end\n                6'b000100: begin // READ_WAIT\n                    crc_rst <= 0;\n                    crc_en <= 1;\n                    DAT_oe_o <= 0;\n                    transf_cnt <= 0;\n                    busy_n <= 0;\n                end\n                6'b000101: begin // READ_DAT\n                    if (transf_cnt < BIT_BLOCK_REC) begin\n                        data_out <= DAR_dat_i;\n                        crc_in <= DAR_dat_i;\n                        transf_cnt <= transf_cnt + SD_BUS_W;\n                        we <= 1;\n                    end else begin\n                        we <= 0;\n                        crc_en <= 0;\n                        crc_ok <= (crc_out == DAR_dat_i);\n                        transm_complete <= 1;\n                        busy_n <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 1, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state = IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                            if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                            if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                            if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                            if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) rec_failed <= 1;\n                        else if (card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) rec_done <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) trans_done <= 1;\n                    if (rx_cycle && !rx_full) trans_done <= 1;\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end else if (!crc_ok) trans_failed <= 1;\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 2, "code": "module sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    parameter FIFO_RX_MEM_DEPTH = 16;\n    parameter FIFO_RX_MEM_ADR_SIZE = 4;\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [31:0] tmp;\n    reg [2:0] byte_count;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            byte_count <= 0;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            byte_count <= byte_count + 1;\n            if (byte_count == 3) begin\n                ram[adr_i] <= {tmp[27:0], d};\n                adr_i <= adr_i + 1;\n                byte_count <= 0;\n                if (adr_i + 1 == adr_o)\n                    full <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i)\n                empty <= 1;\n            full <= 0;\n        end\n    end\n\n    always @(*) begin\n        mem_empt = adr_i - adr_o;\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            empty <= 1;\n            full <= 0;\n        end else begin\n            if (adr_i == adr_o)\n                empty <= 1;\n            else\n                empty <= 0;\n            if ((adr_i + 1) == adr_o)\n                full <= 1;\n            else\n                full <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] bit_count;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n            bit_count <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            bit_count <= bit_count + 1;\n            if (bit_count == 7) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                bit_count <= 0;\n                if (adr_i + 1 == adr_o) full <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i) empty <= 1;\n        end\n    end\n\n    always @(*) begin\n        if (adr_i == adr_o) begin\n            empty = 1;\n            full = 0;\n        end else if (adr_i + 1 == adr_o) begin\n            full = 1;\n            empty = 0;\n        end else begin\n            full = 0;\n            empty = 0;\n        end\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00, REQUEST = 2'b01, WRITE_FIFO = 2'b10, DELAY = 2'b11;\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 9'b0;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n        end else begin\n            state <= next_state;\n            if (state == DELAY) delay <= 1'b0;\n            if (state == WRITE_FIFO && m_wb_ack_i) ackd <= ~ackd;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        wr_tx = 1'b0;\n        reset_tx_fifo = 1'b0;\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end\n            end\n            WRITE_FIFO: begin\n                if (!m_wb_ack_i) begin\n                    next_state = DELAY;\n                    wr_tx = 1'b1;\n                    din = m_wb_dat_i;\n                end\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    delay = 1'b1;\n                end\n            end\n        endcase\n    end\n\n    // Wishbone signals\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (state == REQUEST) begin\n            m_wb_adr_o <= adr + {23'b0, offset};\n            m_wb_cyc_o <= 1'b1;\n            m_wb_stb_o <= 1'b1;\n            m_wb_we_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (state == WRITE_FIFO && m_wb_ack_i) begin\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH-1)\n                adr_i <= 0;\n        end\n        full <= (wptr[FIFO_TX_MEM_ADR_SIZE-1:0] == rptr[FIFO_TX_MEM_ADR_SIZE-1:0]) && \n                (wptr[FIFO_TX_MEM_ADR_SIZE] != rptr[FIFO_TX_MEM_ADR_SIZE]);\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr + 1;\n            if (adr_o == FIFO_TX_MEM_DEPTH-1)\n                adr_o <= 0;\n        end\n        empty <= (wptr == rptr);\n    end\n\n    always @(*) begin\n        mem_empt = wptr - rptr;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_rclk, rptr_gray_wclk;\n\n    // Write Clock Domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n            wptr_gray <= 0;\n            full <= 0;\n        end else begin\n            if (wr && !full) begin\n                ram[adr_i] <= d;\n                adr_i <= adr_i + 1;\n                wptr <= wptr + 1;\n                wptr_gray <= (wptr + 1) ^ ((wptr + 1) >> 1);\n            end\n            full <= (wptr_gray == {~rptr_gray_wclk[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray_wclk[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        end\n    end\n\n    // Read Clock Domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n            rptr_gray <= 0;\n            empty <= 1;\n        end else begin\n            if (rd && !empty) begin\n                q <= ram[adr_o];\n                adr_o <= adr_o + 1;\n                rptr <= rptr + 1;\n                rptr_gray <= (rptr + 1) ^ ((rptr + 1) >> 1);\n            end\n            empty <= (rptr_gray == wptr_gray_rclk);\n        end\n    end\n\n    // Cross Clock Domain Synchronization\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            wptr_gray_rclk <= 0;\n        end else begin\n            wptr_gray_rclk <= wptr_gray;\n        end\n    end\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            rptr_gray_wclk <= 0;\n        end else begin\n            rptr_gray_wclk <= rptr_gray;\n        end\n    end\n\n    // FIFO Occupancy Calculation\n    always @(*) begin\n        mem_empt = wptr - rptr;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 6, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 0)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                    crc_ok <= 0;\n                end\n                WRITE_DAT: begin\n                    // Implement WRITE_DAT logic\n                end\n                WRITE_CRC: begin\n                    // Implement WRITE_CRC logic\n                end\n                WRITE_BUSY: begin\n                    // Implement WRITE_BUSY logic\n                end\n                READ_WAIT: begin\n                    // Implement READ_WAIT logic\n                end\n                READ_DAT: begin\n                    // Implement READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 7, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter SD_BUS_W = 4;\n    parameter BIT_BLOCK = 512;\n    parameter CRC_OFF = 16;\n    parameter BIT_BLOCK_REC = 512;\n    parameter BIT_CRC_CYCLE = 16;\n    parameter LITLE_ENDIAN = 0;\n    parameter BIG_ENDIAN = 1;\n    parameter SD_BUS_WIDTH_1 = 1;\n    parameter SD_BUS_WIDTH_4 = 4;\n\n    // CRC_16_gen submodule\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'b000000: begin // IDLE\n                if (start_dat == 2'b10)\n                    next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b01)\n                    next_state = 6'b000010; // READ_WAIT\n                else\n                    next_state = 6'b000000; // IDLE\n            end\n            6'b000001: begin // WRITE_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000011; // WRITE_CRC\n                else\n                    next_state = 6'b000001; // WRITE_DAT\n            end\n            6'b000011: begin // WRITE_CRC\n                if (crc_status == 0)\n                    next_state = 6'b000100; // WRITE_BUSY\n                else\n                    next_state = 6'b000011; // WRITE_CRC\n            end\n            6'b000100: begin // WRITE_BUSY\n                if (busy_int == 0)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000100; // WRITE_BUSY\n            end\n            6'b000010: begin // READ_WAIT\n                if (DAR_dat_i[0] == 0)\n                    next_state = 6'b000101; // READ_DAT\n                else\n                    next_state = 6'b000010; // READ_WAIT\n            end\n            6'b000101: begin // READ_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000101; // READ_DAT\n            end\n            default: next_state = 6'b000000; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else if (!DAR_dat_i[0] && state == 6'b000010) begin\n            q_start_bit <= 0;\n        end else begin\n            q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    crc_ok <= 0;\n                    transm_complete <= 0;\n                end\n                6'b000001: begin // WRITE_DAT\n                    if (transf_cnt < BIT_BLOCK) begin\n                        if (transf_cnt[4:0] == 0) begin\n                            if (out_buff_ptr == 0) begin\n                                sd_data_out <= write_buf_0;\n                                out_buff_ptr <= 1;\n                            end else begin\n                                sd_data_out <= write_buf_1;\n                                out_buff_ptr <= 0;\n                            end\n                        end\n                        last_din <= sd_data_out[31:28];\n                        crc_in <= sd_data_out[31:28];\n                        DAT_dat_o <= last_din;\n                        sd_data_out <= {sd_data_out[27:0], 4'b0};\n                        transf_cnt <= transf_cnt + 4;\n                        crc_en <= 1;\n                    end\n                end\n                6'b000011: begin // WRITE_CRC\n                    crc_en <= 0;\n                    crc_rst <= 0;\n                    crc_status <= crc_out[15:0] == 16'h0 ? 0 : 1;\n                end\n                6'b000100: begin // WRITE_BUSY\n                    transm_complete <= 1;\n                    crc_ok <= (crc_s == 3'b010);\n                    busy_int <= DAR_dat_i[0];\n                end\n                6'b000010: begin // READ_WAIT\n                    crc_rst <= 0;\n                    crc_en <= 1;\n                    DAT_oe_o <= 0;\n                    transf_cnt <= 0;\n                end\n                6'b000101: begin // READ_DAT\n                    if (transf_cnt < BIT_BLOCK) begin\n                        data_out <= DAR_dat_i;\n                        crc_in <= DAR_dat_i;\n                        transf_cnt <= transf_cnt + SD_BUS_W;\n                        we <= 1;\n                    end else begin\n                        we <= 0;\n                        crc_ok <= (crc_out[15:0] == 16'h0);\n                        transm_complete <= 1;\n                        busy_n <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 4, "code": "module sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    `include \"sd_defines.v\"\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[0]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i == adr_o - 1) begin\n                full <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i - 1) begin\n                empty <= 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        if (adr_i == adr_o) begin\n            empty = 1;\n            full = 0;\n        end else if (adr_i == adr_o - 1) begin\n            full = 1;\n            empty = 0;\n        end else begin\n            full = 0;\n            empty = 0;\n        end\n        mem_empt = (adr_i - adr_o) >> 5;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    // Parameters\n    parameter FIFO_TX_MEM_DEPTH = 64;\n    parameter FIFO_TX_MEM_ADR_SIZE = 6;\n\n    // Registers\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] fifo_count;\n\n    // Write Operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            fifo_count <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            fifo_count <= fifo_count + 1;\n        end\n    end\n\n    // Read Operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            fifo_count <= fifo_count - 1;\n        end\n    end\n\n    // Status Flags\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n            mem_empt <= 0;\n        end else begin\n            full <= (fifo_count == FIFO_TX_MEM_DEPTH);\n            empty <= (fifo_count == 0);\n            mem_empt <= fifo_count[FIFO_TX_MEM_ADR_SIZE-1:0];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] state, next_state;\n\n    localparam IDLE = 3'b000, WRITING = 3'b001, READING = 3'b010;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[0]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i + 1 == adr_o) full <= 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i) empty <= 1;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 2'b11;\n        end else begin\n            mem_empt <= (adr_i - adr_o) >> 5;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (wr && !full) next_state = WRITING;\n                else if (rd && !empty) next_state = READING;\n                else next_state = IDLE;\n            end\n            WRITING: begin\n                if (!wr || full) next_state = IDLE;\n                else next_state = WRITING;\n            end\n            READING: begin\n                if (!rd || empty) next_state = IDLE;\n                else next_state = READING;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State machine states\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        REQUEST = 2'b01,\n        WRITE_FIFO = 2'b10,\n        DELAY = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic and state actions\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    if (delay) begin\n                        offset <= offset + 1;\n                        ackd <= ~ackd;\n                        wr_tx <= 1'b0;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00, REQUEST = 2'b01, WRITE_FIFO = 2'b10, DELAY = 2'b11;\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // Output and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            offset <= 9'b0;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end else begin\n                        reset_tx_fifo <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    offset <= offset + 1;\n                    ackd <= ~ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] state, next_state;\n\n    localparam IDLE = 3'b000;\n    localparam WRITING = 3'b001;\n    localparam READING = 3'b010;\n\n    // State transition\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (wr && !full) begin\n                    next_state = WRITING;\n                end else if (rd && !empty) begin\n                    next_state = READING;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITING: begin\n                if (wr && !full) begin\n                    next_state = WRITING;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            READING: begin\n                if (rd && !empty) begin\n                    next_state = READING;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            ft <= ft + 1;\n            if (ft == 7) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 0;\n            end\n            if (adr_i == adr_o - 1) begin\n                full <= 1;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i) begin\n                empty <= 1;\n            end\n        end\n    end\n\n    // Full and empty flags\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else begin\n            full <= (adr_i == adr_o - 1);\n            empty <= (adr_o == adr_i);\n        end\n    end\n\n    // Memory empty space\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 2'b11;\n        end else begin\n            mem_empt <= (adr_i > adr_o) ? (adr_i - adr_o) : (FIFO_RX_MEM_DEPTH - (adr_o - adr_i));\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo u_sd_rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            state <= next_state;\n            if (state == WRITE && m_wb_ack_i) begin\n                offset <= offset + `MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    rd = 1'b1;\n                    next_state = READ;\n                end else begin\n                    reset_rx_fifo = 1'b1;\n                end\n            end\n            READ: begin\n                if (rd) begin\n                    m_wb_dat_o = dat_o;\n                    m_wb_adr_o = adr + offset;\n                    m_wb_we_o = 1'b1;\n                    m_wb_cyc_o = 1'b1;\n                    m_wb_stb_o = 1'b1;\n                    wb_free = 1'b0;\n                    next_state = WRITE;\n                end\n            end\n            WRITE: begin\n                if (m_wb_ack_i) begin\n                    m_wb_we_o = 1'b0;\n                    m_wb_cyc_o = 1'b0;\n                    m_wb_stb_o = 1'b0;\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + {offset, 2'b00};\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + `MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00, REQUEST = 2'b01, WRITE_FIFO = 2'b10, DELAY = 2'b11;\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output and internal signals logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end else begin\n                        reset_tx_fifo <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    if (delay) begin\n                        offset <= offset + 1'b1;\n                        ackd <= ~ackd;\n                        wr_tx <= 1'b0;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 7, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    `include \"sd_defines.v\"\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] state, next_state;\n\n    localparam IDLE = 3'b000;\n    localparam WRITING = 3'b001;\n    localparam READING = 3'b010;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n            state <= IDLE;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (wr && !full) begin\n                        tmp <= {tmp[27:0], d};\n                        ft <= 1;\n                        if (ft) begin\n                            ram[adr_i] <= {tmp[27:0], d};\n                            adr_i <= adr_i + 1;\n                            if (adr_i + 1 == adr_o)\n                                full <= 1;\n                        end\n                        state <= WRITING;\n                    end\n                end\n                WRITING: begin\n                    if (wr && !full) begin\n                        tmp <= {tmp[27:0], d};\n                        ft <= 1;\n                        if (ft) begin\n                            ram[adr_i] <= {tmp[27:0], d};\n                            adr_i <= adr_i + 1;\n                            if (adr_i + 1 == adr_o)\n                                full <= 1;\n                        end\n                    end else begin\n                        state <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n            state <= IDLE;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (rd && !empty) begin\n                        q <= ram[adr_o];\n                        adr_o <= adr_o + 1;\n                        if (adr_o + 1 == adr_i)\n                            empty <= 1;\n                        state <= READING;\n                    end\n                end\n                READING: begin\n                    if (rd && !empty) begin\n                        q <= ram[adr_o];\n                        adr_o <= adr_o + 1;\n                        if (adr_o + 1 == adr_i)\n                            empty <= 1;\n                    end else begin\n                        state <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\n\n    always @(*) begin\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 8, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen instantiation\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'b000000: // IDLE\n                if (start_dat == 2'b10)\n                    next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b01)\n                    next_state = 6'b000010; // READ_WAIT\n                else\n                    next_state = 6'b000000; // IDLE\n            6'b000001: // WRITE_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000011; // WRITE_CRC\n                else\n                    next_state = 6'b000001; // WRITE_DAT\n            6'b000011: // WRITE_CRC\n                if (crc_status == 0)\n                    next_state = 6'b000100; // WRITE_BUSY\n                else\n                    next_state = 6'b000011; // WRITE_CRC\n            6'b000100: // WRITE_BUSY\n                if (busy_int == 0)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000100; // WRITE_BUSY\n            6'b000010: // READ_WAIT\n                if (DAR_dat_i[0] == 0)\n                    next_state = 6'b000101; // READ_DAT\n                else\n                    next_state = 6'b000010; // READ_WAIT\n            6'b000101: // READ_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000101; // READ_DAT\n            default:\n                next_state = 6'b000000; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAR_dat_i[0] && state == 6'b000010)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                end\n                6'b000001: begin // WRITE_DAT\n                    if (transf_cnt < BIT_BLOCK) begin\n                        if (transf_cnt[2:0] == 3'b000) begin\n                            if (out_buff_ptr == 0) begin\n                                sd_data_out <= write_buf_0;\n                                out_buff_ptr <= 1;\n                            end else begin\n                                sd_data_out <= write_buf_1;\n                                out_buff_ptr <= 0;\n                            end\n                        end\n                        last_din <= sd_data_out[31:28];\n                        crc_in <= sd_data_out[31:28];\n                        DAT_dat_o <= last_din;\n                        sd_data_out <= {sd_data_out[27:0], 4'b0};\n                        transf_cnt <= transf_cnt + 1;\n                        crc_en <= 1;\n                    end\n                end\n                6'b000011: begin // WRITE_CRC\n                    crc_en <= 0;\n                    crc_rst <= 0;\n                    crc_status <= crc_out[15:0] == DAR_dat_i ? 0 : 1;\n                end\n                6'b000100: begin // WRITE_BUSY\n                    transm_complete <= 1;\n                    crc_ok <= crc_status == 0;\n                    busy_int <= DAR_dat_i[0];\n                end\n                6'b000010: begin // READ_WAIT\n                    crc_rst <= 0;\n                    crc_en <= 1;\n                    DAT_oe_o <= 0;\n                    transf_cnt <= 0;\n                end\n                6'b000101: begin // READ_DAT\n                    if (transf_cnt < BIT_BLOCK) begin\n                        data_out <= DAR_dat_i;\n                        crc_in <= DAR_dat_i;\n                        transf_cnt <= transf_cnt + 1;\n                        we <= 1;\n                    end else begin\n                        we <= 0;\n                        crc_ok <= crc_out[15:0] == DAR_dat_i;\n                        transm_complete <= 1;\n                        busy_n <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // State encoding\n    localparam IDLE  = 2'b00;\n    localparam READ  = 2'b01;\n    localparam WRITE = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    next_state = READ;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            READ: begin\n                if (m_wb_ack_i && !wb_free) begin\n                    next_state = WRITE;\n                end else begin\n                    next_state = READ;\n                end\n            end\n            WRITE: begin\n                if (rd && m_wb_we_o && m_wb_cyc_o && m_wb_stb_o) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = WRITE;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    rd <= 1'b0;\n                    reset_rx_fifo <= 1'b1;\n                    if (en && !empty && wb_free) begin\n                        rd <= 1'b1;\n                        reset_rx_fifo <= 1'b0;\n                    end\n                end\n                READ: begin\n                    if (m_wb_ack_i && !wb_free) begin\n                        m_wb_adr_o <= adr + offset;\n                        offset <= offset + `MEM_OFFSET;\n                        wb_free <= 1'b1;\n                    end\n                end\n                WRITE: begin\n                    if (rd && m_wb_we_o && m_wb_cyc_o && m_wb_stb_o) begin\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        wb_free <= 1'b1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 2, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY)\n                    next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY)\n                    next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1)\n                    next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1)\n                    next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done)\n                    next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done)\n                    next_state = DATA_TRANSFER;\n                else if (rec_failed)\n                    next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done)\n                    next_state = IDLE;\n                else if (trans_failed)\n                    next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0)\n                                sys_adr <= dat_in_tx;\n                            else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0)\n                                sys_adr[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 1)\n                                sys_adr[31:16] <= dat_in_tx;\n                            else if (bd_cnt == 2)\n                                cmd_arg[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0)\n                                sys_adr <= dat_in_rx;\n                            else if (bd_cnt == 1)\n                                cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0)\n                                sys_adr[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 1)\n                                sys_adr[31:16] <= dat_in_rx;\n                            else if (bd_cnt == 2)\n                                cmd_arg[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 3)\n                                cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle)\n                        d_write <= 1;\n                    else if (rx_cycle)\n                        d_read <= 1;\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                            we_req <= 0;\n                        end\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle)\n                        start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt)\n                        trans_done <= 1;\n                    else if (rx_cycle && !rx_full)\n                        trans_done <= 1;\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        if (tx_cycle)\n                            a_cmp_tx <= 1;\n                        else if (rx_cycle)\n                            a_cmp_rx <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT)\n                        Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                            we_req <= 0;\n                        end\n                    end\n                end\n            endcase\n            if (Dat_Int_Status_rst)\n                Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 1, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // Card Detect\n    input wire card_detect,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg)\n);\n\nsd_clock_divider sd_clock_divider_inst (\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\n// Additional sub-modules would be instantiated here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    if (en && !empty && wb_free) begin\n                        rd <= 1'b1;\n                        reset_rx_fifo <= 1'b0;\n                    end else begin\n                        rd <= 1'b0;\n                        reset_rx_fifo <= 1'b1;\n                    end\n                end\n                READ: begin\n                    if (rd && wb_free) begin\n                        m_wb_dat_o <= dat_o;\n                        m_wb_we_o <= 1'b1;\n                        m_wb_cyc_o <= 1'b1;\n                        m_wb_stb_o <= 1'b1;\n                        wb_free <= 1'b0;\n                    end\n                end\n                WRITE: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        offset <= offset + `MEM_OFFSET;\n                        wb_free <= 1'b1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    next_state = READ;\n                end\n            end\n            READ: begin\n                if (rd && wb_free) begin\n                    next_state = WRITE;\n                end\n            end\n            WRITE: begin\n                if (m_wb_ack_i) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] state, next_state;\n\n    localparam IDLE = 3'b000,\n               WRITING = 3'b001,\n               READING = 3'b010;\n\n    // Asynchronous reset\n    always @(posedge rst or posedge wclk) begin\n        if (rst) begin\n            adr_i <= 0;\n            adr_o <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n            empty <= 1;\n            mem_empt <= 2'b11;\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // State transition\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (wr && !full) begin\n                    next_state = WRITING;\n                end else if (rd && !empty) begin\n                    next_state = READING;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITING: begin\n                if (wr && !full) begin\n                    next_state = WRITING;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            READING: begin\n                if (rd && !empty) begin\n                    next_state = READING;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Write operation\n    always @(posedge wclk) begin\n        if (state == WRITING) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], 1'b1};\n            if (we == 8'h80) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                we <= 8'h1;\n                if (adr_i + 1 == adr_o) begin\n                    full <= 1;\n                end\n                empty <= 0;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk) begin\n        if (state == READING) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i) begin\n                empty <= 1;\n            end\n            full <= 0;\n        end\n    end\n\n    // Memory empty space calculation\n    always @(*) begin\n        if (adr_i >= adr_o) begin\n            mem_empt = FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\n        end else begin\n            mem_empt = adr_o - adr_i;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 3, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done;\n    reg rec_done;\n    reg rec_failed;\n    reg tx_cycle;\n    reg rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done;\n    reg trans_failed;\n    reg internal_transm_complete;\n    reg transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state = IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    CIDAT <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] == 1) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] bit_count;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            bit_count <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            bit_count <= bit_count + 1;\n            if (bit_count == 7) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                bit_count <= 0;\n                if (adr_i + 1 == adr_o) full <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i) empty <= 1;\n            full <= 0;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 2'b11;\n        end else begin\n            mem_empt <= (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 9, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen\n    genvar i;\n    generate\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'b000000: begin // IDLE\n                if (start_dat == 2'b10)\n                    next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b01)\n                    next_state = 6'b000100; // READ_WAIT\n                else\n                    next_state = 6'b000000; // IDLE\n            end\n            6'b000001: begin // WRITE_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000010; // WRITE_CRC\n                else\n                    next_state = 6'b000001; // WRITE_DAT\n            end\n            6'b000010: begin // WRITE_CRC\n                if (crc_status == 0)\n                    next_state = 6'b000011; // WRITE_BUSY\n                else\n                    next_state = 6'b000010; // WRITE_CRC\n            end\n            6'b000011: begin // WRITE_BUSY\n                if (!busy_int)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000011; // WRITE_BUSY\n            end\n            6'b000100: begin // READ_WAIT\n                if (DAT_dat_i[0] == 0)\n                    next_state = 6'b000101; // READ_DAT\n                else\n                    next_state = 6'b000100; // READ_WAIT\n            end\n            6'b000101: begin // READ_DAT\n                if (transf_cnt >= BIT_BLOCK_REC)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000101; // READ_DAT\n            end\n            default: next_state = 6'b000000; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == 6'b000100)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    crc_c <= 0;\n                    crc_in <= 0;\n                    DAT_dat_o <= 0;\n                    crc_status <= 3'b111;\n                    crc_s <= 0;\n                    transm_complete <= 0;\n                    busy_n <= 1;\n                    we <= 0;\n                    data_out <= 0;\n                    crc_ok <= 0;\n                    busy_int <= 0;\n                    data_send_index <= 0;\n                    out_buff_ptr <= 0;\n                    in_buff_ptr <= 0;\n                end\n                6'b000001: begin // WRITE_DAT\n                    if (transf_cnt < BIT_BLOCK) begin\n                        if (out_buff_ptr == 0) begin\n                            sd_data_out <= write_buf_0;\n                            out_buff_ptr <= 1;\n                        end else begin\n                            sd_data_out <= write_buf_1;\n                            out_buff_ptr <= 0;\n                        end\n                        last_din <= sd_data_out[31:28];\n                        crc_in <= sd_data_out[31:28];\n                        DAT_dat_o <= last_din;\n                        transf_cnt <= transf_cnt + 4;\n                    end\n                end\n                6'b000010: begin // WRITE_CRC\n                    crc_en <= 1;\n                    crc_rst <= 0;\n                    crc_status <= crc_out[15:0] == DAT_dat_i ? 0 : 1;\n                end\n                6'b000011: begin // WRITE_BUSY\n                    transm_complete <= 1;\n                    crc_ok <= (crc_status == 0);\n                    busy_int <= DAT_dat_i[0];\n                end\n                6'b000100: begin // READ_WAIT\n                    crc_en <= 1;\n                    crc_rst <= 0;\n                    DAT_oe_o <= 0;\n                    busy_int <= 1;\n                end\n                6'b000101: begin // READ_DAT\n                    data_out <= DAT_dat_i;\n                    crc_in <= DAT_dat_i;\n                    transf_cnt <= transf_cnt + 1;\n                    if (transf_cnt >= BIT_BLOCK_REC) begin\n                        crc_ok <= (crc_out[15:0] == DAT_dat_i);\n                        transm_complete <= 1;\n                        busy_n <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            state <= next_state;\n            if (state == WRITE && m_wb_ack_i) begin\n                offset <= offset + `MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    rd = 1'b1;\n                    next_state = READ;\n                end else begin\n                    rd = 1'b0;\n                    reset_rx_fifo = 1'b1;\n                end\n            end\n            READ: begin\n                if (rd) begin\n                    m_wb_adr_o = adr + offset;\n                    m_wb_dat_o = dat_o;\n                    m_wb_we_o = 1'b1;\n                    m_wb_cyc_o = 1'b1;\n                    m_wb_stb_o = 1'b1;\n                    wb_free = 1'b0;\n                    next_state = WRITE;\n                end\n            end\n            WRITE: begin\n                if (m_wb_ack_i) begin\n                    m_wb_we_o = 1'b0;\n                    m_wb_cyc_o = 1'b0;\n                    m_wb_stb_o = 1'b0;\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 2, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Other sub-modules instantiation and connections go here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            state <= next_state;\n            if (state == WRITE && m_wb_ack_i) begin\n                offset <= offset + `MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    rd = 1'b1;\n                    next_state = READ;\n                end else begin\n                    rd = 1'b0;\n                    reset_rx_fifo = 1'b1;\n                end\n            end\n            READ: begin\n                if (rd) begin\n                    m_wb_dat_o = dat_o;\n                    m_wb_we_o = 1'b1;\n                    m_wb_cyc_o = 1'b1;\n                    m_wb_stb_o = 1'b1;\n                    m_wb_adr_o = adr + offset;\n                    wb_free = 1'b0;\n                    next_state = WRITE;\n                end\n            end\n            WRITE: begin\n                if (m_wb_ack_i) begin\n                    m_wb_we_o = 1'b0;\n                    m_wb_cyc_o = 1'b0;\n                    m_wb_stb_o = 1'b0;\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 10, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter IDLE = 6'b000001;\n    parameter WRITE_DAT = 6'b000010;\n    parameter WRITE_CRC = 6'b000100;\n    parameter WRITE_BUSY = 6'b001000;\n    parameter READ_WAIT = 6'b010000;\n    parameter READ_DAT = 6'b100000;\n\n    // CRC_16_gen submodule instantiation\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO block\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = WRITE_CRC;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 0)\n                    next_state = WRITE_BUSY;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int && ack_transfer_int)\n                    next_state = IDLE;\n            end\n            READ_WAIT: begin\n                if (!q_start_bit)\n                    next_state = READ_DAT;\n            end\n            READ_DAT: begin\n                if (transf_cnt >= BIT_BLOCK_REC)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // START_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAR_dat_i[0] && state == READ_WAIT)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                end\n                WRITE_DAT: begin\n                    crc_rst <= 0;\n                    crc_en <= 1;\n                    if (transf_cnt < BIT_BLOCK) begin\n                        if (transf_cnt[2:0] == 3'b000) begin\n                            if (out_buff_ptr == 0) begin\n                                sd_data_out <= write_buf_0;\n                                out_buff_ptr <= 1;\n                            end else begin\n                                sd_data_out <= write_buf_1;\n                                out_buff_ptr <= 0;\n                            end\n                        end\n                        last_din <= sd_data_out[31:28];\n                        crc_in <= sd_data_out[31:28];\n                        DAT_dat_o <= last_din;\n                        sd_data_out <= {sd_data_out[27:0], 4'b0};\n                        transf_cnt <= transf_cnt + 4;\n                    end\n                end\n                WRITE_CRC: begin\n                    crc_en <= 0;\n                    crc_rst <= 1;\n                    crc_s <= crc_out[15:13];\n                    if (crc_c < 5) begin\n                        crc_c <= crc_c + 1;\n                    end else begin\n                        crc_c <= 0;\n                        crc_status <= crc_s;\n                    end\n                end\n                WRITE_BUSY: begin\n                    if (!DAR_dat_i[0]) begin\n                        busy_int <= 0;\n                        transm_complete <= 1;\n                        crc_ok <= (crc_status == 3'b010);\n                    end else begin\n                        busy_int <= 1;\n                    end\n                end\n                READ_WAIT: begin\n                    crc_rst <= 0;\n                    crc_en <= 1;\n                    DAT_oe_o <= 0;\n                    transf_cnt <= 0;\n                    busy_n <= 0;\n                end\n                READ_DAT: begin\n                    if (transf_cnt < BIT_BLOCK_REC) begin\n                        data_out <= DAR_dat_i;\n                        crc_in <= DAR_dat_i;\n                        transf_cnt <= transf_cnt + SD_BUS_W;\n                        we <= 1;\n                    end else begin\n                        we <= 0;\n                        if (crc_out[15:0] != DAR_dat_i[15:0])\n                            crc_ok <= 0;\n                        else\n                            crc_ok <= 1;\n                        transm_complete <= 1;\n                        busy_n <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] count;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            if (adr_i + 1 == adr_o)\n                full <= 1;\n            else\n                full <= 0;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i)\n                empty <= 1;\n            else\n                empty <= 0;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            count <= 0;\n            mem_empt <= 0;\n        end else begin\n            count <= adr_i - adr_o;\n            mem_empt <= count[FIFO_TX_MEM_ADR_SIZE-1:0];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 11, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter IDLE = 6'b000001;\n    parameter WRITE_DAT = 6'b000010;\n    parameter WRITE_CRC = 6'b000100;\n    parameter WRITE_BUSY = 6'b001000;\n    parameter READ_WAIT = 6'b010000;\n    parameter READ_DAT = 6'b100000;\n\n    // CRC_16_gen\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10) next_state = WRITE_DAT;\n                else if (start_dat == 2'b01) next_state = READ_WAIT;\n                else next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt >= BIT_BLOCK) next_state = WRITE_CRC;\n                else next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 0) next_state = WRITE_BUSY;\n                else next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0) next_state = IDLE;\n                else next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (q_start_bit == 0) next_state = READ_DAT;\n                else next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt >= BIT_BLOCK_REC) next_state = IDLE;\n                else next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAR_dat_i[0] && state == READ_WAIT) q_start_bit <= 0;\n            else q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                end\n                WRITE_DAT: begin\n                    if (transf_cnt < BIT_BLOCK) begin\n                        if (out_buff_ptr == 0) begin\n                            sd_data_out <= write_buf_0;\n                        end else begin\n                            sd_data_out <= write_buf_1;\n                        end\n                        DAT_oe_o <= 1;\n                        crc_rst <= 0;\n                        crc_en <= 1;\n                        crc_in <= sd_data_out[31:28];\n                        last_din <= sd_data_out[31:28];\n                        DAT_dat_o <= last_din;\n                        transf_cnt <= transf_cnt + 4;\n                        if (transf_cnt[4:0] == 28) begin\n                            out_buff_ptr <= ~out_buff_ptr;\n                        end\n                    end\n                end\n                WRITE_CRC: begin\n                    crc_en <= 0;\n                    crc_rst <= 0;\n                    crc_s <= crc_out[15:13];\n                    if (crc_c < 7) begin\n                        crc_c <= crc_c + 1;\n                    end else begin\n                        crc_status <= crc_s;\n                    end\n                end\n                WRITE_BUSY: begin\n                    if (crc_status == 0) crc_ok <= 1;\n                    else crc_ok <= 0;\n                    if (!DAR_dat_i[0]) busy_int <= 0;\n                    else busy_int <= 1;\n                    if (!busy_int) begin\n                        transm_complete <= 1;\n                        busy_n <= 1;\n                    end\n                end\n                READ_WAIT: begin\n                    crc_rst <= 0;\n                    crc_en <= 1;\n                    DAT_oe_o <= 0;\n                    transf_cnt <= 0;\n                    busy_n <= 0;\n                end\n                READ_DAT: begin\n                    if (transf_cnt < BIT_BLOCK_REC) begin\n                        data_out <= DAR_dat_i;\n                        crc_in <= DAR_dat_i;\n                        transf_cnt <= transf_cnt + SD_BUS_W;\n                        we <= 1;\n                    end else begin\n                        we <= 0;\n                        if (crc_out == DAR_dat_i) crc_ok <= 1;\n                        else crc_ok <= 0;\n                        transm_complete <= 1;\n                        busy_n <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 3, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input wire card_detect\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(),\n    .error_int_status_reg(),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules would be instantiated here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr; // Extra bit for wrap-around detection\n\n    // Write logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH-1)\n                adr_i <= 0;\n        end\n    end\n\n    // Read logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr + 1;\n            if (adr_o == FIFO_TX_MEM_DEPTH-1)\n                adr_o <= 0;\n        end\n    end\n\n    // Status logic\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n            mem_empt <= 0;\n        end else begin\n            full <= (wptr[FIFO_TX_MEM_ADR_SIZE] != rptr[FIFO_TX_MEM_ADR_SIZE]) &&\n                    (wptr[FIFO_TX_MEM_ADR_SIZE-1:0] == rptr[FIFO_TX_MEM_ADR_SIZE-1:0]);\n            empty <= (wptr == rptr);\n            mem_empt <= wptr - rptr;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:`FIFO_RX_MEM_DEPTH-1];\n    reg [`FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [`FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] state, next_state;\n\n    localparam IDLE = 3'b000;\n    localparam WRITING = 3'b001;\n    localparam READING = 3'b010;\n\n    // State transition\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (wr && !full) begin\n                    next_state = WRITING;\n                end else if (rd && !empty) begin\n                    next_state = READING;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITING: begin\n                if (wr && !full) begin\n                    next_state = WRITING;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            READING: begin\n                if (rd && !empty) begin\n                    next_state = READING;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n            we <= 8'h1;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            ft <= ft + 1;\n            if (ft == 7) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 0;\n            end\n            if (adr_i == adr_o - 1) begin\n                full <= 1;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i - 1) begin\n                empty <= 1;\n            end\n        end\n    end\n\n    // Full and empty flags\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else begin\n            full <= (adr_i == adr_o - 1);\n            empty <= (adr_o == adr_i);\n        end\n    end\n\n    // Memory empty space\n    always @(*) begin\n        mem_empt = (adr_i - adr_o) >> 2;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 4, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg send_done;\n    reg rec_done;\n    reg rec_failed;\n    reg tx_cycle;\n    reg rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done;\n    reg trans_failed;\n    reg internal_transm_complete;\n    reg transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != `BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != `BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > `READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= `READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state = IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (`RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                            if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                            if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (`RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                            if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                            if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) rec_failed <= 1;\n                        else if (card_status[0] == 1 || card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6) rec_done <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && tx_empt) trans_failed <= 1;\n                    if (rx_cycle && rx_full) trans_failed <= 1;\n                    if (transm_complete) begin\n                        if (crc_ok) trans_done <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output reg empty,\n    output reg fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00, REQUEST = 2'b01, WRITE_FIFO = 2'b10, DELAY = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            dat_o <= 32'b0;\n            empty <= 1'b1;\n            fe <= 1'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            first <= 1'b0;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                end\n                WRITE_FIFO: begin\n                    wr_tx <= 1'b1;\n                    din <= m_wb_dat_i;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    if (delay) begin\n                        offset <= offset + 1;\n                        ackd <= ~ackd;\n                        wr_tx <= 1'b0;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // FIFO instantiation\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00,\n               REQUEST = 2'b01,\n               WRITE_FIFO = 2'b10,\n               DELAY = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic and state actions\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end else begin\n                        reset_tx_fifo <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    if (delay) begin\n                        offset <= offset + 1;\n                        ackd <= ~ackd;\n                        wr_tx <= 1'b0;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr + 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr + 1;\n        end\n    end\n\n    always @(*) begin\n        full = (wptr[FIFO_TX_MEM_ADR_SIZE-1:0] == rptr[FIFO_TX_MEM_ADR_SIZE-1:0]) && \n               (wptr[FIFO_TX_MEM_ADR_SIZE] != rptr[FIFO_TX_MEM_ADR_SIZE]);\n        empty = (wptr == rptr);\n        mem_empt = wptr - rptr;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            state <= next_state;\n            if (state == WRITE && m_wb_ack_i) begin\n                offset <= offset + `MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        reset_rx_fifo = 1'b0;\n        rd = 1'b0;\n        m_wb_we_o = 1'b0;\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    next_state = READ;\n                    rd = 1'b1;\n                end else if (!en) begin\n                    reset_rx_fifo = 1'b1;\n                end\n            end\n\n            READ: begin\n                if (rd && wb_free) begin\n                    next_state = WRITE;\n                    m_wb_adr_o = adr + offset;\n                    m_wb_dat_o = dat_o;\n                    m_wb_we_o = 1'b1;\n                    m_wb_cyc_o = 1'b1;\n                    m_wb_stb_o = 1'b1;\n                    wb_free = 1'b0;\n                end\n            end\n\n            WRITE: begin\n                if (m_wb_ack_i) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            if (en) begin\n                reset_rx_fifo <= 1'b0;\n                if (!empty && wb_free) begin\n                    rd <= 1'b1;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1'b1;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    wb_free <= 1'b0;\n                end else if (m_wb_ack_i) begin\n                    rd <= 1'b0;\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    offset <= offset + `MEM_OFFSET;\n                    wb_free <= 1'b1;\n                end\n            end else begin\n                reset_rx_fifo <= 1'b1;\n                rd <= 1'b0;\n                offset <= 9'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 12, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'b000000: begin // IDLE\n                if (start_dat == 2'b01)\n                    next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b10)\n                    next_state = 6'b000010; // READ_WAIT\n                else\n                    next_state = 6'b000000; // IDLE\n            end\n            6'b000001: begin // WRITE_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000011; // WRITE_CRC\n                else\n                    next_state = 6'b000001; // WRITE_DAT\n            end\n            6'b000011: begin // WRITE_CRC\n                if (crc_status == 0)\n                    next_state = 6'b000100; // WRITE_BUSY\n                else\n                    next_state = 6'b000011; // WRITE_CRC\n            end\n            6'b000100: begin // WRITE_BUSY\n                if (!busy_int)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000100; // WRITE_BUSY\n            end\n            6'b000010: begin // READ_WAIT\n                if (DAR_dat_i[0] == 0)\n                    next_state = 6'b000101; // READ_DAT\n                else\n                    next_state = 6'b000010; // READ_WAIT\n            end\n            6'b000101: begin // READ_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000101; // READ_DAT\n            end\n            default: next_state = 6'b000000; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAR_dat_i[0] && state == 6'b000010)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                    crc_ok <= 0;\n                end\n                6'b000001: begin // WRITE_DAT\n                    // Implementation of WRITE_DAT state\n                end\n                6'b000011: begin // WRITE_CRC\n                    // Implementation of WRITE_CRC state\n                end\n                6'b000100: begin // WRITE_BUSY\n                    // Implementation of WRITE_BUSY state\n                end\n                6'b000010: begin // READ_WAIT\n                    // Implementation of READ_WAIT state\n                end\n                6'b000101: begin // READ_DAT\n                    // Implementation of READ_DAT state\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 32'b0;\n            ft <= 1'b0;\n            full <= 1'b0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[0]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1'b1;\n            end\n            if (adr_i + 1 == adr_o) begin\n                full <= 1'b1;\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 32'b0;\n            empty <= 1'b1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i) begin\n                empty <= 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        if (adr_i == adr_o) begin\n            empty = 1'b1;\n        end else begin\n            empty = 1'b0;\n        end\n        if (adr_i + 1 == adr_o) begin\n            full = 1'b1;\n        end else begin\n            full = 1'b0;\n        end\n        mem_empt = (adr_i >= adr_o) ? (adr_i - adr_o) : (FIFO_RX_MEM_DEPTH - adr_o + adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // State encoding\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    // RX FIFO instance\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    next_state = READ;\n                end\n            end\n            READ: begin\n                if (rd && wb_we_o && m_wb_cyc_o && m_wb_stb_o) begin\n                    next_state = WRITE;\n                end\n            end\n            WRITE: begin\n                if (m_wb_ack_i && !wb_free) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // Output and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    rd <= 1'b0;\n                    reset_rx_fifo <= !en;\n                    if (en && !empty && wb_free) begin\n                        rd <= 1'b1;\n                    end\n                end\n                READ: begin\n                    if (rd && wb_we_o && m_wb_cyc_o && m_wb_stb_o) begin\n                        m_wb_adr_o <= adr + offset;\n                        m_wb_we_o <= 1'b1;\n                        m_wb_cyc_o <= 1'b1;\n                        m_wb_stb_o <= 1'b1;\n                        wb_free <= 1'b0;\n                    end\n                end\n                WRITE: begin\n                    if (m_wb_ack_i && !wb_free) begin\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        offset <= offset + `MEM_OFFSET;\n                        wb_free <= 1'b1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 5, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != 0) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != 0) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else if (RAM_MEM_WIDTH == 16) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else if (RAM_MEM_WIDTH == 16) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) begin\n                            rec_failed <= 1;\n                        end else begin\n                            rec_done <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && tx_empt) begin\n                        trans_failed <= 1;\n                    end else if (rx_cycle && rx_full) begin\n                        trans_failed <= 1;\n                    end\n                    if (transm_complete) begin\n                        if (crc_ok) begin\n                            trans_done <= 1;\n                        end else begin\n                            trans_failed <= 1;\n                        end\n                    end\n                    if (trans_done || trans_failed) begin\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else if (rx_cycle) begin\n                            a_cmp_rx <= 1;\n                        end\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr + 1;\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr + 1;\n        end\n    end\n\n    // Status flags\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n            mem_empt <= 0;\n        end else begin\n            full <= (wptr[FIFO_TX_MEM_ADR_SIZE-1:0] == rptr[FIFO_TX_MEM_ADR_SIZE-1:0]) && (wptr[FIFO_TX_MEM_ADR_SIZE] != rptr[FIFO_TX_MEM_ADR_SIZE]);\n            empty <= (wptr == rptr);\n            mem_empt <= wptr - rptr;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 13, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'b000000: begin // IDLE\n                if (start_dat == 2'b01)\n                    next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b10)\n                    next_state = 6'b000010; // READ_WAIT\n                else\n                    next_state = 6'b000000; // IDLE\n            end\n            6'b000001: begin // WRITE_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000011; // WRITE_CRC\n                else\n                    next_state = 6'b000001; // WRITE_DAT\n            end\n            6'b000011: begin // WRITE_CRC\n                if (crc_status == 0)\n                    next_state = 6'b000100; // WRITE_BUSY\n                else\n                    next_state = 6'b000011; // WRITE_CRC\n            end\n            6'b000100: begin // WRITE_BUSY\n                if (!busy_int)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000100; // WRITE_BUSY\n            end\n            6'b000010: begin // READ_WAIT\n                if (DAT_dat_i[0] == 0)\n                    next_state = 6'b000101; // READ_DAT\n                else\n                    next_state = 6'b000010; // READ_WAIT\n            end\n            6'b000101: begin // READ_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000101; // READ_DAT\n            end\n            default: next_state = 6'b000000; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == 6'b000010)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                end\n                6'b000001: begin // WRITE_DAT\n                    // Implement WRITE_DAT logic here\n                end\n                6'b000011: begin // WRITE_CRC\n                    // Implement WRITE_CRC logic here\n                end\n                6'b000100: begin // WRITE_BUSY\n                    // Implement WRITE_BUSY logic here\n                end\n                6'b000010: begin // READ_WAIT\n                    // Implement READ_WAIT logic here\n                end\n                6'b000101: begin // READ_DAT\n                    // Implement READ_DAT logic here\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr + 1;\n            if (adr_i + 1 == adr_o)\n                full <= 1;\n            else\n                full <= 0;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr + 1;\n            if (adr_o + 1 == adr_i)\n                empty <= 1;\n            else\n                empty <= 0;\n        end\n    end\n\n    always @(*) begin\n        mem_empt = wptr - rptr;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00, REQUEST = 2'b01, WRITE_FIFO = 2'b10, DELAY = 2'b11;\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            offset <= 9'b0;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end else begin\n                        reset_tx_fifo <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    if (delay) begin\n                        offset <= offset + 1;\n                        ackd <= ~ackd;\n                        wr_tx <= 1'b0;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 6, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state = IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    resend_try_cnt <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                            if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                            if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                            if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                            if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) rec_failed <= 1;\n                        else if (card_status[0] == 1 || card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6) rec_done <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && tx_empt) trans_failed <= 1;\n                    if (rx_cycle && rx_full) trans_failed <= 1;\n                    if (transm_complete) begin\n                        if (crc_ok) trans_done <= 1;\n                        else trans_failed <= 1;\n                    end\n                    if (trans_done || trans_failed) begin\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n    wire fifo_full, fifo_empty;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!fifo_empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + {23'd0, offset};\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + `MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 4, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n\n    // Wishbone Master Interface\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_sel_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg m_wb_cti_o,\n    output reg m_wb_bte_o,\n\n    // SDC IO\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output reg sd_cmd_out_o,\n    output reg sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output reg [3:0] sd_dat_out_o,\n    output reg sd_dat_oe_o,\n    output reg sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output reg int_a,\n    output reg int_b,\n    output reg int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules would be instantiated here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 14, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen instance\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'b000000: begin // IDLE\n                if (start_dat == 2'b10)\n                    next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b01)\n                    next_state = 6'b000100; // READ_WAIT\n                else\n                    next_state = 6'b000000; // IDLE\n            end\n            6'b000001: begin // WRITE_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000010; // WRITE_CRC\n                else\n                    next_state = 6'b000001; // WRITE_DAT\n            end\n            6'b000010: begin // WRITE_CRC\n                if (crc_status == 0)\n                    next_state = 6'b000011; // WRITE_BUSY\n                else\n                    next_state = 6'b000010; // WRITE_CRC\n            end\n            6'b000011: begin // WRITE_BUSY\n                if (!busy_int)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000011; // WRITE_BUSY\n            end\n            6'b000100: begin // READ_WAIT\n                if (!DAT_dat_i[0])\n                    next_state = 6'b000101; // READ_DAT\n                else\n                    next_state = 6'b000100; // READ_WAIT\n            end\n            6'b000101: begin // READ_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000101; // READ_DAT\n            end\n            default: next_state = 6'b000000; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == 6'b000100)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                    crc_ok <= 0;\n                end\n                6'b000001: begin // WRITE_DAT\n                    if (transf_cnt < BIT_BLOCK) begin\n                        if (transf_cnt[2:0] == 3'b000) begin\n                            if (out_buff_ptr == 0) begin\n                                sd_data_out <= write_buf_0;\n                                out_buff_ptr <= 1;\n                            end else begin\n                                sd_data_out <= write_buf_1;\n                                out_buff_ptr <= 0;\n                            end\n                        end\n                        last_din <= sd_data_out[31:28];\n                        crc_in <= sd_data_out[31:28];\n                        DAT_dat_o <= last_din;\n                        sd_data_out <= {sd_data_out[27:0], 4'b0};\n                        transf_cnt <= transf_cnt + 4;\n                        crc_en <= 1;\n                    end else begin\n                        crc_rst <= 0;\n                        crc_en <= 0;\n                    end\n                end\n                6'b000010: begin // WRITE_CRC\n                    crc_en <= 0;\n                    crc_rst <= 0;\n                    crc_s <= crc_out[15:13];\n                    crc_status <= crc_s == 3'b010 ? 0 : 1;\n                end\n                6'b000011: begin // WRITE_BUSY\n                    transm_complete <= 1;\n                    crc_ok <= (crc_s == 3'b010);\n                    busy_int <= DAT_dat_i[0];\n                end\n                6'b000100: begin // READ_WAIT\n                    crc_rst <= 0;\n                    crc_en <= 1;\n                    DAT_oe_o <= 0;\n                    busy_int <= 0;\n                end\n                6'b000101: begin // READ_DAT\n                    if (transf_cnt < BIT_BLOCK) begin\n                        data_out <= DAR_dat_i;\n                        crc_in <= DAR_dat_i;\n                        transf_cnt <= transf_cnt + SD_BUS_W;\n                        we <= 1;\n                    end else begin\n                        we <= 0;\n                        crc_en <= 0;\n                        crc_ok <= (crc_out == DAR_dat_i);\n                        transm_complete <= 1;\n                        busy_n <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo u_sd_rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            state <= next_state;\n            if (state == WRITE && m_wb_ack_i) begin\n                offset <= offset + `MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        rd = 1'b0;\n        reset_rx_fifo = 1'b0;\n        m_wb_we_o = 1'b0;\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n        m_wb_dat_o = 32'b0;\n\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    next_state = READ;\n                    rd = 1'b1;\n                end else if (!en) begin\n                    reset_rx_fifo = 1'b1;\n                end\n            end\n\n            READ: begin\n                if (rd) begin\n                    next_state = WRITE;\n                    m_wb_dat_o = dat_o;\n                    m_wb_we_o = 1'b1;\n                    m_wb_cyc_o = 1'b1;\n                    m_wb_stb_o = 1'b1;\n                    wb_free = 1'b0;\n                end\n            end\n\n            WRITE: begin\n                if (m_wb_ack_i) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] state, next_state;\n\n    localparam IDLE = 3'b000, WRITING = 3'b001, READING = 3'b010;\n\n    // State transition\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (wr && !full) next_state = WRITING;\n                else if (rd && !empty) next_state = READING;\n                else next_state = IDLE;\n            end\n            WRITING: begin\n                if (wr && !full) next_state = WRITING;\n                else next_state = IDLE;\n            end\n            READING: begin\n                if (rd && !empty) next_state = READING;\n                else next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            ft <= ft + 1;\n            if (ft == 7) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 0;\n            end\n            if (adr_i == adr_o - 1) full <= 1;\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i) empty <= 1;\n        end\n    end\n\n    // Full and empty flag management\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else begin\n            if (adr_i == adr_o - 1) full <= 1;\n            else full <= 0;\n            if (adr_o == adr_i) empty <= 1;\n            else empty <= 0;\n        end\n    end\n\n    // Memory empty space calculation\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 2'b11;\n        end else begin\n            mem_empt <= (adr_i - adr_o) >> 5;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // State encoding\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    next_state = READ;\n                end\n            end\n            READ: begin\n                if (rd && wb_we_o && m_wb_cyc_o && m_wb_stb_o) begin\n                    next_state = WRITE;\n                end\n            end\n            WRITE: begin\n                if (m_wb_ack_i && !wb_free) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // Output logic and state actions\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    rd <= 1'b0;\n                    reset_rx_fifo <= 1'b1;\n                    if (en && !empty && wb_free) begin\n                        rd <= 1'b1;\n                        reset_rx_fifo <= 1'b0;\n                    end\n                end\n                READ: begin\n                    if (rd && wb_we_o && m_wb_cyc_o && m_wb_stb_o) begin\n                        m_wb_adr_o <= adr + offset;\n                        m_wb_we_o <= 1'b1;\n                        m_wb_cyc_o <= 1'b1;\n                        m_wb_stb_o <= 1'b1;\n                        wb_free <= 1'b0;\n                    end\n                end\n                WRITE: begin\n                    if (m_wb_ack_i && !wb_free) begin\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        offset <= offset + `MEM_OFFSET;\n                        wb_free <= 1'b1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_rclk, rptr_gray_wclk;\n\n    // Write Pointer Management\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            wptr <= 0;\n            wptr_gray <= 0;\n        end else if (wr && !full) begin\n            ram[wptr[FIFO_TX_MEM_ADR_SIZE-1:0]] <= d;\n            wptr <= wptr + 1;\n            wptr_gray <= (wptr + 1) ^ ((wptr + 1) >> 1);\n        end\n    end\n\n    // Read Pointer Management\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            rptr <= 0;\n            rptr_gray <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[rptr[FIFO_TX_MEM_ADR_SIZE-1:0]];\n            rptr <= rptr + 1;\n            rptr_gray <= (rptr + 1) ^ ((rptr + 1) >> 1);\n        end\n    end\n\n    // Synchronize Write Pointer to Read Clock Domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            wptr_gray_rclk <= 0;\n        end else begin\n            wptr_gray_rclk <= wptr_gray;\n        end\n    end\n\n    // Synchronize Read Pointer to Write Clock Domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            rptr_gray_wclk <= 0;\n        end else begin\n            rptr_gray_wclk <= rptr_gray;\n        end\n    end\n\n    // Full and Empty Flag Management\n    always @(*) begin\n        full = (wptr_gray == {~rptr_gray_wclk[FIFO_TX_MEM_ADR_SIZE:FIFO_TX_MEM_ADR_SIZE-1], rptr_gray_wclk[FIFO_TX_MEM_ADR_SIZE-2:0]});\n        empty = (wptr_gray_rclk == rptr_gray);\n    end\n\n    // FIFO Occupancy Calculation\n    always @(*) begin\n        mem_empt = wptr[FIFO_TX_MEM_ADR_SIZE-1:0] - rptr[FIFO_TX_MEM_ADR_SIZE-1:0];\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 7, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? BD_SIZE / 2 : BD_SIZE / 4;\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                            if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                            if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                            if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                            if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0]) rec_done <= 1;\n                        else rec_failed <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && tx_empt) trans_failed <= 1;\n                    if (rx_cycle && rx_full) trans_failed <= 1;\n                    if (transm_complete) begin\n                        if (crc_ok) trans_done <= 1;\n                        else trans_failed <= 1;\n                    end\n                    if (trans_done) begin\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 13, "code": "module sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    // Parameters\n    parameter FIFO_RX_MEM_DEPTH = 256;\n    parameter FIFO_RX_MEM_ADR_SIZE = 8;\n\n    // Registers\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] byte_count;\n\n    // Write Operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            byte_count <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            byte_count <= byte_count + 1;\n            if (byte_count == 3) begin\n                ram[adr_i] <= {tmp[27:0], d};\n                adr_i <= adr_i + 1;\n                byte_count <= 0;\n                ft <= 1;\n            end\n            if (adr_i + 1 == adr_o) full <= 1;\n        end\n    end\n\n    // Read Operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i) empty <= 1;\n        end\n    end\n\n    // Full and Empty Flags\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else begin\n            if (adr_i == adr_o) begin\n                if (ft) full <= 1;\n                else empty <= 1;\n            end else begin\n                full <= 0;\n                empty <= 0;\n            end\n        end\n    end\n\n    // Memory Empty Space\n    always @(*) begin\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 5, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n\n    // Wishbone Master Interface\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_sel_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg m_wb_cti_o,\n    output reg m_wb_bte_o,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output reg sd_cmd_out_o,\n    output reg sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output reg [3:0] sd_dat_out_o,\n    output reg sd_dat_oe_o,\n    output reg sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output reg int_a,\n    output reg int_b,\n    output reg int_c,\n\n    // Optional IO\n    input wire card_detect\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Clock Divider\nsd_clock_divider sd_clock_divider_inst (\n    .CLK(wb_clk_i),\n    .DIVIDER(clock_divider),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\n// SD CMD Master\nsd_cmd_master sd_cmd_master_inst (\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(data_write),\n    .data_read(data_read),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(error_int_status_reg),\n    .NORMAL_INT_REG(normal_int_status_reg),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(cmd_setting_reg),\n    .go_idle_o(go_idle_o),\n    .cmd_out(cmd_out),\n    .req_out(req_out),\n    .ack_out(ack_out),\n    .req_in(req_in),\n    .ack_in(ack_in),\n    .cmd_in(cmd_in),\n    .serial_status(serial_status),\n    .card_detect(card_detect)\n);\n\n// SD CMD Serial Host\nsd_cmd_serial_host sd_cmd_serial_host_inst (\n    .SD_CLK_IN(sd_clk_o_pad),\n    .RST_IN(wb_rst_i),\n    .SETTING_IN(cmd_setting_reg),\n    .CMD_IN(cmd_out),\n    .REQ_IN(req_out),\n    .ACK_IN(ack_out),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(sd_cmd_out_o),\n    .ACK_OUT(ack_out),\n    .REQ_OUT(req_out),\n    .STATUS(serial_status),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t(st_dat_t)\n);\n\n// SD Data Master\nsd_data_master sd_data_master_inst (\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .dat_in_tx(dat_in_m_tx_bd),\n    .free_tx_bd(free_tx_bd),\n    .ack_i_s_tx(ack_i_s_tx),\n    .dat_in_rx(dat_in_m_rx_bd),\n    .free_rx_bd(free_rx_bd),\n    .ack_i_s_rx(ack_i_s_rx),\n    .cmd_busy(cmd_int_busy),\n    .we_ack(we_ack),\n    .cmd_tsf_err(cmd_tsf_err),\n    .card_status(card_status),\n    .tx_empt(tx_empt),\n    .tx_full(tx_full),\n    .rx_full(rx_full),\n    .busy_n(busy_n),\n    .transm_complete(transm_complete),\n    .crc_ok(crc_ok),\n    .Dat_Int_Status_rst(Dat_Int_Status_rst),\n    .transfer_type(transfer_type),\n    .re_s_tx(re_s_tx),\n    .a_cmp_tx(a_cmp_tx),\n    .re_s_rx(re_s_rx),\n    .a_cmp_rx(a_cmp_rx),\n    .we_req(we_req),\n    .d_write(d_write),\n    .d_read(d_read),\n    .cmd_arg(cmd_arg),\n    .cmd_set(cmd_set),\n    .start_tx_fifo(start_tx_fifo),\n    .start_rx_fifo(start_rx_fifo),\n    .sys_adr(sys_adr),\n    .ack_transfer(ack_transfer),\n    .Dat_Int_Status(Dat_Int_Status),\n    .CIDAT(CIDAT)\n);\n\n// SD Data Serial Host\nsd_data_serial_host sd_data_serial_host_inst (\n    .sd_clk(sd_clk_o_pad),\n    .rst(wb_rst_i),\n    .data_in(dat_in_m_tx_bd),\n    .start_dat(st_dat_t),\n    .ack_transfer(ack_transfer),\n    .DAT_dat_i(sd_dat_dat_i),\n    .rd(rd),\n    .data_out(sd_dat_out_o),\n    .we(we),\n    .DAT_oe_o(sd_dat_oe_o),\n    .DAT_dat_o(sd_dat_out_o),\n    .busy_n(busy_n),\n    .transm_complete(transm_complete),\n    .crc_ok(crc_ok)\n);\n\n// RX BD\nrx_bd rx_bd_inst (\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_rx_bd),\n    .dat_in_m(dat_in_m_rx_bd),\n    .free_bd(free_rx_bd),\n    .re_s(re_s_rx),\n    .ack_o_s(ack_i_s_rx),\n    .a_cmp(a_cmp_rx),\n    .dat_out_s(dat_out_s_rx)\n);\n\n// TX BD\ntx_bd tx_bd_inst (\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .we_m(we_m_tx_bd),\n    .dat_in_m(dat_in_m_tx_bd),\n    .free_bd(free_tx_bd),\n    .re_s(re_s_tx),\n    .ack_o_s(ack_i_s_tx),\n    .a_cmp(a_cmp_tx),\n    .dat_out_s(dat_out_s_tx)\n);\n\n// SD FIFO TX Filler\nsd_fifo_tx_filler sd_fifo_tx_filler_inst (\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_i(m_wb_dat_i),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(start_tx_fifo),\n    .adr(sys_adr),\n    .sd_clk(sd_clk_o_pad),\n    .dat_o(sd_dat_out_o),\n    .rd(rd),\n    .empty(tx_empt),\n    .fe(fe)\n);\n\n// SD FIFO RX Filler\nsd_fifo_rx_filler sd_fifo_rx_filler_inst (\n    .clk(wb_clk_i),\n    .rst(wb_rst_i),\n    .m_wb_adr_o(m_wb_adr_o),\n    .m_wb_we_o(m_wb_we_o),\n    .m_wb_dat_o(m_wb_dat_o),\n    .m_wb_cyc_o(m_wb_cyc_o),\n    .m_wb_stb_o(m_wb_stb_o),\n    .m_wb_ack_i(m_wb_ack_i),\n    .m_wb_cti_o(m_wb_cti_o),\n    .m_wb_bte_o(m_wb_bte_o),\n    .en(start_rx_fifo),\n    .adr(sys_adr),\n    .sd_clk(sd_clk_o_pad),\n    .dat_i(sd_dat_dat_i),\n    .wr(we),\n    .full(rx_full)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00, REQUEST = 2'b01, WRITE_FIFO = 2'b10, DELAY = 2'b11;\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end else begin\n                        reset_tx_fifo <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    if (delay) begin\n                        offset <= offset + 1;\n                        ackd <= ~ackd;\n                        wr_tx <= 1'b0;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n\n    // Write logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr + 1;\n        end\n    end\n\n    // Read logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr + 1;\n        end\n    end\n\n    // Status logic\n    always @(*) begin\n        full = (wptr[FIFO_TX_MEM_ADR_SIZE-1:0] == rptr[FIFO_TX_MEM_ADR_SIZE-1:0]) && \n               (wptr[FIFO_TX_MEM_ADR_SIZE] != rptr[FIFO_TX_MEM_ADR_SIZE]);\n        empty = (wptr == rptr);\n        mem_empt = wptr - rptr;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 6, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n\n    // Wishbone Master Interface\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_sel_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg m_wb_cti_o,\n    output reg m_wb_bte_o,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output reg sd_cmd_out_o,\n    output reg sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output reg [3:0] sd_dat_out_o,\n    output reg sd_dat_oe_o,\n    output reg sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output reg int_a,\n    output reg int_b,\n    output reg int_c,\n\n    // Optional IO\n    input wire card_detect\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-module instantiations and logic here...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wr_ptr, rd_ptr;\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wr_ptr <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wr_ptr <= wr_ptr + 1;\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rd_ptr <= 0;\n            q <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rd_ptr <= rd_ptr + 1;\n        end\n    end\n\n    // Status updates\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n            mem_empt <= 0;\n        end else begin\n            full <= (wr_ptr[FIFO_TX_MEM_ADR_SIZE-1:0] == rd_ptr[FIFO_TX_MEM_ADR_SIZE-1:0]) && \n                    (wr_ptr[FIFO_TX_MEM_ADR_SIZE] != rd_ptr[FIFO_TX_MEM_ADR_SIZE]);\n            empty <= (wr_ptr == rd_ptr);\n            mem_empt <= wr_ptr - rd_ptr;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        REQUEST = 2'b01,\n        WRITE_FIFO = 2'b10,\n        DELAY = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic and state actions\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            dat_o <= 32'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    if (delay) begin\n                        offset <= offset + 1;\n                        ackd <= ~ackd;\n                        wr_tx <= 1'b0;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Instantiate sd_tx_fifo\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 8, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? BD_SIZE / 2 : BD_SIZE / 4;\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                            if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                            if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                            if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                            if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) rec_failed <= 1;\n                        else if (card_status[0] == 1 || (card_status[4:1] >= 4 && card_status[4:1] <= 6)) rec_done <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && tx_empt) trans_failed <= 1;\n                    if (rx_cycle && rx_full) trans_failed <= 1;\n                    if (transm_complete) begin\n                        if (crc_ok) trans_done <= 1;\n                        else trans_failed <= 1;\n                    end\n                    if (trans_done || trans_failed) begin\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        if (rx_cycle) a_cmp_rx <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00;\n    localparam REQUEST = 2'b01;\n    localparam WRITE_FIFO = 2'b10;\n    localparam DELAY = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            offset <= 9'b0;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end else begin\n                        reset_tx_fifo <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    if (delay) begin\n                        offset <= offset + 1;\n                        ackd <= ~ackd;\n                        wr_tx <= 1'b0;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[0]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i == adr_o - 1)\n                full <= 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i - 1)\n                empty <= 1;\n        end\n    end\n\n    always @(*) begin\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else begin\n            full <= (adr_i == adr_o - 1);\n            empty <= (adr_o == adr_i);\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 9'd0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'd0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'd0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    if (en && !empty && wb_free) begin\n                        rd <= 1'b1;\n                        reset_rx_fifo <= 1'b0;\n                    end else begin\n                        rd <= 1'b0;\n                        reset_rx_fifo <= 1'b1;\n                    end\n                end\n                READ: begin\n                    if (rd && wb_free) begin\n                        m_wb_dat_o <= dat_o;\n                        m_wb_we_o <= 1'b1;\n                        m_wb_cyc_o <= 1'b1;\n                        m_wb_stb_o <= 1'b1;\n                        wb_free <= 1'b0;\n                    end\n                end\n                WRITE: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        offset <= offset + `MEM_OFFSET;\n                        wb_free <= 1'b1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    next_state = READ;\n                end\n            end\n            READ: begin\n                if (rd && wb_free) begin\n                    next_state = WRITE;\n                end\n            end\n            WRITE: begin\n                if (m_wb_ack_i) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00, REQUEST = 2'b01, WRITE_FIFO = 2'b10, DELAY = 2'b11;\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end else begin\n                        reset_tx_fifo <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    if (delay) begin\n                        offset <= offset + 1;\n                        ackd <= ~ackd;\n                        wr_tx <= 1'b0;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 13, "code": "module sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00;\n    localparam REQUEST = 2'b01;\n    localparam WRITE_FIFO = 2'b10;\n    localparam DELAY = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic and state actions\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            dat_o <= 32'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b0;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    if (delay) begin\n                        offset <= offset + 1;\n                        ackd <= ~ackd;\n                        wr_tx <= 1'b0;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // FIFO instantiation\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00, REQUEST = 2'b01, WRITE_FIFO = 2'b10, DELAY = 2'b11;\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            offset <= 9'b0;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end else begin\n                        reset_tx_fifo <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    if (delay) begin\n                        offset <= offset + 1;\n                        ackd <= ~ackd;\n                        wr_tx <= 1'b0;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr + 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr + 1;\n        end\n    end\n\n    always @(*) begin\n        full = (wptr[FIFO_TX_MEM_ADR_SIZE-1:0] == rptr[FIFO_TX_MEM_ADR_SIZE-1:0]) && \n               (wptr[FIFO_TX_MEM_ADR_SIZE] != rptr[FIFO_TX_MEM_ADR_SIZE]);\n        empty = (wptr == rptr);\n        mem_empt = wptr - rptr;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else if (en) begin\n            reset_rx_fifo <= 1'b0;\n            if (!empty && wb_free) begin\n                rd <= 1'b1;\n                m_wb_dat_o <= dat_o;\n                m_wb_we_o <= 1'b1;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                wb_free <= 1'b0;\n            end else if (m_wb_ack_i) begin\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= offset + `MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end else begin\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            offset <= 9'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            wb_free <= 1'b1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // State machine states\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    // RX FIFO instance\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            state <= next_state;\n            if (state == WRITE && m_wb_ack_i) begin\n                offset <= offset + `MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        rd = 1'b0;\n        reset_rx_fifo = 1'b0;\n        m_wb_we_o = 1'b0;\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    rd = 1'b1;\n                    next_state = READ;\n                end else if (!en) begin\n                    reset_rx_fifo = 1'b1;\n                end\n            end\n\n            READ: begin\n                if (rd) begin\n                    m_wb_adr_o = adr + offset;\n                    m_wb_we_o = 1'b1;\n                    m_wb_cyc_o = 1'b1;\n                    m_wb_stb_o = 1'b1;\n                    wb_free = 1'b0;\n                    next_state = WRITE;\n                end\n            end\n\n            WRITE: begin\n                if (m_wb_ack_i) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 9, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    Dat_Int_Status <= 0;\n                    CIDAT <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n            endcase\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_RX_MEM_ADR_SIZE:0] count;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH-1)\n                adr_i <= 0;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == FIFO_TX_MEM_DEPTH-1)\n                adr_o <= 0;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            count <= 0;\n            full <= 0;\n            empty <= 1;\n        end else begin\n            if (wr && !full)\n                count <= count + 1;\n            if (rd && !empty)\n                count <= count - 1;\n\n            full <= (count == FIFO_TX_MEM_DEPTH);\n            empty <= (count == 0);\n            mem_empt <= count[FIFO_RX_MEM_ADR_SIZE-1:0];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] count;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            if (adr_i == FIFO_TX_MEM_DEPTH-1)\n                adr_i <= 0;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == FIFO_TX_MEM_DEPTH-1)\n                adr_o <= 0;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            count <= 0;\n            full <= 0;\n            empty <= 1;\n        end else begin\n            if (wr && !full && !(rd && !empty)) begin\n                count <= count + 1;\n            end else if (rd && !empty && !(wr && !full)) begin\n                count <= count - 1;\n            end\n\n            full <= (count == FIFO_TX_MEM_DEPTH);\n            empty <= (count == 0);\n            mem_empt <= count[FIFO_TX_MEM_ADR_SIZE-1:0];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State machine states\n    typedef enum reg [1:0] {\n        IDLE,\n        REQUEST,\n        WRITE_FIFO,\n        DELAY\n    } state_t;\n\n    state_t state, next_state;\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        // Default values\n        next_state = state;\n        m_wb_adr_o = adr + offset;\n        m_wb_we_o = 0;\n        m_wb_cyc_o = 0;\n        m_wb_stb_o = 0;\n        m_wb_cti_o = 3'b000;\n        m_wb_bte_o = 2'b00;\n        wr_tx = 0;\n        reset_tx_fifo = 0;\n        din = m_wb_dat_i;\n\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end\n                if (!en) begin\n                    reset_tx_fifo = 1;\n                    offset = 0;\n                end\n            end\n\n            REQUEST: begin\n                m_wb_cyc_o = 1;\n                m_wb_stb_o = 1;\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end\n            end\n\n            WRITE_FIFO: begin\n                wr_tx = 1;\n                next_state = DELAY;\n            end\n\n            DELAY: begin\n                if (delay) begin\n                    offset = offset + 1;\n                    ackd = ~ackd;\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // Delay logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            delay <= 0;\n        end else if (state == WRITE_FIFO) begin\n            delay <= 1;\n        end else begin\n            delay <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 15, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter IDLE = 6'd0;\n    parameter WRITE_DAT = 6'd1;\n    parameter WRITE_CRC = 6'd2;\n    parameter WRITE_BUSY = 6'd3;\n    parameter READ_WAIT = 6'd4;\n    parameter READ_DAT = 6'd5;\n\n    // CRC_16_gen\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 1'b0;\n            ack_q <= 1'b0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!q_start_bit)\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt >= BIT_BLOCK_REC)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else begin\n            if (!DAR_dat_i[0] && state == READ_WAIT)\n                q_start_bit <= 1'b0;\n            else\n                q_start_bit <= 1'b1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 32'b0;\n            write_buf_1 <= 32'b0;\n            DAT_oe_o <= 1'b0;\n            crc_en <= 1'b0;\n            crc_rst <= 1'b1;\n            transf_cnt <= 11'b0;\n            rd <= 1'b0;\n            last_din <= 4'b0;\n            crc_c <= 5'b0;\n            crc_in <= {SD_BUS_W{1'b0}};\n            DAT_dat_o <= {SD_BUS_W{1'b0}};\n            crc_status <= 3'b111;\n            crc_s <= 3'b0;\n            transm_complete <= 1'b0;\n            busy_n <= 1'b1;\n            we <= 1'b0;\n            data_out <= {SD_BUS_W{1'b0}};\n            crc_ok <= 1'b0;\n            busy_int <= 1'b0;\n            data_send_index <= 3'b0;\n            out_buff_ptr <= 1'b0;\n            in_buff_ptr <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1'b1;\n                    crc_en <= 1'b0;\n                    transf_cnt <= 11'b0;\n                    rd <= 1'b0;\n                    last_din <= 4'b0;\n                    crc_c <= 5'b0;\n                    crc_in <= {SD_BUS_W{1'b0}};\n                    DAT_dat_o <= {SD_BUS_W{1'b0}};\n                    crc_status <= 3'b111;\n                    crc_s <= 3'b0;\n                    transm_complete <= 1'b0;\n                    busy_n <= 1'b1;\n                    we <= 1'b0;\n                    data_out <= {SD_BUS_W{1'b0}};\n                    crc_ok <= 1'b0;\n                    busy_int <= 1'b0;\n                    data_send_index <= 3'b0;\n                    out_buff_ptr <= 1'b0;\n                    in_buff_ptr <= 1'b0;\n                end\n                WRITE_DAT: begin\n                    if (transf_cnt < BIT_BLOCK) begin\n                        if (out_buff_ptr == 1'b0) begin\n                            sd_data_out <= write_buf_0;\n                        end else begin\n                            sd_data_out <= write_buf_1;\n                        end\n                        DAT_dat_o <= last_din;\n                        crc_in <= sd_data_out[31:28];\n                        last_din <= sd_data_out[31:28];\n                        sd_data_out <= {sd_data_out[27:0], 4'b0};\n                        transf_cnt <= transf_cnt + 4;\n                        if (transf_cnt[4:0] == 5'b11100) begin\n                            out_buff_ptr <= ~out_buff_ptr;\n                        end\n                    end\n                end\n                WRITE_CRC: begin\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    if (crc_c < 5'd16) begin\n                        crc_c <= crc_c + 1;\n                    end else begin\n                        crc_status <= crc_out[15:0] == 16'h0 ? 3'b000 : 3'b111;\n                    end\n                end\n                WRITE_BUSY: begin\n                    transm_complete <= 1'b1;\n                    crc_ok <= (crc_s == 3'b010);\n                    busy_int <= DAR_dat_i[0];\n                end\n                READ_WAIT: begin\n                    crc_en <= 1'b1;\n                    crc_rst <= 1'b0;\n                    DAT_oe_o <= 1'b0;\n                    busy_n <= 1'b0;\n                end\n                READ_DAT: begin\n                    if (transf_cnt < BIT_BLOCK_REC) begin\n                        data_out <= DAR_dat_i;\n                        crc_in <= DAR_dat_i;\n                        transf_cnt <= transf_cnt + 1;\n                        we <= 1'b1;\n                    end else begin\n                        we <= 1'b0;\n                        crc_ok <= (crc_out[15:0] == 16'h0);\n                        transm_complete <= 1'b1;\n                        busy_n <= 1'b1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray, rptr_gray;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr_gray_sync1, wptr_gray_sync2;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] rptr_gray_sync1, rptr_gray_sync2;\n\n    // Write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n            wptr_gray <= 0;\n            full <= 0;\n        end else begin\n            if (wr && !full) begin\n                ram[adr_i] <= d;\n                adr_i <= adr_i + 1;\n                wptr <= wptr + 1;\n                wptr_gray <= (wptr + 1) ^ ((wptr + 1) >> 1);\n            end\n            full <= (wptr_gray == {~rptr_gray_sync2[FIFO_TX_MEM_ADR_SIZE], rptr_gray_sync2[FIFO_TX_MEM_ADR_SIZE-1:0]});\n        end\n    end\n\n    // Read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n            rptr_gray <= 0;\n            empty <= 1;\n        end else begin\n            if (rd && !empty) begin\n                q <= ram[adr_o];\n                adr_o <= adr_o + 1;\n                rptr <= rptr + 1;\n                rptr_gray <= (rptr + 1) ^ ((rptr + 1) >> 1);\n            end\n            empty <= (rptr_gray == wptr_gray_sync2);\n        end\n    end\n\n    // Synchronize write pointer to read clock domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            wptr_gray_sync1 <= 0;\n            wptr_gray_sync2 <= 0;\n        end else begin\n            wptr_gray_sync1 <= wptr_gray;\n            wptr_gray_sync2 <= wptr_gray_sync1;\n        end\n    end\n\n    // Synchronize read pointer to write clock domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            rptr_gray_sync1 <= 0;\n            rptr_gray_sync2 <= 0;\n        end else begin\n            rptr_gray_sync1 <= rptr_gray;\n            rptr_gray_sync2 <= rptr_gray_sync1;\n        end\n    end\n\n    // FIFO occupancy\n    always @(*) begin\n        mem_empt = wptr - rptr;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            state <= next_state;\n            if (state == WRITE && m_wb_ack_i) begin\n                offset <= offset + `MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        rd = 1'b0;\n        reset_rx_fifo = 1'b0;\n        m_wb_we_o = 1'b0;\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n        m_wb_adr_o = adr + offset;\n        m_wb_dat_o = dat_o;\n\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    rd = 1'b1;\n                    next_state = READ;\n                end else if (!en) begin\n                    reset_rx_fifo = 1'b1;\n                end\n            end\n\n            READ: begin\n                if (rd) begin\n                    m_wb_we_o = 1'b1;\n                    m_wb_cyc_o = 1'b1;\n                    m_wb_stb_o = 1'b1;\n                    wb_free = 1'b0;\n                    next_state = WRITE;\n                end\n            end\n\n            WRITE: begin\n                if (m_wb_ack_i) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 7, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire cmd_int_busy;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb u_sd_controller_wb (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional sub-modules instantiation and connections\n    // ...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 8, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // Card Detect\n    input wire card_detect,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules instantiation and logic here...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] state, next_state;\n\n    localparam IDLE = 3'b000, WRITING = 3'b001, READING = 3'b010;\n\n    // State Transition\n    always @(posedge wclk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (wr && !full)\n                    next_state = WRITING;\n                else if (rd && !empty)\n                    next_state = READING;\n                else\n                    next_state = IDLE;\n            end\n            WRITING: begin\n                if (wr && !full)\n                    next_state = WRITING;\n                else\n                    next_state = IDLE;\n            end\n            READING: begin\n                if (rd && !empty)\n                    next_state = READING;\n                else\n                    next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Write Operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            ft <= ft + 1;\n            if (ft == 7) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 0;\n            end\n            if (adr_i == adr_o - 1)\n                full <= 1;\n            else\n                full <= 0;\n        end\n    end\n\n    // Read Operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i - 1)\n                empty <= 1;\n            else\n                empty <= 0;\n        end\n    end\n\n    // Memory Empty Space Calculation\n    always @(*) begin\n        if (adr_i >= adr_o)\n            mem_empt = (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) >> 3;\n        else\n            mem_empt = (adr_o - adr_i) >> 3;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] count;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            count <= 0;\n            full <= 0;\n            empty <= 1;\n        end else begin\n            if (wr && !full && !(rd && !empty)) begin\n                count <= count + 1;\n            end else if (rd && !empty && !(wr && !full)) begin\n                count <= count - 1;\n            end\n\n            full <= (count == FIFO_TX_MEM_DEPTH);\n            empty <= (count == 0);\n            mem_empt <= count[FIFO_TX_MEM_ADR_SIZE-1:0];\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 9, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    \n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    \n    // SDC IO\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Other sub-modules instantiation...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 10, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional sub-modules instantiation and connections go here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 10, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != `BD_EMPTY) next_state = GET_TX_BD;\n                else if (free_rx_bd != `BD_EMPTY) next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > `READ_CYCLE - 1 && tx_full == 1) next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= `READ_CYCLE - 1) next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done) next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done) next_state = DATA_TRANSFER;\n                else if (rec_failed) next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) next_state = IDLE;\n                else if (trans_failed) next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    resend_try_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (`RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                            else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                            else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (`RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                            else if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                            else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    else if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) rec_failed <= 1;\n                        else if (card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) rec_done <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && tx_empt) trans_failed <= 1;\n                    else if (rx_cycle && rx_full) trans_failed <= 1;\n                    if (transm_complete) begin\n                        if (crc_ok) trans_done <= 1;\n                        else trans_failed <= 1;\n                    end\n                    if (trans_done || trans_failed) begin\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        else if (rx_cycle) a_cmp_rx <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 11, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input wire card_detect\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(),\n    .error_int_status_reg(),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules instantiation and connections would go here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    // State encoding\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    // RX FIFO instance\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    next_state = READ;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            READ: begin\n                if (m_wb_ack_i && !wb_free) begin\n                    next_state = WRITE;\n                end else begin\n                    next_state = READ;\n                end\n            end\n            WRITE: begin\n                if (rd && m_wb_we_o && m_wb_cyc_o && m_wb_stb_o) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = WRITE;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    rd <= 1'b0;\n                    reset_rx_fifo <= 1'b0;\n                    if (!en) begin\n                        reset_rx_fifo <= 1'b1;\n                        wb_free <= 1'b1;\n                    end\n                end\n                READ: begin\n                    rd <= 1'b1;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_we_o <= 1'b1;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    wb_free <= 1'b0;\n                end\n                WRITE: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        offset <= offset + `MEM_OFFSET;\n                        wb_free <= 1'b1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 16, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters\n    parameter IDLE = 6'b000001, WRITE_DAT = 6'b000010, WRITE_CRC = 6'b000100,\n              WRITE_BUSY = 6'b001000, READ_WAIT = 6'b010000, READ_DAT = 6'b100000;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO Block\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = WRITE_CRC;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 0)\n                    next_state = WRITE_BUSY;\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0)\n                    next_state = IDLE;\n            end\n            READ_WAIT: begin\n                if (q_start_bit == 0)\n                    next_state = READ_DAT;\n            end\n            READ_DAT: begin\n                if (transf_cnt >= BIT_BLOCK_REC)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // START_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                    crc_ok <= 0;\n                end\n                WRITE_DAT: begin\n                    if (transf_cnt < BIT_BLOCK) begin\n                        if (transf_cnt[4:0] == 0) begin\n                            if (out_buff_ptr == 0)\n                                sd_data_out <= write_buf_0;\n                            else\n                                sd_data_out <= write_buf_1;\n                            out_buff_ptr <= ~out_buff_ptr;\n                        end\n                        last_din <= sd_data_out[31:28];\n                        crc_in <= sd_data_out[31:28];\n                        DAT_dat_o <= last_din;\n                        sd_data_out <= {sd_data_out[27:0], 4'b0};\n                        transf_cnt <= transf_cnt + 4;\n                        crc_en <= 1;\n                    end else begin\n                        crc_rst <= 0;\n                        crc_en <= 0;\n                    end\n                end\n                WRITE_CRC: begin\n                    crc_s <= DAT_dat_i[3:1];\n                    if (crc_c < 7)\n                        crc_c <= crc_c + 1;\n                    else\n                        crc_c <= 0;\n                end\n                WRITE_BUSY: begin\n                    if (crc_s == 3'b010)\n                        crc_ok <= 1;\n                    else\n                        crc_ok <= 0;\n                    if (DAT_dat_i[0] == 0)\n                        busy_int <= 1;\n                    else\n                        busy_int <= 0;\n                    if (!busy_int && ack_transfer_int) begin\n                        transm_complete <= 1;\n                        busy_n <= 1;\n                    end\n                end\n                READ_WAIT: begin\n                    crc_rst <= 0;\n                    crc_en <= 1;\n                    DAT_oe_o <= 0;\n                    transf_cnt <= 0;\n                end\n                READ_DAT: begin\n                    if (transf_cnt < BIT_BLOCK_REC) begin\n                        data_out <= DAT_dat_i;\n                        crc_in <= DAT_dat_i;\n                        transf_cnt <= transf_cnt + 1;\n                        we <= 1;\n                    end else begin\n                        we <= 0;\n                        if (crc_out[15:0] == DAT_dat_i[15:0])\n                            crc_ok <= 1;\n                        else\n                            crc_ok <= 0;\n                        if (transf_cnt == BIT_BLOCK_REC + BIT_CRC_CYCLE)\n                            transm_complete <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 16, "code": "module sd_rx_fifo (\n    input wire [3:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    `include \"sd_defines.v\"\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] state, next_state;\n\n    localparam IDLE = 3'b000;\n    localparam WRITING = 3'b001;\n    localparam READING = 3'b010;\n\n    // State transition\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (wr) begin\n                    next_state = WRITING;\n                end else if (rd) begin\n                    next_state = READING;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITING: begin\n                if (ft) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = WRITING;\n                end\n            end\n            READING: begin\n                if (!rd) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = READING;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n            we <= 8'h1;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[0]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end else begin\n                ft <= 0;\n            end\n            if (adr_i == adr_o - 1) begin\n                full <= 1;\n            end\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i - 1) begin\n                empty <= 1;\n            end\n        end\n    end\n\n    // Empty and memory empty space calculation\n    always @(*) begin\n        empty = (adr_i == adr_o);\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 12, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider sd_clock_divider_inst (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master sd_cmd_master_inst (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(),\n        .data_write(),\n        .data_read(),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(),\n        .NORMAL_INT_REG(),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host sd_cmd_serial_host_inst (\n        .SD_CLK_IN(sd_clk_o_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n\n    sd_data_master sd_data_master_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(),\n        .we_ack(),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(),\n        .tx_full(),\n        .rx_full(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok(),\n        .Dat_Int_Status_rst(),\n        .transfer_type(),\n        .re_s_tx(),\n        .a_cmp_tx(),\n        .re_s_rx(),\n        .a_cmp_rx(),\n        .we_req(),\n        .d_write(),\n        .d_read(),\n        .cmd_arg(),\n        .cmd_set(),\n        .start_tx_fifo(),\n        .start_rx_fifo(),\n        .sys_adr(),\n        .ack_transfer(),\n        .Dat_Int_Status(),\n        .CIDAT()\n    );\n\n    sd_data_serial_host sd_data_serial_host_inst (\n        .sd_clk(sd_clk_o_pad),\n        .rst(wb_rst_i),\n        .data_in(),\n        .start_dat(),\n        .ack_transfer(),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(),\n        .data_out(sd_dat_out_o),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok()\n    );\n\n    // Additional logic for interrupts and optional IO\n    assign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) ? 1'b1 : 1'b0;\n    assign int_b = (error_int_status_reg & error_int_signal_enable_reg) ? 1'b1 : 1'b0;\n    assign int_c = (Bd_isr_reg & Bd_isr_enable_reg) ? 1'b1 : 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            state <= next_state;\n            if (state == WRITE && m_wb_ack_i) begin\n                offset <= offset + `MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    rd = 1'b1;\n                    next_state = READ;\n                end else begin\n                    rd = 1'b0;\n                    reset_rx_fifo = !en;\n                end\n            end\n            READ: begin\n                if (rd) begin\n                    m_wb_adr_o = adr + offset;\n                    m_wb_dat_o = dat_o;\n                    m_wb_we_o = 1'b1;\n                    m_wb_cyc_o = 1'b1;\n                    m_wb_stb_o = 1'b1;\n                    wb_free = 1'b0;\n                    next_state = WRITE;\n                end\n            end\n            WRITE: begin\n                if (m_wb_ack_i) begin\n                    m_wb_we_o = 1'b0;\n                    m_wb_cyc_o = 1'b0;\n                    m_wb_stb_o = 1'b0;\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 13, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input wire card_detect\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb u_sd_controller_wb (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider u_sd_clock_divider (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master u_sd_cmd_master (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(),\n        .data_write(),\n        .data_read(),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host u_sd_cmd_serial_host (\n        .SD_CLK_IN(sd_clk_o_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n\n    sd_data_master u_sd_data_master (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(),\n        .we_ack(),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(),\n        .tx_full(),\n        .rx_full(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok(),\n        .Dat_Int_Status_rst(),\n        .transfer_type(),\n        .re_s_tx(),\n        .a_cmp_tx(),\n        .re_s_rx(),\n        .a_cmp_rx(),\n        .we_req(),\n        .d_write(),\n        .d_read(),\n        .cmd_arg(),\n        .cmd_set(),\n        .start_tx_fifo(),\n        .start_rx_fifo(),\n        .sys_adr(),\n        .ack_transfer(),\n        .Dat_Int_Status(),\n        .CIDAT()\n    );\n\n    sd_data_serial_host u_sd_data_serial_host (\n        .sd_clk(sd_clk_o_pad),\n        .rst(wb_rst_i),\n        .data_in(),\n        .start_dat(),\n        .ack_transfer(),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(),\n        .data_out(sd_dat_out_o),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok()\n    );\n\n    rx_bd u_rx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(),\n        .dat_in_m(),\n        .free_bd(),\n        .re_s(),\n        .ack_o_s(),\n        .a_cmp(),\n        .dat_out_s()\n    );\n\n    tx_bd u_tx_bd (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .we_m(),\n        .dat_in_m(),\n        .free_bd(),\n        .re_s(),\n        .ack_o_s(),\n        .a_cmp(),\n        .dat_out_s()\n    );\n\n    sd_fifo_tx_filler u_sd_fifo_tx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_i(m_wb_dat_i),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(),\n        .adr(),\n        .sd_clk(sd_clk_o_pad),\n        .dat_o(),\n        .rd(),\n        .empty(),\n        .fe()\n    );\n\n    sd_fifo_rx_filler u_sd_fifo_rx_filler (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .m_wb_adr_o(m_wb_adr_o),\n        .m_wb_we_o(m_wb_we_o),\n        .m_wb_dat_o(m_wb_dat_o),\n        .m_wb_cyc_o(m_wb_cyc_o),\n        .m_wb_stb_o(m_wb_stb_o),\n        .m_wb_ack_i(m_wb_ack_i),\n        .m_wb_cti_o(m_wb_cti_o),\n        .m_wb_bte_o(m_wb_bte_o),\n        .en(),\n        .adr(),\n        .sd_clk(sd_clk_o_pad),\n        .dat_i(sd_dat_dat_i),\n        .wr(),\n        .full()\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 14, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider sd_clock_divider_inst (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master sd_cmd_master_inst (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(),\n        .data_write(),\n        .data_read(),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(),\n        .NORMAL_INT_REG(),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host sd_cmd_serial_host_inst (\n        .SD_CLK_IN(wb_clk_i),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n\n    sd_data_master sd_data_master_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(),\n        .we_ack(),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(),\n        .tx_full(),\n        .rx_full(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok(),\n        .Dat_Int_Status_rst(),\n        .transfer_type(),\n        .re_s_tx(),\n        .a_cmp_tx(),\n        .re_s_rx(),\n        .a_cmp_rx(),\n        .we_req(),\n        .d_write(),\n        .d_read(),\n        .cmd_arg(),\n        .cmd_set(),\n        .start_tx_fifo(),\n        .start_rx_fifo(),\n        .sys_adr(),\n        .ack_transfer(),\n        .Dat_Int_Status(),\n        .CIDAT()\n    );\n\n    sd_data_serial_host sd_data_serial_host_inst (\n        .sd_clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .data_in(),\n        .start_dat(),\n        .ack_transfer(),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(),\n        .data_out(sd_dat_out_o),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok()\n    );\n\n    // Additional logic for handling interrupts and optional IO\n    assign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) ? 1'b1 : 1'b0;\n    assign int_b = (error_int_status_reg & error_int_signal_enable_reg) ? 1'b1 : 1'b0;\n    assign int_c = (Bd_isr_reg & Bd_isr_enable_reg) ? 1'b1 : 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output reg empty,\n    output reg fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00,\n               REQUEST = 2'b01,\n               WRITE_FIFO = 2'b10,\n               DELAY = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State transition\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            dat_o <= 32'b0;\n            empty <= 1'b1;\n            fe <= 1'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b0;\n            first <= 1'b0;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (en) begin\n                        reset_tx_fifo <= 1'b0;\n                        m_wb_adr_o <= adr + offset;\n                        m_wb_cyc_o <= 1'b1;\n                        m_wb_stb_o <= 1'b1;\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cti_o <= 3'b000;\n                        m_wb_bte_o <= 2'b00;\n                    end else begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    if (m_wb_ack_i) begin\n                        din <= m_wb_dat_i;\n                        wr_tx <= 1'b1;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        delay <= 1'b1;\n                    end\n                end\n                WRITE_FIFO: begin\n                    wr_tx <= 1'b0;\n                    offset <= offset + 1'b1;\n                    ackd <= ~ackd;\n                end\n                DELAY: begin\n                    delay <= 1'b0;\n                end\n            endcase\n        end\n    end\n\n    // Instantiate sd_tx_fifo\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 17, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen submodule instances\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO block\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 0)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 0)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (q_start_bit == 0)\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt >= BIT_BLOCK_REC)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                    crc_ok <= 0;\n                end\n                WRITE_DAT: begin\n                    // Implement WRITE_DAT logic\n                end\n                WRITE_CRC: begin\n                    // Implement WRITE_CRC logic\n                end\n                WRITE_BUSY: begin\n                    // Implement WRITE_BUSY logic\n                end\n                READ_WAIT: begin\n                    // Implement READ_WAIT logic\n                end\n                READ_DAT: begin\n                    // Implement READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            we <= {we[6:0], we[7]};\n            if (we[7]) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 1;\n            end\n            if (adr_i == adr_o - 1)\n                full <= 1;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i)\n                empty <= 1;\n            full <= 0;\n        end\n    end\n\n    always @(*) begin\n        mem_empt = adr_i - adr_o;\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            empty <= 1;\n            full <= 0;\n        end else begin\n            empty <= (adr_i == adr_o);\n            full <= (adr_i == adr_o - 1);\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] byte_count;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            we <= 8'h1;\n            tmp <= 0;\n            ft <= 0;\n            byte_count <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            byte_count <= byte_count + 1;\n            if (byte_count == 3) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                byte_count <= 0;\n                if (adr_i + 1 == adr_o)\n                    full <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i)\n                empty <= 1;\n        end\n    end\n\n    always @(*) begin\n        if (adr_i == adr_o)\n            empty = 1;\n        else\n            empty = 0;\n\n        if ((adr_i + 1) == adr_o)\n            full = 1;\n        else\n            full = 0;\n\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 11, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done;\n    reg rec_done;\n    reg rec_failed;\n    reg tx_cycle;\n    reg rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done;\n    reg trans_failed;\n    reg internal_transm_complete;\n    reg transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else if (rx_cycle) begin\n                            a_cmp_rx <= 1;\n                        end\n                        ack_transfer <= 1;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    wire [31:0] dat_o;\n\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    localparam IDLE = 2'b00, READ = 2'b01, WRITE = 2'b10;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n        end else begin\n            state <= next_state;\n            if (state == WRITE && m_wb_ack_i) begin\n                offset <= offset + `MEM_OFFSET;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        rd = 1'b0;\n        reset_rx_fifo = 1'b0;\n        m_wb_we_o = 1'b0;\n        m_wb_cyc_o = 1'b0;\n        m_wb_stb_o = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    rd = 1'b1;\n                    next_state = READ;\n                end else if (!en) begin\n                    reset_rx_fifo = 1'b1;\n                end\n            end\n\n            READ: begin\n                if (rd) begin\n                    m_wb_dat_o = dat_o;\n                    m_wb_adr_o = adr + {23'b0, offset};\n                    m_wb_we_o = 1'b1;\n                    m_wb_cyc_o = 1'b1;\n                    m_wb_stb_o = 1'b1;\n                    wb_free = 1'b0;\n                    next_state = WRITE;\n                end\n            end\n\n            WRITE: begin\n                if (m_wb_ack_i) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 15, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider sd_clock_divider_inst (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    sd_cmd_master sd_cmd_master_inst (\n        .CLK_PAD_IO(wb_clk_i),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(),\n        .data_write(),\n        .data_read(),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(cmd_resp_1),\n        .ERR_INT_REG(error_int_status_reg),\n        .NORMAL_INT_REG(normal_int_status_reg),\n        .ERR_INT_RST(error_isr_reset),\n        .NORMAL_INT_RST(normal_isr_reset),\n        .settings(),\n        .go_idle_o(),\n        .cmd_out(),\n        .req_out(),\n        .ack_out(),\n        .req_in(),\n        .ack_in(),\n        .cmd_in(),\n        .serial_status(),\n        .card_detect(card_detect)\n    );\n\n    sd_cmd_serial_host sd_cmd_serial_host_inst (\n        .SD_CLK_IN(sd_clk_o_pad),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(cmd_setting_reg),\n        .CMD_IN(),\n        .REQ_IN(),\n        .ACK_IN(),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(),\n        .ACK_OUT(),\n        .REQ_OUT(),\n        .STATUS(),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t()\n    );\n\n    sd_data_master sd_data_master_inst (\n        .clk(wb_clk_i),\n        .rst(wb_rst_i),\n        .dat_in_tx(),\n        .free_tx_bd(),\n        .ack_i_s_tx(),\n        .dat_in_rx(),\n        .free_rx_bd(),\n        .ack_i_s_rx(),\n        .cmd_busy(),\n        .we_ack(),\n        .cmd_tsf_err(),\n        .card_status(),\n        .tx_empt(),\n        .tx_full(),\n        .rx_full(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok(),\n        .Dat_Int_Status_rst(),\n        .transfer_type(),\n        .re_s_tx(),\n        .a_cmp_tx(),\n        .re_s_rx(),\n        .a_cmp_rx(),\n        .we_req(),\n        .d_write(),\n        .d_read(),\n        .cmd_arg(),\n        .cmd_set(),\n        .start_tx_fifo(),\n        .start_rx_fifo(),\n        .sys_adr(),\n        .ack_transfer(),\n        .Dat_Int_Status(),\n        .CIDAT()\n    );\n\n    sd_data_serial_host sd_data_serial_host_inst (\n        .sd_clk(sd_clk_o_pad),\n        .rst(wb_rst_i),\n        .data_in(),\n        .start_dat(),\n        .ack_transfer(),\n        .DAT_dat_i(sd_dat_dat_i),\n        .rd(),\n        .data_out(sd_dat_out_o),\n        .we(),\n        .DAT_oe_o(sd_dat_oe_o),\n        .DAT_dat_o(),\n        .busy_n(),\n        .transm_complete(),\n        .crc_ok()\n    );\n\n    // Interrupt logic\n    assign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) ? 1'b1 : 1'b0;\n    assign int_b = (error_int_status_reg & error_int_signal_enable_reg) ? 1'b1 : 1'b0;\n    assign int_c = (Bd_isr_reg & Bd_isr_enable_reg) ? 1'b1 : 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 19, "code": "module sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    parameter FIFO_RX_MEM_DEPTH = 16;\n    parameter FIFO_RX_MEM_ADR_SIZE = 4;\n\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n    reg [2:0] state, next_state;\n\n    localparam IDLE = 3'b000, WRITING = 3'b001, READING = 3'b010;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n            we <= 8'h1;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            ft <= ft + 1;\n            if (ft == 7) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 0;\n                if (adr_i + 1 == adr_o)\n                    full <= 1;\n            end\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o + 1 == adr_i)\n                empty <= 1;\n            full <= 0;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 2'b11;\n        end else begin\n            mem_empt <= (adr_i - adr_o) >> 2;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (wr && !full)\n                    next_state = WRITING;\n                else if (rd && !empty)\n                    next_state = READING;\n                else\n                    next_state = IDLE;\n            end\n            WRITING: begin\n                if (ft == 7)\n                    next_state = IDLE;\n                else\n                    next_state = WRITING;\n            end\n            READING: begin\n                if (empty)\n                    next_state = IDLE;\n                else\n                    next_state = READING;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n    // Parameters\n    parameter FIFO_RX_MEM_DEPTH = 16; // Example depth\n    parameter FIFO_RX_MEM_ADR_SIZE = 5; // Example address size\n\n    // Registers\n    reg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [7:0] we;\n    reg [31:0] tmp;\n    reg ft;\n\n    // Write Operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            tmp <= 0;\n            ft <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            tmp <= {tmp[27:0], d};\n            ft <= ft + 1;\n            if (ft == 7) begin\n                ram[adr_i] <= tmp;\n                adr_i <= adr_i + 1;\n                ft <= 0;\n            end\n            if (adr_i == adr_o - 1) begin\n                full <= 1;\n            end\n        end\n    end\n\n    // Read Operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            q <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            if (adr_o == adr_i) begin\n                empty <= 1;\n            end\n        end\n    end\n\n    // Full and Empty Flags\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else begin\n            if (adr_i == adr_o - 1) begin\n                full <= 1;\n            end else begin\n                full <= 0;\n            end\n\n            if (adr_o == adr_i) begin\n                empty <= 1;\n            end else begin\n                empty <= 0;\n            end\n        end\n    end\n\n    // Memory Empty Space Calculation\n    always @(*) begin\n        mem_empt = (adr_i >= adr_o) ? (FIFO_RX_MEM_DEPTH - (adr_i - adr_o)) : (adr_o - adr_i);\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    input wire rd,\n    input wire rclk,\n    input wire rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n            full <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr + 1;\n            if (adr_i + 1 == adr_o)\n                full <= 1;\n            else\n                full <= 0;\n        end\n    end\n\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n            empty <= 1;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr + 1;\n            if (adr_o + 1 == adr_i)\n                empty <= 1;\n            else\n                empty <= 0;\n        end\n    end\n\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 0;\n        end else begin\n            mem_empt <= wptr - rptr;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n\n    // Write operation\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr + 1;\n        end\n    end\n\n    // Read operation\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n            q <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr + 1;\n        end\n    end\n\n    // Status flags\n    always @(posedge wclk or posedge rclk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n            mem_empt <= 0;\n        end else begin\n            full <= (wptr[FIFO_TX_MEM_ADR_SIZE-1:0] == rptr[FIFO_TX_MEM_ADR_SIZE-1:0]) &&\n                    (wptr[FIFO_TX_MEM_ADR_SIZE] != rptr[FIFO_TX_MEM_ADR_SIZE]);\n            empty <= (wptr == rptr);\n            mem_empt <= wptr - rptr;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 12, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != 0) next_state = GET_TX_BD;\n                else if (free_rx_bd != 0) next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > `READ_CYCLE - 1 && tx_full == 1) next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= `READ_CYCLE - 1) next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done) next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done) next_state = DATA_TRANSFER;\n                else if (rec_failed) next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) next_state = IDLE;\n                else if (trans_failed) next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (`RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                            else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else if (`RAM_MEM_WIDTH == 16) begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                            else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (`RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                            else if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                        end else if (`RAM_MEM_WIDTH == 16) begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                            else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    else if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) rec_failed <= 1;\n                        else if (card_status[0] || (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) rec_done <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) trans_done <= 1;\n                    else if (rx_cycle && !rx_full) trans_done <= 1;\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        else if (rx_cycle) a_cmp_rx <= 1;\n                    end else trans_failed <= 1;\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [`SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n\n    // Instantiate the RX FIFO\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(m_wb_dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    // State machine states\n    typedef enum reg [1:0] {\n        IDLE,\n        READ,\n        WRITE\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    next_state = READ;\n                end\n            end\n            READ: begin\n                if (m_wb_ack_i && !wb_free) begin\n                    next_state = WRITE;\n                end\n            end\n            WRITE: begin\n                if (!en || empty || !wb_free) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    rd <= 1'b0;\n                    reset_rx_fifo <= 1'b1;\n                    if (en && !empty && wb_free) begin\n                        rd <= 1'b1;\n                        reset_rx_fifo <= 1'b0;\n                    end\n                end\n                READ: begin\n                    if (m_wb_ack_i && !wb_free) begin\n                        offset <= offset + `MEM_OFFSET;\n                        wb_free <= 1'b1;\n                    end\n                end\n                WRITE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1'b1;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    wb_free <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00, REQUEST = 2'b01, WRITE_FIFO = 2'b10, DELAY = 2'b11;\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end else begin\n                        reset_tx_fifo <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    if (delay) begin\n                        offset <= offset + 1;\n                        ackd <= ~ackd;\n                        wr_tx <= 1'b0;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 13, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? BD_SIZE / 2 : BD_SIZE / 4;\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY) next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done) next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done) next_state = DATA_TRANSFER;\n                else if (rec_failed) next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) next_state = IDLE;\n                else if (trans_failed) next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                            else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                            else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                            else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                            else if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                            else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                            else if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    else if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) rec_failed <= 1;\n                        else if (card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) rec_done <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) trans_done <= 1;\n                    else if (rx_cycle && !rx_full) trans_done <= 1;\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        if (tx_cycle) a_cmp_tx <= 1;\n                        else if (rx_cycle) a_cmp_rx <= 1;\n                    end else trans_failed <= 1;\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 16, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n\n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n\n    // SDC IO\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c,\n\n    // Optional IO\n    input wire card_detect\n);\n\n// Internal signals\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg)\n);\n\nsd_cmd_master u_sd_cmd_master (\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .card_detect(card_detect),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg)\n);\n\nsd_data_master u_sd_data_master (\n    .clk(wb_clk_i),\n    .rst(wb_rst_i)\n);\n\n// Clock Divider\nsd_clock_divider u_sd_clock_divider (\n    .CLK(wb_clk_i),\n    .DIVIDER(8'd0),\n    .RST(wb_rst_i),\n    .SD_CLK(sd_clk_o_pad)\n);\n\n// Interrupt logic\nassign int_a = |(normal_int_status_reg & Bd_isr_enable_reg);\nassign int_b = |(error_int_status_reg & Bd_isr_enable_reg);\nassign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt\n);\n\n    reg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i;\n    reg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_o;\n    reg [FIFO_TX_MEM_ADR_SIZE:0] wptr, rptr;\n\n    // Write logic\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            adr_i <= 0;\n            wptr <= 0;\n        end else if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= adr_i + 1;\n            wptr <= wptr + 1;\n        end\n    end\n\n    // Read logic\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            adr_o <= 0;\n            rptr <= 0;\n        end else if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= adr_o + 1;\n            rptr <= rptr + 1;\n        end\n    end\n\n    // Status logic\n    always @(*) begin\n        full = (wptr[FIFO_TX_MEM_ADR_SIZE-1:0] == rptr[FIFO_TX_MEM_ADR_SIZE-1:0]) && \n               (wptr[FIFO_TX_MEM_ADR_SIZE] != rptr[FIFO_TX_MEM_ADR_SIZE]);\n        empty = (wptr == rptr);\n        mem_empt = wptr - rptr;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 14, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    cmd_arg <= 0;\n                    cmd_set <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    sys_adr <= 0;\n                    ack_transfer <= 0;\n                    CIDAT <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else if (rx_cycle) begin\n                            a_cmp_rx <= 1;\n                        end\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n            endcase\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 15, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                        end\n                    end\n                end\n            endcase\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 16, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? BD_SIZE / 2 : BD_SIZE / 4;\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done == 1) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done == 1) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done == 1) begin\n                    next_state = IDLE;\n                end else if (trans_failed == 1) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done == 1) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    transm_complete_q <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (!cmd_tsf_err && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                            rec_done <= 1;\n                        end else begin\n                            rec_failed <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 17, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Sequential Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        // Default assignments\n        next_state = state;\n        re_s_tx = 0;\n        a_cmp_tx = 0;\n        re_s_rx = 0;\n        a_cmp_rx = 0;\n        we_req = 0;\n        d_write = 0;\n        d_read = 0;\n        start_tx_fifo = 0;\n        start_rx_fifo = 0;\n        ack_transfer = 0;\n        send_done = 0;\n        rec_done = 0;\n        rec_failed = 0;\n        trans_done = 0;\n        trans_failed = 0;\n\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n\n            GET_TX_BD: begin\n                re_s_tx = 1;\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n\n            GET_RX_BD: begin\n                re_s_rx = 1;\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n\n            SEND_CMD: begin\n                if (!cmd_busy) begin\n                    we_req = 1;\n                    if (we_ack) begin\n                        send_done = 1;\n                        next_state = RECIVE_CMD;\n                    end\n                end\n            end\n\n            RECIVE_CMD: begin\n                if (!cmd_busy) begin\n                    if (!cmd_tsf_err && card_status[0]) begin\n                        rec_done = 1;\n                        next_state = DATA_TRANSFER;\n                    end else begin\n                        rec_failed = 1;\n                        next_state = SEND_CMD;\n                    end\n                end\n            end\n\n            DATA_TRANSFER: begin\n                if (transm_complete && crc_ok) begin\n                    trans_done = 1;\n                    next_state = IDLE;\n                end else if (!crc_ok) begin\n                    trans_failed = 1;\n                    next_state = STOP;\n                end\n            end\n\n            STOP: begin\n                cmd_set = CMD12;\n                next_state = STOP_SEND;\n            end\n\n            STOP_SEND: begin\n                if (!cmd_busy) begin\n                    we_req = 1;\n                    if (we_ack) begin\n                        send_done = 1;\n                        next_state = IDLE;\n                    end\n                end\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            Dat_Int_Status <= 0;\n        end else begin\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end else begin\n                if (trans_failed) begin\n                    Dat_Int_Status[1] <= 1;\n                end\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00, REQUEST = 2'b01, WRITE_FIFO = 2'b10, DELAY = 2'b11;\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (!en) begin\n                        reset_tx_fifo <= 1'b1;\n                        offset <= 9'b0;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        m_wb_we_o <= 1'b0;\n                    end else begin\n                        reset_tx_fifo <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    if (delay) begin\n                        offset <= offset + 1;\n                        ackd <= ~ackd;\n                        wr_tx <= 1'b0;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 18, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAR_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'b000000: begin // IDLE\n                if (start_dat == 2'b10)\n                    next_state = 6'b000001; // WRITE_DAT\n                else if (start_dat == 2'b01)\n                    next_state = 6'b000010; // READ_WAIT\n                else\n                    next_state = 6'b000000; // IDLE\n            end\n            6'b000001: begin // WRITE_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000011; // WRITE_CRC\n                else\n                    next_state = 6'b000001; // WRITE_DAT\n            end\n            6'b000011: begin // WRITE_CRC\n                if (crc_status == 0)\n                    next_state = 6'b000100; // WRITE_BUSY\n                else\n                    next_state = 6'b000011; // WRITE_CRC\n            end\n            6'b000100: begin // WRITE_BUSY\n                if (busy_int == 0)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000100; // WRITE_BUSY\n            end\n            6'b000010: begin // READ_WAIT\n                if (DAR_dat_i[0] == 0)\n                    next_state = 6'b000101; // READ_DAT\n                else\n                    next_state = 6'b000010; // READ_WAIT\n            end\n            6'b000101: begin // READ_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'b000000; // IDLE\n                else\n                    next_state = 6'b000101; // READ_DAT\n            end\n            default: next_state = 6'b000000; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAR_dat_i[0] && state == 6'b000010)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'b000000; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'b000000: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                end\n                6'b000001: begin // WRITE_DAT\n                    // Implement WRITE_DAT logic\n                end\n                6'b000011: begin // WRITE_CRC\n                    // Implement WRITE_CRC logic\n                end\n                6'b000100: begin // WRITE_BUSY\n                    // Implement WRITE_BUSY logic\n                end\n                6'b000010: begin // READ_WAIT\n                    // Implement READ_WAIT logic\n                end\n                6'b000101: begin // READ_DAT\n                    // Implement READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 18, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? BD_SIZE / 2 : BD_SIZE / 4;\n\n    // Internal signals\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY) next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done) next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done) next_state = DATA_TRANSFER;\n                else if (rec_failed) next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) next_state = IDLE;\n                else if (trans_failed) next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                        else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end else begin\n                        if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                        else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                        else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                        else if (bd_cnt == 3) begin\n                            cmd_arg[31:16] <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                    bd_cnt <= bd_cnt + 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (RAM_MEM_WIDTH == 32) begin\n                        if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                        else if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                    end else begin\n                        if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                        else if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                        else if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                        else if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                    bd_cnt <= bd_cnt + 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    else if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) rec_failed <= 1;\n                        else if (card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) rec_done <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) trans_done <= 1;\n                    else if (rx_cycle && !rx_full) trans_done <= 1;\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end else trans_failed <= 1;\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00,\n               REQUEST = 2'b01,\n               WRITE_FIFO = 2'b10,\n               DELAY = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i)\n                    next_state = REQUEST;\n                else\n                    next_state = IDLE;\n            end\n            REQUEST: begin\n                if (m_wb_ack_i)\n                    next_state = WRITE_FIFO;\n                else\n                    next_state = REQUEST;\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay)\n                    next_state = IDLE;\n                else\n                    next_state = DELAY;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output and control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            we <= 9'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    reset_tx_fifo <= !en;\n                    if (en) begin\n                        m_wb_adr_o <= adr + offset;\n                        m_wb_we_o <= 1'b0;\n                        m_wb_cyc_o <= 1'b1;\n                        m_wb_stb_o <= 1'b1;\n                        m_wb_cti_o <= 3'b000;\n                        m_wb_bte_o <= 2'b00;\n                    end\n                end\n                REQUEST: begin\n                    if (m_wb_ack_i) begin\n                        din <= m_wb_dat_i;\n                        wr_tx <= 1'b1;\n                        m_wb_cyc_o <= 1'b0;\n                        m_wb_stb_o <= 1'b0;\n                        delay <= 1'b1;\n                    end\n                end\n                WRITE_FIFO: begin\n                    wr_tx <= 1'b0;\n                    offset <= offset + 1;\n                    ackd <= ~ackd;\n                end\n                DELAY: begin\n                    delay <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // State encoding\n    localparam IDLE = 2'b00, REQUEST = 2'b01, WRITE_FIFO = 2'b10, DELAY = 2'b11;\n    reg [1:0] state, next_state;\n\n    // FIFO instance\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && ackd && !m_wb_ack_i) begin\n                    next_state = REQUEST;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            REQUEST: begin\n                if (m_wb_ack_i) begin\n                    next_state = WRITE_FIFO;\n                end else begin\n                    next_state = REQUEST;\n                end\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                if (delay) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DELAY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            din <= 32'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            offset <= 9'b0;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    reset_tx_fifo <= !en;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    m_wb_we_o <= 1'b0;\n                    if (en) begin\n                        reset_tx_fifo <= 1'b0;\n                    end\n                end\n                REQUEST: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_we_o <= 1'b0;\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                DELAY: begin\n                    wr_tx <= 1'b0;\n                    if (delay) begin\n                        offset <= offset + 1;\n                        ackd <= ~ackd;\n                        delay <= 1'b0;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 19, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC_16_gen instantiation\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 0)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt >= BIT_BLOCK_REC)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == READ_WAIT)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                    crc_ok <= 0;\n                end\n                WRITE_DAT: begin\n                    // Implement WRITE_DAT logic\n                end\n                WRITE_CRC: begin\n                    // Implement WRITE_CRC logic\n                end\n                WRITE_BUSY: begin\n                    // Implement WRITE_BUSY logic\n                end\n                READ_WAIT: begin\n                    // Implement READ_WAIT logic\n                end\n                READ_DAT: begin\n                    // Implement READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 17, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire we_m_tx_bd;\nwire we_m_rx_bd;\nwire new_cmd;\nwire we_ack;\nwire int_ack;\nwire cmd_int_busy;\nwire int_busy;\nwire write_req_s;\nwire [15:0] cmd_set_s;\nwire [31:0] cmd_arg_s;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules would be instantiated similarly\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 18, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire we_m_tx_bd;\nwire we_m_rx_bd;\nwire new_cmd;\nwire we_ack;\nwire int_ack;\nwire cmd_int_busy;\nwire int_busy;\nwire write_req_s;\nwire [15:0] cmd_set_s;\nwire [31:0] cmd_arg_s;\nwire [31:0] dat_in_m_tx_bd;\nwire [31:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb u_sd_controller_wb (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Other sub-modules instantiation would follow similarly...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 20, "code": "module sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_inst (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[16*i +: 16])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            6'd0: begin // IDLE\n                if (start_dat == 2'b10)\n                    next_state = 6'd1; // WRITE_DAT\n                else if (start_dat == 2'b01)\n                    next_state = 6'd4; // READ_WAIT\n                else\n                    next_state = 6'd0; // IDLE\n            end\n            6'd1: begin // WRITE_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'd2; // WRITE_CRC\n                else\n                    next_state = 6'd1; // WRITE_DAT\n            end\n            6'd2: begin // WRITE_CRC\n                if (crc_status == 0)\n                    next_state = 6'd3; // WRITE_BUSY\n                else\n                    next_state = 6'd2; // WRITE_CRC\n            end\n            6'd3: begin // WRITE_BUSY\n                if (!busy_int)\n                    next_state = 6'd0; // IDLE\n                else\n                    next_state = 6'd3; // WRITE_BUSY\n            end\n            6'd4: begin // READ_WAIT\n                if (!DAT_dat_i[0])\n                    next_state = 6'd5; // READ_DAT\n                else\n                    next_state = 6'd4; // READ_WAIT\n            end\n            6'd5: begin // READ_DAT\n                if (transf_cnt >= BIT_BLOCK)\n                    next_state = 6'd0; // IDLE\n                else\n                    next_state = 6'd5; // READ_DAT\n            end\n            default: next_state = 6'd0; // IDLE\n        endcase\n    end\n\n    // START_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1;\n        end else begin\n            if (!DAT_dat_i[0] && state == 6'd4)\n                q_start_bit <= 0;\n            else\n                q_start_bit <= 1;\n        end\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= 6'd0; // IDLE\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                6'd0: begin // IDLE\n                    crc_rst <= 1;\n                    crc_en <= 0;\n                    transf_cnt <= 0;\n                    rd <= 0;\n                    we <= 0;\n                    busy_n <= 1;\n                    transm_complete <= 0;\n                end\n                6'd1: begin // WRITE_DAT\n                    // Implement WRITE_DAT logic\n                end\n                6'd2: begin // WRITE_CRC\n                    // Implement WRITE_CRC logic\n                end\n                6'd3: begin // WRITE_BUSY\n                    // Implement WRITE_BUSY logic\n                end\n                6'd4: begin // READ_WAIT\n                    // Implement READ_WAIT logic\n                end\n                6'd5: begin // READ_DAT\n                    // Implement READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 19, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\n    wire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(),\n        .we_m_rx_bd(),\n        .new_cmd(),\n        .we_ack(),\n        .int_ack(),\n        .cmd_int_busy(),\n        .int_busy(),\n        .write_req_s(),\n        .cmd_set_s(),\n        .cmd_arg_s(),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    sd_clock_divider sd_clock_divider_inst (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_o_pad)\n    );\n\n    // Additional sub-module instantiations go here...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 20, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(),\n    .we_m_rx_bd(),\n    .new_cmd(),\n    .we_ack(),\n    .int_ack(),\n    .cmd_int_busy(),\n    .int_busy(),\n    .write_req_s(),\n    .cmd_set_s(),\n    .cmd_arg_s(),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(Bd_Status_reg),\n    .Bd_isr_reg(Bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// Additional sub-modules would be instantiated similarly\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 19, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? (BD_SIZE / 2) : (BD_SIZE / 4);\n\n    // Internal signals\n    reg [8:0] state, next_state;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_tx;\n                            if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_tx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_tx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_tx;\n                            if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) sys_adr <= dat_in_rx;\n                            if (bd_cnt == 1) cmd_arg <= dat_in_rx;\n                        end else begin\n                            if (bd_cnt == 0) sys_adr[15:0] <= dat_in_rx;\n                            if (bd_cnt == 1) sys_adr[31:16] <= dat_in_rx;\n                            if (bd_cnt == 2) cmd_arg[15:0] <= dat_in_rx;\n                            if (bd_cnt == 3) cmd_arg[31:16] <= dat_in_rx;\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) d_write <= 1;\n                    if (rx_cycle) d_read <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) start_rx_fifo <= 1;\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) rec_failed <= 1;\n                        else if (card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) rec_done <= 1;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) trans_done <= 1;\n                    if (rx_cycle && !rx_full) trans_done <= 1;\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end else begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) Dat_Int_Status[1] <= 1;\n                    if (!cmd_busy) we_req <= 1;\n                    if (we_ack) send_done <= 1;\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 20, "code": "module sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n    parameter READ_CYCLE = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n    parameter BD_EMPTY = (RAM_MEM_WIDTH == 32) ? BD_SIZE / 2 : BD_SIZE / 4;\n\n    // Internal signals\n    reg send_done;\n    reg rec_done;\n    reg rec_failed;\n    reg tx_cycle;\n    reg rx_cycle;\n    reg [2:0] resend_try_cnt;\n    reg [8:0] state, next_state;\n    reg trans_done;\n    reg trans_failed;\n    reg internal_transm_complete;\n    reg transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM_SEQ\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full == 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (send_done) begin\n                    next_state = RECIVE_CMD;\n                end\n            end\n            RECIVE_CMD: begin\n                if (rec_done) begin\n                    next_state = DATA_TRANSFER;\n                end else if (rec_failed) begin\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) begin\n                    next_state = IDLE;\n                end else if (trans_failed) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // FSM_OUT\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            resend_try_cnt <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    re_s_tx <= 0;\n                    a_cmp_tx <= 0;\n                    re_s_rx <= 0;\n                    a_cmp_rx <= 0;\n                    we_req <= 0;\n                    d_write <= 0;\n                    d_read <= 0;\n                    start_tx_fifo <= 0;\n                    start_rx_fifo <= 0;\n                    ack_transfer <= 0;\n                    send_done <= 0;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    tx_cycle <= 0;\n                    rx_cycle <= 0;\n                    resend_try_cnt <= 0;\n                    trans_done <= 0;\n                    trans_failed <= 0;\n                    internal_transm_complete <= 0;\n                    bd_cnt <= 0;\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    if (ack_i_s_tx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_tx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_tx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_tx;\n                                start_tx_fifo <= 1;\n                            end\n                        end\n                    end\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    if (ack_i_s_rx) begin\n                        bd_cnt <= bd_cnt + 1;\n                        if (RAM_MEM_WIDTH == 32) begin\n                            if (bd_cnt == 0) begin\n                                sys_adr <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                cmd_arg <= dat_in_rx;\n                            end\n                        end else begin\n                            if (bd_cnt == 0) begin\n                                sys_adr[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 1) begin\n                                sys_adr[31:16] <= dat_in_rx;\n                            end else if (bd_cnt == 2) begin\n                                cmd_arg[15:0] <= dat_in_rx;\n                            end else if (bd_cnt == 3) begin\n                                cmd_arg[31:16] <= dat_in_rx;\n                            end\n                        end\n                    end\n                    case (transfer_type)\n                        2'b00: cmd_set <= CMD17;\n                        2'b01: cmd_set <= ACMD13;\n                        default: cmd_set <= ACMD51;\n                    endcase\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    if (tx_cycle) begin\n                        d_write <= 1;\n                    end else if (rx_cycle) begin\n                        d_read <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (rx_cycle) begin\n                        start_rx_fifo <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) begin\n                            rec_failed <= 1;\n                        end else if (card_status[0] == 1 || card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6) begin\n                            rec_done <= 1;\n                        end\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (tx_cycle && !tx_empt) begin\n                        trans_done <= 1;\n                    end else if (rx_cycle && !rx_full) begin\n                        trans_done <= 1;\n                    end\n                    if (transm_complete && crc_ok) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end else if (!crc_ok) begin\n                        trans_failed <= 1;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    rec_done <= 0;\n                    rec_failed <= 0;\n                    send_done <= 0;\n                    trans_failed <= 0;\n                    trans_done <= 0;\n                    d_read <= 1;\n                    d_write <= 1;\n                    start_rx_fifo <= 0;\n                    start_tx_fifo <= 0;\n                end\n                STOP_SEND: begin\n                    resend_try_cnt <= resend_try_cnt + 1;\n                    if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                        Dat_Int_Status[1] <= 1;\n                    end\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                    end\n                    if (we_ack) begin\n                        send_done <= 1;\n                    end\n                end\n            endcase\n\n            if (Dat_Int_Status_rst) begin\n                Dat_Int_Status <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
