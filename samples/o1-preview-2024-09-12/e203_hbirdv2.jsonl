{"task": "e203_extend_csr", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_extend_csr(\n    input               clk,\n    input               rst_n,\n    input               nice_csr_valid,\n    output              nice_csr_ready,\n    input       [31:0]  nice_csr_addr,\n    input               nice_csr_wr,\n    input       [31:0]  nice_csr_wdata,\n    output      [31:0]  nice_csr_rdata\n    );\n\n  // The module is controlled by the macro E203_HAS_CSR_NICE.\n  // Currently, it provides basic interface definitions without actual functional implementation.\n  // Future functionality can be added under the `ifdef E203_HAS_CSR_NICE` directive.\n\n`ifdef E203_HAS_CSR_NICE\n  // Currently, the module always indicates ready and returns zero data.\n  assign nice_csr_ready = 1'b1;\n  assign nice_csr_rdata = 32'b0;\n`else\n  // If the feature is not enabled, outputs default values.\n  assign nice_csr_ready = 1'b1;\n  assign nice_csr_rdata = 32'b0;\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clkgate", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_clkgate(\n    input  clk_in,\n    input  test_mode,\n    input  clock_en,\n    output clk_out\n);\n\n`ifdef FPGA_SOURCE\n\n   // FPGA Mode: Direct clock connection\n   assign clk_out = clk_in;\n\n`else\n\n   // Gating Mode: Implement clock gating with enable latch\n   reg enb;\n\n   always @(*) begin\n       if (!clk_in) begin\n           enb = clock_en | test_mode;\n       end\n       // Latch retains previous value when clk_in is high\n   end\n\n   assign clk_out = clk_in & enb;\n\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_muldiv", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_alu_muldiv(\n  input                         mdv_nob2b,\n  input                         muldiv_i_valid,\n  output                        muldiv_i_ready,\n  input  [`E203_XLEN-1:0]       muldiv_i_rs1,\n  input  [`E203_XLEN-1:0]       muldiv_i_rs2,\n  input  [`E203_XLEN-1:0]       muldiv_i_imm,\n  input  [`E203_DECINFO_MULDIV_WIDTH-1:0] muldiv_i_info,\n  input  [`E203_ITAG_WIDTH-1:0] muldiv_i_itag,\n  output                        muldiv_i_longpipe,\n  input                         flush_pulse,\n  output                        muldiv_o_valid,\n  input                         muldiv_o_ready,\n  output [`E203_XLEN-1:0]       muldiv_o_wbck_wdat,\n  output                        muldiv_o_wbck_err,\n  output [`E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n  output [`E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n  output                        muldiv_req_alu_add,\n  output                        muldiv_req_alu_sub,\n  input  [`E203_MULDIV_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n  output                        muldiv_sbf_0_ena,\n  output [32:0]                 muldiv_sbf_0_nxt,\n  input  [32:0]                 muldiv_sbf_0_r,\n  output                        muldiv_sbf_1_ena,\n  output [32:0]                 muldiv_sbf_1_nxt,\n  input  [32:0]                 muldiv_sbf_1_r,\n  input                         clk,\n  input                         rst_n\n);\n\n  // FSM State Encoding\n  localparam MULDIV_STATE_0TH       = 3'd0;\n  localparam MULDIV_STATE_EXEC      = 3'd1;\n  localparam MULDIV_STATE_REMD_CHCK = 3'd2;\n  localparam MULDIV_STATE_QUOT_CORR = 3'd3;\n  localparam MULDIV_STATE_REMD_CORR = 3'd4;\n\n  // FSM State Register\n  reg [2:0] muldiv_state;\n  wire fsm_reset = ~rst_n | flush_pulse;\n\n  // Cycle Counter\n  reg [5:0] muldiv_counter;\n  wire muldiv_counter_zero = (muldiv_counter == 6'd0);\n\n  // Input Instruction Decoding\n  wire is_mul    = muldiv_i_info[`E203_DECINFO_MULDIV_MUL];\n  wire is_mulh   = muldiv_i_info[`E203_DECINFO_MULDIV_MULH];\n  wire is_mulhsu = muldiv_i_info[`E203_DECINFO_MULDIV_MULHSU];\n  wire is_mulhu  = muldiv_i_info[`E203_DECINFO_MULDIV_MULHU];\n  wire is_div    = muldiv_i_info[`E203_DECINFO_MULDIV_DIV];\n  wire is_divu   = muldiv_i_info[`E203_DECINFO_MULDIV_DIVU];\n  wire is_rem    = muldiv_i_info[`E203_DECINFO_MULDIV_REM];\n  wire is_remu   = muldiv_i_info[`E203_DECINFO_MULDIV_REMU];\n  wire is_b2b    = ~mdv_nob2b & muldiv_i_info[`E203_DECINFO_MULDIV_B2B];\n\n  wire muldiv_en = is_mul | is_mulh | is_mulhsu | is_mulhu |\n                   is_div | is_divu | is_rem | is_remu;\n\n  // Operand Registers\n  reg [`E203_XLEN-1:0] op_a;\n  reg [`E203_XLEN-1:0] op_b;\n  reg [`E203_XLEN-1:0] muldiv_res;\n  reg                  muldiv_res_sign;\n\n  // Handshake Signals\n  assign muldiv_i_ready = (muldiv_state == MULDIV_STATE_0TH);\n  assign muldiv_i_longpipe = muldiv_en;\n\n  // Output Signals\n  reg muldiv_o_valid_r;\n  assign muldiv_o_valid = muldiv_o_valid_r;\n  assign muldiv_o_wbck_err = 1'b0;\n\n  // ALU Interface Signals\n  reg [`E203_MULDIV_ADDER_WIDTH-1:0] alu_op1;\n  reg [`E203_MULDIV_ADDER_WIDTH-1:0] alu_op2;\n  reg alu_add;\n  reg alu_sub;\n\n  assign muldiv_req_alu_op1 = alu_op1;\n  assign muldiv_req_alu_op2 = alu_op2;\n  assign muldiv_req_alu_add = alu_add;\n  assign muldiv_req_alu_sub = alu_sub;\n\n  // Shared Buffer Enable Signals\n  reg sbf_0_ena;\n  reg [32:0] sbf_0_nxt;\n  reg sbf_1_ena;\n  reg [32:0] sbf_1_nxt;\n\n  assign muldiv_sbf_0_ena = sbf_0_ena;\n  assign muldiv_sbf_0_nxt = sbf_0_nxt;\n  assign muldiv_sbf_1_ena = sbf_1_ena;\n  assign muldiv_sbf_1_nxt = sbf_1_nxt;\n\n  // FSM Implementation\n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      muldiv_state <= MULDIV_STATE_0TH;\n      muldiv_counter <= 6'd0;\n      muldiv_o_valid_r <= 1'b0;\n      op_a <= {`E203_XLEN{1'b0}};\n      op_b <= {`E203_XLEN{1'b0}};\n    end else begin\n      if (flush_pulse) begin\n        muldiv_state <= MULDIV_STATE_0TH;\n        muldiv_o_valid_r <= 1'b0;\n      end else begin\n        case (muldiv_state)\n          MULDIV_STATE_0TH: begin\n            if (muldiv_i_valid & muldiv_i_ready) begin\n              // Latch operands\n              op_a <= muldiv_i_rs1;\n              op_b <= muldiv_i_rs2;\n\n              if (is_mul | is_mulh | is_mulhsu | is_mulhu) begin\n                muldiv_state <= MULDIV_STATE_EXEC;\n                muldiv_counter <= 6'd16; // 17 cycles for multiplier\n              end else if (is_div | is_divu | is_rem | is_remu) begin\n                muldiv_state <= MULDIV_STATE_EXEC;\n                muldiv_counter <= 6'd32; // 33 cycles for divider\n              end\n            end\n          end\n\n          MULDIV_STATE_EXEC: begin\n            if (muldiv_counter_zero) begin\n              if (is_div | is_divu | is_rem | is_remu) begin\n                // Check for division corrections\n                muldiv_state <= MULDIV_STATE_REMD_CHCK;\n              end else begin\n                muldiv_o_valid_r <= 1'b1;\n                if (muldiv_o_ready) begin\n                  muldiv_o_valid_r <= 1'b0;\n                  muldiv_state <= MULDIV_STATE_0TH;\n                end\n              end\n            end else begin\n              muldiv_counter <= muldiv_counter - 1'b1;\n            end\n          end\n\n          MULDIV_STATE_REMD_CHCK: begin\n            // Placeholder for remainder check logic\n            // Transition to correction states if needed\n            muldiv_state <= MULDIV_STATE_QUOT_CORR;\n          end\n\n          MULDIV_STATE_QUOT_CORR: begin\n            // Placeholder for quotient correction logic\n            muldiv_state <= MULDIV_STATE_REMD_CORR;\n          end\n\n          MULDIV_STATE_REMD_CORR: begin\n            // Placeholder for remainder correction logic\n            muldiv_o_valid_r <= 1'b1;\n            if (muldiv_o_ready) begin\n              muldiv_o_valid_r <= 1'b0;\n              muldiv_state <= MULDIV_STATE_0TH;\n            end\n          end\n\n          default: begin\n            muldiv_state <= MULDIV_STATE_0TH;\n          end\n        endcase\n      end\n    end\n  end\n\n  // Placeholder for multiplicand and multiplier handling using Booth encoding\n  // Placeholder for divider implementation and special case handling\n\n  // Output write-back data (for simulation purposes, assign result directly)\n  assign muldiv_o_wbck_wdat = muldiv_res;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_minidec", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_ifu_minidec(\n  input  [`E203_INSTR_SIZE-1:0] instr,\n\n  output dec_rs1en,\n  output dec_rs2en,\n  output [`E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n  output [`E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n  output dec_mulhsu,\n  output dec_mul,\n  output dec_div,\n  output dec_rem,\n  output dec_divu,\n  output dec_remu,\n  output dec_rv32,\n  output dec_bjp,\n  output dec_jal,\n  output dec_jalr,\n  output dec_bxx,\n  output [`E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n  output [`E203_XLEN-1:0] dec_bjp_imm\n);\n\ne203_exu_decode u_e203_exu_decode (\n  .i_instr           (instr),\n  .i_pc              (`E203_PC_SIZE'b0),\n  .i_prdt_taken      (1'b0),\n  .i_muldiv_b2b      (1'b0),\n  .i_misalgn         (1'b0),\n  .i_buserr          (1'b0),\n  .dbg_mode          (1'b0),\n\n  .dec_rs1x0         (), // Unused\n  .dec_rs2x0         (), // Unused\n  .dec_rs1en         (dec_rs1en),\n  .dec_rs2en         (dec_rs2en),\n  .dec_rdwen         (), // Unused\n  .dec_rs1idx        (dec_rs1idx),\n  .dec_rs2idx        (dec_rs2idx),\n  .dec_rdidx         (), // Unused\n\n  .dec_info          (), // Unused\n  .dec_imm           (), // Unused\n  .dec_pc            (), // Unused\n  .dec_misalgn       (), // Unused\n  .dec_buserr        (), // Unused\n  .dec_ilegl         (), // Unused\n\n  .dec_mulhsu        (dec_mulhsu),\n  .dec_mul           (dec_mul),\n  .dec_div           (dec_div),\n  .dec_rem           (dec_rem),\n  .dec_divu          (dec_divu),\n  .dec_remu          (dec_remu),\n  .dec_rv32          (dec_rv32),\n  .dec_bjp           (dec_bjp),\n  .dec_jal           (dec_jal),\n  .dec_jalr          (dec_jalr),\n  .dec_bxx           (dec_bxx),\n  .dec_jalr_rs1idx   (dec_jalr_rs1idx),\n  .dec_bjp_imm       (dec_bjp_imm)\n\n  // NICE-related signals\n  `ifdef E203_HAS_NICE\n  , .dec_nice             ()    // Unused\n  , .nice_xs_off          (1'b0)\n  , .nice_cmt_off_ilgl_o  ()    // Unused\n  `endif\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ram", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_dtcm_ram (\n    input                           sd,     // Power domain shutdown enable signal for power management\n    input                           ds,     // Deep sleep mode enable\n    input                           ls,     // Light sleep mode enable\n    input                           cs,     // Chip select signal\n    input                           we,     // Write enable signal\n    input  [E203_DTCM_RAM_AW-1:0]   addr,   // Address input\n    input  [E203_DTCM_RAM_MW-1:0]   wem,    // Write mask\n    input  [E203_DTCM_RAM_DW-1:0]   din,    // Data input\n    input                           rst_n,  // Asynchronous reset signal (active low)\n    input                           clk,    // System clock\n    output [E203_DTCM_RAM_DW-1:0]   dout    // Data output\n);\n\nsirv_gnrl_ram #(\n    .FORCE_X2ZERO(1),\n    .DP         (E203_DTCM_RAM_DP),\n    .DW         (E203_DTCM_RAM_DW),\n    .MW         (E203_DTCM_RAM_MW),\n    .AW         (E203_DTCM_RAM_AW)\n) u_e203_dtcm_gnrl_ram (\n    .sd     (sd),\n    .ds     (ds),\n    .ls     (ls),\n    .rst_n  (rst_n),\n    .clk    (clk),\n    .cs     (cs),\n    .we     (we),\n    .addr   (addr),\n    .din    (din),\n    .wem    (wem),\n    .dout   (dout)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_clk_ctrl", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_clk_ctrl(\n    input  wire clk,\n    input  wire rst_n,\n    input  wire test_mode,\n    input  wire core_cgstop,\n\n    // Functional Unit Activity State Signals\n    input  wire core_ifu_active,\n    input  wire core_exu_active,\n    input  wire core_lsu_active,\n    input  wire core_biu_active,\n    input  wire core_wfi,\n\n    // Clock Output Signals\n    output wire clk_aon,\n    output wire clk_core_ifu,\n    output wire clk_core_exu,\n    output wire clk_core_lsu,\n    output wire clk_core_biu\n\n    // Optional Signals\n    `ifdef E203_HAS_ITCM\n    ,\n    input  wire itcm_active,\n    output wire itcm_ls,\n    output wire clk_itcm\n    `endif\n\n    `ifdef E203_HAS_DTCM\n    ,\n    input  wire dtcm_active,\n    output wire dtcm_ls,\n    output wire clk_dtcm\n    `endif\n);\n\n// Generate always-on clock\nassign clk_aon = clk;\n\n// Clock enable control logic for IFU\nwire ifu_clk_en = core_cgstop | (core_ifu_active & (~core_wfi));\n\n// Clock enable control logic for other modules\nwire exu_clk_en = core_cgstop | core_exu_active;\nwire lsu_clk_en = core_cgstop | core_lsu_active;\nwire biu_clk_en = core_cgstop | core_biu_active;\n\n`ifdef E203_HAS_ITCM\n// Clock enable control logic for ITCM\nreg itcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        itcm_active_r <= 1'b0;\n    else\n        itcm_active_r <= itcm_active;\nend\n\nwire itcm_clk_en = core_cgstop | itcm_active | itcm_active_r;\n// Light sleep signal\nassign itcm_ls = ~(itcm_active | itcm_active_r);\n`endif\n\n`ifdef E203_HAS_DTCM\n// Clock enable control logic for DTCM\nreg dtcm_active_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dtcm_active_r <= 1'b0;\n    else\n        dtcm_active_r <= dtcm_active;\nend\n\nwire dtcm_clk_en = core_cgstop | dtcm_active | dtcm_active_r;\n// Light sleep signal\nassign dtcm_ls = ~(dtcm_active | dtcm_active_r);\n`endif\n\n// Instantiate clock gating cells\n// Assuming e203_clkgate module has the following ports:\n// .clk_in, .en, .test_mode, .clk_out\n\ne203_clkgate u_e203_clkgate_ifu(\n    .clk_in    (clk),\n    .en        (ifu_clk_en),\n    .test_mode (test_mode),\n    .clk_out   (clk_core_ifu)\n);\n\ne203_clkgate u_e203_clkgate_exu(\n    .clk_in    (clk),\n    .en        (exu_clk_en),\n    .test_mode (test_mode),\n    .clk_out   (clk_core_exu)\n);\n\ne203_clkgate u_e203_clkgate_lsu(\n    .clk_in    (clk),\n    .en        (lsu_clk_en),\n    .test_mode (test_mode),\n    .clk_out   (clk_core_lsu)\n);\n\ne203_clkgate u_e203_clkgate_biu(\n    .clk_in    (clk),\n    .en        (biu_clk_en),\n    .test_mode (test_mode),\n    .clk_out   (clk_core_biu)\n);\n\n`ifdef E203_HAS_ITCM\ne203_clkgate u_e203_clkgate_itcm(\n    .clk_in    (clk),\n    .en        (itcm_clk_en),\n    .test_mode (test_mode),\n    .clk_out   (clk_itcm)\n);\n`endif\n\n`ifdef E203_HAS_DTCM\ne203_clkgate u_e203_clkgate_dtcm(\n    .clk_in    (clk),\n    .en        (dtcm_clk_en),\n    .test_mode (test_mode),\n    .clk_out   (clk_dtcm)\n);\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_reset_ctrl", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_reset_ctrl #(\n    parameter MASTER = 1,\n    parameter RST_SYNC_LEVEL = `E203_ASYNC_FF_LEVELS\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire test_mode,\n\n    output wire rst_core,\n`ifdef E203_HAS_ITCM\n    output wire rst_itcm,\n`endif\n`ifdef E203_HAS_DTCM\n    output wire rst_dtcm,\n`endif\n    output wire rst_aon\n);\n\nwire reset_sync_int;\n\ngenerate\n    if (MASTER) begin : master_reset_ctrl\n        reg [RST_SYNC_LEVEL-1:0] reset_sync_r;\n\n        always @(posedge clk or negedge rst_n) begin\n            if (!rst_n) begin\n                reset_sync_r <= {RST_SYNC_LEVEL{1'b1}};\n            end else begin\n                reset_sync_r <= {1'b0, reset_sync_r[RST_SYNC_LEVEL-1:1]};\n            end\n        end\n\n        assign reset_sync_int = reset_sync_r[0];\n\n    end else begin : slave_reset_ctrl\n        assign reset_sync_int = ~rst_n;\n    end\nendgenerate\n\nwire reset_sync;\n\nassign reset_sync = test_mode ? ~rst_n : reset_sync_int;\n\n// Output assignments\nassign rst_core = reset_sync;\n`ifdef E203_HAS_ITCM\nassign rst_itcm = reset_sync;\n`endif\n`ifdef E203_HAS_DTCM\nassign rst_dtcm = reset_sync;\n`endif\nassign rst_aon = reset_sync;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_lsu_ctrl (\n    // Control Interface\n    input                           commit_mret,     // MRET commit instruction signal\n    input                           commit_trap,     // Trap commit signal\n    output                          lsu_ctrl_active, // Indication of the active state of the LSU control module\n    \n    // LSU Write-back Interface\n    output                          lsu_o_valid,       // Write-back data valid signal\n    input                           lsu_o_ready,       // Write-back interface ready signal\n    output       [E203_XLEN-1:0]    lsu_o_wbck_wdat,   // Write-back data\n    output       [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag, // Instruction tag\n    output                          lsu_o_wbck_err,    // Error indication signal\n    output                          lsu_o_cmt_buserr,  // Bus error exception indication\n    output       [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr, // Error address\n    output                          lsu_o_cmt_ld,      // Load instruction commit indication\n    output                          lsu_o_cmt_st,      // Store instruction commit indication\n    \n    // AGU-ICB Interface\n    input                           agu_icb_cmd_valid,    // Command valid signal\n    output                          agu_icb_cmd_ready,    // Command ready signal\n    input        [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,     // Access address\n    input                           agu_icb_cmd_read,     // Read/write control (1: read, 0: write)\n    input        [E203_XLEN-1:0]    agu_icb_cmd_wdata,    // Write data\n    input        [E203_XLEN/8-1:0]  agu_icb_cmd_wmask,    // Byte write enable\n    input                           agu_icb_cmd_lock,     // Lock signal\n    input                           agu_icb_cmd_excl,     // Exclusive access signal\n    input        [1:0]              agu_icb_cmd_size,     // Access size (00: byte, 01: half, 10: word)\n    input                           agu_icb_cmd_back2agu, // Indication that the response needs to be returned to the AGU\n    input                           agu_icb_cmd_usign,    // Unsigned load indication\n    input        [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,  // Instruction tag\n    \n    // AGU-ICB Response Interface\n    output                          agu_icb_rsp_valid,   // Response valid signal\n    input                           agu_icb_rsp_ready,   // Response receive ready signal\n    output                          agu_icb_rsp_err,     // Error response indication\n    output                          agu_icb_rsp_excl_ok, // Exclusive access success indication\n    output       [E203_XLEN-1:0]    agu_icb_rsp_rdata,   // Read data\n    \n    // NICE Interface (Optional Configuration)\n`ifdef E203_HAS_NICE\n    input                           nice_mem_holdup,     // Memory access hold signal\n    input                           nice_icb_cmd_valid,  // Command valid signal\n    output                          nice_icb_cmd_ready,  // Command ready signal\n    input        [E203_ADDR_SIZE-1:0] nice_icb_cmd_addr, // Access address\n    input                           nice_icb_cmd_read,   // Read/write control\n    input        [E203_XLEN-1:0]    nice_icb_cmd_wdata,  // Write data\n    input        [E203_XLEN/8-1:0]  nice_icb_cmd_wmask,  // Write mask\n    output                          nice_icb_rsp_valid,  // Response valid signal\n    input                           nice_icb_rsp_ready,  // Response ready signal\n    output                          nice_icb_rsp_err,    // Error indication\n    output       [E203_XLEN-1:0]    nice_icb_rsp_rdata,  // Read data\n`endif\n    \n    // DCache Interface (Optional Configuration)\n`ifdef E203_HAS_DCACHE\n    output                          dcache_icb_cmd_valid,   // Command valid signal\n    input                           dcache_icb_cmd_ready,   // Command ready signal\n    output       [E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,  // Access address\n    output                          dcache_icb_cmd_read,    // Read/write control signal (1: Read, 0: Write)\n    output       [E203_XLEN-1:0]    dcache_icb_cmd_wdata,   // Write data\n    output       [E203_XLEN/8-1:0]  dcache_icb_cmd_wmask,   // Write mask\n    output                          dcache_icb_cmd_lock,    // Lock signal\n    output                          dcache_icb_cmd_excl,    // Exclusive access signal\n    output       [1:0]              dcache_icb_cmd_size,    // Access size\n    input                           dcache_icb_rsp_valid,   // Response valid signal\n    output                          dcache_icb_rsp_ready,   // Response ready signal\n    input                           dcache_icb_rsp_err,     // Error signal\n    input                           dcache_icb_rsp_excl_ok, // Exclusive access success signal\n    input        [E203_XLEN-1:0]    dcache_icb_rsp_rdata,   // Read data\n`endif\n\n    // DTCM Interface (Optional Configuration)\n`ifdef E203_HAS_DTCM\n    output                          dtcm_icb_cmd_valid,     // Command valid signal\n    input                           dtcm_icb_cmd_ready,     // Command ready signal\n    output       [E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr, // Access address\n    output                          dtcm_icb_cmd_read,      // Read/write control signal (1: Read, 0: Write)\n    output       [E203_XLEN-1:0]    dtcm_icb_cmd_wdata,     // Write data\n    output       [E203_XLEN/8-1:0]  dtcm_icb_cmd_wmask,     // Write mask\n    output                          dtcm_icb_cmd_lock,      // Lock signal\n    output                          dtcm_icb_cmd_excl,      // Exclusive access signal\n    output       [1:0]              dtcm_icb_cmd_size,      // Access size\n    input                           dtcm_icb_rsp_valid,     // Response valid signal\n    output                          dtcm_icb_rsp_ready,     // Response ready signal\n    input                           dtcm_icb_rsp_err,       // Error signal\n    input                           dtcm_icb_rsp_excl_ok,   // Exclusive access success signal\n    input        [E203_XLEN-1:0]    dtcm_icb_rsp_rdata,     // Read data\n    input        [E203_ADDR_SIZE-1:0] dtcm_region_indic,    // Indicates if the current address belongs to the DTCM region\n`endif\n\n    // ITCM Interface (Optional Configuration)\n`ifdef E203_HAS_ITCM\n    output                          itcm_icb_cmd_valid,     // Command valid signal\n    input                           itcm_icb_cmd_ready,     // Command ready signal\n    output       [E203_ITCM_ADDR_WIDTH-1:0] itcm_icb_cmd_addr, // Access address\n    output                          itcm_icb_cmd_read,      // Read/write control signal (1: Read, 0: Write)\n    output       [E203_XLEN-1:0]    itcm_icb_cmd_wdata,     // Write data\n    output       [E203_XLEN/8-1:0]  itcm_icb_cmd_wmask,     // Write mask\n    output                          itcm_icb_cmd_lock,      // Lock signal\n    output                          itcm_icb_cmd_excl,      // Exclusive access signal\n    output       [1:0]              itcm_icb_cmd_size,      // Access size\n    input                           itcm_icb_rsp_valid,     // Response valid signal\n    output                          itcm_icb_rsp_ready,     // Response ready signal\n    input                           itcm_icb_rsp_err,       // Error signal\n    input                           itcm_icb_rsp_excl_ok,   // Exclusive access success signal\n    input        [E203_XLEN-1:0]    itcm_icb_rsp_rdata,     // Read data\n    input        [E203_ADDR_SIZE-1:0] itcm_region_indic,    // Indicates if the current address belongs to the ITCM region\n`endif\n\n    // BIU Interface\n    output                          biu_icb_cmd_valid,      // Command valid signal\n    input                           biu_icb_cmd_ready,      // Command ready signal\n    output       [E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,     // Access address\n    output                          biu_icb_cmd_read,       // Read/write control signal (1: Read, 0: Write)\n    output       [E203_XLEN-1:0]    biu_icb_cmd_wdata,      // Write data\n    output       [E203_XLEN/8-1:0]  biu_icb_cmd_wmask,      // Write mask\n    output                          biu_icb_cmd_lock,       // Lock signal\n    output                          biu_icb_cmd_excl,       // Exclusive access signal\n    output       [1:0]              biu_icb_cmd_size,       // Access size\n    input                           biu_icb_rsp_valid,      // Response valid signal\n    output                          biu_icb_rsp_ready,      // Response ready signal\n    input                           biu_icb_rsp_err,        // Error signal\n    input                           biu_icb_rsp_excl_ok,    // Exclusive access success signal\n    input        [E203_XLEN-1:0]    biu_icb_rsp_rdata       // Read data\n);\n\n// Module internal logic and signal declarations\n// ...\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_branchslv", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_branchslv(\n    input  wire                 cmt_i_valid, \n    output wire                 cmt_i_ready, \n    input  wire                 cmt_i_rv32,  \n    input  wire                 cmt_i_dret,  \n    input  wire                 cmt_i_mret,  \n    input  wire                 cmt_i_fencei,\n    input  wire                 cmt_i_bjp,   \n    input  wire                 cmt_i_bjp_prdt, \n    input  wire                 cmt_i_bjp_rslv,\n    input  wire [E203_PC_SIZE-1:0]  cmt_i_pc,   \n    input  wire [E203_XLEN-1:0]     cmt_i_imm,  \n    input  wire [E203_PC_SIZE-1:0]  csr_epc_r,  \n    input  wire [E203_PC_SIZE-1:0]  csr_dpc_r,  \n    input  wire                 nonalu_excpirq_flush_req_raw, \n    input  wire                 brchmis_flush_ack, \n    output wire                 brchmis_flush_req, \n    output wire [E203_PC_SIZE-1:0]  brchmis_flush_add_op1,\n    output wire [E203_PC_SIZE-1:0]  brchmis_flush_add_op2,\n    output wire [E203_PC_SIZE-1:0]  brchmis_flush_pc, \n    output wire                 cmt_mret_ena, \n    output wire                 cmt_dret_ena, \n    output wire                 cmt_fencei_ena,\n    input  wire                 clk,\n    input  wire                 rst_n\n);\n\n// Flush Need Generation\nwire bjp_mispred = cmt_i_bjp & (cmt_i_bjp_prdt ^ cmt_i_bjp_rslv);\nwire flush_need = bjp_mispred | cmt_i_fencei | cmt_i_mret | cmt_i_dret;\n\n// Pipeline Flush Control\nassign brchmis_flush_req = flush_need & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n\n// Controls the ready signal for the instruction (cmt_i_ready)\nwire inst_is_not_ctrl = ~(cmt_i_bjp | cmt_i_fencei | cmt_i_mret | cmt_i_dret);\nwire no_flush_pending = ~flush_need | brchmis_flush_ack;\n\nassign cmt_i_ready = inst_is_not_ctrl | (~nonalu_excpirq_flush_req_raw & no_flush_pending);\n\n// Flush handshake completion\nwire flush_handshake = brchmis_flush_req & brchmis_flush_ack & cmt_i_valid & ~nonalu_excpirq_flush_req_raw;\n\n// Special Signal Commit\nassign cmt_mret_ena    = cmt_i_mret    & flush_handshake;\nassign cmt_dret_ena    = cmt_i_dret    & flush_handshake;\nassign cmt_fencei_ena  = cmt_i_fencei  & flush_handshake;\n\n// Branch Misprediction Flush Target Calculation\nwire [E203_PC_SIZE-1:0] pc_incr = cmt_i_rv32 ? `E203_PC_SIZE'd4 : `E203_PC_SIZE'd2;\nwire [E203_PC_SIZE-1:0] next_pc = cmt_i_pc + pc_incr;\n\nwire cond_branch1 = cmt_i_fencei | (cmt_i_bjp & cmt_i_bjp_prdt & ~cmt_i_bjp_rslv);\nwire cond_branch2 = cmt_i_bjp & ~cmt_i_bjp_prdt & cmt_i_bjp_rslv;\nwire cond_dret    = cmt_i_dret;\nwire cond_mret    = cmt_i_mret;\n\nreg [E203_PC_SIZE-1:0] brchmis_flush_pc_r;\n\nalways @(*) begin\n    if (cond_branch1) begin\n        brchmis_flush_pc_r = next_pc;\n    end else if (cond_branch2) begin\n        brchmis_flush_pc_r = cmt_i_pc + cmt_i_imm[E203_PC_SIZE-1:0];\n    end else if (cond_dret) begin\n        brchmis_flush_pc_r = csr_dpc_r;\n    end else begin // cond_mret or default\n        brchmis_flush_pc_r = csr_epc_r;\n    end\nend\n\nassign brchmis_flush_pc = brchmis_flush_pc_r;\n\n// Since E203_TIMING_BOOST is defined, brchmis_flush_add_op1 and brchmis_flush_add_op2 are not used\nassign brchmis_flush_add_op1 = {E203_PC_SIZE{1'b0}};\nassign brchmis_flush_add_op2 = {E203_PC_SIZE{1'b0}};\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_wbck", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_wbck (\n    input                           alu_wbck_i_valid    ,\n    output                          alu_wbck_i_ready    ,\n    input  [E203_XLEN-1:0]          alu_wbck_i_wdat     ,\n    input  [E203_RFIDX_WIDTH-1:0]   alu_wbck_i_rdidx    ,\n\n    input                           longp_wbck_i_valid  ,\n    output                          longp_wbck_i_ready  ,\n    input  [E203_FLEN-1:0]          longp_wbck_i_wdat   ,\n    input  [4:0]                    longp_wbck_i_flags  ,\n    input  [E203_RFIDX_WIDTH-1:0]   longp_wbck_i_rdidx  ,\n    input                           longp_wbck_i_rdfpu  ,\n\n    output                          rf_wbck_o_ena       ,\n    output [E203_XLEN-1:0]          rf_wbck_o_wdat      ,\n    output [E203_RFIDX_WIDTH-1:0]   rf_wbck_o_rdidx     ,\n\n    input                           clk                 ,\n    input                           rst_n               \n);\n\n  // Arbitration logic\n  wire wbck_i_sel_longp = longp_wbck_i_valid;\n  wire wbck_i_sel_alu   = ~longp_wbck_i_valid;\n\n  wire                    wbck_i_valid = wbck_i_sel_longp ? longp_wbck_i_valid : alu_wbck_i_valid;\n  wire [E203_FLEN-1:0]    wbck_i_wdat;\n  wire [E203_RFIDX_WIDTH-1:0] wbck_i_rdidx;\n  wire                    wbck_i_rdfpu;\n  wire [4:0]              wbck_i_flags;\n\n  // Data width handling for ALU write-back data\n`ifdef E203_FLEN_IS_32\n  wire [E203_FLEN-1:0] alu_wbck_wdat_ext = alu_wbck_i_wdat;\n`else\n  wire [E203_FLEN-1:0] alu_wbck_wdat_ext = {{(E203_FLEN - E203_XLEN){1'b0}}, alu_wbck_i_wdat};\n`endif\n\n  assign wbck_i_wdat  = wbck_i_sel_longp ? longp_wbck_i_wdat : alu_wbck_wdat_ext;\n  assign wbck_i_rdidx = wbck_i_sel_longp ? longp_wbck_i_rdidx : alu_wbck_i_rdidx;\n  assign wbck_i_rdfpu = wbck_i_sel_longp ? longp_wbck_i_rdfpu : 1'b0; // ALU wbck_i_rdfpu is 0\n  assign wbck_i_flags = wbck_i_sel_longp ? longp_wbck_i_flags : 5'b0; // ALU wbck_i_flags are 0\n\n  // Ready signals\n  assign longp_wbck_i_ready = 1'b1;\n  assign alu_wbck_i_ready   = (~longp_wbck_i_valid) ? 1'b1 : 1'b0;\n\n  // rf_wbck_o_ena is set to 1 if write-back is valid and destination is not FPU register\n  assign rf_wbck_o_ena   = wbck_i_valid & (~wbck_i_rdfpu);\n\n  // Output write-back data to register file\n  assign rf_wbck_o_wdat  = wbck_i_wdat[E203_XLEN-1:0];\n  assign rf_wbck_o_rdidx = wbck_i_rdidx;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ift2icb", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_ifu_ift2icb(\n  input  wire                     itcm_nohold,\n  input  wire                     ifu_req_valid,\n  input  wire [PC_SIZE-1:0]       ifu_req_pc,\n  input  wire                     ifu_req_seq,\n  input  wire                     ifu_req_seq_rv32,\n  input  wire [PC_SIZE-1:0]       ifu_req_last_pc,\n  output wire                     ifu_req_ready,\n  output wire                     ifu_rsp_valid,\n  output wire                     ifu_rsp_err,\n  output wire [31:0]              ifu_rsp_instr,\n  input  wire                     ifu_rsp_ready,\n  // ITCM Interface\n  output wire                     ifu2itcm_icb_cmd_valid,\n  input  wire                     ifu2itcm_icb_cmd_ready,\n  output wire [ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n  input  wire                     ifu2itcm_icb_rsp_valid,\n  output wire                     ifu2itcm_icb_rsp_ready,\n  input  wire                     ifu2itcm_icb_rsp_err,\n  input  wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n  // System Memory Interface\n  output wire                     ifu2biu_icb_cmd_valid,\n  input  wire                     ifu2biu_icb_cmd_ready,\n  output wire [ADDR_SIZE-1:0]     ifu2biu_icb_cmd_addr,\n  input  wire                     ifu2biu_icb_rsp_valid,\n  output wire                     ifu2biu_icb_rsp_ready,\n  input  wire                     ifu2biu_icb_rsp_err,\n  input  wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata,\n  // Clock and Reset\n  input  wire                     clk,\n  input  wire                     rst_n\n);\n\n  //===========================================================================\n  // State Machine Implementation\n  //===========================================================================\n  // State Definitions\n  localparam ICB_STATE_IDLE     = 2'b00;\n  localparam ICB_STATE_1ST      = 2'b01;\n  localparam ICB_STATE_WAIT2ND  = 2'b10;\n  localparam ICB_STATE_2ND      = 2'b11;\n\n  reg [1:0] icb_state;\n  wire [1:0] icb_state_nxt;\n  wire       icb_state_ena;\n\n  wire icb_sta_is_idle    = (icb_state == ICB_STATE_IDLE);\n  wire icb_sta_is_1st     = (icb_state == ICB_STATE_1ST);\n  wire icb_sta_is_wait2nd = (icb_state == ICB_STATE_WAIT2ND);\n  wire icb_sta_is_2nd     = (icb_state == ICB_STATE_2ND);\n\n  // Handshake Signals\n  wire ifu_req_hsked     = ifu_req_valid & ifu_req_ready;\n  wire ifu_icb_cmd_hsked = ifu_icb_cmd_valid & ifu_icb_cmd_ready;\n  wire ifu_icb_rsp_hsked = ifu_icb_rsp_valid & ifu_icb_rsp_ready;\n  wire i_ifu_rsp_valid;\n  wire i_ifu_rsp_ready   = ifu_rsp_ready;\n  wire i_ifu_rsp_hsked   = i_ifu_rsp_valid & i_ifu_rsp_ready;\n\n  // State Transition Logic\n  always @(*) begin\n    icb_state_ena = 1'b0;\n    icb_state_nxt = icb_state;\n    case (icb_state)\n      ICB_STATE_IDLE: begin\n        if (ifu_req_hsked) begin\n          icb_state_ena = 1'b1;\n          icb_state_nxt = ICB_STATE_1ST;\n        end\n      end\n      ICB_STATE_1ST: begin\n        if (/* conditions to go to WAIT2ND */) begin\n          icb_state_ena = 1'b1;\n          icb_state_nxt = ICB_STATE_WAIT2ND;\n        end else if (/* conditions to stay in 1ST */) begin\n          icb_state_ena = 1'b1;\n          icb_state_nxt = ICB_STATE_1ST;\n        end else if (/* conditions to go to IDLE */) begin\n          icb_state_ena = 1'b1;\n          icb_state_nxt = ICB_STATE_IDLE;\n        end\n      end\n      ICB_STATE_WAIT2ND: begin\n        if (ifu_icb_cmd_ready) begin\n          icb_state_ena = 1'b1;\n          icb_state_nxt = ICB_STATE_2ND;\n        end\n      end\n      ICB_STATE_2ND: begin\n        if (i_ifu_rsp_hsked) begin\n          if (/* new request condition */) begin\n            icb_state_ena = 1'b1;\n            icb_state_nxt = ICB_STATE_1ST;\n          end else begin\n            icb_state_ena = 1'b1;\n            icb_state_nxt = ICB_STATE_IDLE;\n          end\n        end\n      end\n      default: begin\n        icb_state_ena = 1'b1;\n        icb_state_nxt = ICB_STATE_IDLE;\n      end\n    endcase\n  end\n\n  // State Register Update\n  sirv_gnrl_dfflr #(2) icb_state_dfflr (\n    .lden (icb_state_ena),\n    .dnxt (icb_state_nxt),\n    .qout (icb_state),\n    .clk  (clk),\n    .rst_n(rst_n)\n  );\n\n  //===========================================================================\n  // Leftover Buffer Implementation\n  //===========================================================================\n  reg [15:0] leftover_r;\n  reg        leftover_err_r;\n  wire       leftover_ena;\n  wire       leftover_err_nxt;\n  wire [15:0] leftover_nxt;\n\n  // Leftover Enable Conditions\n  wire holdup2leftover_ena = ifu_req_hsked & req_same_cross_holdup;\n  wire uop1st2leftover_ena = ifu_icb_rsp_hsked & ifu_icb_rsp2leftover;\n  assign leftover_ena = holdup2leftover_ena | uop1st2leftover_ena;\n\n  // Leftover Data Selection\n  wire [15:0] leftover_data_from_itcm = ifu2itcm_icb_rsp_rdata[31:16];\n  wire [15:0] leftover_data_from_biu  = ifu2biu_icb_rsp_rdata[31:16];\n  assign leftover_nxt = icb_cmd2itcm_r ? leftover_data_from_itcm : leftover_data_from_biu;\n\n  // Leftover Error Generation\n  assign leftover_err_nxt = holdup2leftover_ena ? 1'b0 : ifu_icb_rsp_err;\n\n  // Leftover Registers\n  sirv_gnrl_dfflr #(16) leftover_dfflr (\n    .lden (leftover_ena),\n    .dnxt (leftover_nxt),\n    .qout (leftover_r),\n    .clk  (clk),\n    .rst_n(rst_n)\n  );\n\n  sirv_gnrl_dfflr #(1) leftover_err_dfflr (\n    .lden (leftover_ena),\n    .dnxt (leftover_err_nxt),\n    .qout (leftover_err_r),\n    .clk  (clk),\n    .rst_n(rst_n)\n  );\n\n  //===========================================================================\n  // Response Generation Implementation\n  //===========================================================================\n  wire rsp_instr_sel_leftover = (icb_sta_is_1st & req_same_cross_holdup_r) | icb_sta_is_2nd;\n  wire rsp_instr_sel_icb_rsp  = ~rsp_instr_sel_leftover;\n  wire [31:0] rsp_instr_leftover = {ifu_icb_rsp_rdata_lsb16, leftover_r};\n  wire [31:0] rsp_instr_icb_rsp;\n\n  // Data Alignment\n  // ITCM Data Alignment\n  reg [31:0] ifu_icb_rsp_rdata_algn;\n  always @(*) begin\n    if (icb_cmd2itcm_r) begin\n      if (ITCM_DATA_WIDTH == 64) begin\n        case (icb_cmd_addr_2_1_r)\n          2'b00: ifu_icb_rsp_rdata_algn = ifu2itcm_icb_rsp_rdata[31:0];\n          2'b01: ifu_icb_rsp_rdata_algn = ifu2itcm_icb_rsp_rdata[47:16];\n          2'b10: ifu_icb_rsp_rdata_algn = ifu2itcm_icb_rsp_rdata[63:32];\n          default: ifu_icb_rsp_rdata_algn = 32'b0;\n        endcase\n      end else begin\n        ifu_icb_rsp_rdata_algn = ifu2itcm_icb_rsp_rdata[31:0];\n      end\n    end else begin\n      // System Memory Data Alignment\n      if (SYSMEM_DATA_WIDTH == 64) begin\n        case (icb_cmd_addr_2_1_r)\n          2'b00: ifu_icb_rsp_rdata_algn = ifu2biu_icb_rsp_rdata[31:0];\n          2'b01: ifu_icb_rsp_rdata_algn = ifu2biu_icb_rsp_rdata[47:16];\n          2'b10: ifu_icb_rsp_rdata_algn = ifu2biu_icb_rsp_rdata[63:32];\n          default: ifu_icb_rsp_rdata_algn = 32'b0;\n        endcase\n      end else begin\n        ifu_icb_rsp_rdata_algn = ifu2biu_icb_rsp_rdata[31:0];\n      end\n    end\n  end\n\n  // Lowest 16 Bits Acquisition\n  wire [15:0] ifu_icb_rsp_rdata_lsb16 = (icb_cmd2itcm_r) ? ifu2itcm_icb_rsp_rdata[15:0] : ifu2biu_icb_rsp_rdata[15:0];\n\n  // Response Error Handling\n  wire ifu_icb_rsp_err = (icb_cmd2itcm_r & ifu2itcm_icb_rsp_err) |\n                         (icb_cmd2biu_r  & ifu2biu_icb_rsp_err);\n\n  // Instruction Response Data Path\n  assign ifu_rsp_instr = rsp_instr_sel_leftover ? rsp_instr_leftover : ifu_icb_rsp_rdata_algn;\n\n  // Response Error Flag\n  wire i_ifu_rsp_err = rsp_instr_sel_leftover ? (leftover_err_r | ifu_icb_rsp_err) : ifu_icb_rsp_err;\n\n  // Response Valid Control\n  wire holdup_gen_fake_rsp_valid = icb_sta_is_1st & req_need_0uop_r;\n  wire ifu_icb_rsp2ir_valid = ifu_icb_rsp_hsked & ~ifu_icb_rsp2leftover;\n  assign i_ifu_rsp_valid = holdup_gen_fake_rsp_valid | ifu_icb_rsp2ir_valid;\n\n  //===========================================================================\n  // Bypass Buffer Implementation\n  //===========================================================================\n  wire ifu_rsp_bypbuf_i_valid = i_ifu_rsp_valid;\n  wire ifu_rsp_bypbuf_o_ready = ifu_rsp_ready;\n  wire [32:0] ifu_rsp_bypbuf_i_data = {i_ifu_rsp_err, ifu_rsp_instr};\n  wire ifu_rsp_bypbuf_o_valid;\n  wire [32:0] ifu_rsp_bypbuf_o_data;\n\n  // Bypass Buffer Instance\n  sirv_gnrl_bypbuf #(\n    .DP(1),\n    .DW(33)\n  ) u_ifu_rsp_bypbuf (\n    .i_vld (ifu_rsp_bypbuf_i_valid),\n    .i_rdy (ifu_rsp_bypbuf_i_ready),\n    .i_dat (ifu_rsp_bypbuf_i_data),\n    .o_vld (ifu_rsp_bypbuf_o_valid),\n    .o_rdy (ifu_rsp_bypbuf_o_ready),\n    .o_dat (ifu_rsp_bypbuf_o_data),\n    .clk   (clk),\n    .rst_n (rst_n)\n  );\n\n  // Output Assignments\n  assign ifu_rsp_valid = ifu_rsp_bypbuf_o_valid;\n  assign ifu_rsp_err   = ifu_rsp_bypbuf_o_data[32];\n  assign ifu_rsp_instr = ifu_rsp_bypbuf_o_data[31:0];\n\n  //===========================================================================\n  // ICB Command Generation Implementation\n  //===========================================================================\n  // Command Valid Control\n  wire ifu_icb_cmd_valid;\n  // Conditions to generate ifu_icb_cmd_valid\n  // (Not shown here due to complexity)\n\n  // Command Address Generation\n  wire [ADDR_SIZE-1:0] ifu_icb_cmd_addr;\n\n  // Target Selection\n  wire ifu_icb_cmd2itcm;\n  wire ifu_icb_cmd2biu;\n\n  // Command Distribution\n  assign ifu2itcm_icb_cmd_valid = ifu_icb_cmd_valid & ifu_icb_cmd2itcm;\n  assign ifu2itcm_icb_cmd_addr  = ifu_icb_cmd_addr[ITCM_ADDR_WIDTH-1:0];\n\n  assign ifu2biu_icb_cmd_valid  = ifu_icb_cmd_valid & ifu_icb_cmd2biu;\n  assign ifu2biu_icb_cmd_addr   = ifu_icb_cmd_addr;\n\n  // Command Ready Merge\n  wire ifu_icb_cmd_ready = (ifu_icb_cmd2itcm & ifu2itcm_icb_cmd_ready) |\n                           (ifu_icb_cmd2biu  & ifu2biu_icb_cmd_ready);\n\n  //===========================================================================\n  // ICB Response Handling\n  //===========================================================================\n  // ICB Response Valid and Ready\n  wire ifu2itcm_icb_rsp_ready = ifu_icb_rsp_ready;\n  wire ifu2biu_icb_rsp_ready  = ifu_icb_rsp_ready;\n\n  wire ifu_icb_rsp_valid = (icb_cmd2itcm_r & ifu2itcm_icb_rsp_valid) |\n                           (icb_cmd2biu_r  & ifu2biu_icb_rsp_valid);\n\n  // ICB Response Data\n  wire [ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata;\n  wire [SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata;\n\n  //===========================================================================\n  // Handshake Control Implementation\n  //===========================================================================\n  // IFU Request Ready Generation\n  assign ifu_req_ready = ifu_icb_cmd_ready & ifu_req_ready_condi;\n\n  //===========================================================================\n  // Additional Logic (Not Fully Shown Due to Complexity)\n  //===========================================================================\n\n  // Include the remaining logic as per the design document,\n  // including the implementation of req_same_cross_holdup_r,\n  // req_need_2uop_r, req_need_0uop_r, lane operations, etc.\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_irq_sync", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_irq_sync #(\n  parameter MASTER = 1\n)(\n  input  clk,\n  input  rst_n,\n  input  ext_irq_a,\n  input  sft_irq_a,\n  input  tmr_irq_a,\n  input  dbg_irq_a,\n  output ext_irq_r,\n  output sft_irq_r,\n  output tmr_irq_r,\n  output dbg_irq_r\n);\n\n  wire ext_irq_r_int;\n  wire sft_irq_r_int;\n  wire tmr_irq_r_int;\n  wire dbg_irq_r_int;\n\n  generate\n    if (MASTER) begin : master_mode\n      `ifndef E203_HAS_LOCKSTEP\n        `ifdef E203_IRQ_NEED_SYNC\n          // Synchronize each interrupt\n          sirv_gnrl_sync #(\n            .DP(E203_ASYNC_FF_LEVELS),\n            .DW(1)\n          ) u_ext_irq_sync (\n            .din_a (ext_irq_a      ),\n            .dout  (ext_irq_r_int  ),\n            .rst_n (rst_n          ),\n            .clk   (clk            )\n          );\n\n          sirv_gnrl_sync #(\n            .DP(E203_ASYNC_FF_LEVELS),\n            .DW(1)\n          ) u_sft_irq_sync (\n            .din_a (sft_irq_a      ),\n            .dout  (sft_irq_r_int  ),\n            .rst_n (rst_n          ),\n            .clk   (clk            )\n          );\n\n          sirv_gnrl_sync #(\n            .DP(E203_ASYNC_FF_LEVELS),\n            .DW(1)\n          ) u_tmr_irq_sync (\n            .din_a (tmr_irq_a      ),\n            .dout  (tmr_irq_r_int  ),\n            .rst_n (rst_n          ),\n            .clk   (clk            )\n          );\n\n          sirv_gnrl_sync #(\n            .DP(E203_ASYNC_FF_LEVELS),\n            .DW(1)\n          ) u_dbg_irq_sync (\n            .din_a (dbg_irq_a      ),\n            .dout  (dbg_irq_r_int  ),\n            .rst_n (rst_n          ),\n            .clk   (clk            )\n          );\n        `else\n          // Direct pass-through\n          assign ext_irq_r_int = ext_irq_a;\n          assign sft_irq_r_int = sft_irq_a;\n          assign tmr_irq_r_int = tmr_irq_a;\n          assign dbg_irq_r_int = dbg_irq_a;\n        `endif\n      `else\n        // No operations are performed (neither synchronization nor pass-through)\n        assign ext_irq_r_int = 1'b0;\n        assign sft_irq_r_int = 1'b0;\n        assign tmr_irq_r_int = 1'b0;\n        assign dbg_irq_r_int = 1'b0;\n      `endif\n    end else begin : slave_mode\n      // Signal pass-through is used regardless of lockstep mode.\n      assign ext_irq_r_int = ext_irq_a;\n      assign sft_irq_r_int = sft_irq_a;\n      assign tmr_irq_r_int = tmr_irq_a;\n      assign dbg_irq_r_int = dbg_irq_a;\n    end\n  endgenerate\n\n  assign ext_irq_r = ext_irq_r_int;\n  assign sft_irq_r = sft_irq_r_int;\n  assign tmr_irq_r = tmr_irq_r_int;\n  assign dbg_irq_r = dbg_irq_r_int;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ram", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_itcm_ram (\n    input wire sd, // Power domain shutdown enable signal for power management\n    input wire ds, // Deep sleep mode enable, controlling complete power area shutdown\n    input wire ls, // Light sleep mode enable, reducing power without full shutdown\n    input wire cs, // Chip select signal, controlling RAM selection\n    input wire we, // Write enable signal, controlling write operation\n    input wire [E203_ITCM_RAM_AW-1:0] addr, // Address input, specifying read/write location\n    input wire [E203_ITCM_RAM_MW-1:0] wem, // Write mask, controlling specific byte writing\n    input wire [E203_ITCM_RAM_DW-1:0] din, // Data input to be written\n    input wire rst_n, // Asynchronous reset signal (active low)\n    input wire clk, // System clock\n    output wire [E203_ITCM_RAM_DW-1:0] dout // Data output, read data\n);\n\n    // Parameters\n    parameter FORCE_X2ZERO = 0; // Force undefined states to zero (disabled when ECC is present)\n    parameter DP = E203_ITCM_RAM_DP; // RAM depth\n    parameter AW = E203_ITCM_RAM_AW; // Address width\n    parameter DW = E203_ITCM_RAM_DW; // Data width\n    parameter MW = E203_ITCM_RAM_MW; // Write mask width\n\n    // Instantiate the sirv_gnrl_ram module\n    sirv_gnrl_ram #(\n        .FORCE_X2ZERO (FORCE_X2ZERO),\n        .DP           (DP),\n        .DW           (DW),\n        .MW           (MW),\n        .AW           (AW)\n    ) u_sirv_gnrl_ram (\n        .sd    (sd),\n        .ds    (ds),\n        .ls    (ls),\n        .cs    (cs),\n        .we    (we),\n        .addr  (addr),\n        .wem   (wem),\n        .din   (din),\n        .dout  (dout),\n        .rst_n (rst_n),\n        .clk   (clk)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_srams", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_srams(\n    // ITCM RAM Interface\n    input wire itcm_ram_sd,\n    input wire itcm_ram_ds,\n    input wire itcm_ram_ls,\n    input wire itcm_ram_cs,\n    input wire itcm_ram_we,\n    input wire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,\n    input wire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,\n    input wire [E203_ITCM_RAM_DW-1:0] itcm_ram_din,\n    output wire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,\n    input wire clk_itcm_ram,\n    input wire rst_itcm,\n\n    // DTCM RAM Interface\n    input wire dtcm_ram_sd,\n    input wire dtcm_ram_ds,\n    input wire dtcm_ram_ls,\n    input wire dtcm_ram_cs,\n    input wire dtcm_ram_we,\n    input wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    input wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    input wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    input wire clk_dtcm_ram,\n    input wire rst_dtcm\n);\n\n`ifdef E203_HAS_ITCM\n    e203_itcm_ram u_e203_itcm_ram(\n        .sd    (itcm_ram_sd),\n        .ds    (itcm_ram_ds),\n        .ls    (itcm_ram_ls),\n        .cs    (itcm_ram_cs),\n        .we    (itcm_ram_we),\n        .addr  (itcm_ram_addr),\n        .wem   (itcm_ram_wem),\n        .din   (itcm_ram_din),\n        .dout  (itcm_ram_dout),\n        .clk   (clk_itcm_ram),\n        .rst_n (rst_itcm)\n    );\n`else\n    assign itcm_ram_dout = {E203_ITCM_RAM_DW{1'b0}};\n`endif\n\n`ifdef E203_HAS_DTCM\n    e203_dtcm_ram u_e203_dtcm_ram(\n        .sd    (dtcm_ram_sd),\n        .ds    (dtcm_ram_ds),\n        .ls    (dtcm_ram_ls),\n        .cs    (dtcm_ram_cs),\n        .we    (dtcm_ram_we),\n        .addr  (dtcm_ram_addr),\n        .wem   (dtcm_ram_wem),\n        .din   (dtcm_ram_din),\n        .dout  (dtcm_ram_dout),\n        .clk   (clk_dtcm_ram),\n        .rst_n (rst_dtcm)\n    );\n`else\n    assign dtcm_ram_dout = {E203_DTCM_RAM_DW{1'b0}};\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_nice", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_nice(\n    input                          nice_i_xs_off,\n    input                          nice_i_valid,\n    output                         nice_i_ready,\n    input  [`E203_XLEN-1:0]        nice_i_instr,\n    input  [`E203_XLEN-1:0]        nice_i_rs1,\n    input  [`E203_XLEN-1:0]        nice_i_rs2,\n    input  [`E203_ITAG_WIDTH-1:0]  nice_i_itag,\n\n    output                         nice_o_longpipe,\n    output                         nice_o_valid,\n    input                          nice_o_ready,\n    output                         nice_o_itag_valid,\n    input                          nice_o_itag_ready,\n    output [`E203_ITAG_WIDTH-1:0]  nice_o_itag,\n\n    input                          nice_rsp_multicyc_valid,\n    output                         nice_rsp_multicyc_ready,\n\n    output                         nice_req_valid,\n    input                          nice_req_ready,\n    output [`E203_XLEN-1:0]        nice_req_instr,\n    output [`E203_XLEN-1:0]        nice_req_rs1,\n    output [`E203_XLEN-1:0]        nice_req_rs2,\n\n    input                          clk,\n    input                          rst_n\n);\n\n  wire inst_handshake = nice_i_valid & nice_i_ready;\n\n  wire nice_req_ready_real = nice_i_xs_off ? 1'b1 : nice_req_ready;\n\n  assign nice_i_ready = nice_req_ready_real & nice_o_ready & fifo_i_rdy;\n\n  assign nice_req_valid = (~nice_i_xs_off) & inst_handshake;\n\n  assign nice_o_longpipe = ~nice_i_xs_off;\n\n  assign nice_o_valid = inst_handshake;\n\n  assign nice_req_instr = nice_i_instr;\n  assign nice_req_rs1   = nice_i_rs1;\n  assign nice_req_rs2   = nice_i_rs2;\n\n  // FIFO signals\n  wire fifo_i_vld = nice_req_valid;\n  wire fifo_i_rdy;\n  wire [`E203_ITAG_WIDTH-1:0] fifo_i_dat = nice_i_itag;\n\n  wire fifo_o_vld;\n  wire fifo_o_rdy;\n  wire [`E203_ITAG_WIDTH-1:0] fifo_o_dat;\n\n  assign nice_o_itag = fifo_o_dat;\n\n  assign nice_o_itag_valid = fifo_o_vld & nice_rsp_multicyc_valid;\n\n  assign fifo_o_rdy = nice_rsp_multicyc_valid & nice_o_itag_ready;\n\n  assign nice_rsp_multicyc_ready = fifo_o_vld & nice_o_itag_ready;\n\n  sirv_gnrl_fifo #(\n    .CUT_READY(1),\n    .MSKO(0),\n    .DP(4),\n    .DW(`E203_ITAG_WIDTH)\n  ) u_itag_fifo (\n    .i_vld (fifo_i_vld ),\n    .i_rdy (fifo_i_rdy ),\n    .i_dat (fifo_i_dat ),\n    .o_vld (fifo_o_vld ),\n    .o_rdy (fifo_o_rdy ),\n    .o_dat (fifo_o_dat ),\n    .clk   (clk        ),\n    .rst_n (rst_n      )\n  );\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_litebpu", "codeid": 1, "code": "module e203_ifu_litebpu #(\n    parameter E203_PC_SIZE     = 32,\n    parameter E203_XLEN        = 32,\n    parameter E203_RFIDX_WIDTH = 5\n)(\n    input                       clk,\n    input                       rst_n,\n\n    input  [E203_PC_SIZE-1:0]   pc,\n    input                       dec_jal,\n    input                       dec_jalr,\n    input                       dec_bxx,\n    input  [E203_XLEN-1:0]      dec_bjp_imm,\n    input  [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    input                       oitf_empty,\n    input                       ir_empty,\n    input                       ir_rs1en,\n    input                       jalr_rs1idx_cam_irrdidx,\n    input                       dec_i_valid,\n    input                       ir_valid_clr,\n    input  [E203_XLEN-1:0]      rf2bpu_x1,\n    input  [E203_XLEN-1:0]      rf2bpu_rs1,\n\n    output                      prdt_taken,\n    output [E203_PC_SIZE-1:0]   prdt_pc_add_op1,\n    output [E203_PC_SIZE-1:0]   prdt_pc_add_op2,\n    output                      bpu_wait,\n    output                      bpu2rf_rs1_ena\n);\n\n// Determine if dec_jalr_rs1idx equals x0, x1, or other\nwire dec_jalr_rs1x0 = (dec_jalr_rs1idx == 5'd0);\nwire dec_jalr_rs1x1 = (dec_jalr_rs1idx == 5'd1);\nwire dec_jalr_rs1xn = ~(dec_jalr_rs1x0 | dec_jalr_rs1x1);\n\nwire jalr_rs1x0 = dec_jalr & dec_jalr_rs1x0;\nwire jalr_rs1x1 = dec_jalr & dec_jalr_rs1x1;\nwire jalr_rs1xn = dec_jalr & dec_jalr_rs1xn;\n\n// Predict taken for JAL, JALR, and negative offset branches\nwire bxx_pred_taken = dec_bxx & dec_bjp_imm[E203_XLEN-1];\nassign prdt_taken = dec_jal | dec_jalr | bxx_pred_taken;\n\n// Calculate prdt_pc_add_op1 based on instruction type\nassign prdt_pc_add_op1 = \n    ({E203_PC_SIZE{dec_jal | dec_bxx}} & pc) |\n    ({E203_PC_SIZE{jalr_rs1x0}} & {E203_PC_SIZE{1'b0}}) |\n    ({E203_PC_SIZE{jalr_rs1x1}} & rf2bpu_x1) |\n    ({E203_PC_SIZE{jalr_rs1xn}} & rf2bpu_rs1);\n\n// prdt_pc_add_op2 is the immediate offset\nassign prdt_pc_add_op2 = dec_bjp_imm[E203_PC_SIZE-1:0];\n\n// Dependency detection for JALR rs1 = xn\nwire jalr_rs1xn_dep = jalr_rs1xn & (~oitf_empty | ((~ir_empty & ir_rs1en & ~ir_valid_clr)));\nwire rs1xn_rdrf_set = (~rs1xn_rdrf_r) & dec_i_valid & jalr_rs1xn & (~jalr_rs1xn_dep);\nwire rs1xn_rdrf_clr = rs1xn_rdrf_r;\nwire rs1xn_rdrf_ena = rs1xn_rdrf_set | rs1xn_rdrf_clr;\nwire rs1xn_rdrf_nxt = rs1xn_rdrf_set ? 1'b1 : 1'b0;\n\nreg rs1xn_rdrf_r;\nsirv_gnrl_dfflr #(1) rs1xn_rdrf_dfflr (\n    .lden (rs1xn_rdrf_ena  ),\n    .dnxt (rs1xn_rdrf_nxt  ),\n    .qout (rs1xn_rdrf_r    ),\n    .clk  (clk             ),\n    .rst_n(rst_n           ) \n);\n\n// Generate bpu_wait signal\nassign bpu_wait = (jalr_rs1x1 & (~oitf_empty | jalr_rs1idx_cam_irrdidx)) |\n                  (jalr_rs1xn & (jalr_rs1xn_dep | rs1xn_rdrf_r));\n\n// Register read enable signal\nassign bpu2rf_rs1_ena = rs1xn_rdrf_set;\n\nendmodule\n\n// Definition of sirv_gnrl_dfflr module\nmodule sirv_gnrl_dfflr #(parameter DW = 1) (\n    input             lden,\n    input  [DW-1:0]   dnxt,\n    output reg [DW-1:0] qout,\n    input             clk,\n    input             rst_n\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n)\n            qout <= {DW{1'b0}};\n        else if (lden)\n            qout <= dnxt;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_lsuagu", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_alu_lsuagu(\n    // I/O ports\n    // Inputs\n    input                              agu_i_valid,\n    output                             agu_i_ready,\n    input  [`E203_XLEN-1:0]            agu_i_rs1,\n    input  [`E203_XLEN-1:0]            agu_i_rs2,\n    input  [`E203_XLEN-1:0]            agu_i_imm,\n    input  [`E203_DECINFO_AGU_WIDTH-1:0] agu_i_info,\n    input  [`E203_ITAG_WIDTH-1:0]      agu_i_itag,\n    output                             agu_i_longpipe,\n    input                              flush_req,\n    input                              flush_pulse,\n    output                             amo_wait,\n    input                              oitf_empty, // OITF empty signal\n\n    // Outputs\n    output                             agu_o_valid,\n    input                              agu_o_ready,\n    output [`E203_XLEN-1:0]            agu_o_wbck_wdat,\n    output                             agu_o_wbck_err,\n    output                             agu_o_cmt_misalgn,\n    output                             agu_o_cmt_ld,\n    output                             agu_o_cmt_stamo,\n    output                             agu_o_cmt_buserr,\n    output [`E203_ADDR_SIZE-1:0]       agu_o_cmt_badaddr,\n\n    // ICB Interface to LSU\n    output                             agu_icb_cmd_valid,\n    input                              agu_icb_cmd_ready,\n    output [`E203_ADDR_SIZE-1:0]       agu_icb_cmd_addr,\n    output                             agu_icb_cmd_read,\n    output [`E203_XLEN-1:0]            agu_icb_cmd_wdata,\n    output [`E203_XLEN/8-1:0]          agu_icb_cmd_wmask,\n    output                             agu_icb_cmd_back2agu,\n    output                             agu_icb_cmd_lock,\n    output                             agu_icb_cmd_excl,\n    output [1:0]                       agu_icb_cmd_size,\n    output [`E203_ITAG_WIDTH-1:0]      agu_icb_cmd_itag,\n    output                             agu_icb_cmd_usign,\n\n    input                              agu_icb_rsp_valid,\n    output                             agu_icb_rsp_ready,\n    input                              agu_icb_rsp_err,\n    input                              agu_icb_rsp_excl_ok,\n    input  [`E203_XLEN-1:0]            agu_icb_rsp_rdata,\n\n    // ALU shared datapath\n    output [`E203_XLEN-1:0]            agu_req_alu_op1,\n    output [`E203_XLEN-1:0]            agu_req_alu_op2,\n    output                             agu_req_alu_swap,\n    output                             agu_req_alu_add,\n    output                             agu_req_alu_and,\n    output                             agu_req_alu_or,\n    output                             agu_req_alu_xor,\n    output                             agu_req_alu_max,\n    output                             agu_req_alu_min,\n    output                             agu_req_alu_maxu,\n    output                             agu_req_alu_minu,\n    input  [`E203_XLEN-1:0]            agu_req_alu_res,\n\n    // Shared buffer\n    output                             agu_sbf_0_ena,\n    output [`E203_XLEN-1:0]            agu_sbf_0_nxt,\n    input  [`E203_XLEN-1:0]            agu_sbf_0_r,\n    output                             agu_sbf_1_ena,\n    output [`E203_XLEN-1:0]            agu_sbf_1_nxt,\n    input  [`E203_XLEN-1:0]            agu_sbf_1_r,\n\n    // Clock and Reset\n    input                              clk,\n    input                              rst_n\n);\n\n    // === AGU Info Decode ===\n    wire agu_i_load      = agu_i_info[`E203_DECINFO_AGU_LOAD ];\n    wire agu_i_store     = agu_i_info[`E203_DECINFO_AGU_STORE ];\n    wire agu_i_amo       = agu_i_info[`E203_DECINFO_AGU_AMO ];\n    wire [1:0] agu_i_size= agu_i_info[`E203_DECINFO_AGU_SIZE ];\n    wire agu_i_usign     = agu_i_info[`E203_DECINFO_AGU_USIGN ];\n    wire agu_i_excl      = agu_i_info[`E203_DECINFO_AGU_EXCL ];\n    wire agu_i_amoswap   = agu_i_info[`E203_DECINFO_AGU_AMOSWAP ];\n    wire agu_i_amoadd    = agu_i_info[`E203_DECINFO_AGU_AMOADD ];\n    wire agu_i_amoand    = agu_i_info[`E203_DECINFO_AGU_AMOAND ];\n    wire agu_i_amoor     = agu_i_info[`E203_DECINFO_AGU_AMOOR ];\n    wire agu_i_amoxor    = agu_i_info[`E203_DECINFO_AGU_AMOXOR ];\n    wire agu_i_amomax    = agu_i_info[`E203_DECINFO_AGU_AMOMAX ];\n    wire agu_i_amomin    = agu_i_info[`E203_DECINFO_AGU_AMOMIN ];\n    wire agu_i_amomaxu   = agu_i_info[`E203_DECINFO_AGU_AMOMAXU ];\n    wire agu_i_amominu   = agu_i_info[`E203_DECINFO_AGU_AMOMINU ];\n\n    // Load or Store\n    wire agu_cmd_load = agu_i_load;\n    wire agu_cmd_store = agu_i_store;\n    wire agu_cmd_amo = agu_i_amo;\n    wire agu_cmd_read = agu_cmd_load | agu_cmd_amo;\n    wire agu_cmd_write = agu_cmd_store | agu_cmd_amo;\n\n    // Generate address\n    wire [`E203_XLEN-1:0] agu_op1 = agu_i_rs1;\n    wire [`E203_XLEN-1:0] agu_op2 = agu_i_imm;\n\n    // Generate ALU requests\n    assign agu_req_alu_op1 = agu_op1;\n    assign agu_req_alu_op2 = agu_op2;\n    assign agu_req_alu_add = 1'b1; // Perform addition for address calculation\n\n    // All other ALU operations are zero unless AMO instruction\n    assign agu_req_alu_swap = agu_i_amoswap;\n    assign agu_req_alu_and = agu_i_amoand;\n    assign agu_req_alu_or = agu_i_amoor;\n    assign agu_req_alu_xor = agu_i_amoxor;\n    assign agu_req_alu_max = agu_i_amomax;\n    assign agu_req_alu_min = agu_i_amomin;\n    assign agu_req_alu_maxu = agu_i_amomaxu;\n    assign agu_req_alu_minu = agu_i_amominu;\n\n    // ALU result is the computed address\n    wire [`E203_ADDR_SIZE-1:0] mem_addr = agu_req_alu_res[`E203_ADDR_SIZE-1:0];\n\n    // Address alignment checking\n    wire [1:0] addr_lsb = mem_addr[1:0]; // For misalignment check\n    wire misaligned = (agu_i_size == 2'b10) ? (|addr_lsb) : // Word access, check bits [1:0]\n                      (agu_i_size == 2'b01) ? addr_lsb[0] : // Halfword access, check bit [0]\n                      1'b0; // Byte access, always aligned\n\n    // Generate AGU command valid signal\n    wire agu_icb_cmd_valid_pre = agu_i_valid & (~misaligned);\n\n    // Assign outputs\n    assign agu_icb_cmd_valid = agu_icb_cmd_valid_pre & (~flush_pulse);\n    assign agu_icb_cmd_addr = mem_addr;\n    assign agu_icb_cmd_read = agu_cmd_read;\n    assign agu_icb_cmd_wdata = agu_i_rs2; // For store and AMO, rs2 is write data\n    assign agu_icb_cmd_wmask = ({`E203_XLEN/8{(agu_i_size == 2'b00)}} & (8'b1 << mem_addr[2:0])) |\n                               ({`E203_XLEN/8{(agu_i_size == 2'b01)}} & (8'b11 << {mem_addr[2:1],1'b0})) |\n                               ({`E203_XLEN/8{(agu_i_size == 2'b10)}} & 8'b1111); // Adjust according to size and address\n    assign agu_icb_cmd_back2agu = 1'b1;\n    assign agu_icb_cmd_lock = 1'b0;\n    assign agu_icb_cmd_excl = agu_i_excl | agu_i_amo; // Exclusive for AMO or EXCL instruction\n    assign agu_icb_cmd_size = agu_i_size;\n    assign agu_icb_cmd_itag = agu_i_itag;\n    assign agu_icb_cmd_usign = agu_i_usign;\n\n    // Generate misalignment exception signal\n    assign agu_o_cmt_misalgn = misaligned;\n\n    // Output valid signals\n    assign agu_o_valid = agu_icb_rsp_valid & (~flush_pulse);\n    assign agu_o_wbck_wdat = agu_icb_rsp_rdata;\n    assign agu_o_wbck_err = agu_icb_rsp_err;\n    assign agu_o_cmt_ld = agu_i_load;\n    assign agu_o_cmt_stamo = agu_i_store | agu_i_amo;\n    assign agu_o_cmt_buserr = agu_icb_rsp_err;\n    assign agu_o_cmt_badaddr = misaligned ? mem_addr : {`E203_ADDR_SIZE{1'b0}};\n\n    // AGU response ready\n    assign agu_icb_rsp_ready = agu_o_ready;\n\n    // AGU input ready\n    assign agu_i_ready = agu_icb_cmd_ready & (~flush_pulse);\n\n    // Indicate operation is a long pipeline instruction (e.g., AMO)\n    assign agu_i_longpipe = agu_i_amo;\n\n    // AMO wait signal (simple implementation)\n    assign amo_wait = agu_i_amo & ~(agu_icb_rsp_valid & agu_icb_rsp_ready);\n\n    // Shared buffer control signals (for AMO operations)\n    assign agu_sbf_0_ena = 1'b0; // Implementation depends on the AMO state machine\n    assign agu_sbf_0_nxt = {`E203_XLEN{1'b0}};\n    assign agu_sbf_1_ena = 1'b0;\n    assign agu_sbf_1_nxt = {`E203_XLEN{1'b0}};\n\n    // For simplicity, assuming no AMO state machine implementation here\n\n    // Flush handling\n    wire flush_block = flush_req & (~agu_i_valid);\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_longpwbck", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_exu_longpwbck(\n    // LSU write-back interface\n    input  wire                      lsu_wbck_i_valid,\n    output wire                      lsu_wbck_i_ready,\n    input  wire [`E203_XLEN-1:0]     lsu_wbck_i_wdat,\n    input  wire [`E203_ITAG_WIDTH-1:0] lsu_wbck_i_itag,\n    input  wire                      lsu_wbck_i_err,\n    input  wire                      lsu_cmt_i_buserr,\n    input  wire [`E203_ADDR_SIZE-1:0] lsu_cmt_i_badaddr,\n    input  wire                      lsu_cmt_i_ld,\n    input  wire                      lsu_cmt_i_st,\n\n    // Long-pipeline write-back output to the final WB module\n    output wire                      longp_wbck_o_valid,\n    input  wire                      longp_wbck_o_ready,\n    output wire [`E203_FLEN-1:0]     longp_wbck_o_wdat,\n    output wire [4:0]                longp_wbck_o_flags,\n    output wire [`E203_RFIDX_WIDTH-1:0] longp_wbck_o_rdidx,\n    output wire                      longp_wbck_o_rdfpu,\n\n    // Exception signals to the commit stage\n    output wire                      longp_excp_o_valid,\n    input  wire                      longp_excp_o_ready,\n    output wire                      longp_excp_o_insterr,\n    output wire                      longp_excp_o_ld,\n    output wire                      longp_excp_o_st,\n    output wire                      longp_excp_o_buserr,\n    output wire [`E203_ADDR_SIZE-1:0] longp_excp_o_badaddr,\n    output wire [`E203_PC_SIZE-1:0]  longp_excp_o_pc,\n\n    // OITF interface\n    input  wire                      oitf_empty,\n    input  wire [`E203_ITAG_WIDTH-1:0] oitf_ret_ptr,\n    input  wire [`E203_RFIDX_WIDTH-1:0] oitf_ret_rdidx,\n    input  wire [`E203_PC_SIZE-1:0]  oitf_ret_pc,\n    input  wire                      oitf_ret_rdwen,\n    input  wire                      oitf_ret_rdfpu,\n    output wire                      oitf_ret_ena,\n\n    // Clock and reset\n    input  wire                      clk,\n    input  wire                      rst_n\n\n    // The NICE interface is included if E203_HAS_NICE is defined\n    `ifdef E203_HAS_NICE\n    ,\n    // NICE long-pipeline write-back interface\n    input  wire                      nice_longp_wbck_i_valid,\n    output wire                      nice_longp_wbck_i_ready,\n    input  wire [`E203_XLEN-1:0]     nice_longp_wbck_i_wdat,\n    input  wire [`E203_ITAG_WIDTH-1:0] nice_longp_wbck_i_itag,\n    input  wire                      nice_longp_wbck_i_err\n    `endif\n);\n\n// Match signals\nwire lsu_itag_match = (~oitf_empty) && (lsu_wbck_i_itag == oitf_ret_ptr);\nwire lsu_wbck_req_valid = lsu_wbck_i_valid && lsu_itag_match;\n\n`ifdef E203_HAS_NICE\nwire nice_itag_match = (~oitf_empty) && (nice_longp_wbck_i_itag == oitf_ret_ptr);\nwire nice_wbck_req_valid = nice_longp_wbck_i_valid && nice_itag_match;\n`else\nwire nice_wbck_req_valid = 1'b0;\n`endif\n\n// Select which source to use\nwire wbck_sel_lsu = lsu_wbck_req_valid;\nwire wbck_sel_nice = (~lsu_wbck_req_valid) && nice_wbck_req_valid;\n\nwire wbck_req_valid = wbck_sel_lsu ? lsu_wbck_req_valid :\n                      wbck_sel_nice ? nice_wbck_req_valid : 1'b0;\n\nwire wbck_i_err;\nwire wbck_i_ld;\nwire wbck_i_st;\nwire wbck_i_buserr;\nwire [`E203_ADDR_SIZE-1:0] wbck_i_badaddr;\nwire [`E203_XLEN-1:0] wbck_i_wdat;\nwire [`E203_ITAG_WIDTH-1:0] wbck_i_itag;\n\nassign wbck_i_err = wbck_sel_lsu ? lsu_wbck_i_err :\n                    wbck_sel_nice ? nice_longp_wbck_i_err : 1'b0;\n\nassign wbck_i_wdat = wbck_sel_lsu ? lsu_wbck_i_wdat :\n                     wbck_sel_nice ? nice_longp_wbck_i_wdat : {`E203_XLEN{1'b0}};\n\nassign wbck_i_itag = wbck_sel_lsu ? lsu_wbck_i_itag :\n                     wbck_sel_nice ? nice_longp_wbck_i_itag : {`E203_ITAG_WIDTH{1'b0}};\n\nassign wbck_i_buserr = wbck_sel_lsu ? lsu_cmt_i_buserr :\n                       1'b0; // NICE does not have bus error\n\nassign wbck_i_badaddr = wbck_sel_lsu ? lsu_cmt_i_badaddr :\n                        {`E203_ADDR_SIZE{1'b0}};\n\nassign wbck_i_ld = wbck_sel_lsu ? lsu_cmt_i_ld :\n                   1'b0;\n\nassign wbck_i_st = wbck_sel_lsu ? lsu_cmt_i_st :\n                   1'b0;\n\n// OITF signals\nwire wbck_i_rdwen = oitf_ret_rdwen;\nwire wbck_i_rdfpu = oitf_ret_rdfpu;\nwire [`E203_RFIDX_WIDTH-1:0] wbck_i_rdidx = oitf_ret_rdidx;\nwire [`E203_PC_SIZE-1:0] wbck_i_pc = oitf_ret_pc;\n\n// Determine if write-back or exception is needed\nwire wbck_need = wbck_i_rdwen && (~wbck_i_err);\nwire excp_need = wbck_i_err;\n\n// Ready signals\nwire wbck_ready_wbck = (~wbck_need) | (longp_wbck_o_ready);\nwire wbck_ready_excp = (~excp_need) | (longp_excp_o_ready);\nwire wbck_i_ready = wbck_ready_wbck & wbck_ready_excp;\n\n// Valid signal\nwire wbck_i_valid = wbck_req_valid;\n\n// Assign ready signals to sources\nassign lsu_wbck_i_ready = wbck_sel_lsu ? wbck_i_ready : 1'b0;\n\n`ifdef E203_HAS_NICE\nassign nice_longp_wbck_i_ready = wbck_sel_nice ? wbck_i_ready : 1'b0;\n`endif\n\n// OITF retire enable\nassign oitf_ret_ena = wbck_i_valid && wbck_i_ready;\n\n// Write-back outputs\nwire longp_wbck_o_valid_raw = wbck_need && wbck_i_valid && ((~excp_need) | longp_excp_o_ready);\nassign longp_wbck_o_valid = longp_wbck_o_valid_raw;\nassign longp_wbck_o_wdat = wbck_i_wdat;\nassign longp_wbck_o_rdidx = wbck_i_rdidx;\nassign longp_wbck_o_rdfpu = wbck_i_rdfpu;\nassign longp_wbck_o_flags = 5'b0; // Adjust as required\n\n// Exception outputs\nwire longp_excp_o_valid_raw = excp_need && wbck_i_valid && ((~wbck_need) | longp_wbck_o_ready);\nassign longp_excp_o_valid = longp_excp_o_valid_raw;\nassign longp_excp_o_insterr = wbck_i_err;\nassign longp_excp_o_ld = wbck_i_ld;\nassign longp_excp_o_st = wbck_i_st;\nassign longp_excp_o_buserr = wbck_i_buserr;\nassign longp_excp_o_badaddr = wbck_i_badaddr;\nassign longp_excp_o_pc = wbck_i_pc;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_rglr", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_alu_rglr(\n    // Input valid-ready handshake signals\n    input  wire                    alu_i_valid,\n    output wire                    alu_i_ready,\n    // Input operands and instruction info\n    input  wire [E203_XLEN-1:0]    alu_i_rs1,\n    input  wire [E203_XLEN-1:0]    alu_i_rs2,\n    input  wire [E203_XLEN-1:0]    alu_i_imm,\n    input  wire [E203_PC_SIZE-1:0] alu_i_pc,\n    input  wire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info,\n    // Output valid-ready handshake signals\n    output wire                    alu_o_valid,\n    input  wire                    alu_o_ready,\n    // Output write-back data and error\n    output wire [E203_XLEN-1:0]    alu_o_wbck_wdat,\n    output wire                    alu_o_wbck_err,\n    // Output special instructions\n    output wire                    alu_o_cmt_ecall,\n    output wire                    alu_o_cmt_ebreak,\n    output wire                    alu_o_cmt_wfi,\n    // ALU operation requests\n    output wire                    alu_req_alu_add,\n    output wire                    alu_req_alu_sub,\n    output wire                    alu_req_alu_xor,\n    output wire                    alu_req_alu_sll,\n    output wire                    alu_req_alu_srl,\n    output wire                    alu_req_alu_sra,\n    output wire                    alu_req_alu_or,\n    output wire                    alu_req_alu_and,\n    output wire                    alu_req_alu_slt,\n    output wire                    alu_req_alu_sltu,\n    output wire                    alu_req_alu_lui,\n    // ALU operands and result\n    output wire [E203_XLEN-1:0]    alu_req_alu_op1,\n    output wire [E203_XLEN-1:0]    alu_req_alu_op2,\n    input  wire [E203_XLEN-1:0]    alu_req_alu_res,\n    // Clock and reset\n    input  wire                    clk,\n    input  wire                    rst_n\n);\n\n// Valid-ready handshake\nassign alu_o_valid = alu_i_valid;\nassign alu_i_ready = alu_o_ready;\n\n// Extract instruction fields from alu_i_info\nwire dec_add       = alu_i_info[`E203_DECINFO_ALU_ADD];\nwire dec_sub       = alu_i_info[`E203_DECINFO_ALU_SUB];\nwire dec_xor       = alu_i_info[`E203_DECINFO_ALU_XOR];\nwire dec_sll       = alu_i_info[`E203_DECINFO_ALU_SLL];\nwire dec_srl       = alu_i_info[`E203_DECINFO_ALU_SRL];\nwire dec_sra       = alu_i_info[`E203_DECINFO_ALU_SRA];\nwire dec_or        = alu_i_info[`E203_DECINFO_ALU_OR];\nwire dec_and       = alu_i_info[`E203_DECINFO_ALU_AND];\nwire dec_slt       = alu_i_info[`E203_DECINFO_ALU_SLT];\nwire dec_sltu      = alu_i_info[`E203_DECINFO_ALU_SLTU];\nwire dec_lui       = alu_i_info[`E203_DECINFO_ALU_LUI];\nwire dec_op2imm    = alu_i_info[`E203_DECINFO_ALU_OP2IMM];\nwire dec_op1pc     = alu_i_info[`E203_DECINFO_ALU_OP1PC];\nwire dec_nop       = alu_i_info[`E203_DECINFO_ALU_NOP];\nwire dec_ecall     = alu_i_info[`E203_DECINFO_ALU_ECAL];\nwire dec_ebreak    = alu_i_info[`E203_DECINFO_ALU_EBRK];\nwire dec_wfi       = alu_i_info[`E203_DECINFO_ALU_WFI];\n\n// Generate ALU operation requests\nassign alu_req_alu_add  = dec_add & (~dec_nop);\nassign alu_req_alu_sub  = dec_sub;\nassign alu_req_alu_xor  = dec_xor;\nassign alu_req_alu_sll  = dec_sll;\nassign alu_req_alu_srl  = dec_srl;\nassign alu_req_alu_sra  = dec_sra;\nassign alu_req_alu_or   = dec_or;\nassign alu_req_alu_and  = dec_and;\nassign alu_req_alu_slt  = dec_slt;\nassign alu_req_alu_sltu = dec_sltu;\nassign alu_req_alu_lui  = dec_lui;\n\n// Prepare source operands\nassign alu_req_alu_op1 = dec_op1pc ? {{(E203_XLEN-E203_PC_SIZE){1'b0}}, alu_i_pc} : alu_i_rs1;\nassign alu_req_alu_op2 = dec_op2imm ? alu_i_imm : alu_i_rs2;\n\n// Get calculation result\nassign alu_o_wbck_wdat = alu_req_alu_res;\n\n// Handle special instructions\nassign alu_o_cmt_ecall  = dec_ecall;\nassign alu_o_cmt_ebreak = dec_ebreak;\nassign alu_o_cmt_wfi    = dec_wfi;\n\n// When instruction is ecall, ebreak, or wfi, set write-back error\nassign alu_o_wbck_err = dec_ecall | dec_ebreak | dec_wfi;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_bjp", "codeid": 1, "code": "// e203_exu_alu_bjp.v\n\n`include \"e203_defines.v\"\n\nmodule e203_exu_alu_bjp(\n    // Input handshake signals\n    input  wire                 bjp_i_valid,\n    output wire                 bjp_i_ready,\n    // Input operands\n    input  wire [E203_XLEN-1:0] bjp_i_rs1,\n    input  wire [E203_XLEN-1:0] bjp_i_rs2,\n    input  wire [E203_XLEN-1:0] bjp_i_imm,\n    input  wire [E203_PC_SIZE-1:0] bjp_i_pc,\n    input  wire [E203_DECINFO_BJP_WIDTH-1:0] bjp_i_info,\n    // Output handshake signals\n    output wire                 bjp_o_valid,\n    input  wire                 bjp_o_ready,\n    // Output writeback data and error\n    output wire [E203_XLEN-1:0] bjp_o_wbck_wdat,\n    output wire                 bjp_o_wbck_err,\n    // Commit signals\n    output wire                 bjp_o_cmt_bjp,\n    output wire                 bjp_o_cmt_mret,\n    output wire                 bjp_o_cmt_dret,\n    output wire                 bjp_o_cmt_fencei,\n    output wire                 bjp_o_cmt_prdt,\n    output wire                 bjp_o_cmt_rslv,\n    // ALU request signals\n    output wire [E203_XLEN-1:0] bjp_req_alu_op1,\n    output wire [E203_XLEN-1:0] bjp_req_alu_op2,\n    output wire                 bjp_req_alu_cmp_eq,\n    output wire                 bjp_req_alu_cmp_ne,\n    output wire                 bjp_req_alu_cmp_lt,\n    output wire                 bjp_req_alu_cmp_gt,\n    output wire                 bjp_req_alu_cmp_ltu,\n    output wire                 bjp_req_alu_cmp_gtu,\n    output wire                 bjp_req_alu_add,\n    // ALU response signals\n    input  wire                 bjp_req_alu_cmp_res,\n    input  wire [E203_XLEN-1:0] bjp_req_alu_add_res,\n    // Clock and reset\n    input  wire                 clk,\n    input  wire                 rst_n\n);\n\n    // Handshake signals\n    assign bjp_o_valid = bjp_i_valid;\n    assign bjp_i_ready = bjp_o_ready;\n\n    // Decode instruction information\n    wire dec_jal     = bjp_i_info[`E203_DECINFO_BJP_JUMP] & bjp_i_info[`E203_DECINFO_BJP_JAL];\n    wire dec_jalr    = bjp_i_info[`E203_DECINFO_BJP_JUMP] & bjp_i_info[`E203_DECINFO_BJP_JALR];\n    wire dec_beq     = bjp_i_info[`E203_DECINFO_BJP_BEQ];\n    wire dec_bne     = bjp_i_info[`E203_DECINFO_BJP_BNE];\n    wire dec_blt     = bjp_i_info[`E203_DECINFO_BJP_BLT];\n    wire dec_bge     = bjp_i_info[`E203_DECINFO_BJP_BGE];\n    wire dec_bltu    = bjp_i_info[`E203_DECINFO_BJP_BLTU];\n    wire dec_bgeu    = bjp_i_info[`E203_DECINFO_BJP_BGEU];\n    wire dec_mret    = bjp_i_info[`E203_DECINFO_BJP_MRET];\n    wire dec_dret    = bjp_i_info[`E203_DECINFO_BJP_DRET];\n    wire dec_fencei  = bjp_i_info[`E203_DECINFO_BJP_FENCEI];\n    wire dec_bxx     = bjp_i_info[`E203_DECINFO_BJP_BXX];\n    wire dec_jump    = bjp_i_info[`E203_DECINFO_BJP_JUMP];\n    wire dec_bprdt   = bjp_i_info[`E203_DECINFO_BJP_BPRDT];\n\n    // ALU operation requests\n    assign bjp_req_alu_add     = dec_jump;\n    assign bjp_req_alu_cmp_eq  = dec_beq;\n    assign bjp_req_alu_cmp_ne  = dec_bne;\n    assign bjp_req_alu_cmp_lt  = dec_blt;\n    assign bjp_req_alu_cmp_gt  = dec_bge;\n    assign bjp_req_alu_cmp_ltu = dec_bltu;\n    assign bjp_req_alu_cmp_gtu = dec_bgeu;\n\n    // Operand selection\n    assign bjp_req_alu_op1 = dec_jump ? bjp_i_pc : bjp_i_rs1;\n    assign bjp_req_alu_op2 = dec_jump ? {E203_XLEN{1'b0}} + 4 : bjp_i_rs2;\n\n    // Commit signals\n    assign bjp_o_cmt_bjp    = dec_bxx | dec_jump;\n    assign bjp_o_cmt_mret   = dec_mret;\n    assign bjp_o_cmt_dret   = dec_dret;\n    assign bjp_o_cmt_fencei = dec_fencei;\n    assign bjp_o_cmt_prdt   = dec_bprdt;\n    assign bjp_o_cmt_rslv   = dec_jump ? 1'b1 : bjp_req_alu_cmp_res;\n\n    // Writeback data and error\n    assign bjp_o_wbck_wdat = bjp_req_alu_add_res;\n    assign bjp_o_wbck_err  = 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_exu (\n  // Basic Interface\n  output commit_mret,\n  output commit_trap,\n  output exu_active,\n  output excp_active,\n  output core_wfi,\n  output tm_stop,\n  output itcm_nohold,\n  output core_cgstop,\n  output tcm_cgstop,\n  input [E203_HART_ID_W-1:0] core_mhartid,\n  input dbg_irq_r,\n  input [E203_LIRQ_NUM-1:0] lcl_irq_r,\n  input [E203_EVT_NUM-1:0] evt_r,\n  input ext_irq_r,\n  input sft_irq_r,\n  input tmr_irq_r,\n  output wfi_halt_ifu_req,\n  input wfi_halt_ifu_ack,\n  output oitf_empty,\n  output [E203_XLEN-1:0] rf2ifu_x1,\n  output [E203_XLEN-1:0] rf2ifu_rs1,\n  output dec2ifu_rden,\n  output dec2ifu_rs1en,\n  output [E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n  output dec2ifu_mulhsu,\n  output dec2ifu_div,\n  output dec2ifu_rem,\n  output dec2ifu_divu,\n  output dec2ifu_remu,\n  input test_mode,\n  input clk_aon,\n  input clk,\n  input rst_n,\n\n  // From/To debug ctrl module\n  output [E203_PC_SIZE-1:0] cmt_dpc,\n  output cmt_dpc_ena,\n  output [2:0] cmt_dcause,\n  output cmt_dcause_ena,\n  output wr_dcsr_ena,\n  output wr_dpc_ena,\n  output wr_dscratch_ena,\n  output [E203_XLEN-1:0] wr_csr_nxt,\n  input [E203_XLEN-1:0] dcsr_r,\n  input [E203_PC_SIZE-1:0] dpc_r,\n  input [E203_XLEN-1:0] dscratch_r,\n  input dbg_mode,\n  input dbg_halt_r,\n  input dbg_step_r,\n  input dbg_ebreakm_r,\n  input dbg_stopcycle,\n\n  // IFU IR stage to EXU interface\n  input i_valid,\n  output i_ready,\n  input [E203_INSTR_SIZE-1:0] i_ir,\n  input [E203_PC_SIZE-1:0] i_pc,\n  input i_pc_vld,\n  input i_misalgn,\n  input i_buserr,\n  input i_prdt_taken,\n  input i_muldiv_b2b,\n  input [E203_RFIDX_WIDTH-1:0] i_rs1idx,\n  input [E203_RFIDX_WIDTH-1:0] i_rs2idx,\n\n  // Flush interface to IFU\n  input pipe_flush_ack,\n  output pipe_flush_req,\n  output [E203_PC_SIZE-1:0] pipe_flush_add_op1,\n  output [E203_PC_SIZE-1:0] pipe_flush_add_op2,\n  // If E203_TIMING_BOOST is defined\n`ifdef E203_TIMING_BOOST\n  output [E203_PC_SIZE-1:0] pipe_flush_pc,\n`endif\n\n  // LSU Write-Back Interface\n  input lsu_o_valid,\n  output lsu_o_ready,\n  input [E203_XLEN-1:0] lsu_o_wbck_wdat,\n  input [E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n  input lsu_o_wbck_err,\n  input lsu_o_cmt_ld,\n  input lsu_o_cmt_st,\n  input [E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n  input lsu_o_cmt_buserr,\n\n  // AGU ICB Interface to LSU-ctrl\n  output agu_icb_cmd_valid,\n  input agu_icb_cmd_ready,\n  output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n  output agu_icb_cmd_read,\n  output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n  output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n  output agu_icb_cmd_lock,\n  output agu_icb_cmd_excl,\n  output [1:0] agu_icb_cmd_size,\n  output agu_icb_cmd_back2agu,\n  output agu_icb_cmd_usign,\n  output [E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n  input agu_icb_rsp_valid,\n  output agu_icb_rsp_ready,\n  input agu_icb_rsp_err,\n  input agu_icb_rsp_excl_ok,\n  input [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n  // CSR_NICE Interface (optional)\n`ifdef E203_HAS_CSR_NICE\n  output nice_csr_valid,\n  input nice_csr_ready,\n  output [31:0] nice_csr_addr,\n  output nice_csr_wr,\n  output [31:0] nice_csr_wdata,\n  input [31:0] nice_csr_rdata,\n`endif\n\n  // NICE Interface (optional)\n`ifdef E203_HAS_NICE\n  output nice_req_valid,\n  input nice_req_ready,\n  output [E203_XLEN-1:0] nice_req_inst,\n  output [E203_XLEN-1:0] nice_req_rs1,\n  output [E203_XLEN-1:0] nice_req_rs2,\n  input nice_rsp_multicyc_valid,\n  output nice_rsp_multicyc_ready,\n  input [E203_XLEN-1:0] nice_rsp_multicyc_dat,\n  input nice_rsp_multicyc_err,\n`endif\n\n  // ...\n  // Additional ports from submodules can be declared here\n  // ...\n\n  // Include the rest of the ports as per the interface specifications\n  // ...\n\n);\n\n// Internal wires and registers\n\n// Instantiate submodules\n\n// e203_exu_regfile: Manages the core's register file\ne203_exu_regfile u_e203_exu_regfile (\n  .read_src1_idx(read_src1_idx),\n  .read_src2_idx(read_src2_idx),\n  .read_src1_dat(read_src1_dat),\n  .read_src2_dat(read_src2_dat),\n  .wbck_dest_wen(wbck_dest_wen),\n  .wbck_dest_idx(wbck_dest_idx),\n  .wbck_dest_dat(wbck_dest_dat),\n  .x1_r(x1_r),\n  .test_mode(test_mode),\n  .clk(clk),\n  .rst_n(rst_n)\n);\n\n// e203_exu_decode: Decodes incoming instructions\ne203_exu_decode u_e203_exu_decode (\n  .i_instr(i_instr),\n  .i_pc(i_pc),\n  .i_prdt_taken(i_prdt_taken),\n  .i_misalgn(i_misalgn),\n  .i_buserr(i_buserr),\n  .i_muldiv_b2b(i_muldiv_b2b),\n  .dbg_mode(dbg_mode),\n  .dec_rs1x0(dec_rs1x0),\n  .dec_rs2x0(dec_rs2x0),\n  .dec_rs1en(dec_rs1en),\n  .dec_rs2en(dec_rs2en),\n  .dec_rdwen(dec_rdwen),\n  .dec_rs1idx(dec_rs1idx),\n  .dec_rs2idx(dec_rs2idx),\n  .dec_rdidx(dec_rdidx),\n  .dec_info(dec_info),\n  .dec_imm(dec_imm),\n  .dec_pc(dec_pc),\n  .dec_misalgn(dec_misalgn),\n  .dec_buserr(dec_buserr),\n  .dec_ilegl(dec_ilegl),\n  .dec_mulhsu(dec_mulhsu),\n  .dec_mul(dec_mul),\n  .dec_div(dec_div),\n  .dec_rem(dec_rem),\n  .dec_divu(dec_divu),\n  .dec_remu(dec_remu),\n  .dec_rv32(dec_rv32),\n  .dec_bjp(dec_bjp),\n  .dec_jal(dec_jal),\n  .dec_jalr(dec_jalr),\n  .dec_bxx(dec_bxx),\n  .dec_jalr_rs1idx(dec_jalr_rs1idx),\n  .dec_bjp_imm(dec_bjp_imm)\n  // If E203_HAS_NICE is defined, include additional ports\n`ifdef E203_HAS_NICE\n  ,\n  .nice_xs_off(nice_xs_off),\n  .dec_nice(dec_nice),\n  .nice_cmt_off_ilgl_o(nice_cmt_off_ilgl_o)\n`endif\n);\n\n// e203_exu_disp: Dispatches instructions for execution\ne203_exu_disp u_e203_exu_disp (\n  .wfi_halt_exu_req(wfi_halt_exu_req),\n  .wfi_halt_exu_ack(wfi_halt_exu_ack),\n  .oitf_empty(oitf_empty),\n  .amo_wait(amo_wait),\n  .disp_i_valid(disp_i_valid),\n  .disp_i_ready(disp_i_ready),\n  .disp_i_rs1x0(disp_i_rs1x0),\n  .disp_i_rs2x0(disp_i_rs2x0),\n  .disp_i_rs1en(disp_i_rs1en),\n  .disp_i_rs2en(disp_i_rs2en),\n  .disp_i_rs1idx(disp_i_rs1idx),\n  .disp_i_rs2idx(disp_i_rs2idx),\n  .disp_i_rs1(disp_i_rs1),\n  .disp_i_rs2(disp_i_rs2),\n  .disp_i_rdwen(disp_i_rdwen),\n  .disp_i_rdidx(disp_i_rdidx),\n  .disp_i_info(disp_i_info),\n  .disp_i_imm(disp_i_imm),\n  .disp_i_pc(disp_i_pc),\n  .disp_i_misalgn(disp_i_misalgn),\n  .disp_i_buserr(disp_i_buserr),\n  .disp_i_ilegl(disp_i_ilegl),\n  .disp_o_alu_valid(disp_o_alu_valid),\n  .disp_o_alu_ready(disp_o_alu_ready),\n  .disp_o_alu_longpipe(disp_o_alu_longpipe),\n  .disp_o_alu_rs1(disp_o_alu_rs1),\n  .disp_o_alu_rs2(disp_o_alu_rs2),\n  .disp_o_alu_rdwen(disp_o_alu_rdwen),\n  .disp_o_alu_rdidx(disp_o_alu_rdidx),\n  .disp_o_alu_info(disp_o_alu_info),\n  .disp_o_alu_imm(disp_o_alu_imm),\n  .disp_o_alu_pc(disp_o_alu_pc),\n  .disp_o_alu_itag(disp_o_alu_itag),\n  .disp_o_alu_misalgn(disp_o_alu_misalgn),\n  .disp_o_alu_buserr(disp_o_alu_buserr),\n  .disp_o_alu_ilegl(disp_o_alu_ilegl),\n  .oitfrd_match_disprs1(oitfrd_match_disprs1),\n  .oitfrd_match_disprs2(oitfrd_match_disprs2),\n  .oitfrd_match_disprs3(oitfrd_match_disprs3),\n  .oitfrd_match_disprd(oitfrd_match_disprd),\n  .disp_oitf_ptr(disp_oitf_ptr),\n  .disp_oitf_ena(disp_oitf_ena),\n  .disp_oitf_ready(disp_oitf_ready),\n  .disp_oitf_rs1fpu(disp_oitf_rs1fpu),\n  .disp_oitf_rs2fpu(disp_oitf_rs2fpu),\n  .disp_oitf_rs3fpu(disp_oitf_rs3fpu),\n  .disp_oitf_rdfpu(disp_oitf_rdfpu),\n  .disp_oitf_rs1en(disp_oitf_rs1en),\n  .disp_oitf_rs2en(disp_oitf_rs2en),\n  .disp_oitf_rs3en(disp_oitf_rs3en),\n  .disp_oitf_rdwen(disp_oitf_rdwen),\n  .disp_oitf_rs1idx(disp_oitf_rs1idx),\n  .disp_oitf_rs2idx(disp_oitf_rs2idx),\n  .disp_oitf_rs3idx(disp_oitf_rs3idx),\n  .disp_oitf_rdidx(disp_oitf_rdidx),\n  .disp_oitf_pc(disp_oitf_pc),\n  .clk(clk),\n  .rst_n(rst_n)\n);\n\n// e203_exu_oitf: Tracks outstanding instructions\ne203_exu_oitf u_e203_exu_oitf (\n  .dis_ready(dis_ready),\n  .dis_ena(dis_ena),\n  .ret_ena(ret_ena),\n  .dis_ptr(dis_ptr),\n  .ret_ptr(ret_ptr),\n  .ret_rdidx(ret_rdidx),\n  .ret_rdwen(ret_rdwen),\n  .ret_rdfpu(ret_rdfpu),\n  .ret_pc(ret_pc),\n  .disp_i_rs1en(disp_i_rs1en),\n  .disp_i_rs2en(disp_i_rs2en),\n  .disp_i_rs3en(disp_i_rs3en),\n  .disp_i_rdwen(disp_i_rdwen),\n  .disp_i_rs1fpu(disp_i_rs1fpu),\n  .disp_i_rs2fpu(disp_i_rs2fpu),\n  .disp_i_rs3fpu(disp_i_rs3fpu),\n  .disp_i_rdfpu(disp_i_rdfpu),\n  .disp_i_rs1idx(disp_i_rs1idx),\n  .disp_i_rs2idx(disp_i_rs2idx),\n  .disp_i_rs3idx(disp_i_rs3idx),\n  .disp_i_rdidx(disp_i_rdidx),\n  .disp_i_pc(disp_i_pc),\n  .oitfrd_match_disprs1(oitfrd_match_disprs1),\n  .oitfrd_match_disprs2(oitfrd_match_disprs2),\n  .oitfrd_match_disprs3(oitfrd_match_disprs3),\n  .oitfrd_match_disprd(oitfrd_match_disprd),\n  .oitf_empty(oitf_empty),\n  .clk(clk),\n  .rst_n(rst_n)\n);\n\n// e203_exu_alu: Executes arithmetic and logic operations\ne203_exu_alu u_e203_exu_alu (\n  .i_valid(i_valid),\n  .i_ready(i_ready),\n  .i_longpipe(i_longpipe),\n`ifdef E203_HAS_CSR_NICE\n  .nice_csr_valid(nice_csr_valid),\n  .nice_csr_ready(nice_csr_ready),\n  .nice_csr_addr(nice_csr_addr),\n  .nice_csr_wr(nice_csr_wr),\n  .nice_csr_wdata(nice_csr_wdata),\n  .nice_csr_rdata(nice_csr_rdata),\n`endif\n`ifdef E203_HAS_NICE\n  .nice_xs_off(nice_xs_off),\n`endif\n  .amo_wait(amo_wait),\n  .oitf_empty(oitf_empty),\n  .i_itag(i_itag),\n  .i_rs1(i_rs1),\n  .i_rs2(i_rs2),\n  .i_imm(i_imm),\n  .i_info(i_info),\n  .i_pc(i_pc),\n  .i_instr(i_instr),\n  .i_pc_vld(i_pc_vld),\n  .i_rdidx(i_rdidx),\n  .i_rdwen(i_rdwen),\n  .i_ilegl(i_ilegl),\n  .i_buserr(i_buserr),\n  .i_misalgn(i_misalgn),\n  .flush_req(flush_req),\n  .flush_pulse(flush_pulse),\n  // Commit interface\n  .cmt_o_valid(cmt_o_valid),\n  .cmt_o_ready(cmt_o_ready),\n  .cmt_o_pc_vld(cmt_o_pc_vld),\n  .cmt_o_pc(cmt_o_pc),\n  .cmt_o_instr(cmt_o_instr),\n  .cmt_o_imm(cmt_o_imm),\n  .cmt_o_rv32(cmt_o_rv32),\n  .cmt_o_bjp(cmt_o_bjp),\n  .cmt_o_mret(cmt_o_mret),\n  .cmt_o_dret(cmt_o_dret),\n  .cmt_o_ecall(cmt_o_ecall),\n  .cmt_o_ebreak(cmt_o_ebreak),\n  .cmt_o_fencei(cmt_o_fencei),\n  .cmt_o_wfi(cmt_o_wfi),\n  .cmt_o_ifu_misalgn(cmt_o_ifu_misalgn),\n  .cmt_o_ifu_buserr(cmt_o_ifu_buserr),\n  .cmt_o_ifu_ilegl(cmt_o_ifu_ilegl),\n  .cmt_o_bjp_prdt(cmt_o_bjp_prdt),\n  .cmt_o_bjp_rslv(cmt_o_bjp_rslv),\n  .cmt_o_misalgn(cmt_o_misalgn),\n  .cmt_o_ld(cmt_o_ld),\n  .cmt_o_stamo(cmt_o_stamo),\n  .cmt_o_buserr(cmt_o_buserr),\n  .cmt_o_badaddr(cmt_o_badaddr),\n  // Write-back interface\n  .wbck_o_valid(wbck_o_valid),\n  .wbck_o_ready(wbck_o_ready),\n  .wbck_o_wdat(wbck_o_wdat),\n  .wbck_o_rdidx(wbck_o_rdidx),\n  .mdv_nob2b(mdv_nob2b),\n  // CSR interface\n  .csr_ena(csr_ena),\n  .csr_wr_en(csr_wr_en),\n  .csr_rd_en(csr_rd_en),\n  .csr_idx(csr_idx),\n  .nonflush_cmt_ena(nonflush_cmt_ena),\n  .csr_access_ilgl(csr_access_ilgl),\n  .read_csr_dat(read_csr_dat),\n  .wbck_csr_dat(wbck_csr_dat),\n  // AGU interface\n  .agu_icb_cmd_valid(agu_icb_cmd_valid),\n  .agu_icb_cmd_ready(agu_icb_cmd_ready),\n  .agu_icb_cmd_addr(agu_icb_cmd_addr),\n  .agu_icb_cmd_read(agu_icb_cmd_read),\n  .agu_icb_cmd_wdata(agu_icb_cmd_wdata),\n  .agu_icb_cmd_wmask(agu_icb_cmd_wmask),\n  .agu_icb_cmd_lock(agu_icb_cmd_lock),\n  .agu_icb_cmd_excl(agu_icb_cmd_excl),\n  .agu_icb_cmd_size(agu_icb_cmd_size),\n  .agu_icb_cmd_back2agu(agu_icb_cmd_back2agu),\n  .agu_icb_cmd_usign(agu_icb_cmd_usign),\n  .agu_icb_cmd_itag(agu_icb_cmd_itag),\n  .agu_icb_rsp_valid(agu_icb_rsp_valid),\n  .agu_icb_rsp_ready(agu_icb_rsp_ready),\n  .agu_icb_rsp_err(agu_icb_rsp_err),\n  .agu_icb_rsp_excl_ok(agu_icb_rsp_excl_ok),\n  .agu_icb_rsp_rdata(agu_icb_rsp_rdata),\n`ifdef E203_HAS_NICE\n  // NICE interface\n  .nice_req_valid(nice_req_valid),\n  .nice_req_ready(nice_req_ready),\n  .nice_req_instr(nice_req_inst),\n  .nice_req_rs1(nice_req_rs1),\n  .nice_req_rs2(nice_req_rs2),\n  .nice_rsp_multicyc_valid(nice_rsp_multicyc_valid),\n  .nice_rsp_multicyc_ready(nice_rsp_multicyc_ready),\n  .nice_longp_wbck_valid(nice_longp_wbck_valid),\n  .nice_longp_wbck_ready(nice_longp_wbck_ready),\n  .nice_o_itag(nice_o_itag),\n  .i_nice_cmt_off_ilgl(i_nice_cmt_off_ilgl),\n`endif\n  .clk(clk),\n  .rst_n(rst_n)\n);\n\n// e203_exu_commit: Handles instruction commit and exception processing\ne203_exu_commit u_e203_exu_commit (\n  .commit_mret(commit_mret),\n  .commit_trap(commit_trap),\n  .core_wfi(core_wfi),\n  .nonflush_cmt_ena(nonflush_cmt_ena),\n  .excp_active(excp_active),\n  .amo_wait(amo_wait),\n  .wfi_halt_ifu_req(wfi_halt_ifu_req),\n  .wfi_halt_exu_req(wfi_halt_exu_req),\n  .wfi_halt_ifu_ack(wfi_halt_ifu_ack),\n  .wfi_halt_exu_ack(wfi_halt_exu_ack),\n  .dbg_irq_r(dbg_irq_r),\n  .lcl_irq_r(lcl_irq_r),\n  .ext_irq_r(ext_irq_r),\n  .sft_irq_r(sft_irq_r),\n  .tmr_irq_r(tmr_irq_r),\n  .evt_r(evt_r),\n  .status_mie_r(status_mie_r),\n  .mtie_r(mtie_r),\n  .msie_r(msie_r),\n  .meie_r(meie_r),\n  .alu_cmt_i_valid(cmt_o_valid),\n  .alu_cmt_i_ready(cmt_o_ready),\n  .alu_cmt_i_pc(cmt_o_pc),\n  .alu_cmt_i_instr(cmt_o_instr),\n  .alu_cmt_i_pc_vld(cmt_o_pc_vld),\n  .alu_cmt_i_imm(cmt_o_imm),\n  .alu_cmt_i_rv32(cmt_o_rv32),\n  .alu_cmt_i_bjp(cmt_o_bjp),\n  .alu_cmt_i_wfi(cmt_o_wfi),\n  .alu_cmt_i_fencei(cmt_o_fencei),\n  .alu_cmt_i_mret(cmt_o_mret),\n  .alu_cmt_i_dret(cmt_o_dret),\n  .alu_cmt_i_ecall(cmt_o_ecall),\n  .alu_cmt_i_ebreak(cmt_o_ebreak),\n  .alu_cmt_i_ifu_misalgn(cmt_o_ifu_misalgn),\n  .alu_cmt_i_ifu_buserr(cmt_o_ifu_buserr),\n  .alu_cmt_i_ifu_ilegl(cmt_o_ifu_ilegl),\n  .alu_cmt_i_bjp_prdt(cmt_o_bjp_prdt),\n  .alu_cmt_i_bjp_rslv(cmt_o_bjp_rslv),\n  .alu_cmt_i_misalgn(cmt_o_misalgn),\n  .alu_cmt_i_ld(cmt_o_ld),\n  .alu_cmt_i_stamo(cmt_o_stamo),\n  .alu_cmt_i_buserr(cmt_o_buserr),\n  .alu_cmt_i_badaddr(cmt_o_badaddr),\n  .cmt_badaddr(cmt_badaddr),\n  .cmt_badaddr_ena(cmt_badaddr_ena),\n  .cmt_epc(cmt_epc),\n  .cmt_epc_ena(cmt_epc_ena),\n  .cmt_cause(cmt_cause),\n  .cmt_cause_ena(cmt_cause_ena),\n  .cmt_instret_ena(cmt_instret_ena),\n  .cmt_status_ena(cmt_status_ena),\n  .cmt_dpc(cmt_dpc),\n  .cmt_dpc_ena(cmt_dpc_ena),\n  .cmt_dcause(cmt_dcause),\n  .cmt_dcause_ena(cmt_dcause_ena),\n  .cmt_mret_ena(cmt_mret_ena),\n  .csr_epc_r(csr_epc_r),\n  .csr_dpc_r(csr_dpc_r),\n  .csr_mtvec_r(csr_mtvec_r),\n  .dbg_mode(dbg_mode),\n  .dbg_halt_r(dbg_halt_r),\n  .dbg_step_r(dbg_step_r),\n  .dbg_ebreakm_r(dbg_ebreakm_r),\n  .oitf_empty(oitf_empty),\n  .u_mode(u_mode),\n  .s_mode(s_mode),\n  .h_mode(h_mode),\n  .m_mode(m_mode),\n  .longp_excp_i_ready(longp_excp_o_ready),\n  .longp_excp_i_valid(longp_excp_o_valid),\n  .longp_excp_i_ld(longp_excp_o_ld),\n  .longp_excp_i_st(longp_excp_o_st),\n  .longp_excp_i_buserr(longp_excp_o_buserr),\n  .longp_excp_i_badaddr(longp_excp_o_badaddr),\n  .longp_excp_i_insterr(longp_excp_o_insterr),\n  .longp_excp_i_pc(longp_excp_o_pc)\n);\n\n// e203_exu_csr: Performs CSR (Control and Status Register) operations\ne203_exu_csr u_e203_exu_csr (\n  .nonflush_cmt_ena(nonflush_cmt_ena),\n  .csr_ena(csr_ena),\n  .csr_wr_en(csr_wr_en),\n  .csr_rd_en(csr_rd_en),\n  .csr_idx(csr_idx),\n  .csr_access_ilgl(csr_access_ilgl),\n  .tm_stop(tm_stop),\n  .core_cgstop(core_cgstop),\n  .tcm_cgstop(tcm_cgstop),\n  .itcm_nohold(itcm_nohold),\n  .mdv_nob2b(mdv_nob2b),\n  .read_csr_dat(read_csr_dat),\n  .wbck_csr_dat(wbck_csr_dat),\n  .core_mhartid(core_mhartid),\n  .ext_irq_r(ext_irq_r),\n  .sft_irq_r(sft_irq_r),\n  .tmr_irq_r(tmr_irq_r),\n  .status_mie_r(status_mie_r),\n  .mtie_r(mtie_r),\n  .msie_r(msie_r),\n  .meie_r(meie_r),\n  .wr_dcsr_ena(wr_dcsr_ena),\n  .wr_dpc_ena(wr_dpc_ena),\n  .wr_dscratch_ena(wr_dscratch_ena),\n  .dcsr_r(dcsr_r),\n  .dpc_r(dpc_r),\n  .dscratch_r(dscratch_r),\n  .u_mode(u_mode),\n  .s_mode(s_mode),\n  .h_mode(h_mode),\n  .m_mode(m_mode),\n  .cmt_badaddr(cmt_badaddr),\n  .cmt_badaddr_ena(cmt_badaddr_ena),\n  .cmt_epc(cmt_epc),\n  .cmt_epc_ena(cmt_epc_ena),\n  .cmt_cause(cmt_cause),\n  .cmt_cause_ena(cmt_cause_ena),\n  .cmt_status_ena(cmt_status_ena),\n  .cmt_instret_ena(cmt_instret_ena),\n  .cmt_mret_ena(cmt_mret_ena),\n  .csr_epc_r(csr_epc_r),\n  .csr_dpc_r(csr_dpc_r),\n  .csr_mtvec_r(csr_mtvec_r),\n  .clk_aon(clk_aon),\n  .clk(clk),\n  .rst_n(rst_n)\n`ifdef E203_HAS_NICE\n  ,\n  .nice_xs_off(nice_xs_off)\n`endif\n);\n\n// e203_exu_longpwbck: Handles long-pipeline write-back operations\ne203_exu_longpwbck u_e203_exu_longpwbck (\n  .lsu_wbck_i_valid(lsu_o_valid),\n  .lsu_wbck_i_ready(lsu_o_ready),\n  .lsu_wbck_i_wdat(lsu_o_wbck_wdat),\n  .lsu_wbck_i_itag(lsu_o_wbck_itag),\n  .lsu_wbck_i_err(lsu_o_wbck_err),\n  .lsu_cmt_i_buserr(lsu_o_cmt_buserr),\n  .lsu_cmt_i_badaddr(lsu_o_cmt_badaddr),\n  .lsu_cmt_i_ld(lsu_o_cmt_ld),\n  .lsu_cmt_i_st(lsu_o_cmt_st),\n  .longp_wbck_o_valid(longp_wbck_o_valid),\n  .longp_wbck_o_ready(longp_wbck_o_ready),\n  .longp_wbck_o_wdat(longp_wbck_o_wdat),\n  .longp_wbck_o_flags(longp_wbck_o_flags),\n  .longp_wbck_o_rdidx(longp_wbck_o_rdidx),\n  .longp_wbck_o_rdfpu(longp_wbck_o_rdfpu),\n  .longp_excp_o_valid(longp_excp_o_valid),\n  .longp_excp_o_ready(longp_excp_o_ready),\n  .longp_excp_o_insterr(longp_excp_o_insterr),\n  .longp_excp_o_ld(longp_excp_o_ld),\n  .longp_excp_o_st(longp_excp_o_st),\n  .longp_excp_o_buserr(longp_excp_o_buserr),\n  .longp_excp_o_badaddr(longp_excp_o_badaddr),\n  .longp_excp_o_pc(longp_excp_o_pc),\n  .oitf_empty(oitf_empty),\n  .oitf_ret_ptr(oitf_ret_ptr),\n  .oitf_ret_rdidx(oitf_ret_rdidx),\n  .oitf_ret_pc(oitf_ret_pc),\n  .oitf_ret_rdwen(oitf_ret_rdwen),\n  .oitf_ret_rdfpu(oitf_ret_rdfpu),\n  .oitf_ret_ena(oitf_ret_ena),\n  .clk(clk),\n  .rst_n(rst_n)\n`ifdef E203_HAS_NICE\n  ,\n  .nice_longp_wbck_i_valid(nice_longp_wbck_valid),\n  .nice_longp_wbck_i_ready(nice_longp_wbck_ready),\n  .nice_longp_wbck_i_wdat(nice_rsp_multicyc_dat),\n  .nice_longp_wbck_i_itag(nice_o_itag),\n  .nice_longp_wbck_i_err(nice_rsp_multicyc_err)\n`endif\n);\n\n// e203_exu_wbck: Handles final instruction write-back\ne203_exu_wbck u_e203_exu_wbck (\n  .alu_wbck_i_valid(wbck_o_valid),\n  .alu_wbck_i_ready(wbck_o_ready),\n  .alu_wbck_i_wdat(wbck_o_wdat),\n  .alu_wbck_i_rdidx(wbck_o_rdidx),\n  .longp_wbck_i_valid(longp_wbck_o_valid),\n  .longp_wbck_i_ready(longp_wbck_o_ready),\n  .longp_wbck_i_wdat(longp_wbck_o_wdat),\n  .longp_wbck_i_flags(longp_wbck_o_flags),\n  .longp_wbck_i_rdidx(longp_wbck_o_rdidx),\n  .longp_wbck_i_rdfpu(longp_wbck_o_rdfpu),\n  .rf_wbck_o_ena(rf_wbck_o_ena),\n  .rf_wbck_o_wdat(rf_wbck_o_wdat),\n  .rf_wbck_o_rdidx(rf_wbck_o_rdidx),\n  .clk(clk),\n  .rst_n(rst_n)\n);\n\n// Additional logic and connections can be added here\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_csrctrl", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_alu_csrctrl(\n  // Input interface\n  input        csr_i_valid,     // Valid-ready handshake signal\n  output       csr_i_ready,     // Valid-ready handshake signal\n  \n  input  [E203_XLEN-1:0] csr_i_rs1,       // Source register 1\n  input  [E203_DECINFO_CSR_WIDTH-1:0] csr_i_info, // CSR instruction information\n  input        csr_i_rdwen,     // Destination reg need to be written\n  \n  // Output interface\n  output       csr_ena,         // Enable signal for CSR module\n  output       csr_wr_en,       // Write signal for CSR\n  output       csr_rd_en,       // Read signal for CSR\n  output [11:0] csr_idx,        // CSR address index\n  \n  input        csr_access_ilgl, // Illegal access signal\n  input  [E203_XLEN-1:0] read_csr_dat,    // Data read from the CSR\n  output [E203_XLEN-1:0] wbck_csr_dat,    // Data written back to CSR\n\n  output       csr_o_valid,     // Valid signal for CSR output\n  input        csr_o_ready,     // Ready signal for CSR output\n  output [E203_XLEN-1:0] csr_o_wbck_wdat, // Special write-back data\n  output       csr_o_wbck_err,  // Special write-back error\n  \n  // Clock and reset\n  input        clk,             // Clock signal\n  input        rst_n            // Reset signal\n`ifdef E203_HAS_CSR_NICE\n  ,\n  // NICE interface\n  input        nice_xs_off,     // Flag to disable NICE interface\n  output       csr_sel_nice,    // Selects the NICE CSR range\n  output       nice_csr_valid,  // Indicates valid NICE CSR data\n  input        nice_csr_ready,  // Indicates that NICE CSR is ready\n  output [31:0] nice_csr_addr,  // Address of the NICE CSR\n  output       nice_csr_wr,     // Write enable for NICE CSR\n  output [31:0] nice_csr_wdata, // Write data for NICE CSR\n  input  [31:0] nice_csr_rdata  // Read data from NICE CSR\n`endif\n);\n\n  // Extract fields from csr_i_info\n  wire        csrrw    = csr_i_info [`E203_DECINFO_CSR_CSRRW];\n  wire        csrrs    = csr_i_info [`E203_DECINFO_CSR_CSRRS];\n  wire        csrrc    = csr_i_info [`E203_DECINFO_CSR_CSRRC];\n  wire        rs1imm   = csr_i_info [`E203_DECINFO_CSR_RS1IMM];\n  wire        rs1is0   = csr_i_info [`E203_DECINFO_CSR_RS1IS0];\n  wire [4:0]  zimm     = csr_i_info [`E203_DECINFO_CSR_ZIMM_MSB:`E203_DECINFO_CSR_ZIMM_LSB];\n  assign      csr_idx  = csr_i_info [`E203_DECINFO_CSR_CSRIDX_MSB:`E203_DECINFO_CSR_CSRIDX_LSB];\n  \n  // Prepare Operand\n  wire [E203_XLEN-1:0] csr_op1;\n  assign csr_op1 = rs1imm ? {{(E203_XLEN - 5){1'b0}}, zimm} : csr_i_rs1;\n\n  // Generate control signals\n  assign csr_rd_en = csr_i_valid & ((csrrw & csr_i_rdwen) | csrrs | csrrc);\n  assign csr_wr_en = csr_i_valid & (csrrw | ((csrrs | csrrc) & ~rs1is0));\n  \n  // Data to be written back to CSR\n  wire [E203_XLEN-1:0] wbck_csr_dat_csrrw = csr_op1;\n  wire [E203_XLEN-1:0] wbck_csr_dat_csrrs = csr_op1 | read_csr_dat;\n  wire [E203_XLEN-1:0] wbck_csr_dat_csrrc = (~csr_op1) & read_csr_dat;\n  \n  assign wbck_csr_dat = ({E203_XLEN{csrrw}} & wbck_csr_dat_csrrw) |\n                        ({E203_XLEN{csrrs}} & wbck_csr_dat_csrrs) |\n                        ({E203_XLEN{csrrc}} & wbck_csr_dat_csrrc);\n\n  // Error handling\n  assign csr_o_wbck_err = csr_access_ilgl;\n\n`ifdef E203_HAS_CSR_NICE\n  // Determine if NICE interface should be used\n  assign csr_sel_nice = (csr_idx[11:8] == 4'hE) & ~nice_xs_off;\n  \n  // csr_o_valid and csr_i_ready handling with NICE\n  assign csr_o_valid = csr_sel_nice ? (csr_i_valid & nice_csr_ready) : csr_i_valid;\n  assign csr_i_ready = csr_o_ready;\n  \n  assign nice_csr_valid = csr_sel_nice ? (csr_i_valid & csr_o_ready) : 1'b0;\n  \n  // NICE CSR interface signals\n  assign nice_csr_addr = {20'b0, csr_idx};\n  assign nice_csr_wr = csr_sel_nice & csr_wr_en;\n  assign nice_csr_wdata = wbck_csr_dat;\n\n  // CSR enable signal\n  assign csr_ena = csr_o_valid & csr_o_ready & ~csr_sel_nice;\n\n  // Return data from CSR or NICE\n  assign csr_o_wbck_wdat = csr_sel_nice ? nice_csr_rdata : read_csr_dat;\n  \n`else\n\n  // No NICE interface\n  assign csr_sel_nice = 1'b0; // Not used\n  assign csr_o_valid = csr_i_valid;\n  assign csr_i_ready = csr_o_ready;\n  \n  assign csr_ena = csr_o_valid & csr_o_ready;\n\n  // Return data from CSR\n  assign csr_o_wbck_wdat = read_csr_dat;\n  \n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_core", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_core(\n    // System Interface\n    output [E203_PC_SIZE-1:0] inspect_pc,       // Current Program Counter (PC) value\n    output                    core_wfi,         // Core is in Wait-For-Interrupt (WFI) state\n    output                    tm_stop,          // Debug stop signal to stop the processor\n    output                    core_cgstop,      // Core clock gating stop signal\n    output                    tcm_cgstop,       // TCM clock gating stop signal\n    input  [E203_PC_SIZE-1:0] pc_rtvec,         // Reset vector address\n    input  [E203_HART_ID_W-1:0] core_mhartid,   // Hardware Thread ID\n    input                     dbg_irq_r,        // Debug interrupt signal\n    input  [E203_LIRQ_NUM-1:0] lcl_irq_r,       // Local interrupt signal vector\n    input  [E203_EVT_NUM-1:0] evt_r,            // Special event trigger signal\n    input                     ext_irq_r,        // External interrupt signal\n    input                     sft_irq_r,        // Software interrupt signal\n    input                     tmr_irq_r,        // Timer interrupt signal\n    output                    wr_dcsr_ena,      // Write enable for DCSR\n    output                    wr_dpc_ena,       // Write enable for DPC\n    output                    wr_dscratch_ena,  // Write enable for DSCRATCH\n    output [31:0]             wr_csr_nxt,       // Data to write to CSR\n    input  [31:0]             dcsr_r,           // Current value of DCSR\n    input  [E203_PC_SIZE-1:0] dpc_r,            // Current value of DPC\n    input  [31:0]             dscratch_r,       // Current value of DSCRATCH\n    output [E203_PC_SIZE-1:0] cmt_dpc,          // Committed PC value\n    output                    cmt_dpc_ena,      // Enable signal for cmt_dpc\n    output [2:0]              cmt_dcause,       // Cause code for committed exception\n    output                    cmt_dcause_ena,   // Enable signal for cmt_dcause\n    input                     dbg_mode,         // Debug mode flag\n    input                     dbg_halt_r,       // Debug halt signal\n    input                     dbg_step_r,       // Debug single-step signal\n    input                     dbg_ebreakm_r,    // Debug ebreak in M mode signal\n    input                     dbg_stopcycle,    // Debug stop cycle signal\n\n    // ICB Interfaces\n    // Note: For each ICB interface group, we have similar signals.\n    // PPI Interface\n    input                     ppi_icb_enable,       // PPI enable signal\n    output                    ppi_icb_cmd_valid,    // PPI ICB command valid\n    input                     ppi_icb_cmd_ready,    // PPI ICB command ready\n    output [E203_ADDR_SIZE-1:0] ppi_icb_cmd_addr,    // PPI ICB command address\n    output                    ppi_icb_cmd_read,     // PPI ICB command read/write\n    output [E203_XLEN-1:0]    ppi_icb_cmd_wdata,    // PPI ICB write data\n    output [E203_XLEN/8-1:0]  ppi_icb_cmd_wmask,    // PPI ICB write mask\n    output                    ppi_icb_cmd_lock,     // PPI ICB lock signal\n    output                    ppi_icb_cmd_excl,     // PPI ICB exclusive access\n    output [1:0]              ppi_icb_cmd_size,     // PPI ICB transaction size\n    input                     ppi_icb_rsp_valid,    // PPI ICB response valid\n    output                    ppi_icb_rsp_ready,    // PPI ICB response ready\n    input                     ppi_icb_rsp_err,      // PPI ICB response error\n    input                     ppi_icb_rsp_excl_ok,  // PPI ICB exclusive access success\n    input  [E203_XLEN-1:0]    ppi_icb_rsp_rdata,    // PPI ICB read data\n    input  [E203_ADDR_SIZE-1:0] ppi_region_indic,    // PPI region indicator\n\n    // CLINT Interface\n    input                     clint_icb_enable,     // CLINT enable signal\n    output                    clint_icb_cmd_valid,  // CLINT ICB command valid\n    input                     clint_icb_cmd_ready,  // CLINT ICB command ready\n    output [E203_ADDR_SIZE-1:0] clint_icb_cmd_addr,  // CLINT ICB command address\n    output                    clint_icb_cmd_read,   // CLINT ICB command read/write\n    output [E203_XLEN-1:0]    clint_icb_cmd_wdata,  // CLINT ICB write data\n    output [E203_XLEN/8-1:0]  clint_icb_cmd_wmask,  // CLINT ICB write mask\n    output                    clint_icb_cmd_lock,   // CLINT ICB lock signal\n    output                    clint_icb_cmd_excl,   // CLINT ICB exclusive access\n    output [1:0]              clint_icb_cmd_size,   // CLINT ICB transaction size\n    input                     clint_icb_rsp_valid,  // CLINT ICB response valid\n    output                    clint_icb_rsp_ready,  // CLINT ICB response ready\n    input                     clint_icb_rsp_err,    // CLINT ICB response error\n    input                     clint_icb_rsp_excl_ok,// CLINT ICB exclusive access success\n    input  [E203_XLEN-1:0]    clint_icb_rsp_rdata,  // CLINT ICB read data\n    input  [E203_ADDR_SIZE-1:0] clint_region_indic,  // CLINT region indicator\n\n    // PLIC Interface\n    input                     plic_icb_enable,      // PLIC enable signal\n    output                    plic_icb_cmd_valid,   // PLIC ICB command valid\n    input                     plic_icb_cmd_ready,   // PLIC ICB command ready\n    output [E203_ADDR_SIZE-1:0] plic_icb_cmd_addr,   // PLIC ICB command address\n    output                    plic_icb_cmd_read,    // PLIC ICB command read/write\n    output [E203_XLEN-1:0]    plic_icb_cmd_wdata,   // PLIC ICB write data\n    output [E203_XLEN/8-1:0]  plic_icb_cmd_wmask,   // PLIC ICB write mask\n    output                    plic_icb_cmd_lock,    // PLIC ICB lock signal\n    output                    plic_icb_cmd_excl,    // PLIC ICB exclusive access\n    output [1:0]              plic_icb_cmd_size,    // PLIC ICB transaction size\n    input                     plic_icb_rsp_valid,   // PLIC ICB response valid\n    output                    plic_icb_rsp_ready,   // PLIC ICB response ready\n    input                     plic_icb_rsp_err,     // PLIC ICB response error\n    input                     plic_icb_rsp_excl_ok, // PLIC ICB exclusive access success\n    input  [E203_XLEN-1:0]    plic_icb_rsp_rdata,   // PLIC ICB read data\n    input  [E203_ADDR_SIZE-1:0] plic_region_indic,   // PLIC region indicator\n\n`ifdef E203_HAS_FIO\n    // FIO Interface\n    input                     fio_icb_enable,       // FIO enable signal\n    output                    fio_icb_cmd_valid,    // FIO ICB command valid\n    input                     fio_icb_cmd_ready,    // FIO ICB command ready\n    output [E203_ADDR_SIZE-1:0] fio_icb_cmd_addr,    // FIO ICB command address\n    output                    fio_icb_cmd_read,     // FIO ICB command read/write\n    output [E203_XLEN-1:0]    fio_icb_cmd_wdata,    // FIO ICB write data\n    output [E203_XLEN/8-1:0]  fio_icb_cmd_wmask,    // FIO ICB write mask\n    output                    fio_icb_cmd_lock,     // FIO ICB lock signal\n    output                    fio_icb_cmd_excl,     // FIO ICB exclusive access\n    output [1:0]              fio_icb_cmd_size,     // FIO ICB transaction size\n    input                     fio_icb_rsp_valid,    // FIO ICB response valid\n    output                    fio_icb_rsp_ready,    // FIO ICB response ready\n    input                     fio_icb_rsp_err,      // FIO ICB response error\n    input                     fio_icb_rsp_excl_ok,  // FIO ICB exclusive access success\n    input  [E203_XLEN-1:0]    fio_icb_rsp_rdata,    // FIO ICB read data\n    input  [E203_ADDR_SIZE-1:0] fio_region_indic,    // FIO region indicator\n`endif\n\n`ifdef E203_HAS_ITCM\n    // ITCM Interface (Instruction TCM)\n    output                    ifu2itcm_icb_cmd_valid, // IFU to ITCM command valid\n    input                     ifu2itcm_icb_cmd_ready, // IFU to ITCM command ready\n    output [E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr, // IFU to ITCM address\n    input                     ifu2itcm_icb_rsp_valid, // ITCM response valid\n    output                    ifu2itcm_icb_rsp_ready, // IFU ready to receive response\n    input                     ifu2itcm_icb_rsp_err,   // ITCM response error\n    input  [E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata, // ITCM read data\n    input  [E203_ADDR_SIZE-1:0] itcm_region_indic,     // ITCM region indicator\n`endif\n\n`ifdef E203_HAS_DTCM\n    // DTCM Interface (Data TCM)\n    input  [E203_ADDR_SIZE-1:0] dtcm_region_indic,   // DTCM region indicator\n    // LSU to DTCM ICB interface signals...\n`endif\n\n`ifdef E203_HAS_NICE\n    // NICE Interface\n    input                     nice_mem_holdup,          // NICE memory holdup signal\n    output                    nice_req_valid,           // NICE request valid\n    input                     nice_req_ready,           // NICE request ready\n    output [E203_XLEN-1:0]    nice_req_inst,            // NICE instruction\n    output [E203_XLEN-1:0]    nice_req_rs1,             // NICE operand rs1\n    output [E203_XLEN-1:0]    nice_req_rs2,             // NICE operand rs2\n    input                     nice_rsp_multicyc_valid,  // NICE multi-cycle response valid\n    output                    nice_rsp_multicyc_ready,  // NICE multi-cycle response ready\n    input  [E203_XLEN-1:0]    nice_rsp_multicyc_dat,    // NICE multi-cycle data\n    input                     nice_rsp_multicyc_err,    // NICE multi-cycle error\n    input                     nice_icb_cmd_valid,       // NICE ICB command valid\n    output                    nice_icb_cmd_ready,       // NICE ICB command ready\n    input  [E203_XLEN-1:0]    nice_icb_cmd_addr,        // NICE ICB command address\n    input                     nice_icb_cmd_read,        // NICE ICB command read/write\n    input  [E203_XLEN-1:0]    nice_icb_cmd_wdata,       // NICE ICB write data\n    input  [1:0]              nice_icb_cmd_size,        // NICE ICB transaction size\n    output                    nice_icb_rsp_valid,       // NICE ICB response valid\n    input                     nice_icb_rsp_ready,       // NICE ICB response ready\n    output [E203_XLEN-1:0]    nice_icb_rsp_rdata,       // NICE ICB read data\n    output                    nice_icb_rsp_err          // NICE ICB response error\n`endif\n    // Add other interfaces as necessary\n\n    // Clock and Reset\n    ,input clk,                                         // System clock\n    input clk_aon,                                      // Always-on clock\n    input rst_n                                         // Active-low reset signal\n);\n\n// Internal signal declarations and module instantiations\n// ...\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu_dpath", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_alu_dpath(\n    // Inputs\n    // ALU request signals\n    input  wire                     alu_req_alu,\n    input  wire                     alu_req_alu_add,\n    input  wire                     alu_req_alu_sub,\n    input  wire                     alu_req_alu_xor,\n    input  wire                     alu_req_alu_sll,\n    input  wire                     alu_req_alu_srl,\n    input  wire                     alu_req_alu_sra,\n    input  wire                     alu_req_alu_or,\n    input  wire                     alu_req_alu_and,\n    input  wire [E203_XLEN-1:0]     alu_req_alu_op1,\n    input  wire [E203_XLEN-1:0]     alu_req_alu_op2,\n\n    // BJP request signals\n    input  wire                     bjp_req_alu,\n    input  wire [E203_XLEN-1:0]     bjp_req_alu_op1,\n    input  wire [E203_XLEN-1:0]     bjp_req_alu_op2,\n\n    // AGU request signals\n    input  wire                     agu_req_alu,\n    input  wire [E203_XLEN-1:0]     agu_req_alu_op1,\n    input  wire [E203_XLEN-1:0]     agu_req_alu_op2,\n\n    // MULDIV request signals (if enabled)\n    input  wire                     muldiv_req_alu,\n    input  wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1,\n    input  wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2,\n    input  wire                     muldiv_req_alu_add,\n    input  wire                     muldiv_req_alu_sub,\n    input  wire                     muldiv_sbf_0_ena,\n    input  wire [32:0]              muldiv_sbf_0_nxt,\n    input  wire                     muldiv_sbf_1_ena,\n    input  wire [32:0]              muldiv_sbf_1_nxt,\n\n    // Clock and reset\n    input  wire                     clk,\n    input  wire                     rst_n,\n\n    // Outputs\n    // ALU result\n    output wire [E203_XLEN-1:0]     alu_req_alu_res,\n\n    // BJP result\n    output wire [E203_XLEN-1:0]     bjp_req_alu_add_res,\n    output wire                     bjp_req_alu_cmp_res,\n\n    // AGU result\n    output wire [E203_XLEN-1:0]     agu_req_alu_res,\n\n    // MULDIV result\n    output wire [E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res,\n\n    // Shared buffers\n    output wire [32:0]              muldiv_sbf_0_r,\n    output wire [32:0]              muldiv_sbf_1_r\n);\n\n// ALU operation\nwire [E203_XLEN-1:0] alu_op1 = alu_req_alu_op1;\nwire [E203_XLEN-1:0] alu_op2 = alu_req_alu_op2;\n\nwire [E203_XLEN-1:0] alu_add_res = alu_op1 + alu_op2;\nwire [E203_XLEN-1:0] alu_sub_res = alu_op1 - alu_op2;\nwire [E203_XLEN-1:0] alu_xor_res = alu_op1 ^ alu_op2;\nwire [E203_XLEN-1:0] alu_sll_res = alu_op1 << alu_op2[4:0];\nwire [E203_XLEN-1:0] alu_srl_res = alu_op1 >> alu_op2[4:0];\nwire [E203_XLEN-1:0] alu_sra_res = $signed(alu_op1) >>> alu_op2[4:0];\nwire [E203_XLEN-1:0] alu_or_res  = alu_op1 | alu_op2;\nwire [E203_XLEN-1:0] alu_and_res = alu_op1 & alu_op2;\n\nassign alu_req_alu_res = ({E203_XLEN{alu_req_alu_add}} & alu_add_res)\n                       | ({E203_XLEN{alu_req_alu_sub}} & alu_sub_res)\n                       | ({E203_XLEN{alu_req_alu_xor}} & alu_xor_res)\n                       | ({E203_XLEN{alu_req_alu_sll}} & alu_sll_res)\n                       | ({E203_XLEN{alu_req_alu_srl}} & alu_srl_res)\n                       | ({E203_XLEN{alu_req_alu_sra}} & alu_sra_res)\n                       | ({E203_XLEN{alu_req_alu_or }} & alu_or_res )\n                       | ({E203_XLEN{alu_req_alu_and}} & alu_and_res);\n\n// BJP operation\nassign bjp_req_alu_add_res = bjp_req_alu_op1 + bjp_req_alu_op2;\n\n// Comparison result\nassign bjp_req_alu_cmp_res = (bjp_req_alu_op1 == bjp_req_alu_op2);\n\n// AGU operation\nassign agu_req_alu_res = agu_req_alu_op1 + agu_req_alu_op2;\n\n// MULDIV operation\nwire [E203_ALU_ADDER_WIDTH-1:0] muldiv_op1 = muldiv_req_alu_op1;\nwire [E203_ALU_ADDER_WIDTH-1:0] muldiv_op2 = muldiv_req_alu_op2;\n\nwire [E203_ALU_ADDER_WIDTH-1:0] muldiv_add_res = muldiv_op1 + muldiv_op2;\nwire [E203_ALU_ADDER_WIDTH-1:0] muldiv_sub_res = muldiv_op1 - muldiv_op2;\n\nassign muldiv_req_alu_res = ({E203_ALU_ADDER_WIDTH{muldiv_req_alu_add}} & muldiv_add_res)\n                          | ({E203_ALU_ADDER_WIDTH{muldiv_req_alu_sub}} & muldiv_sub_res);\n\n// Shared buffer registers using sirv_gnrl_dffl module\nsirv_gnrl_dffl #(\n    .DW(33)\n) sbf_0_dffl (\n    .lden ( muldiv_sbf_0_ena ),\n    .dnxt ( muldiv_sbf_0_nxt ),\n    .qout ( muldiv_sbf_0_r ),\n    .clk  ( clk )\n);\n\nsirv_gnrl_dffl #(\n    .DW(33)\n) sbf_1_dffl (\n    .lden ( muldiv_sbf_1_ena ),\n    .dnxt ( muldiv_sbf_1_nxt ),\n    .qout ( muldiv_sbf_1_r ),\n    .clk  ( clk )\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_regfile", "codeid": 1, "code": "`ifdef E203_CFG_REGNUM_IS_32\n  `define E203_RFREG_NUM   32\n  `define E203_RFIDX_WIDTH  5\n`elsif E203_CFG_REGNUM_IS_16\n  `define E203_RFREG_NUM   16\n  `define E203_RFIDX_WIDTH  4\n`else\n  // Default to 32 registers\n  `define E203_RFREG_NUM   32\n  `define E203_RFIDX_WIDTH  5\n`endif\n\n`ifndef E203_XLEN\n  `define E203_XLEN 32\n`endif\n\nmodule e203_exu_regfile(\n  input  [`E203_RFIDX_WIDTH-1:0] read_src1_idx,\n  input  [`E203_RFIDX_WIDTH-1:0] read_src2_idx,\n  output reg [`E203_XLEN-1:0]    read_src1_dat,\n  output reg [`E203_XLEN-1:0]    read_src2_dat,\n  input                          wbck_dest_wen,\n  input  [`E203_RFIDX_WIDTH-1:0] wbck_dest_idx,\n  input  [`E203_XLEN-1:0]        wbck_dest_dat,\n  output [`E203_XLEN-1:0]        x1_r,\n  input                          test_mode,\n  input                          clk,\n  input                          rst_n\n);\n\n`ifdef E203_REGFILE_LATCH_BASED\n\n  // Latch-based implementation\n  reg [`E203_XLEN-1:0] rf_r [1:`E203_RFREG_NUM-1];\n\n  wire wbck_dest_wen_clk = wbck_dest_wen;\n\n  wire clk_gated;\n\n  e203_clkgate u_e203_clkgate(\n    .clk_in(clk),\n    .test_mode(test_mode), \n    .clock_en(wbck_dest_wen_clk), \n    .clk_out(clk_gated)\n  );\n\n  genvar i;\n  generate\n    for (i = 1; i < `E203_RFREG_NUM; i = i + 1) begin : regfile\n      wire lden = (wbck_dest_idx == i) & wbck_dest_wen;\n      sirv_gnrl_ltch #(`E203_XLEN) u_sirv_gnrl_ltch(\n        .lden(lden),\n        .dnxt(wbck_dest_dat),\n        .qout(rf_r[i])\n      );\n    end\n  endgenerate\n\n  // Read ports\n  always @(*) begin\n    if (read_src1_idx == 0)\n      read_src1_dat = {`E203_XLEN{1'b0}};\n    else\n      read_src1_dat = rf_r[read_src1_idx];\n  end\n\n  always @(*) begin\n    if (read_src2_idx == 0)\n      read_src2_dat = {`E203_XLEN{1'b0}};\n    else\n      read_src2_dat = rf_r[read_src2_idx];\n  end\n\n  assign x1_r = rf_r[1];\n\n`else\n\n  // DFF-based implementation\n  reg [`E203_XLEN-1:0] rf_r [1:`E203_RFREG_NUM-1];\n\n  // Write port\n  always @(posedge clk) begin\n    if (wbck_dest_wen && (wbck_dest_idx != 0)) begin\n      rf_r[wbck_dest_idx] <= wbck_dest_dat;\n    end\n  end\n\n  // Read port 1\n  always @(*) begin\n    if (read_src1_idx == 0)\n      read_src1_dat = {`E203_XLEN{1'b0}};\n    else\n      read_src1_dat = rf_r[read_src1_idx];\n  end\n\n  // Read port 2\n  always @(*) begin\n    if (read_src2_idx == 0)\n      read_src2_dat = {`E203_XLEN{1'b0}};\n    else\n      read_src2_dat = rf_r[read_src2_idx];\n  end\n\n  assign x1_r = rf_r[1];\n\n`endif\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_cpu (\n    // Core Interfaces\n    output [E203_PC_SIZE-1:0] inspect_pc,           // Current instruction address\n    output                    inspect_dbg_irq,      // Debug interrupt signal\n    output                    inspect_mem_cmd_valid,// Memory command valid signal\n    output                    inspect_mem_cmd_ready,// Memory command ready signal\n    output                    inspect_mem_rsp_valid,// Memory response valid signal\n    output                    inspect_mem_rsp_ready,// Memory response ready signal\n    output                    inspect_core_clk,     // Core module clock signal\n    output                    core_csr_clk,         // Clock signal for CSR registers\n    output                    core_wfi,             // Core work completion signal\n    output                    tm_stop,              // Timer stop signal\n    input  [E203_PC_SIZE-1:0] pc_rtvec,             // Reset vector address\n    input  [E203_HART_ID_W-1:0] core_mhartid,       // Hardware thread ID\n    input                     dbg_irq_a,            // Original debug interrupt signal\n    input                     ext_irq_a,            // Original external interrupt signal\n    input                     sft_irq_a,            // Original software interrupt signal\n    input                     tmr_irq_a,            // Original timer interrupt signal\n\n    // ITCM Interfaces (Optional)\n`ifdef E203_HAS_ITCM\n    output                    itcm_ls,              // ITCM clock inactivation signal\n    output                    itcm_ram_cs,          // ITCM RAM chip select\n    output                    itcm_ram_we,          // ITCM write enable\n    output [E203_ITCM_RAM_AW-1:0] itcm_ram_addr,    // ITCM address\n    output [E203_ITCM_RAM_MW-1:0] itcm_ram_wem,     // ITCM write mask\n    output [E203_ITCM_RAM_DW-1:0] itcm_ram_din,     // ITCM write data\n    input  [E203_ITCM_RAM_DW-1:0] itcm_ram_dout,    // ITCM read data\n    output                    clk_itcm_ram,         // ITCM RAM clock\n`endif\n\n    // DTCM Interfaces (Optional)\n`ifdef E203_HAS_DTCM\n    output                    rst_dtcm,             // DTCM reset signal\n    output                    dtcm_ls,              // DTCM clock inactivation signal\n    output                    dtcm_ram_cs,          // DTCM RAM chip select\n    output                    dtcm_ram_we,          // DTCM write enable\n    output [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,    // DTCM address\n    output [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,     // DTCM write mask\n    output [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,     // DTCM write data\n    input  [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,    // DTCM read data\n    output                    clk_dtcm_ram,         // DTCM RAM clock\n`endif\n\n    // Debug Related Interface\n    output [E203_PC_SIZE-1:0] cmt_dpc,              // Debug mode PC value\n    output                    cmt_dpc_ena,          // DPC register update enable\n    output [2:0]              cmt_dcause,           // Debug cause code\n    output                    cmt_dcause_ena,       // DCAUSE register update enable\n    output                    dbg_irq_r,            // Synchronized debug interrupt signal\n    output                    wr_dcsr_ena,          // Write DCSR enable\n    output                    wr_dpc_ena,           // Write DPC enable\n    output                    wr_dscratch_ena,      // Write DSCRATCH enable\n    output [31:0]             wr_csr_nxt,           // Next CSR write data\n    input  [31:0]             dcsr_r,               // Current DCSR value\n    input  [E203_PC_SIZE-1:0] dpc_r,                // Current DPC value\n    input  [31:0]             dscratch_r,           // Current DSCRATCH value\n    input                     dbg_mode,             // Debug mode indicator\n    input                     dbg_halt_r,           // Debug halt signal\n    input                     dbg_step_r,           // Debug step signal\n    input                     dbg_ebreakm_r,        // EBREAK in M mode\n    input                     dbg_stopcycle,        // Debug stop cycle signal\n\n    // External-agent ICB to ITCM (Optional)\n`ifdef E203_HAS_ITCM\n    input                     ext2itcm_icb_cmd_valid, // External ITCM command valid\n    output                    ext2itcm_icb_cmd_ready, // External ITCM command ready\n    input  [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr, // External ITCM address\n    input                     ext2itcm_icb_cmd_read,  // External ITCM read command\n    input  [E203_XLEN-1:0]    ext2itcm_icb_cmd_wdata, // External ITCM write data\n    input  [E203_XLEN/8-1:0]  ext2itcm_icb_cmd_wmask, // External ITCM write mask\n    output                    ext2itcm_icb_rsp_valid, // External ITCM response valid\n    input                     ext2itcm_icb_rsp_ready, // External ITCM response ready\n    output                    ext2itcm_icb_rsp_err,   // External ITCM response error\n    output [E203_XLEN-1:0]    ext2itcm_icb_rsp_rdata, // External ITCM read data\n`endif\n\n    // External-agent ICB to DTCM (Optional)\n`ifdef E203_HAS_DTCM\n    input                     ext2dtcm_icb_cmd_valid, // External DTCM command valid\n    output                    ext2dtcm_icb_cmd_ready, // External DTCM command ready\n    input  [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr, // External DTCM address\n    input                     ext2dtcm_icb_cmd_read,  // External DTCM read command\n    input  [E203_XLEN-1:0]    ext2dtcm_icb_cmd_wdata, // External DTCM write data\n    input  [E203_XLEN/8-1:0]  ext2dtcm_icb_cmd_wmask, // External DTCM write mask\n    output                    ext2dtcm_icb_rsp_valid, // External DTCM response valid\n    input                     ext2dtcm_icb_rsp_ready, // External DTCM response ready\n    output                    ext2dtcm_icb_rsp_err,   // External DTCM response error\n    output [E203_XLEN-1:0]    ext2dtcm_icb_rsp_rdata, // External DTCM read data\n`endif\n\n    // ICB Interfaces with PPI, CLINT, PLIC, FIO, etc.\n    // (Omitted for brevity; should be defined based on the detailed ICB interface specifications)\n\n    // Clock and Reset Signals\n    input                     clk,                   // Main clock signal\n    input                     rst_n                  // Main reset signal\n);\n\n// Internal signal declarations\nwire                         rst_core;\nwire                         rst_itcm;\nwire                         rst_dtcm;\nwire                         rst_aon;\nwire                         clk_core_ifu;\nwire                         clk_core_exu;\nwire                         clk_core_lsu;\nwire                         clk_core_biu;\nwire                         clk_itcm;\nwire                         clk_dtcm;\n\n// Instantiate reset control module\ne203_reset_ctrl u_e203_reset_ctrl(\n    .clk                (clk            ),\n    .rst_n              (rst_n          ),\n    .test_mode          (1'b0           ), // Assuming test mode is inactive\n    .rst_core           (rst_core       ),\n`ifdef E203_HAS_ITCM\n    .rst_itcm           (rst_itcm       ),\n`endif\n`ifdef E203_HAS_DTCM\n    .rst_dtcm           (rst_dtcm       ),\n`endif\n    .rst_aon            (rst_aon        )\n);\n\n// Instantiate clock control module\ne203_clk_ctrl u_e203_clk_ctrl(\n    .clk                (clk            ),\n    .rst_n              (rst_n          ),\n    .test_mode          (1'b0           ),\n    .core_cgstop        (1'b0           ),\n    // Active status signals from core modules\n    .core_ifu_active    (/* Connect as per design */),\n    .core_exu_active    (/* Connect as per design */),\n    .core_lsu_active    (/* Connect as per design */),\n    .core_biu_active    (/* Connect as per design */),\n    .core_wfi           (core_wfi       ),\n`ifdef E203_HAS_ITCM\n    .itcm_active        (/* Connect as per design */),\n    .itcm_ls            (itcm_ls        ),\n    .clk_itcm           (clk_itcm       ),\n`endif\n`ifdef E203_HAS_DTCM\n    .dtcm_active        (/* Connect as per design */),\n    .dtcm_ls            (dtcm_ls        ),\n    .clk_dtcm           (clk_dtcm       ),\n`endif\n    .clk_aon            (/* Provide as per design */),\n    .clk_core_ifu       (clk_core_ifu   ),\n    .clk_core_exu       (clk_core_exu   ),\n    .clk_core_lsu       (clk_core_lsu   ),\n    .clk_core_biu       (clk_core_biu   )\n);\n\n// Instantiate IRQ synchronization module\ne203_irq_sync u_e203_irq_sync(\n    .clk                (clk            ),\n    .rst_n              (rst_n          ),\n    .dbg_irq_a          (dbg_irq_a      ),\n    .ext_irq_a          (ext_irq_a      ),\n    .sft_irq_a          (sft_irq_a      ),\n    .tmr_irq_a          (tmr_irq_a      ),\n    .dbg_irq_r          (dbg_irq_r      ),\n    .ext_irq_r          (/* Connect as per design */),\n    .sft_irq_r          (/* Connect as per design */),\n    .tmr_irq_r          (/* Connect as per design */)\n);\n\n// Instantiate core module\ne203_core u_e203_core(\n    .clk                (clk_core_exu   ),\n    .rst_n              (rst_core       ),\n    .inspect_pc         (inspect_pc     ),\n    .core_wfi           (core_wfi       ),\n    .tm_stop            (tm_stop        ),\n    .pc_rtvec           (pc_rtvec       ),\n    .core_mhartid       (core_mhartid   ),\n    .dbg_irq_r          (dbg_irq_r      ),\n    .lcl_irq_r          (/* Connect as per design */),\n    .evt_r              (/* Connect as per design */),\n    .ext_irq_r          (/* Connect as per design */),\n    .sft_irq_r          (/* Connect as per design */),\n    .tmr_irq_r          (/* Connect as per design */),\n    .wr_dcsr_ena        (wr_dcsr_ena    ),\n    .wr_dpc_ena         (wr_dpc_ena     ),\n    .wr_dscratch_ena    (wr_dscratch_ena),\n    .wr_csr_nxt         (wr_csr_nxt     ),\n    .dcsr_r             (dcsr_r         ),\n    .dpc_r              (dpc_r          ),\n    .dscratch_r         (dscratch_r     ),\n    .cmt_dpc            (cmt_dpc        ),\n    .cmt_dpc_ena        (cmt_dpc_ena    ),\n    .cmt_dcause         (cmt_dcause     ),\n    .cmt_dcause_ena     (cmt_dcause_ena ),\n    .dbg_mode           (dbg_mode       ),\n    .dbg_halt_r         (dbg_halt_r     ),\n    .dbg_step_r         (dbg_step_r     ),\n    .dbg_ebreakm_r      (dbg_ebreakm_r  ),\n    .dbg_stopcycle      (dbg_stopcycle  ),\n`ifdef E203_HAS_NICE\n    // NICE Interface signals\n    .nice_mem_holdup    (/* Connect as per design */),\n    .nice_req_valid     (/* Connect as per design */),\n    .nice_req_ready     (/* Connect as per design */),\n    .nice_req_inst      (/* Connect as per design */),\n    .nice_req_rs1       (/* Connect as per design */),\n    .nice_req_rs2       (/* Connect as per design */),\n    .nice_rsp_multicyc_valid (/* Connect as per design */),\n    .nice_rsp_multicyc_ready (/* Connect as per design */),\n    .nice_rsp_multicyc_dat   (/* Connect as per design */),\n    .nice_rsp_multicyc_err   (/* Connect as per design */),\n    .nice_icb_cmd_valid      (/* Connect as per design */),\n    .nice_icb_cmd_ready      (/* Connect as per design */),\n    .nice_icb_cmd_addr       (/* Connect as per design */),\n    .nice_icb_cmd_read       (/* Connect as per design */),\n    .nice_icb_cmd_wdata      (/* Connect as per design */),\n    .nice_icb_cmd_size       (/* Connect as per design */),\n    .nice_icb_rsp_valid      (/* Connect as per design */),\n    .nice_icb_rsp_ready      (/* Connect as per design */),\n    .nice_icb_rsp_rdata      (/* Connect as per design */),\n    .nice_icb_rsp_err        (/* Connect as per design */),\n`endif\n    // Additional ICB interfaces should be connected here\n    // ...\n);\n\n// Instantiate ITCM control module (Optional)\n`ifdef E203_HAS_ITCM\ne203_itcm_ctrl u_e203_itcm_ctrl(\n    .clk                (clk_itcm       ),\n    .rst_n              (rst_itcm       ),\n    .test_mode          (1'b0           ),\n    .itcm_active        (/* Connect as per design */),\n    .tcm_cgstop         (/* Connect as per design */),\n    // IFU Interface\n    .ifu2itcm_icb_cmd_valid (/* Connect as per design */),\n    .ifu2itcm_icb_cmd_ready (/* Connect as per design */),\n    .ifu2itcm_icb_cmd_addr  (/* Connect as per design */),\n    .ifu2itcm_icb_cmd_read  (/* Connect as per design */),\n    .ifu2itcm_icb_rsp_valid (/* Connect as per design */),\n    .ifu2itcm_icb_rsp_ready (/* Connect as per design */),\n    .ifu2itcm_icb_rsp_err   (/* Connect as per design */),\n    .ifu2itcm_icb_rsp_rdata (/* Connect as per design */),\n    // LSU Interface\n    // ...\n`ifdef E203_HAS_ITCM_EXTITF\n    // External Interface\n    .ext2itcm_icb_cmd_valid (ext2itcm_icb_cmd_valid),\n    .ext2itcm_icb_cmd_ready (ext2itcm_icb_cmd_ready),\n    .ext2itcm_icb_cmd_addr  (ext2itcm_icb_cmd_addr ),\n    .ext2itcm_icb_cmd_read  (ext2itcm_icb_cmd_read ),\n    .ext2itcm_icb_cmd_wdata (ext2itcm_icb_cmd_wdata),\n    .ext2itcm_icb_cmd_wmask (ext2itcm_icb_cmd_wmask),\n    .ext2itcm_icb_rsp_valid (ext2itcm_icb_rsp_valid),\n    .ext2itcm_icb_rsp_ready (ext2itcm_icb_rsp_ready),\n    .ext2itcm_icb_rsp_err   (ext2itcm_icb_rsp_err  ),\n    .ext2itcm_icb_rsp_rdata (ext2itcm_icb_rsp_rdata),\n`endif\n    // RAM Interface\n    .itcm_ram_cs        (itcm_ram_cs    ),\n    .itcm_ram_we        (itcm_ram_we    ),\n    .itcm_ram_addr      (itcm_ram_addr  ),\n    .itcm_ram_wem       (itcm_ram_wem   ),\n    .itcm_ram_din       (itcm_ram_din   ),\n    .itcm_ram_dout      (itcm_ram_dout  ),\n    .clk_itcm_ram       (clk_itcm_ram   )\n);\n`endif\n\n// Instantiate DTCM control module (Optional)\n`ifdef E203_HAS_DTCM\ne203_dtcm_ctrl u_e203_dtcm_ctrl(\n    .clk                (clk_dtcm       ),\n    .rst_n              (rst_dtcm       ),\n    .test_mode          (1'b0           ),\n    .tcm_cgstop         (/* Connect as per design */),\n    .dtcm_active        (/* Connect as per design */),\n    // LSU Interface\n    // ...\n`ifdef E203_HAS_DTCM_EXTITF\n    // External Interface\n    .ext2dtcm_icb_cmd_valid (ext2dtcm_icb_cmd_valid),\n    .ext2dtcm_icb_cmd_ready (ext2dtcm_icb_cmd_ready),\n    .ext2dtcm_icb_cmd_addr  (ext2dtcm_icb_cmd_addr ),\n    .ext2dtcm_icb_cmd_read  (ext2dtcm_icb_cmd_read ),\n    .ext2dtcm_icb_cmd_wdata (ext2dtcm_icb_cmd_wdata),\n    .ext2dtcm_icb_cmd_wmask (ext2dtcm_icb_cmd_wmask),\n    .ext2dtcm_icb_rsp_valid (ext2dtcm_icb_rsp_valid),\n    .ext2dtcm_icb_rsp_ready (ext2dtcm_icb_rsp_ready),\n    .ext2dtcm_icb_rsp_err   (ext2dtcm_icb_rsp_err  ),\n    .ext2dtcm_icb_rsp_rdata (ext2dtcm_icb_rsp_rdata),\n`endif\n    // RAM Interface\n    .dtcm_ram_cs        (dtcm_ram_cs    ),\n    .dtcm_ram_we        (dtcm_ram_we    ),\n    .dtcm_ram_addr      (dtcm_ram_addr  ),\n    .dtcm_ram_wem       (dtcm_ram_wem   ),\n    .dtcm_ram_din       (dtcm_ram_din   ),\n    .dtcm_ram_dout      (dtcm_ram_dout  ),\n    .clk_dtcm_ram       (clk_dtcm_ram   )\n);\n`endif\n\n// Additional module instantiations (e.g., e203_extend_csr, e203_subsys_nice_core) would go here\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_decode", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_exu_decode (\n    // Inputs\n    input  [E203_INSTR_SIZE-1:0] i_instr,\n    input  [E203_PC_SIZE-1:0]    i_pc,\n    input                        i_prdt_taken,\n    input                        i_misalgn,\n    input                        i_buserr,\n    input                        i_muldiv_b2b,\n    input                        dbg_mode,\n`ifdef E203_HAS_NICE\n    input                        nice_xs_off,\n`endif\n    // Outputs\n    output                       dec_rs1x0,\n    output                       dec_rs2x0,\n    output                       dec_rs1en,\n    output                       dec_rs2en,\n    output                       dec_rdwen,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output [E203_RFIDX_WIDTH-1:0] dec_rdidx,\n    output [E203_DECINFO_WIDTH-1:0] dec_info,\n    output [E203_XLEN-1:0]         dec_imm,\n    output [E203_PC_SIZE-1:0]      dec_pc,\n    output                       dec_misalgn,\n    output                       dec_buserr,\n    output                       dec_ilegl,\n    output                       dec_mulhsu,\n    output                       dec_mul,\n    output                       dec_div,\n    output                       dec_rem,\n    output                       dec_divu,\n    output                       dec_remu,\n    output                       dec_rv32,\n    output                       dec_bjp,\n    output                       dec_jal,\n    output                       dec_jalr,\n    output                       dec_bxx,\n    output [E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output [E203_XLEN-1:0]        dec_bjp_imm,\n`ifdef E203_HAS_NICE\n    output                       dec_nice,\n    output                       nice_cmt_off_ilgl_o,\n`endif\n    output                       dec_muldiv_sel,\n    output                       dec_alu_sel,\n    output                       dec_agu_sel,\n    output                       dec_bjp_sel,\n    output                       dec_csr_sel\n);\n\n// Internal signals\nwire [31:0] instr;\nwire        instr_16bit;\nwire        instr_32bit;\nwire [6:0]  opcode;\nwire [4:0]  rd;\nwire [2:0]  funct3;\nwire [4:0]  rs1;\nwire [4:0]  rs2;\nwire [6:0]  funct7;\nwire [11:0] imm_i;\nwire [11:0] imm_s;\nwire [12:0] imm_b;\nwire [31:0] imm_u;\nwire [20:1] imm_j;\n\nassign instr = i_instr;\nassign instr_16bit = (instr[1:0] != 2'b11);\nassign instr_32bit = (instr[1:0] == 2'b11);\n\nassign dec_rv32 = instr_32bit;\nassign dec_pc = i_pc;\nassign dec_misalgn = i_misalgn;\nassign dec_buserr = i_buserr;\n\n// Initialize outputs to zero\nassign dec_rs1en = 1'b0;\nassign dec_rs2en = 1'b0;\nassign dec_rdwen = 1'b0;\nassign dec_rs1idx = 5'd0;\nassign dec_rs2idx = 5'd0;\nassign dec_rdidx  = 5'd0;\nassign dec_rs1x0 = 1'b0;\nassign dec_rs2x0 = 1'b0;\nassign dec_info = {E203_DECINFO_WIDTH{1'b0}};\nassign dec_imm  = {E203_XLEN{1'b0}};\nassign dec_ilegl = 1'b0;\nassign dec_mulhsu = 1'b0;\nassign dec_mul = 1'b0;\nassign dec_div = 1'b0;\nassign dec_rem = 1'b0;\nassign dec_divu = 1'b0;\nassign dec_remu = 1'b0;\nassign dec_bjp = 1'b0;\nassign dec_jal = 1'b0;\nassign dec_jalr = 1'b0;\nassign dec_bxx = 1'b0;\nassign dec_jalr_rs1idx = 5'd0;\nassign dec_bjp_imm = {E203_XLEN{1'b0}};\n`ifdef E203_HAS_NICE\nassign dec_nice = 1'b0;\nassign nice_cmt_off_ilgl_o = 1'b0;\n`endif\nassign dec_muldiv_sel = 1'b0;\nassign dec_alu_sel = 1'b0;\nassign dec_agu_sel = 1'b0;\nassign dec_bjp_sel = 1'b0;\nassign dec_csr_sel = 1'b0;\n\n// Decode logic\ngenerate\n    if (E203_XLEN == 32) begin: decode_32bit\n        // 32-bit instruction fields\n        assign opcode = instr[6:0];\n        assign rd     = instr[11:7];\n        assign funct3 = instr[14:12];\n        assign rs1    = instr[19:15];\n        assign rs2    = instr[24:20];\n        assign funct7 = instr[31:25];\n        assign imm_i  = instr[31:20];\n        assign imm_s  = {instr[31:25], instr[11:7]};\n        assign imm_b  = {instr[31], instr[7], instr[30:25], instr[11:8], 1'b0};\n        assign imm_u  = {instr[31:12], 12'b0};\n        assign imm_j  = {instr[31], instr[19:12], instr[20], instr[30:21], 1'b0};\n\n        // R-type instructions\n        wire op_rtype = (opcode == 7'b0110011);\n        wire op_alu = op_rtype;\n        wire op_muldiv = (opcode == 7'b0110011) && (funct7 == 7'b0000001);\n        wire is_add = op_rtype && (funct3 == 3'b000) && (funct7 == 7'b0000000);\n        wire is_sub = op_rtype && (funct3 == 3'b000) && (funct7 == 7'b0100000);\n        wire is_sll = op_rtype && (funct3 == 3'b001) && (funct7 == 7'b0000000);\n        wire is_slt = op_rtype && (funct3 == 3'b010) && (funct7 == 7'b0000000);\n        wire is_sltu= op_rtype && (funct3 == 3'b011) && (funct7 == 7'b0000000);\n        wire is_xor = op_rtype && (funct3 == 3'b100) && (funct7 == 7'b0000000);\n        wire is_srl = op_rtype && (funct3 == 3'b101) && (funct7 == 7'b0000000);\n        wire is_sra = op_rtype && (funct3 == 3'b101) && (funct7 == 7'b0100000);\n        wire is_or  = op_rtype && (funct3 == 3'b110) && (funct7 == 7'b0000000);\n        wire is_and = op_rtype && (funct3 == 3'b111) && (funct7 == 7'b0000000);\n\n        // I-type instructions\n        wire op_itype = (opcode == 7'b0010011);\n        wire is_addi = op_itype && (funct3 == 3'b000);\n        wire is_slti = op_itype && (funct3 == 3'b010);\n        wire is_sltiu= op_itype && (funct3 == 3'b011);\n        wire is_xori = op_itype && (funct3 == 3'b100);\n        wire is_ori  = op_itype && (funct3 == 3'b110);\n        wire is_andi = op_itype && (funct3 == 3'b111);\n        wire is_slli = op_itype && (funct3 == 3'b001) && (funct7[6:1] == 6'b000000);\n        wire is_srli = op_itype && (funct3 == 3'b101) && (funct7[6:1] == 6'b000000);\n        wire is_srai = op_itype && (funct3 == 3'b101) && (funct7[6:1] == 6'b010000);\n\n        // Load instructions\n        wire op_load = (opcode == 7'b0000011);\n        wire is_lb   = op_load && (funct3 == 3'b000);\n        wire is_lh   = op_load && (funct3 == 3'b001);\n        wire is_lw   = op_load && (funct3 == 3'b010);\n        wire is_lbu  = op_load && (funct3 == 3'b100);\n        wire is_lhu  = op_load && (funct3 == 3'b101);\n\n        // Store instructions\n        wire op_store = (opcode == 7'b0100011);\n        wire is_sb   = op_store && (funct3 == 3'b000);\n        wire is_sh   = op_store && (funct3 == 3'b001);\n        wire is_sw   = op_store && (funct3 == 3'b010);\n\n        // Branch instructions\n        wire op_branch = (opcode == 7'b1100011);\n        wire is_beq  = op_branch && (funct3 == 3'b000);\n        wire is_bne  = op_branch && (funct3 == 3'b001);\n        wire is_blt  = op_branch && (funct3 == 3'b100);\n        wire is_bge  = op_branch && (funct3 == 3'b101);\n        wire is_bltu = op_branch && (funct3 == 3'b110);\n        wire is_bgeu = op_branch && (funct3 == 3'b111);\n\n        // Jump instructions\n        wire is_jal  = (opcode == 7'b1101111);\n        wire is_jalr = (opcode == 7'b1100111) && (funct3 == 3'b000);\n\n        // LUI and AUIPC\n        wire is_lui   = (opcode == 7'b0110111);\n        wire is_auipc = (opcode == 7'b0010111);\n\n        // CSR instructions\n        wire op_system = (opcode == 7'b1110011);\n        wire is_csrrw  = op_system && (funct3 == 3'b001);\n        wire is_csrrs  = op_system && (funct3 == 3'b010);\n        wire is_csrrc  = op_system && (funct3 == 3'b011);\n        wire is_csrrwi = op_system && (funct3 == 3'b101);\n        wire is_csrrsi = op_system && (funct3 == 3'b110);\n        wire is_csrrci = op_system && (funct3 == 3'b111);\n        wire is_ecall  = op_system && (funct3 == 3'b000) && (imm_i == 12'b000000000000);\n        wire is_ebreak = op_system && (funct3 == 3'b000) && (imm_i == 12'b000000000001);\n\n        // Handle illegal instructions\n        assign dec_ilegl = !(is_add | is_sub | is_sll | is_slt | is_sltu | is_xor | is_srl | is_sra |\n                             is_or | is_and | is_addi | is_slti | is_sltiu | is_xori | is_ori | is_andi |\n                             is_slli | is_srli | is_srai | is_lb | is_lh | is_lw | is_lbu | is_lhu |\n                             is_sb | is_sh | is_sw | is_beq | is_bne | is_blt | is_bge | is_bltu | is_bgeu |\n                             is_jal | is_jalr | is_lui | is_auipc | is_csrrw | is_csrrs | is_csrrc |\n                             is_csrrwi | is_csrrsi | is_csrrci | is_ecall | is_ebreak);\n\n        // Set decode outputs\n        assign dec_rs1en = is_add | is_sub | is_sll | is_slt | is_sltu | is_xor | is_srl | is_sra |\n                           is_or | is_and | is_addi | is_slti | is_sltiu | is_xori | is_ori | is_andi |\n                           is_slli | is_srli | is_srai | is_lb | is_lh | is_lw | is_lbu | is_lhu |\n                           is_beq | is_bne | is_blt | is_bge | is_bltu | is_bgeu | is_jalr | is_sb |\n                           is_sh | is_sw | is_csrrw | is_csrrs | is_csrrc | is_csrrwi | is_csrrsi | is_csrrci;\n\n        assign dec_rs2en = is_add | is_sub | is_sll | is_slt | is_sltu | is_xor | is_srl | is_sra |\n                           is_or | is_and | is_sb | is_sh | is_sw | is_beq | is_bne | is_blt | is_bge |\n                           is_bltu | is_bgeu;\n\n        assign dec_rdwen = is_add | is_sub | is_sll | is_slt | is_sltu | is_xor | is_srl | is_sra |\n                           is_or | is_and | is_addi | is_slti | is_sltiu | is_xori | is_ori | is_andi |\n                           is_slli | is_srli | is_srai | is_lb | is_lh | is_lw | is_lbu | is_lhu |\n                           is_jal | is_jalr | is_lui | is_auipc | is_csrrw | is_csrrs | is_csrrc |\n                           is_csrrwi | is_csrrsi | is_csrrci;\n\n        assign dec_rs1idx = rs1;\n        assign dec_rs2idx = rs2;\n        assign dec_rdidx  = rd;\n        assign dec_rs1x0  = (rs1 == 5'd0);\n        assign dec_rs2x0  = (rs2 == 5'd0);\n\n        // Immediate values\n        wire [31:0] imm_ext_i = {{20{imm_i[11]}}, imm_i};\n        wire [31:0] imm_ext_s = {{20{imm_s[11]}}, imm_s};\n        wire [31:0] imm_ext_b = {{19{imm_b[12]}}, imm_b, 1'b0};\n        wire [31:0] imm_ext_u = imm_u;\n        wire [31:0] imm_ext_j = {{11{imm_j[20]}}, imm_j, 1'b0};\n\n        assign dec_imm = (is_addi | is_slti | is_sltiu | is_xori | is_ori | is_andi | is_slli | is_srli | is_srai |\n                          is_lb | is_lh | is_lw | is_lbu | is_lhu | is_jalr | is_csrrw | is_csrrs | is_csrrc) ? imm_ext_i :\n                         (is_sb | is_sh | is_sw) ? imm_ext_s :\n                         (is_beq | is_bne | is_blt | is_bge | is_bltu | is_bgeu) ? imm_ext_b :\n                         (is_lui | is_auipc) ? imm_ext_u :\n                         (is_jal) ? imm_ext_j :\n                         32'd0;\n\n        // dec_info bus\n        assign dec_info[`E203_DECINFO_GRP] = (is_add | is_sub | is_sll | is_slt | is_sltu | is_xor | is_srl |\n                                              is_sra | is_or | is_and | is_addi | is_slti | is_sltiu | is_xori |\n                                              is_ori | is_andi | is_slli | is_srli | is_srai | is_lui | is_auipc) ? `E203_DECINFO_GRP_ALU :\n                                             (is_jal | is_jalr | is_beq | is_bne | is_blt | is_bge | is_bltu | is_bgeu) ? `E203_DECINFO_GRP_BJP :\n                                             (is_lb | is_lh | is_lw | is_lbu | is_lhu | is_sb | is_sh | is_sw) ? `E203_DECINFO_GRP_AGU :\n                                             (is_csrrw | is_csrrs | is_csrrc | is_csrrwi | is_csrrsi | is_csrrci) ? `E203_DECINFO_GRP_CSR :\n                                             (is_ecall | is_ebreak) ? `E203_DECINFO_GRP_ALU :\n                                             `E203_DECINFO_GRP_ALU;\n\n        assign dec_alu_sel = (dec_info[`E203_DECINFO_GRP] == `E203_DECINFO_GRP_ALU);\n        assign dec_bjp_sel = (dec_info[`E203_DECINFO_GRP] == `E203_DECINFO_GRP_BJP);\n        assign dec_agu_sel = (dec_info[`E203_DECINFO_GRP] == `E203_DECINFO_GRP_AGU);\n        assign dec_csr_sel = (dec_info[`E203_DECINFO_GRP] == `E203_DECINFO_GRP_CSR);\n\n        // Additional dec_bjp outputs\n        assign dec_bjp = is_jal | is_jalr | is_beq | is_bne | is_blt | is_bge | is_bltu | is_bgeu;\n        assign dec_jal = is_jal;\n        assign dec_jalr = is_jalr;\n        assign dec_bxx = is_beq | is_bne | is_blt | is_bge | is_bltu | is_bgeu;\n        assign dec_jalr_rs1idx = rs1;\n        assign dec_bjp_imm = dec_imm;\n\n        // MulDiv instructions\n        assign dec_mul = op_muldiv && (funct3 == 3'b000);\n        assign dec_mulhsu = op_muldiv && (funct3 == 3'b010);\n        assign dec_div = op_muldiv && (funct3 == 3'b100);\n        assign dec_divu = op_muldiv && (funct3 == 3'b101);\n        assign dec_rem = op_muldiv && (funct3 == 3'b110);\n        assign dec_remu = op_muldiv && (funct3 == 3'b111);\n        assign dec_muldiv_sel = op_muldiv;\n\n        // NICE extension\n    `ifdef E203_HAS_NICE\n        // Decode NICE instruction here (custom instruction decoding)\n        assign dec_nice = /* custom NICE instruction decoding */;\n        assign nice_cmt_off_ilgl_o = dec_nice & nice_xs_off;\n    `endif\n\n    end\nendgenerate\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_lsu_ctrl", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_lsu_ctrl (\n  // Control Interface\n  input commit_mret,\n  input commit_trap,\n  output lsu_ctrl_active,\n\n  // LSU Write-back Interface\n  output lsu_o_valid,\n  input lsu_o_ready,\n  output [`E203_XLEN-1:0] lsu_o_wbck_wdat,\n  output [`E203_ITAG_WIDTH-1:0] lsu_o_wbck_itag,\n  output lsu_o_wbck_err,\n  output lsu_o_cmt_buserr,\n  output [`E203_ADDR_SIZE-1:0] lsu_o_cmt_badaddr,\n  output lsu_o_cmt_ld,\n  output lsu_o_cmt_st,\n\n  // AGU-ICB Interface\n  input agu_icb_cmd_valid,\n  output agu_icb_cmd_ready,\n  input [`E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n  input agu_icb_cmd_read,\n  input [`E203_XLEN-1:0] agu_icb_cmd_wdata,\n  input [`E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n  input agu_icb_cmd_lock,\n  input agu_icb_cmd_excl,\n  input [1:0] agu_icb_cmd_size,\n  input agu_icb_cmd_back2agu,\n  input agu_icb_cmd_usign,\n  input [`E203_ITAG_WIDTH-1:0] agu_icb_cmd_itag,\n\n  // AGU-ICB Response Interface\n  output agu_icb_rsp_valid,\n  input agu_icb_rsp_ready,\n  output agu_icb_rsp_err,\n  output agu_icb_rsp_excl_ok,\n  output [`E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n  // NICE Interface (Optional Configuration)\n  input nice_mem_holdup,\n  input nice_icb_cmd_valid,\n  output nice_icb_cmd_ready,\n  input [`E203_ADDR_SIZE-1:0] nice_icb_cmd_addr,\n  input nice_icb_cmd_read,\n  input [`E203_XLEN-1:0] nice_icb_cmd_wdata,\n  input [`E203_XLEN/8-1:0] nice_icb_cmd_wmask,\n  output nice_icb_rsp_valid,\n  input nice_icb_rsp_ready,\n  output nice_icb_rsp_err,\n  output [`E203_XLEN-1:0] nice_icb_rsp_rdata,\n\n  // DCache Interface (Optional Configuration)\n  output dcache_icb_cmd_valid,\n  input dcache_icb_cmd_ready,\n  output [`E203_ADDR_SIZE-1:0] dcache_icb_cmd_addr,\n  output dcache_icb_cmd_read,\n  output [`E203_XLEN-1:0] dcache_icb_cmd_wdata,\n  output [`E203_XLEN/8-1:0] dcache_icb_cmd_wmask,\n  output dcache_icb_cmd_lock,\n  output dcache_icb_cmd_excl,\n  output [1:0] dcache_icb_cmd_size,\n  input dcache_icb_rsp_valid,\n  output dcache_icb_rsp_ready,\n  input dcache_icb_rsp_err,\n  input dcache_icb_rsp_excl_ok,\n  input [`E203_XLEN-1:0] dcache_icb_rsp_rdata,\n\n  // DTCM Interface (Optional Configuration)\n  output dtcm_icb_cmd_valid,\n  input dtcm_icb_cmd_ready,\n  output [`E203_DTCM_ADDR_WIDTH-1:0] dtcm_icb_cmd_addr,\n  output dtcm_icb_cmd_read,\n  output [`E203_XLEN-1:0] dtcm_icb_cmd_wdata,\n  output [`E203_XLEN/8-1:0] dtcm_icb_cmd_wmask,\n  output dtcm_icb_cmd_lock,\n  output dtcm_icb_cmd_excl,\n  output [1:0] dtcm_icb_cmd_size,\n  input dtcm_icb_rsp_valid,\n  output dtcm_icb_rsp_ready,\n  input dtcm_icb_rsp_err,\n  input dtcm_icb_rsp_excl_ok,\n  input [`E203_XLEN-1:0] dtcm_icb_rsp_rdata,\n  input dtcm_region_indic,\n\n  // ITCM Interface (Optional Configuration)\n  output itcm_icb_cmd_valid,\n  input itcm_icb_cmd_ready,\n  output [`E203_ITCM_ADDR_WIDTH-1:0] itcm_icb_cmd_addr,\n  output itcm_icb_cmd_read,\n  output [`E203_XLEN-1:0] itcm_icb_cmd_wdata,\n  output [`E203_XLEN/8-1:0] itcm_icb_cmd_wmask,\n  output itcm_icb_cmd_lock,\n  output itcm_icb_cmd_excl,\n  output [1:0] itcm_icb_cmd_size,\n  input itcm_icb_rsp_valid,\n  output itcm_icb_rsp_ready,\n  input itcm_icb_rsp_err,\n  input itcm_icb_rsp_excl_ok,\n  input [`E203_XLEN-1:0] itcm_icb_rsp_rdata,\n  input itcm_region_indic,\n\n  // BIU Interface\n  output biu_icb_cmd_valid,\n  input biu_icb_cmd_ready,\n  output [`E203_ADDR_SIZE-1:0] biu_icb_cmd_addr,\n  output biu_icb_cmd_read,\n  output [`E203_XLEN-1:0] biu_icb_cmd_wdata,\n  output [`E203_XLEN/8-1:0] biu_icb_cmd_wmask,\n  output biu_icb_cmd_lock,\n  output biu_icb_cmd_excl,\n  output [1:0] biu_icb_cmd_size,\n  input biu_icb_rsp_valid,\n  output biu_icb_rsp_ready,\n  input biu_icb_rsp_err,\n  input biu_icb_rsp_excl_ok,\n  input [`E203_XLEN-1:0] biu_icb_rsp_rdata,\n\n  input clk,\n  input rst_n\n);\n\n  // Internal signals\n  wire agu_icb_cmd_valid_real;\n  wire agu_icb_cmd_ready_real;\n  wire agu_icb_rsp_valid_real;\n  wire agu_icb_rsp_ready_real;\n\n  assign agu_icb_cmd_valid_real = (!nice_mem_holdup) & agu_icb_cmd_valid;\n  assign agu_icb_cmd_ready = (!nice_mem_holdup) ? agu_icb_cmd_ready_real : 1'b0;\n\n  assign agu_icb_rsp_valid = (!nice_mem_holdup) ? agu_icb_rsp_valid_real : 1'b0;\n  assign agu_icb_rsp_ready_real = agu_icb_rsp_ready;\n\n  // Arbiter signals\n  localparam LSU_ARBT_I_NUM = 2;\n  localparam LSU_ARBT_I_PTR_W = 1;\n\n  wire [LSU_ARBT_I_NUM-1:0] arbt_bus_icb_cmd_valid;\n  wire [LSU_ARBT_I_NUM-1:0] arbt_bus_icb_cmd_ready;\n  wire [LSU_ARBT_I_NUM*`E203_ADDR_SIZE-1:0] arbt_bus_icb_cmd_addr;\n  wire [LSU_ARBT_I_NUM-1:0] arbt_bus_icb_cmd_read;\n  wire [LSU_ARBT_I_NUM*`E203_XLEN-1:0] arbt_bus_icb_cmd_wdata;\n  wire [LSU_ARBT_I_NUM*(`E203_XLEN/8)-1:0] arbt_bus_icb_cmd_wmask;\n  wire [LSU_ARBT_I_NUM-1:0] arbt_bus_icb_cmd_lock;\n  wire [LSU_ARBT_I_NUM-1:0] arbt_bus_icb_cmd_excl;\n  wire [LSU_ARBT_I_NUM*2-1:0] arbt_bus_icb_cmd_size;\n  wire [LSU_ARBT_I_NUM*1-1:0] arbt_bus_icb_cmd_usr;\n\n  wire [LSU_ARBT_I_NUM-1:0] arbt_bus_icb_rsp_valid;\n  wire [LSU_ARBT_I_NUM-1:0] arbt_bus_icb_rsp_ready;\n  wire [LSU_ARBT_I_NUM-1:0] arbt_bus_icb_rsp_err;\n  wire [LSU_ARBT_I_NUM-1:0] arbt_bus_icb_rsp_excl_ok;\n  wire [LSU_ARBT_I_NUM*`E203_XLEN-1:0] arbt_bus_icb_rsp_rdata;\n  wire [LSU_ARBT_I_NUM*1-1:0] arbt_bus_icb_rsp_usr;\n\n  // Map AGU interface to arbiter\n  assign arbt_bus_icb_cmd_valid[0] = agu_icb_cmd_valid_real;\n  assign agu_icb_cmd_ready_real = arbt_bus_icb_cmd_ready[0];\n  assign arbt_bus_icb_cmd_addr[`E203_ADDR_SIZE*0 +: `E203_ADDR_SIZE] = agu_icb_cmd_addr;\n  assign arbt_bus_icb_cmd_read[0] = agu_icb_cmd_read;\n  assign arbt_bus_icb_cmd_wdata[`E203_XLEN*0 +: `E203_XLEN] = agu_icb_cmd_wdata;\n  assign arbt_bus_icb_cmd_wmask[(`E203_XLEN/8)*0 +: (`E203_XLEN/8)] = agu_icb_cmd_wmask;\n  assign arbt_bus_icb_cmd_lock[0] = agu_icb_cmd_lock;\n  assign arbt_bus_icb_cmd_excl[0] = agu_icb_cmd_excl;\n  assign arbt_bus_icb_cmd_size[2*0 +: 2] = agu_icb_cmd_size;\n  assign arbt_bus_icb_cmd_usr[0] = agu_icb_cmd_back2agu;\n\n  // Map NICE interface to arbiter\n`ifdef E203_HAS_NICE\n  assign arbt_bus_icb_cmd_valid[1] = nice_icb_cmd_valid;\n  assign nice_icb_cmd_ready = arbt_bus_icb_cmd_ready[1];\n  assign arbt_bus_icb_cmd_addr[`E203_ADDR_SIZE*1 +: `E203_ADDR_SIZE] = nice_icb_cmd_addr;\n  assign arbt_bus_icb_cmd_read[1] = nice_icb_cmd_read;\n  assign arbt_bus_icb_cmd_wdata[`E203_XLEN*1 +: `E203_XLEN] = nice_icb_cmd_wdata;\n  assign arbt_bus_icb_cmd_wmask[(`E203_XLEN/8)*1 +: (`E203_XLEN/8)] = nice_icb_cmd_wmask;\n  assign arbt_bus_icb_cmd_lock[1] = 1'b0;\n  assign arbt_bus_icb_cmd_excl[1] = 1'b0;\n  assign arbt_bus_icb_cmd_size[2*1 +: 2] = 2'b10;\n  assign arbt_bus_icb_cmd_usr[1] = 1'b0;\n`else\n  assign arbt_bus_icb_cmd_valid[1] = 1'b0;\n  assign nice_icb_cmd_ready = 1'b0;\n  assign arbt_bus_icb_cmd_addr[`E203_ADDR_SIZE*1 +: `E203_ADDR_SIZE] = {`E203_ADDR_SIZE{1'b0}};\n  assign arbt_bus_icb_cmd_read[1] = 1'b0;\n  assign arbt_bus_icb_cmd_wdata[`E203_XLEN*1 +: `E203_XLEN] = {`E203_XLEN{1'b0}};\n  assign arbt_bus_icb_cmd_wmask[(`E203_XLEN/8)*1 +: (`E203_XLEN/8)] = {(`E203_XLEN/8){1'b0}};\n  assign arbt_bus_icb_cmd_lock[1] = 1'b0;\n  assign arbt_bus_icb_cmd_excl[1] = 1'b0;\n  assign arbt_bus_icb_cmd_size[2*1 +: 2] = 2'b00;\n  assign arbt_bus_icb_cmd_usr[1] = 1'b0;\n`endif\n\n  // Instantiate the arbiter\n  sirv_gnrl_icb_arbt #(\n    .ARBT_NUM   (LSU_ARBT_I_NUM),\n    .ARBT_PTR_W (LSU_ARBT_I_PTR_W),\n    .AW         (`E203_ADDR_SIZE),\n    .DW         (`E203_XLEN),\n    .USR_W      (1),\n    .ARBT_SCHEME(0),\n    .FIFO_OUTS_NUM(`E203_LSU_OUTS_NUM),\n    .FIFO_CUT_READY(0),\n    .ALLOW_0CYCL_RSP(0)\n  ) u_lsu_icb_arbt (\n    .o_icb_cmd_valid    (arbt_icb_cmd_valid),\n    .o_icb_cmd_ready    (arbt_icb_cmd_ready),\n    .o_icb_cmd_read     (arbt_icb_cmd_read),\n    .o_icb_cmd_addr     (arbt_icb_cmd_addr),\n    .o_icb_cmd_wdata    (arbt_icb_cmd_wdata),\n    .o_icb_cmd_wmask    (arbt_icb_cmd_wmask),\n    .o_icb_cmd_burst    (),\n    .o_icb_cmd_beat     (),\n    .o_icb_cmd_lock     (arbt_icb_cmd_lock),\n    .o_icb_cmd_excl     (arbt_icb_cmd_excl),\n    .o_icb_cmd_size     (arbt_icb_cmd_size),\n    .o_icb_cmd_usr      (arbt_icb_cmd_usr),\n    .o_icb_rsp_valid    (arbt_icb_rsp_valid),\n    .o_icb_rsp_ready    (arbt_icb_rsp_ready),\n    .o_icb_rsp_err      (arbt_icb_rsp_err),\n    .o_icb_rsp_excl_ok  (arbt_icb_rsp_excl_ok),\n    .o_icb_rsp_rdata    (arbt_icb_rsp_rdata),\n    .o_icb_rsp_usr      (arbt_icb_rsp_usr),\n    .i_bus_icb_cmd_ready(arbt_bus_icb_cmd_ready),\n    .i_bus_icb_cmd_valid(arbt_bus_icb_cmd_valid),\n    .i_bus_icb_cmd_read (arbt_bus_icb_cmd_read),\n    .i_bus_icb_cmd_addr (arbt_bus_icb_cmd_addr),\n    .i_bus_icb_cmd_wdata(arbt_bus_icb_cmd_wdata),\n    .i_bus_icb_cmd_wmask(arbt_bus_icb_cmd_wmask),\n    .i_bus_icb_cmd_burst({LSU_ARBT_I_NUM*2{1'b0}}),\n    .i_bus_icb_cmd_beat ({LSU_ARBT_I_NUM*2{1'b0}}),\n    .i_bus_icb_cmd_lock (arbt_bus_icb_cmd_lock),\n    .i_bus_icb_cmd_excl (arbt_bus_icb_cmd_excl),\n    .i_bus_icb_cmd_size (arbt_bus_icb_cmd_size),\n    .i_bus_icb_cmd_usr  (arbt_bus_icb_cmd_usr),\n    .i_bus_icb_rsp_valid(arbt_bus_icb_rsp_valid),\n    .i_bus_icb_rsp_ready(arbt_bus_icb_rsp_ready),\n    .i_bus_icb_rsp_err  (arbt_bus_icb_rsp_err),\n    .i_bus_icb_rsp_excl_ok(arbt_bus_icb_rsp_excl_ok),\n    .i_bus_icb_rsp_rdata(arbt_bus_icb_rsp_rdata),\n    .i_bus_icb_rsp_usr  (arbt_bus_icb_rsp_usr),\n    .clk                (clk),\n    .rst_n              (rst_n)\n  );\n\n  // Address decoding\n  wire sel_dtcm = dtcm_region_indic;\n  wire sel_itcm = itcm_region_indic;\n  wire sel_dcache = 1'b0; // Placeholder, implement actual condition\n  wire sel_biu = ~(sel_dtcm | sel_itcm | sel_dcache);\n\n  // Distribute commands to memory interfaces\n  assign dtcm_icb_cmd_valid = sel_dtcm & arbt_icb_cmd_valid;\n  assign dtcm_icb_cmd_addr  = arbt_icb_cmd_addr[`E203_DTCM_ADDR_WIDTH-1:0];\n  assign dtcm_icb_cmd_read  = arbt_icb_cmd_read;\n  assign dtcm_icb_cmd_wdata = arbt_icb_cmd_wdata;\n  assign dtcm_icb_cmd_wmask = arbt_icb_cmd_wmask;\n  assign dtcm_icb_cmd_lock  = arbt_icb_cmd_lock;\n  assign dtcm_icb_cmd_excl  = arbt_icb_cmd_excl;\n  assign dtcm_icb_cmd_size  = arbt_icb_cmd_size;\n  assign dtcm_icb_rsp_ready = arbt_icb_rsp_ready;\n\n  assign itcm_icb_cmd_valid = sel_itcm & arbt_icb_cmd_valid;\n  assign itcm_icb_cmd_addr  = arbt_icb_cmd_addr[`E203_ITCM_ADDR_WIDTH-1:0];\n  assign itcm_icb_cmd_read  = arbt_icb_cmd_read;\n  assign itcm_icb_cmd_wdata = arbt_icb_cmd_wdata;\n  assign itcm_icb_cmd_wmask = arbt_icb_cmd_wmask;\n  assign itcm_icb_cmd_lock  = arbt_icb_cmd_lock;\n  assign itcm_icb_cmd_excl  = arbt_icb_cmd_excl;\n  assign itcm_icb_cmd_size  = arbt_icb_cmd_size;\n  assign itcm_icb_rsp_ready = arbt_icb_rsp_ready;\n\n  assign biu_icb_cmd_valid  = sel_biu & arbt_icb_cmd_valid;\n  assign biu_icb_cmd_addr   = arbt_icb_cmd_addr;\n  assign biu_icb_cmd_read   = arbt_icb_cmd_read;\n  assign biu_icb_cmd_wdata  = arbt_icb_cmd_wdata;\n  assign biu_icb_cmd_wmask  = arbt_icb_cmd_wmask;\n  assign biu_icb_cmd_lock   = arbt_icb_cmd_lock;\n  assign biu_icb_cmd_excl   = arbt_icb_cmd_excl;\n  assign biu_icb_cmd_size   = arbt_icb_cmd_size;\n  assign biu_icb_rsp_ready  = arbt_icb_rsp_ready;\n\n  // Merge ready signals\n  assign arbt_icb_cmd_ready = (sel_dtcm & dtcm_icb_cmd_ready) |\n                              (sel_itcm & itcm_icb_cmd_ready) |\n                              (sel_biu  & biu_icb_cmd_ready);\n\n  assign arbt_icb_rsp_valid = (sel_dtcm & dtcm_icb_rsp_valid) |\n                              (sel_itcm & itcm_icb_rsp_valid) |\n                              (sel_biu  & biu_icb_rsp_valid);\n\n  assign arbt_icb_rsp_err   = (sel_dtcm & dtcm_icb_rsp_err) |\n                              (sel_itcm & itcm_icb_rsp_err) |\n                              (sel_biu  & biu_icb_rsp_err);\n\n  assign arbt_icb_rsp_rdata = ({`E203_XLEN{sel_dtcm}} & dtcm_icb_rsp_rdata) |\n                              ({`E203_XLEN{sel_itcm}} & itcm_icb_rsp_rdata) |\n                              ({`E203_XLEN{sel_biu}}  & biu_icb_rsp_rdata);\n\n  // Assign AGU response signals\n  assign agu_icb_rsp_valid_real = arbt_bus_icb_rsp_valid[0];\n  assign arbt_bus_icb_rsp_ready[0] = agu_icb_rsp_ready_real;\n  assign agu_icb_rsp_err = arbt_bus_icb_rsp_err[0];\n  assign agu_icb_rsp_excl_ok = arbt_bus_icb_rsp_excl_ok[0];\n  assign agu_icb_rsp_rdata = arbt_bus_icb_rsp_rdata[`E203_XLEN*0 +: `E203_XLEN];\n\n  // Generate lsu_ctrl_active\n  assign lsu_ctrl_active = agu_icb_cmd_valid | nice_icb_cmd_valid;\n\n  // Implement outstanding request tracking FIFO\n  generate\n    if (`E203_LSU_OUTS_NUM == 1) begin : gen_single_outs_fifo\n      // Use a pipeline stage for single outstanding request\n      sirv_gnrl_pipe_stage #(\n        .CUT_READY(0),\n        .DP(1),\n        .DW(/* appropriate width */)\n      ) u_lsuctrl_pipe_stage (\n        .i_vld(/* input valid */),\n        .i_rdy(/* input ready */),\n        .i_dat(/* input data */),\n        .o_vld(/* output valid */),\n        .o_rdy(/* output ready */),\n        .o_dat(/* output data */),\n        .clk(clk),\n        .rst_n(rst_n)\n      );\n    end else begin : gen_multi_outs_fifo\n      // Use a FIFO for multiple outstanding requests\n      sirv_gnrl_fifo #(\n        .CUT_READY(0),\n        .MSKO(0),\n        .DP(`E203_LSU_OUTS_NUM),\n        .DW(/* appropriate width */)\n      ) u_lsuctrl_fifo (\n        .i_vld(/* input valid */),\n        .i_rdy(/* input ready */),\n        .i_dat(/* input data */),\n        .o_vld(/* output valid */),\n        .o_rdy(/* output ready */),\n        .o_dat(/* output data */),\n        .clk(clk),\n        .rst_n(rst_n)\n      );\n    end\n  endgenerate\n\n  // Exclusive access mechanism, error handling, data alignment, etc.\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_alu", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_alu(\n  // Clock and reset\n  input clk,\n  input rst_n,\n\n  // From dispatch stage\n  input i_valid,    // Indicates a valid instruction is available.\n  output i_ready,   // Indicates the module is ready to accept a new instruction.\n  output i_longpipe, // Indicates the instruction is a long pipeline operation.\n\n  // Instruction fields\n  input [E203_ITAG_WIDTH-1:0] i_itag, // Instruction tag for tracking.\n  input [E203_XLEN-1:0] i_rs1,        // First source operand.\n  input [E203_XLEN-1:0] i_rs2,        // Second source operand.\n  input [E203_XLEN-1:0] i_imm,        // Immediate operand.\n  input [E203_DECINFO_WIDTH-1:0] i_info, // Instruction decode information.\n  input [E203_PC_SIZE-1:0] i_pc,         // Program counter of the instruction.\n  input [E203_INSTR_SIZE-1:0] i_instr,   // Instruction word.\n  input i_pc_vld,                        // Indicates the program counter is valid.\n  input [E203_RFIDX_WIDTH-1:0] i_rdidx,  // Destination register index.\n  input i_rdwen,                         // Write-enable signal for the destination register.\n  input i_ilegl,                         // Indicates an illegal instruction.\n  input i_buserr,                        // Indicates a bus error occurred.\n  input i_misalgn,                       // Indicates a misaligned memory access.\n\n  // Flush signals\n  input flush_req,   // Flush request signal.\n  input flush_pulse, // Flush pulse signal.\n\n  // OITF status\n  input oitf_empty,  // Indicates if the operation issue tracking FIFO is empty.\n\n  // MULDIV\n  input mdv_nob2b,   // No back-to-back MUL/DIV instructions allowed.\n\n  // NICE interface\n  output nice_req_valid,\n  input nice_req_ready,\n  output [E203_XLEN-1:0] nice_req_instr,\n  output [E203_XLEN-1:0] nice_req_rs1,\n  output [E203_XLEN-1:0] nice_req_rs2,\n\n  input nice_rsp_multicyc_valid,\n  output nice_rsp_multicyc_ready,\n\n  output nice_longp_wbck_valid,\n  input nice_longp_wbck_ready,\n  output [E203_ITAG_WIDTH-1:0] nice_o_itag,\n  input i_nice_cmt_off_ilgl,\n  input nice_xs_off,\n\n  output nice_csr_valid,   // Valid signal for NICE CSR request.\n  input nice_csr_ready,    // Ready signal for NICE CSR response.\n  output [31:0] nice_csr_addr,  // Address for NICE CSR.\n  output nice_csr_wr,           // Write enable for NICE CSR.\n  output [31:0] nice_csr_wdata, // Data for NICE CSR write operation.\n  input  [31:0] nice_csr_rdata, // Data from NICE CSR read operation.\n\n  // AGU to LSU ICB interface\n  output agu_icb_cmd_valid,\n  input  agu_icb_cmd_ready,\n  output [E203_ADDR_SIZE-1:0] agu_icb_cmd_addr,\n  output agu_icb_cmd_read,\n  output [E203_XLEN-1:0] agu_icb_cmd_wdata,\n  output [E203_XLEN/8-1:0] agu_icb_cmd_wmask,\n  output agu_icb_cmd_lock,\n  output agu_icb_cmd_excl,\n  output [1:0] agu_icb_cmd_size,\n  output agu_icb_cmd_back2agu,\n  output agu_icb_cmd_usign,\n  output [E203_ITAG_WIDTH -1:0] agu_icb_cmd_itag,\n\n  input  agu_icb_rsp_valid,\n  output agu_icb_rsp_ready,\n  input  agu_icb_rsp_err,\n  input  agu_icb_rsp_excl_ok,\n  input  [E203_XLEN-1:0] agu_icb_rsp_rdata,\n\n  // CSR interface\n  output csr_ena,\n  output csr_wr_en,\n  output csr_rd_en,\n  output [12-1:0] csr_idx,\n  input  [E203_XLEN-1:0] read_csr_dat,\n  output [E203_XLEN-1:0] wbck_csr_dat,\n  input  csr_access_ilgl,\n\n  input  nonflush_cmt_ena,\n\n  // Outputs to write back and commit\n  output wbck_o_valid,\n  input  wbck_o_ready,\n  output [E203_XLEN-1:0] wbck_o_wdat,\n  output [E203_RFIDX_WIDTH-1:0] wbck_o_rdidx,\n\n  output cmt_o_valid,\n  input  cmt_o_ready,\n  output cmt_o_pc_vld,\n  output [E203_PC_SIZE-1:0] cmt_o_pc,\n  output [E203_INSTR_SIZE-1:0] cmt_o_instr,\n  output [E203_XLEN-1:0] cmt_o_imm,\n  output cmt_o_rv32,\n  output cmt_o_bjp,\n  output cmt_o_mret,\n  output cmt_o_dret,\n  output cmt_o_ecall,\n  output cmt_o_ebreak,\n  output cmt_o_fencei,\n  output cmt_o_wfi,\n  output cmt_o_ifu_misalgn,\n  output cmt_o_ifu_buserr,\n  output cmt_o_ifu_ilegl,\n  output cmt_o_bjp_prdt,\n  output cmt_o_bjp_rslv,\n  output cmt_o_misalgn,\n  output cmt_o_ld,\n  output cmt_o_stamo,\n  output cmt_o_buserr,\n  output [E203_ADDR_SIZE-1:0] cmt_o_badaddr,\n\n  output amo_wait\n);\n\n// Internal wires\nwire alu_i_valid;\nwire alu_i_ready;\nwire [E203_DECINFO_ALU_WIDTH-1:0] alu_i_info;\nwire alu_o_valid;\nwire alu_o_ready;\nwire [E203_XLEN-1:0] alu_o_wbck_wdat;\nwire alu_o_wbck_err;\nwire alu_o_cmt_ecall;\nwire alu_o_cmt_ebreak;\nwire alu_o_cmt_wfi;\nwire alu_req_alu_add;\nwire alu_req_alu_sub;\nwire alu_req_alu_xor;\nwire alu_req_alu_sll;\nwire alu_req_alu_srl;\nwire alu_req_alu_sra;\nwire alu_req_alu_or;\nwire alu_req_alu_and;\nwire alu_req_alu_slt;\nwire alu_req_alu_sltu;\nwire alu_req_alu_lui;\nwire [E203_XLEN-1:0] alu_req_alu_op1;\nwire [E203_XLEN-1:0] alu_req_alu_op2;\nwire [E203_XLEN-1:0] alu_req_alu_res;\n\n// Similarly for other submodules...\n\n// Instruction group decoding\nwire [E203_DECINFO_GRP_WIDTH-1:0] i_info_grp = i_info[`E203_DECINFO_GRP_MSB:`E203_DECINFO_GRP_LSB];\n\n// Generate valid signals\nassign alu_i_valid    = i_valid & (i_info_grp == `E203_DECINFO_GRP_ALU);\n// Similarly for other submodules...\n\n// Generate ready signal\nassign i_ready = (\n  (i_info_grp == `E203_DECINFO_GRP_ALU)    ? alu_i_ready    :\n  (i_info_grp == `E203_DECINFO_GRP_AGU)    ? agu_i_ready    :\n  (i_info_grp == `E203_DECINFO_GRP_BJP)    ? bjp_i_ready    :\n  (i_info_grp == `E203_DECINFO_GRP_CSR)    ? csr_i_ready    :\n  (i_info_grp == `E203_DECINFO_GRP_MULDIV) ? ( ( `E203_SUPPORT_MULDIV ) ? muldiv_i_ready : 1'b0 ) :\n  (i_info_grp == `E203_DECINFO_GRP_NICE)   ? ( ( `E203_HAS_NICE ) ? nice_i_ready : 1'b0 ) :\n  1'b0 // Default\n);\n\n// Extract subdecode info\nassign alu_i_info = i_info[`E203_DECINFO_SUBDECINFO_LSB + E203_DECINFO_ALU_WIDTH -1 : `E203_DECINFO_SUBDECINFO_LSB];\n// Similarly for other submodules...\n\n// Instantiate submodules\ne203_exu_alu_rglr u_e203_exu_alu_rglr (\n  .alu_i_valid  (alu_i_valid),\n  .alu_i_ready  (alu_i_ready),\n  .alu_i_rs1    (i_rs1),\n  .alu_i_rs2    (i_rs2),\n  .alu_i_imm    (i_imm),\n  .alu_i_pc     (i_pc),\n  .alu_i_info   (alu_i_info),\n  .alu_i_rdwen  (i_rdwen),\n\n  .alu_o_valid      (alu_o_valid),\n  .alu_o_ready      (alu_o_ready),\n  .alu_o_wbck_wdat  (alu_o_wbck_wdat),\n  .alu_o_wbck_err   (alu_o_wbck_err),\n  .alu_o_cmt_ecall  (alu_o_cmt_ecall),\n  .alu_o_cmt_ebreak (alu_o_cmt_ebreak),\n  .alu_o_cmt_wfi    (alu_o_cmt_wfi),\n\n  .alu_req_alu_add  (alu_req_alu_add),\n  .alu_req_alu_sub  (alu_req_alu_sub),\n  .alu_req_alu_xor  (alu_req_alu_xor),\n  .alu_req_alu_sll  (alu_req_alu_sll),\n  .alu_req_alu_srl  (alu_req_alu_srl),\n  .alu_req_alu_sra  (alu_req_alu_sra),\n  .alu_req_alu_or   (alu_req_alu_or),\n  .alu_req_alu_and  (alu_req_alu_and),\n  .alu_req_alu_slt  (alu_req_alu_slt),\n  .alu_req_alu_sltu (alu_req_alu_sltu),\n  .alu_req_alu_lui  (alu_req_alu_lui),\n  .alu_req_alu_op1  (alu_req_alu_op1),\n  .alu_req_alu_op2  (alu_req_alu_op2),\n\n  .alu_req_alu_res  (alu_req_alu_res),\n\n  .clk              (clk),\n  .rst_n            (rst_n)\n);\n\n// Similarly instantiate other submodules...\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_oitf", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_oitf(\n    output                          dis_ready,             // Dispatch ready signal\n    input                           dis_ena,               // Dispatch enable signal\n    input                           ret_ena,               // Retirement enable signal\n    output [E203_ITAG_WIDTH-1:0]    dis_ptr,               // Dispatch pointer\n    output [E203_ITAG_WIDTH-1:0]    ret_ptr,               // Retirement pointer\n    output [E203_RFIDX_WIDTH-1:0]   ret_rdidx,             // Retiring instruction's destination register index\n    output                          ret_rdwen,             // Retiring instruction's destination register write enable\n    output                          ret_rdfpu,             // Retiring instruction's destination is FPU register\n    output [E203_PC_SIZE-1:0]       ret_pc,                // Retiring instruction's program counter\n    input                           disp_i_rs1en,          // Dispatched instruction's source register 1 enable\n    input                           disp_i_rs2en,          // Dispatched instruction's source register 2 enable\n    input                           disp_i_rs3en,          // Dispatched instruction's source register 3 enable\n    input                           disp_i_rdwen,          // Dispatched instruction's destination register write enable\n    input                           disp_i_rs1fpu,         // Dispatched instruction's source register 1 is FPU register\n    input                           disp_i_rs2fpu,         // Dispatched instruction's source register 2 is FPU register\n    input                           disp_i_rs3fpu,         // Dispatched instruction's source register 3 is FPU register\n    input                           disp_i_rdfpu,          // Dispatched instruction's destination register is FPU register\n    input  [E203_RFIDX_WIDTH-1:0]   disp_i_rs1idx,         // Dispatched instruction's source register 1 index\n    input  [E203_RFIDX_WIDTH-1:0]   disp_i_rs2idx,         // Dispatched instruction's source register 2 index\n    input  [E203_RFIDX_WIDTH-1:0]   disp_i_rs3idx,         // Dispatched instruction's source register 3 index\n    input  [E203_RFIDX_WIDTH-1:0]   disp_i_rdidx,          // Dispatched instruction's destination register index\n    input  [E203_PC_SIZE-1:0]       disp_i_pc,             // Dispatched instruction's program counter\n    output                          oitfrd_match_disprs1,  // OITF matches dispatched instruction's source register 1\n    output                          oitfrd_match_disprs2,  // OITF matches dispatched instruction's source register 2\n    output                          oitfrd_match_disprs3,  // OITF matches dispatched instruction's source register 3\n    output                          oitfrd_match_disprd,   // OITF matches dispatched instruction's destination register\n    output                          oitf_empty,            // OITF is empty\n    input                           clk,                   // Clock signal\n    input                           rst_n                  // Reset signal (active low)\n);\n\n// Local parameters\nlocalparam OITF_DEPTH = E203_OITF_DEPTH;\nlocalparam PTR_WIDTH = E203_ITAG_WIDTH;\n\n// Pointer and flag registers\nreg [PTR_WIDTH-1:0] dis_ptr_r;\nreg                 dis_ptr_flag_r;\nreg [PTR_WIDTH-1:0] ret_ptr_r;\nreg                 ret_ptr_flag_r;\n\n// OITF entry storage\nreg [E203_RFIDX_WIDTH-1:0] rdidx_r [0:OITF_DEPTH-1];\nreg                        rdwen_r [0:OITF_DEPTH-1];\nreg                        rdfpu_r [0:OITF_DEPTH-1];\nreg [E203_PC_SIZE-1:0]     pc_r    [0:OITF_DEPTH-1];\nreg                        valid_r [0:OITF_DEPTH-1];\n\n// Assign pointers\nassign dis_ptr = dis_ptr_r;\nassign ret_ptr = ret_ptr_r;\n\n// Full and empty conditions\nwire oitf_full  = (dis_ptr_r == ret_ptr_r) && (dis_ptr_flag_r != ret_ptr_flag_r);\nwire oitf_empty_wire = (dis_ptr_r == ret_ptr_r) && (dis_ptr_flag_r == ret_ptr_flag_r);\n\nassign dis_ready = ~oitf_full;\nassign oitf_empty = oitf_empty_wire;\n\n// Dispatch logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        dis_ptr_r      <= {PTR_WIDTH{1'b0}};\n        dis_ptr_flag_r <= 1'b0;\n    end else if (dis_ena) begin\n        // Write dispatched instruction into OITF\n        rdidx_r[dis_ptr_r] <= disp_i_rdidx;\n        rdwen_r[dis_ptr_r] <= disp_i_rdwen;\n        rdfpu_r[dis_ptr_r] <= disp_i_rdfpu;\n        pc_r   [dis_ptr_r] <= disp_i_pc;\n        valid_r[dis_ptr_r] <= 1'b1;\n\n        // Update dispatch pointer\n        if (dis_ptr_r == (OITF_DEPTH - 1)) begin\n            dis_ptr_r      <= {PTR_WIDTH{1'b0}};\n            dis_ptr_flag_r <= ~dis_ptr_flag_r;\n        end else begin\n            dis_ptr_r <= dis_ptr_r + 1'b1;\n        end\n    end\nend\n\n// Retirement logic\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        ret_ptr_r      <= {PTR_WIDTH{1'b0}};\n        ret_ptr_flag_r <= 1'b0;\n    end else if (ret_ena) begin\n        valid_r[ret_ptr_r] <= 1'b0;\n\n        // Update retirement pointer\n        if (ret_ptr_r == (OITF_DEPTH - 1)) begin\n            ret_ptr_r      <= {PTR_WIDTH{1'b0}};\n            ret_ptr_flag_r <= ~ret_ptr_flag_r;\n        end else begin\n            ret_ptr_r <= ret_ptr_r + 1'b1;\n        end\n    end\nend\n\n// Outputs for retirement\nassign ret_rdidx = rdidx_r[ret_ptr_r];\nassign ret_rdwen = rdwen_r[ret_ptr_r];\nassign ret_rdfpu = rdfpu_r[ret_ptr_r];\nassign ret_pc    = pc_r   [ret_ptr_r];\n\n// Initialize valid bits\ninteger j;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        for (j = 0; j < OITF_DEPTH; j = j + 1) begin\n            valid_r[j] <= 1'b0;\n        end\n    end\nend\n\n// Dependency checking\nreg oitfrd_match_disprs1;\nreg oitfrd_match_disprs2;\nreg oitfrd_match_disprs3;\nreg oitfrd_match_disprd;\n\ninteger idx;\nalways @(*) begin\n    oitfrd_match_disprs1 = 1'b0;\n    oitfrd_match_disprs2 = 1'b0;\n    oitfrd_match_disprs3 = 1'b0;\n    oitfrd_match_disprd  = 1'b0;\n    for (idx = 0; idx < OITF_DEPTH; idx = idx + 1) begin\n        if (valid_r[idx] && rdwen_r[idx]) begin\n            // Dependency on source register 1\n            if (disp_i_rs1en && (rdfpu_r[idx] == disp_i_rs1fpu) && (rdidx_r[idx] == disp_i_rs1idx)) begin\n                oitfrd_match_disprs1 = 1'b1;\n            end\n            // Dependency on source register 2\n            if (disp_i_rs2en && (rdfpu_r[idx] == disp_i_rs2fpu) && (rdidx_r[idx] == disp_i_rs2idx)) begin\n                oitfrd_match_disprs2 = 1'b1;\n            end\n            // Dependency on source register 3\n            if (disp_i_rs3en && (rdfpu_r[idx] == disp_i_rs3fpu) && (rdidx_r[idx] == disp_i_rs3idx)) begin\n                oitfrd_match_disprs3 = 1'b1;\n            end\n            // Dependency on destination register\n            if (disp_i_rdwen && (rdfpu_r[idx] == disp_i_rdfpu) && (rdidx_r[idx] == disp_i_rdidx)) begin\n                oitfrd_match_disprd = 1'b1;\n            end\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_dtcm_ctrl", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_dtcm_ctrl (\n\n    // System Interface\n    input  wire clk,\n    input  wire rst_n,\n    input  wire test_mode,\n    input  wire tcm_cgstop,\n    output wire dtcm_active,\n\n    // LSU ICB Bus Interface\n    input  wire lsu2dtcm_icb_cmd_valid,\n    output wire lsu2dtcm_icb_cmd_ready,\n    input  wire [E203_DTCM_ADDR_WIDTH-1:0] lsu2dtcm_icb_cmd_addr,\n    input  wire lsu2dtcm_icb_cmd_read,\n    input  wire [31:0] lsu2dtcm_icb_cmd_wdata,\n    input  wire [3:0] lsu2dtcm_icb_cmd_wmask,\n    output wire lsu2dtcm_icb_rsp_valid,\n    input  wire lsu2dtcm_icb_rsp_ready,\n    output wire lsu2dtcm_icb_rsp_err,\n    output wire [31:0] lsu2dtcm_icb_rsp_rdata,\n\n    // External ICB Bus Interface (Optional)\n`ifdef E203_HAS_DTCM_EXTITF\n    input  wire ext2dtcm_icb_cmd_valid,\n    output wire ext2dtcm_icb_cmd_ready,\n    input  wire [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input  wire ext2dtcm_icb_cmd_read,\n    input  wire [31:0] ext2dtcm_icb_cmd_wdata,\n    input  wire [3:0] ext2dtcm_icb_cmd_wmask,\n    output wire ext2dtcm_icb_rsp_valid,\n    input  wire ext2dtcm_icb_rsp_ready,\n    output wire ext2dtcm_icb_rsp_err,\n    output wire [31:0] ext2dtcm_icb_rsp_rdata,\n`endif\n\n    // DTCM RAM Interface\n    output wire dtcm_ram_cs,\n    output wire dtcm_ram_we,\n    output wire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr,\n    output wire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem,\n    output wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din,\n    input  wire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout,\n    output wire clk_dtcm_ram\n);\n\n`ifdef E203_HAS_DTCM_EXTITF\nlocalparam DTCM_ARBT_I_NUM = 2;\n`else\nlocalparam DTCM_ARBT_I_NUM = 1;\n`endif\nlocalparam DTCM_ARBT_I_PTR_W = 1;\n\n// Internal wires for arbiter and sram controller\n\n// Wires between arbiter and sram controller\nwire arbt_icb_cmd_valid;\nwire arbt_icb_cmd_ready;\nwire [E203_DTCM_ADDR_WIDTH-1:0] arbt_icb_cmd_addr;\nwire arbt_icb_cmd_read;\nwire [31:0] arbt_icb_cmd_wdata;\nwire [3:0] arbt_icb_cmd_wmask;\nwire arbt_icb_cmd_usr;\n\nwire arbt_icb_rsp_valid;\nwire arbt_icb_rsp_ready;\nwire [31:0] arbt_icb_rsp_rdata;\nwire arbt_icb_rsp_err;\nwire arbt_icb_rsp_usr;\n\nwire [DTCM_ARBT_I_NUM-1:0] arbt_bus_icb_cmd_valid;\nwire [DTCM_ARBT_I_NUM-1:0] arbt_bus_icb_cmd_ready;\nwire [DTCM_ARBT_I_NUM*E203_DTCM_ADDR_WIDTH-1:0] arbt_bus_icb_cmd_addr;\nwire [DTCM_ARBT_I_NUM-1:0] arbt_bus_icb_cmd_read;\nwire [DTCM_ARBT_I_NUM*32-1:0] arbt_bus_icb_cmd_wdata;\nwire [DTCM_ARBT_I_NUM*4-1:0] arbt_bus_icb_cmd_wmask;\nwire [DTCM_ARBT_I_NUM*1-1:0] arbt_bus_icb_cmd_usr;\n\nwire [DTCM_ARBT_I_NUM-1:0] arbt_bus_icb_rsp_valid;\nwire [DTCM_ARBT_I_NUM-1:0] arbt_bus_icb_rsp_ready;\nwire [DTCM_ARBT_I_NUM*32-1:0] arbt_bus_icb_rsp_rdata;\nwire [DTCM_ARBT_I_NUM-1:0] arbt_bus_icb_rsp_err;\nwire [DTCM_ARBT_I_NUM*1-1:0] arbt_bus_icb_rsp_usr;\n\nassign arbt_bus_icb_cmd_valid = {\n`ifdef E203_HAS_DTCM_EXTITF\n    ext2dtcm_icb_cmd_valid,\n`endif\n    lsu2dtcm_icb_cmd_valid\n};\n\nassign arbt_bus_icb_cmd_addr = {\n`ifdef E203_HAS_DTCM_EXTITF\n    ext2dtcm_icb_cmd_addr,\n`endif\n    lsu2dtcm_icb_cmd_addr\n};\n\nassign arbt_bus_icb_cmd_read = {\n`ifdef E203_HAS_DTCM_EXTITF\n    ext2dtcm_icb_cmd_read,\n`endif\n    lsu2dtcm_icb_cmd_read\n};\n\nassign arbt_bus_icb_cmd_wdata = {\n`ifdef E203_HAS_DTCM_EXTITF\n    ext2dtcm_icb_cmd_wdata,\n`endif\n    lsu2dtcm_icb_cmd_wdata\n};\n\nassign arbt_bus_icb_cmd_wmask = {\n`ifdef E203_HAS_DTCM_EXTITF\n    ext2dtcm_icb_cmd_wmask,\n`endif\n    lsu2dtcm_icb_cmd_wmask\n};\n\nassign arbt_bus_icb_cmd_usr = {\n`ifdef E203_HAS_DTCM_EXTITF\n    1'b0,\n`endif\n    1'b0\n};\n\nassign arbt_bus_icb_rsp_ready = {\n`ifdef E203_HAS_DTCM_EXTITF\n    ext2dtcm_icb_rsp_ready,\n`endif\n    lsu2dtcm_icb_rsp_ready\n};\n\nassign lsu2dtcm_icb_cmd_ready = arbt_bus_icb_cmd_ready[0];\nassign lsu2dtcm_icb_rsp_valid = arbt_bus_icb_rsp_valid[0];\nassign lsu2dtcm_icb_rsp_err   = arbt_bus_icb_rsp_err[0];\nassign lsu2dtcm_icb_rsp_rdata = arbt_bus_icb_rsp_rdata[32*0 +:32];\n\n`ifdef E203_HAS_DTCM_EXTITF\nassign ext2dtcm_icb_cmd_ready = arbt_bus_icb_cmd_ready[1];\nassign ext2dtcm_icb_rsp_valid = arbt_bus_icb_rsp_valid[1];\nassign ext2dtcm_icb_rsp_err   = arbt_bus_icb_rsp_err[1];\nassign ext2dtcm_icb_rsp_rdata = arbt_bus_icb_rsp_rdata[32*1 +:32];\n`endif\n\nsirv_gnrl_icb_arbt #(\n    .ARBT_SCHEME (0),\n    .ALLOW_0CYCL_RSP (0),\n    .FIFO_OUTS_NUM (`E203_DTCM_OUTS_NUM),\n    .FIFO_CUT_READY (0),\n    .USR_W (1),\n    .ARBT_NUM (DTCM_ARBT_I_NUM),\n    .AW (E203_DTCM_ADDR_WIDTH),\n    .DW (E203_DTCM_DATA_WIDTH),\n    .ARBT_PTR_W (DTCM_ARBT_I_PTR_W)\n) u_sirv_gnrl_icb_arbt (\n    .o_icb_cmd_valid (arbt_icb_cmd_valid),\n    .o_icb_cmd_ready (arbt_icb_cmd_ready),\n    .o_icb_cmd_read  (arbt_icb_cmd_read),\n    .o_icb_cmd_addr  (arbt_icb_cmd_addr),\n    .o_icb_cmd_wdata (arbt_icb_cmd_wdata),\n    .o_icb_cmd_wmask (arbt_icb_cmd_wmask),\n    .o_icb_cmd_burst (),\n    .o_icb_cmd_beat  (),\n    .o_icb_cmd_excl  (),\n    .o_icb_cmd_lock  (),\n    .o_icb_cmd_size  (),\n    .o_icb_cmd_usr   (arbt_icb_cmd_usr),\n    .o_icb_rsp_valid (arbt_icb_rsp_valid),\n    .o_icb_rsp_ready (arbt_icb_rsp_ready),\n    .o_icb_rsp_err   (arbt_icb_rsp_err),\n    .o_icb_rsp_excl_ok (),\n    .o_icb_rsp_rdata (arbt_icb_rsp_rdata),\n    .o_icb_rsp_usr   (arbt_icb_rsp_usr),\n    .i_bus_icb_cmd_valid (arbt_bus_icb_cmd_valid),\n    .i_bus_icb_cmd_ready (arbt_bus_icb_cmd_ready),\n    .i_bus_icb_cmd_read  (arbt_bus_icb_cmd_read),\n    .i_bus_icb_cmd_addr  (arbt_bus_icb_cmd_addr),\n    .i_bus_icb_cmd_wdata (arbt_bus_icb_cmd_wdata),\n    .i_bus_icb_cmd_wmask (arbt_bus_icb_cmd_wmask),\n    .i_bus_icb_cmd_burst ({(DTCM_ARBT_I_NUM*2){1'b0}}),\n    .i_bus_icb_cmd_beat  ({(DTCM_ARBT_I_NUM*2){1'b0}}),\n    .i_bus_icb_cmd_lock  ({(DTCM_ARBT_I_NUM){1'b0}}),\n    .i_bus_icb_cmd_excl  ({(DTCM_ARBT_I_NUM){1'b0}}),\n    .i_bus_icb_cmd_size  ({(DTCM_ARBT_I_NUM*2){1'b0}}),\n    .i_bus_icb_cmd_usr   (arbt_bus_icb_cmd_usr),\n    .i_bus_icb_rsp_valid (arbt_bus_icb_rsp_valid),\n    .i_bus_icb_rsp_ready (arbt_bus_icb_rsp_ready),\n    .i_bus_icb_rsp_err   (arbt_bus_icb_rsp_err),\n    .i_bus_icb_rsp_excl_ok (),\n    .i_bus_icb_rsp_rdata (arbt_bus_icb_rsp_rdata),\n    .i_bus_icb_rsp_usr   (arbt_bus_icb_rsp_usr),\n    .clk (clk),\n    .rst_n (rst_n)\n);\n\nsirv_sram_icb_ctrl #(\n    .DW (E203_DTCM_DATA_WIDTH),\n    .AW (E203_DTCM_ADDR_WIDTH),\n    .MW (E203_DTCM_WMSK_WIDTH),\n    .AW_LSB (2),\n    .USR_W (1)\n) u_sirv_sram_icb_ctrl (\n    .sram_ctrl_active (dtcm_active),\n    .tcm_cgstop (tcm_cgstop),\n    .i_icb_cmd_valid (arbt_icb_cmd_valid),\n    .i_icb_cmd_ready (arbt_icb_cmd_ready),\n    .i_icb_cmd_read  (arbt_icb_cmd_read),\n    .i_icb_cmd_addr  (arbt_icb_cmd_addr),\n    .i_icb_cmd_wdata (arbt_icb_cmd_wdata),\n    .i_icb_cmd_wmask (arbt_icb_cmd_wmask),\n    .i_icb_cmd_usr   (arbt_icb_cmd_usr),\n    .i_icb_rsp_valid (arbt_icb_rsp_valid),\n    .i_icb_rsp_ready (arbt_icb_rsp_ready),\n    .i_icb_rsp_rdata (arbt_icb_rsp_rdata),\n    .i_icb_rsp_usr   (arbt_icb_rsp_usr),\n    .ram_cs    (dtcm_ram_cs),\n    .ram_we    (dtcm_ram_we),\n    .ram_addr  (dtcm_ram_addr),\n    .ram_wem   (dtcm_ram_wem),\n    .ram_din   (dtcm_ram_din),\n    .ram_dout  (dtcm_ram_dout),\n    .clk_ram   (clk_dtcm_ram),\n    .test_mode (test_mode),\n    .clk (clk),\n    .rst_n (rst_n)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_biu", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_biu(\n    output biu_active,\n    input  clk,\n    input  rst_n,\n\n    // LSU ICB Interface\n    input                         lsu2biu_icb_cmd_valid,\n    output                        lsu2biu_icb_cmd_ready,\n    input  [`E203_ADDR_SIZE-1:0]  lsu2biu_icb_cmd_addr,\n    input                         lsu2biu_icb_cmd_read,\n    input  [`E203_XLEN-1:0]       lsu2biu_icb_cmd_wdata,\n    input  [`E203_XLEN/8-1:0]     lsu2biu_icb_cmd_wmask,\n    input  [1:0]                  lsu2biu_icb_cmd_burst,\n    input  [1:0]                  lsu2biu_icb_cmd_beat,\n    input                         lsu2biu_icb_cmd_lock,\n    input                         lsu2biu_icb_cmd_excl,\n    input  [1:0]                  lsu2biu_icb_cmd_size,\n    output                        lsu2biu_icb_rsp_valid,\n    input                         lsu2biu_icb_rsp_ready,\n    output                        lsu2biu_icb_rsp_err,\n    output                        lsu2biu_icb_rsp_excl_ok,\n    output [`E203_XLEN-1:0]       lsu2biu_icb_rsp_rdata,\n\n    // IFU ICB Interface (if E203_HAS_MEM_ITF is defined)\n`ifdef E203_HAS_MEM_ITF\n    input                         ifu2biu_icb_cmd_valid,\n    output                        ifu2biu_icb_cmd_ready,\n    input  [`E203_ADDR_SIZE-1:0]  ifu2biu_icb_cmd_addr,\n    input                         ifu2biu_icb_cmd_read,\n    input  [`E203_XLEN-1:0]       ifu2biu_icb_cmd_wdata,\n    input  [`E203_XLEN/8-1:0]     ifu2biu_icb_cmd_wmask,\n    input  [1:0]                  ifu2biu_icb_cmd_burst,\n    input  [1:0]                  ifu2biu_icb_cmd_beat,\n    input                         ifu2biu_icb_cmd_lock,\n    input                         ifu2biu_icb_cmd_excl,\n    input  [1:0]                  ifu2biu_icb_cmd_size,\n    output                        ifu2biu_icb_rsp_valid,\n    input                         ifu2biu_icb_rsp_ready,\n    output                        ifu2biu_icb_rsp_err,\n    output                        ifu2biu_icb_rsp_excl_ok,\n    output [`E203_XLEN-1:0]       ifu2biu_icb_rsp_rdata,\n`endif\n\n    // PPI ICB Interface\n    output                        biu2ppi_icb_cmd_valid,\n    input                         biu2ppi_icb_cmd_ready,\n    output [`E203_ADDR_SIZE-1:0]  biu2ppi_icb_cmd_addr,\n    output                        biu2ppi_icb_cmd_read,\n    output [`E203_XLEN-1:0]       biu2ppi_icb_cmd_wdata,\n    output [`E203_XLEN/8-1:0]     biu2ppi_icb_cmd_wmask,\n    output [1:0]                  biu2ppi_icb_cmd_burst,\n    output [1:0]                  biu2ppi_icb_cmd_beat,\n    output                        biu2ppi_icb_cmd_lock,\n    output                        biu2ppi_icb_cmd_excl,\n    output [1:0]                  biu2ppi_icb_cmd_size,\n    input                         biu2ppi_icb_rsp_valid,\n    output                        biu2ppi_icb_rsp_ready,\n    input                         biu2ppi_icb_rsp_err,\n    input                         biu2ppi_icb_rsp_excl_ok,\n    input  [`E203_XLEN-1:0]       biu2ppi_icb_rsp_rdata,\n    input  [`E203_ADDR_SIZE-1:0]  ppi_region_indic,\n    input                         ppi_icb_enable,\n\n    // CLINT ICB Interface\n    output                        biu2clint_icb_cmd_valid,\n    input                         biu2clint_icb_cmd_ready,\n    output [`E203_ADDR_SIZE-1:0]  biu2clint_icb_cmd_addr,\n    output                        biu2clint_icb_cmd_read,\n    output [`E203_XLEN-1:0]       biu2clint_icb_cmd_wdata,\n    output [`E203_XLEN/8-1:0]     biu2clint_icb_cmd_wmask,\n    output [1:0]                  biu2clint_icb_cmd_burst,\n    output [1:0]                  biu2clint_icb_cmd_beat,\n    output                        biu2clint_icb_cmd_lock,\n    output                        biu2clint_icb_cmd_excl,\n    output [1:0]                  biu2clint_icb_cmd_size,\n    input                         biu2clint_icb_rsp_valid,\n    output                        biu2clint_icb_rsp_ready,\n    input                         biu2clint_icb_rsp_err,\n    input                         biu2clint_icb_rsp_excl_ok,\n    input  [`E203_XLEN-1:0]       biu2clint_icb_rsp_rdata,\n    input  [`E203_ADDR_SIZE-1:0]  clint_region_indic,\n    input                         clint_icb_enable,\n\n    // PLIC ICB Interface\n    output                        biu2plic_icb_cmd_valid,\n    input                         biu2plic_icb_cmd_ready,\n    output [`E203_ADDR_SIZE-1:0]  biu2plic_icb_cmd_addr,\n    output                        biu2plic_icb_cmd_read,\n    output [`E203_XLEN-1:0]       biu2plic_icb_cmd_wdata,\n    output [`E203_XLEN/8-1:0]     biu2plic_icb_cmd_wmask,\n    output [1:0]                  biu2plic_icb_cmd_burst,\n    output [1:0]                  biu2plic_icb_cmd_beat,\n    output                        biu2plic_icb_cmd_lock,\n    output                        biu2plic_icb_cmd_excl,\n    output [1:0]                  biu2plic_icb_cmd_size,\n    input                         biu2plic_icb_rsp_valid,\n    output                        biu2plic_icb_rsp_ready,\n    input                         biu2plic_icb_rsp_err,\n    input                         biu2plic_icb_rsp_excl_ok,\n    input  [`E203_XLEN-1:0]       biu2plic_icb_rsp_rdata,\n    input  [`E203_ADDR_SIZE-1:0]  plic_region_indic,\n    input                         plic_icb_enable,\n\n    // FIO ICB Interface (if E203_HAS_FIO is defined)\n`ifdef E203_HAS_FIO\n    output                        biu2fio_icb_cmd_valid,\n    input                         biu2fio_icb_cmd_ready,\n    output [`E203_ADDR_SIZE-1:0]  biu2fio_icb_cmd_addr,\n    output                        biu2fio_icb_cmd_read,\n    output [`E203_XLEN-1:0]       biu2fio_icb_cmd_wdata,\n    output [`E203_XLEN/8-1:0]     biu2fio_icb_cmd_wmask,\n    output [1:0]                  biu2fio_icb_cmd_burst,\n    output [1:0]                  biu2fio_icb_cmd_beat,\n    output                        biu2fio_icb_cmd_lock,\n    output                        biu2fio_icb_cmd_excl,\n    output [1:0]                  biu2fio_icb_cmd_size,\n    input                         biu2fio_icb_rsp_valid,\n    output                        biu2fio_icb_rsp_ready,\n    input                         biu2fio_icb_rsp_err,\n    input                         biu2fio_icb_rsp_excl_ok,\n    input  [`E203_XLEN-1:0]       biu2fio_icb_rsp_rdata,\n    input  [`E203_ADDR_SIZE-1:0]  fio_region_indic,\n    input                         fio_icb_enable,\n`endif\n\n    // MEM ICB Interface (if E203_HAS_MEM_ITF is defined)\n`ifdef E203_HAS_MEM_ITF\n    output                        biu2mem_icb_cmd_valid,\n    input                         biu2mem_icb_cmd_ready,\n    output [`E203_ADDR_SIZE-1:0]  biu2mem_icb_cmd_addr,\n    output                        biu2mem_icb_cmd_read,\n    output [`E203_XLEN-1:0]       biu2mem_icb_cmd_wdata,\n    output [`E203_XLEN/8-1:0]     biu2mem_icb_cmd_wmask,\n    output [1:0]                  biu2mem_icb_cmd_burst,\n    output [1:0]                  biu2mem_icb_cmd_beat,\n    output                        biu2mem_icb_cmd_lock,\n    output                        biu2mem_icb_cmd_excl,\n    output [1:0]                  biu2mem_icb_cmd_size,\n    input                         biu2mem_icb_rsp_valid,\n    output                        biu2mem_icb_rsp_ready,\n    input                         biu2mem_icb_rsp_err,\n    input                         biu2mem_icb_rsp_excl_ok,\n    input  [`E203_XLEN-1:0]       biu2mem_icb_rsp_rdata,\n    input                         mem_icb_enable,\n`endif\n\n    // Internal Signals\n    // ...\n);\n\n    // Local parameters\n`ifdef E203_HAS_MEM_ITF\n    localparam BIU_ARBT_I_NUM = 2;\n`else\n    localparam BIU_ARBT_I_NUM = 1;\n`endif\n\n    localparam BIU_ARBT_I_PTR_W = 1;\n\n`ifdef E203_HAS_FIO\n`ifdef E203_HAS_MEM_ITF\n    localparam BIU_SPLT_I_NUM = 6;\n`else\n    localparam BIU_SPLT_I_NUM = 5;\n`endif\n`else\n`ifdef E203_HAS_MEM_ITF\n    localparam BIU_SPLT_I_NUM = 5;\n`else\n    localparam BIU_SPLT_I_NUM = 4;\n`endif\n`endif\n\n    // Internal wires and registers\n    // ...\n    // Implement the internal logic as per the design document\n    // Instantiate the submodules (arbiter, buffer, splitter)\n    // Include the address decoding logic and handling of corner cases\n    // Ensure all interfaces are correctly connected and configured\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_commit", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_exu_commit (\n    output commit_mret,\n    output commit_trap,\n    output core_wfi,\n    output nonflush_cmt_ena,\n    output excp_active,\n    input  amo_wait,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input  wfi_halt_ifu_ack,\n    input  wfi_halt_exu_ack,\n    input  dbg_irq_r,\n    input  [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input  ext_irq_r,\n    input  sft_irq_r,\n    input  tmr_irq_r,\n    input  [E203_EVT_NUM-1:0] evt_r,\n    input  status_mie_r,\n    input  mtie_r,\n    input  msie_r,\n    input  meie_r,\n    input  alu_cmt_i_valid,\n    output alu_cmt_i_ready,\n    input  [E203_PC_SIZE-1:0]    alu_cmt_i_pc,\n    input  [E203_INSTR_SIZE-1:0] alu_cmt_i_instr,\n    input  alu_cmt_i_pc_vld,\n    input  [E203_XLEN-1:0]       alu_cmt_i_imm,\n    input  alu_cmt_i_rv32,\n    input  alu_cmt_i_bjp,\n    input  alu_cmt_i_wfi,\n    input  alu_cmt_i_fencei,\n    input  alu_cmt_i_mret,\n    input  alu_cmt_i_dret,\n    input  alu_cmt_i_ecall,\n    input  alu_cmt_i_ebreak,\n    input  alu_cmt_i_ifu_misalgn,\n    input  alu_cmt_i_ifu_buserr,\n    input  alu_cmt_i_ifu_ilegl,\n    input  alu_cmt_i_bjp_prdt,\n    input  alu_cmt_i_bjp_rslv,\n    input  alu_cmt_i_misalgn,\n    input  alu_cmt_i_ld,\n    input  alu_cmt_i_stamo,\n    input  alu_cmt_i_buserr,\n    input  [E203_ADDR_SIZE-1:0] alu_cmt_i_badaddr,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output cmt_badaddr_ena,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output cmt_epc_ena,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_cause_ena,\n    output cmt_instret_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    output cmt_mret_ena,\n    input  [E203_PC_SIZE-1:0] csr_epc_r,\n    input  [E203_PC_SIZE-1:0] csr_dpc_r,\n    input  [E203_XLEN-1:0]    csr_mtvec_r,\n    input  dbg_mode,\n    input  dbg_halt_r,\n    input  dbg_step_r,\n    input  dbg_ebreakm_r,\n    input  oitf_empty,\n    input  u_mode,\n    input  s_mode,\n    input  h_mode,\n    input  m_mode,\n    output longp_excp_i_ready,\n    input  longp_excp_i_valid,\n    input  longp_excp_i_ld,\n    input  longp_excp_i_st,\n    input  longp_excp_i_buserr,\n    input  [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input  longp_excp_i_insterr,\n    input  [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input  clk,\n    input  rst_n\n);\n\n// Internal wires\nwire cmt_ena = alu_cmt_i_valid & alu_cmt_i_ready;\nwire pipe_flush_req;\nwire flush_ack = 1'b1; // Assuming immediate acknowledgment\nwire flush_pulse = pipe_flush_req;\nwire excpirq_flush_req;\nwire [E203_PC_SIZE-1:0] excpirq_flush_add_op1;\nwire [E203_PC_SIZE-1:0] excpirq_flush_add_op2;\nwire nonalu_excpirq_flush_req_raw;\n\nwire brchmis_flush_req;\nwire [E203_PC_SIZE-1:0] brchmis_flush_add_op1;\nwire [E203_PC_SIZE-1:0] brchmis_flush_add_op2;\nwire [E203_PC_SIZE-1:0] brchmis_flush_pc;\n\n// Generate pipe_flush_req\nassign pipe_flush_req = excpirq_flush_req | brchmis_flush_req;\n\n// Generate cmt_instret_ena and nonflush_cmt_ena\nassign cmt_instret_ena = cmt_ena & ~flush_pulse;\nassign nonflush_cmt_ena = cmt_instret_ena;\n\n// Instantiate e203_exu_excp\ne203_exu_excp u_e203_exu_excp(\n    .commit_trap            (commit_trap),\n    .core_wfi               (core_wfi),\n    .wfi_halt_ifu_req       (wfi_halt_ifu_req),\n    .wfi_halt_exu_req       (wfi_halt_exu_req),\n    .wfi_halt_ifu_ack       (wfi_halt_ifu_ack),\n    .wfi_halt_exu_ack       (wfi_halt_exu_ack),\n    .amo_wait               (amo_wait),\n    .alu_excp_i_valid       (alu_cmt_i_valid),\n    .alu_excp_i_ld          (alu_cmt_i_ld),\n    .alu_excp_i_stamo       (alu_cmt_i_stamo),\n    .alu_excp_i_misalgn     (alu_cmt_i_misalgn),\n    .alu_excp_i_buserr      (alu_cmt_i_buserr),\n    .alu_excp_i_ecall       (alu_cmt_i_ecall),\n    .alu_excp_i_ebreak      (alu_cmt_i_ebreak),\n    .alu_excp_i_wfi         (alu_cmt_i_wfi),\n    .alu_excp_i_ifu_misalgn (alu_cmt_i_ifu_misalgn),\n    .alu_excp_i_ifu_buserr  (alu_cmt_i_ifu_buserr),\n    .alu_excp_i_ifu_ilegl   (alu_cmt_i_ifu_ilegl),\n    .alu_excp_i_pc          (alu_cmt_i_pc),\n    .alu_excp_i_instr       (alu_cmt_i_instr),\n    .alu_excp_i_pc_vld      (alu_cmt_i_pc_vld),\n    .longp_excp_i_valid     (longp_excp_i_valid),\n    .longp_excp_i_ld        (longp_excp_i_ld),\n    .longp_excp_i_st        (longp_excp_i_st),\n    .longp_excp_i_buserr    (longp_excp_i_buserr),\n    .longp_excp_i_insterr   (longp_excp_i_insterr),\n    .longp_excp_i_badaddr   (longp_excp_i_badaddr),\n    .longp_excp_i_pc        (longp_excp_i_pc),\n    .longp_excp_i_ready     (longp_excp_i_ready),\n    .excpirq_flush_ack      (flush_ack),\n    .excpirq_flush_req      (excpirq_flush_req),\n    .nonalu_excpirq_flush_req_raw (nonalu_excpirq_flush_req_raw),\n    .excpirq_flush_add_op1  (excpirq_flush_add_op1),\n    .excpirq_flush_add_op2  (excpirq_flush_add_op2),\n    .csr_mtvec_r            (csr_mtvec_r),\n    .cmt_dret_ena           (cmt_dret_ena),\n    .cmt_ena                (cmt_ena),\n    .cmt_badaddr            (cmt_badaddr),\n    .cmt_epc                (cmt_epc),\n    .cmt_cause              (cmt_cause),\n    .cmt_badaddr_ena        (cmt_badaddr_ena),\n    .cmt_epc_ena            (cmt_epc_ena),\n    .cmt_cause_ena          (cmt_cause_ena),\n    .cmt_status_ena         (cmt_status_ena),\n    .cmt_dpc                (cmt_dpc),\n    .cmt_dpc_ena            (cmt_dpc_ena),\n    .cmt_dcause             (cmt_dcause),\n    .cmt_dcause_ena         (cmt_dcause_ena),\n    .dbg_irq_r              (dbg_irq_r),\n    .lcl_irq_r              (lcl_irq_r),\n    .ext_irq_r              (ext_irq_r),\n    .sft_irq_r              (sft_irq_r),\n    .tmr_irq_r              (tmr_irq_r),\n    .status_mie_r           (status_mie_r),\n    .mtie_r                 (mtie_r),\n    .msie_r                 (msie_r),\n    .meie_r                 (meie_r),\n    .dbg_mode               (dbg_mode),\n    .dbg_halt_r             (dbg_halt_r),\n    .dbg_step_r             (dbg_step_r),\n    .dbg_ebreakm_r          (dbg_ebreakm_r),\n    .oitf_empty             (oitf_empty),\n    .u_mode                 (u_mode),\n    .s_mode                 (s_mode),\n    .h_mode                 (h_mode),\n    .m_mode                 (m_mode),\n    .excp_active            (excp_active),\n    .clk                    (clk),\n    .rst_n                  (rst_n)\n);\n\n// Instantiate e203_exu_branchslv\ne203_exu_branchslv u_e203_exu_branchslv(\n    .cmt_i_valid                (alu_cmt_i_valid),\n    .cmt_i_ready                (alu_cmt_i_ready),\n    .cmt_i_rv32                 (alu_cmt_i_rv32),\n    .cmt_i_dret                 (alu_cmt_i_dret),\n    .cmt_i_mret                 (alu_cmt_i_mret),\n    .cmt_i_fencei               (alu_cmt_i_fencei),\n    .cmt_i_bjp                  (alu_cmt_i_bjp),\n    .cmt_i_bjp_prdt             (alu_cmt_i_bjp_prdt),\n    .cmt_i_bjp_rslv             (alu_cmt_i_bjp_rslv),\n    .cmt_i_pc                   (alu_cmt_i_pc),\n    .cmt_i_imm                  (alu_cmt_i_imm),\n    .csr_epc_r                  (csr_epc_r),\n    .csr_dpc_r                  (csr_dpc_r),\n    .nonalu_excpirq_flush_req_raw (nonalu_excpirq_flush_req_raw),\n    .brchmis_flush_ack          (flush_ack),\n    .brchmis_flush_req          (brchmis_flush_req),\n    .brchmis_flush_add_op1      (brchmis_flush_add_op1),\n    .brchmis_flush_add_op2      (brchmis_flush_add_op2),\n`ifdef E203_TIMING_BOOST\n    .brchmis_flush_pc           (brchmis_flush_pc),\n`endif\n    .cmt_mret_ena               (cmt_mret_ena),\n    .cmt_dret_ena               (cmt_dret_ena),\n    .cmt_fencei_ena             (/* unused */),\n    .clk                        (clk),\n    .rst_n                      (rst_n)\n);\n\n// Generate commit_mret\nassign commit_mret = cmt_mret_ena;\n\n// Generate pipe_flush_add_op1 and pipe_flush_add_op2\nwire [E203_PC_SIZE-1:0] pipe_flush_add_op1 = excpirq_flush_req ? excpirq_flush_add_op1 : brchmis_flush_add_op1;\nwire [E203_PC_SIZE-1:0] pipe_flush_add_op2 = excpirq_flush_req ? excpirq_flush_add_op2 : brchmis_flush_add_op2;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_excp", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_exu_excp(\n    output commit_trap,\n    output core_wfi,\n    output wfi_halt_ifu_req,\n    output wfi_halt_exu_req,\n    input  wfi_halt_ifu_ack,\n    input  wfi_halt_exu_ack,\n    input  amo_wait,\n    input  alu_excp_i_valid,\n    input  alu_excp_i_ld,\n    input  alu_excp_i_stamo,\n    input  alu_excp_i_misalgn,\n    input  alu_excp_i_buserr,\n    input  alu_excp_i_ecall,\n    input  alu_excp_i_ebreak,\n    input  alu_excp_i_wfi,\n    input  alu_excp_i_ifu_misalgn,\n    input  alu_excp_i_ifu_buserr,\n    input  alu_excp_i_ifu_ilegl,\n    input  [E203_PC_SIZE-1:0] alu_excp_i_pc,\n    input  [E203_INSTR_SIZE-1:0] alu_excp_i_instr,\n    input  alu_excp_i_pc_vld,\n    input  longp_excp_i_valid,\n    input  longp_excp_i_ld,\n    input  longp_excp_i_st,\n    input  longp_excp_i_buserr,\n    input  longp_excp_i_insterr,\n    input  [E203_ADDR_SIZE-1:0] longp_excp_i_badaddr,\n    input  [E203_PC_SIZE-1:0] longp_excp_i_pc,\n    input  excpirq_flush_ack,\n    output excpirq_flush_req,\n    output nonalu_excpirq_flush_req_raw,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op1,\n    output [E203_PC_SIZE-1:0] excpirq_flush_add_op2,\n    input  [E203_XLEN-1:0] csr_mtvec_r,\n    input  cmt_dret_ena,\n    input  cmt_ena,\n    output [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    output [E203_PC_SIZE-1:0] cmt_epc,\n    output [E203_XLEN-1:0] cmt_cause,\n    output cmt_badaddr_ena,\n    output cmt_epc_ena,\n    output cmt_cause_ena,\n    output cmt_status_ena,\n    output [E203_PC_SIZE-1:0] cmt_dpc,\n    output cmt_dpc_ena,\n    output [2:0] cmt_dcause,\n    output cmt_dcause_ena,\n    input  dbg_irq_r,\n    input  [E203_LIRQ_NUM-1:0] lcl_irq_r,\n    input  ext_irq_r,\n    input  sft_irq_r,\n    input  tmr_irq_r,\n    input  status_mie_r,\n    input  mtie_r,\n    input  msie_r,\n    input  meie_r,\n    input  dbg_mode,\n    input  dbg_halt_r,\n    input  dbg_step_r,\n    input  dbg_ebreakm_r,\n    input  oitf_empty,\n    input  u_mode,\n    input  s_mode,\n    input  h_mode,\n    input  m_mode,\n    output excp_active,\n    input  clk,\n    input  rst_n\n);\n\n// WFI handling\nwire wfi_halt_req_set = alu_excp_i_wfi & cmt_ena & ~dbg_mode;\nwire wfi_halt_req_clr = wfi_exit;\n\nwire wfi_halt_req_ena = wfi_halt_req_set | wfi_halt_req_clr;\nwire wfi_halt_req_nxt = wfi_halt_req_set ? 1'b1 : 1'b0;\n\nreg wfi_halt_req_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if(~rst_n)\n        wfi_halt_req_r <= 1'b0;\n    else if(wfi_halt_req_ena)\n        wfi_halt_req_r <= wfi_halt_req_nxt;\nend\n\nassign wfi_halt_ifu_req = wfi_halt_req_r;\nassign wfi_halt_exu_req = wfi_halt_req_r;\n\nwire wfi_flag_set = (wfi_halt_req_r & wfi_halt_ifu_ack & wfi_halt_exu_ack);\n\nwire wfi_exit = irq_req | dbg_entry_req;\n\nwire wfi_flag_clr = wfi_exit;\n\nwire wfi_flag_ena = wfi_flag_set | wfi_flag_clr;\nwire wfi_flag_nxt = wfi_flag_set ? 1'b1 : 1'b0;\n\nreg wfi_flag_r;\n\nalways @(posedge clk or negedge rst_n) begin\n    if(~rst_n)\n        wfi_flag_r <= 1'b0;\n    else if(wfi_flag_ena)\n        wfi_flag_r <= wfi_flag_nxt;\nend\n\nassign core_wfi = wfi_flag_r;\n\n// Interrupt request handling\nwire ext_irq_req = ext_irq_r & meie_r;\nwire sft_irq_req = sft_irq_r & msie_r;\nwire tmr_irq_req = tmr_irq_r & mtie_r;\nwire lcl_irq_req = (|lcl_irq_r);\n\n// Interrupt request is valid when global interrupt enable is high\nwire irq_req = (ext_irq_req | sft_irq_req | tmr_irq_req | lcl_irq_req) & status_mie_r;\n\n// Debug entry request logic\nwire dbg_req_ebreak = alu_excp_i_valid & alu_excp_i_ebreak & dbg_ebreakm_r & ~dbg_mode;\nwire dbg_req_halt = dbg_halt_r & ~dbg_mode;\nwire dbg_req_step = dbg_step_r & ~dbg_mode;\nwire dbg_req_interrupt = dbg_irq_r & ~dbg_mode;\nwire dbg_entry_req = dbg_req_ebreak | dbg_req_halt | dbg_req_step | dbg_req_interrupt;\n\n// Exception flush requests\nwire longp_excp_flush_req = longp_excp_i_valid;\n\nwire dbg_flush_req = ~longp_excp_flush_req & alu_excp_i_pc_vld & oitf_empty & dbg_entry_req;\n\nwire irq_flush_req = ~longp_excp_flush_req & ~dbg_flush_req & alu_excp_i_pc_vld & oitf_empty & irq_req;\n\nwire alu_excp_need_flush = alu_excp_i_misalgn | alu_excp_i_buserr |\n                           (alu_excp_i_ebreak & (~dbg_ebreakm_r | dbg_mode)) |\n                           alu_excp_i_ecall |\n                           alu_excp_i_ifu_misalgn | alu_excp_i_ifu_buserr | alu_excp_i_ifu_ilegl;\n\nwire alu_excp_flush_req = ~longp_excp_flush_req & ~dbg_flush_req & ~irq_flush_req & oitf_empty & alu_excp_need_flush;\n\nassign excpirq_flush_req = longp_excp_flush_req | dbg_flush_req | irq_flush_req | alu_excp_flush_req;\nassign nonalu_excpirq_flush_req_raw = excpirq_flush_req & ~alu_excp_flush_req;\n\n// Flush address operands calculation\nreg [E203_PC_SIZE-1:0] excpirq_flush_add_op1_r;\nreg [E203_PC_SIZE-1:0] excpirq_flush_add_op2_r;\n\nalways @(*) begin\n    if (dbg_flush_req) begin\n        excpirq_flush_add_op1_r = {E203_PC_SIZE{1'b0}} | 32'h800;\n        excpirq_flush_add_op2_r = {E203_PC_SIZE{1'b0}};\n    end else if ((longp_excp_flush_req | alu_excp_flush_req) & dbg_mode) begin\n        excpirq_flush_add_op1_r = {E203_PC_SIZE{1'b0}} | 32'h808;\n        excpirq_flush_add_op2_r = {E203_PC_SIZE{1'b0}};\n    end else begin\n        excpirq_flush_add_op1_r = csr_mtvec_r[E203_PC_SIZE-1:0];\n        excpirq_flush_add_op2_r = {E203_PC_SIZE{1'b0}};\n    end\nend\n\nassign excpirq_flush_add_op1 = excpirq_flush_add_op1_r;\nassign excpirq_flush_add_op2 = excpirq_flush_add_op2_r;\n\n// Commit trap output\nassign commit_trap = excpirq_flush_ack;\n\n// Exception cause, epc, badaddr handling\nreg [E203_XLEN-1:0] cmt_cause_r;\nreg cmt_cause_ena_r;\nreg cmt_epc_ena_r;\nreg cmt_badaddr_ena_r;\nreg [E203_PC_SIZE-1:0] cmt_epc_r;\nreg [E203_ADDR_SIZE-1:0] cmt_badaddr_r;\n\nreg [2:0] cmt_dcause_r;\nreg cmt_dcause_ena_r;\nreg [E203_PC_SIZE-1:0] cmt_dpc_r;\nreg cmt_dpc_ena_r;\n\nalways @(*) begin\n    cmt_cause_ena_r    = 1'b0;\n    cmt_epc_ena_r      = 1'b0;\n    cmt_badaddr_ena_r  = 1'b0;\n    cmt_status_ena     = 1'b0;\n    cmt_cause_r        = {E203_XLEN{1'b0}};\n    cmt_epc_r          = {E203_PC_SIZE{1'b0}};\n    cmt_badaddr_r      = {E203_ADDR_SIZE{1'b0}};\n    cmt_dcause_ena_r   = 1'b0;\n    cmt_dpc_ena_r      = 1'b0;\n    cmt_dcause_r       = 3'b000;\n    cmt_dpc_r          = {E203_PC_SIZE{1'b0}};\n\n    if (longp_excp_flush_req) begin\n        // Handle long-pipe exceptions\n        cmt_cause_ena_r = 1'b1;\n        cmt_epc_ena_r = 1'b1;\n        cmt_status_ena = 1'b1;\n        cmt_epc_r = longp_excp_i_pc;\n        if (longp_excp_i_insterr) begin\n            cmt_cause_r = 32'd16; // NICE long instructions\n        end else if (longp_excp_i_buserr & longp_excp_i_ld) begin\n            cmt_cause_r = 32'd5; // Load access fault\n            cmt_badaddr_ena_r = 1'b1;\n            cmt_badaddr_r = longp_excp_i_badaddr;\n        end else if (longp_excp_i_buserr & longp_excp_i_st) begin\n            cmt_cause_r = 32'd7; // Store access fault\n            cmt_badaddr_ena_r = 1'b1;\n            cmt_badaddr_r = longp_excp_i_badaddr;\n        end\n    end else if (alu_excp_flush_req) begin\n        cmt_cause_ena_r = 1'b1;\n        cmt_epc_ena_r = 1'b1;\n        cmt_status_ena = 1'b1;\n        cmt_epc_r = alu_excp_i_pc;\n        if (alu_excp_i_ifu_misalgn) begin\n            cmt_cause_r = 32'd0; // Instruction address misaligned\n            cmt_badaddr_ena_r = 1'b1;\n            cmt_badaddr_r = alu_excp_i_pc;\n        end else if (alu_excp_i_ifu_buserr) begin\n            cmt_cause_r = 32'd1; // Instruction access fault\n            cmt_badaddr_ena_r = 1'b1;\n            cmt_badaddr_r = alu_excp_i_pc;\n        end else if (alu_excp_i_ifu_ilegl) begin\n            cmt_cause_r = 32'd2; // Illegal instruction\n            cmt_badaddr_ena_r = 1'b1;\n            cmt_badaddr_r = { {E203_ADDR_SIZE-E203_INSTR_SIZE{1'b0}}, alu_excp_i_instr };\n        end else if (alu_excp_i_ebreak & (~dbg_ebreakm_r | dbg_mode)) begin\n            cmt_cause_r = 32'd3; // Breakpoint\n            cmt_badaddr_ena_r = 1'b1;\n            cmt_badaddr_r = alu_excp_i_pc;\n        end else if (alu_excp_i_misalgn & alu_excp_i_ld) begin\n            cmt_cause_r = 32'd4; // Load address misaligned\n            cmt_badaddr_ena_r = 1'b1;\n            cmt_badaddr_r = alu_excp_i_pc; // Assuming badaddr is PC\n        end else if (alu_excp_i_misalgn & alu_excp_i_stamo) begin\n            cmt_cause_r = 32'd6; // Store/AMO address misaligned\n            cmt_badaddr_ena_r = 1'b1;\n            cmt_badaddr_r = alu_excp_i_pc; // Assuming badaddr is PC\n        end else if (alu_excp_i_ecall) begin\n            cmt_cause_r = u_mode ? 32'd8 :\n                          s_mode ? 32'd9 :\n                          h_mode ? 32'd10 :\n                                   32'd11; // Environment call from ...\n        end\n    end else if (irq_flush_req) begin\n        cmt_cause_ena_r = 1'b1;\n        cmt_epc_ena_r = 1'b1;\n        cmt_status_ena = 1'b1;\n        cmt_epc_r = alu_excp_i_pc;\n        if (ext_irq_req) begin\n            cmt_cause_r = {1'b1, 31'd11}; // External interrupt\n        end else if (sft_irq_req) begin\n            cmt_cause_r = {1'b1, 31'd3}; // Software interrupt\n        end else if (tmr_irq_req) begin\n            cmt_cause_r = {1'b1, 31'd7}; // Timer interrupt\n        end else if (lcl_irq_req) begin\n            cmt_cause_r = {1'b1, 31'd16}; // Local interrupt\n        end\n    end else if (dbg_flush_req) begin\n        cmt_dcause_ena_r = 1'b1;\n        cmt_dpc_ena_r = 1'b1;\n        cmt_status_ena = 1'b1;\n        cmt_dpc_r = alu_excp_i_pc;\n        if (dbg_req_ebreak) begin\n            cmt_dcause_r = 3'd1; // EBREAK\n        end else if (dbg_req_step) begin\n            cmt_dcause_r = 3'd4; // STEP\n        end else if (dbg_req_halt) begin\n            cmt_dcause_r = 3'd3; // HALT request\n        end else if (dbg_req_interrupt) begin\n            cmt_dcause_r = 3'd2; // Interrupt\n        end else begin\n            cmt_dcause_r = 3'd0; // Other\n        end\n    end\nend\n\nassign cmt_cause = cmt_cause_r;\nassign cmt_cause_ena = cmt_cause_ena_r;\nassign cmt_epc = cmt_epc_r;\nassign cmt_epc_ena = cmt_epc_ena_r;\nassign cmt_badaddr = cmt_badaddr_r;\nassign cmt_badaddr_ena = cmt_badaddr_ena_r;\nassign cmt_dcause = cmt_dcause_r;\nassign cmt_dcause_ena = cmt_dcause_ena_r;\nassign cmt_dpc = cmt_dpc_r;\nassign cmt_dpc_ena = cmt_dpc_ena_r;\n\n// Exception active signal\nassign excp_active = excpirq_flush_req;\n\n// We can add any additional logic as required\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_cpu_top", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_cpu_top (\n    // Clock and Reset inputs\n    input clk,\n    input rst_n,\n\n    // Interrupt signals\n    input ext_irq_a,\n    input sft_irq_a,\n    input tmr_irq_a,\n    input dbg_irq_a,\n\n    // TCM control signals\n    input tcm_sd,\n    input tcm_ds,\n\n    // Reset vector\n    input [E203_PC_SIZE-1:0] pc_rtvec,\n\n    // Outputs for inspection/debugging\n    output [E203_PC_SIZE-1:0] inspect_pc,\n    output inspect_dbg_irq,\n    output inspect_mem_cmd_valid,\n    output inspect_mem_cmd_ready,\n    output inspect_mem_rsp_valid,\n    output inspect_mem_rsp_ready,\n    output inspect_core_clk,\n    output core_csr_clk,\n    output core_wfi,\n    output tm_stop,\n    output dbg_irq_r,\n\n    // External ICB interfaces to ITCM\n    `ifdef E203_HAS_ITCM\n    // Commands from external agent to ITCM\n    input ext2itcm_icb_cmd_valid,\n    output ext2itcm_icb_cmd_ready,\n    input [E203_ITCM_ADDR_WIDTH-1:0] ext2itcm_icb_cmd_addr,\n    input ext2itcm_icb_cmd_read,\n    input [E203_XLEN-1:0] ext2itcm_icb_cmd_wdata,\n    input [E203_XLEN/8-1:0] ext2itcm_icb_cmd_wmask,\n    // Responses from ITCM to external agent\n    output ext2itcm_icb_rsp_valid,\n    input ext2itcm_icb_rsp_ready,\n    output ext2itcm_icb_rsp_err,\n    output [E203_XLEN-1:0] ext2itcm_icb_rsp_rdata,\n    `endif\n\n    // External ICB interfaces to DTCM\n    `ifdef E203_HAS_DTCM\n    // Commands from external agent to DTCM\n    input ext2dtcm_icb_cmd_valid,\n    output ext2dtcm_icb_cmd_ready,\n    input [E203_DTCM_ADDR_WIDTH-1:0] ext2dtcm_icb_cmd_addr,\n    input ext2dtcm_icb_cmd_read,\n    input [E203_XLEN-1:0] ext2dtcm_icb_cmd_wdata,\n    input [E203_XLEN/8-1:0] ext2dtcm_icb_cmd_wmask,\n    // Responses from DTCM to external agent\n    output ext2dtcm_icb_rsp_valid,\n    input ext2dtcm_icb_rsp_ready,\n    output ext2dtcm_icb_rsp_err,\n    output [E203_XLEN-1:0] ext2dtcm_icb_rsp_rdata,\n    `endif\n\n    // Additional interface signals can be added here\n    // ...\n);\n\n// Internal wires for connecting sub-modules\nwire [E203_PC_SIZE-1:0] inspect_pc_wire;\nwire inspect_dbg_irq_wire;\nwire inspect_mem_cmd_valid_wire;\nwire inspect_mem_cmd_ready_wire;\nwire inspect_mem_rsp_valid_wire;\nwire inspect_mem_rsp_ready_wire;\nwire inspect_core_clk_wire;\nwire core_csr_clk_wire;\nwire core_wfi_wire;\nwire tm_stop_wire;\nwire dbg_irq_r_wire;\n\nassign inspect_pc             = inspect_pc_wire;\nassign inspect_dbg_irq        = inspect_dbg_irq_wire;\nassign inspect_mem_cmd_valid  = inspect_mem_cmd_valid_wire;\nassign inspect_mem_cmd_ready  = inspect_mem_cmd_ready_wire;\nassign inspect_mem_rsp_valid  = inspect_mem_rsp_valid_wire;\nassign inspect_mem_rsp_ready  = inspect_mem_rsp_ready_wire;\nassign inspect_core_clk       = inspect_core_clk_wire;\nassign core_csr_clk           = core_csr_clk_wire;\nassign core_wfi               = core_wfi_wire;\nassign tm_stop                = tm_stop_wire;\nassign dbg_irq_r              = dbg_irq_r_wire;\n\n// ITCM interface wires\n`ifdef E203_HAS_ITCM\nwire itcm_ls;\nwire itcm_ram_cs;\nwire itcm_ram_we;\nwire [E203_ITCM_RAM_AW-1:0] itcm_ram_addr;\nwire [E203_ITCM_RAM_MW-1:0] itcm_ram_wem;\nwire [E203_ITCM_RAM_DW-1:0] itcm_ram_din;\nwire [E203_ITCM_RAM_DW-1:0] itcm_ram_dout;\nwire clk_itcm_ram = clk;\nwire rst_itcm     = rst_n;\n`endif\n\n// DTCM interface wires\n`ifdef E203_HAS_DTCM\nwire dtcm_ls;\nwire dtcm_ram_cs;\nwire dtcm_ram_we;\nwire [E203_DTCM_RAM_AW-1:0] dtcm_ram_addr;\nwire [E203_DTCM_RAM_MW-1:0] dtcm_ram_wem;\nwire [E203_DTCM_RAM_DW-1:0] dtcm_ram_din;\nwire [E203_DTCM_RAM_DW-1:0] dtcm_ram_dout;\nwire clk_dtcm_ram = clk;\nwire rst_dtcm     = rst_n;\n`endif\n\n// Instantiate the core CPU module\ne203_cpu u_e203_cpu (\n    // Clock and Reset\n    .clk                (clk),\n    .rst_n              (rst_n),\n    // Core interfaces\n    .pc_rtvec           (pc_rtvec),\n    .core_mhartid       (1'b0), // Assuming single core with hart ID 0\n    .dbg_irq_a          (dbg_irq_a),\n    .ext_irq_a          (ext_irq_a),\n    .sft_irq_a          (sft_irq_a),\n    .tmr_irq_a          (tmr_irq_a),\n    // Inspection signals\n    .inspect_pc         (inspect_pc_wire),\n    .inspect_dbg_irq    (inspect_dbg_irq_wire),\n    .inspect_mem_cmd_valid (inspect_mem_cmd_valid_wire),\n    .inspect_mem_cmd_ready (inspect_mem_cmd_ready_wire),\n    .inspect_mem_rsp_valid (inspect_mem_rsp_valid_wire),\n    .inspect_mem_rsp_ready (inspect_mem_rsp_ready_wire),\n    .inspect_core_clk   (inspect_core_clk_wire),\n    .core_csr_clk       (core_csr_clk_wire),\n    .core_wfi           (core_wfi_wire),\n    .tm_stop            (tm_stop_wire),\n    .dbg_irq_r          (dbg_irq_r_wire),\n\n    // ITCM interfaces (conditional)\n    `ifdef E203_HAS_ITCM\n    .itcm_ls            (itcm_ls),\n    .itcm_ram_cs        (itcm_ram_cs),\n    .itcm_ram_we        (itcm_ram_we),\n    .itcm_ram_addr      (itcm_ram_addr),\n    .itcm_ram_wem       (itcm_ram_wem),\n    .itcm_ram_din       (itcm_ram_din),\n    .itcm_ram_dout      (itcm_ram_dout),\n    .clk_itcm_ram       (clk_itcm_ram),\n    // External-agent ICB to ITCM\n    .ext2itcm_icb_cmd_valid (ext2itcm_icb_cmd_valid),\n    .ext2itcm_icb_cmd_ready (ext2itcm_icb_cmd_ready),\n    .ext2itcm_icb_cmd_addr  (ext2itcm_icb_cmd_addr),\n    .ext2itcm_icb_cmd_read  (ext2itcm_icb_cmd_read),\n    .ext2itcm_icb_cmd_wdata (ext2itcm_icb_cmd_wdata),\n    .ext2itcm_icb_cmd_wmask (ext2itcm_icb_cmd_wmask),\n    .ext2itcm_icb_rsp_valid (ext2itcm_icb_rsp_valid),\n    .ext2itcm_icb_rsp_ready (ext2itcm_icb_rsp_ready),\n    .ext2itcm_icb_rsp_err   (ext2itcm_icb_rsp_err),\n    .ext2itcm_icb_rsp_rdata (ext2itcm_icb_rsp_rdata),\n    `endif\n\n    // DTCM interfaces (conditional)\n    `ifdef E203_HAS_DTCM\n    .dtcm_ls            (dtcm_ls),\n    .dtcm_ram_cs        (dtcm_ram_cs),\n    .dtcm_ram_we        (dtcm_ram_we),\n    .dtcm_ram_addr      (dtcm_ram_addr),\n    .dtcm_ram_wem       (dtcm_ram_wem),\n    .dtcm_ram_din       (dtcm_ram_din),\n    .dtcm_ram_dout      (dtcm_ram_dout),\n    .clk_dtcm_ram       (clk_dtcm_ram),\n    .rst_dtcm           (rst_dtcm),\n    // External-agent ICB to DTCM\n    .ext2dtcm_icb_cmd_valid (ext2dtcm_icb_cmd_valid),\n    .ext2dtcm_icb_cmd_ready (ext2dtcm_icb_cmd_ready),\n    .ext2dtcm_icb_cmd_addr  (ext2dtcm_icb_cmd_addr),\n    .ext2dtcm_icb_cmd_read  (ext2dtcm_icb_cmd_read),\n    .ext2dtcm_icb_cmd_wdata (ext2dtcm_icb_cmd_wdata),\n    .ext2dtcm_icb_cmd_wmask (ext2dtcm_icb_cmd_wmask),\n    .ext2dtcm_icb_rsp_valid (ext2dtcm_icb_rsp_valid),\n    .ext2dtcm_icb_rsp_ready (ext2dtcm_icb_rsp_ready),\n    .ext2dtcm_icb_rsp_err   (ext2dtcm_icb_rsp_err),\n    .ext2dtcm_icb_rsp_rdata (ext2dtcm_icb_rsp_rdata),\n    `endif\n\n    // Additional interfaces can be connected here\n    // ...\n);\n\n// Instantiate the SRAM module\ne203_srams u_e203_srams (\n    // ITCM SRAM interfaces (conditional)\n    `ifdef E203_HAS_ITCM\n    .itcm_ram_sd        (tcm_sd),\n    .itcm_ram_ds        (tcm_ds),\n    .itcm_ram_ls        (itcm_ls),\n    .itcm_ram_cs        (itcm_ram_cs),\n    .itcm_ram_we        (itcm_ram_we),\n    .itcm_ram_addr      (itcm_ram_addr),\n    .itcm_ram_wem       (itcm_ram_wem),\n    .itcm_ram_din       (itcm_ram_din),\n    .itcm_ram_dout      (itcm_ram_dout),\n    .clk_itcm_ram       (clk_itcm_ram),\n    .rst_itcm           (rst_itcm),\n    `endif\n\n    // DTCM SRAM interfaces (conditional)\n    `ifdef E203_HAS_DTCM\n    .dtcm_ram_sd        (tcm_sd),\n    .dtcm_ram_ds        (tcm_ds),\n    .dtcm_ram_ls        (dtcm_ls),\n    .dtcm_ram_cs        (dtcm_ram_cs),\n    .dtcm_ram_we        (dtcm_ram_we),\n    .dtcm_ram_addr      (dtcm_ram_addr),\n    .dtcm_ram_wem       (dtcm_ram_wem),\n    .dtcm_ram_din       (dtcm_ram_din),\n    .dtcm_ram_dout      (dtcm_ram_dout),\n    .clk_dtcm_ram       (clk_dtcm_ram),\n    .rst_dtcm           (rst_dtcm),\n    `endif\n\n    // Test mode signal\n    .test_mode          (1'b0) // Assuming test mode is inactive\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_csr", "codeid": 1, "code": "`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_exu_csr(\n    // Inputs\n    input wire nonflush_cmt_ena, // Not used\n    input wire csr_ena,\n    input wire csr_wr_en,\n    input wire csr_rd_en,\n    input wire [11:0] csr_idx,\n    input wire [E203_XLEN-1:0] wbck_csr_dat,\n    input wire [E203_HART_ID_W-1:0] core_mhartid,\n    input wire ext_irq_r,\n    input wire sft_irq_r,\n    input wire tmr_irq_r,\n    input wire [E203_XLEN-1:0] dcsr_r,\n    input wire [E203_PC_SIZE-1:0] dpc_r,\n    input wire [E203_XLEN-1:0] dscratch_r,\n    input wire [E203_ADDR_SIZE-1:0] cmt_badaddr,\n    input wire cmt_badaddr_ena,\n    input wire [E203_PC_SIZE-1:0] cmt_epc,\n    input wire cmt_epc_ena,\n    input wire [E203_XLEN-1:0] cmt_cause,\n    input wire cmt_cause_ena,\n    input wire cmt_status_ena,\n    input wire cmt_instret_ena,\n    input wire cmt_mret_ena,\n    input wire clk_aon,\n    input wire clk,\n    input wire rst_n,\n    \n    // Outputs\n    output wire csr_access_ilgl,\n    output wire tm_stop,\n    output wire core_cgstop,\n    output wire tcm_cgstop,\n    output wire itcm_nohold,\n    output wire mdv_nob2b,\n    output wire [E203_XLEN-1:0] read_csr_dat,\n    output wire status_mie_r,\n    output wire mtie_r,\n    output wire msie_r,\n    output wire meie_r,\n    output wire wr_dcsr_ena,\n    output wire wr_dpc_ena,\n    output wire wr_dscratch_ena,\n    output wire u_mode,\n    output wire s_mode,\n    output wire h_mode,\n    output wire m_mode,\n    output wire [E203_PC_SIZE-1:0] csr_epc_r,\n    output wire [E203_PC_SIZE-1:0] csr_dpc_r,\n    output wire [E203_XLEN-1:0] csr_mtvec_r\n`ifdef E203_HAS_NICE\n    , output wire nice_xs_off\n`endif\n);\n\n// Assign constants for modes\nassign u_mode = 1'b0; // User mode not supported\nassign s_mode = 1'b0; // Supervisor mode not supported\nassign h_mode = 1'b0; // Hypervisor mode not supported\nassign m_mode = 1'b1; // Machine mode always active\n\n// CSR Access Illegal Flag is always zero in this implementation\nassign csr_access_ilgl = 1'b0;\n\n// Internal Registers for CSRs\nreg [31:0] mstatus;\nreg [31:0] mie;\nreg [31:0] mtvec;\nreg [31:0] mscratch;\nreg [E203_PC_SIZE-1:0] mepc;\nreg [31:0] mcause;\nreg [E203_ADDR_SIZE-1:0] mtval;\nreg [63:0] mcycle;\nreg [63:0] minstret;\n\nreg [31:0] mcounterstop;\nreg core_cgstop_r;\nreg tcm_cgstop_r;\nreg itcm_nohold_r;\nreg mdv_nob2b_r;\n\n`ifdef E203_HAS_NICE\nreg nice_xs_off_r;\nassign nice_xs_off = nice_xs_off_r;\n`endif\n\n// Implement the mstatus register\n// Initialize mstatus to default value on reset\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        // On reset, initialize mstatus\n        mstatus <= 32'h00001800; // MPP = 11\n        // Initialize other CSRs\n        mie <= 32'b0;\n        mtvec <= `E203_MTVEC_TRAP_BASE;\n        mscratch <= 32'b0;\n        mepc <= {E203_PC_SIZE{1'b0}};\n        mcause <= 32'b0;\n        mtval <= {E203_ADDR_SIZE{1'b0}};\n        mcounterstop <= 32'b0;\n        core_cgstop_r <= 1'b0;\n        tcm_cgstop_r <= 1'b0;\n        itcm_nohold_r <= 1'b0;\n        mdv_nob2b_r <= 1'b0;\n        `ifdef E203_HAS_NICE\n        nice_xs_off_r <= 1'b0;\n        `endif\n        mcycle <= 64'b0;\n        minstret <= 64'b0;\n    end else begin\n        // Handle mstatus updates\n        if (cmt_status_ena) begin\n            // On exception or trap entry\n            mstatus[7] <= mstatus[3]; // MPIE <= MIE\n            mstatus[3] <= 1'b0; // MIE <= 0\n        end else if (cmt_mret_ena) begin\n            // On MRET instruction\n            mstatus[3] <= mstatus[7]; // MIE <= MPIE\n            mstatus[7] <= 1'b1; // MPIE <= 1\n        end else if (csr_ena & csr_wr_en & (csr_idx == 12'h300)) begin\n            // When mstatus is written via CSR instruction\n            mstatus[7] <= wbck_csr_dat[7]; // MPIE\n            mstatus[3] <= wbck_csr_dat[3]; // MIE\n            // MPP is hardwired to 2'b11\n            // Read-only bits (SD, XS, FS, MPP)\n            mstatus[31] <= 1'b0; // SD is 0, since FS and XS are 0\n            mstatus[12:11] <= 2'b11; // MPP = 2'b11\n            mstatus[16:15] <= 2'b0; // XS = 2'b00\n            mstatus[14:13] <= 2'b0; // FS = 2'b00\n            // Other bits are reserved or read-only\n        end\n\n        // Handle mie updates\n        if (csr_ena & csr_wr_en & (csr_idx == 12'h304)) begin\n            // Update only the valid bits in MIE\n            mie[11] <= wbck_csr_dat[11]; // MEIE\n            mie[7] <= wbck_csr_dat[7]; // MTIE\n            mie[3] <= wbck_csr_dat[3]; // MSIE\n        end\n\n        // Handle mtvec updates\n        `ifdef E203_SUPPORT_MTVEC\n        if (csr_ena & csr_wr_en & (csr_idx == 12'h305)) begin\n            mtvec <= wbck_csr_dat;\n        end\n        `else\n        mtvec <= `E203_MTVEC_TRAP_BASE;\n        `endif\n\n        // Handle mscratch updates\n        `ifdef E203_SUPPORT_MSCRATCH\n        if (csr_ena & csr_wr_en & (csr_idx == 12'h340)) begin\n            mscratch <= wbck_csr_dat;\n        end\n        `else\n        mscratch <= 32'b0;\n        `endif\n\n        // Handle mepc updates\n        if (cmt_epc_ena) begin\n            mepc <= cmt_epc;\n            mepc[1:0] <= 2'b00; // mepc[1:0] are 0\n        end else if (csr_ena & csr_wr_en & (csr_idx == 12'h341)) begin\n            mepc <= wbck_csr_dat[E203_PC_SIZE-1:0];\n            mepc[1:0] <= 2'b00; // mepc[1:0] are 0\n        end\n\n        // Handle mcause updates\n        if (cmt_cause_ena) begin\n            mcause <= cmt_cause;\n        end else if (csr_ena & csr_wr_en & (csr_idx == 12'h342)) begin\n            mcause[31] <= wbck_csr_dat[31]; // Interrupt bit\n            mcause[3:0] <= wbck_csr_dat[3:0]; // Exception code\n            // Other bits are read-only or reserved\n        end\n\n        // Handle mtval updates\n        if (cmt_badaddr_ena) begin\n            mtval <= cmt_badaddr;\n        end else if (csr_ena & csr_wr_en & (csr_idx == 12'h343)) begin\n            mtval <= wbck_csr_dat[E203_ADDR_SIZE-1:0];\n        end\n\n        // Handle mcounterstop updates\n        if (csr_ena & csr_wr_en & (csr_idx == 12'hbff)) begin\n            mcounterstop <= wbck_csr_dat;\n            core_cgstop_r <= wbck_csr_dat[1];\n            tcm_cgstop_r <= wbck_csr_dat[2];\n            itcm_nohold_r <= wbck_csr_dat[3];\n            mdv_nob2b_r <= wbck_csr_dat[4];\n            `ifdef E203_HAS_NICE\n            nice_xs_off_r <= wbck_csr_dat[5];\n            `endif\n        end\n\n        // Handle mcycle and minstret updates\n        `ifdef E203_SUPPORT_MCYCLE_MINSTRET\n        if (!mcounterstop[0]) begin // If tm_stop is not set\n            mcycle <= mcycle + 1;\n            if (cmt_instret_ena) begin\n                minstret <= minstret + 1;\n            end\n        end\n        `endif\n\n    end\nend\n\n// Assign outputs\nassign status_mie_r = mstatus[3]; // MIE bit in mstatus\nassign mtie_r = mie[7];\nassign msie_r = mie[3];\nassign meie_r = mie[11];\nassign csr_epc_r = mepc;\nassign csr_dpc_r = dpc_r;\nassign csr_mtvec_r = mtvec;\nassign tm_stop = mcounterstop[0];\nassign core_cgstop = core_cgstop_r;\nassign tcm_cgstop = tcm_cgstop_r;\nassign itcm_nohold = itcm_nohold_r;\nassign mdv_nob2b = mdv_nob2b_r;\n\n// Write enables for debug CSRs\nassign wr_dcsr_ena = csr_ena & csr_wr_en & (csr_idx == 12'h7b0);\nassign wr_dpc_ena = csr_ena & csr_wr_en & (csr_idx == 12'h7b1);\nassign wr_dscratch_ena = csr_ena & csr_wr_en & (csr_idx == 12'h7b2);\n\n// Read CSR data\nreg [E203_XLEN-1:0] csr_read_dat;\nassign read_csr_dat = csr_read_dat;\n\nalways @(*) begin\n    case (csr_idx)\n        12'h000: csr_read_dat = 32'b0; // ustatus, not implemented\n        12'h300: csr_read_dat = mstatus;\n        12'h301: csr_read_dat = 32'b0; // misa, optional\n        12'h304: csr_read_dat = mie;\n        12'h305: csr_read_dat = mtvec;\n        12'h340: csr_read_dat = mscratch;\n        12'h341: csr_read_dat = mepc;\n        12'h342: csr_read_dat = mcause;\n        12'h343: csr_read_dat = mtval;\n        12'h344: csr_read_dat = {20'b0, ext_irq_r, 1'b0, sft_irq_r, 1'b0, tmr_irq_r, 1'b0, 3'b0};\n        12'hb00: csr_read_dat = mcycle[31:0];\n        12'hb80: csr_read_dat = mcycle[63:32];\n        12'hb02: csr_read_dat = minstret[31:0];\n        12'hb82: csr_read_dat = minstret[63:32];\n        12'hf11: csr_read_dat = 32'd536; // mvendorid\n        12'hf12: csr_read_dat = 32'hE203; // marchid\n        12'hf13: csr_read_dat = 32'd1; // mimpid\n        12'hf14: csr_read_dat = { {E203_XLEN-E203_HART_ID_W{1'b0}}, core_mhartid }; // mhartid\n        12'hbff: csr_read_dat = mcounterstop;\n        // Debug CSRs\n        12'h7b0: csr_read_dat = dcsr_r; // dcsr\n        12'h7b1: csr_read_dat = dpc_r; // dpc\n        12'h7b2: csr_read_dat = dscratch_r; // dscratch\n        default: csr_read_dat = 32'b0;\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_itcm_ctrl", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_itcm_ctrl #(\n  parameter ADDR_WIDTH = `E203_ITCM_ADDR_WIDTH,\n  parameter DATA_WIDTH = `E203_ITCM_DATA_WIDTH, // Should be 64 bits\n  parameter WMSK_WIDTH = `E203_ITCM_WMSK_WIDTH, // Should be 8 bits\n  parameter RAM_AW = `E203_ITCM_RAM_AW,         // Address width for RAM\n  parameter RAM_DW = `E203_ITCM_RAM_DW,         // Should be 64 bits\n  parameter RAM_MW = `E203_ITCM_RAM_MW          // Should be 8 bits\n)(\n  // System Interfaces\n  input                          clk,\n  input                          rst_n,\n  input                          test_mode,\n  output                         itcm_active,\n  input                          tcm_cgstop,\n\n  // IFU Interface\n  input                          ifu2itcm_icb_cmd_valid,\n  output                         ifu2itcm_icb_cmd_ready,\n  input  [ADDR_WIDTH-1:0]        ifu2itcm_icb_cmd_addr,\n  input                          ifu2itcm_icb_cmd_read,\n  input  [DATA_WIDTH-1:0]        ifu2itcm_icb_cmd_wdata,\n  input  [WMSK_WIDTH-1:0]        ifu2itcm_icb_cmd_wmask,\n  output                         ifu2itcm_icb_rsp_valid,\n  input                          ifu2itcm_icb_rsp_ready,\n  output                         ifu2itcm_icb_rsp_err,\n  output [DATA_WIDTH-1:0]        ifu2itcm_icb_rsp_rdata,\n\n  // LSU Interface\n  input                          lsu2itcm_icb_cmd_valid,\n  output                         lsu2itcm_icb_cmd_ready,\n  input  [ADDR_WIDTH-1:0]        lsu2itcm_icb_cmd_addr,\n  input                          lsu2itcm_icb_cmd_read,\n  input  [31:0]                  lsu2itcm_icb_cmd_wdata, // LSU data width is 32 bits\n  input  [3:0]                   lsu2itcm_icb_cmd_wmask, // LSU write mask is 4 bits\n  output                         lsu2itcm_icb_rsp_valid,\n  input                          lsu2itcm_icb_rsp_ready,\n  output                         lsu2itcm_icb_rsp_err,\n  output [31:0]                  lsu2itcm_icb_rsp_rdata,\n\n`ifdef E203_HAS_ITCM_EXTITF\n  // External Interface\n  input                          ext2itcm_icb_cmd_valid,\n  output                         ext2itcm_icb_cmd_ready,\n  input  [ADDR_WIDTH-1:0]        ext2itcm_icb_cmd_addr,\n  input                          ext2itcm_icb_cmd_read,\n  input  [31:0]                  ext2itcm_icb_cmd_wdata, // External interface data width is 32 bits\n  input  [3:0]                   ext2itcm_icb_cmd_wmask, // External interface write mask is 4 bits\n  output                         ext2itcm_icb_rsp_valid,\n  input                          ext2itcm_icb_rsp_ready,\n  output                         ext2itcm_icb_rsp_err,\n  output [31:0]                  ext2itcm_icb_rsp_rdata,\n`endif\n\n  // RAM Interface\n  output                         itcm_ram_cs,\n  output                         itcm_ram_we,\n  output [RAM_AW-1:0]            itcm_ram_addr,\n  output [RAM_MW-1:0]            itcm_ram_wem,\n  output [RAM_DW-1:0]            itcm_ram_din,\n  input  [RAM_DW-1:0]            itcm_ram_dout,\n  output                         clk_itcm_ram\n);\n\n`ifdef E203_HAS_ITCM_EXTITF\nlocalparam ITCM_ARBT_I_NUM = 3;\n`else\nlocalparam ITCM_ARBT_I_NUM = 2;\n`endif\n\nlocalparam ITCM_ARBT_PTR_W = $clog2(ITCM_ARBT_I_NUM);\n\n// LSU Data Width Conversion\n// Instantiate sirv_gnrl_icb_n2w for LSU\nwire                         lsu_icb_cmd_valid;\nwire                         lsu_icb_cmd_ready;\nwire [ADDR_WIDTH-1:0]        lsu_icb_cmd_addr;\nwire                         lsu_icb_cmd_read;\nwire [DATA_WIDTH-1:0]        lsu_icb_cmd_wdata; // Converted to 64 bits\nwire [WMSK_WIDTH-1:0]        lsu_icb_cmd_wmask; // Converted to 8 bits\nwire                         lsu_icb_rsp_valid;\nwire                         lsu_icb_rsp_ready;\nwire                         lsu_icb_rsp_err;\nwire [DATA_WIDTH-1:0]        lsu_icb_rsp_rdata;\n\n// Internal signals for n2w module\nwire                         lsu_n2w_icb_cmd_valid;\nwire                         lsu_n2w_icb_cmd_ready;\nwire [ADDR_WIDTH-1:0]        lsu_n2w_icb_cmd_addr;\nwire                         lsu_n2w_icb_cmd_read;\nwire [DATA_WIDTH-1:0]        lsu_n2w_icb_cmd_wdata;\nwire [WMSK_WIDTH-1:0]        lsu_n2w_icb_cmd_wmask;\nwire                         lsu_n2w_icb_cmd_lock;\nwire                         lsu_n2w_icb_cmd_excl;\nwire [1:0]                   lsu_n2w_icb_cmd_size;\nwire [1:0]                   lsu_n2w_icb_cmd_burst;\nwire [1:0]                   lsu_n2w_icb_cmd_beat;\nwire [0:0]                   lsu_n2w_icb_cmd_usr;\nwire                         lsu_n2w_icb_rsp_valid;\nwire                         lsu_n2w_icb_rsp_ready;\nwire                         lsu_n2w_icb_rsp_err;\nwire                         lsu_n2w_icb_rsp_excl_ok;\nwire [DATA_WIDTH-1:0]        lsu_n2w_icb_rsp_rdata;\nwire [0:0]                   lsu_n2w_icb_rsp_usr;\n\n// Instantiate n2w module for LSU\nsirv_gnrl_icb_n2w #(\n  .AW               (ADDR_WIDTH),\n  .USR_W            (1),\n  .FIFO_OUTS_NUM    (`E203_ITCM_OUTS_NUM),\n  .FIFO_CUT_READY   (0),\n  .X_W              (32),\n  .Y_W              (DATA_WIDTH)\n) u_itcm_icb_lsu2itcm_n2w (\n  // Input ICB Interface\n  .i_icb_cmd_valid  (lsu2itcm_icb_cmd_valid),\n  .i_icb_cmd_ready  (lsu2itcm_icb_cmd_ready),\n  .i_icb_cmd_read   (lsu2itcm_icb_cmd_read),\n  .i_icb_cmd_addr   (lsu2itcm_icb_cmd_addr),\n  .i_icb_cmd_wdata  (lsu2itcm_icb_cmd_wdata),\n  .i_icb_cmd_wmask  (lsu2itcm_icb_cmd_wmask),\n  .i_icb_cmd_lock   (1'b0),\n  .i_icb_cmd_excl   (1'b0),\n  .i_icb_cmd_size   (2'b10), // Assuming word size\n  .i_icb_cmd_burst  (2'b0),\n  .i_icb_cmd_beat   (2'b0),\n  .i_icb_cmd_usr    (1'b0),\n  .i_icb_rsp_valid  (lsu2itcm_icb_rsp_valid),\n  .i_icb_rsp_ready  (lsu2itcm_icb_rsp_ready),\n  .i_icb_rsp_err    (lsu2itcm_icb_rsp_err),\n  .i_icb_rsp_excl_ok( ),\n  .i_icb_rsp_rdata  (lsu2itcm_icb_rsp_rdata),\n  .i_icb_rsp_usr    ( ),\n\n  // Output ICB Interface\n  .o_icb_cmd_valid  (lsu_n2w_icb_cmd_valid),\n  .o_icb_cmd_ready  (lsu_n2w_icb_cmd_ready),\n  .o_icb_cmd_read   (lsu_n2w_icb_cmd_read),\n  .o_icb_cmd_addr   (lsu_n2w_icb_cmd_addr),\n  .o_icb_cmd_wdata  (lsu_n2w_icb_cmd_wdata),\n  .o_icb_cmd_wmask  (lsu_n2w_icb_cmd_wmask),\n  .o_icb_cmd_lock   (lsu_n2w_icb_cmd_lock),\n  .o_icb_cmd_excl   (lsu_n2w_icb_cmd_excl),\n  .o_icb_cmd_size   (lsu_n2w_icb_cmd_size),\n  .o_icb_cmd_burst  (lsu_n2w_icb_cmd_burst),\n  .o_icb_cmd_beat   (lsu_n2w_icb_cmd_beat),\n  .o_icb_cmd_usr    (lsu_n2w_icb_cmd_usr),\n  .o_icb_rsp_valid  (lsu_n2w_icb_rsp_valid),\n  .o_icb_rsp_ready  (lsu_n2w_icb_rsp_ready),\n  .o_icb_rsp_err    (lsu_n2w_icb_rsp_err),\n  .o_icb_rsp_excl_ok(lsu_n2w_icb_rsp_excl_ok),\n  .o_icb_rsp_rdata  (lsu_n2w_icb_rsp_rdata),\n  .o_icb_rsp_usr    (lsu_n2w_icb_rsp_usr),\n\n  // Clock and Reset\n  .clk              (clk),\n  .rst_n            (rst_n)\n);\n\n`ifdef E203_HAS_ITCM_EXTITF\n// External Interface Data Width Conversion\n// Instantiate sirv_gnrl_icb_n2w for External Interface\nwire                         ext_icb_cmd_valid;\nwire                         ext_icb_cmd_ready;\nwire [ADDR_WIDTH-1:0]        ext_icb_cmd_addr;\nwire                         ext_icb_cmd_read;\nwire [DATA_WIDTH-1:0]        ext_icb_cmd_wdata;\nwire [WMSK_WIDTH-1:0]        ext_icb_cmd_wmask;\nwire                         ext_icb_rsp_valid;\nwire                         ext_icb_rsp_ready;\nwire                         ext_icb_rsp_err;\nwire [DATA_WIDTH-1:0]        ext_icb_rsp_rdata;\n\n// Internal signals for n2w module\nwire                         ext_n2w_icb_cmd_valid;\nwire                         ext_n2w_icb_cmd_ready;\nwire [ADDR_WIDTH-1:0]        ext_n2w_icb_cmd_addr;\nwire                         ext_n2w_icb_cmd_read;\nwire [DATA_WIDTH-1:0]        ext_n2w_icb_cmd_wdata;\nwire [WMSK_WIDTH-1:0]        ext_n2w_icb_cmd_wmask;\nwire                         ext_n2w_icb_cmd_lock;\nwire                         ext_n2w_icb_cmd_excl;\nwire [1:0]                   ext_n2w_icb_cmd_size;\nwire [1:0]                   ext_n2w_icb_cmd_burst;\nwire [1:0]                   ext_n2w_icb_cmd_beat;\nwire [0:0]                   ext_n2w_icb_cmd_usr;\nwire                         ext_n2w_icb_rsp_valid;\nwire                         ext_n2w_icb_rsp_ready;\nwire                         ext_n2w_icb_rsp_err;\nwire                         ext_n2w_icb_rsp_excl_ok;\nwire [DATA_WIDTH-1:0]        ext_n2w_icb_rsp_rdata;\nwire [0:0]                   ext_n2w_icb_rsp_usr;\n\n// Instantiate n2w module for External Interface\nsirv_gnrl_icb_n2w #(\n  .AW               (ADDR_WIDTH),\n  .USR_W            (1),\n  .FIFO_OUTS_NUM    (`E203_ITCM_OUTS_NUM),\n  .FIFO_CUT_READY   (0),\n  .X_W              (32),\n  .Y_W              (DATA_WIDTH)\n) u_itcm_icb_ext2itcm_n2w (\n  // Input ICB Interface\n  .i_icb_cmd_valid  (ext2itcm_icb_cmd_valid),\n  .i_icb_cmd_ready  (ext2itcm_icb_cmd_ready),\n  .i_icb_cmd_read   (ext2itcm_icb_cmd_read),\n  .i_icb_cmd_addr   (ext2itcm_icb_cmd_addr),\n  .i_icb_cmd_wdata  (ext2itcm_icb_cmd_wdata),\n  .i_icb_cmd_wmask  (ext2itcm_icb_cmd_wmask),\n  .i_icb_cmd_lock   (1'b0),\n  .i_icb_cmd_excl   (1'b0),\n  .i_icb_cmd_size   (2'b10), // Assuming word size\n  .i_icb_cmd_burst  (2'b0),\n  .i_icb_cmd_beat   (2'b0),\n  .i_icb_cmd_usr    (1'b0),\n  .i_icb_rsp_valid  (ext2itcm_icb_rsp_valid),\n  .i_icb_rsp_ready  (ext2itcm_icb_rsp_ready),\n  .i_icb_rsp_err    (ext2itcm_icb_rsp_err),\n  .i_icb_rsp_excl_ok( ),\n  .i_icb_rsp_rdata  (ext2itcm_icb_rsp_rdata),\n  .i_icb_rsp_usr    ( ),\n\n  // Output ICB Interface\n  .o_icb_cmd_valid  (ext_n2w_icb_cmd_valid),\n  .o_icb_cmd_ready  (ext_n2w_icb_cmd_ready),\n  .o_icb_cmd_read   (ext_n2w_icb_cmd_read),\n  .o_icb_cmd_addr   (ext_n2w_icb_cmd_addr),\n  .o_icb_cmd_wdata  (ext_n2w_icb_cmd_wdata),\n  .o_icb_cmd_wmask  (ext_n2w_icb_cmd_wmask),\n  .o_icb_cmd_lock   (ext_n2w_icb_cmd_lock),\n  .o_icb_cmd_excl   (ext_n2w_icb_cmd_excl),\n  .o_icb_cmd_size   (ext_n2w_icb_cmd_size),\n  .o_icb_cmd_burst  (ext_n2w_icb_cmd_burst),\n  .o_icb_cmd_beat   (ext_n2w_icb_cmd_beat),\n  .o_icb_cmd_usr    (ext_n2w_icb_cmd_usr),\n  .o_icb_rsp_valid  (ext_n2w_icb_rsp_valid),\n  .o_icb_rsp_ready  (ext_n2w_icb_rsp_ready),\n  .o_icb_rsp_err    (ext_n2w_icb_rsp_err),\n  .o_icb_rsp_excl_ok(ext_n2w_icb_rsp_excl_ok),\n  .o_icb_rsp_rdata  (ext_n2w_icb_rsp_rdata),\n  .o_icb_rsp_usr    (ext_n2w_icb_rsp_usr),\n\n  // Clock and Reset\n  .clk              (clk),\n  .rst_n            (rst_n)\n);\n`endif\n\n// Arbitration Module\n// Internal signals for Arbitration\nwire [ITCM_ARBT_I_NUM-1:0]            arbt_bus_icb_cmd_valid;\nwire [ITCM_ARBT_I_NUM-1:0]            arbt_bus_icb_cmd_ready;\nwire [ITCM_ARBT_I_NUM*ADDR_WIDTH-1:0] arbt_bus_icb_cmd_addr;\nwire [ITCM_ARBT_I_NUM-1:0]            arbt_bus_icb_cmd_read;\nwire [ITCM_ARBT_I_NUM*DATA_WIDTH-1:0] arbt_bus_icb_cmd_wdata;\nwire [ITCM_ARBT_I_NUM*WMSK_WIDTH-1:0] arbt_bus_icb_cmd_wmask;\nwire [ITCM_ARBT_I_NUM-1:0]            arbt_bus_icb_cmd_lock;\nwire [ITCM_ARBT_I_NUM-1:0]            arbt_bus_icb_cmd_excl;\nwire [ITCM_ARBT_I_NUM*2-1:0]          arbt_bus_icb_cmd_size;\nwire [ITCM_ARBT_I_NUM*2-1:0]          arbt_bus_icb_cmd_burst;\nwire [ITCM_ARBT_I_NUM*2-1:0]          arbt_bus_icb_cmd_beat;\nwire [ITCM_ARBT_I_NUM*1-1:0]          arbt_bus_icb_cmd_usr;\nwire [ITCM_ARBT_I_NUM-1:0]            arbt_bus_icb_rsp_valid;\nwire [ITCM_ARBT_I_NUM-1:0]            arbt_bus_icb_rsp_ready;\nwire [ITCM_ARBT_I_NUM-1:0]            arbt_bus_icb_rsp_err;\nwire [ITCM_ARBT_I_NUM-1:0]            arbt_bus_icb_rsp_excl_ok;\nwire [ITCM_ARBT_I_NUM*DATA_WIDTH-1:0] arbt_bus_icb_rsp_rdata;\nwire [ITCM_ARBT_I_NUM*1-1:0]          arbt_bus_icb_rsp_usr;\n\n// Assign inputs to Arbitration module\nassign arbt_bus_icb_cmd_valid[0] = ifu2itcm_icb_cmd_valid;\nassign arbt_bus_icb_cmd_ready[0] = ifu2itcm_icb_cmd_ready;\nassign arbt_bus_icb_cmd_addr [ADDR_WIDTH*0 +: ADDR_WIDTH] = ifu2itcm_icb_cmd_addr;\nassign arbt_bus_icb_cmd_read [0] = ifu2itcm_icb_cmd_read;\nassign arbt_bus_icb_cmd_wdata[DATA_WIDTH*0 +: DATA_WIDTH] = ifu2itcm_icb_cmd_wdata;\nassign arbt_bus_icb_cmd_wmask[WMSK_WIDTH*0 +: WMSK_WIDTH] = ifu2itcm_icb_cmd_wmask;\nassign arbt_bus_icb_cmd_lock [0] = 1'b0;\nassign arbt_bus_icb_cmd_excl [0] = 1'b0;\nassign arbt_bus_icb_cmd_size [2*0 +: 2] = 2'b11; // Assuming double word\nassign arbt_bus_icb_cmd_burst[2*0 +: 2] = 2'b0;\nassign arbt_bus_icb_cmd_beat [2*0 +: 2] = 2'b0;\nassign arbt_bus_icb_cmd_usr  [0] = 1'b0;\nassign ifu2itcm_icb_rsp_valid = arbt_bus_icb_rsp_valid[0];\nassign ifu2itcm_icb_rsp_err   = arbt_bus_icb_rsp_err[0];\nassign ifu2itcm_icb_rsp_rdata = arbt_bus_icb_rsp_rdata[DATA_WIDTH*0 +: DATA_WIDTH];\nassign arbt_bus_icb_rsp_ready[0] = ifu2itcm_icb_rsp_ready;\n\nassign arbt_bus_icb_cmd_valid[1] = lsu_n2w_icb_cmd_valid;\nassign lsu_n2w_icb_cmd_ready     = arbt_bus_icb_cmd_ready[1];\nassign arbt_bus_icb_cmd_addr [ADDR_WIDTH*1 +: ADDR_WIDTH] = lsu_n2w_icb_cmd_addr;\nassign arbt_bus_icb_cmd_read [1] = lsu_n2w_icb_cmd_read;\nassign arbt_bus_icb_cmd_wdata[DATA_WIDTH*1 +: DATA_WIDTH] = lsu_n2w_icb_cmd_wdata;\nassign arbt_bus_icb_cmd_wmask[WMSK_WIDTH*1 +: WMSK_WIDTH] = lsu_n2w_icb_cmd_wmask;\nassign arbt_bus_icb_cmd_lock [1] = lsu_n2w_icb_cmd_lock;\nassign arbt_bus_icb_cmd_excl [1] = lsu_n2w_icb_cmd_excl;\nassign arbt_bus_icb_cmd_size [2*1 +: 2] = lsu_n2w_icb_cmd_size;\nassign arbt_bus_icb_cmd_burst[2*1 +: 2] = lsu_n2w_icb_cmd_burst;\nassign arbt_bus_icb_cmd_beat [2*1 +: 2] = lsu_n2w_icb_cmd_beat;\nassign arbt_bus_icb_cmd_usr  [1] = lsu_n2w_icb_cmd_usr;\nassign lsu_n2w_icb_rsp_valid = arbt_bus_icb_rsp_valid[1];\nassign lsu_n2w_icb_rsp_err   = arbt_bus_icb_rsp_err[1];\nassign lsu_n2w_icb_rsp_rdata = arbt_bus_icb_rsp_rdata[DATA_WIDTH*1 +: DATA_WIDTH];\nassign arbt_bus_icb_rsp_ready[1] = lsu_n2w_icb_rsp_ready;\n\n`ifdef E203_HAS_ITCM_EXTITF\nassign arbt_bus_icb_cmd_valid[2] = ext_n2w_icb_cmd_valid;\nassign ext_n2w_icb_cmd_ready     = arbt_bus_icb_cmd_ready[2];\nassign arbt_bus_icb_cmd_addr [ADDR_WIDTH*2 +: ADDR_WIDTH] = ext_n2w_icb_cmd_addr;\nassign arbt_bus_icb_cmd_read [2] = ext_n2w_icb_cmd_read;\nassign arbt_bus_icb_cmd_wdata[DATA_WIDTH*2 +: DATA_WIDTH] = ext_n2w_icb_cmd_wdata;\nassign arbt_bus_icb_cmd_wmask[WMSK_WIDTH*2 +: WMSK_WIDTH] = ext_n2w_icb_cmd_wmask;\nassign arbt_bus_icb_cmd_lock [2] = ext_n2w_icb_cmd_lock;\nassign arbt_bus_icb_cmd_excl [2] = ext_n2w_icb_cmd_excl;\nassign arbt_bus_icb_cmd_size [2*2 +: 2] = ext_n2w_icb_cmd_size;\nassign arbt_bus_icb_cmd_burst[2*2 +: 2] = ext_n2w_icb_cmd_burst;\nassign arbt_bus_icb_cmd_beat [2*2 +: 2] = ext_n2w_icb_cmd_beat;\nassign arbt_bus_icb_cmd_usr  [2] = ext_n2w_icb_cmd_usr;\nassign ext_n2w_icb_rsp_valid = arbt_bus_icb_rsp_valid[2];\nassign ext_n2w_icb_rsp_err   = arbt_bus_icb_rsp_err[2];\nassign ext_n2w_icb_rsp_rdata = arbt_bus_icb_rsp_rdata[DATA_WIDTH*2 +: DATA_WIDTH];\nassign arbt_bus_icb_rsp_ready[2] = ext_n2w_icb_rsp_ready;\n`endif\n\n// Outputs from Arbitration module to SRAM controller\nwire                         arbt_icb_cmd_valid;\nwire                         arbt_icb_cmd_ready;\nwire [ADDR_WIDTH-1:0]        arbt_icb_cmd_addr;\nwire                         arbt_icb_cmd_read;\nwire [DATA_WIDTH-1:0]        arbt_icb_cmd_wdata;\nwire [WMSK_WIDTH-1:0]        arbt_icb_cmd_wmask;\nwire                         arbt_icb_cmd_lock;\nwire                         arbt_icb_cmd_excl;\nwire [1:0]                   arbt_icb_cmd_size;\nwire [1:0]                   arbt_icb_cmd_burst;\nwire [1:0]                   arbt_icb_cmd_beat;\nwire [0:0]                   arbt_icb_cmd_usr;\nwire                         arbt_icb_rsp_valid;\nwire                         arbt_icb_rsp_ready;\nwire                         arbt_icb_rsp_err;\nwire                         arbt_icb_rsp_excl_ok;\nwire [DATA_WIDTH-1:0]        arbt_icb_rsp_rdata;\nwire [0:0]                   arbt_icb_rsp_usr;\n\n// Instantiate Arbitration module\nsirv_gnrl_icb_arbt #(\n  .ARBT_SCHEME        (0), // Priority-based\n  .ALLOW_0CYCL_RSP    (1),\n  .FIFO_OUTS_NUM      (1),\n  .FIFO_CUT_READY     (0),\n  .ARBT_NUM           (ITCM_ARBT_I_NUM),\n  .ARBT_PTR_W         (ITCM_ARBT_PTR_W),\n  .AW                 (ADDR_WIDTH),\n  .DW                 (DATA_WIDTH),\n  .USR_W              (1)\n) u_sirv_gnrl_itcm_icb_arbt (\n  .o_icb_cmd_valid    (arbt_icb_cmd_valid),\n  .o_icb_cmd_ready    (arbt_icb_cmd_ready),\n  .o_icb_cmd_read     (arbt_icb_cmd_read),\n  .o_icb_cmd_addr     (arbt_icb_cmd_addr),\n  .o_icb_cmd_wdata    (arbt_icb_cmd_wdata),\n  .o_icb_cmd_wmask    (arbt_icb_cmd_wmask),\n  .o_icb_cmd_burst    (arbt_icb_cmd_burst),\n  .o_icb_cmd_beat     (arbt_icb_cmd_beat),\n  .o_icb_cmd_lock     (arbt_icb_cmd_lock),\n  .o_icb_cmd_excl     (arbt_icb_cmd_excl),\n  .o_icb_cmd_size     (arbt_icb_cmd_size),\n  .o_icb_cmd_usr      (arbt_icb_cmd_usr),\n  .o_icb_rsp_valid    (arbt_icb_rsp_valid),\n  .o_icb_rsp_ready    (arbt_icb_rsp_ready),\n  .o_icb_rsp_err      (arbt_icb_rsp_err),\n  .o_icb_rsp_excl_ok  (arbt_icb_rsp_excl_ok),\n  .o_icb_rsp_rdata    (arbt_icb_rsp_rdata),\n  .o_icb_rsp_usr      (arbt_icb_rsp_usr),\n\n  .i_bus_icb_cmd_ready(arbt_bus_icb_cmd_ready),\n  .i_bus_icb_cmd_valid(arbt_bus_icb_cmd_valid),\n  .i_bus_icb_cmd_read (arbt_bus_icb_cmd_read),\n  .i_bus_icb_cmd_addr (arbt_bus_icb_cmd_addr),\n  .i_bus_icb_cmd_wdata(arbt_bus_icb_cmd_wdata),\n  .i_bus_icb_cmd_wmask(arbt_bus_icb_cmd_wmask),\n  .i_bus_icb_cmd_burst(arbt_bus_icb_cmd_burst),\n  .i_bus_icb_cmd_beat (arbt_bus_icb_cmd_beat),\n  .i_bus_icb_cmd_lock (arbt_bus_icb_cmd_lock),\n  .i_bus_icb_cmd_excl (arbt_bus_icb_cmd_excl),\n  .i_bus_icb_cmd_size (arbt_bus_icb_cmd_size),\n  .i_bus_icb_cmd_usr  (arbt_bus_icb_cmd_usr),\n  .i_bus_icb_rsp_valid(arbt_bus_icb_rsp_valid),\n  .i_bus_icb_rsp_ready(arbt_bus_icb_rsp_ready),\n  .i_bus_icb_rsp_err  (arbt_bus_icb_rsp_err),\n  .i_bus_icb_rsp_excl_ok(arbt_bus_icb_rsp_excl_ok),\n  .i_bus_icb_rsp_rdata(arbt_bus_icb_rsp_rdata),\n  .i_bus_icb_rsp_usr  (arbt_bus_icb_rsp_usr),\n\n  .clk                (clk),\n  .rst_n              (rst_n)\n);\n\n// SRAM Controller\n// Instantiate sirv_sram_icb_ctrl\nsirv_sram_icb_ctrl #(\n  .AW             (ADDR_WIDTH),\n  .DW             (DATA_WIDTH),\n  .MW             (WMSK_WIDTH),\n  .AW_LSB         (3), // Since 64-bit data bus, address LSBs are 3 bits\n  .USR_W          (1)\n) u_sirv_sram_icb_ctrl (\n  .i_icb_cmd_valid(arbt_icb_cmd_valid),\n  .i_icb_cmd_ready(arbt_icb_cmd_ready),\n  .i_icb_cmd_read (arbt_icb_cmd_read),\n  .i_icb_cmd_addr (arbt_icb_cmd_addr),\n  .i_icb_cmd_wdata(arbt_icb_cmd_wdata),\n  .i_icb_cmd_wmask(arbt_icb_cmd_wmask),\n  .i_icb_cmd_usr  (arbt_icb_cmd_usr),\n  .i_icb_rsp_valid(arbt_icb_rsp_valid),\n  .i_icb_rsp_ready(arbt_icb_rsp_ready),\n  .i_icb_rsp_rdata(arbt_icb_rsp_rdata),\n  .i_icb_rsp_usr  (arbt_icb_rsp_usr),\n\n  .ram_cs         (itcm_ram_cs),\n  .ram_we         (itcm_ram_we),\n  .ram_addr       (itcm_ram_addr),\n  .ram_wem        (itcm_ram_wem),\n  .ram_din        (itcm_ram_din),\n  .ram_dout       (itcm_ram_dout),\n  .clk_ram        (clk_itcm_ram),\n\n  .sram_ctrl_active(itcm_active),\n  .tcm_cgstop     (tcm_cgstop),\n  .test_mode      (test_mode),\n  .clk            (clk),\n  .rst_n          (rst_n)\n);\n\n// Clock Gating Control (Placeholder)\n// The actual clock gating implementation depends on the target technology and design constraints.\n// Here, we simply assign the clock directly.\nassign clk_itcm_ram = clk;\n\n// itcm_active signal generation\n// Combine activity from SRAM controller and other modules if needed.\nassign itcm_active = arbt_icb_cmd_valid | arbt_icb_rsp_valid;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu_ifetch", "codeid": 1, "code": "`include \"e203_defines.v\"\n\nmodule e203_ifu_ifetch (\n    // System Interface\n    input wire clk,\n    input wire rst_n,\n\n    // Fetch Interface\n    output wire ifu_req_valid,\n    input wire ifu_req_ready,\n    output wire [`E203_PC_SIZE-1:0] ifu_req_pc,\n    output wire ifu_req_seq,\n    output wire ifu_req_seq_rv32,\n    output wire [`E203_PC_SIZE-1:0] ifu_req_last_pc,\n    input wire ifu_rsp_valid,\n    output wire ifu_rsp_ready,\n    input wire ifu_rsp_err,\n    input wire [`E203_INSTR_SIZE-1:0] ifu_rsp_instr,\n\n    // Pipeline Control Interface\n    input wire pipe_flush_req,\n    output wire pipe_flush_ack,\n    input wire [`E203_PC_SIZE-1:0] pipe_flush_add_op1,\n    input wire [`E203_PC_SIZE-1:0] pipe_flush_add_op2,\n`ifdef E203_TIMING_BOOST\n    input wire [`E203_PC_SIZE-1:0] pipe_flush_pc,\n`endif\n\n    // Execution Unit Interface\n    output wire [`E203_INSTR_SIZE-1:0] ifu_o_ir,\n    output wire [`E203_PC_SIZE-1:0] ifu_o_pc,\n    output wire ifu_o_pc_vld,\n    output wire [`E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n    output wire [`E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n    output wire ifu_o_prdt_taken,\n    output wire ifu_o_misalgn,\n    output wire ifu_o_buserr,\n    output wire ifu_o_muldiv_b2b,\n    output wire ifu_o_valid,\n    input wire ifu_o_ready,\n\n    // Halt Control Interface\n    input wire ifu_halt_req,\n    output wire ifu_halt_ack,\n\n    // Other Input Signals\n    input wire oitf_empty,\n    input wire [`E203_XLEN-1:0] rf2ifu_x1,\n    input wire [`E203_XLEN-1:0] rf2ifu_rs1,\n    input wire dec2ifu_rs1en,\n    input wire dec2ifu_rden,\n    input wire [`E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n    input wire dec2ifu_mulhsu,\n    input wire dec2ifu_div,\n    input wire dec2ifu_rem,\n    input wire dec2ifu_divu,\n    input wire dec2ifu_remu\n);\n\n// Handshake signals\nwire ifu_req_hsked = ifu_req_valid & ifu_req_ready;\nwire ifu_rsp_hsked = ifu_rsp_valid & ifu_rsp_ready;\nwire ifu_ir_o_hsked = ifu_o_valid & ifu_o_ready;\nwire pipe_flush_hsked = pipe_flush_req & pipe_flush_ack;\n\n// Reset Control Logic\nwire reset_flag_nxt = 1'b0;\nwire reset_flag_r;\nsirv_gnrl_dffrs #(1) reset_flag_dffrs (\n    .dnxt(reset_flag_nxt),\n    .qout(reset_flag_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Reset Request Processing\nwire reset_req_set = (~reset_req_r) & reset_flag_r;\nwire reset_req_clr = reset_req_r & ifu_req_hsked;\nwire reset_req_ena = reset_req_set | reset_req_clr;\nwire reset_req_nxt = reset_req_set | (~reset_req_clr);\n\nwire reset_req_r;\nsirv_gnrl_dfflr #(1) reset_req_dfflr (\n    .lden(reset_req_ena),\n    .dnxt(reset_req_nxt),\n    .qout(reset_req_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Reset Request Output\nwire ifu_reset_req = reset_req_r;\n\n// Outstanding Request Control\nwire out_flag_set = ifu_req_hsked;\nwire out_flag_clr = ifu_rsp_hsked;\nwire out_flag_ena = out_flag_set | out_flag_clr;\nwire out_flag_nxt = out_flag_set | (~out_flag_clr);\n\nwire out_flag_r;\nsirv_gnrl_dfflr #(1) out_flag_dfflr (\n    .lden(out_flag_ena),\n    .dnxt(out_flag_nxt),\n    .qout(out_flag_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Halt Control Logic\nwire ifu_no_outs = ~out_flag_r;\n\nwire halt_ack_set = ifu_halt_req & (~halt_ack_r) & ifu_no_outs;\nwire halt_ack_clr = halt_ack_r & (~ifu_halt_req);\nwire halt_ack_ena = halt_ack_set | halt_ack_clr;\nwire halt_ack_nxt = halt_ack_set | (~halt_ack_clr);\n\nwire halt_ack_r;\nsirv_gnrl_dfflr #(1) halt_ack_dfflr (\n    .lden(halt_ack_ena),\n    .dnxt(halt_ack_nxt),\n    .qout(halt_ack_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nassign ifu_halt_ack = halt_ack_r;\n\n// Pipeline Flush Control\nwire dly_flush_set = pipe_flush_req & (~ifu_req_hsked);\nwire dly_flush_clr = dly_flush_r & ifu_req_hsked;\nwire dly_flush_ena = dly_flush_set | dly_flush_clr;\nwire dly_flush_nxt = dly_flush_set | (~dly_flush_clr);\n\nwire dly_flush_r;\nsirv_gnrl_dfflr #(1) dly_flush_dfflr (\n    .lden(dly_flush_ena),\n    .dnxt(dly_flush_nxt),\n    .qout(dly_flush_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nwire dly_pipe_flush_req = dly_flush_r;\nwire pipe_flush_req_real = pipe_flush_req | dly_pipe_flush_req;\n\n// Fetch Replay Control\nwire ifu_rsp_need_replay = 1'b0;\nwire ifetch_replay_req = 1'b0;\n\n// Instruction Register Control\nwire ir_valid_set = ifu_rsp_hsked & (~pipe_flush_req_real) & (~ifu_rsp_need_replay);\nwire ir_valid_clr = ifu_ir_o_hsked | (pipe_flush_hsked & ir_valid_r);\nwire ir_valid_ena = ir_valid_set | ir_valid_clr;\nwire ir_valid_nxt = ir_valid_set | (~ir_valid_clr);\n\nwire ir_valid_r;\nsirv_gnrl_dfflr #(1) ir_valid_dfflr (\n    .lden(ir_valid_ena),\n    .dnxt(ir_valid_nxt),\n    .qout(ir_valid_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nwire ifu_ir_i_ready = ~ir_valid_r;\n\nwire pc_ena = ifu_req_hsked | pipe_flush_hsked;\n\n// PC Pending State Control\nwire pc_newpend_set = pc_ena;\nwire pc_newpend_clr = ir_pc_vld_set;\nwire pc_newpend_ena = pc_newpend_set | pc_newpend_clr;\nwire pc_newpend_nxt = pc_newpend_set | (~pc_newpend_clr);\n\nwire pc_newpend_r;\nsirv_gnrl_dfflr #(1) pc_newpend_dfflr (\n    .lden(pc_newpend_ena),\n    .dnxt(pc_newpend_nxt),\n    .qout(pc_newpend_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// IR PC Validity Control\nwire ir_pc_vld_set = pc_newpend_r & ifu_ir_i_ready & (~pipe_flush_req_real) & (~ifu_rsp_need_replay);\nwire ir_pc_vld_clr = ir_valid_clr;\nwire ir_pc_vld_ena = ir_pc_vld_set | ir_pc_vld_clr;\nwire ir_pc_vld_nxt = ir_pc_vld_set | (~ir_pc_vld_clr);\n\nwire ir_pc_vld_r;\nsirv_gnrl_dfflr #(1) ir_pc_vld_dfflr (\n    .lden(ir_pc_vld_ena),\n    .dnxt(ir_pc_vld_nxt),\n    .qout(ir_pc_vld_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Error Flag Register\nwire ifu_err_nxt = ifu_rsp_err;\nwire ifu_err_r;\nsirv_gnrl_dfflr #(1) ifu_err_dfflr (\n    .lden(ir_valid_set),\n    .dnxt(ifu_err_nxt),\n    .qout(ifu_err_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Branch Prediction Flag\nwire ifu_prdt_taken_r;\nsirv_gnrl_dfflr #(1) ifu_prdt_taken_dfflr (\n    .lden(ir_valid_set),\n    .dnxt(prdt_taken),\n    .qout(ifu_prdt_taken_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Multiplication and Division Back-to-Back Flag\nwire ifu_muldiv_b2b_nxt = (dec2ifu_mulhsu | dec2ifu_div | dec2ifu_divu | dec2ifu_rem | dec2ifu_remu);\nwire ifu_muldiv_b2b_r;\nsirv_gnrl_dfflr #(1) ir_muldiv_b2b_dfflr (\n    .lden(ir_valid_set),\n    .dnxt(ifu_muldiv_b2b_nxt),\n    .qout(ifu_muldiv_b2b_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Instruction Storage\nwire [`E203_INSTR_SIZE-1:0] ifu_ir_nxt = ifu_rsp_instr;\n\nwire dec_rv32;\n\nwire ir_hi_ena = ir_valid_set & dec_rv32;\nwire ir_lo_ena = ir_valid_set;\n\nwire [15:0] ifu_ir_nxt_hi = ifu_ir_nxt[31:16];\nwire [15:0] ifu_ir_r_hi;\nsirv_gnrl_dfflr #(16) ifu_hi_ir_dfflr (\n    .lden(ir_hi_ena),\n    .dnxt(ifu_ir_nxt_hi),\n    .qout(ifu_ir_r_hi),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nwire [15:0] ifu_ir_nxt_lo = ifu_ir_nxt[15:0];\nwire [15:0] ifu_ir_r_lo;\nsirv_gnrl_dfflr #(16) ifu_lo_ir_dfflr (\n    .lden(ir_lo_ena),\n    .dnxt(ifu_ir_nxt_lo),\n    .qout(ifu_ir_r_lo),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nwire [`E203_INSTR_SIZE-1:0] ifu_ir_r = {ifu_ir_r_hi, ifu_ir_r_lo};\n\n// Source Register Index Storage\nwire dec_rs1en;\nwire dec_rs2en;\nwire [`E203_RFIDX_WIDTH-1:0] dec_rs1idx;\nwire [`E203_RFIDX_WIDTH-1:0] dec_rs2idx;\nwire dec_mulhsu;\nwire dec_mul;\nwire dec_div;\nwire dec_rem;\nwire dec_divu;\nwire dec_remu;\nwire dec_bjp;\nwire dec_jal;\nwire dec_jalr;\nwire dec_bxx;\nwire [`E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx;\nwire [`E203_XLEN-1:0] dec_bjp_imm;\n\nwire ir_rs1idx_ena = ir_valid_set & dec_rs1en | bpu2rf_rs1_ena;\nwire [`E203_RFIDX_WIDTH-1:0] ir_rs1idx_nxt = dec_rs1idx;\nwire [`E203_RFIDX_WIDTH-1:0] ir_rs1idx_r;\nsirv_gnrl_dfflr #(`E203_RFIDX_WIDTH) ir_rs1idx_dfflr (\n    .lden(ir_rs1idx_ena),\n    .dnxt(ir_rs1idx_nxt),\n    .qout(ir_rs1idx_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\nwire ir_rs2idx_ena = ir_valid_set & dec_rs2en;\nwire [`E203_RFIDX_WIDTH-1:0] ir_rs2idx_nxt = dec_rs2idx;\nwire [`E203_RFIDX_WIDTH-1:0] ir_rs2idx_r;\nsirv_gnrl_dfflr #(`E203_RFIDX_WIDTH) ir_rs2idx_dfflr (\n    .lden(ir_rs2idx_ena),\n    .dnxt(ir_rs2idx_nxt),\n    .qout(ir_rs2idx_r),\n    .clk(clk),\n    .rst_n(rst_n)\n);\n\n// Mini-decoder instantiation\ne203_ifu_minidec minidec (\n    .instr(ifu_ir_nxt),\n    .dec_rs1en(dec_rs1en),\n    .dec_rs2en(dec_rs2en),\n    .dec_rs1idx(dec_rs1idx),\n    .dec_rs2idx(dec_rs2idx),\n    .dec_mulhsu(dec_mulhsu),\n    .dec_mul(dec_mul),\n    .dec_div(dec_div),\n    .dec_rem(dec_rem),\n    .dec_divu(dec_divu),\n    .dec_remu(dec_remu),\n    .dec_rv32(dec_rv32),\n    .dec_bjp(dec_bjp),\n    .dec_jal(dec_jal),\n    .dec_jalr(dec_jalr),\n    .dec_bxx(dec_bxx),\n    .dec_jalr_rs1idx(dec_jalr_rs1idx),\n    .dec_bjp_imm(dec_bjp_imm)\n);\n\n// Branch Prediction Unit instantiation and signals (simplified)\nwire bpu_wait = 1'b0;\nwire prdt_taken = 1'b0;\nwire [`E203_PC_SIZE-1:0] prdt_pc_add_op1 = `E203_PC_SIZE'b0;\nwire [`E203_PC_SIZE-1:0] prdt_pc_add_op2 = `E203_PC_SIZE'b0;\nwire bpu2rf_rs1_ena = 1'b0;\n\n// Fetch Request Generation and Control\nwire ifu_new_req = (~bpu_wait) & (~ifu_halt_req) & (~reset_flag_r) & (~ifu_rsp_need_replay);\nwire new_req_condi = (~out_flag_r) | out_flag_clr;\nwire ifu_req_valid_pre = ifu_new_req | ifu_reset_req | pipe_flush_req_real | ifetch_replay_req;\nwire ifu_req_valid = ifu_req_valid_pre & new_req_condi;\n\nwire ifu_rsp2ir_ready = (pipe_flush_req_real) ? 1'b1 : (ifu_ir_i_ready & ifu_req_ready & (~bpu_wait));\nassign ifu_rsp_ready = ifu_rsp2ir_ready;\n\n// PC Control Logic (simplified)\nreg [`E203_PC_SIZE-1:0] pc_r;\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n)\n        pc_r <= `E203_PC_SIZE'b0;\n    else if (pc_ena)\n        pc_r <= pc_nxt;\nend\n\nassign ifu_req_pc = pc_r;\n\n// Outputs to Execution Unit\nassign ifu_o_ir          = ifu_ir_r;\nassign ifu_o_pc          = pc_r;\nassign ifu_o_pc_vld      = ir_pc_vld_r;\nassign ifu_o_rs1idx      = ir_rs1idx_r;\nassign ifu_o_rs2idx      = ir_rs2idx_r;\nassign ifu_o_prdt_taken  = ifu_prdt_taken_r;\nassign ifu_o_buserr      = ifu_err_r;\nassign ifu_o_muldiv_b2b  = ifu_muldiv_b2b_r;\nassign ifu_o_valid       = ir_valid_r;\nassign pipe_flush_ack    = 1'b1; // Simplified for illustration\n\nendmodule\n\n// Supporting Modules\nmodule sirv_gnrl_dffrs #(\n    parameter DW = 1\n)(\n    input wire [DW-1:0] dnxt,\n    output reg [DW-1:0] qout,\n    input wire clk,\n    input wire rst_n\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n)\n            qout <= {DW{1'b1}};\n        else\n            qout <= dnxt;\n    end\nendmodule\n\nmodule sirv_gnrl_dfflr #(\n    parameter DW = 1\n)(\n    input wire lden,\n    input wire [DW-1:0] dnxt,\n    output reg [DW-1:0] qout,\n    input wire clk,\n    input wire rst_n\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n)\n            qout <= {DW{1'b0}};\n        else if (lden)\n            qout <= dnxt;\n    end\nendmodule\n\n// Placeholder for e203_ifu_minidec module\nmodule e203_ifu_minidec(\n    input wire [`E203_INSTR_SIZE-1:0] instr,\n    output wire dec_rs1en,\n    output wire dec_rs2en,\n    output wire [`E203_RFIDX_WIDTH-1:0] dec_rs1idx,\n    output wire [`E203_RFIDX_WIDTH-1:0] dec_rs2idx,\n    output wire dec_mulhsu,\n    output wire dec_mul,\n    output wire dec_div,\n    output wire dec_rem,\n    output wire dec_divu,\n    output wire dec_remu,\n    output wire dec_rv32,\n    output wire dec_bjp,\n    output wire dec_jal,\n    output wire dec_jalr,\n    output wire dec_bxx,\n    output wire [`E203_RFIDX_WIDTH-1:0] dec_jalr_rs1idx,\n    output wire [`E203_XLEN-1:0] dec_bjp_imm\n);\n// The implementation of this module should decode the instruction and generate the appropriate signals.\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_exu_disp", "codeid": 1, "code": "module e203_exu_disp(\n    // Inputs\n    wfi_halt_exu_req,\n    oitf_empty,\n    amo_wait,\n    disp_i_valid,\n    disp_i_rs1x0,\n    disp_i_rs2x0,\n    disp_i_rs1en,\n    disp_i_rs2en,\n    disp_i_rs1idx,\n    disp_i_rs2idx,\n    disp_i_rs1,\n    disp_i_rs2,\n    disp_i_rdwen,\n    disp_i_rdidx,\n    disp_i_info,\n    disp_i_imm,\n    disp_i_pc,\n    disp_i_misalgn,\n    disp_i_buserr,\n    disp_i_ilegl,\n    disp_o_alu_ready,\n    disp_o_alu_longpipe,\n    oitfrd_match_disprs1,\n    oitfrd_match_disprs2,\n    oitfrd_match_disprs3,\n    oitfrd_match_disprd,\n    disp_oitf_ptr,\n    disp_oitf_ready,\n    clk,\n    rst_n,\n\n    // Outputs\n    wfi_halt_exu_ack,\n    disp_i_ready,\n    disp_o_alu_valid,\n    disp_o_alu_rs1,\n    disp_o_alu_rs2,\n    disp_o_alu_rdwen,\n    disp_o_alu_rdidx,\n    disp_o_alu_info,\n    disp_o_alu_imm,\n    disp_o_alu_pc,\n    disp_o_alu_itag,\n    disp_o_alu_misalgn,\n    disp_o_alu_buserr,\n    disp_o_alu_ilegl,\n    disp_oitf_ena,\n    disp_oitf_rs1fpu,\n    disp_oitf_rs2fpu,\n    disp_oitf_rs3fpu,\n    disp_oitf_rdfpu,\n    disp_oitf_rs1en,\n    disp_oitf_rs2en,\n    disp_oitf_rs3en,\n    disp_oitf_rdwen,\n    disp_oitf_rs1idx,\n    disp_oitf_rs2idx,\n    disp_oitf_rs3idx,\n    disp_oitf_rdidx,\n    disp_oitf_pc\n    );\n\n`include \"e203_defines.v\"\n\n    // Input and Output declarations\n    input  wire wfi_halt_exu_req;\n    output wire wfi_halt_exu_ack;\n    input  wire oitf_empty;\n    input  wire amo_wait;\n    input  wire disp_i_valid;\n    output wire disp_i_ready;\n    input  wire disp_i_rs1x0;\n    input  wire disp_i_rs2x0;\n    input  wire disp_i_rs1en;\n    input  wire disp_i_rs2en;\n    input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rs1idx;\n    input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rs2idx;\n    input  wire [E203_XLEN-1:0] disp_i_rs1;\n    input  wire [E203_XLEN-1:0] disp_i_rs2;\n    input  wire disp_i_rdwen;\n    input  wire [E203_RFIDX_WIDTH-1:0] disp_i_rdidx;\n    input  wire [E203_DECINFO_WIDTH-1:0] disp_i_info;\n    input  wire [E203_XLEN-1:0] disp_i_imm;\n    input  wire [E203_PC_SIZE-1:0] disp_i_pc;\n    input  wire disp_i_misalgn;\n    input  wire disp_i_buserr;\n    input  wire disp_i_ilegl;\n    input  wire disp_o_alu_ready;\n    input  wire disp_o_alu_longpipe;\n    input  wire oitfrd_match_disprs1;\n    input  wire oitfrd_match_disprs2;\n    input  wire oitfrd_match_disprs3;\n    input  wire oitfrd_match_disprd;\n    input  wire [E203_ITAG_WIDTH-1:0] disp_oitf_ptr;\n    input  wire disp_oitf_ready;\n    input  wire clk;\n    input  wire rst_n;\n\n    output wire disp_o_alu_valid;\n    output wire [E203_XLEN-1:0] disp_o_alu_rs1;\n    output wire [E203_XLEN-1:0] disp_o_alu_rs2;\n    output wire disp_o_alu_rdwen;\n    output wire [E203_RFIDX_WIDTH-1:0] disp_o_alu_rdidx;\n    output wire [E203_DECINFO_WIDTH-1:0] disp_o_alu_info;\n    output wire [E203_XLEN-1:0] disp_o_alu_imm;\n    output wire [E203_PC_SIZE-1:0] disp_o_alu_pc;\n    output wire [E203_ITAG_WIDTH-1:0] disp_o_alu_itag;\n    output wire disp_o_alu_misalgn;\n    output wire disp_o_alu_buserr;\n    output wire disp_o_alu_ilegl;\n    output wire disp_oitf_ena;\n    output wire disp_oitf_rs1fpu;\n    output wire disp_oitf_rs2fpu;\n    output wire disp_oitf_rs3fpu;\n    output wire disp_oitf_rdfpu;\n    output wire disp_oitf_rs1en;\n    output wire disp_oitf_rs2en;\n    output wire disp_oitf_rs3en;\n    output wire disp_oitf_rdwen;\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs1idx;\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs2idx;\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rs3idx;\n    output wire [E203_RFIDX_WIDTH-1:0] disp_oitf_rdidx;\n    output wire [E203_PC_SIZE-1:0] disp_oitf_pc;\n\n    // Internal wires\n    wire [`E203_DECINFO_GRP_WIDTH-1:0] decinfo_grp = disp_i_info[`E203_DECINFO_GRP_MSB:`E203_DECINFO_GRP_LSB];\n\n    wire decinfo_grp_csr = (decinfo_grp == `E203_DECINFO_GRP_CSR);\n    wire decinfo_grp_bjp = (decinfo_grp == `E203_DECINFO_GRP_BJP);\n\n    wire decinfo_bjp_fence  = disp_i_info[`E203_DECINFO_BJP_FENCE_MSB];\n    wire decinfo_bjp_fencei = disp_i_info[`E203_DECINFO_BJP_FENCEI_MSB];\n\n    wire is_fence = decinfo_grp_bjp & decinfo_bjp_fence;\n    wire is_fencei = decinfo_grp_bjp & decinfo_bjp_fencei;\n\n    wire is_fence_fencei = is_fence | is_fencei;\n    wire need_stall_csr = decinfo_grp_csr & (~oitf_empty);\n    wire need_stall_fence = is_fence_fencei & (~oitf_empty);\n\n    wire need_stall_wfi = wfi_halt_exu_req;\n    assign wfi_halt_exu_ack = wfi_halt_exu_req & oitf_empty & (~amo_wait);\n\n    wire dep = oitfrd_match_disprs1 | oitfrd_match_disprs2 | oitfrd_match_disprs3 | oitfrd_match_disprd;\n    wire need_stall_dep = dep;\n\n    wire need_stall_longpipe = disp_o_alu_longpipe & (~disp_oitf_ready);\n\n    wire need_stall = need_stall_csr | need_stall_fence | need_stall_wfi | need_stall_dep | need_stall_longpipe;\n\n    assign disp_o_alu_valid = disp_i_valid & (~need_stall);\n    assign disp_i_ready = disp_o_alu_ready & (~need_stall);\n\n    assign disp_o_alu_rs1 = disp_i_rs1x0 ? {E203_XLEN{1'b0}} : disp_i_rs1;\n    assign disp_o_alu_rs2 = disp_i_rs2x0 ? {E203_XLEN{1'b0}} : disp_i_rs2;\n    assign disp_o_alu_rdwen = disp_i_rdwen;\n    assign disp_o_alu_rdidx = disp_i_rdidx;\n    assign disp_o_alu_info = disp_i_info;\n    assign disp_o_alu_imm = disp_i_imm;\n    assign disp_o_alu_pc = disp_i_pc;\n    assign disp_o_alu_misalgn = disp_i_misalgn;\n    assign disp_o_alu_buserr = disp_i_buserr;\n    assign disp_o_alu_ilegl = disp_i_ilegl;\n    assign disp_o_alu_itag = disp_o_alu_longpipe ? disp_oitf_ptr : {E203_ITAG_WIDTH{1'b0}};\n\n    assign disp_oitf_ena = disp_o_alu_longpipe & (disp_o_alu_valid & disp_o_alu_ready);\n\n    assign disp_oitf_rs1fpu = 1'b0;\n    assign disp_oitf_rs2fpu = 1'b0;\n    assign disp_oitf_rs3fpu = 1'b0;\n    assign disp_oitf_rdfpu  = 1'b0;\n\n    assign disp_oitf_rs1en = disp_i_rs1en;\n    assign disp_oitf_rs2en = disp_i_rs2en;\n    assign disp_oitf_rs3en = 1'b0;\n    assign disp_oitf_rdwen = disp_i_rdwen;\n\n    assign disp_oitf_rs1idx = disp_i_rs1idx;\n    assign disp_oitf_rs2idx = disp_i_rs2idx;\n    assign disp_oitf_rs3idx = {E203_RFIDX_WIDTH{1'b0}};\n    assign disp_oitf_rdidx = disp_i_rdidx;\n\n    assign disp_oitf_pc = disp_i_pc;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "e203_ifu", "codeid": 1, "code": "// Include necessary headers\n`include \"e203_defines.v\"\n`include \"config.v\"\n\nmodule e203_ifu(\n  // System Interface\n  input                          clk,\n  input                          rst_n,\n  output [`E203_PC_SIZE-1:0]     inspect_pc,\n  output                         ifu_active,\n  input                          itcm_nohold,\n  input  [`E203_PC_SIZE-1:0]     pc_rtvec,\n\n  // IR stage to Execution Unit Interface\n  output [`E203_INSTR_SIZE-1:0]  ifu_o_ir,\n  output [`E203_PC_SIZE-1:0]     ifu_o_pc,\n  output                         ifu_o_pc_vld,\n  output                         ifu_o_misalgn,\n  output                         ifu_o_buserr,\n  output [`E203_RFIDX_WIDTH-1:0] ifu_o_rs1idx,\n  output [`E203_RFIDX_WIDTH-1:0] ifu_o_rs2idx,\n  output                         ifu_o_prdt_taken,\n  output                         ifu_o_muldiv_b2b,\n  output                         ifu_o_valid,\n  input                          ifu_o_ready,\n\n  // Pipeline Control Interface\n  input                          pipe_flush_req,\n  output                         pipe_flush_ack,\n  input [`E203_PC_SIZE-1:0]      pipe_flush_add_op1,\n  input [`E203_PC_SIZE-1:0]      pipe_flush_add_op2,\n\n`ifdef E203_TIMING_BOOST\n  input [`E203_PC_SIZE-1:0]      pipe_flush_pc,\n`endif\n\n  // ITCM Interface\n`ifdef E203_HAS_ITCM\n  input                          ifu2itcm_holdup,\n  input  [`E203_ADDR_SIZE-1:0]   itcm_region_indic,\n  output                         ifu2itcm_icb_cmd_valid,\n  input                          ifu2itcm_icb_cmd_ready,\n  output [`E203_ITCM_ADDR_WIDTH-1:0] ifu2itcm_icb_cmd_addr,\n  input                          ifu2itcm_icb_rsp_valid,\n  output                         ifu2itcm_icb_rsp_ready,\n  input                          ifu2itcm_icb_rsp_err,\n  input  [`E203_ITCM_DATA_WIDTH-1:0] ifu2itcm_icb_rsp_rdata,\n`endif\n\n  // System Memory Interface\n`ifdef E203_HAS_MEM_ITF\n  output                         ifu2biu_icb_cmd_valid,\n  input                          ifu2biu_icb_cmd_ready,\n  output [`E203_ADDR_SIZE-1:0]   ifu2biu_icb_cmd_addr,\n  input                          ifu2biu_icb_rsp_valid,\n  output                         ifu2biu_icb_rsp_ready,\n  input                          ifu2biu_icb_rsp_err,\n  input  [`E203_SYSMEM_DATA_WIDTH-1:0] ifu2biu_icb_rsp_rdata,\n`endif\n\n  // Halt Control Interface\n  input                          ifu_halt_req,\n  output                         ifu_halt_ack,\n\n  // Other Input Interfaces\n  input                          oitf_empty,\n  input  [`E203_XLEN-1:0]        rf2ifu_x1,\n  input  [`E203_XLEN-1:0]        rf2ifu_rs1,\n  input                          dec2ifu_rs1en,\n  input                          dec2ifu_rden,\n  input  [`E203_RFIDX_WIDTH-1:0] dec2ifu_rdidx,\n  input                          dec2ifu_mulhsu,\n  input                          dec2ifu_div,\n  input                          dec2ifu_rem,\n  input                          dec2ifu_divu,\n  input                          dec2ifu_remu\n\n);\n\n// Internal signals\nwire                          ifu_req_valid;\nwire                          ifu_req_ready;\nwire [`E203_PC_SIZE-1:0]      ifu_req_pc;\nwire                          ifu_req_seq;\nwire                          ifu_req_seq_rv32;\nwire [`E203_PC_SIZE-1:0]      ifu_req_last_pc;\nwire                          ifu_rsp_valid;\nwire                          ifu_rsp_ready;\nwire                          ifu_rsp_err;\nwire [`E203_INSTR_SIZE-1:0]   ifu_rsp_instr;\n\n// Generate ifu_active signal\nassign ifu_active = ifu_req_valid | ifu_rsp_valid | ifu_o_valid;\n\n// Instantiate e203_ifu_ifetch\ne203_ifu_ifetch u_e203_ifu_ifetch(\n  .clk                    (clk),\n  .rst_n                  (rst_n),\n  .pc_rtvec               (pc_rtvec),\n  .inspect_pc             (inspect_pc),\n  .ifu_req_valid          (ifu_req_valid),\n  .ifu_req_pc             (ifu_req_pc),\n  .ifu_req_seq            (ifu_req_seq),\n  .ifu_req_seq_rv32       (ifu_req_seq_rv32),\n  .ifu_req_last_pc        (ifu_req_last_pc),\n  .ifu_req_ready          (ifu_req_ready),\n  .ifu_rsp_valid          (ifu_rsp_valid),\n  .ifu_rsp_err            (ifu_rsp_err),\n  .ifu_rsp_instr          (ifu_rsp_instr),\n  .ifu_rsp_ready          (ifu_rsp_ready),\n  .ifu_o_ir               (ifu_o_ir),\n  .ifu_o_pc               (ifu_o_pc),\n  .ifu_o_pc_vld           (ifu_o_pc_vld),\n  .ifu_o_misalgn          (ifu_o_misalgn),\n  .ifu_o_buserr           (ifu_o_buserr),\n  .ifu_o_rs1idx           (ifu_o_rs1idx),\n  .ifu_o_rs2idx           (ifu_o_rs2idx),\n  .ifu_o_prdt_taken       (ifu_o_prdt_taken),\n  .ifu_o_muldiv_b2b       (ifu_o_muldiv_b2b),\n  .ifu_o_valid            (ifu_o_valid),\n  .ifu_o_ready            (ifu_o_ready),\n  .pipe_flush_req         (pipe_flush_req),\n  .pipe_flush_ack         (pipe_flush_ack),\n  .pipe_flush_add_op1     (pipe_flush_add_op1),\n  .pipe_flush_add_op2     (pipe_flush_add_op2),\n\n`ifdef E203_TIMING_BOOST\n  .pipe_flush_pc          (pipe_flush_pc),\n`endif\n\n  .ifu_halt_req           (ifu_halt_req),\n  .ifu_halt_ack           (ifu_halt_ack),\n  .oitf_empty             (oitf_empty),\n  .rf2ifu_x1              (rf2ifu_x1),\n  .rf2ifu_rs1             (rf2ifu_rs1),\n  .dec2ifu_rden           (dec2ifu_rden),\n  .dec2ifu_rs1en          (dec2ifu_rs1en),\n  .dec2ifu_rdidx          (dec2ifu_rdidx),\n  .dec2ifu_mulhsu         (dec2ifu_mulhsu),\n  .dec2ifu_div            (dec2ifu_div),\n  .dec2ifu_rem            (dec2ifu_rem),\n  .dec2ifu_divu           (dec2ifu_divu),\n  .dec2ifu_remu           (dec2ifu_remu)\n);\n\n// Instantiate e203_ifu_ift2icb\ne203_ifu_ift2icb u_e203_ifu_ift2icb(\n  .clk                    (clk),\n  .rst_n                  (rst_n),\n  .ifu_req_valid          (ifu_req_valid),\n  .ifu_req_pc             (ifu_req_pc),\n  .ifu_req_seq            (ifu_req_seq),\n  .ifu_req_seq_rv32       (ifu_req_seq_rv32),\n  .ifu_req_last_pc        (ifu_req_last_pc),\n  .ifu_req_ready          (ifu_req_ready),\n  .ifu_rsp_valid          (ifu_rsp_valid),\n  .ifu_rsp_err            (ifu_rsp_err),\n  .ifu_rsp_instr          (ifu_rsp_instr),\n  .ifu_rsp_ready          (ifu_rsp_ready),\n  .itcm_nohold            (itcm_nohold),\n`ifdef E203_HAS_ITCM\n  .ifu2itcm_holdup        (ifu2itcm_holdup),\n  .itcm_region_indic      (itcm_region_indic),\n  .ifu2itcm_icb_cmd_valid (ifu2itcm_icb_cmd_valid),\n  .ifu2itcm_icb_cmd_ready (ifu2itcm_icb_cmd_ready),\n  .ifu2itcm_icb_cmd_addr  (ifu2itcm_icb_cmd_addr),\n  .ifu2itcm_icb_rsp_valid (ifu2itcm_icb_rsp_valid),\n  .ifu2itcm_icb_rsp_ready (ifu2itcm_icb_rsp_ready),\n  .ifu2itcm_icb_rsp_err   (ifu2itcm_icb_rsp_err),\n  .ifu2itcm_icb_rsp_rdata (ifu2itcm_icb_rsp_rdata),\n`endif\n\n`ifdef E203_HAS_MEM_ITF\n  .ifu2biu_icb_cmd_valid  (ifu2biu_icb_cmd_valid),\n  .ifu2biu_icb_cmd_ready  (ifu2biu_icb_cmd_ready),\n  .ifu2biu_icb_cmd_addr   (ifu2biu_icb_cmd_addr),\n  .ifu2biu_icb_rsp_valid  (ifu2biu_icb_rsp_valid),\n  .ifu2biu_icb_rsp_ready  (ifu2biu_icb_rsp_ready),\n  .ifu2biu_icb_rsp_err    (ifu2biu_icb_rsp_err),\n  .ifu2biu_icb_rsp_rdata  (ifu2biu_icb_rsp_rdata),\n`endif\n\n  .itcm_region_indic      (itcm_region_indic)\n);\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
