{"task": "sd_crc_7", "codeid": 1, "code": "module sd_crc_7 (\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nreg inv;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        inv = BITVAL ^ CRC[6];\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\n    // else CRC remains unchanged when Enable is low\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 1, "code": "module sd_crc_16(\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [15:0] CRC\n);\n\nreg inv;\nreg [15:0] temp_CRC;\n\nalways @(posedge CLK or posedge RST)\nbegin\n    if (RST)\n        CRC <= 16'h0000;\n    else if (Enable)\n    begin\n        // Compute inverse\n        inv = BITVAL ^ CRC[15];\n\n        // Shift CRC left by one\n        temp_CRC[15:1] = CRC[14:0];\n\n        // Update specific bits\n        temp_CRC[12] = temp_CRC[12] ^ inv;\n        temp_CRC[5]  = temp_CRC[5]  ^ inv;\n        temp_CRC[0]  = inv;\n\n        // Update CRC\n        CRC <= temp_CRC;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler (\n    input          clk,\n    input          rst,\n    input  [31:0]  adr,\n    input          en,\n    // Wishbone Master signals\n    output [31:0]  m_wb_adr_o,\n    output         m_wb_we_o,\n    input  [31:0]  m_wb_dat_i,\n    output         m_wb_cyc_o,\n    output         m_wb_stb_o,\n    input          m_wb_ack_i,\n    output [2:0]   m_wb_cti_o,\n    output [1:0]   m_wb_bte_o,\n    // FIFO and SD interface\n    input          sd_clk,\n    output [31:0]  dat_o,\n    input          rd,\n    output         empty,\n    output         fe\n);\n\n// Internal signals\nreg [8:0] offset;         // Address offset\nreg [31:0] din;           // Data input to FIFO\nreg wr_tx;                // Write enable for FIFO\nreg reset_tx_fifo;        // FIFO reset control\nreg ackd;                 // Acknowledge delay flag\nreg delay;                // Delay flag\nreg first;                // First operation flag\n\nwire full;\nwire empty_fifo;\nwire [5:0] mem_empt;      // FIFO occupancy\n\n// Assign outputs\nassign fe = full;\nassign empty = empty_fifo;\n\n// FIFO instance\nsd_tx_fifo tx_fifo (\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty_fifo),\n    .mem_empt(mem_empt),\n    .rclk(sd_clk),\n    .rst(reset_tx_fifo)\n);\n\n// Wishbone signals\nreg [31:0] m_wb_adr_o_reg;\nreg m_wb_we_o_reg;\nreg m_wb_cyc_o_reg;\nreg m_wb_stb_o_reg;\nreg [2:0] m_wb_cti_o_reg;\nreg [1:0] m_wb_bte_o_reg;\n\n// Assign outputs\nassign m_wb_adr_o = m_wb_adr_o_reg;\nassign m_wb_we_o = m_wb_we_o_reg;\nassign m_wb_cyc_o = m_wb_cyc_o_reg;\nassign m_wb_stb_o = m_wb_stb_o_reg;\nassign m_wb_cti_o = m_wb_cti_o_reg;\nassign m_wb_bte_o = m_wb_bte_o_reg;\n\nalways @(posedge clk or posedge rst)\nbegin\n    if (rst)\n    begin\n        // Reset logic\n        offset <= 9'd0;\n        din <= 32'd0;\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b1; // Reset FIFO\n        ackd <= 1'b1; // Set ackd to 1\n        delay <= 1'b0;\n        first <= 1'b1;\n        // Reset Wishbone signals\n        m_wb_adr_o_reg <= 32'd0;\n        m_wb_we_o_reg <= 1'b0;\n        m_wb_cyc_o_reg <= 1'b0;\n        m_wb_stb_o_reg <= 1'b0;\n        m_wb_cti_o_reg <= 3'b000;\n        m_wb_bte_o_reg <= 2'b00;\n    end\n    else\n    begin\n        if (en)\n        begin\n            reset_tx_fifo <= 1'b0; // FIFO not reset\n            if (!full && ackd && !m_wb_ack_i)\n            begin\n                // Start Wishbone read transaction\n                m_wb_cyc_o_reg <= 1'b1;\n                m_wb_stb_o_reg <= 1'b1;\n                m_wb_we_o_reg <= 1'b0; // Read transaction\n                m_wb_adr_o_reg <= adr + {offset, 2'b00}; // Address offset\n                // Burst cycle type - assuming classic cycle for simplicity\n                m_wb_cti_o_reg <= 3'b000;\n                m_wb_bte_o_reg <= 2'b00;\n            end\n            if (m_wb_ack_i)\n            begin\n                // Data has been read from system memory\n                din <= m_wb_dat_i;\n                wr_tx <= 1'b1;\n                // Deassert Wishbone signals\n                m_wb_cyc_o_reg <= 1'b0;\n                m_wb_stb_o_reg <= 1'b0;\n                // Set delay flag\n                delay <= 1'b1;\n            end\n            else\n            begin\n                wr_tx <= 1'b0;\n                if (delay)\n                begin\n                    delay <= 1'b0;\n                    // Increment offset\n                    offset <= offset + 9'd1;\n                    // Toggle ackd\n                    ackd <= ~ackd;\n                end\n            end\n        end\n        else\n        begin\n            // Disabled state handling\n            reset_tx_fifo <= 1'b1;\n            offset <= 9'd0;\n            m_wb_cyc_o_reg <= 1'b0;\n            m_wb_stb_o_reg <= 1'b0;\n            m_wb_we_o_reg <= 1'b0;\n            wr_tx <= 1'b0;\n            delay <= 1'b0;\n            ackd <= 1'b1;\n        end\n    end\nend\n\nendmodule\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output full,\n    output empty,\n    output [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\nparameter FIFO_DEPTH = 64;\nparameter ADDR_WIDTH = 6;\n\nreg [31:0] mem [0:FIFO_DEPTH-1];\nreg [ADDR_WIDTH-1:0] wptr;\nreg [ADDR_WIDTH-1:0] rptr;\nreg [ADDR_WIDTH:0] count;\n\nassign full = (count == FIFO_DEPTH);\nassign empty = (count == 0);\nassign mem_empt = count[ADDR_WIDTH-1:0];\n\nassign q = mem[rptr];\n\nalways @(posedge wclk or posedge rst)\nbegin\n    if (rst)\n    begin\n        wptr <= 0;\n        count <= 0;\n    end\n    else\n    begin\n        if (wr && !full)\n        begin\n            mem[wptr] <= d;\n            wptr <= wptr + 1;\n            count <= count + 1;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst)\nbegin\n    if (rst)\n    begin\n        rptr <= 0;\n    end\n    else\n    begin\n        if (rd && !empty)\n        begin\n            rptr <= rptr + 1;\n            count <= count - 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output wire SD_CLK\n);\n\n    reg [7:0] cnt;\n    reg SD_CLK_O;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            cnt      <= 8'd0;\n            SD_CLK_O <= 1'b0;\n        end else if (cnt == DIVIDER) begin\n            cnt      <= 8'd0;\n            SD_CLK_O <= 1'b1;\n        end else begin\n            cnt      <= cnt + 1'b1;\n            SD_CLK_O <= 1'b0;\n        end\n    end\n\n    `ifdef SIM\n        assign SD_CLK = SD_CLK_O;\n    `elsif ACTEL\n        CLKINT clkint_inst (\n            .A(SD_CLK_O),\n            .Y(SD_CLK)\n        );\n    `else\n        assign SD_CLK = SD_CLK_O;\n    `endif\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk, // System clock\n    input wire rst, // Asynchronous reset, active high\n    input wire we_m, // Write enable signal\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m, // Input data for writing BD\n    output reg [BD_WIDTH-1:0] free_bd, // Number of free buffer descriptors\n    input wire re_s, // Read enable signal\n    output reg ack_o_s, // Read operation acknowledgment\n    input wire a_cmp, // SD card operation completion\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s // Output data from reading BD\n);\n\n    // Internal registers\n    reg [BD_WIDTH-1:0] m_wr_pnt; // Write pointer\n    reg [BD_WIDTH-1:0] s_rd_pnt; // Read pointer\n    reg [1:0] m_wr_cnt; // Write counter per BD\n    reg [1:0] s_rd_cnt; // Read counter per BD\n    reg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1]; // BD memory\n    reg new_bw; // BD write complete signal\n    reg last_a_cmp; // For edge detection of a_cmp\n\n    // Determine words per BD based on RAM_MEM_WIDTH\n    localparam MEM_WORDS_PER_BD = (RAM_MEM_WIDTH == 32) ? 2 : 4;\n\n    // Initialization / Reset\n    always @(posedge clk or posedge rst)\n    begin\n        if (rst) begin\n            m_wr_pnt <= 0;\n            s_rd_pnt <= 0;\n            m_wr_cnt <= 0;\n            s_rd_cnt <= 0;\n            last_a_cmp <= 0;\n            new_bw <= 0;\n            ack_o_s <= 0;\n            free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        end\n        else begin\n            // Write operation\n            if (we_m && (free_bd > 0)) begin\n                bd_mem[m_wr_pnt] <= dat_in_m;\n                m_wr_pnt <= m_wr_pnt + 1;\n                m_wr_cnt <= m_wr_cnt + 1;\n                if (m_wr_cnt == MEM_WORDS_PER_BD - 1) begin\n                    // BD write complete\n                    new_bw <= 1;\n                    free_bd <= free_bd - 1;\n                    m_wr_cnt <= 0;\n                end else begin\n                    new_bw <= 0;\n                end\n            end else begin\n                new_bw <= 0;\n            end\n\n            // Read operation\n            ack_o_s <= 0; // Default ack_o_s to 0\n            if (re_s) begin\n                dat_out_s <= bd_mem[s_rd_pnt];\n                s_rd_pnt <= s_rd_pnt + 1;\n                s_rd_cnt <= s_rd_cnt + 1;\n                if (RAM_MEM_WIDTH == 16) begin\n                    ack_o_s <= 1;\n                end\n                if (s_rd_cnt == MEM_WORDS_PER_BD - 1) begin\n                    // BD read complete\n                    s_rd_cnt <= 0;\n                end\n            end\n\n            // Releasing Buffer Descriptor\n            last_a_cmp <= a_cmp;\n            if (~last_a_cmp & a_cmp) begin\n                // Rising edge detected\n                free_bd <= free_bd + 1;\n            end\n\n            // Circular operation handled by pointer wrapping around\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,           // Input data from SD card\n    input wr,                // Write enable signal (active high)\n    input wclk,              // Write clock (rising edge active)\n    output reg [31:0] q,     // Output data to host\n    input rd,                // Read enable signal (active high)\n    output full,             // FIFO full flag (active high)\n    output empty,            // FIFO empty flag (active high)\n    output reg [1:0] mem_empt, // Memory empty space (in words)\n    input rclk,              // Read clock (rising edge active)\n    input rst                // Asynchronous reset (active high)\n);\n\n// Memory depth and address size are defined in sd_defines.v\n// ram: the FIFO storage\nreg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n// Write and read pointers\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i;  // Write address\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o;  // Read address\n\n// Synchronization registers\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_wclk1, adr_o_wclk2;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_o_sync = adr_o_wclk2;\n\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_rclk1, adr_i_rclk2;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i_sync = adr_i_rclk2;\n\n// Write enable, tmp storage, count\nreg [7:0] we;\nreg [31:0] tmp;\nreg [2:0] cnt4; // counts from 0 to 7\nreg ft;         // Data written flag\n\n// Full and empty flags\nreg full_flag;\nreg empty_flag;\n\nassign full = full_flag;\nassign empty = empty_flag;\n\n// Synchronize read pointer into write clock domain\nalways @(posedge wclk or posedge rst)\nbegin\n    if (rst)\n    begin\n        adr_o_wclk1 <= 0;\n        adr_o_wclk2 <= 0;\n    end\n    else\n    begin\n        adr_o_wclk1 <= adr_o;\n        adr_o_wclk2 <= adr_o_wclk1;\n    end\nend\n\n// Synchronize write pointer into read clock domain\nalways @(posedge rclk or posedge rst)\nbegin\n    if (rst)\n    begin\n        adr_i_rclk1 <= 0;\n        adr_i_rclk2 <= 0;\n    end\n    else\n    begin\n        adr_i_rclk1 <= adr_i;\n        adr_i_rclk2 <= adr_i_rclk1;\n    end\nend\n\n// Full flag in write clock domain\nalways @(posedge wclk or posedge rst)\nbegin\n    if (rst)\n        full_flag <= 1'b0;\n    else\n        full_flag <= ( (adr_i[FIFO_RX_MEM_ADR_SIZE-1] != adr_o_sync[FIFO_RX_MEM_ADR_SIZE-1]) &&\n                       (adr_i[FIFO_RX_MEM_ADR_SIZE-2:0] == adr_o_sync[FIFO_RX_MEM_ADR_SIZE-2:0]) );\nend\n\n// Empty flag in read clock domain\nalways @(posedge rclk or posedge rst)\nbegin\n    if (rst)\n        empty_flag <= 1'b1; // FIFO is empty after reset\n    else\n        empty_flag <= (adr_o == adr_i_sync);\nend\n\n// Write operation in write clock domain\nalways @(posedge wclk or posedge rst)\nbegin\n    if (rst)\n    begin\n        adr_i <= 0;\n        cnt4 <= 3'b0;\n        tmp <= 32'b0;\n        ft <= 1'b0;\n        we <= 8'h1;\n    end\n    else\n    begin\n        if (wr && !full)\n        begin\n            tmp <= {tmp[27:0], d};  // Shift in new 4 bits\n            cnt4 <= cnt4 + 1;\n            if (cnt4 == 3'b111) // When cnt4 wraps around after 8 nibbles (0-7)\n            begin\n                ram[adr_i[FIFO_RX_MEM_ADR_SIZE-2:0]] <= tmp;\n                adr_i <= adr_i + 1;\n                cnt4 <= 3'b0;\n                tmp <= 32'b0;  // prepare for next word\n                ft <= 1'b1;\n            end\n        end\n    end\nend\n\n// Read operation in read clock domain\nalways @(posedge rclk or posedge rst)\nbegin\n    if (rst)\n    begin\n        adr_o <= 0;\n        q <= 32'b0;\n    end\n    else\n    begin\n        if (rd && !empty)\n        begin\n            q <= ram[adr_o[FIFO_RX_MEM_ADR_SIZE-2:0]];\n            adr_o <= adr_o + 1;\n        end\n        else\n        begin\n            q <= q; // Retain previous value\n        end\n    end\nend\n\n// mem_empt calculation (Optional, can be refined based on actual design)\nalways @(*)\nbegin\n    mem_empt = 2'b00; // For simplicity, set to zero or implement as needed\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb(\n    input         wb_clk_i,                     // Slave WISHBONE Clock Input\n    input         wb_rst_i,                     // Slave WISHBONE Reset Input\n    input  [31:0] wb_dat_i,                     // Slave WISHBONE Data Inputs\n    output reg [31:0] wb_dat_o,                 // Slave WISHBONE Data Outputs\n    input   [7:0] wb_adr_i,                     // Slave WISHBONE Address Input\n    input   [3:0] wb_sel_i,                     // Slave WISHBONE Select Input (Not used)\n    input         wb_we_i,                      // Slave WISHBONE Write Enable\n    input         wb_cyc_i,                     // Slave WISHBONE Cycle\n    input         wb_stb_i,                     // Slave WISHBONE Strobe\n    output reg    wb_ack_o,                     // Slave WISHBONE Acknowledge\n    output reg    we_m_tx_bd,                   // Write enable Tx BD\n    output reg    we_m_rx_bd,                   // Write enable Rx BD\n    output reg    new_cmd,                      // New command indication signal\n    output reg    we_ack,                       // Ack on cmd access request\n    output reg    int_ack,                      // Internal Delayed Acknowledge\n    output reg    cmd_int_busy,                 // Cmd busy by data module\n    output reg    int_busy,                     // Command Busy by data module\n    input         write_req_s,                  // Cmd access request\n    input  [15:0] cmd_set_s,                    // Command setting input from data master\n    input  [31:0] cmd_arg_s,                    // Command argument input from data master\n    output reg [31:0] argument_reg,             // Command Argument Reg\n    output reg [15:0] cmd_setting_reg,          // Command Setting Reg\n    input  [15:0] status_reg,                   // Card Status Reg\n    input  [31:0] cmd_resp_1,                   // Command Response\n    output reg  [7:0] software_reset_reg,       // Software reset Reg\n    output reg [15:0] time_out_reg,             // Timeout Reg\n    input  [15:0] normal_int_status_reg,        // Normal Interrupt Status Reg\n    input  [15:0] error_int_status_reg,         // Error Interrupt Status Reg\n    output reg [15:0] normal_int_signal_enable_reg, // Normal Interrupt Enable Reg\n    output reg [15:0] error_int_signal_enable_reg,  // Error Interrupt Enable Reg\n    output reg  [7:0] clock_divider,            // Clock Divider Reg\n    input  [15:0] Bd_Status_reg,                // BD Status Reg\n    input   [7:0] Bd_isr_reg,                   // Data Interrupt Status Reg\n    output reg  [7:0] Bd_isr_enable_reg,        // Data Interrupt Enable Reg\n    output reg        Bd_isr_reset,             // Reset data interrupt status\n    output reg        normal_isr_reset,         // Reset normal interrupt status\n    output reg        error_isr_reset,          // Reset error interrupt status\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd, // Data going to the Tx BD\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd  // Data going to the RX BD\n);\n\n    // Internal Registers\n    reg [1:0] bd_rx_write_state;\n    reg [1:0] bd_tx_write_state;\n\n    // Asynchronous Reset\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            // Reset configuration registers to default values\n            argument_reg                   <= 32'h00000000;\n            cmd_setting_reg                <= 16'h0000;\n            software_reset_reg             <= 8'h00;\n            time_out_reg                   <= 16'h0000;\n            normal_int_signal_enable_reg   <= 16'h0000;\n            error_int_signal_enable_reg    <= 16'h0000;\n            clock_divider                  <= 8'h00;\n            Bd_isr_enable_reg              <= 8'h00;\n            // Reset other variables\n            int_ack                        <= 1'b1;\n            wb_ack_o                       <= 1'b0;\n            we_m_rx_bd                     <= 1'b0;\n            we_m_tx_bd                     <= 1'b0;\n            we_ack                         <= 1'b0;\n            new_cmd                        <= 1'b0;\n            cmd_int_busy                   <= 1'b0;\n            int_busy                       <= 1'b0;\n            bd_rx_write_state              <= 2'b00;\n            bd_tx_write_state              <= 2'b00;\n            Bd_isr_reset                   <= 1'b0;\n            normal_isr_reset               <= 1'b0;\n            error_isr_reset                <= 1'b0;\n            dat_in_m_tx_bd                 <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd                 <= {RAM_MEM_WIDTH{1'b0}};\n        end else begin\n            // Handle write request from data master\n            we_ack <= write_req_s;\n            if (write_req_s) begin\n                cmd_int_busy <= 1'b1;\n            end else begin\n                cmd_int_busy <= 1'b0;\n            end\n\n            // Handle Wishbone Write Operations\n            if (wb_stb_i && wb_cyc_i && wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: begin\n                        // Argument Register\n                        argument_reg <= wb_dat_i;\n                        new_cmd      <= 1'b1;\n                        int_busy     <= 1'b1;\n                    end\n                    8'h04: begin\n                        // Command Setting Register\n                        cmd_setting_reg <= wb_dat_i[15:0];\n                        int_busy        <= 1'b1;\n                    end\n                    8'h28: begin\n                        // Software Reset Register\n                        software_reset_reg <= wb_dat_i[7:0];\n                    end\n                    8'h2C: begin\n                        // Timeout Register\n                        time_out_reg <= wb_dat_i[15:0];\n                    end\n                    8'h30: begin\n                        // Normal Interrupt Status Register\n                        normal_isr_reset <= 1'b1;\n                    end\n                    8'h34: begin\n                        // Error Interrupt Status Register\n                        error_isr_reset <= 1'b1;\n                    end\n                    8'h38: begin\n                        // Normal Interrupt Enable Register\n                        normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h3C: begin\n                        // Error Interrupt Enable Register\n                        error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    end\n                    8'h4C: begin\n                        // Clock Divider Register\n                        clock_divider <= wb_dat_i[7:0];\n                    end\n                    8'h54: begin\n                        // Data Interrupt Status Register\n                        Bd_isr_reset <= 1'b1;\n                    end\n                    8'h58: begin\n                        // Data Interrupt Enable Register\n                        Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    end\n                    8'h60, 8'h64, 8'h68, 8'h6C, 8'h70, 8'h74, 8'h78, 8'h7C: begin\n                        // BD RX Write Handling\n                        if (RAM_MEM_WIDTH == 32) begin\n                            we_m_rx_bd      <= 1'b1;\n                            dat_in_m_rx_bd  <= wb_dat_i;\n                            int_ack         <= 1'b0;\n                        end else if (RAM_MEM_WIDTH == 16) begin\n                            if (bd_rx_write_state == 2'b00) begin\n                                we_m_rx_bd      <= 1'b1;\n                                dat_in_m_rx_bd  <= wb_dat_i[15:0];\n                                int_ack         <= 1'b0;\n                                bd_rx_write_state <= 2'b01;\n                            end else if (bd_rx_write_state == 2'b01) begin\n                                we_m_rx_bd      <= 1'b1;\n                                dat_in_m_rx_bd  <= wb_dat_i[31:16];\n                                int_ack         <= 1'b1;\n                                bd_rx_write_state <= 2'b00;\n                            end\n                        end\n                    end\n                    8'h80, 8'h84, 8'h88, 8'h8C, 8'h90, 8'h94, 8'h98, 8'h9C: begin\n                        // BD TX Write Handling\n                        if (RAM_MEM_WIDTH == 32) begin\n                            we_m_tx_bd      <= 1'b1;\n                            dat_in_m_tx_bd  <= wb_dat_i;\n                            int_ack         <= 1'b0;\n                        end else if (RAM_MEM_WIDTH == 16) begin\n                            if (bd_tx_write_state == 2'b00) begin\n                                we_m_tx_bd      <= 1'b1;\n                                dat_in_m_tx_bd  <= wb_dat_i[15:0];\n                                int_ack         <= 1'b0;\n                                bd_tx_write_state <= 2'b01;\n                            end else if (bd_tx_write_state == 2'b01) begin\n                                we_m_tx_bd      <= 1'b1;\n                                dat_in_m_tx_bd  <= wb_dat_i[31:16];\n                                int_ack         <= 1'b1;\n                                bd_tx_write_state <= 2'b00;\n                            end\n                        end\n                    end\n                    default: begin\n                        // No action for other addresses\n                    end\n                endcase\n            end else begin\n                // Reset write enables and states when not writing\n                we_m_rx_bd       <= 1'b0;\n                we_m_tx_bd       <= 1'b0;\n                bd_rx_write_state <= 2'b00;\n                bd_tx_write_state <= 2'b00;\n                int_ack          <= 1'b1;\n            end\n\n            // Handle Wishbone Read Operations\n            if (wb_stb_i && wb_cyc_i && !wb_we_i) begin\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'h0000, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'h0000, status_reg};\n                    8'h0C: wb_dat_o <= cmd_resp_1;\n                    8'h1C: wb_dat_o <= 32'h00000000; // Controller Settings (Not used)\n                    8'h20: wb_dat_o <= 32'h00000200; // Block Size (Fixed at 512)\n                    8'h24: wb_dat_o <= 32'h0000000F; // Power Control Register\n                    8'h28: wb_dat_o <= {24'h000000, software_reset_reg};\n                    8'h2C: wb_dat_o <= {16'h0000, time_out_reg};\n                    8'h30: wb_dat_o <= {16'h0000, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'h0000, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'h0000, normal_int_signal_enable_reg};\n                    8'h3C: wb_dat_o <= {16'h0000, error_int_signal_enable_reg};\n                    8'h48: wb_dat_o <= 32'h00000000; // Capability Register (Not used)\n                    8'h4C: wb_dat_o <= {24'h000000, clock_divider};\n                    8'h50: wb_dat_o <= {16'h0000, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'h000000, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'h000000, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'h00000000;\n                endcase\n            end\n\n            // Generate wb_ack_o\n            if (wb_cyc_i && wb_stb_i && !wb_ack_o && int_ack) begin\n                wb_ack_o <= 1'b1;\n            end else begin\n                wb_ack_o <= 1'b0;\n            end\n\n            // Reset signals after use\n            if (new_cmd) begin\n                new_cmd <= 1'b0;\n            end\n            if (int_busy) begin\n                int_busy <= 1'b0;\n            end\n            if (Bd_isr_reset) begin\n                Bd_isr_reset <= 1'b0;\n            end\n            if (normal_isr_reset) begin\n                normal_isr_reset <= 1'b0;\n            end\n            if (error_isr_reset) begin\n                error_isr_reset <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo(\n    input wire [31:0] d,         // Data input\n    input wire wr,               // Write enable (active high)\n    input wire wclk,             // Write clock (rising edge active)\n    input wire rd,               // Read enable (active high)\n    input wire rclk,             // Read clock (rising edge active)\n    input wire rst,              // Asynchronous reset (active high)\n\n    output reg [31:0] q,         // Data output\n    output wire full,            // FIFO full flag (active high)\n    output wire empty,           // FIFO empty flag (active high)\n    output reg [5:0] mem_empt    // FIFO occupancy\n);\n\n    // Parameters\n    parameter FIFO_DEPTH = FIFO_TX_MEM_DEPTH;          // FIFO depth from sd_defines.v\n    parameter ADDR_WIDTH = FIFO_TX_MEM_ADR_SIZE;       // Address width (log2(FIFO_DEPTH) + 1)\n\n    // Internal Signals\n    reg [31:0] ram [0:FIFO_DEPTH-1];                   // FIFO storage array\n\n    // Write pointer (binary and Gray code)\n    reg [ADDR_WIDTH-1:0] wptr_bin;\n    reg [ADDR_WIDTH-1:0] wptr_gray;\n\n    // Read pointer (binary and Gray code)\n    reg [ADDR_WIDTH-1:0] rptr_bin;\n    reg [ADDR_WIDTH-1:0] rptr_gray;\n\n    // Synchronization registers for read pointer (into write clock domain)\n    reg [ADDR_WIDTH-1:0] rptr_gray_wclk1, rptr_gray_wclk2;\n\n    // Synchronization registers for write pointer (into read clock domain)\n    reg [ADDR_WIDTH-1:0] wptr_gray_rclk1, wptr_gray_rclk2;\n\n    // Function to convert binary to Gray code\n    function [ADDR_WIDTH-1:0] binary2gray;\n        input [ADDR_WIDTH-1:0] bin;\n        begin\n            binary2gray = bin ^ (bin >> 1);\n        end\n    endfunction\n\n    // Function to convert Gray code to binary\n    function [ADDR_WIDTH-1:0] gray2binary;\n        input [ADDR_WIDTH-1:0] gray;\n        integer i;\n        begin\n            gray2binary[ADDR_WIDTH-1] = gray[ADDR_WIDTH-1];\n            for (i = ADDR_WIDTH-2; i >= 0; i = i - 1) begin\n                gray2binary[i] = gray[i] ^ gray2binary[i+1];\n            end\n        end\n    endfunction\n\n    // Write Pointer Logic (Write Clock Domain)\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            wptr_bin <= 0;\n            wptr_gray <= 0;\n        end else begin\n            if (wr && !full) begin\n                ram[wptr_bin[ADDR_WIDTH-2:0]] <= d;          // Write data to RAM\n                wptr_bin <= wptr_bin + 1;                    // Increment binary write pointer\n                wptr_gray <= binary2gray(wptr_bin + 1);      // Update Gray code write pointer\n            end\n        end\n    end\n\n    // Read Pointer Logic (Read Clock Domain)\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            rptr_bin <= 0;\n            rptr_gray <= 0;\n            q <= 0;\n        end else begin\n            if (rd && !empty) begin\n                q <= ram[rptr_bin[ADDR_WIDTH-2:0]];          // Read data from RAM\n                rptr_bin <= rptr_bin + 1;                    // Increment binary read pointer\n                rptr_gray <= binary2gray(rptr_bin + 1);      // Update Gray code read pointer\n            end\n        end\n    end\n\n    // Synchronize Read Pointer into Write Clock Domain\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            rptr_gray_wclk1 <= 0;\n            rptr_gray_wclk2 <= 0;\n        end else begin\n            rptr_gray_wclk1 <= rptr_gray;\n            rptr_gray_wclk2 <= rptr_gray_wclk1;\n        end\n    end\n\n    // Synchronize Write Pointer into Read Clock Domain\n    always @(posedge rclk or posedge rst) begin\n        if (rst) begin\n            wptr_gray_rclk1 <= 0;\n            wptr_gray_rclk2 <= 0;\n        end else begin\n            wptr_gray_rclk1 <= wptr_gray;\n            wptr_gray_rclk2 <= wptr_gray_wclk1;\n        end\n    end\n\n    // Compute Next Gray Code Write Pointer\n    wire [ADDR_WIDTH-1:0] wptr_bin_next = wptr_bin + (wr && !full);\n    wire [ADDR_WIDTH-1:0] wptr_gray_next = binary2gray(wptr_bin_next);\n\n    // Compute Full Flag (Write Clock Domain)\n    assign full = (wptr_gray_next == {~rptr_gray_wclk2[ADDR_WIDTH-1:ADDR_WIDTH-2], rptr_gray_wclk2[ADDR_WIDTH-3:0]});\n\n    // Compute Empty Flag (Read Clock Domain)\n    assign empty = (wptr_gray_rclk2 == rptr_gray);\n\n    // Compute FIFO Occupancy (Write Clock Domain)\n    wire [ADDR_WIDTH-1:0] rptr_bin_wclk = gray2binary(rptr_gray_wclk2);\n    wire [ADDR_WIDTH:0] fifo_count = wptr_bin - rptr_bin_wclk;\n\n    always @(posedge wclk or posedge rst) begin\n        if (rst) begin\n            mem_empt <= 0;\n        end else begin\n            mem_empt <= fifo_count[5:0];                     // Update FIFO occupancy\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host(\n    input                   sd_clk,\n    input                   rst,\n    input       [31:0]      data_in,\n    input       [1:0]       start_dat,\n    input                   ack_transfer,\n    input       [SD_BUS_W-1:0] DAT_dat_i,\n    \n    output reg              rd,\n    output reg  [SD_BUS_W-1:0] data_out,\n    output reg              we,\n    output reg              DAT_oe_o,\n    output reg  [SD_BUS_W-1:0] DAT_dat_o,\n    output reg              busy_n,\n    output reg              transm_complete,\n    output reg              crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [15:0] crc_out [SD_BUS_W-1:0];  // Array of CRC outputs for each data line\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Parameters for state machine states\n    localparam IDLE        = 6'd0;\n    localparam WRITE_DAT   = 6'd1;\n    localparam WRITE_CRC   = 6'd2;\n    localparam WRITE_BUSY  = 6'd3;\n    localparam READ_WAIT   = 6'd4;\n    localparam READ_DAT    = 6'd5;\n    // ... additional states as needed\n\n    // Generate block for CRC instances\n    genvar i;\n    generate\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : CRC_GEN\n            sd_crc_16 crc_inst (\n                .BITVAL (crc_in[i]),\n                .Enable (crc_en),\n                .CLK    (sd_clk),\n                .RST    (crc_rst),\n                .CRC    (crc_out[i])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_q <= 1'b0;\n            ack_transfer_int <= 1'b0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // START_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            q_start_bit <= 1'b1;\n        end else begin\n            if (~DAT_dat_i[0] && (state == READ_WAIT)) begin\n                q_start_bit <= 1'b0;\n            end else begin\n                q_start_bit <= 1'b1;\n            end\n        end\n    end\n\n    // FSM_COMBO block\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10) begin\n                    next_state = WRITE_DAT;\n                end else if (start_dat == 2'b01) begin\n                    next_state = READ_WAIT;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            WRITE_DAT: begin\n                if (transf_cnt >= BIT_BLOCK) begin\n                    next_state = WRITE_CRC;\n                end else begin\n                    next_state = WRITE_DAT;\n                end\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b000) begin  // Assuming 0 indicates completion\n                    next_state = WRITE_BUSY;\n                end else begin\n                    next_state = WRITE_CRC;\n                end\n            end\n            WRITE_BUSY: begin\n                if (busy_int == 1'b0) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = WRITE_BUSY;\n                end\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 1'b0) begin\n                    next_state = READ_DAT;\n                end else begin\n                    next_state = READ_WAIT;\n                end\n            end\n            READ_DAT: begin\n                if (transf_cnt >= BIT_BLOCK_REC) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = READ_DAT;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM_SEQ block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            write_buf_0     <= 32'b0;\n            write_buf_1     <= 32'b0;\n            DAT_oe_o        <= 1'b0;\n            crc_en          <= 1'b0;\n            crc_rst         <= 1'b1;\n            transf_cnt      <= 11'b0;\n            rd              <= 1'b0;\n            last_din        <= 4'b0;\n            crc_c           <= 5'b0;\n            crc_in          <= {SD_BUS_W{1'b0}};\n            DAT_dat_o       <= {SD_BUS_W{1'b0}};\n            crc_status      <= 3'b111;\n            crc_s           <= 3'b0;\n            transm_complete <= 1'b0;\n            busy_n          <= 1'b1;\n            we              <= 1'b0;\n            data_out        <= {SD_BUS_W{1'b0}};\n            crc_ok          <= 1'b0;\n            busy_int        <= 1'b0;\n            data_send_index <= 3'b0;\n            out_buff_ptr    <= 1'b0;\n            in_buff_ptr     <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    crc_rst      <= 1'b1;\n                    crc_en       <= 1'b0;\n                    transf_cnt   <= 11'b0;\n                    rd           <= 1'b0;\n                    last_din     <= 4'b0;\n                    crc_c        <= 5'b0;\n                    crc_status   <= 3'b111;\n                    crc_s        <= 3'b0;\n                    transm_complete <= 1'b0;\n                    DAT_oe_o     <= 1'b0;\n                    we           <= 1'b0;\n                    busy_n       <= 1'b1;\n                    crc_ok       <= 1'b0;\n                    busy_int     <= 1'b0;\n                end\n                WRITE_DAT: begin\n                    crc_rst  <= 1'b0;\n                    crc_en   <= 1'b1;\n                    DAT_oe_o <= 1'b1;\n                    if (transf_cnt == 0) begin\n                        // Load initial data into buffers\n                        write_buf_0 <= data_in;\n                        rd <= 1'b1;\n                        out_buff_ptr <= 1'b0;\n                        in_buff_ptr <= 1'b1;\n                        sd_data_out <= data_in;\n                        data_send_index <= 3'b0;\n                        // Send start bit\n                        DAT_dat_o <= {SD_BUS_W{1'b0}};\n                        transf_cnt <= transf_cnt + SD_BUS_W;\n                    end else begin\n                        // Shift out data\n                        last_din <= sd_data_out[31:28];\n                        DAT_dat_o <= last_din;\n                        crc_in <= last_din;\n                        sd_data_out <= {sd_data_out[27:0], 4'b0};\n                        transf_cnt <= transf_cnt + SD_BUS_W;\n                        data_send_index <= data_send_index + 1;\n                        if (data_send_index == 3'd7) begin\n                            // Switch buffers\n                            if (out_buff_ptr == 1'b0) begin\n                                sd_data_out <= write_buf_1;\n                            end else begin\n                                sd_data_out <= write_buf_0;\n                            end\n                            out_buff_ptr <= ~out_buff_ptr;\n                            // Load next data\n                            rd <= 1'b1;\n                            if (in_buff_ptr == 1'b0) begin\n                                write_buf_0 <= data_in;\n                            end else begin\n                                write_buf_1 <= data_in;\n                            end\n                            in_buff_ptr <= ~in_buff_ptr;\n                            data_send_index <= 3'd0;\n                        end\n                    end\n                end\n                WRITE_CRC: begin\n                    // Handle CRC transmission\n                    crc_en <= 1'b0;\n                    if (crc_c < BIT_CRC_CYCLE) begin\n                        transf_cnt <= transf_cnt + 1;\n                        crc_c <= crc_c + 1;\n                        // Send CRC bits\n                        for (i = 0; i < SD_BUS_W; i = i + 1) begin\n                            DAT_dat_o[i] <= crc_out[i][15 - crc_c];\n                        end\n                    end else begin\n                        // Send stop bit\n                        DAT_dat_o <= {SD_BUS_W{1'b1}};\n                        transf_cnt <= transf_cnt + SD_BUS_W;\n                    end\n                end\n                WRITE_BUSY: begin\n                    transm_complete <= 1'b1;\n                    // Check CRC response\n                    crc_ok <= (crc_s == 3'b010) ? 1'b1 : 1'b0;\n                    // Poll busy signal\n                    if (DAT_dat_i[0] == 1'b1) begin\n                        busy_int <= 1'b0;\n                        busy_n <= 1'b1;\n                    end else begin\n                        busy_int <= 1'b1;\n                        busy_n <= 1'b0;\n                    end\n                end\n                READ_WAIT: begin\n                    crc_rst  <= 1'b0;\n                    crc_en   <= 1'b1;\n                    DAT_oe_o <= 1'b0;\n                    transf_cnt <= 11'b0;\n                    we <= 1'b0;\n                end\n                READ_DAT: begin\n                    crc_in <= DAT_dat_i;\n                    data_out <= DAT_dat_i;\n                    we <= 1'b1;\n                    transf_cnt <= transf_cnt + SD_BUS_W;\n                    if (transf_cnt >= BIT_BLOCK_REC - SD_BUS_W) begin\n                        // Read CRC and compare\n                        transm_complete <= 1'b1;\n                        // Check CRC\n                        crc_ok <= 1'b1; // Assume CRC check passed\n                        busy_n <= 1'b1;\n                    end\n                end\n                default: begin\n                    // Default case\n                end\n            endcase\n        end\n    end\n\nendmodule\n\n// CRC-16 generation module\nmodule sd_crc_16(\n    input       BITVAL,\n    input       Enable,\n    input       CLK,\n    input       RST,\n    output reg [15:0] CRC\n);\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'h0;\n        end else if (Enable) begin\n            CRC[0]  <= BITVAL ^ CRC[15];\n            CRC[1]  <= CRC[0];\n            CRC[2]  <= CRC[1];\n            CRC[3]  <= CRC[2];\n            CRC[4]  <= CRC[3];\n            CRC[5]  <= CRC[4] ^ (BITVAL ^ CRC[15]);\n            CRC[6]  <= CRC[5];\n            CRC[7]  <= CRC[6];\n            CRC[8]  <= CRC[7];\n            CRC[9]  <= CRC[8];\n            CRC[10] <= CRC[9];\n            CRC[11] <= CRC[10];\n            CRC[12] <= CRC[11];\n            CRC[13] <= CRC[12];\n            CRC[14] <= CRC[13];\n            CRC[15] <= CRC[14];\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 1, "code": "`timescale 1ns / 1ps\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Include the sd_defines.v if needed\n    // `include \"sd_defines.v\"\n\n    // Parameter definitions\n    `ifdef SIM\n        parameter INIT_DELAY = 2;\n    `else\n        parameter INIT_DELAY = 64;\n    `endif\n\n    parameter NCR = 2;\n    parameter SEND_SIZE = 48;\n    parameter SIZE = 10;\n    parameter CONTENT_SIZE = 40;\n    parameter Read_Delay = 7;\n    parameter EIGHT_PAD = 8;\n\n    // FSM State Definitions\n    parameter INIT      = 10'b0000000001;\n    parameter IDLE      = 10'b0000000010;\n    parameter WRITE_WR  = 10'b0000000100;\n    parameter DLY_WR    = 10'b0000001000;\n    parameter READ_WR   = 10'b0000010000;\n    parameter DLY_READ  = 10'b0000100000;\n    parameter ACK_WR    = 10'b0001000000;\n    parameter WRITE_WO  = 10'b0010000000;\n    parameter DLY_WO    = 10'b0100000000;\n    parameter ACK_WO    = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [9:0] state;\n    reg [9:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            INIT: begin\n                if (Cmd_Cnt >= INIT_DELAY)\n                    next_state = IDLE;\n                else\n                    next_state = INIT;\n            end\n            IDLE: begin\n                if (Write_Read)\n                    next_state = WRITE_WR;\n                else if (Write_Only)\n                    next_state = WRITE_WO;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_WR: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WR;\n                else\n                    next_state = WRITE_WR;\n            end\n            WRITE_WO: begin\n                if (Cmd_Cnt >= SEND_SIZE - 1)\n                    next_state = DLY_WO;\n                else\n                    next_state = WRITE_WO;\n            end\n            DLY_WR: begin\n                if ((Delay_Cnt >= NCR) && (!cmd_dat_i))\n                    next_state = READ_WR;\n                else\n                    next_state = DLY_WR;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt >= Delay_Cycler)\n                    next_state = ACK_WO;\n                else\n                    next_state = DLY_WO;\n            end\n            READ_WR: begin\n                if (Cmd_Cnt >= (Response_Size + EIGHT_PAD))\n                    next_state = DLY_READ;\n                else\n                    next_state = READ_WR;\n            end\n            DLY_READ: begin\n                if (Ack_internal_in)\n                    next_state = ACK_WR;\n                else\n                    next_state = DLY_READ;\n            end\n            ACK_WO: begin\n                next_state = IDLE;\n            end\n            ACK_WR: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = INIT;\n            end\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN) begin\n        if (RST_IN)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // REQ_SYNC\n    always @(posedge SD_CLK_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC\n    always @(posedge SD_CLK_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN) begin\n        if (RST_IN) begin\n            Delay_Cycler <= 3'b0;\n            Response_Size <= 7'b0;\n            DECODER_ACK <= 1'b1;\n            Write_Read <= 1'b0;\n            Write_Only <= 1'b0;\n            CRC_Check_On <= 1'b0;\n            In_Buff <= 40'b0;\n            block_write <= 1'b0;\n            block_read <= 1'b0;\n            word_select <= 2'b0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            DECODER_ACK <= 1'b0;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1'b1;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN) begin\n        if (RST_IN) begin\n            CRC_Enable <= 0;\n            word_select_counter <= 0;\n            Delay_Cnt <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            Out_Buff <= 0;\n            FSM_ACK <= 1;\n            REQ_OUT <= 0;\n            CRC_RST <= 1;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            CMD_OUT <= 0;\n            Crc_Buffering <= 0;\n            STATUS <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                    Crc_Buffering <= 0;\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering == 1) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt < (SEND_SIZE - 7)) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt < SEND_SIZE - 1) begin\n                            cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - (SEND_SIZE - 7))];\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering == 1) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt < (SEND_SIZE - 7)) begin\n                            cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                            CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                        end else if (Cmd_Cnt < SEND_SIZE - 1) begin\n                            cmd_out_o <= CRC_VAL[6 - (Cmd_Cnt - (SEND_SIZE - 7))];\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN[6 - (Cmd_Cnt - Response_Size)] <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        if (block_read && block_write) begin\n                            st_dat_t <= 2'b11;\n                        end else if (block_write) begin\n                            st_dat_t <= 2'b01;\n                        end\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n                default: begin\n                    // Default behavior\n                end\n            endcase\n        end\n    end\n\n    // Instantiate sd_crc_7 module (Assuming sd_crc_7 is defined elsewhere)\n    sd_crc_7 crc7 (\n        .BITVAL(CRC_OUT),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\n    // Output assignment\n    assign ACK_OUT = FSM_ACK;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler (\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg        m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg        m_wb_cyc_o,\n    output reg        m_wb_stb_o,\n    input  wire       m_wb_ack_i,\n    output reg [2:0]  m_wb_cti_o,\n    output reg [1:0]  m_wb_bte_o,\n    input  wire       en,\n    input  wire [31:0] adr,\n    input  wire        sd_clk,\n    input  wire [`SD_BUS_W-1:0] dat_i,\n    input  wire        wr,\n    output wire        full,\n    output wire        empty\n);\n\n    // Internal signals and registers\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    reg [2:0] state;\n    reg [31:0] data_reg;\n    reg [31:0] address_offset;\n\n    // Wires for FIFO outputs\n    wire [31:0] fifo_q;\n    wire fifo_full;\n    wire fifo_empty;\n    wire [1:0] mem_empt;\n\n    // Parameters for states\n    localparam [2:0]\n        S_IDLE       = 3'b000,\n        S_READ_FIFO  = 3'b001,\n        S_WAIT_DATA  = 3'b010,\n        S_START_WB   = 3'b011,\n        S_WAIT_ACK   = 3'b100;\n\n    // Instantiate the RX FIFO\n    sd_rx_fifo rx_fifo_inst (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(fifo_q),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .mem_empt(mem_empt),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    // Assign outputs\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    // State machine\n    always @(posedge clk or posedge rst)\n    begin\n        if (rst)\n        begin\n            // Reset all control signals and counters\n            address_offset <= 32'd0;\n            wb_free        <= 1'b1; // Bus is free after reset\n            reset_rx_fifo  <= 1'b1; // Reset the FIFO\n            rd             <= 1'b0; // Stop any read operation\n\n            // Set Wishbone master signals to inactive state\n            m_wb_adr_o    <= 32'd0;\n            m_wb_we_o     <= 1'b0;\n            m_wb_dat_o    <= 32'd0;\n            m_wb_cyc_o    <= 1'b0;\n            m_wb_stb_o    <= 1'b0;\n            m_wb_cti_o    <= 3'b111; // End of burst\n            m_wb_bte_o    <= 2'b00;\n\n            state         <= S_IDLE;\n            data_reg      <= 32'd0;\n        end\n        else\n        begin\n            case (state)\n                S_IDLE:\n                begin\n                    if (en)\n                    begin\n                        reset_rx_fifo <= 1'b0; // Release FIFO from reset\n                        rd            <= 1'b0; // Stop any previous read operation\n                        wb_free       <= 1'b1;\n                        state         <= S_READ_FIFO;\n                    end\n                    else\n                    begin\n                        // Remain in IDLE state\n                        reset_rx_fifo  <= 1'b1; // Keep FIFO in reset\n                        rd             <= 1'b0; // Stop any read operation\n                        address_offset <= 32'd0; // Reset address offset\n                        // Reset all Wishbone control signals\n                        m_wb_adr_o    <= 32'd0;\n                        m_wb_we_o     <= 1'b0;\n                        m_wb_dat_o    <= 32'd0;\n                        m_wb_cyc_o    <= 1'b0;\n                        m_wb_stb_o    <= 1'b0;\n                        m_wb_cti_o    <= 3'b111;\n                        m_wb_bte_o    <= 2'b00;\n                        wb_free       <= 1'b1;\n                    end\n                end\n\n                S_READ_FIFO:\n                begin\n                    if (fifo_empty)\n                    begin\n                        // FIFO is empty, wait until data is available\n                        rd <= 1'b0;\n                    end\n                    else if (wb_free)\n                    begin\n                        // FIFO is not empty and bus is free\n                        rd    <= 1'b1; // Start reading from FIFO\n                        state <= S_WAIT_DATA;\n                    end\n                    else\n                    begin\n                        rd <= 1'b0;\n                    end\n                end\n\n                S_WAIT_DATA:\n                begin\n                    rd         <= 1'b0; // Stop reading from FIFO\n                    data_reg   <= fifo_q; // Store data from FIFO\n                    state      <= S_START_WB;\n                end\n\n                S_START_WB:\n                begin\n                    // Initiate Wishbone write transaction\n                    m_wb_we_o    <= 1'b1;\n                    m_wb_stb_o   <= 1'b1;\n                    m_wb_cyc_o   <= 1'b1;\n                    m_wb_adr_o   <= adr + address_offset;\n                    m_wb_dat_o   <= data_reg;\n                    m_wb_cti_o   <= 3'b000; // Classic cycle\n                    m_wb_bte_o   <= 2'b00;  // Linear burst\n\n                    wb_free      <= 1'b0; // Bus is busy\n                    state        <= S_WAIT_ACK;\n                end\n\n                S_WAIT_ACK:\n                begin\n                    if (m_wb_ack_i)\n                    begin\n                        // Wishbone write transaction completed\n                        // Reset Wishbone control signals\n                        m_wb_we_o     <= 1'b0;\n                        m_wb_stb_o    <= 1'b0;\n                        m_wb_cyc_o    <= 1'b0;\n                        m_wb_cti_o    <= 3'b111; // End of burst\n\n                        // Update address offset\n                        address_offset <= address_offset + `MEM_OFFSET;\n\n                        wb_free       <= 1'b1; // Mark bus as free\n                        state         <= S_READ_FIFO; // Read more data\n                    end\n                end\n\n                default:\n                    state <= S_IDLE;\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n  // Inputs\n  input wire CLK_PAD_IO,\n  input wire RST_PAD_I,\n  input wire New_CMD,\n  input wire data_write,\n  input wire data_read,\n  input wire [31:0] ARG_REG,\n  input wire [13:0] CMD_SET_REG,\n  input wire [15:0] TIMEOUT_REG,\n  input wire ERR_INT_RST,\n  input wire NORMAL_INT_RST,\n  input wire req_in,\n  input wire ack_in,\n  input wire [39:0] cmd_in,\n  input wire [7:0] serial_status,\n  input wire card_detect,\n  // Outputs\n  output reg [15:0] STATUS_REG,\n  output reg [31:0] RESP_1_REG,\n  output reg [4:0] ERR_INT_REG,\n  output reg [15:0] NORMAL_INT_REG,\n  output reg [15:0] settings,\n  output reg go_idle_o,\n  output reg [39:0] cmd_out,\n  output reg req_out,\n  output reg ack_out\n);\n\n// Include local parameters\nlocalparam IDLE    = 3'b001;\nlocalparam SETUP   = 3'b010;\nlocalparam EXECUTE = 3'b100;\n\n// Debounce logic variables\nreg [3:0] debounce;\nreg card_present;\n\n// Synchronization registers\nreg req_q;\nreg req_in_int;\nreg ack_q;\nreg ack_in_int;\n\n// FSM state variables\nreg [2:0] state;\nreg [2:0] next_state;\n\n// Internal registers\nreg complete;\nreg index_check_enable;\nreg CRC_check_enable;\nreg [6:0] response_size;\nreg [15:0] Watchdog_Cnt;\nreg [7:0] status;\n\n// Debounce logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        debounce <= 4'b0;\n        card_present <= 1'b0;\n    end else begin\n        if (~card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1'b1;\n        end else begin\n            debounce <= 4'b0;\n        end\n\n        if (debounce == 4'b1111)\n            card_present <= 1'b1;\n        else\n            card_present <= 1'b0;\n    end\nend\n\n// Synchronize ack_in\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        ack_q <= 1'b0;\n        ack_in_int <= 1'b0;\n    end else begin\n        ack_q <= ack_in;\n        ack_in_int <= ack_q;\n    end\nend\n\n// Synchronize req_in\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        req_q <= 1'b0;\n        req_in_int <= 1'b0;\n    end else begin\n        req_q <= req_in;\n        req_in_int <= req_q;\n    end\nend\n\n// FSM next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (New_CMD)\n                next_state = SETUP;\n            else\n                next_state = IDLE;\n        end\n        SETUP: begin\n            if (ack_in_int)\n                next_state = EXECUTE;\n            else\n                next_state = SETUP;\n        end\n        EXECUTE: begin\n            if (complete)\n                next_state = IDLE;\n            else\n                next_state = EXECUTE;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// FSM state register update\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// FSM output logic\nalways @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n    if (RST_PAD_I) begin\n        // Reset all outputs and internal registers\n        CRC_check_enable <= 1'b0;\n        complete <= 1'b0;\n        RESP_1_REG <= 32'b0;\n        ERR_INT_REG <= 5'b0;\n        NORMAL_INT_REG <= 16'b0;\n        STATUS_REG <= 16'b0;\n        status <= 8'b0;\n        cmd_out <= 40'b0;\n        settings <= 16'b0;\n        response_size <= 7'b0;\n        req_out <= 1'b0;\n        ack_out <= 1'b0;\n        index_check_enable <= 1'b0;\n        Watchdog_Cnt <= 16'b0;\n        go_idle_o <= 1'b0;\n    end else begin\n        // Assign card_present to Interrupt registers\n        NORMAL_INT_REG[1] <= card_present;\n        NORMAL_INT_REG[2] <= ~card_present;\n        complete <= 1'b0;\n        \n        case (state)\n            IDLE: begin\n                // IDLE state operations\n                go_idle_o <= 1'b0;\n                req_out <= 1'b0;\n                ack_out <= 1'b0;\n                STATUS_REG[0] <= 1'b0; // CICMD\n                if (req_in_int) begin\n                    status <= serial_status;\n                    ack_out <= 1'b1;\n                end else begin\n                    ack_out <= 1'b0;\n                end\n            end\n            SETUP: begin\n                // SETUP state operations\n                NORMAL_INT_REG <= 16'b0;\n                ERR_INT_REG <= 5'b0;\n                index_check_enable <= CMD_SET_REG[4]; // CICE\n                CRC_check_enable <= CMD_SET_REG[3];   // CRCE\n                \n                // Construct cmd_out\n                cmd_out[39:38] <= 2'b01; // Start bits\n                cmd_out[37:32] <= CMD_SET_REG[13:8]; // CMDI\n                cmd_out[31:0]  <= ARG_REG;\n                \n                // Determine response_size based on RTS\n                case (CMD_SET_REG[1:0]) // RTS\n                    2'b10, 2'b11: response_size <= 7'b0101000; // small_rsp\n                    2'b01:        response_size <= 7'b1111111; // big_rsp\n                    default:      response_size <= 7'b0;\n                endcase\n                \n                // Construct settings\n                settings[14:13] <= CMD_SET_REG[7:6]; // WORD_SELECT\n                settings[12]    <= data_read;\n                settings[11]    <= data_write;\n                settings[10:8]  <= 3'b111; // Delay\n                settings[7]     <= CMD_SET_REG[3]; // CRCE\n                settings[6:0]   <= response_size;\n                \n                Watchdog_Cnt <= 16'b0;\n                STATUS_REG[0] <= 1'b1; // CICMD\n            end\n            EXECUTE: begin\n                // EXECUTE state operations\n                Watchdog_Cnt <= Watchdog_Cnt + 1'b1;\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    ERR_INT_REG[0] <= 1'b1; // CTE\n                    NORMAL_INT_REG[15] <= 1'b1; // EI\n                    if (ack_in_int) begin\n                        complete <= 1'b1;\n                    end\n                    go_idle_o <= 1'b1;\n                end else begin\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end else begin\n                        req_out <= 1'b0;\n                    end\n                    if (req_in_int) begin\n                        status <= serial_status;\n                        ack_out <= 1'b1;\n                        if (status[6]) begin // dat_ava == 1\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[15] <= 1'b0; // EI\n                            if (CRC_check_enable && !status[5]) begin // crc_valid == 0\n                                ERR_INT_REG[1] <= 1'b1; // CCRCE\n                                NORMAL_INT_REG[15] <=1'b1; // EI\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1; // CIE\n                                NORMAL_INT_REG[15] <=1'b1; // EI\n                            end\n                            NORMAL_INT_REG[0] <= 1'b1; // CC\n                            if (response_size != 0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end else begin\n                        ack_out <= 1'b0;\n                    end\n                end\n            end\n            default: begin\n                // Should not occur, but set defaults if necessary\n            end\n        endcase\n        \n        // Handle Interrupt Resets\n        if (ERR_INT_RST)\n            ERR_INT_REG <= 5'b0;\n        if (NORMAL_INT_RST)\n            NORMAL_INT_REG <= 16'b0;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sdc_controller(\n    // Wishbone Slave Interface\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output wire [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    \n    // Wishbone Master Interface\n    output wire [31:0] m_wb_adr_o,\n    output wire [3:0] m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire [2:0] m_wb_cti_o,\n    output wire [1:0] m_wb_bte_o,\n    \n    // Card detect\n    input wire card_detect,\n    \n    // SDC IO\n    input wire sd_cmd_dat_i,  // CMD Input\n    output wire sd_cmd_out_o, // CMD Output\n    output wire sd_cmd_oe_o,  // CMD Output Enable\n    input wire [3:0] sd_dat_dat_i, // Data Input\n    output wire [3:0] sd_dat_out_o, // Data Output\n    output wire sd_dat_oe_o, // Data Output Enable\n    output wire sd_clk_o_pad // CLK Output\n    `ifdef SDC_CLK_SEP\n        ,input wire sd_clk_i_pad // Optional input when SDC_CLK_SEP is defined\n    `endif\n    `ifdef SDC_IRQ_ENABLE\n        ,output wire int_a\n        ,output wire int_b\n        ,output wire int_c\n    `endif\n);\n\n// Internal signals\nwire we_m_tx_bd;\nwire we_m_rx_bd;\nwire new_cmd;\nwire we_ack;\nwire int_ack;\nwire cmd_int_busy;\nwire int_busy;\nwire [31:0] argument_reg;\nwire [15:0] cmd_setting_reg;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [RAM_MEM_WIDTH -1:0] dat_in_m_tx_bd;\nwire [RAM_MEM_WIDTH -1:0] dat_in_m_rx_bd;\n\nwire write_req_s;\nwire [15:0] cmd_set_s;\nwire [31:0] cmd_arg_s;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] bd_status_reg;\nwire [7:0] bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\n\n`ifdef SDC_IRQ_ENABLE\n    wire [15:0] normal_int_status_reg_int;\n    wire [15:0] error_int_status_reg_int;\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(bd_isr_reg & Bd_isr_enable_reg);\n`endif\n\n// Reset logic\nwire rst;\nassign rst = wb_rst_i | software_reset_reg[0];\n\n// Clock signals\nwire sd_clk_i;\nwire sd_clk_o;\n`ifdef SDC_CLK_SEP\n    assign sd_clk_i = sd_clk_i_pad;\n`else\n    assign sd_clk_i = wb_clk_i;\n`endif\n\n`ifdef SD_CLK_DYNAMIC\n    // Instantiate sd_clock_divider\n    sd_clock_divider u_sd_clock_divider (\n        .CLK(sd_clk_i),\n        .RST(rst),\n        .DIVIDER(clock_divider),\n        .SD_CLK(sd_clk_o)\n    );\n`else\n    assign sd_clk_o = sd_clk_i;\n`endif\n\nassign sd_clk_o_pad = sd_clk_o;\n\n// Sub-module instantiations\n\n// sd_controller_wb\nsd_controller_wb u_sd_controller_wb (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(wb_dat_o),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o),\n    .we_m_tx_bd(we_m_tx_bd),\n    .we_m_rx_bd(we_m_rx_bd),\n    .new_cmd(new_cmd),\n    .we_ack(we_ack),\n    .int_ack(int_ack),\n    .cmd_int_busy(cmd_int_busy),\n    .int_busy(int_busy),\n    .write_req_s(write_req_s),\n    .cmd_set_s(cmd_set_s),\n    .cmd_arg_s(cmd_arg_s),\n    .argument_reg(argument_reg),\n    .cmd_setting_reg(cmd_setting_reg),\n    .status_reg(status_reg),\n    .cmd_resp_1(cmd_resp_1),\n    .software_reset_reg(software_reset_reg),\n    .time_out_reg(time_out_reg),\n    .normal_int_status_reg(normal_int_status_reg),\n    .error_int_status_reg(error_int_status_reg),\n    .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n    .error_int_signal_enable_reg(error_int_signal_enable_reg),\n    .clock_divider(clock_divider),\n    .Bd_Status_reg(bd_status_reg),\n    .Bd_isr_reg(bd_isr_reg),\n    .Bd_isr_enable_reg(Bd_isr_enable_reg),\n    .bd_isr_reset(bd_isr_reset),\n    .normal_isr_reset(normal_isr_reset),\n    .error_isr_reset(error_isr_reset),\n    .dat_in_m_tx_bd(dat_in_m_tx_bd),\n    .dat_in_m_rx_bd(dat_in_m_rx_bd)\n);\n\n// sd_cmd_master\n// Declare internal signals needed for sd_cmd_master\nwire data_write;\nwire data_read;\nwire [4:0] ERR_INT_REG;\nwire [15:0] NORMAL_INT_REG;\nwire [15:0] settings;\nwire go_idle_o;\nwire [39:0] cmd_out;\nwire req_out;\nwire ack_out;\nwire req_in;\nwire ack_in;\nwire [39:0] cmd_in;\nwire [7:0] serial_status;\nwire [15:0] TIMEOUT_REG;\nassign TIMEOUT_REG = time_out_reg;\n\n// ... similar declarations for other signals for sd_cmd_master\n\nsd_cmd_master u_sd_cmd_master(\n    .CLK_PAD_IO(sd_clk_o),\n    .RST_PAD_I(rst),\n    .New_CMD(new_cmd),\n    .data_write(data_write),\n    .data_read(data_read),\n    .ARG_REG(argument_reg),\n    .CMD_SET_REG(cmd_setting_reg[15:0]),\n    .TIMEOUT_REG(TIMEOUT_REG),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(ERR_INT_REG),\n    .NORMAL_INT_REG(NORMAL_INT_REG),\n    .ERR_INT_RST(error_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(settings),\n    .go_idle_o(go_idle_o),\n    .cmd_out(cmd_out),\n    .req_out(req_out),\n    .ack_out(ack_out),\n    .req_in(req_in),\n    .ack_in(ack_in),\n    .cmd_in(cmd_in),\n    .serial_status(serial_status),\n    .card_detect(card_detect)\n);\n\n// sd_cmd_serial_host\n// Instantiate sd_cmd_serial_host\nsd_cmd_serial_host u_sd_cmd_serial_host (\n    .SD_CLK_IN(sd_clk_o),\n    .RST_IN(rst | go_idle_o),\n    .SETTING_IN(settings),\n    .CMD_IN(cmd_out),\n    .REQ_IN(req_out),\n    .ACK_IN(ack_out),\n    .cmd_dat_i(sd_cmd_dat_i),\n    .CMD_OUT(cmd_in),\n    .ACK_OUT(ack_in),\n    .REQ_OUT(req_in),\n    .STATUS(serial_status),\n    .cmd_oe_o(sd_cmd_oe_o),\n    .cmd_out_o(sd_cmd_out_o),\n    .st_dat_t(st_dat_t)\n);\n\n// Master Wishbone Interface Control\n// Implement mux logic to connect wishbone master signals to either sd_fifo_tx_filler or sd_fifo_rx_filler\n\n// Internal signals for wishbone master interface\n// Outputs from sd_fifo_tx_filler\nwire [31:0] tx_m_wb_adr_o;\nwire tx_m_wb_we_o;\nwire [31:0] tx_m_wb_dat_o;\nwire tx_m_wb_cyc_o;\nwire tx_m_wb_stb_o;\nwire [2:0] tx_m_wb_cti_o;\nwire [1:0] tx_m_wb_bte_o;\n\n// Outputs from sd_fifo_rx_filler\nwire [31:0] rx_m_wb_adr_o;\nwire rx_m_wb_we_o;\nwire [31:0] rx_m_wb_dat_o;\nwire rx_m_wb_cyc_o;\nwire rx_m_wb_stb_o;\nwire [2:0] rx_m_wb_cti_o;\nwire [1:0] rx_m_wb_bte_o;\n\n// Control signals from sd_data_master\nwire start_tx_fifo;\nwire start_rx_fifo;\n\n// Mux logic\nassign m_wb_sel_o = 4'b1111; // as per Implementation Details\nassign m_wb_cyc_o = (start_tx_fifo) ? tx_m_wb_cyc_o :\n                    (start_rx_fifo) ? rx_m_wb_cyc_o : 1'b0;\nassign m_wb_stb_o = (start_tx_fifo) ? tx_m_wb_stb_o :\n                    (start_rx_fifo) ? rx_m_wb_stb_o : 1'b0;\nassign m_wb_we_o  = (start_tx_fifo) ? tx_m_wb_we_o :\n                    (start_rx_fifo) ? rx_m_wb_we_o : 1'b0;\nassign m_wb_adr_o = (start_tx_fifo) ? tx_m_wb_adr_o :\n                    (start_rx_fifo) ? rx_m_wb_adr_o : 32'b0;\nassign m_wb_dat_o = (start_tx_fifo) ? tx_m_wb_dat_o :\n                    (start_rx_fifo) ? rx_m_wb_dat_o : 32'b0;\nassign m_wb_cti_o = (start_tx_fifo) ? tx_m_wb_cti_o :\n                    (start_rx_fifo) ? rx_m_wb_cti_o : 3'b0;\nassign m_wb_bte_o = (start_tx_fifo) ? tx_m_wb_bte_o :\n                    (start_rx_fifo) ? rx_m_wb_bte_o : 2'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters from sd_defines.v and local definitions\n`ifdef RAM_MEM_WIDTH_32\nlocalparam RAM_MEM_WIDTH = 32;\nlocalparam READ_CYCLE = 2;\nlocalparam BD_CNT_WIDTH = 2;\nlocalparam BD_EMPTY = BD_SIZE / 2;\n`elsif RAM_MEM_WIDTH_16\nlocalparam RAM_MEM_WIDTH = 16;\nlocalparam READ_CYCLE = 4;\nlocalparam BD_CNT_WIDTH = 3;\nlocalparam BD_EMPTY = BD_SIZE / 4;\n`else\n`error \"RAM_MEM_WIDTH not defined. Define RAM_MEM_WIDTH_16 or RAM_MEM_WIDTH_32 in sd_defines.v\"\n`endif\n\n// Command definitions\nlocalparam CMD17 = 16'h111A; // Read single block\nlocalparam CMD24 = 16'h181A; // Write single block\nlocalparam CMD12 = 16'h0C1A; // Stop transmission\nlocalparam ACMD13 = 16'h0D1A; // SD status\nlocalparam ACMD51 = 16'h331A; // Read SCR\n\nlocalparam SIZE = 9;\nlocalparam IDLE          = 9'b000000001;\nlocalparam GET_TX_BD     = 9'b000000010;\nlocalparam GET_RX_BD     = 9'b000000100;\nlocalparam SEND_CMD      = 9'b000001000;\nlocalparam RECEIVE_CMD   = 9'b000010000;\nlocalparam DATA_TRANSFER = 9'b000100000;\nlocalparam STOP          = 9'b001000000;\nlocalparam STOP_SEND     = 9'b010000000;\nlocalparam RESEND_MAX_CNT = 3;\n\n// Internal signals\nreg [SIZE-1:0] state;\nreg send_done;\nreg rec_done;\nreg rec_failed;\nreg tx_cycle;\nreg rx_cycle;\nreg [2:0] resend_try_cnt;\nreg trans_done;\nreg trans_failed;\nreg [BD_CNT_WIDTH-1:0] bd_cnt;\nreg transm_complete_q;\nreg crc_ok_q;\n\n// FSM\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        // Reset outputs and internal signals\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        cmd_arg <= 0;\n        cmd_set <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        sys_adr <= 0;\n        ack_transfer <= 0;\n        Dat_Int_Status <= 0;\n        CIDAT <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        resend_try_cnt <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        bd_cnt <= 0;\n        transm_complete_q <= 0;\n        crc_ok_q <= 0;\n    end else begin\n        transm_complete_q <= transm_complete;\n        crc_ok_q <= crc_ok;\n\n        // Default assignments\n        re_s_tx <= 0;\n        a_cmp_tx <= 0;\n        re_s_rx <= 0;\n        a_cmp_rx <= 0;\n        we_req <= 0;\n        d_write <= 0;\n        d_read <= 0;\n        start_tx_fifo <= 0;\n        start_rx_fifo <= 0;\n        ack_transfer <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n\n        case (state)\n            IDLE: begin\n                // Wait for new BD to process\n                if (free_tx_bd != BD_EMPTY) begin\n                    state <= GET_TX_BD;\n                    bd_cnt <= 0;\n                end else if (free_rx_bd != BD_EMPTY) begin\n                    state <= GET_RX_BD;\n                    bd_cnt <= 0;\n                end\n            end\n\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n                if (ack_i_s_tx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                            cmd_set <= CMD24;\n                            tx_cycle <= 1;\n                            if (tx_full) begin\n                                state <= SEND_CMD;\n                            end\n                        end\n                    `endif\n                    `ifdef RAM_MEM_WIDTH_16\n                        if (bd_cnt == 0) begin\n                            sys_adr[31:16] <= dat_in_tx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[15:0] <= dat_in_tx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[31:16] <= dat_in_tx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[15:0] <= dat_in_tx;\n                            start_tx_fifo <= 1;\n                            cmd_set <= CMD24;\n                            tx_cycle <= 1;\n                            if (tx_full) begin\n                                state <= SEND_CMD;\n                            end\n                        end\n                    `endif\n                end\n            end\n\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n                if (ack_i_s_rx) begin\n                    bd_cnt <= bd_cnt + 1;\n                    `ifdef RAM_MEM_WIDTH_32\n                        if (bd_cnt == 0) begin\n                            sys_adr <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            cmd_arg <= dat_in_rx;\n                            cmd_set <= (transfer_type == 2'b00) ? CMD17 :\n                                       (transfer_type == 2'b01) ? ACMD13 : ACMD51;\n                            rx_cycle <= 1;\n                            state <= SEND_CMD;\n                        end\n                    `endif\n                    `ifdef RAM_MEM_WIDTH_16\n                        if (bd_cnt == 0) begin\n                            sys_adr[31:16] <= dat_in_rx;\n                        end else if (bd_cnt == 1) begin\n                            sys_adr[15:0] <= dat_in_rx;\n                        end else if (bd_cnt == 2) begin\n                            cmd_arg[31:16] <= dat_in_rx;\n                        end else if (bd_cnt == 3) begin\n                            cmd_arg[15:0] <= dat_in_rx;\n                            cmd_set <= (transfer_type == 2'b00) ? CMD17 :\n                                       (transfer_type == 2'b01) ? ACMD13 : ACMD51;\n                            rx_cycle <= 1;\n                            state <= SEND_CMD;\n                        end\n                    `endif\n                end\n            end\n\n            SEND_CMD: begin\n                if (rx_cycle) begin\n                    d_read <= 1;\n                end else if (tx_cycle) begin\n                    d_write <= 1;\n                end\n                if (!cmd_busy) begin\n                    we_req <= 1;\n                    if (we_ack) begin\n                        send_done <= 1;\n                        state <= RECEIVE_CMD;\n                    end\n                end\n            end\n\n            RECEIVE_CMD: begin\n                if (rx_cycle) begin\n                    start_rx_fifo <= 1;\n                end\n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) begin\n                        rec_failed <= 1;\n                        state <= SEND_CMD;\n                    end else begin\n                        if (card_status[0] == 1'b1 &&\n                            (card_status[4:1] == 4'b0100 || card_status[4:1] == 4'b0101 ||\n                             card_status[4:1] == 4'b0110)) begin\n                            rec_done <= 1;\n                            state <= DATA_TRANSFER;\n                        end else begin\n                            rec_failed <= 1;\n                            state <= SEND_CMD;\n                        end\n                    end\n                end\n            end\n\n            DATA_TRANSFER: begin\n                if (transm_complete && !transm_complete_q) begin\n                    if (!crc_ok) begin\n                        trans_failed <= 1;\n                        state <= STOP;\n                    end else begin\n                        trans_done <= 1;\n                        if (tx_cycle) begin\n                            a_cmp_tx <= 1;\n                        end else if (rx_cycle) begin\n                            a_cmp_rx <= 1;\n                        end\n                        state <= IDLE;\n                    end\n                end\n            end\n\n            STOP: begin\n                cmd_set <= CMD12;\n                resend_try_cnt <= 0;\n                state <= STOP_SEND;\n            end\n\n            STOP_SEND: begin\n                if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1;\n                    state <= IDLE;\n                end else begin\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                            state <= IDLE;\n                        end else begin\n                            resend_try_cnt <= resend_try_cnt + 1;\n                        end\n                    end\n                end\n            end\n\n            default: begin\n                state <= IDLE;\n            end\n        endcase\n        \n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 8'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": 0, "syntax_info": null, "function_info": null, "formal_info": null}
