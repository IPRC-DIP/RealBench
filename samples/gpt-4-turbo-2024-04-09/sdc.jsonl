{"task": "sd_clock_divider", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] count;\nwire [7:0] max_count = DIVIDER;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        SD_CLK <= 0;\n        count <= 0;\n    end else begin\n        if (count >= max_count) begin\n            SD_CLK <= ~SD_CLK;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter == DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input CLK,\n    input [7:0] DIVIDER,\n    input RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Combinational logic for inv calculation\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        // CRC update logic\n        CRC <= {CRC[14:0], 1'b0}; // Shift left\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[5] <= CRC[4] ^ inv;\n        CRC[0] <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Combinational logic for inv calculation\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset to zero\n        CRC <= 16'b0;\n    end else begin\n        if (Enable) begin\n            // Perform CRC update on rising edge of CLK if enabled\n            CRC <= {CRC[14:0], 1'b0}; // Shift left operation\n            CRC[12] <= CRC[11] ^ inv; // Update CRC[12]\n            CRC[5]  <= CRC[4]  ^ inv; // Update CRC[5]\n            CRC[0]  <= inv;           // Set CRC[0] to inv\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\n// Intermediate signal for inversion calculation\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n    wire inv;\n    assign inv = BITVAL ^ CRC[15];\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC <= 16'b0;\n        end else if (Enable) begin\n            CRC <= {CRC[14:0], 1'b0}; // Shift left\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Inverse calculation based on the current input bit and the MSB of CRC\n        wire inv = BITVAL ^ CRC[6];\n\n        // Update CRC based on the inverse calculation and previous CRC state\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Compute the inverse based on the current input bit and the MSB of CRC\n        wire inv = BITVAL ^ CRC[6];\n\n        // Update the CRC value based on the inverse calculation\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Combinational logic for inv calculation\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset to zero\n        CRC <= 16'b0;\n    end else begin\n        if (Enable) begin\n            // Shift left all bits of CRC\n            CRC <= CRC << 1;\n            // Update specific bits after shift\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv; // Least significant bit set to inv\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Combinational logic to calculate inv\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset to zero\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        // Shift left all bits of CRC\n        CRC <= CRC << 1;\n        // Update specific bits based on inv\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[5] <= CRC[4] ^ inv;\n        CRC[0] <= inv; // Least significant bit set to inv\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Intermediate signal for XOR operation\nwire inv;\n\n// Calculate inv as XOR of BITVAL and MSB of CRC\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Reset CRC to 0\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        // Shift CRC left\n        CRC <= CRC << 1;\n        // Update specific CRC bits with XOR results involving inv\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[5] <= CRC[4] ^ inv;\n        // Set CRC[0] to inv\n        CRC[0] <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Intermediate signal for XOR of input bit and MSB of CRC\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset: Set CRC to 0\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        // Update CRC only if Enable is high\n        CRC <= {CRC[14:0], 1'b0};  // Shift left CRC\n        CRC[12] <= CRC[11] ^ inv;  // Update CRC[12]\n        CRC[5]  <= CRC[4] ^ inv;   // Update CRC[5]\n        CRC[0]  <= inv;            // Set CRC[0] to inv\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        wire inv;\n        inv = BITVAL ^ CRC[6];\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\n// Intermediate signal for inversion calculation\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset of CRC\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Update CRC only if Enable is high\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\n    // No else clause needed; CRC remains unchanged if Enable is low\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Calculate the inverse based on the current bit and the MSB of CRC\n        wire inv = BITVAL ^ CRC[6];\n\n        // Update the CRC with the new values\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        SD_CLK <= 0;\n        counter <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal Registers\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            free_bd <= free_bd - 1;\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            ack_o_s <= 1;\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle release of buffer descriptor\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end\n    else if (Enable) begin\n        // Compute the inverse based on the current input bit and the MSB of CRC\n        wire inv = BITVAL ^ CRC[6];\n\n        // Update the CRC based on the inverse calculation\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Combinational logic for inv calculation\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        // CRC update logic\n        CRC[15:1] <= CRC[14:0];  // Shift left operation\n        CRC[0] <= inv;           // Set LSB to inv\n        CRC[12] <= CRC[11] ^ inv; // Update CRC[12]\n        CRC[5] <= CRC[4] ^ inv;   // Update CRC[5]\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Parameters based on sd_defines.v\nlocalparam BD_SIZE_MASK = BD_SIZE - 1;\n\n// Internal Registers\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        last_a_cmp <= 0;\n    end else begin\n        // Handle a_cmp for releasing BD\n        last_a_cmp <= a_cmp;\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n\n        // Writing Buffer Descriptor\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) & BD_SIZE_MASK;\n            if ((RAM_MEM_WIDTH == 32 && m_wr_pnt[0]) || (RAM_MEM_WIDTH == 16 && m_wr_pnt[1:0] == 2'b11)) begin\n                free_bd <= free_bd - 1;\n            end\n        end\n\n        // Reading Buffer Descriptor\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) & BD_SIZE_MASK;\n            ack_o_s <= 1'b1;\n        end else begin\n            ack_o_s <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Combinational logic for inv calculation\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\n// Sequential logic for CRC calculation\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Reset CRC to 0\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        // Shift left CRC and update specific bits\n        CRC <= {CRC[14:0], inv};  // Shift left and insert inv at LSB\n        CRC[12] <= CRC[11] ^ inv; // Update CRC[12]\n        CRC[5] <= CRC[4] ^ inv;   // Update CRC[5]\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Parameters\nlocalparam BD_SIZE_HALF = BD_SIZE >> 1;\nlocalparam BD_SIZE_QUARTER = BD_SIZE >> 2;\n\n// Internal Registers\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg [BD_WIDTH-1:0] write_count, read_count;\nreg last_a_cmp;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        write_count <= 0;\n        read_count <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? BD_SIZE_HALF : BD_SIZE_QUARTER;\n        last_a_cmp <= 0;\n    end else begin\n        // Write operation\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            write_count <= write_count + 1;\n            if ((RAM_MEM_WIDTH == 32 && write_count == 1) || (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                write_count <= 0;\n                free_bd <= free_bd - 1;\n            end\n        end\n\n        // Read operation\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            read_count <= read_count + 1;\n            ack_o_s <= (RAM_MEM_WIDTH == 16);\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Release buffer descriptor\n        last_a_cmp <= a_cmp;\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal registers and wires\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg last_a_cmp;\ninteger i;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? BD_SIZE / 2 : BD_SIZE / 4;\n        for (i = 0; i < BD_SIZE; i = i + 1) begin\n            bd_mem[i] <= 0;\n        end\n    end\n    else begin\n        // Write operation\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            free_bd <= free_bd - 1;\n        end\n\n        // Read operation\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            ack_o_s <= 1;\n        end\n        else begin\n            ack_o_s <= 0;\n        end\n\n        // Release buffer descriptor\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal Registers\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg last_a_cmp;\ninteger i;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        for (i = 0; i < BD_SIZE; i = i + 1) begin\n            bd_mem[i] <= 0;\n        end\n    end\n    else begin\n        // Write Operation\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            free_bd <= free_bd - 1;\n        end\n\n        // Read Operation\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            ack_o_s <= 1;\n        end\n        else begin\n            ack_o_s <= 0;\n        end\n\n        // Release Buffer Descriptor\n        if (a_cmp && !last_a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal signals\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        ack_o_s <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            free_bd <= free_bd - 1;\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            ack_o_s <= 1;\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle completion of SD card operation\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal Registers\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg last_a_cmp;\ninteger i;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        for (i = 0; i < BD_SIZE; i = i + 1) begin\n            bd_mem[i] <= 0;\n        end\n    end\n    else begin\n        // Write Operation\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            free_bd <= free_bd - 1;\n        end\n\n        // Read Operation\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            ack_o_s <= 1;\n        end\n        else begin\n            ack_o_s <= 0;\n        end\n\n        // Release Buffer Descriptor\n        if (a_cmp && !last_a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n\n        // Track last a_cmp state\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Parameters\nlocalparam BD_SIZE_32 = 32;\nlocalparam BD_SIZE_16 = 16;\n\n// Internal Registers\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? BD_SIZE / 2 : BD_SIZE / 4;\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            free_bd <= free_bd - 1;\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            ack_o_s <= 1;\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle SD card operation completion\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Parameters\nlocalparam BD_SIZE_HALF = BD_SIZE / 2;\nlocalparam BD_SIZE_QUARTER = BD_SIZE / 4;\n\n// Internal Registers\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg [BD_WIDTH-1:0] write_count, read_count;\nreg last_a_cmp;\n\n// Memory for Buffer Descriptors\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        write_count <= 0;\n        read_count <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? BD_SIZE_HALF : BD_SIZE_QUARTER;\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            write_count <= write_count + 1;\n            if ((RAM_MEM_WIDTH == 32 && write_count == 1) || (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                write_count <= 0;\n                free_bd <= free_bd - 1;\n            end\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            read_count <= read_count + 1;\n            ack_o_s <= (RAM_MEM_WIDTH == 16);\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle SD card operation completion\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal Registers and Wires\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg [BD_WIDTH-1:0] write_count, read_count;\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        write_count <= 0;\n        read_count <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            write_count <= write_count + 1;\n            if ((RAM_MEM_WIDTH == 32 && write_count == 1) || (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                write_count <= 0;\n                free_bd <= free_bd - 1;\n            end\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            read_count <= read_count + 1;\n            ack_o_s <= 1;\n            if ((RAM_MEM_WIDTH == 32 && read_count == 1) || (RAM_MEM_WIDTH == 16 && read_count == 3)) begin\n                read_count <= 0;\n            end\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle buffer descriptor release\n        last_a_cmp <= a_cmp;\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input wire clk,\n    input wire rst,\n    input wire we_m,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input wire re_s,\n    output reg ack_o_s,\n    input wire a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal registers\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            free_bd <= free_bd - 1;\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            ack_o_s <= 1;\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle SD card operation completion\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output [1:0] mem_empt\n);\n\n// FIFO memory depth and address size\nlocalparam FIFO_DEPTH = `FIFO_RX_MEM_DEPTH;\nlocalparam ADDR_SIZE = `FIFO_RX_MEM_ADR_SIZE;\n\n// RAM for FIFO\nreg [31:0] ram[FIFO_DEPTH-1:0];\n\n// Pointers and registers\nreg [ADDR_SIZE-1:0] adr_i, adr_o;\nreg [31:0] tmp;\nreg [7:0] we;\nreg ft;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        we <= 8'h1;\n        ft <= 0;\n    end else if (wr && !full) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 3) begin\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            ft <= 0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Full and empty flags\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n        empty <= 1;\n    end else begin\n        full <= (adr_i == adr_o - 1);\n        empty <= (adr_i == adr_o);\n    end\nend\n\n// Memory empty space calculation\nassign mem_empt = FIFO_DEPTH - (adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal Registers\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg [BD_WIDTH-1:0] write_count, read_count;\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        write_count <= 0;\n        read_count <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            write_count <= write_count + 1;\n            if ((RAM_MEM_WIDTH == 32 && write_count == 1) || (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                write_count <= 0;\n                free_bd <= free_bd - 1;\n            end\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            read_count <= read_count + 1;\n            ack_o_s <= (RAM_MEM_WIDTH == 16); // Acknowledge every read in 16-bit mode\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle SD card operation completion\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Parameters\nlocalparam BD_SIZE_HALF = BD_SIZE >> 1;\nlocalparam BD_SIZE_QUARTER = BD_SIZE >> 2;\n\n// Internal Registers\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? BD_SIZE_HALF : BD_SIZE_QUARTER;\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            free_bd <= free_bd - 1;\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            ack_o_s <= 1;\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle release of buffer descriptor\n        last_a_cmp <= a_cmp;\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n// Parameter for the depth of the FIFO\nparameter FIFO_DEPTH = `FIFO_RX_MEM_DEPTH;\nparameter ADDR_SIZE = `FIFO_RX_MEM_ADR_SIZE;\n\n// RAM for FIFO\nreg [31:0] ram[FIFO_DEPTH-1:0];\n\n// Pointers and temporary storage\nreg [ADDR_SIZE-1:0] adr_i, adr_o;\nreg [31:0] tmp;\nreg [7:0] we;\nreg ft;\n\n// Write logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        we <= 8'h1;\n        ft <= 0;\n    end else if (wr) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 7) begin\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            ft <= 0;\n        end\n    end\nend\n\n// Read logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Full and empty flags\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n        empty <= 1;\n    end else begin\n        full <= (adr_i == adr_o - 1);\n        empty <= (adr_i == adr_o);\n    end\nend\n\n// Memory empty space calculation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 2'b11; // Assuming FIFO_DEPTH is 4 for simplicity\n    end else begin\n        mem_empt <= FIFO_DEPTH - (adr_i - adr_o);\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\n// Intermediate signal for inverse calculation\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal signals\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg [BD_WIDTH-1:0] write_count, read_count;\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        write_count <= 0;\n        read_count <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        ack_o_s <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            write_count <= write_count + 1;\n            if ((RAM_MEM_WIDTH == 32 && write_count == 1) || (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                write_count <= 0;\n                free_bd <= free_bd - 1;\n            end\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            read_count <= read_count + 1;\n            ack_o_s <= (RAM_MEM_WIDTH == 16);\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle release of buffer descriptor\n        last_a_cmp <= a_cmp;\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Parameters based on sd_defines.v\nlocalparam BD_SIZE_MASK = BD_SIZE - 1;\n\n// Internal Registers\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg [BD_WIDTH-1:0] write_count, read_count;\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        write_count <= 0;\n        read_count <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) & BD_SIZE_MASK;\n            write_count <= write_count + 1;\n            if ((RAM_MEM_WIDTH == 32 && write_count == 1) || (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                write_count <= 0;\n                free_bd <= free_bd - 1;\n            end\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) & BD_SIZE_MASK;\n            read_count <= read_count + 1;\n            ack_o_s <= (RAM_MEM_WIDTH == 16);\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle release of buffer descriptor\n        last_a_cmp <= a_cmp;\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0000000;\n    end\n    else if (Enable) begin\n        // Compute the inverse calculation\n        wire inv = BITVAL ^ CRC[6];\n\n        // Update the CRC values\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output [1:0] mem_empt\n);\n\n// Internal registers and wires\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] next_adr_i, next_adr_o;\n\n// Address calculation\nassign next_adr_i = (adr_i == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_i + 1;\nassign next_adr_o = (adr_o == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n\n// Memory empty space calculation\nassign mem_empt = FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\n\n// Asynchronous reset\nalways @(posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        adr_o <= 0;\n        full <= 0;\n        empty <= 1;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end\nend\n\n// Write operation\nalways @(posedge wclk) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 7) begin\n            ram[adr_i] <= tmp;\n            adr_i <= next_adr_i;\n            ft <= 0;\n        end\n    end\n    full <= (next_adr_i == adr_o);\nend\n\n// Read operation\nalways @(posedge rclk) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= next_adr_o;\n    end\n    empty <= (adr_o == adr_i);\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Intermediate signal for the XOR of the input bit and the MSB of the CRC\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset to zero\n        CRC <= 16'b0;\n    end else begin\n        if (Enable) begin\n            // Shift left all bits of the CRC\n            CRC <= CRC << 1;\n            // Update specific bits after the shift\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5]  <= CRC[4] ^ inv;\n            CRC[0]  <= inv; // Set the LSB to the inv value\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty detection\nwire write_cond;\nwire read_cond;\nwire fifo_full;\nwire fifo_empty;\n\n// Write operation\nassign write_cond = wr && !full;\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (write_cond) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\n    end\nend\n\n// Read operation\nassign read_cond = rd && !empty;\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (read_cond) begin\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n    end\nend\n\n// Data output\nassign q = ram[adr_o];\n\n// Full and empty status update\nassign fifo_full = (adr_i == adr_o - 1) || (adr_i == FIFO_TX_MEM_DEPTH-1 && adr_o == 0);\nassign fifo_empty = (adr_i == adr_o);\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n    end else begin\n        full <= fifo_full;\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        empty <= 1;\n    end else begin\n        empty <= fifo_empty;\n    end\nend\n\n// FIFO occupancy calculation\nalways @(*) begin\n    if (adr_i >= adr_o) begin\n        mem_empt = adr_i - adr_o;\n    end else begin\n        mem_empt = (FIFO_TX_MEM_DEPTH - adr_o) + adr_i;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output reg empty,\n    output reg fe,\n    output wire reset_tx_fifo\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Submodule instantiation\n    sd_tx_fifo tx_fifo(\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(rst)\n    );\n\n    // State machine for control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + (offset << MEM_OFFSET);\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 0;\n                    m_wb_bte_o <= 0;\n                end\n\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    delay <= 1;\n                end\n\n                if (delay) begin\n                    offset <= offset + 1;\n                    ackd <= !ackd;\n                    wr_tx <= 0;\n                    delay <= 0;\n                end\n            end else begin\n                offset <= 0;\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                m_wb_we_o <= 0;\n                wr_tx <= 0;\n            end\n        end\n    end\n\n    assign reset_tx_fifo = rst || !en;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Combinational logic for inv calculation\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset\n        CRC <= 16'b0;\n    end else begin\n        if (Enable) begin\n            // CRC update logic\n            CRC <= {CRC[14:0], 1'b0}; // Shift left operation\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[0] <= inv;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Submodule instantiation\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(rst)\n    );\n\n    // State machine for control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 1;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            if (en) begin\n                if (!fe && !m_wb_cyc_o && ackd) begin\n                    m_wb_adr_o <= adr + (offset << MEM_OFFSET);\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00; // Linear burst\n                end\n\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    delay <= 1;\n                end\n\n                if (delay) begin\n                    offset <= offset + 1;\n                    ackd <= !ackd;\n                    wr_tx <= 0;\n                    delay <= 0;\n                end\n            end else begin\n                reset_tx_fifo <= 1;\n                offset <= 0;\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                m_wb_we_o <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\n// Intermediate signal for inverse calculation\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset of CRC\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Update CRC only when Enable is high\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\n    // When Enable is low, CRC remains unchanged\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7 (\n    input wire BITVAL,\n    input wire Enable,\n    input wire CLK,\n    input wire RST,\n    output reg [6:0] CRC\n);\n\n// Internal signal for inverse calculation\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset of CRC\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Update CRC only if Enable is high\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire mem_empty;\n    wire fifo_full;\n    wire fifo_empty;\n\n    // Constants\n    localparam MEM_OFFSET = `MEM_OFFSET;\n\n    // Instantiate the FIFO\n    sd_rx_fifo fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .mem_empt(mem_empty),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Assign external full and empty signals\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    // State machine for managing FIFO and Wishbone transactions\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else begin\n            if (en) begin\n                reset_rx_fifo <= 0;\n                if (!fifo_empty && wb_free) begin\n                    rd <= 1;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 0; // Classic cycle\n                    m_wb_bte_o <= 0; // Linear burst\n                    wb_free <= 0;\n                end\n                if (m_wb_ack_i) begin\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    offset <= offset + MEM_OFFSET;\n                    wb_free <= 1;\n                end\n            end else begin\n                reset_rx_fifo <= 1;\n                rd <= 0;\n                offset <= 0;\n                m_wb_we_o <= 0;\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                wb_free <= 1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Parameters\nlocalparam BD_SIZE_HALF = BD_SIZE >> 1;\nlocalparam BD_SIZE_QUARTER = BD_SIZE >> 2;\n\n// Internal Registers\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? BD_SIZE_HALF : BD_SIZE_QUARTER;\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            free_bd <= free_bd - 1;\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            ack_o_s <= 1;\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle SD card operation completion\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output reg empty,\n    output reg fe,\n    output wire reset_tx_fifo\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Instantiate the sd_tx_fifo submodule\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // Reset and initialization\n    assign reset_tx_fifo = rst || (en == 0);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            if (en) begin\n                if (first) begin\n                    m_wb_adr_o <= adr;\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00; // Linear burst\n                    first <= 0;\n                    ackd <= 0;\n                end else if (m_wb_ack_i && !ackd) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    ackd <= 1;\n                    delay <= 1;\n                end else if (delay) begin\n                    offset <= offset + 1;\n                    m_wb_adr_o <= adr + (offset << MEM_OFFSET);\n                    ackd <= 0;\n                    delay <= 0;\n                    wr_tx <= 0;\n                end\n            end else begin\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                m_wb_we_o <= 0;\n                offset <= 0;\n                first <= 1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\nreg [15:0] next_crc;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 16'b0;\n    end else begin\n        if (Enable) begin\n            CRC <= next_crc;\n        end\n    end\nend\n\nalways @* begin\n    // Calculate 'inv' as the XOR of BITVAL and the MSB of CRC\n    wire inv = BITVAL ^ CRC[15];\n\n    // Calculate the next state of the CRC\n    next_crc[15] = CRC[14];\n    next_crc[14] = CRC[13];\n    next_crc[13] = CRC[12];\n    next_crc[12] = CRC[11] ^ inv;\n    next_crc[11] = CRC[10];\n    next_crc[10] = CRC[9];\n    next_crc[9]  = CRC[8];\n    next_crc[8]  = CRC[7];\n    next_crc[7]  = CRC[6];\n    next_crc[6]  = CRC[5];\n    next_crc[5]  = CRC[4] ^ inv;\n    next_crc[4]  = CRC[3];\n    next_crc[3]  = CRC[2];\n    next_crc[2]  = CRC[1];\n    next_crc[1]  = CRC[0];\n    next_crc[0]  = inv;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire fifo_full;\n    wire fifo_empty;\n    wire [1:0] mem_empty;\n\n    // Instantiate the FIFO\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .mem_empt(mem_empty),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Assign outputs\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    // State machine for managing FIFO and Wishbone interface\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all control signals and counters\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end else begin\n            if (en) begin\n                if (wb_free && !fifo_empty) begin\n                    // Start reading from FIFO\n                    rd <= 1'b1;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1'b1;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00; // Linear burst\n                    wb_free <= 1'b0;\n                end\n                if (!wb_free && m_wb_ack_i) begin\n                    // Acknowledgment received\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    offset <= offset + MEM_OFFSET;\n                    wb_free <= 1'b1;\n                end\n            end else begin\n                // Disabled state handling\n                reset_rx_fifo <= 1'b1;\n                rd <= 1'b0;\n                offset <= 9'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire fifo_full;\n    wire fifo_empty;\n    wire [1:0] mem_empty;\n\n    // Instantiate the FIFO\n    sd_rx_fifo fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .mem_empt(mem_empty),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end else begin\n            if (en) begin\n                reset_rx_fifo <= 1'b0;\n                if (!fifo_empty && wb_free) begin\n                    rd <= 1'b1;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1'b1;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00; // Linear burst\n                    wb_free <= 1'b0;\n                end\n                if (m_wb_ack_i) begin\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    offset <= offset + MEM_OFFSET;\n                    wb_free <= 1'b1;\n                end\n            end else begin\n                reset_rx_fifo <= 1'b1;\n                rd <= 1'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                offset <= 9'b0;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output reg empty,\n    output reg fe,\n    output wire reset_tx_fifo\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Submodule instantiation\n    sd_tx_fifo tx_fifo(\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               WAIT_ACK = 1,\n               WRITE_FIFO = 2,\n               POST_WRITE = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && !m_wb_ack_i && ackd)\n                    next_state = WAIT_ACK;\n                else\n                    next_state = IDLE;\n            end\n            WAIT_ACK: begin\n                if (m_wb_ack_i)\n                    next_state = WRITE_FIFO;\n                else\n                    next_state = WAIT_ACK;\n            end\n            WRITE_FIFO: begin\n                next_state = POST_WRITE;\n            end\n            POST_WRITE: begin\n                if (delay)\n                    next_state = IDLE;\n                else\n                    next_state = POST_WRITE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output and internal logic\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (en && !fe && !m_wb_ack_i && ackd) begin\n                        m_wb_adr_o <= adr + offset;\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 1;\n                        m_wb_stb_o <= 1;\n                        m_wb_cti_o <= 3'b000;\n                        m_wb_bte_o <= 2'b00;\n                    end\n                end\n                WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        din <= m_wb_dat_i;\n                        wr_tx <= 1;\n                    end\n                end\n                WRITE_FIFO: begin\n                    wr_tx <= 0;\n                    delay <= 1;\n                end\n                POST_WRITE: begin\n                    if (delay) begin\n                        offset <= offset + 4;\n                        ackd <= !ackd;\n                        delay <= 0;\n                        m_wb_cyc_o <= 0;\n                        m_wb_stb_o <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign reset_tx_fifo = (rst || (en == 0));\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal variables\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg last_a_cmp;\ninteger i;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? BD_SIZE/2 : BD_SIZE/4;\n        for (i = 0; i < BD_SIZE; i = i + 1) begin\n            bd_mem[i] <= 0;\n        end\n        ack_o_s <= 0;\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            free_bd <= free_bd - 1;\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            ack_o_s <= 1;\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle SD card operation completion\n        if (a_cmp && !last_a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\n// Intermediate signal for inverse calculation\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset of CRC\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Update CRC only if Enable is high\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\n    // No else part needed, CRC retains its value when Enable is low\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Combinational logic for inv calculation\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Reset the CRC to 0\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        // Update CRC on rising edge of CLK if Enable is high\n        CRC <= {CRC[14:0], 1'b0};  // Shift left by 1\n        CRC[12] <= CRC[11] ^ inv;  // Update CRC[12]\n        CRC[5] <= CRC[4] ^ inv;    // Update CRC[5]\n        CRC[0] <= inv;             // Set CRC[0] to inv\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Sub-module instantiation\n    sd_tx_fifo tx_fifo (\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(rst)\n    );\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            if (en) begin\n                if (!fe && !m_wb_cyc_o && ackd) begin\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00; // Linear burst\n                end\n\n                if (m_wb_ack_i) begin\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n\n                if (delay) begin\n                    offset <= offset + 1'b1;\n                    ackd <= !ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\n// Intermediate signal for inverse calculation\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset of CRC\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Update CRC only when Enable is high\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\n    // When Enable is low, CRC retains its value (no else clause needed)\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Intermediate signal for XOR computation\nwire inv;\n\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset to zero\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        // Perform CRC update only when enabled\n        CRC <= {CRC[14:0], 1'b0}; // Shift left operation\n        CRC[12] <= CRC[11] ^ inv; // Update CRC[12]\n        CRC[5]  <= CRC[4]  ^ inv; // Update CRC[5]\n        CRC[0]  <= inv;           // Set CRC[0] to inv\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register address decoding\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers and outputs\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1; // Default to high\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the wishbone transaction\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    // Handle BD RX and TX\n                    8'h60: begin\n                        dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        we_m_rx_bd <= 1'b1;\n                    end\n                    8'h80: begin\n                        dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        we_m_tx_bd <= 1'b1;\n                    end\n                    default: ;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'b0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'b0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    8'h4c: wb_dat_o <= {24'b0, clock_divider};\n                    8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Combinational logic for inv calculation\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset to zero\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        // CRC update logic\n        CRC[15:1] <= CRC[14:0];  // Shift all bits left\n        CRC[0] <= inv;           // Set LSB to inv\n        CRC[12] <= CRC[11] ^ inv; // Update CRC[12]\n        CRC[5] <= CRC[4] ^ inv;  // Update CRC[5]\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for FSM\n    reg [2:0] state, next_state;\n\n    // Registers for debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Synchronization registers\n    reg req_in_q, req_in_int;\n    reg ack_in_q, ack_in_int;\n\n    // Watchdog counter\n    reg [15:0] Watchdog_Cnt;\n\n    // FSM state transition logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = New_CMD ? SETUP : IDLE;\n            SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = (Watchdog_Cnt > TIMEOUT_REG || complete) ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic based on state\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n            STATUS_REG <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            go_idle_o <= 0;\n            cmd_out <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            Watchdog_Cnt <= 0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                SETUP: begin\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], 7'b0000000};\n                    ERR_INT_REG <= 0;\n                    NORMAL_INT_REG <= 0;\n                    Watchdog_Cnt <= 0;\n                end\n                EXECUTE: begin\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                    end\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1; // CTE\n                        NORMAL_INT_REG[15] <= 1; // EI\n                        go_idle_o <= 1;\n                    end\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                end\n            endcase\n        end\n    end\n\n    // Debounce logic for card detect\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 0;\n            card_present <= 0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1;\n            end else begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        end\n    end\n\n    // Synchronize req_in and ack_in signals\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_in_q <= 0;\n            req_in_int <= 0;\n            ack_in_q <= 0;\n            ack_in_int <= 0;\n        end else begin\n            req_in_q <= req_in;\n            req_in_int <= req_in_q;\n            ack_in_q <= ack_in;\n            ack_in_int <= ack_in_q;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Combinational logic for inv calculation\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Reset CRC to 0\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        // Update CRC based on the enable signal\n        CRC <= {CRC[14:0], 1'b0}; // Shift left\n        CRC[12] <= CRC[11] ^ inv; // Update CRC[12]\n        CRC[5] <= CRC[4] ^ inv;   // Update CRC[5]\n        CRC[0] <= inv;            // Set CRC[0] to inv\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Debounce Logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Synchronization Registers\n    reg ack_q, ack_in_int;\n    reg req_q, req_in_int;\n\n    // FSM Registers\n    reg [2:0] state, next_state;\n    reg [15:0] Watchdog_Cnt;\n    wire complete;\n\n    // Reset and Clock Handling\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n            debounce <= 0;\n            card_present <= 0;\n            ack_q <= 0;\n            ack_in_int <= 0;\n            req_q <= 0;\n            req_in_int <= 0;\n            STATUS_REG <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            go_idle_o <= 0;\n            cmd_out <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            Watchdog_Cnt <= 0;\n        end else begin\n            // Debounce Logic\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n            end else begin\n                debounce <= 0;\n            end\n            card_present <= (debounce == 4'b1111);\n\n            // Synchronization Logic\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n            req_q <= req_in;\n            req_in_int <= req_q;\n\n            // FSM Logic\n            state <= next_state;\n\n            // Reset Interrupt Registers\n            if (ERR_INT_RST) ERR_INT_REG <= 0;\n            if (NORMAL_INT_RST) NORMAL_INT_REG <= 0;\n\n            // Watchdog Counter\n            if (state == EXECUTE) begin\n                if (Watchdog_Cnt < TIMEOUT_REG)\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n            end else begin\n                Watchdog_Cnt <= 0;\n            end\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state; // Default to hold current state\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output Logic based on Current State\n    always @(posedge CLK_PAD_IO) begin\n        case (state)\n            IDLE: begin\n                go_idle_o <= 0;\n                req_out <= 0;\n                ack_out <= 0;\n                if (req_in_int) begin\n                    STATUS_REG <= serial_status;\n                    ack_out <= 1;\n                end\n            end\n            SETUP: begin\n                cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], 7'b0101000};\n                NORMAL_INT_REG <= 0;\n                ERR_INT_REG <= 0;\n            end\n            EXECUTE: begin\n                if (ack_in_int) begin\n                    req_out <= 1;\n                end\n                if (req_in_int) begin\n                    STATUS_REG <= serial_status;\n                    ack_out <= 1;\n                    if (serial_status[6]) begin\n                        complete <= 1;\n                        NORMAL_INT_REG[0] <= 1;\n                    end\n                end\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    ERR_INT_REG[0] <= 1; // Command Timeout Error\n                    NORMAL_INT_REG[15] <= 1; // Error Interrupt\n                    go_idle_o <= 1;\n                end\n            end\n        endcase\n    end\n\n    assign complete = (state == EXECUTE && (NORMAL_INT_REG[0] || ERR_INT_REG != 0));\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            SD_CLK <= ~SD_CLK;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for FSM\n    reg [2:0] state, next_state;\n\n    // Registers for Debounce Logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Registers for Synchronizers\n    reg ack_q, ack_in_int;\n    reg req_q, req_in_int;\n\n    // Registers for FSM operation\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [6:0] response_size;\n\n    // Clock and Reset\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n            STATUS_REG <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            go_idle_o <= 0;\n            cmd_out <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            debounce <= 0;\n            card_present <= 0;\n            ack_q <= 0;\n            ack_in_int <= 0;\n            req_q <= 0;\n            req_in_int <= 0;\n            Watchdog_Cnt <= 0;\n            complete <= 0;\n            index_check_enable <= 0;\n            CRC_check_enable <= 0;\n            response_size <= 0;\n        end else begin\n            state <= next_state;\n\n            // Debounce Logic\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1;\n            end else begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n\n            // Synchronizers\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n            req_q <= req_in;\n            req_in_int <= req_q;\n\n            // FSM Operation\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    if (New_CMD) begin\n                        next_state <= SETUP;\n                    end\n                end\n                SETUP: begin\n                    if (ack_in_int) begin\n                        next_state <= EXECUTE;\n                        cmd_out[39:38] <= 2'b01;\n                        cmd_out[37:32] <= CMD_SET_REG[13:8];\n                        cmd_out[31:0] <= ARG_REG;\n                        settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                        index_check_enable <= CMD_SET_REG[4];\n                        CRC_check_enable <= CMD_SET_REG[3];\n                        response_size <= (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) ? 7'b0101000 :\n                                         (CMD_SET_REG[1:0] == 2'b01) ? 7'b1111111 : 7'b0;\n                    end\n                end\n                EXECUTE: begin\n                    if (complete) begin\n                        next_state <= IDLE;\n                    end else begin\n                        if (Watchdog_Cnt > TIMEOUT_REG) begin\n                            ERR_INT_REG[0] <= 1; // CTE\n                            ERR_INT_REG[3] <= 1; // EI\n                            go_idle_o <= 1;\n                        end\n                        if (req_in_int) begin\n                            STATUS_REG <= serial_status;\n                            ack_out <= 1;\n                            if (serial_status[6]) begin\n                                complete <= 1;\n                                NORMAL_INT_REG[0] <= 1; // CC\n                                if (CRC_check_enable && !serial_status[5]) begin\n                                    ERR_INT_REG[1] <= 1; // CCRCE\n                                    ERR_INT_REG[3] <= 1; // EI\n                                end\n                                if (index_check_enable && cmd_out[37:32] != cmd_in[37:32]) begin\n                                    ERR_INT_REG[3] <= 1; // CIE\n                                    ERR_INT_REG[3] <= 1; // EI\n                                end\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                        Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    end\n                end\n                default: begin\n                    next_state <= IDLE;\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for state machine\n    reg [2:0] state, next_state;\n\n    // Registers for debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Registers for synchronization\n    reg req_in_q, req_in_int;\n    reg ack_in_q, ack_in_int;\n\n    // Registers for FSM operation\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [6:0] response_size;\n\n    // Clock and Reset\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n            debounce <= 0;\n            card_present <= 0;\n            req_in_q <= 0;\n            req_in_int <= 0;\n            ack_in_q <= 0;\n            ack_in_int <= 0;\n            STATUS_REG <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            go_idle_o <= 0;\n            cmd_out <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            Watchdog_Cnt <= 0;\n            complete <= 0;\n            index_check_enable <= 0;\n            CRC_check_enable <= 0;\n            response_size <= 0;\n        end else begin\n            state <= next_state;\n            debounce_logic;\n            sync_req_ack;\n            fsm_operations;\n        end\n    end\n\n    // Debounce Logic\n    task debounce_logic;\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1;\n            if (debounce == 4'b1111)\n                card_present <= 1;\n        end else begin\n            debounce <= 0;\n            card_present <= 0;\n        end\n    endtask\n\n    // Request and Acknowledge Synchronizers\n    task sync_req_ack;\n        req_in_q <= req_in;\n        req_in_int <= req_in_q;\n        ack_in_q <= ack_in;\n        ack_in_int <= ack_in_q;\n    endtask\n\n    // FSM Operations\n    task fsm_operations;\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state <= SETUP;\n                else\n                    next_state <= IDLE;\n                go_idle_o <= 0;\n                req_out <= 0;\n                ack_out <= 0;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state <= EXECUTE;\n                else\n                    next_state <= SETUP;\n                settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], response_size};\n                cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                index_check_enable <= CMD_SET_REG[4];\n                CRC_check_enable <= CMD_SET_REG[3];\n                response_size <= (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) ? 7'b0101000 : \n                                 (CMD_SET_REG[1:0] == 2'b01) ? 7'b1111111 : 7'b0;\n                Watchdog_Cnt <= 0;\n            end\n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1;\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    ERR_INT_REG[0] <= 1; // CTE\n                    NORMAL_INT_REG[15] <= 1; // EI\n                    go_idle_o <= 1;\n                end\n                if (ack_in_int) begin\n                    req_out <= 1;\n                    complete <= 1;\n                end\n                if (req_in_int) begin\n                    STATUS_REG <= serial_status;\n                    ack_out <= 1;\n                    if (serial_status[6]) begin\n                        complete <= 1;\n                        NORMAL_INT_REG[0] <= 1; // CC\n                        if (CRC_check_enable && !serial_status[5])\n                            ERR_INT_REG[1] <= 1; // CCRCE\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32]))\n                            ERR_INT_REG[3] <= 1; // CIE\n                    end\n                    if (response_size != 0)\n                        RESP_1_REG <= cmd_in[31:0];\n                end\n                if (complete)\n                    next_state <= IDLE;\n                else\n                    next_state <= EXECUTE;\n            end\n            default: next_state <= IDLE;\n        endcase\n    endtask\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Registers for state machine\n    reg [2:0] state, next_state;\n\n    // Debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Synchronization registers\n    reg req_in_q, req_in_int;\n    reg ack_in_q, ack_in_int;\n\n    // Watchdog counter\n    reg [15:0] Watchdog_Cnt;\n\n    // FSM combinational logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (Watchdog_Cnt > TIMEOUT_REG || (req_in_int && serial_status[6]))\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Output logic based on current state\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            STATUS_REG <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            go_idle_o <= 0;\n            cmd_out <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            Watchdog_Cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                SETUP: begin\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], 7'b0000000};\n                    req_out <= 0;\n                    ack_out <= 0;\n                    Watchdog_Cnt <= 0;\n                end\n                EXECUTE: begin\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1; // CTE\n                        NORMAL_INT_REG[15] <= 1; // EI\n                        go_idle_o <= 1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                        if (serial_status[6]) begin\n                            NORMAL_INT_REG[0] <= 1; // CC\n                        end\n                    end\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                end\n            endcase\n        end\n    end\n\n    // Debounce logic for card detection\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 0;\n            card_present <= 0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1;\n            end else begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        end\n    end\n\n    // Synchronize req_in and ack_in signals\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_in_q <= 0;\n            req_in_int <= 0;\n            ack_in_q <= 0;\n            ack_in_int <= 0;\n        end else begin\n            req_in_q <= req_in;\n            req_in_int <= req_in_q;\n            ack_in_q <= ack_in;\n            ack_in_int <= ack_in_q;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for state machine\n    reg [2:0] state, next_state;\n\n    // Registers for debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Registers for synchronization\n    reg req_in_q, req_in_int;\n    reg ack_in_q, ack_in_int;\n\n    // Registers for internal operations\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n\n    // FSM state transition logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Output logic based on current state\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            go_idle_o <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            STATUS_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            cmd_out <= 0;\n            RESP_1_REG <= 0;\n            Watchdog_Cnt <= 0;\n            complete <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], 7'b0000000};\n                    Watchdog_Cnt <= 0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1; // CTE\n                        ERR_INT_REG[3] <= 1; // EI\n                        go_idle_o <= 1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                        complete <= 1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                        if (serial_status[6]) begin\n                            complete <= 1;\n                            NORMAL_INT_REG[0] <= 1; // CC\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Debounce logic for card detection\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 0;\n            card_present <= 0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1;\n            end else begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        end\n    end\n\n    // Synchronization of req_in and ack_in signals\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_in_q <= 0;\n            req_in_int <= 0;\n            ack_in_q <= 0;\n            ack_in_int <= 0;\n        end else begin\n            req_in_q <= req_in;\n            req_in_int <= req_in_q;\n            ack_in_q <= ack_in;\n            ack_in_int <= ack_in_q;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_clock_divider", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_clock_divider(\n    input wire CLK,\n    input wire [7:0] DIVIDER,\n    input wire RST,\n    output reg SD_CLK\n);\n\nreg [7:0] counter;\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        counter <= 0;\n        SD_CLK <= 0;\n    end else begin\n        if (counter >= DIVIDER) begin\n            counter <= 0;\n            SD_CLK <= ~SD_CLK;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Submodule instantiation\n    sd_tx_fifo tx_fifo(\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               WAIT_ACK = 1,\n               WRITE_FIFO = 2,\n               POST_WRITE = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && !m_wb_ack_i && ackd)\n                    next_state = WAIT_ACK;\n                else\n                    next_state = IDLE;\n            end\n            WAIT_ACK: begin\n                if (m_wb_ack_i)\n                    next_state = WRITE_FIFO;\n                else\n                    next_state = WAIT_ACK;\n            end\n            WRITE_FIFO: begin\n                next_state = POST_WRITE;\n            end\n            POST_WRITE: begin\n                if (delay)\n                    next_state = IDLE;\n                else\n                    next_state = POST_WRITE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic and control signal updates\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            case (next_state)\n                IDLE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00;  // Linear burst\n                    reset_tx_fifo <= 0;\n                    if (first) begin\n                        ackd <= 1;\n                        first <= 0;\n                    end\n                end\n                WAIT_ACK: begin\n                    // Wait for acknowledgment\n                end\n                WRITE_FIFO: begin\n                    wr_tx <= 1;\n                end\n                POST_WRITE: begin\n                    wr_tx <= 0;\n                    offset <= offset + 1;\n                    ackd <= !ackd;\n                    delay <= !delay;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [8:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register definitions based on address\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1; // Default to high\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 9'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the wishbone transaction\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    // Additional cases for other writable registers\n                    default: ;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'b0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'b0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    8'h4c: wb_dat_o <= {24'b0, clock_divider};\n                    8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    // Additional cases for other readable registers\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0; // De-assert acknowledge when not in a valid cycle\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire sd_clk,\n    input wire en,\n    input wire [31:0] adr,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output reg empty,\n    output reg fe,\n    output wire reset_tx_fifo\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Submodule instantiation\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               WAIT_ACK = 1,\n               WRITE_FIFO = 2,\n               DELAY = 3;\n\n    reg [1:0] state, next_state;\n\n    // Asynchronous reset\n    assign reset_tx_fifo = rst;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && !m_wb_ack_i && ackd)\n                    next_state = WAIT_ACK;\n                else\n                    next_state = IDLE;\n            end\n            WAIT_ACK: begin\n                if (m_wb_ack_i)\n                    next_state = WRITE_FIFO;\n                else\n                    next_state = WAIT_ACK;\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic and memory address management\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n            din <= 0;\n            wr_tx <= 0;\n            offset <= 0;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (en && !fe && !m_wb_ack_i && ackd) begin\n                        m_wb_adr_o <= adr + offset;\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 1;\n                        m_wb_stb_o <= 1;\n                        m_wb_cti_o <= 3'b000;\n                        m_wb_bte_o <= 2'b00;\n                    end\n                end\n                WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        din <= m_wb_dat_i;\n                        wr_tx <= 1;\n                    end\n                end\n                WRITE_FIFO: begin\n                    wr_tx <= 0;\n                    ackd <= 0;\n                    delay <= 1;\n                end\n                DELAY: begin\n                    offset <= offset + 4;\n                    ackd <= 1;\n                    delay <= 0;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Combinational logic for inv calculation\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        // CRC update logic on clock edge\n        CRC <= {CRC[14:0], 1'b0}; // Shift left\n        CRC[12] <= CRC[11] ^ inv;\n        CRC[5] <= CRC[4] ^ inv;\n        CRC[0] <= inv;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\n// Intermediate signal for inverse calculation\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for state machine\n    reg [2:0] state, next_state;\n\n    // Registers for debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Registers for synchronizing req and ack signals\n    reg req_q, req_in_int;\n    reg ack_q, ack_in_int;\n\n    // Registers for internal use\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n\n    // FSM state transition logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Debounce logic for card detection\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 0;\n            card_present <= 0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1;\n            end else begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        end\n    end\n\n    // Synchronizers for req and ack signals\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 0;\n            req_in_int <= 0;\n            ack_q <= 0;\n            ack_in_int <= 0;\n        end else begin\n            req_q <= req_in;\n            req_in_int <= req_q;\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // FSM output logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            go_idle_o <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            STATUS_REG <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            cmd_out <= 0;\n            Watchdog_Cnt <= 0;\n            complete <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CMD_SET_REG[3];\n                    settings[6:0] <= (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) ? 7'b0101000 : \n                                     (CMD_SET_REG[1:0] == 2'b01) ? 7'b1111111 : 7'b0000000;\n                    Watchdog_Cnt <= 0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1; // CTE\n                        ERR_INT_REG[3] <= 1; // EI\n                        go_idle_o <= 1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                        complete <= 1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                        if (serial_status[6]) begin\n                            complete <= 1;\n                            NORMAL_INT_REG[0] <= 1; // CC\n                            if (CMD_SET_REG[4] && !serial_status[5]) begin\n                                ERR_INT_REG[1] <= 1; // CCRCE\n                                ERR_INT_REG[3] <= 1; // EI\n                            end\n                            if (CMD_SET_REG[3] && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1; // CIE\n                                ERR_INT_REG[3] <= 1; // EI\n                            end\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Define register addresses\n    localparam ADDR_ARGUMENT           = 8'h00;\n    localparam ADDR_CMD_SETTING        = 8'h04;\n    localparam ADDR_CARD_STATUS        = 8'h08;\n    localparam ADDR_RESPONSE           = 8'h0C;\n    localparam ADDR_SOFTWARE_RESET     = 8'h28;\n    localparam ADDR_TIMEOUT            = 8'h2C;\n    localparam ADDR_NORMAL_INT_STATUS  = 8'h30;\n    localparam ADDR_ERROR_INT_STATUS   = 8'h34;\n    localparam ADDR_NORMAL_INT_ENABLE  = 8'h38;\n    localparam ADDR_ERROR_INT_ENABLE   = 8'h3C;\n    localparam ADDR_CLOCK_DIVIDER      = 8'h4C;\n    localparam ADDR_BD_RX              = 8'h60;\n    localparam ADDR_BD_TX              = 8'h80;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers and outputs\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1;  // Acknowledge the Wishbone transaction\n            if (wb_we_i) begin\n                // Handle write operations\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: argument_reg <= wb_dat_i;\n                    ADDR_CMD_SETTING: cmd_setting_reg <= wb_dat_i[15:0];\n                    ADDR_SOFTWARE_RESET: software_reset_reg <= wb_dat_i[7:0];\n                    ADDR_TIMEOUT: time_out_reg <= wb_dat_i[15:0];\n                    ADDR_NORMAL_INT_ENABLE: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_ERROR_INT_ENABLE: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_CLOCK_DIVIDER: clock_divider <= wb_dat_i[7:0];\n                    ADDR_BD_RX: begin\n                        dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        we_m_rx_bd <= 1'b1;\n                    end\n                    ADDR_BD_TX: begin\n                        dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        we_m_tx_bd <= 1'b1;\n                    end\n                    default: ;\n                endcase\n            end else begin\n                // Handle read operations\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: wb_dat_o <= argument_reg;\n                    ADDR_CMD_SETTING: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    ADDR_CARD_STATUS: wb_dat_o <= {16'b0, status_reg};\n                    ADDR_RESPONSE: wb_dat_o <= cmd_resp_1;\n                    ADDR_SOFTWARE_RESET: wb_dat_o <= {24'b0, software_reset_reg};\n                    ADDR_TIMEOUT: wb_dat_o <= {16'b0, time_out_reg};\n                    ADDR_NORMAL_INT_STATUS: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    ADDR_ERROR_INT_STATUS: wb_dat_o <= {16'b0, error_int_status_reg};\n                    ADDR_NORMAL_INT_ENABLE: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    ADDR_ERROR_INT_ENABLE: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    ADDR_CLOCK_DIVIDER: wb_dat_o <= {24'b0, clock_divider};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    localparam CMD24 = 16'h181A;\n    localparam CMD17 = 16'h111A;\n    localparam CMD12 = 16'hC1A;\n    localparam ACMD13 = 16'hD1A;\n    localparam ACMD51 = 16'h331A;\n    localparam SIZE = 9;\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n    localparam RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed;\n    reg [1:0] bd_cnt;\n\n    // FSM logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM next state logic\n    always @(*) begin\n        next_state = state; // Default to hold current state\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY)\n                    next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY)\n                    next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full)\n                    next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1)\n                    next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done)\n                    next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done)\n                    next_state = DATA_TRANSFER;\n                else if (rec_failed)\n                    next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done)\n                    next_state = IDLE;\n                else if (trans_failed)\n                    next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM output logic\n    always @(state) begin\n        // Reset all outputs\n        re_s_tx = 0;\n        a_cmp_tx = 0;\n        re_s_rx = 0;\n        a_cmp_rx = 0;\n        we_req = 0;\n        d_write = 0;\n        d_read = 0;\n        cmd_arg = 0;\n        cmd_set = 0;\n        start_tx_fifo = 0;\n        start_rx_fifo = 0;\n        sys_adr = 0;\n        ack_transfer = 0;\n        Dat_Int_Status = 0;\n        CIDAT = 0;\n\n        case (state)\n            GET_TX_BD: begin\n                re_s_tx = 1;\n                if (ack_i_s_tx) begin\n                    sys_adr = dat_in_tx;\n                    cmd_arg = dat_in_tx;\n                    start_tx_fifo = 1;\n                    cmd_set = CMD24;\n                    tx_cycle = 1;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx = 1;\n                if (ack_i_s_rx) begin\n                    sys_adr = dat_in_rx;\n                    cmd_arg = dat_in_rx;\n                    start_rx_fifo = 1;\n                    cmd_set = CMD17;\n                    rx_cycle = 1;\n                end\n            end\n            SEND_CMD: begin\n                we_req = 1;\n                if (we_ack) begin\n                    send_done = 1;\n                    d_write = tx_cycle;\n                    d_read = rx_cycle;\n                end\n            end\n            RECIVE_CMD: begin\n                if (!cmd_busy && !cmd_tsf_err && card_status[0]) begin\n                    rec_done = 1;\n                end else if (cmd_tsf_err) begin\n                    rec_failed = 1;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete && crc_ok) begin\n                    trans_done = 1;\n                    ack_transfer = 1;\n                    a_cmp_tx = tx_cycle;\n                    a_cmp_rx = rx_cycle;\n                end else if (!crc_ok) begin\n                    trans_failed = 1;\n                end\n            end\n            STOP_SEND: begin\n                cmd_set = CMD12;\n                send_done = 1;\n            end\n        endcase\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\n// Intermediate signal for inversion calculation\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset of CRC\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Update CRC only when Enable is high\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Internal signals\n    reg [31:0] internal_regs [0:255]; // Assuming 256 registers for simplicity\n    wire [7:0] reg_index = wb_adr_i[9:2]; // Extracting register index from address\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers and outputs\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1; // Default to high\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else begin\n            if (wb_cyc_i && wb_stb_i) begin\n                wb_ack_o <= 1'b1; // Acknowledge the Wishbone transaction\n                if (wb_we_i) begin\n                    // Write operation\n                    case (wb_adr_i)\n                        8'h00: argument_reg <= wb_dat_i;\n                        8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                        8'h28: software_reset_reg <= wb_dat_i[7:0];\n                        8'h2c: time_out_reg <= wb_dat_i[15:0];\n                        8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                        8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                        8'h4c: clock_divider <= wb_dat_i[7:0];\n                        8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                        // Add more cases as needed\n                    endcase\n                end else begin\n                    // Read operation\n                    case (wb_adr_i)\n                        8'h00: wb_dat_o <= argument_reg;\n                        8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                        8'h08: wb_dat_o <= {16'b0, status_reg};\n                        8'h0c: wb_dat_o <= cmd_resp_1;\n                        8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                        8'h2c: wb_dat_o <= {16'b0, time_out_reg};\n                        8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                        8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                        8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                        8'h3c: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                        8'h4c: wb_dat_o <= {24'b0, clock_divider};\n                        8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                        8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                        8'h58: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                        // Add more cases as needed\n                    endcase\n                end\n            end else begin\n                wb_ack_o <= 1'b0; // De-assert ack if not in a valid cycle\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Parameters\nlocalparam BD_SIZE_HALF = BD_SIZE >> 1;\nlocalparam BD_SIZE_QUARTER = BD_SIZE >> 2;\n\n// Registers\nreg [BD_WIDTH-1:0] m_wr_pnt;\nreg [BD_WIDTH-1:0] s_rd_pnt;\nreg [BD_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? BD_SIZE_HALF : BD_SIZE_QUARTER;\n        last_a_cmp <= 0;\n    end else begin\n        // Write Buffer Descriptor\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            free_bd <= free_bd - 1;\n        end\n\n        // Read Buffer Descriptor\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            ack_o_s <= 1;\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Releasing Buffer Descriptor\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for state machine\n    reg [2:0] state, next_state;\n\n    // Registers for debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Registers for synchronization\n    reg req_in_q, req_in_int;\n    reg ack_in_q, ack_in_int;\n\n    // Registers for FSM operation\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [6:0] response_size;\n    reg crc_valid, dat_ava;\n\n    // Clock and Reset\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n            debounce <= 0;\n            card_present <= 0;\n            req_in_q <= 0;\n            req_in_int <= 0;\n            ack_in_q <= 0;\n            ack_in_int <= 0;\n            STATUS_REG <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            go_idle_o <= 0;\n            cmd_out <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            Watchdog_Cnt <= 0;\n            complete <= 0;\n            index_check_enable <= 0;\n            CRC_check_enable <= 0;\n            response_size <= 0;\n            crc_valid <= 0;\n            dat_ava <= 0;\n        end else begin\n            state <= next_state;\n            debounce_logic;\n            synchronize_signals;\n            fsm_operations;\n        end\n    end\n\n    // Debounce Logic\n    task debounce_logic;\n        if (!card_detect) begin\n            if (debounce != 4'b1111)\n                debounce <= debounce + 1;\n            else\n                card_present <= 1;\n        end else begin\n            debounce <= 0;\n            card_present <= 0;\n        end\n    endtask\n\n    // Synchronize req_in and ack_in\n    task synchronize_signals;\n        req_in_q <= req_in;\n        req_in_int <= req_in_q;\n        ack_in_q <= ack_in;\n        ack_in_int <= ack_in_q;\n    endtask\n\n    // FSM Operations\n    task fsm_operations;\n        case (state)\n            IDLE: begin\n                if (New_CMD) begin\n                    next_state <= SETUP;\n                end else begin\n                    next_state <= IDLE;\n                end\n                go_idle_o <= 0;\n                req_out <= 0;\n                ack_out <= 0;\n                STATUS_REG[0] <= 0; // CICMD\n            end\n            SETUP: begin\n                if (ack_in_int) begin\n                    next_state <= EXECUTE;\n                end else begin\n                    next_state <= SETUP;\n                end\n                NORMAL_INT_REG <= 0;\n                ERR_INT_REG <= 0;\n                index_check_enable <= CMD_SET_REG[4];\n                CRC_check_enable <= CMD_SET_REG[3];\n                cmd_out[39:38] <= 2'b01;\n                cmd_out[37:32] <= CMD_SET_REG[13:8];\n                cmd_out[31:0] <= ARG_REG;\n                response_size <= (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) ? 7'b0101000 :\n                                 (CMD_SET_REG[1:0] == 2'b01) ? 7'b1111111 : 7'b0000000;\n                settings[14:13] <= CMD_SET_REG[7:6];\n                settings[12] <= data_read;\n                settings[11] <= data_write;\n                settings[10:8] <= 3'b111; // Delay\n                settings[7] <= CMD_SET_REG[3]; // CRCE\n                settings[6:0] <= response_size;\n                Watchdog_Cnt <= 0;\n            end\n            EXECUTE: begin\n                Watchdog_Cnt <= Watchdog_Cnt + 1;\n                if (Watchdog_Cnt > TIMEOUT_REG) begin\n                    ERR_INT_REG[0] <= 1; // CTE\n                    NORMAL_INT_REG[15] <= 1; // EI\n                    complete <= 1;\n                    go_idle_o <= 1;\n                end\n                if (ack_in_int) begin\n                    req_out <= 1;\n                end\n                if (req_in_int) begin\n                    STATUS_REG <= serial_status;\n                    ack_out <= 1;\n                    if (serial_status[6]) begin\n                        complete <= 1;\n                        NORMAL_INT_REG[0] <= 1; // CC\n                        if (CRC_check_enable && !crc_valid) begin\n                            ERR_INT_REG[1] <= 1; // CCRCE\n                            NORMAL_INT_REG[15] <= 1; // EI\n                        end\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            ERR_INT_REG[3] <= 1; // CIE\n                            NORMAL_INT_REG[15] <= 1; // EI\n                        end\n                        if (response_size != 0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n                next_state <= complete ? IDLE : EXECUTE;\n            end\n            default: begin\n                next_state <= IDLE;\n            end\n        endcase\n    endtask\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    localparam CMD24 = 16'h181A;\n    localparam CMD17 = 16'h111A;\n    localparam CMD12 = 16'hC1A;\n    localparam ACMD13 = 16'hD1A;\n    localparam ACMD51 = 16'h331A;\n    localparam SIZE = 9;\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n    localparam RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed;\n    reg [2:0] bd_cnt;\n\n    // FSM logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n        end else begin\n            state <= next_state;\n            if (state == STOP_SEND && send_done) begin\n                resend_try_cnt <= resend_try_cnt + 1;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state; // Default to hold state\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY)\n                    next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY)\n                    next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full)\n                    next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1)\n                    next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done)\n                    next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done)\n                    next_state = DATA_TRANSFER;\n                else if (rec_failed)\n                    next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done)\n                    next_state = IDLE;\n                else if (trans_failed)\n                    next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done)\n                    next_state = IDLE;\n            end\n        end\n    end\n\n    // Output logic based on state\n    always @(state) begin\n        // Reset outputs\n        re_s_tx = 0;\n        a_cmp_tx = 0;\n        re_s_rx = 0;\n        a_cmp_rx = 0;\n        we_req = 0;\n        d_write = 0;\n        d_read = 0;\n        start_tx_fifo = 0;\n        start_rx_fifo = 0;\n        ack_transfer = 0;\n        Dat_Int_Status = 0;\n        CIDAT = 0;\n\n        case (state)\n            GET_TX_BD: begin\n                re_s_tx = 1;\n                if (ack_i_s_tx) begin\n                    sys_adr = dat_in_tx;\n                    cmd_arg = dat_in_tx;\n                    start_tx_fifo = 1;\n                    cmd_set = CMD24;\n                    tx_cycle = 1;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx = 1;\n                if (ack_i_s_rx) begin\n                    sys_adr = dat_in_rx;\n                    cmd_arg = dat_in_rx;\n                    start_rx_fifo = 1;\n                    cmd_set = transfer_type == 2'b00 ? CMD17 : (transfer_type == 2'b01 ? ACMD13 : ACMD51);\n                    rx_cycle = 1;\n                end\n            end\n            SEND_CMD: begin\n                we_req = 1;\n                d_write = tx_cycle;\n                d_read = rx_cycle;\n            end\n            RECIVE_CMD: begin\n                if (!cmd_busy) begin\n                    rec_done = 1;\n                    start_rx_fifo = rx_cycle;\n                end else if (cmd_tsf_err) begin\n                    rec_failed = 1;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete && crc_ok) begin\n                    trans_done = 1;\n                    ack_transfer = 1;\n                    a_cmp_tx = tx_cycle;\n                    a_cmp_rx = rx_cycle;\n                end else if (!crc_ok) begin\n                    trans_failed = 1;\n                end\n            end\n            STOP_SEND: begin\n                cmd_set = CMD12;\n                we_req = 1;\n            end\n        end\n    end\n\n    // Handle Dat_Int_Status reset\n    always @(posedge Dat_Int_Status_rst) begin\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status = 0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Inverse calculation based on the highest bit of the current CRC and the input bit\n        wire inv = BITVAL ^ CRC[6];\n\n        // Update CRC values\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // State Definitions\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [SIZE-1:0] state, next_state;\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_IN, CRC_OUT, CRC_Enable, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in;\n    reg q1, Ack_internal_in;\n\n    // REQ_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 1'b0;\n            Req_internal_in <= 1'b0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 1'b0;\n            Ack_internal_in <= 1'b0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = (Write_Read) ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN) begin\n        case (state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                CMD_OUT <= 0;\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS <= 0;\n            end\n            WRITE_WR: begin\n                cmd_oe_o <= 1;\n                CMD_OUT <= In_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n                STATUS[3:0] <= 4'b0001;\n            end\n            WRITE_WO: begin\n                cmd_oe_o <= 1;\n                CMD_OUT <= In_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n                STATUS[3:0] <= 4'b0010;\n            end\n            DLY_WR: begin\n                cmd_oe_o <= 0;\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS[3:0] <= 4'b0011;\n            end\n            DLY_WO: begin\n                cmd_oe_o <= 0;\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS[3:0] <= 4'b0100;\n            end\n            READ_WR: begin\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n                STATUS[3:0] <= 4'b0101;\n            end\n            DLY_READ: begin\n                cmd_oe_o <= 0;\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS[3:0] <= 4'b0110;\n            end\n            ACK_WO: begin\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS[3:0] <= 4'b0111;\n            end\n            ACK_WR: begin\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS[3:0] <= 4'b1000;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 1, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [15:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Submodule Instances\n    sd_crc_16 crc_gen (\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // State Definitions\n    localparam IDLE        = 6'b000001;\n    localparam WRITE_DAT   = 6'b000010;\n    localparam WRITE_CRC   = 6'b000100;\n    localparam WRITE_BUSY  = 6'b001000;\n    localparam READ_WAIT   = 6'b010000;\n    localparam READ_DAT    = 6'b100000;\n\n    // FSM_COMBO Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM_SEQ Logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM_OUT Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            // Normal operation logic\n        end\n    end\n\n    // ACK_SYNC Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // START_SYNC Logic\n    always @(posedge sd_clk) begin\n        if (rst)\n            q_start_bit <= 1;\n        else if (!DAT_dat_i[0] && state == READ_WAIT)\n            q_start_bit <= 0;\n        else\n            q_start_bit <= 1;\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Synchronization registers\n    reg req_q, req_in_int;\n    reg ack_q, ack_in_int;\n\n    // FSM state registers\n    reg [2:0] state, next_state;\n\n    // Watchdog counter\n    reg [15:0] Watchdog_Cnt;\n\n    // Internal signals\n    wire complete;\n    wire index_check_enable = CMD_SET_REG[4];\n    wire CRC_check_enable = CMD_SET_REG[3];\n    wire [5:0] CMDI = CMD_SET_REG[13:8];\n    wire [1:0] WORD_SELECT = CMD_SET_REG[7:6];\n    wire [1:0] RTS = CMD_SET_REG[1:0];\n    wire crc_valid = serial_status[5];\n    wire dat_ava = serial_status[6];\n\n    // Debounce logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 0;\n            card_present <= 0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1;\n            end else begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        end\n    end\n\n    // Synchronization logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 0;\n            req_in_int <= 0;\n            ack_q <= 0;\n            ack_in_int <= 0;\n        end else begin\n            req_q <= req_in;\n            req_in_int <= req_q;\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // FSM logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = New_CMD ? SETUP : IDLE;\n            SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = complete ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            STATUS_REG <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            go_idle_o <= 0;\n            cmd_out <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            Watchdog_Cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMDI;\n                    cmd_out[31:0] <= ARG_REG;\n                    settings[14:13] <= WORD_SELECT;\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CRC_check_enable;\n                    settings[6:0] <= (RTS == 2'b10 || RTS == 2'b11) ? 7'b0101000 : (RTS == 2'b01 ? 7'b1111111 : 7'b0000000);\n                    Watchdog_Cnt <= 0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1; // CTE\n                        NORMAL_INT_REG[15] <= 1; // EI\n                        go_idle_o <= 1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                        if (dat_ava) begin\n                            NORMAL_INT_REG[0] <= 1; // CC\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1; // CCRCE\n                                NORMAL_INT_REG[15] <= 1; // EI\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1; // CIE\n                                NORMAL_INT_REG[15] <= 1; // EI\n                            end\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Define register addresses\n    localparam ADDR_ARGUMENT           = 8'h00;\n    localparam ADDR_CMD_SETTING        = 8'h04;\n    localparam ADDR_CARD_STATUS        = 8'h08;\n    localparam ADDR_RESPONSE           = 8'h0C;\n    localparam ADDR_SOFTWARE_RESET     = 8'h28;\n    localparam ADDR_TIMEOUT            = 8'h2C;\n    localparam ADDR_NORMAL_INT_STATUS  = 8'h30;\n    localparam ADDR_ERROR_INT_STATUS   = 8'h34;\n    localparam ADDR_NORMAL_INT_ENABLE  = 8'h38;\n    localparam ADDR_ERROR_INT_ENABLE   = 8'h3C;\n    localparam ADDR_CLOCK_DIVIDER      = 8'h4C;\n    localparam ADDR_BD_STATUS          = 8'h50;\n    localparam ADDR_DAT_INT_STATUS     = 8'h54;\n    localparam ADDR_DAT_INT_ENABLE     = 8'h58;\n    localparam ADDR_BD_RX              = 8'h60;\n    localparam ADDR_BD_TX              = 8'h80;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the Wishbone transaction\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: argument_reg <= wb_dat_i;\n                    ADDR_CMD_SETTING: cmd_setting_reg <= wb_dat_i[15:0];\n                    ADDR_SOFTWARE_RESET: software_reset_reg <= wb_dat_i[7:0];\n                    ADDR_TIMEOUT: time_out_reg <= wb_dat_i[15:0];\n                    ADDR_NORMAL_INT_ENABLE: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_ERROR_INT_ENABLE: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_CLOCK_DIVIDER: clock_divider <= wb_dat_i[7:0];\n                    ADDR_DAT_INT_ENABLE: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    ADDR_BD_RX: begin\n                        dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        we_m_rx_bd <= 1'b1;\n                    end\n                    ADDR_BD_TX: begin\n                        dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        we_m_tx_bd <= 1'b1;\n                    end\n                    default: ;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: wb_dat_o <= argument_reg;\n                    ADDR_CMD_SETTING: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    ADDR_CARD_STATUS: wb_dat_o <= {16'b0, status_reg};\n                    ADDR_RESPONSE: wb_dat_o <= cmd_resp_1;\n                    ADDR_SOFTWARE_RESET: wb_dat_o <= {24'b0, software_reset_reg};\n                    ADDR_TIMEOUT: wb_dat_o <= {16'b0, time_out_reg};\n                    ADDR_NORMAL_INT_STATUS: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    ADDR_ERROR_INT_STATUS: wb_dat_o <= {16'b0, error_int_status_reg};\n                    ADDR_NORMAL_INT_ENABLE: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    ADDR_ERROR_INT_ENABLE: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    ADDR_CLOCK_DIVIDER: wb_dat_o <= {24'b0, clock_divider};\n                    ADDR_BD_STATUS: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    ADDR_DAT_INT_STATUS: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    ADDR_DAT_INT_ENABLE: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master(\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for state machine\n    reg [2:0] state, next_state;\n\n    // Registers for debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Registers for synchronizers\n    reg req_in_q, req_in_int;\n    reg ack_in_q, ack_in_int;\n\n    // Registers for internal use\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n\n    // FSM state transition logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Debounce logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 0;\n            card_present <= 0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1;\n            end else begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_in_q <= 0;\n            req_in_int <= 0;\n            ack_in_q <= 0;\n            ack_in_int <= 0;\n        end else begin\n            req_in_q <= req_in;\n            req_in_int <= req_in_q;\n            ack_in_q <= ack_in;\n            ack_in_int <= ack_in_q;\n        end\n    end\n\n    // FSM output logic and internal operations\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            STATUS_REG <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            go_idle_o <= 0;\n            cmd_out <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            Watchdog_Cnt <= 0;\n            complete <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    if (req_in_int) begin\n                        STATUS_REG[6] <= serial_status[6];\n                        STATUS_REG[5] <= serial_status[5];\n                        ack_out <= 1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    STATUS_REG <= 0;\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111; // Delay\n                    settings[7] <= CMD_SET_REG[3]; // CRCE\n                    settings[6:0] <= (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) ? 7'b0101000 : \n                                     (CMD_SET_REG[1:0] == 2'b01) ? 7'b1111111 : 7'b0000000;\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n                    Watchdog_Cnt <= 0;\n                end\n                EXECUTE: begin\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1; // CTE\n                        NORMAL_INT_REG[15] <= 1; // EI\n                        go_idle_o <= 1;\n                    end else begin\n                        Watchdog_Cnt <= Watchdog_Cnt + 1;\n                        if (ack_in_int) begin\n                            req_out <= 1;\n                            if (req_in_int) begin\n                                STATUS_REG <= serial_status;\n                                ack_out <= 1;\n                                if (serial_status[6]) begin\n                                    complete <= 1;\n                                    NORMAL_INT_REG[0] <= 1; // CC\n                                    if (CMD_SET_REG[4] && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                        ERR_INT_REG[3] <= 1; // CIE\n                                        NORMAL_INT_REG[15] <= 1; // EI\n                                    end\n                                    if (CMD_SET_REG[3] && !serial_status[5]) begin\n                                        ERR_INT_REG[1] <= 1; // CCRCE\n                                        NORMAL_INT_REG[15] <= 1; // EI\n                                    end\n                                    if (settings[6:0] != 0) begin\n                                        RESP_1_REG <= cmd_in[31:0];\n                                    end\n                                end\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire mem_empty;\n    wire fifo_full;\n    wire fifo_empty;\n\n    // Instantiate the sd_rx_fifo submodule\n    sd_rx_fifo rx_fifo(\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .mem_empt(mem_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    // Assign external full and empty signals\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    // State machine for handling Wishbone transactions\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all control signals and registers\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end else begin\n            if (en) begin\n                reset_rx_fifo <= 1'b0;\n                if (!fifo_empty && wb_free) begin\n                    // Start reading from FIFO and prepare Wishbone transaction\n                    rd <= 1'b1;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1'b1;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00; // Linear burst\n                    wb_free <= 1'b0;\n                end\n                if (m_wb_ack_i) begin\n                    // Transaction acknowledged\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    offset <= offset + MEM_OFFSET;\n                    wb_free <= 1'b1;\n                end\n            end else begin\n                // Module disabled, reset all states\n                reset_rx_fifo <= 1'b1;\n                rd <= 1'b0;\n                offset <= 9'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\n// Intermediate signal for inverse calculation\nwire inv;\n\n// Compute inverse based on BITVAL and the most significant bit of CRC\nassign inv = BITVAL ^ CRC[6];\n\n// CRC update logic\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset of CRC\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Update CRC only when Enable is high\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\n    // When Enable is low, CRC retains its value (no else clause needed)\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [SD_BUS_W*16-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int, ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // State Definitions\n    localparam IDLE        = 6'b000001;\n    localparam WRITE_DAT   = 6'b000010;\n    localparam WRITE_CRC   = 6'b000100;\n    localparam WRITE_BUSY  = 6'b001000;\n    localparam READ_WAIT   = 6'b010000;\n    localparam READ_DAT    = 6'b100000;\n\n    // Submodule Instances\n    // CRC Generation Block\n    sd_crc_16 crc_gen (\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // Synchronization of ack_transfer\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b001)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0)\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM_SEQ Logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset conditions\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            // Normal operation\n            case (state)\n                WRITE_DAT: begin\n                    // Implement WRITE_DAT logic\n                end\n                WRITE_CRC: begin\n                    // Implement WRITE_CRC logic\n                end\n                WRITE_BUSY: begin\n                    // Implement WRITE_BUSY logic\n                end\n                READ_WAIT: begin\n                    // Implement READ_WAIT logic\n                end\n                READ_DAT: begin\n                    // Implement READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for state machine\n    reg [2:0] state, next_state;\n\n    // Registers for debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Registers for synchronization\n    reg ack_q, ack_in_int;\n    reg req_q, req_in_int;\n\n    // Registers for FSM operation\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [6:0] response_size;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1110)\n                    card_present <= 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n                card_present <= 1'b0;\n            end\n        end\n    end\n\n    // Synchronization of ack_in\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // Synchronization of req_in\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 1'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            req_q <= req_in;\n            req_in_int <= req_q;\n        end\n    end\n\n    // FSM Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = New_CMD ? SETUP : IDLE;\n            SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = complete ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic based on state\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            go_idle_o <= 1'b0;\n            req_out <= 1'b0;\n            ack_out <= 1'b0;\n            STATUS_REG <= 16'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            settings <= 16'b0;\n            cmd_out <= 40'b0;\n            Watchdog_Cnt <= 16'b0;\n            complete <= 1'b0;\n            index_check_enable <= 1'b0;\n            CRC_check_enable <= 1'b0;\n            response_size <= 7'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CMD_SET_REG[3];\n                    settings[6:0] <= response_size;\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1; // CTE\n                        NORMAL_INT_REG[15] <= 1'b1; // EI\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1'b1;\n                        if (serial_status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[0] <= 1'b1; // CC\n                        end\n                        if (CRC_check_enable && !serial_status[5]) begin\n                            ERR_INT_REG[1] <= 1'b1; // CCRCE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            ERR_INT_REG[3] <= 1'b1; // CIE\n                            NORMAL_INT_REG[15] <= 1'b1; // EI\n                        end\n                        if (response_size != 0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\n// Intermediate signal for inverse calculation\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Combinational logic for inv calculation\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset to zero\n        CRC <= 16'b0;\n    end else begin\n        if (Enable) begin\n            // Sequential logic for CRC update\n            CRC[15:1] <= CRC[14:0]; // Shift left operation\n            CRC[12] <= CRC[11] ^ inv; // Update CRC[12]\n            CRC[5] <= CRC[4] ^ inv;  // Update CRC[5]\n            CRC[0] <= inv;           // Set CRC[0] to inv\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output [1:0] mem_empt\n);\n\n// FIFO memory\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n\n// Pointers and temporary storage\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n        we <= 8'h1;\n    end else if (wr) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 3) begin\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            ft <= 0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Full and empty flags\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n        empty <= 1;\n    end else begin\n        full <= (adr_i == adr_o - 1);\n        empty <= (adr_i == adr_o);\n    end\nend\n\n// Memory empty space calculation\nassign mem_empt = FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [8:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Define register addresses\n    localparam ADDR_ARGUMENT           = 8'h00;\n    localparam ADDR_CMD_SETTING        = 8'h04;\n    localparam ADDR_CARD_STATUS        = 8'h08;\n    localparam ADDR_RESPONSE           = 8'h0C;\n    localparam ADDR_SOFTWARE_RESET     = 8'h28;\n    localparam ADDR_TIMEOUT            = 8'h2C;\n    localparam ADDR_NORMAL_INT_STATUS  = 8'h30;\n    localparam ADDR_ERROR_INT_STATUS   = 8'h34;\n    localparam ADDR_NORMAL_INT_ENABLE  = 8'h38;\n    localparam ADDR_ERROR_INT_ENABLE   = 8'h3C;\n    localparam ADDR_CLOCK_DIVIDER      = 8'h4C;\n    localparam ADDR_BD_STATUS          = 8'h50;\n    localparam ADDR_DAT_INT_STATUS     = 8'h54;\n    localparam ADDR_DAT_INT_ENABLE     = 8'h58;\n    localparam ADDR_BD_RX              = 8'h60;\n    localparam ADDR_BD_TX              = 8'h80;\n\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 9'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the Wishbone transaction\n            if (wb_we_i) begin\n                // Handle writes to the registers\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: argument_reg <= wb_dat_i;\n                    ADDR_CMD_SETTING: cmd_setting_reg <= wb_dat_i[15:0];\n                    ADDR_SOFTWARE_RESET: software_reset_reg <= wb_dat_i[8:0];\n                    ADDR_TIMEOUT: time_out_reg <= wb_dat_i[15:0];\n                    ADDR_NORMAL_INT_ENABLE: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_ERROR_INT_ENABLE: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_CLOCK_DIVIDER: clock_divider <= wb_dat_i[7:0];\n                    ADDR_DAT_INT_ENABLE: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    ADDR_BD_RX: begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                        we_m_rx_bd <= 1'b1;\n                    end\n                    ADDR_BD_TX: begin\n                        dat_in_m_tx_bd <= wb_dat_i;\n                        we_m_tx_bd <= 1'b1;\n                    end\n                    default: ;\n                endcase\n            end else begin\n                // Handle reads from the registers\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: wb_dat_o <= argument_reg;\n                    ADDR_CMD_SETTING: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    ADDR_CARD_STATUS: wb_dat_o <= {16'b0, status_reg};\n                    ADDR_RESPONSE: wb_dat_o <= cmd_resp_1;\n                    ADDR_SOFTWARE_RESET: wb_dat_o <= {23'b0, software_reset_reg};\n                    ADDR_TIMEOUT: wb_dat_o <= {16'b0, time_out_reg};\n                    ADDR_NORMAL_INT_STATUS: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    ADDR_ERROR_INT_STATUS: wb_dat_o <= {16'b0, error_int_status_reg};\n                    ADDR_NORMAL_INT_ENABLE: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    ADDR_ERROR_INT_ENABLE: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    ADDR_CLOCK_DIVIDER: wb_dat_o <= {24'b0, clock_divider};\n                    ADDR_BD_STATUS: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    ADDR_DAT_INT_STATUS: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    ADDR_DAT_INT_ENABLE: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [8:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register addresses\n    localparam ADDR_ARGUMENT           = 8'h00;\n    localparam ADDR_CMD_SETTING        = 8'h04;\n    localparam ADDR_CARD_STATUS        = 8'h08;\n    localparam ADDR_RESPONSE           = 8'h0C;\n    localparam ADDR_SOFTWARE_RESET     = 8'h28;\n    localparam ADDR_TIMEOUT            = 8'h2C;\n    localparam ADDR_NORMAL_INT_STATUS  = 8'h30;\n    localparam ADDR_ERROR_INT_STATUS   = 8'h34;\n    localparam ADDR_NORMAL_INT_ENABLE  = 8'h38;\n    localparam ADDR_ERROR_INT_ENABLE   = 8'h3C;\n    localparam ADDR_CLOCK_DIVIDER      = 8'h4C;\n    localparam ADDR_BD_STATUS          = 8'h50;\n    localparam ADDR_DAT_INT_STATUS     = 8'h54;\n    localparam ADDR_DAT_INT_ENABLE     = 8'h58;\n    localparam ADDR_BD_RX              = 8'h60;\n    localparam ADDR_BD_TX              = 8'h80;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 9'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the Wishbone transaction\n            if (wb_we_i) begin\n                // Handle writes to the registers\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: argument_reg <= wb_dat_i;\n                    ADDR_CMD_SETTING: cmd_setting_reg <= wb_dat_i[15:0];\n                    ADDR_SOFTWARE_RESET: software_reset_reg <= wb_dat_i[8:0];\n                    ADDR_TIMEOUT: time_out_reg <= wb_dat_i[15:0];\n                    ADDR_NORMAL_INT_ENABLE: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_ERROR_INT_ENABLE: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_CLOCK_DIVIDER: clock_divider <= wb_dat_i[7:0];\n                    ADDR_DAT_INT_ENABLE: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    ADDR_BD_RX: begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                        we_m_rx_bd <= 1'b1;\n                    end\n                    ADDR_BD_TX: begin\n                        dat_in_m_tx_bd <= wb_dat_i;\n                        we_m_tx_bd <= 1'b1;\n                    end\n                    default: ;\n                endcase\n            end else begin\n                // Handle reads from the registers\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: wb_dat_o <= argument_reg;\n                    ADDR_CMD_SETTING: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    ADDR_CARD_STATUS: wb_dat_o <= {16'b0, status_reg};\n                    ADDR_RESPONSE: wb_dat_o <= cmd_resp_1;\n                    ADDR_SOFTWARE_RESET: wb_dat_o <= {23'b0, software_reset_reg};\n                    ADDR_TIMEOUT: wb_dat_o <= {16'b0, time_out_reg};\n                    ADDR_NORMAL_INT_STATUS: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    ADDR_ERROR_INT_STATUS: wb_dat_o <= {16'b0, error_int_status_reg};\n                    ADDR_NORMAL_INT_ENABLE: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    ADDR_ERROR_INT_ENABLE: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    ADDR_CLOCK_DIVIDER: wb_dat_o <= {24'b0, clock_divider};\n                    ADDR_BD_STATUS: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    ADDR_DAT_INT_STATUS: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    ADDR_DAT_INT_ENABLE: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Combinational logic for calculating 'inv'\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset to zero\n        CRC <= 16'b0;\n    end else begin\n        if (Enable) begin\n            // Sequential logic for CRC calculation\n            CRC[15:1] <= CRC[14:0];  // Shift all bits left\n            CRC[0] <= inv;           // Set LSB to 'inv'\n            \n            // Update specific bits with XOR operation\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[5] <= CRC[4] ^ inv;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for state machine\n    reg [2:0] state, next_state;\n\n    // Registers for debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Registers for synchronizing input signals\n    reg req_in_q, req_in_int;\n    reg ack_in_q, ack_in_int;\n\n    // Registers for internal operations\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n\n    // FSM state transition logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic based on state\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            // Reset all outputs and internal registers\n            go_idle_o <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            STATUS_REG <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            cmd_out <= 0;\n            Watchdog_Cnt <= 0;\n            complete <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                SETUP: begin\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], 7'b0101000};\n                    cmd_out <= {2'b01, CMD_SET_REG[13:8], ARG_REG};\n                    req_out <= 0;\n                    ack_out <= 0;\n                    Watchdog_Cnt <= 0;\n                end\n                EXECUTE: begin\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1; // CTE\n                        ERR_INT_REG[3] <= 1; // EI\n                        go_idle_o <= 1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                        if (serial_status[6]) begin\n                            complete <= 1;\n                            NORMAL_INT_REG[0] <= 1; // CC\n                        end\n                    end\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                end\n            endcase\n        end\n    end\n\n    // Debounce logic for card detect\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 0;\n            card_present <= 0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1;\n            end else begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        end\n    end\n\n    // Synchronizers for req_in and ack_in\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_in_q <= 0;\n            req_in_int <= 0;\n            ack_in_q <= 0;\n            ack_in_int <= 0;\n        end else begin\n            req_in_q <= req_in;\n            req_in_int <= req_in_q;\n            ack_in_q <= ack_in;\n            ack_in_int <= ack_in_q;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        // Inverse calculation based on the current input and the MSB of CRC\n        wire inv = BITVAL ^ CRC[6];\n\n        // Update CRC values\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for FSM\n    reg [2:0] state, next_state;\n    reg [3:0] debounce;\n    reg card_present;\n    reg ack_q, ack_in_int;\n    reg req_q, req_in_int;\n    reg [15:0] Watchdog_Cnt;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n                card_present <= 1'b0;\n            end\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 1'b0;\n            ack_in_int <= 1'b0;\n            req_q <= 1'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n            req_q <= req_in;\n            req_in_int <= req_q;\n        end\n    end\n\n    // FSM Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = New_CMD ? SETUP : IDLE;\n            SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = (Watchdog_Cnt > TIMEOUT_REG || complete) ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output Logic based on Current State\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            STATUS_REG <= 16'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            settings <= 16'b0;\n            go_idle_o <= 1'b0;\n            cmd_out <= 40'b0;\n            req_out <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n                    settings <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], 7'b0}; // Example settings\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    STATUS_REG <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1; // CTE\n                        NORMAL_INT_REG[15] <= 1'b1; // EI\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1'b1;\n                        if (serial_status[6]) begin\n                            NORMAL_INT_REG[0] <= 1'b1; // CC\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [(`RAM_MEM_WIDTH-1):0] dat_in_m_tx_bd,\n    output reg [(`RAM_MEM_WIDTH-1):0] dat_in_m_rx_bd\n);\n\n    // Register addresses\n    localparam ADDR_ARGUMENT           = 8'h00;\n    localparam ADDR_CMD_SETTING        = 8'h04;\n    localparam ADDR_CARD_STATUS        = 8'h08;\n    localparam ADDR_RESPONSE           = 8'h0C;\n    localparam ADDR_SOFTWARE_RESET     = 8'h28;\n    localparam ADDR_TIMEOUT            = 8'h2C;\n    localparam ADDR_NORMAL_INT_STATUS  = 8'h30;\n    localparam ADDR_ERROR_INT_STATUS   = 8'h34;\n    localparam ADDR_NORMAL_INT_ENABLE  = 8'h38;\n    localparam ADDR_ERROR_INT_ENABLE   = 8'h3C;\n    localparam ADDR_CLOCK_DIVIDER      = 8'h4C;\n    localparam ADDR_BD_ISR_REG         = 8'h54;\n    localparam ADDR_BD_ISR_ENABLE_REG  = 8'h58;\n    localparam ADDR_BD_RX              = 8'h60;\n    localparam ADDR_BD_TX              = 8'h80;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {(`RAM_MEM_WIDTH){1'b0}};\n            dat_in_m_rx_bd <= {(`RAM_MEM_WIDTH){1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1;  // Acknowledge the wishbone transaction\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: argument_reg <= wb_dat_i;\n                    ADDR_CMD_SETTING: cmd_setting_reg <= wb_dat_i[15:0];\n                    ADDR_SOFTWARE_RESET: software_reset_reg <= wb_dat_i[7:0];\n                    ADDR_TIMEOUT: time_out_reg <= wb_dat_i[15:0];\n                    ADDR_NORMAL_INT_ENABLE: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_ERROR_INT_ENABLE: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_CLOCK_DIVIDER: clock_divider <= wb_dat_i[7:0];\n                    ADDR_BD_ISR_ENABLE_REG: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    ADDR_BD_RX: begin\n                        dat_in_m_rx_bd <= wb_dat_i[(`RAM_MEM_WIDTH-1):0];\n                        we_m_rx_bd <= 1'b1;\n                    end\n                    ADDR_BD_TX: begin\n                        dat_in_m_tx_bd <= wb_dat_i[(`RAM_MEM_WIDTH-1):0];\n                        we_m_tx_bd <= 1'b1;\n                    end\n                    default: ;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: wb_dat_o <= argument_reg;\n                    ADDR_CMD_SETTING: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    ADDR_CARD_STATUS: wb_dat_o <= {16'b0, status_reg};\n                    ADDR_RESPONSE: wb_dat_o <= cmd_resp_1;\n                    ADDR_SOFTWARE_RESET: wb_dat_o <= {24'b0, software_reset_reg};\n                    ADDR_TIMEOUT: wb_dat_o <= {16'b0, time_out_reg};\n                    ADDR_NORMAL_INT_STATUS: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    ADDR_ERROR_INT_STATUS: wb_dat_o <= {16'b0, error_int_status_reg};\n                    ADDR_NORMAL_INT_ENABLE: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    ADDR_ERROR_INT_ENABLE: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    ADDR_CLOCK_DIVIDER: wb_dat_o <= {24'b0, clock_divider};\n                    ADDR_BD_ISR_REG: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    ADDR_BD_ISR_ENABLE_REG: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    localparam CMD24 = 16'h181A;\n    localparam CMD17 = 16'h111A;\n    localparam CMD12 = 16'hC1A;\n    localparam ACMD13 = 16'hD1A;\n    localparam ACMD51 = 16'h331A;\n    localparam SIZE = 9;\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n    localparam RESEND_MAX_CNT = 3;\n\n    // Internal Registers\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed;\n    reg [2:0] bd_cnt; // Adjust size based on RAM_MEM_WIDTH\n\n    // State Machine Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            bd_cnt <= 0;\n            Dat_Int_Status <= 0;\n        end else begin\n            state <= next_state;\n            if (state == SEND_CMD && we_ack) send_done <= 1;\n            if (state == RECIVE_CMD && !cmd_busy) rec_done <= 1;\n            if (state == DATA_TRANSFER && transm_complete) trans_done <= 1;\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\n    // Next State Logic\n    always @(*) begin\n        next_state = state; // Default to hold current state\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY && !tx_full) next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY && !rx_full) next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (ack_i_s_tx && bd_cnt >= READ_CYCLE - 1) next_state = SEND_CMD;\n                else next_state = GET_TX_BD;\n            end\n            GET_RX_BD: begin\n                if (ack_i_s_rx && bd_cnt >= READ_CYCLE - 1) next_state = SEND_CMD;\n                else next_state = GET_RX_BD;\n            end\n            SEND_CMD: begin\n                if (send_done) next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done) next_state = DATA_TRANSFER;\n                else if (rec_failed) next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) next_state = IDLE;\n                else if (trans_failed) next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output Logic\n    always @(*) begin\n        // Reset all outputs\n        re_s_tx = 0;\n        a_cmp_tx = 0;\n        re_s_rx = 0;\n        a_cmp_rx = 0;\n        we_req = 0;\n        d_write = 0;\n        d_read = 0;\n        start_tx_fifo = 0;\n        start_rx_fifo = 0;\n        ack_transfer = 0;\n        CIDAT = 0;\n\n        case (state)\n            GET_TX_BD: begin\n                re_s_tx = 1;\n                if (ack_i_s_tx) begin\n                    sys_adr = dat_in_tx; // Example assignment\n                    cmd_arg = dat_in_tx; // Example assignment\n                    start_tx_fifo = 1;\n                    cmd_set = CMD24;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx = 1;\n                if (ack_i_s_rx) begin\n                    sys_adr = dat_in_rx; // Example assignment\n                    cmd_arg = dat_in_rx; // Example assignment\n                    start_rx_fifo = 1;\n                    cmd_set = CMD17;\n                end\n            end\n            SEND_CMD: begin\n                we_req = 1;\n                if (tx_cycle) d_write = 1;\n                if (rx_cycle) d_read = 1;\n            end\n            DATA_TRANSFER: begin\n                if (tx_cycle && !tx_empt) a_cmp_tx = 1;\n                if (rx_cycle && !rx_full) a_cmp_rx = 1;\n                ack_transfer = transm_complete;\n            end\n            STOP_SEND: begin\n                cmd_set = CMD12;\n                we_req = 1;\n            end\n        endcase\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE    = 3'b001;\n    localparam SETUP   = 3'b010;\n    localparam EXECUTE = 3'b100;\n\n    // Registers for state machine\n    reg [2:0] state, next_state;\n\n    // Debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Synchronization registers\n    reg req_in_q, req_in_int;\n    reg ack_in_q, ack_in_int;\n\n    // Watchdog counter\n    reg [15:0] Watchdog_Cnt;\n\n    // FSM combinational logic to determine next state\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (Watchdog_Cnt > TIMEOUT_REG || (req_in_int && serial_status[6]))\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Output logic based on current state\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            STATUS_REG <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            go_idle_o <= 0;\n            cmd_out <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            Watchdog_Cnt <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n                    settings[15:0] <= {CMD_SET_REG[7:6], data_read, data_write, 3'b111, CMD_SET_REG[3], 7'b0000001};\n                    Watchdog_Cnt <= 0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1; // CTE\n                        NORMAL_INT_REG[15] <= 1; // EI\n                        go_idle_o <= 1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                        if (serial_status[6]) begin\n                            NORMAL_INT_REG[0] <= 1; // CC\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Debounce logic for card detect\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 0;\n            card_present <= 0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1;\n            end else begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        end\n    end\n\n    // Synchronize req_in and ack_in signals\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_in_q <= 0;\n            req_in_int <= 0;\n            ack_in_q <= 0;\n            ack_in_int <= 0;\n        end else begin\n            req_in_q <= req_in;\n            req_in_int <= req_in_q;\n            ack_in_q <= ack_in;\n            ack_in_int <= ack_in_q;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // State Definitions\n    localparam [SIZE-1:0]\n        INIT = 10'b0000000001,\n        IDLE = 10'b0000000010,\n        WRITE_WR = 10'b0000000100,\n        DLY_WR = 10'b0000001000,\n        READ_WR = 10'b0000010000,\n        DLY_READ = 10'b0000100000,\n        ACK_WR = 10'b0001000000,\n        WRITE_WO = 10'b0010000000,\n        DLY_WO = 10'b0100000000,\n        ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [SIZE-1:0] state, next_state;\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_Enable, CRC_OUT, CRC_Check_On, Crc_Buffering, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in, q1, Ack_internal_in;\n\n    // Synchronize REQ_IN and ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // FSM_COMBO logic\n    always @* begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n            Cmd_Cnt <= 0;\n            Delay_Cnt <= 0;\n        end else begin\n            state <= next_state;\n            Cmd_Cnt <= (state == WRITE_WR || state == WRITE_WO || state == READ_WR) ? Cmd_Cnt + 1 : 0;\n            Delay_Cnt <= (state == DLY_WR || state == DLY_WO || state == DLY_READ) ? Delay_Cnt + 1 : 0;\n        end\n    end\n\n    // COMMAND_DECODER logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            Write_Read <= (SETTING_IN[6:0] > 0);\n            Write_Only <= (SETTING_IN[6:0] == 0);\n        end\n    end\n\n    // FSM_OUT logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 1;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 0;\n            cmd_out_o <= 1;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                WRITE_WR, WRITE_WO: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= In_Buff[39-Cmd_Cnt];\n                    CMD_OUT <= In_Buff;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                end\n                ACK_WR, ACK_WO: begin\n                    ACK_OUT <= 0;\n                end\n                default: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_7", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_7(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [6:0] CRC\n);\n\n// Intermediate signal for inverse calculation\nwire inv;\n\nassign inv = BITVAL ^ CRC[6];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        CRC <= 7'b0;\n    end else if (Enable) begin\n        CRC[0] <= inv;\n        CRC[1] <= CRC[0];\n        CRC[2] <= CRC[1];\n        CRC[3] <= CRC[2] ^ inv;\n        CRC[4] <= CRC[3];\n        CRC[5] <= CRC[4];\n        CRC[6] <= CRC[5];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_crc_16", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_crc_16(\n    input BITVAL,\n    input Enable,\n    input CLK,\n    input RST,\n    output reg [15:0] CRC\n);\n\n// Intermediate signal for XOR of input bit and MSB of CRC\nwire inv;\nassign inv = BITVAL ^ CRC[15];\n\nalways @(posedge CLK or posedge RST) begin\n    if (RST) begin\n        // Asynchronous reset: Set CRC to 0\n        CRC <= 16'b0;\n    end else if (Enable) begin\n        // Update CRC only if Enable is high\n        CRC <= {CRC[14:0], 1'b0}; // Shift left CRC\n        CRC[12] <= CRC[11] ^ inv; // Update CRC[12]\n        CRC[5]  <= CRC[4]  ^ inv; // Update CRC[5]\n        CRC[0]  <= inv;            // Set CRC[0] to inv\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i & wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the wishbone transaction\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        we_m_rx_bd <= 1'b1;\n                    end\n                    8'h80: begin\n                        dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        we_m_tx_bd <= 1'b1;\n                    end\n                    default: ;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'b0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'b0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    8'h4c: wb_dat_o <= {24'b0, clock_divider};\n                    8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n\n// Write and read pointers\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Byte-wise write enable\nreg [7:0] we;\n\n// Temporary storage\nreg [31:0] tmp;\n\n// Data written flag\nreg ft;\n\n// Internal signals\nwire write_enable;\nwire read_enable;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] next_adr_i;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] next_adr_o;\n\nassign write_enable = wr && (we == 8'hFF);\nassign read_enable = rd && !empty;\nassign next_adr_i = (adr_i + 1) % FIFO_RX_MEM_DEPTH;\nassign next_adr_o = (adr_o + 1) % FIFO_RX_MEM_DEPTH;\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        we <= 8'h1;\n        ft <= 0;\n    end else if (wr) begin\n        tmp <= {tmp[27:0], d};\n        we <= {we[6:0], 1'b1};\n        if (write_enable) begin\n            ram[adr_i] <= tmp;\n            adr_i <= next_adr_i;\n            we <= 8'h1;\n            ft <= 1;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n        empty <= 1;\n        full <= 0;\n    end else if (read_enable) begin\n        q <= ram[adr_o];\n        adr_o <= next_adr_o;\n    end\nend\n\nalways @(*) begin\n    full = (next_adr_i == adr_o);\n    empty = (adr_i == adr_o) && !ft;\n    mem_empt = FIFO_RX_MEM_DEPTH - (adr_i >= adr_o ? adr_i - adr_o : FIFO_RX_MEM_DEPTH + adr_i - adr_o);\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n\n    // Instantiate the FIFO\n    sd_rx_fifo fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               READ_FIFO = 1,\n               WB_WRITE = 2,\n               WB_WAIT_ACK = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free)\n                    next_state = READ_FIFO;\n                else\n                    next_state = IDLE;\n            end\n            READ_FIFO: begin\n                next_state = WB_WRITE;\n            end\n            WB_WRITE: begin\n                if (m_wb_ack_i)\n                    next_state = WB_WAIT_ACK;\n                else\n                    next_state = WB_WRITE;\n            end\n            WB_WAIT_ACK: begin\n                if (wb_free)\n                    next_state = IDLE;\n                else\n                    next_state = WB_WAIT_ACK;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        end\n    end\n\n    // Output logic and control signal updates\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    reset_rx_fifo <= 0;\n                    rd <= 0;\n                    wb_free <= 1;\n                end\n                READ_FIFO: begin\n                    rd <= 1;\n                    m_wb_dat_o <= dat_o;\n                end\n                WB_WRITE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00;  // Linear burst\n                    wb_free <= 0;\n                end\n                WB_WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 0;\n                        m_wb_stb_o <= 0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 2, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output full,\n    output empty,\n    output [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Write and read pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty detection\nwire full_int, empty_int;\n\n// Write logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\n    end\nend\n\n// Read logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n    end\nend\n\n// Data output\nassign q = ram[adr_o];\n\n// Full detection\nassign full = ((adr_i + 1) % FIFO_TX_MEM_DEPTH) == adr_o;\n\n// Empty detection\nassign empty = adr_i == adr_o;\n\n// Memory occupancy calculation\nassign mem_empt = adr_i >= adr_o ? adr_i - adr_o : (FIFO_TX_MEM_DEPTH - adr_o + adr_i);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output full,\n    output empty,\n    output [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Write and Read pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty status\nwire full_int, empty_int;\n\n// Write logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\n    end\nend\n\n// Read logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (rd && !empty) begin\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n    end\nend\n\n// Output data\nassign q = ram[adr_o];\n\n// Full and Empty flags\nassign full = (adr_i == adr_o - 1) || (adr_i == FIFO_TX_MEM_DEPTH-1 && adr_o == 0);\nassign empty = (adr_i == adr_o);\n\n// FIFO occupancy calculation\nassign mem_empt = adr_i >= adr_o ? adr_i - adr_o : (FIFO_TX_MEM_DEPTH + adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Local parameters for mode selection based on RAM_MEM_WIDTH\nlocalparam MODE_32_BIT = (RAM_MEM_WIDTH == 32);\nlocalparam MODE_16_BIT = (RAM_MEM_WIDTH == 16);\n\n// Memory for buffer descriptors\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\n\n// Pointers and counters\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        free_bd <= MODE_32_BIT ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            free_bd <= free_bd - 1;\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            ack_o_s <= MODE_16_BIT; // Acknowledge every read in 16-bit mode\n        end else begin\n            ack_o_s <= 0;\n        end\n\n        // Handle completion of SD card operation\n        if (a_cmp && !last_a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n\n        // Track last a_cmp value for edge detection\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n\n// Registers\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\n// Internal variables\nwire write_enable;\nwire read_enable;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] next_adr_i, next_adr_o;\n\nassign write_enable = wr && !full;\nassign read_enable = rd && !empty;\n\nassign next_adr_i = (adr_i == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_i + 1;\nassign next_adr_o = (adr_o == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n        we <= 8'h1;\n    end else if (write_enable) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 3) begin\n            ram[adr_i] <= tmp;\n            adr_i <= next_adr_i;\n            ft <= 0;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (read_enable) begin\n        q <= ram[adr_o];\n        adr_o <= next_adr_o;\n    end\nend\n\nalways @(*) begin\n    full = (next_adr_i == adr_o);\n    empty = (adr_i == adr_o);\n    mem_empt = FIFO_RX_MEM_DEPTH - (adr_i >= adr_o ? adr_i - adr_o : FIFO_RX_MEM_DEPTH + adr_i - adr_o);\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty detection\nwire next_full;\nwire next_empty;\nwire [FIFO_TX_MEM_ADR_SIZE:0] write_ptr_plus_one = adr_i + 1;\n\n// Write logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full <= 1'b0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\n    end\n    full <= next_full;\nend\n\n// Read logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty <= 1'b1;\n    end else if (rd && !empty) begin\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n    end\n    empty <= next_empty;\nend\n\n// Output data\nassign q = ram[adr_o];\n\n// Full and empty logic\nassign next_full = (write_ptr_plus_one == adr_o);\nassign next_empty = (adr_i == adr_o);\n\n// Memory occupancy calculation\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 0;\n    end else begin\n        mem_empt <= (adr_i >= adr_o) ? (adr_i - adr_o) : (FIFO_TX_MEM_DEPTH + adr_i - adr_o);\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_bd", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_bd (\n    input clk,\n    input rst,\n    input we_m,\n    input [RAM_MEM_WIDTH-1:0] dat_in_m,\n    output reg [BD_WIDTH-1:0] free_bd,\n    input re_s,\n    output reg ack_o_s,\n    input a_cmp,\n    output reg [RAM_MEM_WIDTH-1:0] dat_out_s\n);\n\n// Internal Registers\nreg [RAM_MEM_WIDTH-1:0] bd_mem [0:BD_SIZE-1];\nreg [BD_WIDTH-1:0] m_wr_pnt, s_rd_pnt;\nreg [BD_WIDTH-1:0] write_count, read_count;\nreg last_a_cmp;\n\n// Initialization\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wr_pnt <= 0;\n        s_rd_pnt <= 0;\n        write_count <= 0;\n        read_count <= 0;\n        free_bd <= (RAM_MEM_WIDTH == 32) ? (BD_SIZE >> 1) : (BD_SIZE >> 2);\n        last_a_cmp <= 0;\n    end else begin\n        // Handle write operations\n        if (we_m && free_bd > 0) begin\n            bd_mem[m_wr_pnt] <= dat_in_m;\n            m_wr_pnt <= (m_wr_pnt + 1) % BD_SIZE;\n            write_count <= write_count + 1;\n            if ((RAM_MEM_WIDTH == 32 && write_count == 1) || (RAM_MEM_WIDTH == 16 && write_count == 3)) begin\n                write_count <= 0;\n                free_bd <= free_bd - 1;\n            end\n        end\n\n        // Handle read operations\n        if (re_s) begin\n            dat_out_s <= bd_mem[s_rd_pnt];\n            s_rd_pnt <= (s_rd_pnt + 1) % BD_SIZE;\n            read_count <= read_count + 1;\n            ack_o_s <= (RAM_MEM_WIDTH == 16); // Acknowledge every read in 16-bit mode\n        end\n\n        // Handle SD card operation completion\n        if (!last_a_cmp && a_cmp) begin\n            free_bd <= free_bd + 1;\n        end\n        last_a_cmp <= a_cmp;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n\n    // Internal Registers\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, trans_done, trans_failed;\n    reg tx_cycle, rx_cycle;\n\n    // State Machine Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            Dat_Int_Status <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next State Logic\n    always @(*) begin\n        next_state = state; // Default to hold current state\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY && !cmd_busy) begin\n                    next_state = GET_TX_BD;\n                end else if (free_rx_bd != BD_EMPTY && !cmd_busy) begin\n                    next_state = GET_RX_BD;\n                end\n            end\n            GET_TX_BD: begin\n                if (ack_i_s_tx) begin\n                    next_state = SEND_CMD;\n                    tx_cycle = 1;\n                    rx_cycle = 0;\n                end\n            end\n            GET_RX_BD: begin\n                if (ack_i_s_rx) begin\n                    next_state = SEND_CMD;\n                    rx_cycle = 1;\n                    tx_cycle = 0;\n                end\n            end\n            SEND_CMD: begin\n                if (we_ack) begin\n                    next_state = RECIVE_CMD;\n                    send_done = 1;\n                end\n            end\n            RECIVE_CMD: begin\n                if (!cmd_busy && card_status[0]) begin\n                    next_state = DATA_TRANSFER;\n                    rec_done = 1;\n                end else if (cmd_tsf_err) begin\n                    rec_failed = 1;\n                    next_state = SEND_CMD;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete && crc_ok) begin\n                    next_state = IDLE;\n                    trans_done = 1;\n                end else if (!crc_ok) begin\n                    next_state = STOP;\n                    trans_failed = 1;\n                end\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // Output Logic\n    always @(state) begin\n        // Reset outputs\n        re_s_tx = 0;\n        a_cmp_tx = 0;\n        re_s_rx = 0;\n        a_cmp_rx = 0;\n        we_req = 0;\n        d_write = 0;\n        d_read = 0;\n        start_tx_fifo = 0;\n        start_rx_fifo = 0;\n        ack_transfer = 0;\n        CIDAT = 0;\n\n        case (state)\n            GET_TX_BD: begin\n                re_s_tx = 1;\n            end\n            GET_RX_BD: begin\n                re_s_rx = 1;\n            end\n            SEND_CMD: begin\n                we_req = 1;\n                if (tx_cycle) begin\n                    d_write = 1;\n                end else if (rx_cycle) begin\n                    d_read = 1;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (tx_cycle) begin\n                    start_tx_fifo = 1;\n                end else if (rx_cycle) begin\n                    start_rx_fifo = 1;\n                end\n            end\n            STOP_SEND: begin\n                cmd_set = CMD12;\n            end\n        endcase\n    end\n\n    // Handle Dat_Int_Status reset\n    always @(posedge Dat_Int_Status_rst) begin\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output full,\n    output empty,\n    output [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Write and read pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals\nwire write_enable;\nwire read_enable;\nwire fifo_full;\nwire fifo_empty;\ninteger occupancy;\n\nassign write_enable = wr && !fifo_full;\nassign read_enable = rd && !fifo_empty;\n\n// FIFO full logic\nassign fifo_full = (adr_i == adr_o - 1'b1) || (adr_i == FIFO_TX_MEM_DEPTH-1 && adr_o == 0);\n// FIFO empty logic\nassign fifo_empty = (adr_i == adr_o);\n\n// FIFO occupancy calculation\nalways @(adr_i or adr_o) begin\n    if (adr_i >= adr_o)\n        occupancy = adr_i - adr_o;\n    else\n        occupancy = (FIFO_TX_MEM_DEPTH - adr_o) + adr_i;\nend\n\nassign mem_empt = occupancy[5:0];\n\n// Output assignments\nassign full = fifo_full;\nassign empty = fifo_empty;\nassign q = ram[adr_o];\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (write_enable) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (read_enable) begin\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output [1:0] mem_empt\n);\n\n// FIFO memory depth and address size from sd_defines.v\nlocalparam FIFO_DEPTH = `FIFO_RX_MEM_DEPTH;\nlocalparam ADDR_SIZE = `FIFO_RX_MEM_ADR_SIZE;\n\n// Memory array\nreg [31:0] ram[FIFO_DEPTH-1:0];\n\n// Pointers and write enable\nreg [ADDR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\n// Write logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr && !full) begin\n        tmp <= {tmp[27:0], d}; // Shift left and add new data\n        ft <= ft + 1;\n        if (ft == 7) begin // Last byte to form a word\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            ft <= 0;\n        end\n    end\nend\n\n// Read logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Full and empty flags\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n        empty <= 1;\n    end else begin\n        full <= (adr_i == adr_o - 1);\n        empty <= (adr_i == adr_o);\n    end\nend\n\n// Memory empty space calculation\nassign mem_empt = FIFO_DEPTH - (adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output full,\n    output empty,\n    output [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Write and Read pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals\nwire write_enable;\nwire read_enable;\nwire fifo_full;\nwire fifo_empty;\ninteger i;\n\nassign write_enable = wr && !fifo_full;\nassign read_enable = rd && !fifo_empty;\n\n// FIFO Full and Empty logic\nassign fifo_full = (adr_i == adr_o - 1) || (adr_i == FIFO_TX_MEM_DEPTH-1 && adr_o == 0);\nassign fifo_empty = (adr_i == adr_o);\nassign full = fifo_full;\nassign empty = fifo_empty;\n\n// FIFO occupancy calculation\nassign mem_empt = adr_i >= adr_o ? adr_i - adr_o : (FIFO_TX_MEM_DEPTH - adr_o + adr_i);\n\n// Asynchronous reset\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        for (i = 0; i < FIFO_TX_MEM_DEPTH; i = i + 1) begin\n            ram[i] <= 0;\n        end\n    end else if (write_enable) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n    end else if (read_enable) begin\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n    end\nend\n\n// Data output\nassign q = ram[adr_o];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output [1:0] mem_empt\n);\n\n// FIFO memory parameters\nlocalparam FIFO_DEPTH = `FIFO_RX_MEM_DEPTH;\nlocalparam ADR_SIZE = `FIFO_RX_MEM_ADR_SIZE;\n\n// RAM storage for the FIFO\nreg [31:0] ram[FIFO_DEPTH-1:0];\n\n// Pointers and write enable\nreg [ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\n// Memory empty space calculation\nassign mem_empt = FIFO_DEPTH - (adr_i - adr_o);\n\n// Asynchronous reset\nalways @(posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        adr_o <= 0;\n        full <= 0;\n        empty <= 1;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end\nend\n\n// Write operation\nalways @(posedge wclk) begin\n    if (wr && !full) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 7) begin\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            ft <= 0;\n            if (adr_i == FIFO_DEPTH - 1)\n                adr_i <= 0;\n            full <= (adr_i == adr_o - 1);\n            empty <= 0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk) begin\n    if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n        if (adr_o == FIFO_DEPTH - 1)\n            adr_o <= 0;\n        empty <= (adr_o == adr_i);\n        full <= 0;\n    end\nend\n\n// Full and empty flag management\nalways @(adr_i or adr_o) begin\n    full <= (adr_i == adr_o - 1);\n    empty <= (adr_i == adr_o);\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers and Wires\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [15:0] crc_out[SD_BUS_W-1:0];\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int, ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Submodule Instances\n    // CRC Generation Block\n    genvar i;\n    generate\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_module (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[i])\n            );\n        end\n    endgenerate\n\n    // FSM_COMBO Logic\n    always @(*) begin\n        case (state)\n            `IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = `READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = `WRITE_DAT;\n                else\n                    next_state = `IDLE;\n            end\n            `WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = `WRITE_CRC;\n                else\n                    next_state = `WRITE_DAT;\n            end\n            `WRITE_CRC: begin\n                if (crc_status == `OK)\n                    next_state = `WRITE_BUSY;\n                else\n                    next_state = `WRITE_CRC;\n            end\n            `WRITE_BUSY: begin\n                if (busy_int == 0)\n                    next_state = `IDLE;\n                else\n                    next_state = `WRITE_BUSY;\n            end\n            `READ_WAIT: begin\n                if (DAT_dat_i[0] == 0)\n                    next_state = `READ_DAT;\n                else\n                    next_state = `READ_WAIT;\n            end\n            `READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = `IDLE;\n                else\n                    next_state = `READ_DAT;\n            end\n            default: next_state = `IDLE;\n        endcase\n    end\n\n    // FSM_SEQ Logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst)\n            state <= `IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM_OUT Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset logic\n            crc_rst <= 1;\n            crc_en <= 0;\n            transf_cnt <= 0;\n            busy_n <= 1;\n            transm_complete <= 0;\n            crc_ok <= 0;\n            DAT_oe_o <= 0;\n            DAT_dat_o <= 0;\n            data_out <= 0;\n            rd <= 0;\n            we <= 0;\n        end else begin\n            // Normal operation\n            case (state)\n                `WRITE_DAT: begin\n                    // Write data logic\n                end\n                `WRITE_CRC: begin\n                    // Write CRC logic\n                end\n                `WRITE_BUSY: begin\n                    // Write busy logic\n                end\n                `READ_WAIT: begin\n                    // Read wait logic\n                end\n                `READ_DAT: begin\n                    // Read data logic\n                end\n                default: begin\n                    // Default state logic\n                end\n            endcase\n        end\n    end\n\n    // ACK_SYNC Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output full,\n    output empty,\n    output [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty status\nreg full_flag, empty_flag;\n\n// Asynchronous reset handling\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full_flag <= 0;\n    end else if (wr && !full_flag) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty_flag <= 1;\n    end else if (rd && !empty_flag) begin\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n    end\nend\n\n// Data output\nassign q = ram[adr_o];\n\n// Full and empty flag logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        full_flag <= 0;\n    end else begin\n        full_flag <= (adr_i + 1 == adr_o) || (adr_i == FIFO_TX_MEM_DEPTH-1 && adr_o == 0);\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        empty_flag <= 1;\n    end else begin\n        empty_flag <= (adr_i == adr_o);\n    end\nend\n\n// Output assignments\nassign full = full_flag;\nassign empty = empty_flag;\n\n// Memory occupancy calculation\nassign mem_empt = (adr_i >= adr_o) ? (adr_i - adr_o) : (FIFO_TX_MEM_DEPTH + adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n// Parameters\nlocalparam FIFO_WIDTH = 32;\n\n// Registers and Memories\nreg [FIFO_WIDTH-1:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [FIFO_WIDTH-1:0] tmp;\nreg ft;\n\n// Write logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 7) begin\n            ram[adr_i] <= tmp;\n            adr_i <= (adr_i == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_i + 1;\n            ft <= 0;\n        end\n    end\nend\n\n// Read logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= (adr_o == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n    end\nend\n\n// Full and Empty flags\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n        empty <= 1;\n    end else begin\n        full <= (adr_i == adr_o) && (ft != 0);\n        empty <= (adr_i == adr_o) && (ft == 0);\n    end\nend\n\n// Memory empty space calculation\nalways @(*) begin\n    if (adr_i >= adr_o)\n        mem_empt = adr_i - adr_o;\n    else\n        mem_empt = (FIFO_RX_MEM_DEPTH - adr_o) + adr_i;\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register address decoding\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1; // Default to high\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the wishbone transaction\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    // Additional registers as needed\n                    default: ;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'b0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'b0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    8'h4c: wb_dat_o <= {24'b0, clock_divider};\n                    8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    // Additional registers as needed\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0; // De-assert acknowledge\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty logic\nwire next_full;\nwire next_empty;\nwire [FIFO_TX_MEM_ADR_SIZE:0] write_ptr_plus_one = adr_i + 1;\nwire [FIFO_TX_MEM_ADR_SIZE:0] read_ptr_plus_one = adr_o + 1;\n\n// Asynchronous reset\nalways @(posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        adr_o <= 0;\n        full <= 0;\n        empty <= 1;\n        mem_empt <= 0;\n    end\nend\n\n// Write operations\nalways @(posedge wclk) begin\n    if (!rst) begin\n        if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\n        end\n    end\nend\n\n// Read operations\nalways @(posedge rclk) begin\n    if (!rst) begin\n        if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n        end\n    end\nend\n\n// Full and empty logic\nalways @(posedge wclk or posedge rclk) begin\n    if (!rst) begin\n        full <= next_full;\n        empty <= next_empty;\n        mem_empt <= adr_i - adr_o;\n    end\nend\n\n// Calculate next full and empty states\nassign next_full = (write_ptr_plus_one == adr_o);\nassign next_empty = (adr_i == adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty status\nwire full_int, empty_int;\n\n// Write logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full <= 1'b0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        adr_i <= (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\n    end\nend\n\n// Read logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty <= 1'b1;\n    end else if (rd && !empty) begin\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n    end\nend\n\n// Data output\nassign q = ram[adr_o];\n\n// Full and empty status update\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 1'b0;\n        empty <= 1'b1;\n    end else begin\n        full <= (adr_i == adr_o - 1) || (adr_i == FIFO_TX_MEM_DEPTH-1 && adr_o == 0);\n        empty <= (adr_i == adr_o);\n    end\nend\n\n// FIFO occupancy calculation\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 0;\n    end else begin\n        mem_empt <= (adr_i >= adr_o) ? (adr_i - adr_o) : (FIFO_TX_MEM_DEPTH + adr_i - adr_o);\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [8:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register address decoding\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the wishbone transaction\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    // Add more cases as per the register map\n                    default: ;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'b0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'b0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    8'h4c: wb_dat_o <= {24'b0, clock_divider};\n                    8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    // Add more cases as per the register map\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0; // De-assert the acknowledge signal\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input wire [31:0] d,\n    input wire wr,\n    input wire wclk,\n    output reg [31:0] q,\n    input wire rd,\n    output wire full,\n    output wire empty,\n    output wire [5:0] mem_empt,\n    input wire rclk,\n    input wire rst\n);\n\n// FIFO storage array\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals\nwire write_enable;\nwire read_enable;\nwire [FIFO_TX_MEM_ADR_SIZE:0] next_adr_i, next_adr_o;\nwire [FIFO_TX_MEM_ADR_SIZE:0] diff;\n\nassign write_enable = wr && !full;\nassign read_enable = rd && !empty;\n\n// Pointer increment and wrap-around logic\nassign next_adr_i = (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\nassign next_adr_o = (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n\n// FIFO full and empty logic\nassign full = (next_adr_i == adr_o);\nassign empty = (adr_i == adr_o);\n\n// FIFO occupancy calculation\nassign diff = adr_i - adr_o;\nassign mem_empt = (adr_i >= adr_o) ? diff[5:0] : (FIFO_TX_MEM_DEPTH + diff)[5:0];\n\n// Asynchronous reset\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n    end else if (write_enable) begin\n        ram[adr_i] <= d;\n        adr_i <= next_adr_i;\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (read_enable) begin\n        q <= ram[adr_o];\n        adr_o <= next_adr_o;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 3, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // State definitions\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q, Req_internal_in;\n    reg q1, Ack_internal_in;\n\n    // REQ_SYNC and ACK_SYNC logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 1'b0;\n            Req_internal_in <= 1'b0;\n            q1 <= 1'b0;\n            Ack_internal_in <= 1'b0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_COMBO logic\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n            Cmd_Cnt <= 0;\n            Delay_Cnt <= 0;\n        end else begin\n            state <= next_state;\n            case (state)\n                INIT: Cmd_Cnt <= Cmd_Cnt + 1;\n                WRITE_WR, WRITE_WO: Cmd_Cnt <= Cmd_Cnt + 1;\n                DLY_WR, DLY_WO: Delay_Cnt <= Delay_Cnt + 1;\n                READ_WR: Cmd_Cnt <= Cmd_Cnt + 1;\n                DLY_READ: Delay_Cnt <= Delay_Cnt + 1;\n                default: begin\n                    Cmd_Cnt <= 0;\n                    Delay_Cnt <= 0;\n                end\n            endcase\n        end\n    end\n\n    // FSM_OUT logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 0;\n            cmd_out_o <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                end\n                WRITE_WR, WRITE_WO: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                end\n                DLY_WR, DLY_WO: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                end\n                READ_WR: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                    Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                end\n                DLY_READ: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                end\n                ACK_WR, ACK_WO: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                    ACK_OUT <= 1;\n                end\n                default: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // State definitions\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [SIZE-1:0] state;\n    reg [SIZE-1:0] next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q;\n    reg Req_internal_in;\n    reg q1;\n    reg Ack_internal_in;\n\n    // Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 1'b0;\n            Req_internal_in <= 1'b0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 1'b0;\n            Ack_internal_in <= 1'b0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // FSM_COMBO logic\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // COMMAND_DECODER logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            In_Buff <= 0;\n            Out_Buff <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n            DECODER_ACK <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 0;\n            cmd_out_o <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                WRITE_WR: begin\n                    CMD_OUT <= In_Buff;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 1;\n                    STATUS <= 8'b00000001;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    st_dat_t <= 2'b01;\n                end\n                WRITE_WO: begin\n                    CMD_OUT <= In_Buff;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 1;\n                    STATUS <= 8'b00000010;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    st_dat_t <= 2'b10;\n                end\n                DLY_WR: begin\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                    STATUS <= 8'b00000100;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                end\n                DLY_WO: begin\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                    STATUS <= 8'b00001000;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                end\n                READ_WR: begin\n                    CMD_OUT <= Out_Buff;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 1;\n                    STATUS <= 8'b00010000;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    st_dat_t <= 2'b11;\n                end\n                DLY_READ: begin\n                    ACK_OUT <= 1;\n                    REQ_OUT <= 0;\n                    STATUS <= 8'b00100000;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                end\n                ACK_WO: begin\n                    ACK_OUT <= 1;\n                    REQ_OUT <= 0;\n                    STATUS <= 8'b01000000;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                end\n                ACK_WR: begin\n                    ACK_OUT <= 1;\n                    REQ_OUT <= 0;\n                    STATUS <= 8'b10000000;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                end\n                default: begin\n                    CMD_OUT <= 0;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                    STATUS <= 0;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    st_dat_t <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output [1:0] mem_empt\n);\n\n// FIFO memory parameters\nlocalparam FIFO_DEPTH = `FIFO_RX_MEM_DEPTH;\nlocalparam ADDR_SIZE = `FIFO_RX_MEM_ADR_SIZE;\n\n// Internal RAM\nreg [31:0] ram[FIFO_DEPTH-1:0];\n\n// Pointers and registers\nreg [ADDR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\n// Memory empty space calculation\nassign mem_empt = FIFO_DEPTH - (adr_i - adr_o);\n\n// Reset and initialization\nalways @(posedge rst or posedge wclk) begin\n    if (rst) begin\n        adr_i <= 0;\n        adr_o <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n        full <= 0;\n        empty <= 1;\n    end else if (wr) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 7) begin\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            ft <= 0;\n            if (adr_i == FIFO_DEPTH - 1)\n                adr_i <= 0;\n            full <= (adr_i == adr_o - 1);\n            empty <= 0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rst or posedge rclk) begin\n    if (rst) begin\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n        if (adr_o == FIFO_DEPTH - 1)\n            adr_o <= 0;\n        empty <= (adr_o == adr_i);\n        full <= 0;\n    end\nend\n\n// Full and empty flags management\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n        empty <= 1;\n    end else begin\n        full <= (adr_i == adr_o - 1);\n        empty <= (adr_o == adr_i);\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n\n// Registers\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\n// Internal signals\nwire write_enable;\nwire read_enable;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] next_adr_i, next_adr_o;\n\nassign write_enable = wr && !full;\nassign read_enable = rd && !empty;\n\nassign next_adr_i = (adr_i == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_i + 1;\nassign next_adr_o = (adr_o == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n        we <= 8'h1;\n    end else if (write_enable) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 3) begin\n            ram[adr_i] <= tmp;\n            adr_i <= next_adr_i;\n            ft <= 0;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (read_enable) begin\n        q <= ram[adr_o];\n        adr_o <= next_adr_o;\n    end\nend\n\nalways @(*) begin\n    full = (next_adr_i == adr_o);\n    empty = (adr_i == adr_o);\n    mem_empt = FIFO_RX_MEM_DEPTH - (adr_i >= adr_o ? adr_i - adr_o : FIFO_RX_MEM_DEPTH + adr_i - adr_o);\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output reg [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Write and Read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty detection\nwire next_full;\nwire next_empty;\nwire [FIFO_TX_MEM_ADR_SIZE:0] write_ptr_plus_one;\n\n// Pointer increment and wrap-around logic\nassign write_ptr_plus_one = adr_i + 1;\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full <= 0;\n    end else begin\n        if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= (write_ptr_plus_one == FIFO_TX_MEM_DEPTH) ? 0 : write_ptr_plus_one;\n        end\n        full <= next_full;\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty <= 1;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= (adr_o + 1 == FIFO_TX_MEM_DEPTH) ? 0 : adr_o + 1;\n        end\n        empty <= next_empty;\n    end\nend\n\n// Full and empty logic\nassign next_full = (write_ptr_plus_one == adr_o);\nassign next_empty = (adr_i == adr_o);\n\n// FIFO occupancy calculation\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 0;\n    end else begin\n        mem_empt <= (adr_i >= adr_o) ? (adr_i - adr_o) : (FIFO_TX_MEM_DEPTH + adr_i - adr_o);\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n    wire full;\n    wire [31:0] fifo_data_out;\n\n    // Submodule: sd_tx_fifo\n    sd_tx_fifo tx_fifo (\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(fifo_data_out),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    assign dat_o = fifo_data_out;\n    assign fe = full;\n\n    // State machine for control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 1;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            if (en) begin\n                if (!full && !m_wb_cyc_o && ackd) begin\n                    m_wb_adr_o <= adr + (offset * `MEM_OFFSET);\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00; // Linear burst\n                end\n\n                if (m_wb_ack_i) begin\n                    wr_tx <= 1;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    delay <= 1;\n                end\n\n                if (delay) begin\n                    offset <= offset + 1;\n                    ackd <= !ackd;\n                    wr_tx <= 0;\n                    delay <= 0;\n                end\n            end else begin\n                reset_tx_fifo <= 1;\n                offset <= 0;\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                m_wb_we_o <= 0;\n            end\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n// FIFO memory and pointers\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n        we <= 8'h1;\n    end else if (wr) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 7) begin\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            ft <= 0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Full and empty flags\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n        empty <= 1;\n    end else begin\n        full <= (adr_i == adr_o - 1);\n        empty <= (adr_i == adr_o);\n    end\nend\n\n// Memory empty space calculation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 2'b11; // Assuming FIFO_RX_MEM_DEPTH is 4 for this example\n    end else begin\n        case (adr_i - adr_o)\n            0: mem_empt <= 2'b11;\n            1: mem_empt <= 2'b10;\n            2: mem_empt <= 2'b01;\n            3: mem_empt <= 2'b00;\n            default: mem_empt <= 2'b11;\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for state machine\n    reg [2:0] state, next_state;\n\n    // Registers for debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Registers for synchronizers\n    reg req_in_q, req_in_int;\n    reg ack_in_q, ack_in_int;\n\n    // Registers for internal use\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n\n    // FSM state transition logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Debounce logic for card detect\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 0;\n            card_present <= 0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1;\n            end else begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        end\n    end\n\n    // Synchronizers for req_in and ack_in\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_in_q <= 0;\n            req_in_int <= 0;\n            ack_in_q <= 0;\n            ack_in_int <= 0;\n        end else begin\n            req_in_q <= req_in;\n            req_in_int <= req_in_q;\n            ack_in_q <= ack_in;\n            ack_in_int <= ack_in_q;\n        end\n    end\n\n    // Output logic based on current state\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            STATUS_REG <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            go_idle_o <= 0;\n            cmd_out <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            Watchdog_Cnt <= 0;\n            complete <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    STATUS_REG <= 0;\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111; // Delay\n                    settings[7] <= CMD_SET_REG[3]; // CRCE\n                    settings[6:0] <= (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) ? 7'b0101000 : \n                                     (CMD_SET_REG[1:0] == 2'b01) ? 7'b1111111 : 7'b0000000;\n                    Watchdog_Cnt <= 0;\n                end\n                EXECUTE: begin\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1; // CTE\n                        NORMAL_INT_REG[15] <= 1; // EI\n                        go_idle_o <= 1;\n                    end else begin\n                        Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                        if (serial_status[6]) begin\n                            complete <= 1;\n                            NORMAL_INT_REG[0] <= 1; // CC\n                        end\n                        if (CMD_SET_REG[4] && !serial_status[5]) begin\n                            ERR_INT_REG[1] <= 1; // CCRCE\n                            NORMAL_INT_REG[15] <= 1; // EI\n                        end\n                        if (CMD_SET_REG[3] && (cmd_out[37:32] != cmd_in[37:32])) begin\n                            ERR_INT_REG[3] <= 1; // CIE\n                            NORMAL_INT_REG[15] <= 1; // EI\n                        end\n                        if (settings[6:0] != 0) begin\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n// FIFO memory and pointers\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Temporary storage and write enable\nreg [31:0] tmp;\nreg [7:0] we;\nreg ft;\n\n// Internal signals\nwire write_enable;\nwire read_enable;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] next_adr_i, next_adr_o;\n\nassign write_enable = wr && !full;\nassign read_enable = rd && !empty;\n\nassign next_adr_i = (adr_i + 1) % FIFO_RX_MEM_DEPTH;\nassign next_adr_o = (adr_o + 1) % FIFO_RX_MEM_DEPTH;\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        we <= 8'h1;\n        ft <= 0;\n    end else if (write_enable) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 3) begin\n            ram[adr_i] <= tmp;\n            adr_i <= next_adr_i;\n            ft <= 0;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (read_enable) begin\n        q <= ram[adr_o];\n        adr_o <= next_adr_o;\n    end\nend\n\nalways @(*) begin\n    full = (next_adr_i == adr_o);\n    empty = (adr_i == adr_o);\n    mem_empt = FIFO_RX_MEM_DEPTH - (adr_i >= adr_o ? adr_i - adr_o : FIFO_RX_MEM_DEPTH + adr_i - adr_o);\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output full,\n    output empty,\n    output [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO parameters\nlocalparam FIFO_DEPTH = `FIFO_TX_MEM_DEPTH;\nlocalparam ADDR_SIZE = `FIFO_TX_MEM_ADR_SIZE;\n\n// RAM storage\nreg [31:0] ram[FIFO_DEPTH-1:0];\n\n// Pointers and status signals\nreg [ADDR_SIZE-1:0] adr_i, adr_o;\nwire [ADDR_SIZE:0] next_adr_i, next_adr_o;\nreg full_reg, empty_reg;\n\n// Write logic\nassign next_adr_i = adr_i + 1'b1;\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full_reg <= 1'b0;\n    end else if (wr && !full_reg) begin\n        ram[adr_i] <= d;\n        adr_i <= next_adr_i[ADDR_SIZE-1:0];\n    end\nend\n\n// Read logic\nassign next_adr_o = adr_o + 1'b1;\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty_reg <= 1'b1;\n    end else if (rd && !empty_reg) begin\n        adr_o <= next_adr_o[ADDR_SIZE-1:0];\n    end\nend\n\n// Output data\nassign q = ram[adr_o];\n\n// Full and empty logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        full_reg <= 1'b0;\n    end else begin\n        full_reg <= (next_adr_i[ADDR_SIZE-1:0] == adr_o) && (next_adr_i[ADDR_SIZE] != adr_o[ADDR_SIZE-1]);\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        empty_reg <= 1'b1;\n    end else begin\n        empty_reg <= (adr_i == next_adr_o[ADDR_SIZE-1:0]) && (adr_i[ADDR_SIZE-1] == next_adr_o[ADDR_SIZE]);\n    end\nend\n\n// Output status signals\nassign full = full_reg;\nassign empty = empty_reg;\n\n// Memory occupancy\nassign mem_empt = adr_i - adr_o;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output full,\n    output empty,\n    output [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Write and read pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals\nwire write_enable, read_enable;\nwire [FIFO_TX_MEM_ADR_SIZE-1:0] next_adr_i, next_adr_o;\nreg full_reg, empty_reg;\n\n// Write enable condition\nassign write_enable = wr && !full_reg;\n\n// Read enable condition\nassign read_enable = rd && !empty_reg;\n\n// Pointer increment logic\nassign next_adr_i = (adr_i == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_i + 1;\nassign next_adr_o = (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full_reg <= 0;\n    end else if (write_enable) begin\n        ram[adr_i] <= d;\n        adr_i <= next_adr_i;\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty_reg <= 1;\n    end else if (read_enable) begin\n        adr_o <= next_adr_o;\n    end\nend\n\n// Output data\nassign q = ram[adr_o];\n\n// Full and empty flag logic\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full_reg <= 0;\n        empty_reg <= 1;\n    end else begin\n        full_reg <= (next_adr_i == adr_o);\n        empty_reg <= (adr_i == adr_o);\n    end\nend\n\n// FIFO occupancy calculation\nassign mem_empt = adr_i - adr_o;\n\n// Output flags\nassign full = full_reg;\nassign empty = empty_reg;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n\n// Write and read address pointers\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Byte-wise write enable and temporary storage\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\n// Internal signals\nwire write_enable;\nwire read_enable;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] next_adr_i;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] next_adr_o;\n\nassign write_enable = wr && !full;\nassign read_enable = rd && !empty;\n\nassign next_adr_i = (adr_i == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_i + 1;\nassign next_adr_o = (adr_o == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n        we <= 8'h1;\n    end else if (write_enable) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 3) begin\n            ram[adr_i] <= tmp;\n            adr_i <= next_adr_i;\n            ft <= 0;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (read_enable) begin\n        q <= ram[adr_o];\n        adr_o <= next_adr_o;\n    end\nend\n\nalways @(*) begin\n    full = (next_adr_i == adr_o);\n    empty = (adr_i == adr_o);\n    mem_empt = FIFO_RX_MEM_DEPTH - (adr_i >= adr_o ? adr_i - adr_o : FIFO_RX_MEM_DEPTH + adr_i - adr_o);\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [FIFO_TX_MEM_DEPTH-1:0];\n\n// Write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty detection\nwire next_full;\nwire next_empty;\nwire [FIFO_TX_MEM_ADR_SIZE:0] write_ptr_plus_one;\nwire [FIFO_TX_MEM_ADR_SIZE:0] adr_diff;\n\nassign write_ptr_plus_one = adr_i + 1;\nassign next_full = (write_ptr_plus_one[FIFO_TX_MEM_ADR_SIZE-1:0] == adr_o) &&\n                   (write_ptr_plus_one[FIFO_TX_MEM_ADR_SIZE] != adr_o[FIFO_TX_MEM_ADR_SIZE]);\nassign next_empty = (adr_i == adr_o);\n\n// Data output\nassign q = ram[adr_o];\n\n// Pointer difference for mem_empt calculation\nassign adr_diff = adr_i - adr_o;\nassign mem_empt = adr_diff[FIFO_TX_MEM_ADR_SIZE-1:0];\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full <= 0;\n    end else begin\n        if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= write_ptr_plus_one[FIFO_TX_MEM_ADR_SIZE-1:0];\n        end\n        full <= next_full;\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty <= 1;\n    end else begin\n        if (rd && !empty) begin\n            adr_o <= adr_o + 1;\n        end\n        empty <= next_empty;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 4, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // External Signals\n    wire [15:0] crc_out[SD_BUS_W-1:0];\n\n    // Submodules\n    genvar i;\n    generate\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen_blocks\n            sd_crc_16 crc_block(\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[i])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            // State definitions\n            // Transitions based on conditions\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            // Reset conditions\n        end else begin\n            case (state)\n                // Output logic based on state\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output reg [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty detection\nwire next_full;\nwire next_empty;\nwire [FIFO_TX_MEM_ADR_SIZE:0] write_ptr_plus_one;\n\n// Pointer increment and wrap-around logic\nassign write_ptr_plus_one = adr_i + 1;\n\n// Write logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        adr_i <= (write_ptr_plus_one == FIFO_TX_MEM_DEPTH) ? 0 : write_ptr_plus_one;\n    end\n    full <= next_full;\nend\n\n// Read logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty <= 1;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= (adr_o == FIFO_TX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n    end\n    empty <= next_empty;\nend\n\n// Full and empty flags logic\nassign next_full = (write_ptr_plus_one == adr_o);\nassign next_empty = (adr_i == adr_o);\n\n// FIFO occupancy calculation\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 0;\n    end else begin\n        mem_empt <= (adr_i >= adr_o) ? (adr_i - adr_o) : (FIFO_TX_MEM_DEPTH + adr_i - adr_o);\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\n\n// Write and read address pointers\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Byte-wise write enable\nreg [7:0] we;\n\n// Temporary storage\nreg [31:0] tmp;\n\n// Data written flag\nreg ft;\n\n// Internal signals\nwire write_enable;\nwire read_enable;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] next_adr_i;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] next_adr_o;\n\nassign write_enable = wr && (adr_i != adr_o || empty);\nassign read_enable = rd && !empty;\nassign next_adr_i = (adr_i == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_i + 1;\nassign next_adr_o = (adr_o == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n        we <= 8'h1;\n    end else if (write_enable) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 3) begin\n            ram[adr_i] <= tmp;\n            adr_i <= next_adr_i;\n            ft <= 0;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (read_enable) begin\n        q <= ram[adr_o];\n        adr_o <= next_adr_o;\n    end\nend\n\nalways @(*) begin\n    full = (next_adr_i == adr_o);\n    empty = (adr_i == adr_o);\n    mem_empt = FIFO_RX_MEM_DEPTH - (adr_i >= adr_o ? adr_i - adr_o : FIFO_RX_MEM_DEPTH + adr_i - adr_o);\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo (\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output [1:0] mem_empt\n);\n\n// FIFO memory and pointers\nreg [31:0] ram [0:FIFO_RX_MEM_DEPTH-1];\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\n// Temporary variables for full and empty logic\nwire write_cond, read_cond;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] next_adr_i, next_adr_o;\n\nassign write_cond = wr && (adr_i != adr_o || empty);\nassign read_cond = rd && !empty;\nassign next_adr_i = (adr_i + 1) % FIFO_RX_MEM_DEPTH;\nassign next_adr_o = (adr_o + 1) % FIFO_RX_MEM_DEPTH;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n        we <= 8'h1;\n    end else if (write_cond) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 3) begin\n            ram[adr_i] <= tmp;\n            adr_i <= next_adr_i;\n            ft <= 0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (read_cond) begin\n        q <= ram[adr_o];\n        adr_o <= next_adr_o;\n    end\nend\n\n// Full and empty flags\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n        empty <= 1;\n    end else begin\n        full <= (next_adr_i == adr_o);\n        empty <= (adr_i == adr_o) && (ft == 0);\n    end\nend\n\n// Memory empty space calculation\nassign mem_empt = FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output reg [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty detection\nwire write_cond, read_cond;\nwire [FIFO_TX_MEM_ADR_SIZE:0] next_adr_i, next_adr_o;\nwire [FIFO_TX_MEM_ADR_SIZE:0] diff;\n\nassign write_cond = wr && !full;\nassign read_cond = rd && !empty;\n\nassign next_adr_i = adr_i + 1;\nassign next_adr_o = adr_o + 1;\n\nassign diff = adr_i - adr_o;\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full <= 0;\n    end else begin\n        if (write_cond) begin\n            ram[adr_i] <= d;\n            adr_i <= next_adr_i[FIFO_TX_MEM_ADR_SIZE-1:0];\n        end\n        full <= (next_adr_i[FIFO_TX_MEM_ADR_SIZE-1:0] == adr_o) &&\n                (next_adr_i[FIFO_TX_MEM_ADR_SIZE] != adr_o[FIFO_TX_MEM_ADR_SIZE]);\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty <= 1;\n        q <= 0;\n    end else begin\n        if (read_cond) begin\n            q <= ram[adr_o];\n            adr_o <= next_adr_o[FIFO_TX_MEM_ADR_SIZE-1:0];\n        end\n        empty <= (adr_i == adr_o);\n    end\nend\n\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 0;\n    end else begin\n        mem_empt <= diff[FIFO_TX_MEM_ADR_SIZE-1:0];\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output reg [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty detection\nwire next_full;\nwire next_empty;\nwire [FIFO_TX_MEM_ADR_SIZE:0] write_ptr_plus_one;\nwire [FIFO_TX_MEM_ADR_SIZE:0] read_ptr_plus_one;\n\n// Pointer increment and wrap-around logic\nassign write_ptr_plus_one = adr_i + 1;\nassign read_ptr_plus_one = adr_o + 1;\n\n// Full and empty logic\nassign next_full = (write_ptr_plus_one[FIFO_TX_MEM_ADR_SIZE-1:0] == adr_o) &&\n                   (write_ptr_plus_one[FIFO_TX_MEM_ADR_SIZE] != adr_o[FIFO_TX_MEM_ADR_SIZE]);\nassign next_empty = (adr_i == adr_o);\n\n// Asynchronous reset\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full <= 0;\n    end else begin\n        if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= write_ptr_plus_one[FIFO_TX_MEM_ADR_SIZE-1:0];\n        end\n        full <= next_full;\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty <= 1;\n        q <= 0;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= read_ptr_plus_one[FIFO_TX_MEM_ADR_SIZE-1:0];\n        end\n        empty <= next_empty;\n    end\nend\n\n// FIFO occupancy calculation\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 0;\n    end else begin\n        mem_empt <= adr_i >= adr_o ? adr_i - adr_o : (FIFO_TX_MEM_DEPTH + adr_i - adr_o);\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output reg [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty detection\nwire next_full;\nwire next_empty;\nwire [FIFO_TX_MEM_ADR_SIZE:0] write_pointer_plus_one;\n\n// Pointer increment and wrap-around logic\nassign write_pointer_plus_one = adr_i + 1;\n\n// Write logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full <= 0;\n    end else begin\n        if (wr && !full) begin\n            ram[adr_i] <= d;\n            adr_i <= (write_pointer_plus_one == FIFO_TX_MEM_DEPTH) ? 0 : write_pointer_plus_one;\n        end\n        full <= next_full;\n    end\nend\n\n// Read logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty <= 1;\n    end else begin\n        if (rd && !empty) begin\n            q <= ram[adr_o];\n            adr_o <= (adr_o + 1 == FIFO_TX_MEM_DEPTH) ? 0 : adr_o + 1;\n        end\n        empty <= next_empty;\n    end\nend\n\n// Full and empty logic\nassign next_full = (write_pointer_plus_one == adr_o);\nassign next_empty = (adr_i == adr_o);\n\n// FIFO occupancy calculation\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 0;\n    end else begin\n        mem_empt <= (adr_i >= adr_o) ? (adr_i - adr_o) : (FIFO_TX_MEM_DEPTH + adr_i - adr_o);\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for FSM\n    reg [2:0] state, next_state;\n\n    // Registers for debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Registers for synchronization\n    reg req_in_q, req_in_int;\n    reg ack_in_q, ack_in_int;\n\n    // Registers for FSM operation\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [6:0] response_size;\n\n    // Debounce logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1110)\n                    card_present <= 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n                card_present <= 1'b0;\n            end\n        end\n    end\n\n    // Synchronization logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_in_q <= 1'b0;\n            req_in_int <= 1'b0;\n            ack_in_q <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_in_q <= req_in;\n            req_in_int <= req_in_q;\n            ack_in_q <= ack_in;\n            ack_in_int <= ack_in_q;\n        end\n    end\n\n    // FSM logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = New_CMD ? SETUP : IDLE;\n            SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = complete ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            go_idle_o <= 1'b0;\n            req_out <= 1'b0;\n            ack_out <= 1'b0;\n            STATUS_REG <= 16'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            settings <= 16'b0;\n            cmd_out <= 40'b0;\n            Watchdog_Cnt <= 16'b0;\n            complete <= 1'b0;\n            index_check_enable <= 1'b0;\n            CRC_check_enable <= 1'b0;\n            response_size <= 7'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n                    response_size <= (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) ? 7'b0101000 :\n                                     (CMD_SET_REG[1:0] == 2'b01) ? 7'b1111111 : 7'b0;\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CMD_SET_REG[3];\n                    settings[6:0] <= response_size;\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1; // CTE\n                        NORMAL_INT_REG[15] <= 1'b1; // EI\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1'b1;\n                        if (serial_status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[0] <= 1'b1; // CC\n                            if (CRC_check_enable && !serial_status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1; // CCRCE\n                                NORMAL_INT_REG[15] <= 1'b1; // EI\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1; // CIE\n                                NORMAL_INT_REG[15] <= 1'b1; // EI\n                            end\n                            if (response_size != 0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output reg [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Write and read address pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty detection\nwire next_full;\nwire next_empty;\nwire [FIFO_TX_MEM_ADR_SIZE-1:0] next_adr_i;\nwire [FIFO_TX_MEM_ADR_SIZE-1:0] next_adr_o;\n\n// Calculate next address pointers\nassign next_adr_i = (adr_i + 1) % FIFO_TX_MEM_DEPTH;\nassign next_adr_o = (adr_o + 1) % FIFO_TX_MEM_DEPTH;\n\n// Determine if FIFO is full or empty\nassign next_full = (next_adr_i == adr_o);\nassign next_empty = (adr_i == adr_o);\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full <= 0;\n    end else if (wr && !full) begin\n        ram[adr_i] <= d;\n        adr_i <= next_adr_i;\n        full <= next_full;\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty <= 1;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= next_adr_o;\n        empty <= next_empty;\n    end\nend\n\n// Update FIFO status flags and occupancy\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n        empty <= 1;\n        mem_empt <= 0;\n    end else begin\n        full <= (next_adr_i == adr_o);\n        empty <= (adr_i == adr_o);\n        mem_empt <= adr_i - adr_o;\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_tx_fifo", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_tx_fifo (\n    input [31:0] d,\n    input wr,\n    input wclk,\n    output reg [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [5:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [0:FIFO_TX_MEM_DEPTH-1];\n\n// Write and read pointers\nreg [FIFO_TX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Internal signals for full and empty detection\nwire write_condition_met;\nwire read_condition_met;\nwire next_full;\nwire next_empty;\n\n// Pointer increment and wrap-around logic\nwire [FIFO_TX_MEM_ADR_SIZE-1:0] next_adr_i = (adr_i + 1) % FIFO_TX_MEM_DEPTH;\nwire [FIFO_TX_MEM_ADR_SIZE-1:0] next_adr_o = (adr_o + 1) % FIFO_TX_MEM_DEPTH;\n\n// Write operation\nassign write_condition_met = wr && !full;\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        full <= 0;\n    end else if (write_condition_met) begin\n        ram[adr_i] <= d;\n        adr_i <= next_adr_i;\n    end\n    full <= next_full;\nend\n\n// Read operation\nassign read_condition_met = rd && !empty;\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        empty <= 1;\n    end else if (read_condition_met) begin\n        q <= ram[adr_o];\n        adr_o <= next_adr_o;\n    end\n    empty <= next_empty;\nend\n\n// Status update logic\nassign next_full = (next_adr_i == adr_o);\nassign next_empty = (adr_i == adr_o);\n\n// FIFO occupancy calculation\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 0;\n    end else begin\n        mem_empt <= (adr_i >= adr_o) ? (adr_i - adr_o) : (FIFO_TX_MEM_DEPTH + adr_i - adr_o);\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n\n    // Instantiate the FIFO\n    sd_rx_fifo fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               READ_FIFO = 1,\n               WB_WRITE = 2,\n               WB_WAIT_ACK = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = en ? READ_FIFO : IDLE;\n            READ_FIFO: next_state = (!empty && wb_free) ? WB_WRITE : READ_FIFO;\n            WB_WRITE: next_state = WB_WAIT_ACK;\n            WB_WAIT_ACK: next_state = m_wb_ack_i ? IDLE : WB_WAIT_ACK;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic and control signal updates\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    wb_free <= 1;\n                    reset_rx_fifo <= 0;\n                    rd <= 0;\n                end\n                READ_FIFO: begin\n                    rd <= 1;\n                end\n                WB_WRITE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000;\n                    m_wb_bte_o <= 2'b00;\n                    wb_free <= 0;\n                end\n                WB_WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 0;\n                        m_wb_stb_o <= 0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    output reg [31:0] q,\n    input rd,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt,\n    input rclk,\n    input rst\n);\n\n// FIFO storage array\nreg [31:0] ram [FIFO_RX_MEM_DEPTH-1:0];\n\n// Write and read address pointers\nreg [FIFO_RX_MEM_ADR_SIZE-1:0] adr_i, adr_o;\n\n// Byte-wise write enable\nreg [7:0] we;\n\n// Temporary storage for incoming data\nreg [31:0] tmp;\n\n// Data written flag\nreg ft;\n\n// Internal signals\nwire write_enable;\nwire read_enable;\nwire [FIFO_RX_MEM_ADR_SIZE-1:0] next_adr_i, next_adr_o;\nwire fifo_full, fifo_empty;\n\nassign write_enable = wr && !full;\nassign read_enable = rd && !empty;\n\nassign next_adr_i = (adr_i == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_i + 1;\nassign next_adr_o = (adr_o == FIFO_RX_MEM_DEPTH-1) ? 0 : adr_o + 1;\n\nassign fifo_full = (next_adr_i == adr_o);\nassign fifo_empty = (adr_i == adr_o);\n\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n        we <= 8'h1;\n    end else if (write_enable) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 3) begin\n            ram[adr_i] <= tmp;\n            adr_i <= next_adr_i;\n            ft <= 0;\n        end\n    end\nend\n\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (read_enable) begin\n        q <= ram[adr_o];\n        adr_o <= next_adr_o;\n    end\nend\n\nalways @(*) begin\n    full = fifo_full;\n    empty = fifo_empty;\n    mem_empt = FIFO_RX_MEM_DEPTH - (adr_i - adr_o);\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register addresses\n    localparam ADDR_ARGUMENT           = 8'h00;\n    localparam ADDR_CMD_SETTING        = 8'h04;\n    localparam ADDR_CARD_STATUS        = 8'h08;\n    localparam ADDR_RESPONSE           = 8'h0C;\n    localparam ADDR_SOFTWARE_RESET     = 8'h28;\n    localparam ADDR_TIMEOUT            = 8'h2C;\n    localparam ADDR_NORMAL_INT_STATUS  = 8'h30;\n    localparam ADDR_ERROR_INT_STATUS   = 8'h34;\n    localparam ADDR_NORMAL_INT_ENABLE  = 8'h38;\n    localparam ADDR_ERROR_INT_ENABLE   = 8'h3C;\n    localparam ADDR_CLOCK_DIVIDER      = 8'h4C;\n    localparam ADDR_BD_STATUS          = 8'h50;\n    localparam ADDR_DAT_INT_STATUS     = 8'h54;\n    localparam ADDR_DAT_INT_ENABLE     = 8'h58;\n    localparam ADDR_BD_RX              = 8'h60;\n    localparam ADDR_BD_TX              = 8'h80;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the Wishbone transaction\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: argument_reg <= wb_dat_i;\n                    ADDR_CMD_SETTING: cmd_setting_reg <= wb_dat_i[15:0];\n                    ADDR_SOFTWARE_RESET: software_reset_reg <= wb_dat_i[7:0];\n                    ADDR_TIMEOUT: time_out_reg <= wb_dat_i[15:0];\n                    ADDR_NORMAL_INT_ENABLE: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_ERROR_INT_ENABLE: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_CLOCK_DIVIDER: clock_divider <= wb_dat_i[7:0];\n                    ADDR_DAT_INT_ENABLE: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    ADDR_BD_RX: begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                        we_m_rx_bd <= 1'b1;\n                    end\n                    ADDR_BD_TX: begin\n                        dat_in_m_tx_bd <= wb_dat_i;\n                        we_m_tx_bd <= 1'b1;\n                    end\n                    default: ;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: wb_dat_o <= argument_reg;\n                    ADDR_CMD_SETTING: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    ADDR_CARD_STATUS: wb_dat_o <= {16'b0, status_reg};\n                    ADDR_RESPONSE: wb_dat_o <= cmd_resp_1;\n                    ADDR_SOFTWARE_RESET: wb_dat_o <= {24'b0, software_reset_reg};\n                    ADDR_TIMEOUT: wb_dat_o <= {16'b0, time_out_reg};\n                    ADDR_NORMAL_INT_STATUS: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    ADDR_ERROR_INT_STATUS: wb_dat_o <= {16'b0, error_int_status_reg};\n                    ADDR_NORMAL_INT_ENABLE: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    ADDR_ERROR_INT_ENABLE: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    ADDR_CLOCK_DIVIDER: wb_dat_o <= {24'b0, clock_divider};\n                    ADDR_BD_STATUS: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    ADDR_DAT_INT_STATUS: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    ADDR_DAT_INT_ENABLE: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [15:0] crc_out[SD_BUS_W-1:0];\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int, ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Submodule Instances\n    genvar i;\n    generate\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_block(\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[i])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            // State definitions and transitions\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            // Reset conditions\n        end else begin\n            // Normal operation\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output [1:0] mem_empt\n);\n\n// FIFO memory depth and address size\nlocalparam FIFO_DEPTH = `FIFO_RX_MEM_DEPTH;\nlocalparam ADDR_SIZE = `FIFO_RX_MEM_ADR_SIZE;\n\n// RAM for FIFO storage\nreg [31:0] ram[FIFO_DEPTH-1:0];\n\n// Pointers and write enable\nreg [ADDR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\n// Internal signals\nwire [ADDR_SIZE-1:0] next_adr_i, next_adr_o;\nwire fifo_full, fifo_empty;\nwire write_cond, read_cond;\n\n// Calculate next addresses\nassign next_adr_i = (adr_i + 1) % FIFO_DEPTH;\nassign next_adr_o = (adr_o + 1) % FIFO_DEPTH;\n\n// Determine full and empty conditions\nassign fifo_full = (next_adr_i == adr_o);\nassign fifo_empty = (adr_i == adr_o);\n\n// Write condition: write enable is high and FIFO is not full\nassign write_cond = wr && !fifo_full;\n\n// Read condition: read enable is high and FIFO is not empty\nassign read_cond = rd && !fifo_empty;\n\n// Write operation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        ft <= 0;\n    end else if (write_cond) begin\n        tmp <= {tmp[27:0], d}; // Shift and write new data\n        ft <= ft + 1;\n        if (ft == 7) begin // Last byte to form a word\n            ram[adr_i] <= tmp;\n            adr_i <= next_adr_i;\n            ft <= 0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (read_cond) begin\n        q <= ram[adr_o];\n        adr_o <= next_adr_o;\n    end\nend\n\n// Update full and empty flags\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n        empty <= 1;\n    end else begin\n        full <= fifo_full;\n        empty <= fifo_empty;\n    end\nend\n\n// Memory empty space calculation\nassign mem_empt = FIFO_DEPTH - (adr_i - adr_o);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out [0:SD_BUS_W-1];\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int, ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // State Definitions\n    localparam IDLE = 6'b000001;\n    localparam WRITE_DAT = 6'b000010;\n    localparam WRITE_CRC = 6'b000100;\n    localparam WRITE_BUSY = 6'b001000;\n    localparam READ_WAIT = 6'b010000;\n    localparam READ_DAT = 6'b100000;\n\n    // ACK_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO Block\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM_SEQ Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT Block\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset all outputs and internal registers\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            // Normal operation based on state\n            case (state)\n                WRITE_DAT: begin\n                    // Implement WRITE_DAT logic here\n                end\n                WRITE_CRC: begin\n                    // Implement WRITE_CRC logic here\n                end\n                WRITE_BUSY: begin\n                    // Implement WRITE_BUSY logic here\n                end\n                READ_WAIT: begin\n                    // Implement READ_WAIT logic here\n                end\n                READ_DAT: begin\n                    // Implement READ_DAT logic here\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out[SD_BUS_W-1:0];\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // State Definitions\n    localparam IDLE = 6'd0,\n               WRITE_DAT = 6'd1,\n               WRITE_CRC = 6'd2,\n               WRITE_BUSY = 6'd3,\n               READ_WAIT = 6'd4,\n               READ_DAT = 6'd5;\n\n    // CRC Generation Block\n    sd_crc_16 crc_gen(\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK Synchronization\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b001)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM_SEQ Logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset all outputs and internal registers\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            // Normal operation logic\n            // Implement the FSM_OUT logic here based on the state\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n// FIFO memory parameters\nlocalparam FIFO_DEPTH = `FIFO_RX_MEM_DEPTH;\nlocalparam ADDR_SIZE = `FIFO_RX_MEM_ADR_SIZE;\n\n// Internal registers and memories\nreg [31:0] ram [0:FIFO_DEPTH-1];\nreg [ADDR_SIZE-1:0] adr_i, adr_o;\nreg [7:0] we;\nreg [31:0] tmp;\nreg ft;\n\n// Write logic\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        we <= 8'h1;\n        tmp <= 0;\n        ft <= 0;\n    end else if (wr) begin\n        tmp <= {tmp[27:0], d};\n        ft <= ft + 1;\n        if (ft == 3) begin\n            ram[adr_i] <= tmp;\n            adr_i <= adr_i + 1;\n            ft <= 0;\n        end\n    end\nend\n\n// Read logic\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= adr_o + 1;\n    end\nend\n\n// Full and empty flags\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n        empty <= 1;\n    end else begin\n        full <= (adr_i == adr_o - 1);\n        empty <= (adr_i == adr_o);\n    end\nend\n\n// Memory empty space calculation\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 2'b11;\n    end else begin\n        case ({full, empty})\n            2'b10: mem_empt <= 2'b00;\n            2'b01: mem_empt <= 2'b11;\n            default: mem_empt <= adr_o - adr_i;\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register addresses\n    localparam ADDR_ARGUMENT           = 8'h00;\n    localparam ADDR_CMD_SETTING        = 8'h04;\n    localparam ADDR_CARD_STATUS        = 8'h08;\n    localparam ADDR_RESPONSE           = 8'h0C;\n    localparam ADDR_SOFTWARE_RESET     = 8'h28;\n    localparam ADDR_TIMEOUT            = 8'h2C;\n    localparam ADDR_NORMAL_INT_STATUS  = 8'h30;\n    localparam ADDR_ERROR_INT_STATUS   = 8'h34;\n    localparam ADDR_NORMAL_INT_ENABLE  = 8'h38;\n    localparam ADDR_ERROR_INT_ENABLE   = 8'h3C;\n    localparam ADDR_CLOCK_DIVIDER      = 8'h4C;\n    localparam ADDR_BD_STATUS          = 8'h50;\n    localparam ADDR_DAT_INT_STATUS     = 8'h54;\n    localparam ADDR_DAT_INT_ENABLE     = 8'h58;\n    localparam ADDR_BD_RX              = 8'h60;\n    localparam ADDR_BD_TX              = 8'h80;\n\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers and outputs\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1; // Default to high\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else begin\n            // Acknowledge logic\n            wb_ack_o <= wb_cyc_i & wb_stb_i & ~wb_ack_o & int_ack;\n\n            if (wb_cyc_i & wb_stb_i) begin\n                if (wb_we_i) begin\n                    // Write operation\n                    case (wb_adr_i)\n                        ADDR_ARGUMENT: argument_reg <= wb_dat_i;\n                        ADDR_CMD_SETTING: cmd_setting_reg <= wb_dat_i[15:0];\n                        ADDR_SOFTWARE_RESET: software_reset_reg <= wb_dat_i[7:0];\n                        ADDR_TIMEOUT: time_out_reg <= wb_dat_i[15:0];\n                        ADDR_NORMAL_INT_ENABLE: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                        ADDR_ERROR_INT_ENABLE: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                        ADDR_CLOCK_DIVIDER: clock_divider <= wb_dat_i[7:0];\n                        ADDR_DAT_INT_ENABLE: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                        ADDR_BD_RX: begin\n                            dat_in_m_rx_bd <= wb_dat_i;\n                            we_m_rx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                        end\n                        ADDR_BD_TX: begin\n                            dat_in_m_tx_bd <= wb_dat_i;\n                            we_m_tx_bd <= 1'b1;\n                            int_ack <= 1'b0;\n                        end\n                        default: ;\n                    endcase\n                end else begin\n                    // Read operation\n                    case (wb_adr_i)\n                        ADDR_ARGUMENT: wb_dat_o <= argument_reg;\n                        ADDR_CMD_SETTING: wb_dat_o <= {16'b0, cmd_setting_reg};\n                        ADDR_CARD_STATUS: wb_dat_o <= {16'b0, status_reg};\n                        ADDR_RESPONSE: wb_dat_o <= cmd_resp_1;\n                        ADDR_SOFTWARE_RESET: wb_dat_o <= {24'b0, software_reset_reg};\n                        ADDR_TIMEOUT: wb_dat_o <= {16'b0, time_out_reg};\n                        ADDR_NORMAL_INT_STATUS: wb_dat_o <= {16'b0, normal_int_status_reg};\n                        ADDR_ERROR_INT_STATUS: wb_dat_o <= {16'b0, error_int_status_reg};\n                        ADDR_NORMAL_INT_ENABLE: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                        ADDR_ERROR_INT_ENABLE: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                        ADDR_CLOCK_DIVIDER: wb_dat_o <= {24'b0, clock_divider};\n                        ADDR_BD_STATUS: wb_dat_o <= {16'b0, Bd_Status_reg};\n                        ADDR_DAT_INT_STATUS: wb_dat_o <= {24'b0, Bd_isr_reg};\n                        ADDR_DAT_INT_ENABLE: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                        default: wb_dat_o <= 32'b0;\n                    endcase\n                end\n            end\n\n            if (!wb_cyc_i) begin\n                // Reset signals after transaction\n                we_m_tx_bd <= 1'b0;\n                we_m_rx_bd <= 1'b0;\n                int_ack <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output reg empty,\n    output reg fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Submodule instantiation\n    sd_tx_fifo tx_fifo(\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 1;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00; // Linear burst\n                end\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    delay <= 1;\n                end\n                if (delay) begin\n                    offset <= offset + 4;\n                    ackd <= !ackd;\n                    wr_tx <= 0;\n                    delay <= 0;\n                end\n            end else begin\n                reset_tx_fifo <= 1;\n                offset <= 0;\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                m_wb_we_o <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal parameters\n    parameter INIT_DELAY = `SIM ? 2 : 64;\n    parameter NCR = 2;\n    parameter SEND_SIZE = 48;\n    parameter SIZE = 10;\n    parameter CONTENT_SIZE = 40;\n    parameter Read_Delay = 7;\n    parameter EIGHT_PAD = 8;\n\n    // State definitions\n    localparam [SIZE-1:0] \n        INIT = 10'b0000000001,\n        IDLE = 10'b0000000010,\n        WRITE_WR = 10'b0000000100,\n        DLY_WR = 10'b0000001000,\n        READ_WR = 10'b0000010000,\n        DLY_READ = 10'b0000100000,\n        ACK_WR = 10'b0001000000,\n        WRITE_WO = 10'b0010000000,\n        DLY_WO = 10'b0100000000,\n        ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_Enable, CRC_Check_On, CRC_Valid, Crc_Buffering;\n    reg [6:0] CRC_IN, CRC_VAL;\n    reg CRC_OUT;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in, q1, Ack_internal_in;\n\n    // Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // FSM_COMBO logic\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n            Cmd_Cnt <= 0;\n            Delay_Cnt <= 0;\n        end else begin\n            state <= next_state;\n            if (state == WRITE_WR || state == WRITE_WO) Cmd_Cnt <= Cmd_Cnt + 1;\n            if (state == DLY_WR || state == DLY_WO || state == DLY_READ) Delay_Cnt <= Delay_Cnt + 1;\n        end\n    end\n\n    // COMMAND_DECODER logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            CRC_Check_On <= 0;\n            Delay_Cycler <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n            In_Buff <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 0;\n            cmd_out_o <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                end\n                WRITE_WR, WRITE_WO: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                end\n                ACK_WO, ACK_WR: begin\n                    ACK_OUT <= 1;\n                    REQ_OUT <= 0;\n                end\n                default: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_rx_fifo", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_rx_fifo(\n    input [3:0] d,\n    input wr,\n    input wclk,\n    input rd,\n    input rclk,\n    input rst,\n    output reg [31:0] q,\n    output reg full,\n    output reg empty,\n    output reg [1:0] mem_empt\n);\n\n// FIFO memory depth and address size from sd_defines.v\nlocalparam FIFO_DEPTH = `FIFO_RX_MEM_DEPTH;\nlocalparam ADDR_SIZE = `FIFO_RX_MEM_ADR_SIZE;\n\n// RAM for FIFO\nreg [31:0] ram[FIFO_DEPTH-1:0];\n\n// Pointers and temporary storage\nreg [ADDR_SIZE-1:0] adr_i, adr_o;\nreg [31:0] tmp;\nreg [2:0] count; // To count the number of 4-bit chunks received\nreg ft; // Data written flag\n\n// Asynchronous reset\nalways @(posedge wclk or posedge rst) begin\n    if (rst) begin\n        adr_i <= 0;\n        tmp <= 0;\n        count <= 0;\n        ft <= 0;\n    end else if (wr) begin\n        tmp <= (tmp << 4) | d;\n        count <= count + 1;\n        if (count == 7) begin\n            ram[adr_i] <= tmp;\n            adr_i <= (adr_i == FIFO_DEPTH-1) ? 0 : adr_i + 1;\n            ft <= 1;\n            count <= 0;\n        end\n    end\nend\n\n// Read operation\nalways @(posedge rclk or posedge rst) begin\n    if (rst) begin\n        adr_o <= 0;\n        q <= 0;\n    end else if (rd && !empty) begin\n        q <= ram[adr_o];\n        adr_o <= (adr_o == FIFO_DEPTH-1) ? 0 : adr_o + 1;\n    end\nend\n\n// Full and empty flags\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        full <= 0;\n        empty <= 1;\n    end else begin\n        full <= (adr_i == adr_o) && ft;\n        empty <= (adr_i == adr_o) && !ft;\n    end\nend\n\n// Memory empty space calculation\nalways @(posedge wclk or posedge rclk or posedge rst) begin\n    if (rst) begin\n        mem_empt <= 2'b11; // Maximum space available\n    end else begin\n        case ({full, empty})\n            2'b10: mem_empt <= 2'b00; // No space available\n            2'b01: mem_empt <= 2'b11; // Full space available\n            default: mem_empt <= 2'b10; // Partially available\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [SD_BUS_W*16-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // State Definitions\n    localparam IDLE = 6'b000001;\n    localparam WRITE_DAT = 6'b000010;\n    localparam WRITE_CRC = 6'b000100;\n    localparam WRITE_BUSY = 6'b001000;\n    localparam READ_WAIT = 6'b010000;\n    localparam READ_DAT = 6'b100000;\n\n    // CRC Generation Block\n    wire [15:0] crc_bit_out;\n    sd_crc_16 crc_gen (\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_bit_out)\n    );\n\n    // Assign CRC output\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            crc_out <= 0;\n        end else if (crc_en) begin\n            crc_out <= {crc_out[SD_BUS_W*16-17:0], crc_bit_out};\n        end\n    end\n\n    // ACK_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM_SEQ Logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset conditions\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                WRITE_DAT: begin\n                    // Write data logic\n                end\n                WRITE_CRC: begin\n                    // Write CRC logic\n                end\n                WRITE_BUSY: begin\n                    // Write busy logic\n                end\n                READ_WAIT: begin\n                    // Read wait logic\n                end\n                READ_DAT: begin\n                    // Read data logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // State definitions\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_Enable, CRC_OUT, CRC_Check_On, Crc_Buffering, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in, q1, Ack_internal_in;\n\n    // Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // FSM_COMBO logic\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = Write_Read ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // COMMAND_DECODER logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                end\n                WRITE_WR: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= (Cmd_Cnt < SEND_SIZE) ? In_Buff[Cmd_Cnt] : 1;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                WRITE_WO: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= (Cmd_Cnt < SEND_SIZE) ? In_Buff[Cmd_Cnt] : 1;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_WR: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                DLY_WO: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                READ_WR: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                    Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_READ: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    ACK_OUT <= 1;\n                end\n                ACK_WR: begin\n                    ACK_OUT <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers and Wires\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int, ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Submodules\n    sd_crc_16 crc16_gen (\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // State Definitions\n    localparam IDLE        = 6'b000001;\n    localparam WRITE_DAT   = 6'b000010;\n    localparam WRITE_CRC   = 6'b000100;\n    localparam WRITE_BUSY  = 6'b001000;\n    localparam READ_WAIT   = 6'b010000;\n    localparam READ_DAT    = 6'b100000;\n\n    // Synchronize ack_transfer\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b001)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Sequential Logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output Logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            // Reset all outputs and internal registers\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            // Handle each state\n            case (state)\n                WRITE_DAT: begin\n                    // Implement WRITE_DAT logic\n                end\n                WRITE_CRC: begin\n                    // Implement WRITE_CRC logic\n                end\n                WRITE_BUSY: begin\n                    // Implement WRITE_BUSY logic\n                end\n                READ_WAIT: begin\n                    // Implement READ_WAIT logic\n                end\n                READ_DAT: begin\n                    // Implement READ_DAT logic\n                end\n                default: begin\n                    // Default case\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // FIFO interface\n    wire full;\n    wire [31:0] q;\n    wire [5:0] mem_empt;\n\n    // Instantiate the FIFO\n    sd_tx_fifo tx_fifo (\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(sd_clk),\n        .rst(rst)\n    );\n\n    // State machine for control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 1;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            if (en) begin\n                if (!fe && !m_wb_cyc_o && ackd) begin\n                    m_wb_adr_o <= adr + (offset << MEM_OFFSET);\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00; // Linear burst\n                end\n\n                if (m_wb_ack_i) begin\n                    wr_tx <= 1;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    delay <= 1;\n                end\n\n                if (delay) begin\n                    offset <= offset + 1;\n                    ackd <= !ackd;\n                    wr_tx <= 0;\n                    delay <= 0;\n                end\n            end else begin\n                reset_tx_fifo <= 1;\n                offset <= 0;\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                m_wb_we_o <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire [1:0] mem_empt;\n\n    // Instantiate the FIFO\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State machine for controlling the Wishbone interface\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_dat_o <= 32'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wb_free <= 1'b1;\n            reset_rx_fifo <= 1'b1;\n            rd <= 1'b0;\n        end else begin\n            if (en) begin\n                reset_rx_fifo <= 1'b0;\n                if (!empty && wb_free) begin\n                    rd <= 1'b1;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_we_o <= 1'b1;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00;  // Linear burst\n                    wb_free <= 1'b0;\n                end\n                if (m_wb_ack_i) begin\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    offset <= offset + MEM_OFFSET;\n                    wb_free <= 1'b1;\n                end\n            end else begin\n                reset_rx_fifo <= 1'b1;\n                rd <= 1'b0;\n                offset <= 9'b0;\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                wb_free <= 1'b1;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    input SD_CLK_IN,\n    input RST_IN,\n    input [15:0] SETTING_IN,\n    input [39:0] CMD_IN,\n    input REQ_IN,\n    input ACK_IN,\n    input cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    parameter INIT_DELAY = `SIM ? 2 : 64;\n    parameter NCR = 2;\n    parameter SEND_SIZE = 48;\n    parameter SIZE = 10;\n    parameter CONTENT_SIZE = 40;\n    parameter Read_Delay = 7;\n    parameter EIGHT_PAD = 8;\n\n    // State Definitions\n    parameter INIT = 10'b0000000001;\n    parameter IDLE = 10'b0000000010;\n    parameter WRITE_WR = 10'b0000000100;\n    parameter DLY_WR = 10'b0000001000;\n    parameter READ_WR = 10'b0000010000;\n    parameter DLY_READ = 10'b0000100000;\n    parameter ACK_WR = 10'b0001000000;\n    parameter WRITE_WO = 10'b0010000000;\n    parameter DLY_WO = 10'b0100000000;\n    parameter ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [SIZE-1:0] state, next_state;\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_Enable, CRC_OUT, CRC_Check_On, Crc_Buffering, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in, q1, Ack_internal_in;\n\n    // REQ_SYNC and ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 1;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    if (Cmd_Cnt < INIT_DELAY) Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= 0;\n                    ACK_OUT <= 1;\n                    REQ_OUT <= 0;\n                    STATUS <= 0;\n                end\n                WRITE_WR: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                    if (Cmd_Cnt < SEND_SIZE - 1) Cmd_Cnt <= Cmd_Cnt + 1;\n                    else CMD_OUT <= In_Buff;\n                end\n                WRITE_WO: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                    if (Cmd_Cnt < SEND_SIZE - 1) Cmd_Cnt <= Cmd_Cnt + 1;\n                    else CMD_OUT <= In_Buff;\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt < NCR) Delay_Cnt <= Delay_Cnt + 1;\n                    else cmd_oe_o <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt < Delay_Cycler) Delay_Cnt <= Delay_Cnt + 1;\n                    else cmd_oe_o <= 0;\n                end\n                READ_WR: begin\n                    if (Cmd_Cnt < Response_Size + EIGHT_PAD) begin\n                        Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else CMD_OUT <= Out_Buff;\n                end\n                DLY_READ: begin\n                    if (Ack_internal_in) ACK_OUT <= 0;\n                end\n                ACK_WO: begin\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                    STATUS <= 0;\n                end\n                ACK_WR: begin\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                    STATUS <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    input wire [31:0] m_wb_dat_i,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    output reg [31:0] dat_o,\n    input wire rd,\n    output reg empty,\n    output reg fe,\n    output wire reset_tx_fifo\n);\n\n// Submodule\nsd_tx_fifo tx_fifo (\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(),\n    .rclk(sd_clk),\n    .rst(reset_tx_fifo)\n);\n\n// Internal signals\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg first;\nreg ackd;\nreg delay;\n\nassign reset_tx_fifo = rst || (en == 0);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        // Reset all control signals and counters\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n        offset <= 0;\n        we <= 0;\n        din <= 0;\n        wr_tx <= 0;\n        first <= 1;\n        ackd <= 0;\n        delay <= 0;\n    end else begin\n        if (en) begin\n            if (!fe && !m_wb_ack_i && ackd) begin\n                // Start Wishbone read transaction\n                m_wb_adr_o <= adr + offset;\n                m_wb_cyc_o <= 1;\n                m_wb_stb_o <= 1;\n                m_wb_we_o <= 0;\n                m_wb_cti_o <= 3'b000; // Classic cycle\n                m_wb_bte_o <= 2'b00; // Linear burst\n            end\n            \n            if (m_wb_ack_i) begin\n                // Wishbone acknowledges\n                din <= m_wb_dat_i;\n                wr_tx <= 1;\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                delay <= 1;\n            end\n            \n            if (delay) begin\n                // Handle delay for synchronization\n                offset <= offset + 4; // Assuming 32-bit data bus and word-aligned addresses\n                ackd <= !ackd;\n                wr_tx <= 0;\n                delay <= 0;\n            end\n        end else begin\n            // Disabled state handling\n            offset <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_we_o <= 0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // FIFO instance\n    wire [31:0] fifo_data_out;\n    wire fifo_full;\n    wire fifo_empty;\n    wire [5:0] fifo_occupancy;\n\n    sd_tx_fifo tx_fifo (\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(fifo_data_out),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .mem_empt(fifo_occupancy),\n        .rclk(sd_clk),\n        .rst(rst)\n    );\n\n    assign dat_o = fifo_data_out;\n    assign empty = fifo_empty;\n    assign fe = fifo_full;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 1;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            if (en) begin\n                if (!fifo_full && !m_wb_cyc_o && ackd) begin\n                    m_wb_adr_o <= adr + (offset << MEM_OFFSET);\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00; // Linear burst\n                end\n                if (m_wb_ack_i) begin\n                    wr_tx <= 1;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    delay <= 1;\n                end\n                if (delay) begin\n                    offset <= offset + 1;\n                    ackd <= !ackd;\n                    wr_tx <= 0;\n                    delay <= 0;\n                end\n            end else begin\n                reset_tx_fifo <= 1;\n                offset <= 0;\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                m_wb_we_o <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_dat_i,\n    input wire m_wb_ack_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output reg empty,\n    output reg fe,\n    output wire reset_tx_fifo\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Sub-module instantiation\n    wire [31:0] fifo_data_out;\n    wire fifo_full;\n    wire fifo_empty;\n    wire [5:0] fifo_occupancy;\n\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(fifo_data_out),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .mem_empt(fifo_occupancy),\n        .rclk(sd_clk),\n        .rst(rst)\n    );\n\n    // Assign outputs\n    assign reset_tx_fifo = (rst || (en == 0));\n    assign empty = fifo_empty;\n    assign fe = fifo_full;\n    assign dat_o = fifo_data_out;\n\n    // State machine for control logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            if (en) begin\n                if (!fifo_full && !m_wb_cyc_o && ackd) begin\n                    m_wb_adr_o <= adr + (offset << 2);\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00; // Linear burst\n                end\n                if (m_wb_ack_i) begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    delay <= 1;\n                end\n                if (delay) begin\n                    offset <= offset + 1;\n                    ackd <= !ackd;\n                    wr_tx <= 0;\n                    delay <= 0;\n                end\n            end else begin\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                m_wb_we_o <= 0;\n                offset <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Debounce variables\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Synchronization registers\n    reg ack_q, ack_in_int;\n    reg req_q, req_in_int;\n\n    // FSM state registers\n    reg [2:0] state, next_state;\n\n    // Watchdog counter\n    reg [15:0] Watchdog_Cnt;\n\n    // Internal signals\n    wire complete;\n    wire crc_valid = (serial_status[5] == 1'b1);\n    wire dat_ava = (serial_status[6] == 1'b1);\n    wire index_check_enable = CMD_SET_REG[4];\n    wire CRC_check_enable = CMD_SET_REG[3];\n    wire [1:0] response_size;\n\n    // Debounce logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n                card_present <= 1'b0;\n            end\n        end\n    end\n\n    // Request and Acknowledge Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            ack_q <= 1'b0;\n            ack_in_int <= 1'b0;\n            req_q <= 1'b0;\n            req_in_int <= 1'b0;\n        end else begin\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n            req_q <= req_in;\n            req_in_int <= req_q;\n        end\n    end\n\n    // FSM Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // State transition\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Output logic based on current state\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            STATUS_REG <= 16'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            settings <= 16'b0;\n            go_idle_o <= 1'b0;\n            cmd_out <= 40'b0;\n            req_out <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    STATUS_REG <= 16'b0;\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CRC_check_enable;\n                    settings[6:0] <= response_size;\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1; // CTE\n                        NORMAL_INT_REG[15] <= 1'b1; // EI\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1'b1;\n                        if (dat_ava) begin\n                            NORMAL_INT_REG[0] <= 1'b1; // CC\n                            if (CRC_check_enable && !crc_valid) begin\n                                ERR_INT_REG[1] <= 1'b1; // CCRCE\n                                NORMAL_INT_REG[15] <= 1'b1; // EI\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1; // CIE\n                                NORMAL_INT_REG[15] <= 1'b1; // EI\n                            end\n                            if (response_size != 0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire [1:0] mem_empt;\n\n    // Instantiate the sd_rx_fifo submodule\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               READ_FIFO = 1,\n               WB_WRITE = 2,\n               WB_WAIT_ACK = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = en ? READ_FIFO : IDLE;\n            READ_FIFO: next_state = (!empty && wb_free) ? WB_WRITE : READ_FIFO;\n            WB_WRITE: next_state = WB_WAIT_ACK;\n            WB_WAIT_ACK: next_state = m_wb_ack_i ? READ_FIFO : WB_WAIT_ACK;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output and internal control logic\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    wb_free <= 1;\n                    reset_rx_fifo <= 0;\n                    rd <= 0;\n                end\n                READ_FIFO: begin\n                    reset_rx_fifo <= 0;\n                    rd <= 1;\n                    m_wb_dat_o <= dat_o;\n                end\n                WB_WRITE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00;  // Linear burst\n                    wb_free <= 0;\n                end\n                WB_WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 0;\n                        m_wb_stb_o <= 0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for state machine\n    reg [2:0] state, next_state;\n\n    // Registers for debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Synchronization registers\n    reg req_in_q, req_in_int;\n    reg ack_in_q, ack_in_int;\n\n    // Watchdog counter\n    reg [15:0] Watchdog_Cnt;\n\n    // Internal signals\n    wire complete;\n    wire [5:0] CMDI;\n    wire [1:0] WORD_SELECT;\n    wire CICE;\n    wire CRCE;\n    wire [1:0] RTS;\n\n    // Assignments from CMD_SET_REG\n    assign CMDI = CMD_SET_REG[13:8];\n    assign WORD_SELECT = CMD_SET_REG[7:6];\n    assign CICE = CMD_SET_REG[4];\n    assign CRCE = CMD_SET_REG[3];\n    assign RTS = CMD_SET_REG[1:0];\n\n    // Debounce logic for card detect\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n                card_present <= 1'b0;\n            end\n        end\n    end\n\n    // Synchronizers for req_in and ack_in\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_in_q <= 1'b0;\n            req_in_int <= 1'b0;\n            ack_in_q <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_in_q <= req_in;\n            req_in_int <= req_in_q;\n            ack_in_q <= ack_in;\n            ack_in_int <= ack_in_q;\n        end\n    end\n\n    // FSM for handling SD commands\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (New_CMD)\n                    next_state = SETUP;\n                else\n                    next_state = IDLE;\n            end\n            SETUP: begin\n                if (ack_in_int)\n                    next_state = EXECUTE;\n                else\n                    next_state = SETUP;\n            end\n            EXECUTE: begin\n                if (complete)\n                    next_state = IDLE;\n                else\n                    next_state = EXECUTE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            STATUS_REG <= 16'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            settings <= 16'b0;\n            go_idle_o <= 1'b0;\n            cmd_out <= 40'b0;\n            req_out <= 1'b0;\n            ack_out <= 1'b0;\n            Watchdog_Cnt <= 16'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        STATUS_REG <= {11'b0, serial_status};\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    cmd_out <= {2'b01, CMDI, ARG_REG};\n                    settings <= {WORD_SELECT, data_read, data_write, 3'b111, CRCE, 7'b0}; // Example settings\n                    req_out <= 1'b1;\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    STATUS_REG <= 16'b0;\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1; // Command Timeout Error\n                        NORMAL_INT_REG[15] <= 1'b1; // Error Interrupt\n                        go_idle_o <= 1'b1;\n                    end else begin\n                        Watchdog_Cnt <= Watchdog_Cnt + 1;\n                        if (ack_in_int) begin\n                            req_out <= 1'b1;\n                        end\n                        if (req_in_int) begin\n                            STATUS_REG <= {11'b0, serial_status};\n                            ack_out <= 1'b1;\n                            if (serial_status[6]) begin\n                                complete <= 1'b1;\n                                NORMAL_INT_REG[0] <= 1'b1; // Command Complete\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Submodule instantiation\n    sd_tx_fifo tx_fifo(\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 32'b0;\n            m_wb_we_o <= 1'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_cti_o <= 3'b0;\n            m_wb_bte_o <= 2'b0;\n            offset <= 9'b0;\n            wr_tx <= 1'b0;\n            reset_tx_fifo <= 1'b1;\n            first <= 1'b1;\n            ackd <= 1'b0;\n            delay <= 1'b0;\n        end else begin\n            if (en) begin\n                if (!fe && !m_wb_cyc_o && ackd) begin\n                    m_wb_adr_o <= adr + {23'b0, offset};\n                    m_wb_we_o <= 1'b0;\n                    m_wb_cyc_o <= 1'b1;\n                    m_wb_stb_o <= 1'b1;\n                    m_wb_cti_o <= 3'b0;\n                    m_wb_bte_o <= 2'b0;\n                end\n                if (m_wb_ack_i) begin\n                    wr_tx <= 1'b1;\n                    m_wb_cyc_o <= 1'b0;\n                    m_wb_stb_o <= 1'b0;\n                    delay <= 1'b1;\n                end\n                if (delay) begin\n                    offset <= offset + 1'b1;\n                    ackd <= !ackd;\n                    wr_tx <= 1'b0;\n                    delay <= 1'b0;\n                end\n            end else begin\n                reset_tx_fifo <= 1'b1;\n                offset <= 9'b0;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                m_wb_we_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire fifo_full;\n    wire fifo_empty;\n    wire [1:0] mem_empty;\n\n    // Instantiate the FIFO\n    sd_rx_fifo fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .mem_empt(mem_empty),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // Assign external full and empty signals\n    assign full = fifo_full;\n    assign empty = fifo_empty;\n\n    // State machine for controlling the Wishbone interface\n    localparam IDLE = 0, READ_FIFO = 1, WB_WRITE = 2, WB_WAIT_ACK = 3;\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    if (en && !fifo_empty && wb_free) begin\n                        next_state <= READ_FIFO;\n                    end\n                end\n                READ_FIFO: begin\n                    rd <= 1;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00;  // Linear burst\n                    wb_free <= 0;\n                    next_state <= WB_WAIT_ACK;\n                end\n                WB_WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 0;\n                        m_wb_stb_o <= 0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1;\n                        next_state <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Reset and disable handling\n    always @(negedge en or posedge rst) begin\n        if (rst) begin\n            reset_rx_fifo <= 1;\n            rd <= 0;\n            offset <= 0;\n            wb_free <= 1;\n        end else if (!en) begin\n            reset_rx_fifo <= 1;\n            rd <= 0;\n            offset <= 0;\n            wb_free <= 1;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire [1:0] mem_empt;\n\n    // Instantiate the FIFO\n    sd_rx_fifo fifo(\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               READ_FIFO = 1,\n               WB_WRITE = 2,\n               WB_WAIT_ACK = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free)\n                    next_state = READ_FIFO;\n                else\n                    next_state = IDLE;\n            end\n            READ_FIFO: begin\n                next_state = WB_WRITE;\n            end\n            WB_WRITE: begin\n                if (m_wb_ack_i)\n                    next_state = WB_WAIT_ACK;\n                else\n                    next_state = WB_WRITE;\n            end\n            WB_WAIT_ACK: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    wb_free <= 1;\n                    rd <= 0;\n                    reset_rx_fifo <= 0;\n                end\n                READ_FIFO: begin\n                    rd <= 1;\n                    m_wb_dat_o <= dat_o;\n                end\n                WB_WRITE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00; // Linear burst\n                    wb_free <= 0;\n                end\n                WB_WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 0;\n                        m_wb_stb_o <= 0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output reg empty,\n    output reg fe,\n    output wire [31:0] q,\n    output wire full,\n    output wire mem_empt\n);\n\n// Internal registers\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg reset_tx_fifo;\nreg first;\nreg ackd;\nreg delay;\n\n// Submodule instantiation\nsd_tx_fifo tx_fifo (\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(q),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(sd_clk),\n    .rst(rst)\n);\n\n// State machine\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        m_wb_adr_o <= 32'b0;\n        m_wb_we_o <= 1'b0;\n        m_wb_cyc_o <= 1'b0;\n        m_wb_stb_o <= 1'b0;\n        m_wb_cti_o <= 3'b0;\n        m_wb_bte_o <= 2'b0;\n        offset <= 9'b0;\n        we <= 9'b0;\n        din <= 32'b0;\n        wr_tx <= 1'b0;\n        reset_tx_fifo <= 1'b1;\n        first <= 1'b1;\n        ackd <= 1'b0;\n        delay <= 1'b0;\n    end else begin\n        if (en) begin\n            if (!full && !m_wb_cyc_o && ackd) begin\n                m_wb_adr_o <= adr + {23'b0, offset};\n                m_wb_we_o <= 1'b0;\n                m_wb_cyc_o <= 1'b1;\n                m_wb_stb_o <= 1'b1;\n                m_wb_cti_o <= 3'b000; // Classic cycle\n                m_wb_bte_o <= 2'b00; // Linear burst\n            end\n            if (m_wb_ack_i) begin\n                din <= m_wb_dat_i;\n                wr_tx <= 1'b1;\n                m_wb_cyc_o <= 1'b0;\n                m_wb_stb_o <= 1'b0;\n                delay <= 1'b1;\n            end\n            if (delay) begin\n                offset <= offset + 1;\n                ackd <= !ackd;\n                wr_tx <= 1'b0;\n                delay <= 1'b0;\n            end\n        end else begin\n            reset_tx_fifo <= 1'b1;\n            offset <= 9'b0;\n            m_wb_cyc_o <= 1'b0;\n            m_wb_stb_o <= 1'b0;\n            m_wb_we_o <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [31:0] m_wb_dat_i,\n    input wire m_wb_ack_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output reg empty,\n    output reg fe,\n    output reg [5:0] mem_empt\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Submodule instantiation\n    sd_tx_fifo tx_fifo(\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State machine\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 1;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            if (en) begin\n                if (!fe && !m_wb_ack_i && ackd) begin\n                    // Start Wishbone transaction\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 0;\n                    m_wb_bte_o <= 0;\n                end\n                if (m_wb_ack_i) begin\n                    // Acknowledge received, write data to FIFO\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    delay <= 1;\n                end\n                if (delay) begin\n                    // Handle delay and increment address offset\n                    offset <= offset + 4;\n                    ackd <= !ackd;\n                    wr_tx <= 0;\n                    delay <= 0;\n                end\n            end else begin\n                // Disabled state handling\n                reset_tx_fifo <= 1;\n                offset <= 0;\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n                m_wb_we_o <= 0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    reg [31:0] next_adr;\n    \n    // Instantiate the FIFO\n    sd_rx_fifo fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               READ_FIFO = 1,\n               WRITE_WB = 2,\n               WAIT_ACK = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n        end else begin\n            state <= next_state;\n            if (m_wb_ack_i) begin\n                offset <= offset + MEM_OFFSET;\n                wb_free <= 1;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free) begin\n                    next_state = READ_FIFO;\n                end\n            end\n            READ_FIFO: begin\n                next_state = WRITE_WB;\n            end\n            WRITE_WB: begin\n                if (!m_wb_ack_i) begin\n                    next_state = WAIT_ACK;\n                end\n            end\n            WAIT_ACK: begin\n                if (m_wb_ack_i) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        case (state)\n            READ_FIFO: begin\n                rd <= 1;\n                m_wb_dat_o <= dat_o;\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1;\n                m_wb_cyc_o <= 1;\n                m_wb_stb_o <= 1;\n                m_wb_cti_o <= 3'b000; // Classic cycle\n                m_wb_bte_o <= 2'b00;  // Linear burst\n                wb_free <= 0;\n            end\n            WRITE_WB: begin\n                rd <= 0;\n            end\n            WAIT_ACK: begin\n                m_wb_we_o <= 0;\n                m_wb_cyc_o <= 0;\n                m_wb_stb_o <= 0;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 1, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional modules would be instantiated here following a similar pattern\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 5, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    localparam CMD24 = 16'h181A;\n    localparam CMD17 = 16'h111A;\n    localparam CMD12 = 16'hC1A;\n    localparam ACMD13 = 16'hD1A;\n    localparam ACMD51 = 16'h331A;\n    localparam SIZE = 9;\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n    localparam RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, trans_done, trans_failed;\n    reg [2:0] bd_cnt;\n\n    // FSM logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state; // Default to hold current state\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY)\n                    next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY)\n                    next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full)\n                    next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1)\n                    next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done)\n                    next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done)\n                    next_state = DATA_TRANSFER;\n                else if (rec_failed)\n                    next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done)\n                    next_state = IDLE;\n                else if (trans_failed)\n                    next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic based on state\n    always @(state) begin\n        // Reset outputs\n        re_s_tx = 0;\n        a_cmp_tx = 0;\n        re_s_rx = 0;\n        a_cmp_rx = 0;\n        we_req = 0;\n        d_write = 0;\n        d_read = 0;\n        start_tx_fifo = 0;\n        start_rx_fifo = 0;\n        ack_transfer = 0;\n        Dat_Int_Status = 0;\n        CIDAT = 0;\n\n        case (state)\n            GET_TX_BD: begin\n                re_s_tx = 1;\n                if (ack_i_s_tx) begin\n                    sys_adr = dat_in_tx;\n                    cmd_arg = dat_in_tx;\n                    start_tx_fifo = 1;\n                    cmd_set = CMD24;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx = 1;\n                if (ack_i_s_rx) begin\n                    sys_adr = dat_in_rx;\n                    cmd_arg = dat_in_rx;\n                    start_rx_fifo = 1;\n                    cmd_set = CMD17;\n                end\n            end\n            SEND_CMD: begin\n                we_req = 1;\n                if (we_ack) begin\n                    send_done = 1;\n                    d_write = 1; // Assuming write operation for simplicity\n                end\n            end\n            RECIVE_CMD: begin\n                if (!cmd_busy && card_status[0]) begin\n                    rec_done = 1;\n                end else if (cmd_tsf_err) begin\n                    rec_failed = 1;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete && crc_ok) begin\n                    trans_done = 1;\n                    ack_transfer = 1;\n                end else if (!crc_ok) begin\n                    trans_failed = 1;\n                end\n            end\n            STOP_SEND: begin\n                cmd_set = CMD12;\n                we_req = 1;\n                if (we_ack) send_done = 1;\n            end\n        endcase\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 2, "code": "module sdc_controller(\n    input wb_clk_i,\n    input wb_rst_i,\n    input [3:0] wb_sel_i,\n    input [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input [7:0] wb_adr_i,\n    input wb_we_i,\n    input wb_cyc_i,\n    input wb_stb_i,\n    output reg wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output m_wb_sel_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output m_wb_cti_o,\n    output m_wb_bte_o,\n    input card_detect,\n    input sd_cmd_dat_i,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input [3:0] sd_dat_dat_i,\n    output [3:0] sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_clk_o_pad,\n    input sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c\n);\n\n    // Internal signals\n    wire sd_clk;\n    wire [31:0] cmd_arg;\n    wire [15:0] cmd_setting;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [15:0] normal_int_status;\n    wire [15:0] error_int_status;\n    wire [7:0] bd_isr_reg;\n    wire [7:0] bd_isr_enable;\n    wire [15:0] normal_int_signal_enable;\n    wire [15:0] error_int_signal_enable;\n    wire [7:0] software_reset;\n    wire [15:0] timeout_reg;\n    wire [7:0] clock_divider;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] bd_status_reg;\n    wire [7:0] isr_reset;\n    wire [7:0] normal_isr_reset;\n    wire [7:0] error_isr_reset;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [15:0] status_reg_s;\n    wire [31:0] cmd_resp_1_s;\n\n    // Clock and reset logic\n    assign sd_clk = (SD_CLK_SEP) ? sd_clk_i_pad : wb_clk_i;\n\n    // Wishbone slave interface\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            wb_ack_o <= 1'b0;\n            wb_dat_o <= 32'b0;\n        end else if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            wb_ack_o <= 1'b1;  // Acknowledge the transaction\n            if (wb_we_i) begin\n                // Handle write operations\n            end else begin\n                // Handle read operations\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\n\n    // Master Wishbone interface logic\n    assign m_wb_adr_o = 32'b0;  // Example address\n    assign m_wb_sel_o = 1'b1;\n    assign m_wb_we_o = 1'b0;\n    assign m_wb_dat_o = 32'b0;\n    assign m_wb_cyc_o = 1'b0;\n    assign m_wb_stb_o = 1'b0;\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n\n    // SD/MMC command and data interface logic\n    assign sd_cmd_out_o = 1'b0;\n    assign sd_cmd_oe_o = 1'b0;\n    assign sd_dat_out_o = 4'b0000;\n    assign sd_dat_oe_o = 1'b0;\n    assign sd_clk_o_pad = sd_clk;\n\n    // Interrupt logic\n    assign int_a = (normal_int_status & normal_int_signal_enable) != 16'b0;\n    assign int_b = (error_int_status & error_int_signal_enable) != 16'b0;\n    assign int_c = (bd_isr_reg & bd_isr_enable) != 8'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 3, "code": "module sdc_controller (\n    input wb_clk_i,\n    input wb_rst_i,\n    input [3:0] wb_sel_i,\n    input [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input [7:0] wb_adr_i,\n    input wb_we_i,\n    input wb_cyc_i,\n    input wb_stb_i,\n    output reg wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output m_wb_sel_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input [30:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output m_wb_cti_o,\n    output m_wb_bte_o,\n    input card_detect,\n    input sd_cmd_dat_i,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input [3:0] sd_dat_dat_i,\n    output [3:0] sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_clk_o_pad,\n    input sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c\n);\n\n// Internal signals\nreg [31:0] internal_reg;\nwire [31:0] data_from_sd_controller_wb;\nwire [31:0] data_to_sd_controller_wb;\nwire [31:0] data_from_sd_cmd_master;\nwire [31:0] data_to_sd_cmd_master;\nwire [31:0] data_from_sd_data_master;\nwire [31:0] data_to_sd_data_master;\nwire [31:0] data_from_sd_cmd_serial_host;\nwire [31:0] data_to_sd_cmd_serial_host;\nwire [31:0] data_from_sd_data_serial_host;\nwire [31:0] data_to_sd_data_serial_host;\nwire [31:0] data_from_rx_bd;\nwire [31:0] data_to_rx_bd;\nwire [31:0] data_from_tx_bd;\nwire [31:0] data_to_tx_bd;\nwire [31:0] data_from_sd_fifo_tx_filler;\nwire [31:0] data_to_sd_fifo_tx_filler;\nwire [31:0] data_from_sd_fifo_rx_filler;\nwire [31:0] data_to_sd_fifo_rx_filler;\n\n// Instantiate sub-modules\nsd_controller_wb sd_controller_wb_inst (\n    .wb_clk_i(wb_clk_i),\n    .wb_rst_i(wb_rst_i),\n    .wb_dat_i(wb_dat_i),\n    .wb_dat_o(data_to_sd_controller_wb),\n    .wb_adr_i(wb_adr_i),\n    .wb_sel_i(wb_sel_i),\n    .wb_we_i(wb_we_i),\n    .wb_cyc_i(wb_cyc_i),\n    .wb_stb_i(wb_stb_i),\n    .wb_ack_o(wb_ack_o)\n);\n\nsd_cmd_master sd_cmd_master_inst (\n    .CLK_PAD_IO(wb_clk_i),\n    .RST_PAD_I(wb_rst_i),\n    .New_CMD(new_cmd),\n    .data_write(data_write),\n    .data_read(data_read),\n    .ARG_REG(cmd_arg_s),\n    .CMD_SET_REG(cmd_set_s),\n    .TIMEOUT_REG(time_out_reg),\n    .STATUS_REG(status_reg),\n    .RESP_1_REG(cmd_resp_1),\n    .ERR_INT_REG(err_int_reg),\n    .NORMAL_INT_REG(normal_int_reg),\n    .ERR_INT_RST(err_isr_reset),\n    .NORMAL_INT_RST(normal_isr_reset),\n    .settings(settings),\n    .go_idle_o(go_idle_o),\n    .cmd_out(cmd_out),\n    .req_out(req_out),\n    .ack_out(ack_out),\n    .req_in(req_in),\n    .ack_in(ack_in),\n    .cmd_in(cmd_in),\n    .serial_status(serial_status),\n    .card_detect(card_detect)\n);\n\n// Additional sub-modules would be instantiated similarly\n\n// Logic to handle Wishbone read/write operations\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_dat_o <= 32'b0;\n        wb_ack_o <= 1'b0;\n    end else begin\n        if (wb_cyc_i && wb_stb_i) begin\n            if (wb_we_i) begin\n                // Handle write operation\n                internal_reg <= wb_dat_i;\n            end else begin\n                // Handle read operation\n                wb_dat_o <= internal_reg;\n            end\n            wb_ack_o <= 1'b1;\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // State Definitions\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_IN, CRC_OUT, CRC_Enable, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in, q1, Ack_internal_in;\n\n    // REQ_SYNC and ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = Write_Read ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN) begin\n        case (state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Cmd_Cnt <= 0;\n                Delay_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n            end\n            WRITE_WR: begin\n                cmd_oe_o <= 1;\n                CMD_OUT <= In_Buff;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            WRITE_WO: begin\n                cmd_oe_o <= 1;\n                CMD_OUT <= In_Buff;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_WR: begin\n                Delay_Cnt <= Delay_Cnt + 1;\n                cmd_oe_o <= 0;\n            end\n            DLY_WO: begin\n                Delay_Cnt <= Delay_Cnt + 1;\n                cmd_oe_o <= 0;\n            end\n            READ_WR: begin\n                cmd_oe_o <= 0;\n                Out_Buff <= {Out_Buff[38:0], cmd_dat_i};\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                Delay_Cnt <= Delay_Cnt + 1;\n                cmd_oe_o <= 0;\n            end\n            ACK_WO: begin\n                ACK_OUT <= 1;\n            end\n            ACK_WR: begin\n                ACK_OUT <= 1;\n            end\n        endcase\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 4, "code": "module sdc_controller (\n    input wb_clk_i,\n    input wb_rst_i,\n    input [3:0] wb_sel_i,\n    input [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input [7:0] wb_adr_i,\n    input wb_we_i,\n    input wb_cyc_i,\n    input wb_stb_i,\n    output reg wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output m_wb_sel_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input [30:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output m_wb_cti_o,\n    output m_wb_bte_o,\n    input card_detect,\n    input sd_cmd_dat_i,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input [3:0] sd_dat_dat_i,\n    output [3:0] sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_clk_o_pad,\n    input sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c\n);\n\n    // Internal signals\n    wire sd_clk;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n\n    // Instantiate sub-modules\n    sd_controller_wb controller_wb (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional logic for master interface, interrupts, and other sub-modules would be added here.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out [0:SD_BUS_W-1];\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int, ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Submodule Instances\n    // CRC Generation Block\n    sd_crc_16 crc_gen (\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // State Definitions\n    localparam IDLE         = 6'b000001;\n    localparam WRITE_DAT    = 6'b000010;\n    localparam WRITE_CRC    = 6'b000100;\n    localparam WRITE_BUSY   = 6'b001000;\n    localparam READ_WAIT    = 6'b010000;\n    localparam READ_DAT     = 6'b100000;\n\n    // FSM_COMBO Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM_SEQ Logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM_OUT Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset conditions\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            // Normal operation\n            case (state)\n                WRITE_DAT: begin\n                    // Data transmission logic\n                end\n                WRITE_CRC: begin\n                    // CRC check logic\n                end\n                WRITE_BUSY: begin\n                    // Busy waiting logic\n                end\n                READ_WAIT: begin\n                    // Wait for start bit\n                end\n                READ_DAT: begin\n                    // Data reception logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire mem_empty;\n\n    // Instantiate the sd_rx_fifo submodule\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empty),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               READ_FIFO = 1,\n               WB_WRITE = 2,\n               WB_WAIT_ACK = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free)\n                    next_state = READ_FIFO;\n                else\n                    next_state = IDLE;\n            end\n            READ_FIFO: begin\n                next_state = WB_WRITE;\n            end\n            WB_WRITE: begin\n                if (m_wb_ack_i)\n                    next_state = WB_WAIT_ACK;\n                else\n                    next_state = WB_WRITE;\n            end\n            WB_WAIT_ACK: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic based on state\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    wb_free <= 1;\n                    rd <= 0;\n                    reset_rx_fifo <= 0;\n                end\n                READ_FIFO: begin\n                    rd <= 1;\n                    m_wb_dat_o <= dat_o;\n                end\n                WB_WRITE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000;\n                    m_wb_bte_o <= 2'b00;\n                    wb_free <= 0;\n                end\n                WB_WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 0;\n                        m_wb_stb_o <= 0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [SD_BUS_W*16-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int, ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // State Definitions\n    localparam IDLE = 6'b000001;\n    localparam WRITE_DAT = 6'b000010;\n    localparam WRITE_CRC = 6'b000100;\n    localparam WRITE_BUSY = 6'b001000;\n    localparam READ_WAIT = 6'b010000;\n    localparam READ_DAT = 6'b100000;\n\n    // CRC Generation Block\n    sd_crc_16 crc_gen (\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out[15:0])\n    );\n\n    // ACK Synchronization\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO Logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (start_dat == 2'b01) ? READ_WAIT : (start_dat == 2'b10) ? WRITE_DAT : IDLE;\n            WRITE_DAT: next_state = (transf_cnt == SD_BUS_W) ? WRITE_CRC : WRITE_DAT;\n            WRITE_CRC: next_state = (crc_status == 3'b111) ? WRITE_BUSY : WRITE_CRC;\n            WRITE_BUSY: next_state = (busy_int == 0) ? IDLE : WRITE_BUSY;\n            READ_WAIT: next_state = (DAT_dat_i[0] == 0) ? READ_DAT : READ_WAIT;\n            READ_DAT: next_state = (transf_cnt == SD_BUS_W) ? IDLE : READ_DAT;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM_SEQ Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset all outputs and internal registers\n            {write_buf_0, write_buf_1, DAT_oe_o, crc_en, crc_rst, transf_cnt, rd, last_din, crc_c, crc_in, DAT_dat_o, crc_status, crc_s, transm_complete, busy_n, we, data_out, crc_ok, busy_int, data_send_index, out_buff_ptr, in_buff_ptr} <= 0;\n        end else begin\n            // Handle state-specific operations\n            case (state)\n                WRITE_DAT: begin\n                    // Data transmission logic\n                end\n                WRITE_CRC: begin\n                    // CRC check logic\n                end\n                WRITE_BUSY: begin\n                    // Busy wait logic\n                end\n                READ_WAIT: begin\n                    // Prepare for reading data\n                end\n                READ_DAT: begin\n                    // Data reception logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // State definitions\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_IN, CRC_OUT, CRC_Enable, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in, q1, Ack_internal_in;\n\n    // REQ_SYNC and ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            Write_Read <= SETTING_IN[6:0] > 0;\n            Write_Only <= SETTING_IN[6:0] == 0;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = Write_Read ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN) begin\n        case (state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                CMD_OUT <= 0;\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n            end\n            WRITE_WR: begin\n                cmd_oe_o <= 1;\n                CMD_OUT <= In_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n            end\n            WRITE_WO: begin\n                cmd_oe_o <= 1;\n                CMD_OUT <= In_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n            end\n            DLY_WR: begin\n                cmd_oe_o <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n            end\n            DLY_WO: begin\n                cmd_oe_o <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n            end\n            READ_WR: begin\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n            end\n            DLY_READ: begin\n                cmd_oe_o <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n            end\n            ACK_WO: begin\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n            end\n            ACK_WR: begin\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register address decoding\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1;\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else begin\n            if (wb_cyc_i && wb_stb_i) begin\n                wb_ack_o <= 1'b1; // Acknowledge the wishbone transaction\n                if (wb_we_i) begin\n                    // Write operation\n                    case (wb_adr_i)\n                        8'h00: argument_reg <= wb_dat_i;\n                        8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                        8'h28: software_reset_reg <= wb_dat_i[7:0];\n                        8'h2c: time_out_reg <= wb_dat_i[15:0];\n                        8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                        8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                        8'h4c: clock_divider <= wb_dat_i[7:0];\n                        8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                        8'h60: begin\n                            dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                            we_m_rx_bd <= 1'b1;\n                        end\n                        8'h80: begin\n                            dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                            we_m_tx_bd <= 1'b1;\n                        end\n                        default: ;\n                    endcase\n                end else begin\n                    // Read operation\n                    case (wb_adr_i)\n                        8'h00: wb_dat_o <= argument_reg;\n                        8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                        8'h08: wb_dat_o <= {16'b0, status_reg};\n                        8'h0c: wb_dat_o <= cmd_resp_1;\n                        8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                        8'h2c: wb_dat_o <= {16'b0, time_out_reg};\n                        8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                        8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                        8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                        8'h3c: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                        8'h4c: wb_dat_o <= {24'b0, clock_divider};\n                        8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                        8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                        8'h58: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                        default: wb_dat_o <= 32'b0;\n                    endcase\n                end\n            end else begin\n                wb_ack_o <= 1'b0;\n                we_m_tx_bd <= 1'b0;\n                we_m_rx_bd <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output reg full,\n    output reg empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire fifo_full;\n    wire fifo_empty;\n    wire [1:0] mem_empt;\n\n    // Instantiate the FIFO\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .mem_empt(mem_empt),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               READ_FIFO = 1,\n               WAIT_ACK = 2;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fifo_empty && wb_free)\n                    next_state = READ_FIFO;\n                else\n                    next_state = IDLE;\n            end\n            READ_FIFO: begin\n                if (!fifo_empty && wb_free)\n                    next_state = WAIT_ACK;\n                else\n                    next_state = IDLE;\n            end\n            WAIT_ACK: begin\n                if (m_wb_ack_i)\n                    next_state = IDLE;\n                else\n                    next_state = WAIT_ACK;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output and internal register logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n            full <= 0;\n            empty <= 1;\n        end else begin\n            case (next_state)\n                IDLE: begin\n                    reset_rx_fifo <= 0;\n                    rd <= 0;\n                    wb_free <= 1;\n                end\n                READ_FIFO: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_dat_o <= dat_o;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 0;\n                    m_wb_bte_o <= 0;\n                    rd <= 1;\n                    wb_free <= 0;\n                end\n                WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 0;\n                        m_wb_stb_o <= 0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1;\n                    end\n                end\n            endcase\n            full <= fifo_full;\n            empty <= fifo_empty;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers and Wires\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [15:0] crc_out[SD_BUS_W-1:0];\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int, ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Submodule Instances\n    // CRC Generation Block\n    genvar i;\n    generate\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen_blocks\n            sd_crc_16 crc_block(\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[i])\n            );\n        end\n    endgenerate\n\n    // FSM_COMBO Logic\n    always @(*) begin\n        case (state)\n            `IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = `READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = `WRITE_DAT;\n                else\n                    next_state = `IDLE;\n            end\n            `WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = `WRITE_CRC;\n                else\n                    next_state = `WRITE_DAT;\n            end\n            `WRITE_CRC: begin\n                if (crc_status == `OK)\n                    next_state = `WRITE_BUSY;\n                else\n                    next_state = `WRITE_CRC;\n            end\n            `WRITE_BUSY: begin\n                if (busy_int == 0)\n                    next_state = `IDLE;\n                else\n                    next_state = `WRITE_BUSY;\n            end\n            `READ_WAIT: begin\n                if (DAT_dat_i[0] == 0)\n                    next_state = `READ_DAT;\n                else\n                    next_state = `READ_WAIT;\n            end\n            `READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = `IDLE;\n                else\n                    next_state = `READ_DAT;\n            end\n            default: next_state = `IDLE;\n        endcase\n    end\n\n    // FSM_SEQ Logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst)\n            state <= `IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM_OUT Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset logic\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            we <= 0;\n            DAT_oe_o <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            crc_ok <= 0;\n            data_out <= 0;\n        end else begin\n            // Normal operation\n            case (state)\n                `WRITE_DAT: begin\n                    // Data transmission logic\n                end\n                `WRITE_CRC: begin\n                    // CRC check logic\n                end\n                `WRITE_BUSY: begin\n                    // Busy wait logic\n                end\n                `READ_WAIT: begin\n                    // Read wait logic\n                end\n                `READ_DAT: begin\n                    // Data reception logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 5, "code": "module sdc_controller (\n    input wb_clk_i,\n    input wb_rst_i,\n    input [3:0] wb_sel_i,\n    input [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input [7:0] wb_adr_i,\n    input wb_we_i,\n    input wb_cyc_i,\n    input wb_stb_i,\n    output reg wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output m_wb_sel_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output m_wb_cti_o,\n    output m_wb_bte_o,\n    input card_detect,\n    input sd_cmd_dat_i,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input [3:0] sd_dat_dat_i,\n    output [3:0] sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_clk_o_pad,\n    input sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional logic and connections as needed for other sub-modules\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire rd,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output reg empty,\n    output reg fe,\n    output reg [5:0] mem_empt\n);\n\n// Internal Registers\nreg [8:0] offset;\nreg [8:0] we;\nreg [31:0] din;\nreg wr_tx;\nreg reset_tx_fifo;\nreg first;\nreg ackd;\nreg delay;\n\n// Sub-module instantiation\nsd_tx_fifo tx_fifo (\n    .d(din),\n    .wr(wr_tx),\n    .wclk(clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(fe),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(sd_clk),\n    .rst(reset_tx_fifo)\n);\n\n// State Machine\nlocalparam IDLE = 0,\n           WAIT_ACK = 1,\n           WRITE_FIFO = 2,\n           DELAY = 3;\n\nreg [1:0] state, next_state;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        reset_tx_fifo <= 1;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_we_o <= 0;\n        offset <= 0;\n        ackd <= 0;\n        delay <= 0;\n    end else begin\n        state <= next_state;\n        if (en == 0) begin\n            reset_tx_fifo <= 1;\n            offset <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_we_o <= 0;\n        end else begin\n            reset_tx_fifo <= 0;\n        end\n    end\nend\n\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (en && !fe && !m_wb_cyc_o && ackd) begin\n                next_state = WAIT_ACK;\n            end\n        end\n        WAIT_ACK: begin\n            if (m_wb_ack_i) begin\n                next_state = WRITE_FIFO;\n            end\n        end\n        WRITE_FIFO: begin\n            next_state = DELAY;\n        end\n        DELAY: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    case (state)\n        IDLE: begin\n            wr_tx <= 0;\n            m_wb_adr_o <= adr + (offset << MEM_OFFSET);\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n            m_wb_we_o <= 0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n        end\n        WAIT_ACK: begin\n            m_wb_cyc_o <= 1;\n            m_wb_stb_o <= 1;\n        end\n        WRITE_FIFO: begin\n            din <= m_wb_dat_i;\n            wr_tx <= 1;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            ackd <= 0;\n        end\n        DELAY: begin\n            offset <= offset + 1;\n            ackd <= 1;\n            wr_tx <= 0;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire [1:0] mem_empt;\n\n    // Submodule: SD RX FIFO\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0, READ_FIFO = 1, WB_WRITE = 2, WB_WAIT_ACK = 3;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free)\n                    next_state = READ_FIFO;\n                else\n                    next_state = IDLE;\n            end\n            READ_FIFO: begin\n                next_state = WB_WRITE;\n            end\n            WB_WRITE: begin\n                if (m_wb_ack_i)\n                    next_state = WB_WAIT_ACK;\n                else\n                    next_state = WB_WRITE;\n            end\n            WB_WAIT_ACK: begin\n                if (wb_free)\n                    next_state = IDLE;\n                else\n                    next_state = WB_WAIT_ACK;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic and control signals\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    reset_rx_fifo <= 0;\n                    rd <= 0;\n                    wb_free <= 1;\n                end\n                READ_FIFO: begin\n                    rd <= 1;\n                    m_wb_dat_o <= dat_o;\n                end\n                WB_WRITE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00;  // Linear burst\n                    wb_free <= 0;\n                end\n                WB_WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 0;\n                        m_wb_stb_o <= 0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable, CRC_OUT, CRC_Check_On, Crc_Buffering, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in, q1, Ack_internal_in;\n\n    // Synchronizers\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            CRC_Check_On <= 0;\n            Delay_Cycler <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n            In_Buff <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_COMBO\n    always @* begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: begin\n                if (Write_Read) next_state = WRITE_WR;\n                else if (Write_Only) next_state = WRITE_WO;\n                else next_state = IDLE;\n            end\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN) begin\n        case (state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                CMD_OUT <= 40'hFFFFFFFFFF;\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS <= 8'h00;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= 40'h0000000000;\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS <= 8'h01;\n                Cmd_Cnt <= 0;\n                Delay_Cnt <= 0;\n            end\n            WRITE_WR: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                CMD_OUT <= In_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n                STATUS <= 8'h02;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            WRITE_WO: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                CMD_OUT <= In_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n                STATUS <= 8'h03;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_WR: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= 40'h0000000000;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS <= 8'h04;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            DLY_WO: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= 40'h0000000000;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS <= 8'h05;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            READ_WR: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= Out_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n                STATUS <= 8'h06;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= Out_Buff;\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS <= 8'h07;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            ACK_WO: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= 40'h0000000000;\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS <= 8'h08;\n            end\n            ACK_WR: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 0;\n                CMD_OUT <= 40'h0000000000;\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS <= 8'h09;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [15:0] crc_out[SD_BUS_W-1:0];\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int, ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // State definitions\n    localparam IDLE = 6'b000001;\n    localparam WRITE_DAT = 6'b000010;\n    localparam WRITE_CRC = 6'b000100;\n    localparam WRITE_BUSY = 6'b001000;\n    localparam READ_WAIT = 6'b010000;\n    localparam READ_DAT = 6'b100000;\n\n    // CRC Generation Block\n    generate\n        genvar i;\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_block (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[i])\n            );\n        end\n    endgenerate\n\n    // ACK_SYNC block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO block\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM_SEQ block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM_OUT block\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset conditions\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            // Normal operation\n            case (state)\n                WRITE_DAT: begin\n                    // Write data handling\n                end\n                WRITE_CRC: begin\n                    // CRC handling\n                end\n                WRITE_BUSY: begin\n                    // Busy handling\n                end\n                READ_WAIT: begin\n                    // Read wait handling\n                end\n                READ_DAT: begin\n                    // Read data handling\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal parameters\n    parameter INIT_DELAY = `SIM ? 2 : 64;\n    parameter NCR = 2;\n    parameter SEND_SIZE = 48;\n    parameter SIZE = 10;\n    parameter CONTENT_SIZE = 40;\n    parameter Read_Delay = 7;\n    parameter EIGHT_PAD = 8;\n\n    // State definitions\n    localparam [SIZE-1:0]\n        INIT = 10'b0000000001,\n        IDLE = 10'b0000000010,\n        WRITE_WR = 10'b0000000100,\n        DLY_WR = 10'b0000001000,\n        READ_WR = 10'b0000010000,\n        DLY_READ = 10'b0000100000,\n        ACK_WR = 10'b0001000000,\n        WRITE_WO = 10'b0010000000,\n        DLY_WO = 10'b0100000000,\n        ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_Enable, CRC_OUT, CRC_Check_On, Crc_Buffering, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in, q1, Ack_internal_in;\n\n    // REQ_SYNC and ACK_SYNC logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // FSM_COMBO logic\n    always @* begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = Write_Read ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WR: next_state = IDLE;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            ACK_WO: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n            Cmd_Cnt <= 0;\n            Delay_Cnt <= 0;\n        end else begin\n            state <= next_state;\n            Cmd_Cnt <= (state == WRITE_WR || state == WRITE_WO || state == READ_WR) ? Cmd_Cnt + 1 : 0;\n            Delay_Cnt <= (state == DLY_WR || state == DLY_WO || state == DLY_READ) ? Delay_Cnt + 1 : 0;\n        end\n    end\n\n    // COMMAND_DECODER logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            In_Buff <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n            DECODER_ACK <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            Write_Read <= SETTING_IN[6:0] > 0;\n            Write_Only <= SETTING_IN[6:0] == 0;\n            DECODER_ACK <= 1;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 0;\n        end\n    end\n\n    // FSM_OUT logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 1;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 0;\n            cmd_out_o <= 1;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                WRITE_WR, WRITE_WO: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                    CMD_OUT <= In_Buff;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 1;\n                end\n                DLY_WR, DLY_WO: begin\n                    cmd_oe_o <= 0;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                end\n                READ_WR: begin\n                    cmd_oe_o <= 0;\n                    Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                    CMD_OUT <= Out_Buff;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 1;\n                end\n                DLY_READ: begin\n                    cmd_oe_o <= 0;\n                    ACK_OUT <= 1;\n                    REQ_OUT <= 0;\n                end\n                ACK_WR, ACK_WO: begin\n                    ACK_OUT <= 1;\n                    REQ_OUT <= 0;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                    ACK_OUT <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 6, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire sd_clk;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire [31:0] cmd_resp_1;\n    wire [15:0] status_reg;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n    wire new_cmd;\n    wire we_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n\n    // Assignments for outputs\n    assign sd_clk_o_pad = sd_clk;\n    assign m_wb_sel_o = 1'b1; // Assuming single byte access for simplicity\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional sub-modules would be instantiated here following a similar pattern\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [8:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register addresses\n    localparam ADDR_ARGUMENT           = 8'h00;\n    localparam ADDR_CMD_SETTING        = 8'h04;\n    localparam ADDR_CARD_STATUS        = 8'h08;\n    localparam ADDR_RESPONSE           = 8'h0C;\n    localparam ADDR_SOFTWARE_RESET     = 8'h28;\n    localparam ADDR_TIMEOUT            = 8'h2C;\n    localparam ADDR_NORMAL_INT_STATUS  = 8'h30;\n    localparam ADDR_ERROR_INT_STATUS   = 8'h34;\n    localparam ADDR_NORMAL_INT_ENABLE  = 8'h38;\n    localparam ADDR_ERROR_INT_ENABLE   = 8'h3C;\n    localparam ADDR_CLOCK_DIVIDER      = 8'h4C;\n    localparam ADDR_BD_STATUS          = 8'h50;\n    localparam ADDR_DAT_INT_STATUS     = 8'h54;\n    localparam ADDR_DAT_INT_ENABLE     = 8'h58;\n    localparam ADDR_BD_RX              = 8'h60;\n    localparam ADDR_BD_TX              = 8'h80;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers and outputs\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1; // Default to high\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 9'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the Wishbone transaction\n            if (wb_we_i) begin\n                // Handle writes to the registers\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: argument_reg <= wb_dat_i;\n                    ADDR_CMD_SETTING: cmd_setting_reg <= wb_dat_i[15:0];\n                    ADDR_SOFTWARE_RESET: software_reset_reg <= wb_dat_i[8:0];\n                    ADDR_TIMEOUT: time_out_reg <= wb_dat_i[15:0];\n                    ADDR_NORMAL_INT_ENABLE: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_ERROR_INT_ENABLE: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_CLOCK_DIVIDER: clock_divider <= wb_dat_i[7:0];\n                    ADDR_DAT_INT_ENABLE: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    ADDR_BD_RX: begin\n                        dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        we_m_rx_bd <= 1'b1;\n                    end\n                    ADDR_BD_TX: begin\n                        dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        we_m_tx_bd <= 1'b1;\n                    end\n                    default: ;\n                endcase\n            end else begin\n                // Handle reads from the registers\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: wb_dat_o <= argument_reg;\n                    ADDR_CMD_SETTING: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    ADDR_CARD_STATUS: wb_dat_o <= {16'b0, status_reg};\n                    ADDR_RESPONSE: wb_dat_o <= cmd_resp_1;\n                    ADDR_SOFTWARE_RESET: wb_dat_o <= {24'b0, software_reset_reg};\n                    ADDR_TIMEOUT: wb_dat_o <= {16'b0, time_out_reg};\n                    ADDR_NORMAL_INT_STATUS: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    ADDR_ERROR_INT_STATUS: wb_dat_o <= {16'b0, error_int_status_reg};\n                    ADDR_NORMAL_INT_ENABLE: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    ADDR_ERROR_INT_ENABLE: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    ADDR_CLOCK_DIVIDER: wb_dat_o <= {24'b0, clock_divider};\n                    ADDR_BD_STATUS: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    ADDR_DAT_INT_STATUS: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    ADDR_DAT_INT_ENABLE: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host(\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // State Definitions\n    localparam IDLE = 6'd0,\n               WRITE_DAT = 6'd1,\n               WRITE_CRC = 6'd2,\n               WRITE_BUSY = 6'd3,\n               READ_WAIT = 6'd4,\n               READ_DAT = 6'd5;\n\n    // CRC-16 Generation Block\n    wire [15:0] crc_out;\n    sd_crc_16 crc_gen (\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // ACK Synchronization\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM Combinational Logic\n    always @(*) begin\n        next_state = state; // Default to hold state\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b001)\n                    next_state = WRITE_BUSY;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // FSM Sequential Logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM Output Logic\n    always @(posedge sd_clk) begin\n        case (state)\n            IDLE: begin\n                crc_rst <= 1;\n                transf_cnt <= 0;\n                busy_n <= 1;\n                transm_complete <= 0;\n                crc_ok <= 0;\n            end\n            WRITE_DAT: begin\n                crc_rst <= 0;\n                crc_en <= 1;\n                DAT_oe_o <= 1;\n                DAT_dat_o <= data_in[31:0];\n                transf_cnt <= transf_cnt + 1;\n            end\n            WRITE_CRC: begin\n                DAT_dat_o <= crc_out;\n            end\n            WRITE_BUSY: begin\n                busy_n <= DAT_dat_i[0];\n                transm_complete <= 1;\n                crc_ok <= (crc_s == 3'b110);\n            end\n            READ_WAIT: begin\n                DAT_oe_o <= 0;\n            end\n            READ_DAT: begin\n                data_out <= DAT_dat_i;\n                crc_in <= DAT_dat_i;\n                transf_cnt <= transf_cnt + 1;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out [0:SD_BUS_W-1];\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int, ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // State Definitions\n    localparam IDLE        = 6'b000001;\n    localparam WRITE_DAT   = 6'b000010;\n    localparam WRITE_CRC   = 6'b000100;\n    localparam WRITE_BUSY  = 6'b001000;\n    localparam READ_WAIT   = 6'b010000;\n    localparam READ_DAT    = 6'b100000;\n\n    // ACK_SYNC Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO Block\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (start_dat == 2'b01) ? READ_WAIT :\n                               (start_dat == 2'b10) ? WRITE_DAT : IDLE;\n            WRITE_DAT: next_state = (transf_cnt == SD_BUS_W) ? WRITE_CRC : WRITE_DAT;\n            WRITE_CRC: next_state = (crc_status == 3'b111) ? WRITE_BUSY : WRITE_CRC;\n            WRITE_BUSY: next_state = (busy_int == 0) ? IDLE : WRITE_BUSY;\n            READ_WAIT: next_state = (q_start_bit == 0) ? READ_DAT : READ_WAIT;\n            READ_DAT: next_state = (transf_cnt == SD_BUS_W) ? IDLE : READ_DAT;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM_SEQ Block\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT Block\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset all outputs and internal registers\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            // Handle each state\n            case (state)\n                WRITE_DAT: begin\n                    // Implement WRITE_DAT logic\n                end\n                WRITE_CRC: begin\n                    // Implement WRITE_CRC logic\n                end\n                WRITE_BUSY: begin\n                    // Implement WRITE_BUSY logic\n                end\n                READ_WAIT: begin\n                    // Implement READ_WAIT logic\n                end\n                READ_DAT: begin\n                    // Implement READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [8:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register address decoding\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers and outputs\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1; // Default to high\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the wishbone transaction\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    default: ;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'b0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'b0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    8'h4c: wb_dat_o <= {24'b0, clock_divider};\n                    8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0; // De-assert the acknowledge signal\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State Definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for FSM\n    reg [2:0] state, next_state;\n\n    // Registers for debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Registers for synchronizers\n    reg req_q, req_in_int;\n    reg ack_q, ack_in_int;\n\n    // Registers for internal operations\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n\n    // FSM State Transition Logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = New_CMD ? SETUP : IDLE;\n            SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = complete ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM State Register\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 0;\n            card_present <= 0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1111)\n                    card_present <= 1;\n            end else begin\n                debounce <= 0;\n                card_present <= 0;\n            end\n        end\n    end\n\n    // Synchronizers\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 0;\n            req_in_int <= 0;\n            ack_q <= 0;\n            ack_in_int <= 0;\n        end else begin\n            req_q <= req_in;\n            req_in_int <= req_q;\n            ack_q <= ack_in;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // FSM Output Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            go_idle_o <= 0;\n            req_out <= 0;\n            ack_out <= 0;\n            STATUS_REG <= 0;\n            RESP_1_REG <= 0;\n            ERR_INT_REG <= 0;\n            NORMAL_INT_REG <= 0;\n            settings <= 0;\n            cmd_out <= 0;\n            Watchdog_Cnt <= 0;\n            complete <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 0;\n                    req_out <= 0;\n                    ack_out <= 0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 0;\n                    ERR_INT_REG <= 0;\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CMD_SET_REG[3];\n                    settings[6:0] <= (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) ? 7'b0101000 : \n                                     (CMD_SET_REG[1:0] == 2'b01) ? 7'b1111111 : 7'b0000000;\n                    Watchdog_Cnt <= 0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1; // CTE\n                        NORMAL_INT_REG[15] <= 1; // EI\n                        go_idle_o <= 1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1;\n                        complete <= 1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1;\n                        if (serial_status[6]) begin\n                            complete <= 1;\n                            NORMAL_INT_REG[0] <= 1; // CC\n                            if (CMD_SET_REG[4] && !serial_status[5]) begin\n                                ERR_INT_REG[1] <= 1; // CCRCE\n                                NORMAL_INT_REG[15] <= 1; // EI\n                            end\n                            if (CMD_SET_REG[3] && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1; // CIE\n                                NORMAL_INT_REG[15] <= 1; // EI\n                            end\n                            RESP_1_REG <= cmd_in[31:0];\n                        end\n                    end\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    input wire [31:0] adr,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [8:0] offset,\n    output reg wb_free,\n    output reg reset_rx_fifo,\n    output reg rd\n);\n\n    // Submodule: sd_rx_fifo\n    wire [31:0] dat_o;\n    wire [1:0] mem_empty;\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empty),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               READ_FIFO = 1,\n               WB_WRITE = 2,\n               WB_WAIT_ACK = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en) begin\n                    next_state = READ_FIFO;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            READ_FIFO: begin\n                if (!empty && wb_free) begin\n                    next_state = WB_WRITE;\n                end else begin\n                    next_state = READ_FIFO;\n                end\n            end\n            WB_WRITE: begin\n                next_state = WB_WAIT_ACK;\n            end\n            WB_WAIT_ACK: begin\n                if (m_wb_ack_i) begin\n                    next_state = READ_FIFO;\n                end else begin\n                    next_state = WB_WAIT_ACK;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        end\n    end\n\n    // Output logic and control signal updates\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    wb_free <= 1;\n                    reset_rx_fifo <= 1;\n                    rd <= 0;\n                end\n                READ_FIFO: begin\n                    reset_rx_fifo <= 0;\n                    rd <= 1;\n                    m_wb_dat_o <= dat_o;\n                end\n                WB_WRITE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00;  // Linear burst\n                    wb_free <= 0;\n                end\n                WB_WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 0;\n                        m_wb_stb_o <= 0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire mem_empty;\n    wire mem_full;\n\n    // Instantiate the sd_rx_fifo submodule\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empty),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               READ_FIFO = 1,\n               WB_WRITE = 2,\n               WB_WAIT_ACK = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free)\n                    next_state = READ_FIFO;\n                else\n                    next_state = IDLE;\n            end\n            READ_FIFO: begin\n                next_state = WB_WRITE;\n            end\n            WB_WRITE: begin\n                if (m_wb_ack_i)\n                    next_state = WB_WAIT_ACK;\n                else\n                    next_state = WB_WRITE;\n            end\n            WB_WAIT_ACK: begin\n                if (wb_free)\n                    next_state = IDLE;\n                else\n                    next_state = WB_WAIT_ACK;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        end\n    end\n\n    // Output logic and control signal updates\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    reset_rx_fifo <= 0;\n                    rd <= 0;\n                    wb_free <= 1;\n                end\n                READ_FIFO: begin\n                    rd <= 1;\n                    m_wb_dat_o <= dat_o;\n                end\n                WB_WRITE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00; // Linear burst\n                    wb_free <= 0;\n                end\n                WB_WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 0;\n                        m_wb_stb_o <= 0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output reg empty,\n    output reg fe,\n    output wire reset_tx_fifo\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Submodule instantiation\n    sd_tx_fifo tx_fifo(\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               WAIT_ACK = 1,\n               WRITE_FIFO = 2,\n               DELAY = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && !m_wb_ack_i && ackd)\n                    next_state = WAIT_ACK;\n                else\n                    next_state = IDLE;\n            end\n            WAIT_ACK: begin\n                if (m_wb_ack_i)\n                    next_state = WRITE_FIFO;\n                else\n                    next_state = WAIT_ACK;\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        end\n    end\n\n    // Output logic and memory address management\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (en) begin\n                        m_wb_adr_o <= adr + offset;\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 1;\n                        m_wb_stb_o <= 1;\n                        m_wb_cti_o <= 3'b000; // Classic cycle\n                        m_wb_bte_o <= 2'b00;  // Linear burst\n                    end\n                end\n                WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        din <= m_wb_dat_i;\n                        wr_tx <= 1;\n                    end\n                end\n                WRITE_FIFO: begin\n                    wr_tx <= 0;\n                    delay <= 1;\n                end\n                DELAY: begin\n                    offset <= offset + 4;\n                    ackd <= !ackd;\n                    delay <= 0;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                end\n            endcase\n        end\n    end\n\n    assign reset_tx_fifo = rst || (en == 0);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 7, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [30:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n    wire new_cmd;\n    wire we_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n\n    // Instantiate submodules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional logic and connections as needed\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 8, "code": "module sdc_controller (\n    input wb_clk_i,\n    input wb_rst_i,\n    input [3:0] wb_sel_i,\n    input [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input [7:0] wb_adr_i,\n    input wb_we_i,\n    input wb_cyc_i,\n    input wb_stb_i,\n    output reg wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output m_wb_sel_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input [30:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output m_wb_cti_o,\n    output m_wb_bte_o,\n    input card_detect,\n    input sd_cmd_dat_i,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input [3:0] sd_dat_dat_i,\n    output [3:0] sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_clk_o_pad,\n    input sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c\n);\n\n    // Internal signals\n    reg [31:0] internal_reg;\n    wire [31:0] cmd_arg;\n    wire [15:0] cmd_setting;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n\n    // Wishbone slave interface\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            wb_ack_o <= 1'b0;\n            wb_dat_o <= 32'b0;\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the bus cycle\n            if (wb_we_i) begin\n                // Write operation\n                if (wb_sel_i[0]) internal_reg[7:0] <= wb_dat_i[7:0];\n                if (wb_sel_i[1]) internal_reg[15:8] <= wb_dat_i[15:8];\n                if (wb_sel_i[2]) internal_reg[23:16] <= wb_dat_i[23:16];\n                if (wb_sel_i[3]) internal_reg[31:24] <= wb_dat_i[31:24];\n            end else begin\n                // Read operation\n                wb_dat_o <= internal_reg;\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\n\n    // Master Wishbone interface logic\n    assign m_wb_adr_o = 32'h00000000; // Example address\n    assign m_wb_sel_o = 1'b1;\n    assign m_wb_we_o = 1'b0;\n    assign m_wb_dat_o = 32'h00000000; // Example data\n    assign m_wb_cyc_o = 1'b0;\n    assign m_wb_stb_o = 1'b0;\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n\n    // SD/MMC interface logic\n    assign sd_cmd_out_o = sd_cmd_dat_i; // Example connection\n    assign sd_cmd_oe_o = 1'b1;\n    assign sd_dat_out_o = {4{sd_dat_dat_i[0]}}; // Example connection\n    assign sd_dat_oe_o = 1'b1;\n    assign sd_clk_o_pad = wb_clk_i; // Clock output example\n\n    // Interrupt logic\n    assign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) != 0;\n    assign int_b = (error_int_status_reg & error_int_signal_enable_reg) != 0;\n    assign int_c = (Bd_isr_reg & Bd_isr_enable_reg) != 0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n\n    // Instantiate the FIFO\n    sd_rx_fifo fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               READ_FIFO = 1,\n               WB_WRITE = 2,\n               WB_WAIT_ACK = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free)\n                    next_state = READ_FIFO;\n                else\n                    next_state = IDLE;\n            end\n            READ_FIFO: begin\n                next_state = WB_WRITE;\n            end\n            WB_WRITE: begin\n                if (m_wb_ack_i)\n                    next_state = WB_WAIT_ACK;\n                else\n                    next_state = WB_WRITE;\n            end\n            WB_WAIT_ACK: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic and control signal updates\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    reset_rx_fifo <= 0;\n                    rd <= 0;\n                    wb_free <= 1;\n                end\n                READ_FIFO: begin\n                    rd <= 1;\n                    m_wb_dat_o <= dat_o;\n                end\n                WB_WRITE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000; // Classic cycle\n                    m_wb_bte_o <= 2'b00;  // Linear burst\n                    wb_free <= 0;\n                end\n                WB_WAIT_ACK: begin\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    offset <= offset + MEM_OFFSET;\n                    wb_free <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [SD_BUS_W*16-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state;\n    reg [5:0] next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0;\n    reg [31:0] write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr;\n    reg in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Submodules\n    sd_crc_16 crc_gen (\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out[15:0])\n    );\n\n    // State Definitions\n    localparam IDLE = 6'b000001;\n    localparam WRITE_DAT = 6'b000010;\n    localparam WRITE_CRC = 6'b000100;\n    localparam WRITE_BUSY = 6'b001000;\n    localparam READ_WAIT = 6'b010000;\n    localparam READ_DAT = 6'b100000;\n\n    // State Machine: FSM_COMBO\n    always @(*) begin\n        next_state = state; // Default state remains unchanged unless conditions met below\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111)\n                    next_state = WRITE_BUSY;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM_SEQ: Sequential Logic for FSM\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT: Output Logic for FSM Control\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset conditions\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            // Normal operation\n            case (state)\n                WRITE_DAT: begin\n                    // Handle data writing logic\n                end\n                WRITE_CRC: begin\n                    // Handle CRC calculation and checking\n                end\n                WRITE_BUSY: begin\n                    // Handle busy waiting\n                end\n                READ_WAIT: begin\n                    // Prepare for reading\n                end\n                READ_DAT: begin\n                    // Handle data reading and CRC checking\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 9, "code": "module sdc_controller(\n    input wb_clk_i,\n    input wb_rst_i,\n    input [3:0] wb_sel_i,\n    input [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input [7:0] wb_adr_i,\n    input wb_we_i,\n    input wb_cyc_i,\n    input wb_stb_i,\n    output reg wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output m_wb_sel_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output m_wb_cti_o,\n    output m_wb_bte_o,\n    input card_detect,\n    input sd_cmd_dat_i,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input [3:0] sd_dat_dat_i,\n    output [3:0] sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_clk_o_pad,\n    input sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c\n);\n\n    // Internal signals\n    reg [31:0] internal_reg;\n    wire [31:0] cmd_response;\n    wire cmd_busy;\n    wire [15:0] status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .status_reg(status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg)\n    );\n\n    // Logic for interrupts\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n\n    // Master interface logic\n    assign m_wb_adr_o = /* logic to assign address */;\n    assign m_wb_sel_o = 4'b1111; // Assuming all bytes are valid\n    assign m_wb_we_o = /* logic to control write enable */;\n    assign m_wb_dat_o = /* logic to assign data */;\n    assign m_wb_cyc_o = /* logic to control cycle */;\n    assign m_wb_stb_o = /* logic to control strobe */;\n    assign m_wb_cti_o = /* logic to control CTI */;\n    assign m_wb_bte_o = /* logic to control BTE */;\n\n    // Clock output logic\n    assign sd_clk_o_pad = /* logic to generate or pass through SD clock */;\n\n    // Reset logic\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            internal_reg <= 32'b0;\n            wb_ack_o <= 1'b0;\n        end else begin\n            if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n                wb_ack_o <= 1'b1; // Acknowledge the transaction\n                if (wb_we_i) begin\n                    // Write operation\n                    case (wb_adr_i)\n                        // Address decoding for write operations\n                        default: internal_reg <= wb_dat_i;\n                    endcase\n                end else begin\n                    // Read operation\n                    case (wb_adr_i)\n                        // Address decoding for read operations\n                        default: wb_dat_o <= internal_reg;\n                    endcase\n                end\n            end else begin\n                wb_ack_o <= 1'b0;\n            end\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output reg [31:0] dat_o,\n    output reg empty,\n    output reg fe,\n    output wire reset_tx_fifo\n);\n\n    // Internal registers\n    reg [8:0] offset;\n    reg [8:0] we;\n    reg [31:0] din;\n    reg wr_tx;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // Submodule instantiation\n    sd_tx_fifo tx_fifo (\n        .d(din),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(),\n        .rclk(sd_clk),\n        .rst(reset_tx_fifo)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               WAIT_ACK = 1,\n               WRITE_FIFO = 2,\n               POST_WRITE = 3;\n\n    reg [1:0] state, next_state;\n\n    // Asynchronous reset\n    assign reset_tx_fifo = rst;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && !m_wb_ack_i && ackd)\n                    next_state = WAIT_ACK;\n                else\n                    next_state = IDLE;\n            end\n            WAIT_ACK: begin\n                if (m_wb_ack_i)\n                    next_state = WRITE_FIFO;\n                else\n                    next_state = WAIT_ACK;\n            end\n            WRITE_FIFO: begin\n                next_state = POST_WRITE;\n            end\n            POST_WRITE: begin\n                if (delay)\n                    next_state = IDLE;\n                else\n                    next_state = POST_WRITE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic and control signal updates\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 3'b000;\n            m_wb_bte_o <= 2'b00;\n            offset <= 0;\n            we <= 0;\n            din <= 0;\n            wr_tx <= 0;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 3'b000;\n                    m_wb_bte_o <= 2'b00;\n                    wr_tx <= 0;\n                end\n                WAIT_ACK: begin\n                    // Hold signals\n                end\n                WRITE_FIFO: begin\n                    din <= m_wb_dat_i;\n                    wr_tx <= 1;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                end\n                POST_WRITE: begin\n                    offset <= offset + 1;\n                    ackd <= !ackd;\n                    wr_tx <= 0;\n                    delay <= !delay;\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // State definitions\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_IN, CRC_OUT, CRC_Enable, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in;\n    reg q1, Ack_internal_in;\n\n    // REQ_SYNC and ACK_SYNC logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // FSM_COMBO logic\n    always @* begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = Write_Read ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // COMMAND_DECODER logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 0;\n            cmd_out_o <= 0;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                WRITE_WR: begin\n                    CMD_OUT <= In_Buff;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 1;\n                    STATUS <= 8'b00000001;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                WRITE_WO: begin\n                    CMD_OUT <= In_Buff;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 1;\n                    STATUS <= 8'b00000010;\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                end\n                DLY_WR, DLY_WO: begin\n                    ACK_OUT <= 1;\n                    REQ_OUT <= 0;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                end\n                READ_WR: begin\n                    CMD_OUT <= Out_Buff;\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 1;\n                    STATUS <= 8'b00000100;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                end\n                DLY_READ: begin\n                    ACK_OUT <= 1;\n                    REQ_OUT <= 0;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                end\n                ACK_WR, ACK_WO: begin\n                    ACK_OUT <= 1;\n                    REQ_OUT <= 0;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                end\n                default: begin\n                    ACK_OUT <= 0;\n                    REQ_OUT <= 0;\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 6, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n\n    // Internal Registers\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed;\n    reg [2:0] bd_cnt;\n\n    // FSM Combinational Logic for Next State\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY)\n                    next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY)\n                    next_state = GET_RX_BD;\n                else\n                    next_state = IDLE;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full)\n                    next_state = SEND_CMD;\n                else\n                    next_state = GET_TX_BD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1)\n                    next_state = SEND_CMD;\n                else\n                    next_state = GET_RX_BD;\n            end\n            SEND_CMD: begin\n                if (send_done)\n                    next_state = RECIVE_CMD;\n                else\n                    next_state = SEND_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done)\n                    next_state = DATA_TRANSFER;\n                else if (rec_failed)\n                    next_state = SEND_CMD;\n                else\n                    next_state = RECIVE_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done)\n                    next_state = IDLE;\n                else if (trans_failed)\n                    next_state = STOP;\n                else\n                    next_state = DATA_TRANSFER;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done)\n                    next_state = IDLE;\n                else\n                    next_state = STOP_SEND;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Sequential Logic for State Transition\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM Output Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n        end\n        else begin\n            case (state)\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    cmd_set <= CMD24;\n                    tx_cycle <= 1;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    cmd_set <= CMD17;\n                    rx_cycle <= 1;\n                end\n                SEND_CMD: begin\n                    we_req <= 1;\n                    d_write <= tx_cycle;\n                    d_read <= rx_cycle;\n                end\n                RECIVE_CMD: begin\n                    start_rx_fifo <= rx_cycle;\n                end\n                DATA_TRANSFER: begin\n                    if (transm_complete) begin\n                        ack_transfer <= 1;\n                        a_cmp_tx <= tx_cycle;\n                        a_cmp_rx <= rx_cycle;\n                    end\n                end\n                STOP_SEND: begin\n                    cmd_set <= CMD12;\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal signals\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [16*SD_BUS_W-1:0] crc_out;\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Submodule instantiation\n    sd_crc_16 crc_gen (\n        .BITVAL(crc_in),\n        .Enable(crc_en),\n        .CLK(sd_clk),\n        .RST(crc_rst),\n        .CRC(crc_out)\n    );\n\n    // State definitions\n    localparam IDLE        = 6'b000001;\n    localparam WRITE_DAT   = 6'b000010;\n    localparam WRITE_CRC   = 6'b000100;\n    localparam WRITE_BUSY  = 6'b001000;\n    localparam READ_WAIT   = 6'b010000;\n    localparam READ_DAT    = 6'b100000;\n\n    // State machine: Sequential logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // State machine: Combinational logic for next state\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (DAT_dat_i[0] == 0)\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic based on state\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset all outputs and internal registers\n            rd <= 0;\n            data_out <= 0;\n            we <= 0;\n            DAT_oe_o <= 0;\n            DAT_dat_o <= 0;\n            busy_n <= 1;\n            transm_complete <= 0;\n            crc_ok <= 0;\n            crc_rst <= 1;\n            crc_en <= 0;\n            transf_cnt <= 0;\n        end else begin\n            case (state)\n                WRITE_DAT: begin\n                    // Handle data writing logic\n                end\n                WRITE_CRC: begin\n                    // Handle CRC generation and checking\n                end\n                WRITE_BUSY: begin\n                    // Handle busy waiting\n                end\n                READ_WAIT: begin\n                    // Prepare for reading data\n                end\n                READ_DAT: begin\n                    // Handle data reading and CRC checking\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output wire full,\n    output wire empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire mem_empty;\n\n    // Submodule: sd_rx_fifo\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(full),\n        .empty(empty),\n        .mem_empt(mem_empty),\n        .rclk(clk),\n        .rst(reset_rx_fifo)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               READ_FIFO = 1,\n               WB_WRITE = 2,\n               WB_WAIT_ACK = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !empty && wb_free)\n                    next_state = READ_FIFO;\n                else\n                    next_state = IDLE;\n            end\n            READ_FIFO: begin\n                next_state = WB_WRITE;\n            end\n            WB_WRITE: begin\n                if (m_wb_ack_i)\n                    next_state = WB_WAIT_ACK;\n                else\n                    next_state = WB_WRITE;\n            end\n            WB_WAIT_ACK: begin\n                if (wb_free)\n                    next_state = IDLE;\n                else\n                    next_state = WB_WAIT_ACK;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic and register updates\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wb_free <= 1;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    reset_rx_fifo <= 0;\n                    rd <= 0;\n                    wb_free <= 1;\n                end\n                READ_FIFO: begin\n                    rd <= 1;\n                    m_wb_dat_o <= dat_o;\n                end\n                WB_WRITE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 0; // Classic cycle\n                    m_wb_bte_o <= 0; // Linear burst\n                    wb_free <= 0;\n                end\n                WB_WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 0;\n                        m_wb_stb_o <= 0;\n                        offset <= offset + MEM_OFFSET;\n                        wb_free <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal parameters\n    parameter INIT_DELAY = `SIM ? 2 : 64;\n    parameter NCR = 2;\n    parameter SEND_SIZE = 48;\n    parameter SIZE = 10;\n    parameter CONTENT_SIZE = 40;\n    parameter Read_Delay = 7;\n    parameter EIGHT_PAD = 8;\n\n    // State definitions\n    localparam [SIZE-1:0]\n        INIT = 10'b0000000001,\n        IDLE = 10'b0000000010,\n        WRITE_WR = 10'b0000000100,\n        DLY_WR = 10'b0000001000,\n        READ_WR = 10'b0000010000,\n        DLY_READ = 10'b0000100000,\n        ACK_WR = 10'b0001000000,\n        WRITE_WO = 10'b0010000000,\n        DLY_WO = 10'b0100000000,\n        ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_Enable, CRC_OUT, CRC_Check_On, Crc_Buffering, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in, q1, Ack_internal_in;\n\n    // Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // FSM_COMBO logic\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = Write_Read ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // COMMAND_DECODER logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            // Reset all internal registers and flags\n            Delay_Cycler <= 0;\n            Response_Size <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            // Decode SETTING_IN\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            // Reset all outputs and internal counters\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            st_dat_t <= 0;\n            CRC_RST <= 1;\n            CRC_Enable <= 0;\n            CRC_OUT <= 0;\n            CRC_IN <= 0;\n            Crc_Buffering <= 0;\n            CRC_Valid <= 0;\n            Cmd_Cnt <= 0;\n            Delay_Cnt <= 0;\n            FSM_ACK <= 1;\n        end else begin\n            case (state)\n                INIT: begin\n                    if (Cmd_Cnt < INIT_DELAY) begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= 1;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        cmd_oe_o <= 0;\n                        cmd_out_o <= 0;\n                        Cmd_Cnt <= 0;\n                    end\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    Crc_Buffering <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[Cmd_Cnt];\n                            if (Cmd_Cnt > 9) begin\n                                CRC_OUT <= In_Buff[Cmd_Cnt];\n                            end\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= {block_read, block_write};\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[Cmd_Cnt];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        cmd_out_o <= In_Buff[Cmd_Cnt];\n                        CRC_OUT <= In_Buff[Cmd_Cnt];\n                        st_dat_t <= {block_read, 1'b0};\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[Cmd_Cnt];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) begin\n                        Delay_Cnt <= Delay_Cnt + 1;\n                    end\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && (CRC_Check_On == 1)) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= {block_read, block_write};\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_tx_filler", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_tx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire m_wb_ack_i,\n    input wire [31:0] m_wb_dat_i,\n    input wire rd,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire [31:0] dat_o,\n    output wire empty,\n    output wire fe\n);\n\n    // Internal Registers\n    reg [8:0] offset;\n    reg wr_tx;\n    reg reset_tx_fifo;\n    reg first;\n    reg ackd;\n    reg delay;\n\n    // FIFO Interface\n    wire full;\n    wire [31:0] q;\n    wire [5:0] mem_empt;\n\n    // Instantiate the FIFO\n    sd_tx_fifo fifo (\n        .d(m_wb_dat_i),\n        .wr(wr_tx),\n        .wclk(clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fe),\n        .empty(empty),\n        .mem_empt(mem_empt),\n        .rclk(sd_clk),\n        .rst(rst)\n    );\n\n    // State Definitions\n    localparam IDLE = 0,\n               WAIT_ACK = 1,\n               WRITE_FIFO = 2,\n               DELAY = 3;\n\n    reg [1:0] state, next_state;\n\n    // State Transition Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fe && !m_wb_ack_i && ackd)\n                    next_state = WAIT_ACK;\n                else\n                    next_state = IDLE;\n            end\n            WAIT_ACK: begin\n                if (m_wb_ack_i)\n                    next_state = WRITE_FIFO;\n                else\n                    next_state = WAIT_ACK;\n            end\n            WRITE_FIFO: begin\n                next_state = DELAY;\n            end\n            DELAY: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            offset <= 0;\n            wr_tx <= 0;\n            reset_tx_fifo <= 1;\n            first <= 1;\n            ackd <= 0;\n            delay <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (en) begin\n                        m_wb_adr_o <= adr + offset;\n                        m_wb_we_o <= 0;\n                        m_wb_cyc_o <= 1;\n                        m_wb_stb_o <= 1;\n                        m_wb_cti_o <= 3'b000; // Classic cycle\n                        m_wb_bte_o <= 2'b00; // Linear burst\n                        reset_tx_fifo <= 0;\n                    end else begin\n                        reset_tx_fifo <= 1;\n                        offset <= 0;\n                        m_wb_cyc_o <= 0;\n                        m_wb_stb_o <= 0;\n                    end\n                end\n                WAIT_ACK: begin\n                    if (m_wb_ack_i) begin\n                        wr_tx <= 1;\n                    end\n                end\n                WRITE_FIFO: begin\n                    wr_tx <= 0;\n                    ackd <= 0;\n                    delay <= 1;\n                end\n                DELAY: begin\n                    offset <= offset + 4;\n                    ackd <= 1;\n                    delay <= 0;\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 10, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire sd_clk_i;\n    wire sd_clk_o;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n\n    // Clock and reset logic\n    assign sd_clk_i = `SD_CLK_SEP ? sd_clk_i_pad : wb_clk_i;\n    assign sd_clk_o = `SD_CLK_DYNAMIC ? sd_clk_o_pad : sd_clk_i;\n\n    // Master Wishbone Interface Control\n    assign m_wb_adr_o = start_tx_fifo ? sd_fifo_tx_filler_adr : (start_rx_fifo ? sd_fifo_rx_filler_adr : 32'b0);\n    assign m_wb_we_o = start_tx_fifo ? sd_fifo_tx_filler_we : (start_rx_fifo ? sd_fifo_rx_filler_we : 1'b0);\n    assign m_wb_dat_o = start_tx_fifo ? sd_fifo_tx_filler_dat : (start_rx_fifo ? sd_fifo_rx_filler_dat : 32'b0);\n    assign m_wb_cyc_o = start_tx_fifo ? sd_fifo_tx_filler_cyc : (start_rx_fifo ? sd_fifo_rx_filler_cyc : 1'b0);\n    assign m_wb_stb_o = start_tx_fifo ? sd_fifo_tx_filler_stb : (start_rx_fifo ? sd_fifo_rx_filler_stb : 1'b0);\n    assign m_wb_cti_o = start_tx_fifo ? sd_fifo_tx_filler_cti : (start_rx_fifo ? sd_fifo_rx_filler_cti : 3'b0);\n    assign m_wb_bte_o = start_tx_fifo ? sd_fifo_tx_filler_bte : (start_rx_fifo ? sd_fifo_rx_filler_bte : 2'b0);\n\n    // Interrupt logic\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n\n    // Wishbone slave interface\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            wb_ack_o <= 1'b0;\n            wb_dat_o <= 32'b0;\n        end else begin\n            wb_ack_o <= wb_cyc_i & wb_stb_i & ~wb_ack_o;\n            if (wb_cyc_i & wb_stb_i & wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    // Address decoding for write operations\n                    // Example: 8'h00: register <= wb_dat_i;\n                endcase\n            end else if (wb_cyc_i & wb_stb_i & ~wb_we_i) begin\n                // Read operation\n                case (wb_adr_i)\n                    // Address decoding for read operations\n                    // Example: 8'h00: wb_dat_o <= register;\n                endcase\n            end\n        end\n    end\n\n    // Submodule instantiations\n    // Example: sd_controller_wb sd_controller_wb_inst (...);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 11, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n// Internal signals\nreg [31:0] internal_reg;\nwire [31:0] cmd_arg;\nwire [15:0] cmd_setting;\nwire [15:0] status_reg;\nwire [31:0] cmd_resp_1;\nwire [7:0] software_reset_reg;\nwire [15:0] time_out_reg;\nwire [15:0] normal_int_status_reg;\nwire [15:0] error_int_status_reg;\nwire [15:0] normal_int_signal_enable_reg;\nwire [15:0] error_int_signal_enable_reg;\nwire [7:0] clock_divider;\nwire [15:0] Bd_Status_reg;\nwire [7:0] Bd_isr_reg;\nwire [7:0] Bd_isr_enable_reg;\nwire bd_isr_reset;\nwire normal_isr_reset;\nwire error_isr_reset;\nwire [31:0] dat_in_m_tx_bd;\nwire [31:0] dat_in_m_rx_bd;\n\n// Wishbone slave interface\nalways @(posedge wb_clk_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 1'b0;\n        wb_dat_o <= 32'b0;\n    end else begin\n        if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n            wb_ack_o <= 1'b1; // Acknowledge the current cycle\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: internal_reg <= wb_dat_i;\n                    // Add more cases as per register map\n                    default: ;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= internal_reg;\n                    // Add more cases as per register map\n                    default: wb_dat_o <= 32'hdeadbeef; // Indicate undefined address\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n        end\n    end\nend\n\n// Master Wishbone interface\nassign m_wb_adr_o = 32'h00000000; // Example address\nassign m_wb_sel_o = 1'b1;\nassign m_wb_we_o = 1'b0;\nassign m_wb_dat_o = 32'h00000000; // Example data\nassign m_wb_cyc_o = 1'b0;\nassign m_wb_stb_o = 1'b0;\nassign m_wb_cti_o = 3'b000;\nassign m_wb_bte_o = 2'b00;\n\n// SD/MMC command and data interfaces\nassign sd_cmd_out_o = 1'b0; // Example output\nassign sd_cmd_oe_o = 1'b0;\nassign sd_dat_out_o = 4'h0; // Example output\nassign sd_dat_oe_o = 1'b0;\nassign sd_clk_o_pad = 1'b0; // Example clock output\n\n// Interrupts\nassign int_a = 1'b0; // Example interrupt output\nassign int_b = 1'b0;\nassign int_c = 1'b0;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 7, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    localparam CMD24 = 16'h181A;\n    localparam CMD17 = 16'h111A;\n    localparam CMD12 = 16'hC1A;\n    localparam ACMD13 = 16'hD1A;\n    localparam ACMD51 = 16'h331A;\n    localparam SIZE = 9;\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n    localparam RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state; // Default to hold state\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY)\n                    next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY)\n                    next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full)\n                    next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1)\n                    next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done)\n                    next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done)\n                    next_state = DATA_TRANSFER;\n                else if (rec_failed)\n                    next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done)\n                    next_state = IDLE;\n                else if (trans_failed)\n                    next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done)\n                    next_state = IDLE;\n            end\n        end\n    end\n\n    // Output logic based on state\n    always @(state) begin\n        // Reset outputs\n        re_s_tx = 0;\n        a_cmp_tx = 0;\n        re_s_rx = 0;\n        a_cmp_rx = 0;\n        we_req = 0;\n        d_write = 0;\n        d_read = 0;\n        start_tx_fifo = 0;\n        start_rx_fifo = 0;\n        ack_transfer = 0;\n        CIDAT = 0;\n        Dat_Int_Status = 0;\n\n        case (state)\n            GET_TX_BD: begin\n                re_s_tx = 1;\n                if (ack_i_s_tx) begin\n                    sys_adr = dat_in_tx;\n                    cmd_arg = dat_in_tx;\n                    cmd_set = CMD24;\n                    start_tx_fifo = 1;\n                    tx_cycle = 1;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx = 1;\n                if (ack_i_s_rx) begin\n                    sys_adr = dat_in_rx;\n                    cmd_arg = dat_in_rx;\n                    cmd_set = transfer_type == 2'b00 ? CMD17 : (transfer_type == 2'b01 ? ACMD13 : ACMD51);\n                    start_rx_fifo = 1;\n                    rx_cycle = 1;\n                end\n            end\n            SEND_CMD: begin\n                we_req = 1;\n                if (we_ack) begin\n                    send_done = 1;\n                    d_write = tx_cycle;\n                    d_read = rx_cycle;\n                end\n            end\n            RECIVE_CMD: begin\n                if (!cmd_busy && card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                    rec_done = 1;\n                end else if (cmd_tsf_err) begin\n                    rec_failed = 1;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete && crc_ok) begin\n                    trans_done = 1;\n                    a_cmp_tx = tx_cycle;\n                    a_cmp_rx = rx_cycle;\n                end else if (!crc_ok) begin\n                    trans_failed = 1;\n                end\n            end\n            STOP_SEND: begin\n                cmd_set = CMD12;\n                we_req = 1;\n                if (we_ack) send_done = 1;\n            end\n        end\n    end\n\n    // Handle Dat_Int_Status reset\n    always @(posedge Dat_Int_Status_rst) begin\n        if (Dat_Int_Status_rst) Dat_Int_Status = 0;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [15:0] crc_out[SD_BUS_W-1:0];\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // Submodule Instances\n    // CRC Generation Block\n    genvar i;\n    generate\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_unit(\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[i])\n            );\n        end\n    endgenerate\n\n    // FSM_COMBO Logic\n    always @(*) begin\n        case (state)\n            `IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = `READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = `WRITE_DAT;\n                else\n                    next_state = `IDLE;\n            end\n            `WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = `WRITE_CRC;\n                else\n                    next_state = `WRITE_DAT;\n            end\n            `WRITE_CRC: begin\n                if (crc_status == `OK)\n                    next_state = `WRITE_BUSY;\n                else\n                    next_state = `WRITE_CRC;\n            end\n            `WRITE_BUSY: begin\n                if (busy_int == 0)\n                    next_state = `IDLE;\n                else\n                    next_state = `WRITE_BUSY;\n            end\n            `READ_WAIT: begin\n                if (DAT_dat_i[0] == 0)\n                    next_state = `READ_DAT;\n                else\n                    next_state = `READ_WAIT;\n            end\n            `READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = `IDLE;\n                else\n                    next_state = `READ_DAT;\n            end\n            default: next_state = `IDLE;\n        endcase\n    end\n\n    // FSM_SEQ Logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst)\n            state <= `IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM_OUT Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset conditions\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            // Normal operation\n            case (state)\n                `WRITE_DAT: begin\n                    // Handle data writing logic\n                end\n                `WRITE_CRC: begin\n                    // Handle CRC writing logic\n                end\n                `WRITE_BUSY: begin\n                    // Handle busy state logic\n                end\n                `READ_WAIT: begin\n                    // Handle read wait logic\n                end\n                `READ_DAT: begin\n                    // Handle data reading logic\n                end\n            endcase\n        end\n    end\n\n    // ACK_SYNC Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            ack_transfer_int <= 0;\n            ack_q <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // State definitions\n    localparam [SIZE-1:0]\n        INIT = 10'b0000000001,\n        IDLE = 10'b0000000010,\n        WRITE_WR = 10'b0000000100,\n        DLY_WR = 10'b0000001000,\n        READ_WR = 10'b0000010000,\n        DLY_READ = 10'b0000100000,\n        ACK_WR = 10'b0001000000,\n        WRITE_WO = 10'b0010000000,\n        DLY_WO = 10'b0100000000,\n        ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_Enable, CRC_OUT, CRC_Check_On, Crc_Buffering, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in, q1, Ack_internal_in;\n\n    // Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 1'b0;\n            Req_internal_in <= 1'b0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 1'b0;\n            Ack_internal_in <= 1'b0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // FSM_COMBO logic\n    always @* begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = Write_Read ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // COMMAND_DECODER logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            Write_Read <= (SETTING_IN[6:0] > 0);\n            Write_Only <= (SETTING_IN[6:0] == 0);\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 1;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    if (Cmd_Cnt < INIT_DELAY) Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            CMD_OUT <= In_Buff[Cmd_Cnt];\n                            if (Cmd_Cnt > 9) CRC_OUT <= In_Buff[Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            CRC_OUT <= In_Buff[Cmd_Cnt];\n                            st_dat_t <= block_read ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[Cmd_Cnt];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        CMD_OUT <= In_Buff[Cmd_Cnt];\n                        st_dat_t <= block_read ? 2'b10 : 2'b01;\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[Cmd_Cnt];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= block_read && block_write ? 2'b11 : (block_write ? 2'b01 : 2'b10);\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    input wire m_wb_ack_i,\n    input wire [31:0] adr,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o,\n    output wire full,\n    output wire empty\n);\n\n// Internal signals\nreg [8:0] offset;\nreg wb_free;\nreg reset_rx_fifo;\nreg rd;\nwire [31:0] dat_o;\nwire [1:0] mem_empt;\n\n// Instantiate the sd_rx_fifo submodule\nsd_rx_fifo rx_fifo (\n    .d(dat_i),\n    .wr(wr),\n    .wclk(sd_clk),\n    .q(dat_o),\n    .rd(rd),\n    .full(full),\n    .empty(empty),\n    .mem_empt(mem_empt),\n    .rclk(clk),\n    .rst(reset_rx_fifo)\n);\n\n// State definitions\nlocalparam IDLE = 0,\n           READ_FIFO = 1,\n           WB_WRITE = 2,\n           WB_WAIT_ACK = 3;\n\nreg [1:0] state, next_state;\n\n// State transition logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (en && !empty && wb_free)\n                next_state = READ_FIFO;\n            else\n                next_state = IDLE;\n        end\n        READ_FIFO: begin\n            next_state = WB_WRITE;\n        end\n        WB_WRITE: begin\n            if (!m_wb_ack_i)\n                next_state = WB_WAIT_ACK;\n            else\n                next_state = WB_WRITE;\n        end\n        WB_WAIT_ACK: begin\n            if (m_wb_ack_i)\n                next_state = IDLE;\n            else\n                next_state = WB_WAIT_ACK;\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\n// Output and internal register logic\nalways @(posedge clk) begin\n    if (rst) begin\n        m_wb_adr_o <= 0;\n        m_wb_we_o <= 0;\n        m_wb_dat_o <= 0;\n        m_wb_cyc_o <= 0;\n        m_wb_stb_o <= 0;\n        m_wb_cti_o <= 0;\n        m_wb_bte_o <= 0;\n        offset <= 0;\n        wb_free <= 1;\n        reset_rx_fifo <= 1;\n        rd <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                reset_rx_fifo <= 0;\n                rd <= 0;\n                wb_free <= 1;\n            end\n            READ_FIFO: begin\n                rd <= 1;\n                m_wb_dat_o <= dat_o;\n            end\n            WB_WRITE: begin\n                m_wb_adr_o <= adr + offset;\n                m_wb_we_o <= 1;\n                m_wb_cyc_o <= 1;\n                m_wb_stb_o <= 1;\n                m_wb_cti_o <= 3'b000; // Classic cycle\n                m_wb_bte_o <= 2'b00;  // Linear burst\n                wb_free <= 0;\n            end\n            WB_WAIT_ACK: begin\n                if (m_wb_ack_i) begin\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    offset <= offset + MEM_OFFSET;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 8, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    localparam CMD24 = 16'h181A;\n    localparam CMD17 = 16'h111A;\n    localparam CMD12 = 16'hC1A;\n    localparam ACMD13 = 16'hD1A;\n    localparam ACMD51 = 16'h331A;\n    localparam SIZE = 9;\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n    localparam RESEND_MAX_CNT = 3;\n\n    // State Registers\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM Combinational Logic for Next State\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY)\n                    next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY)\n                    next_state = GET_RX_BD;\n                else\n                    next_state = IDLE;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full)\n                    next_state = SEND_CMD;\n                else\n                    next_state = GET_TX_BD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1)\n                    next_state = SEND_CMD;\n                else\n                    next_state = GET_RX_BD;\n            end\n            SEND_CMD: begin\n                if (send_done)\n                    next_state = RECIVE_CMD;\n                else\n                    next_state = SEND_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done)\n                    next_state = DATA_TRANSFER;\n                else if (rec_failed)\n                    next_state = SEND_CMD;\n                else\n                    next_state = RECIVE_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done)\n                    next_state = IDLE;\n                else if (trans_failed)\n                    next_state = STOP;\n                else\n                    next_state = DATA_TRANSFER;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done)\n                    next_state = IDLE;\n                else\n                    next_state = STOP_SEND;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Sequential Logic for State Transition\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM Output Logic\n    always @(posedge clk) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    // Reset all control signals\n                end\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    // Additional logic for handling Tx BD based on memory width\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    // Additional logic for handling Rx BD based on memory width\n                end\n                SEND_CMD: begin\n                    we_req <= 1;\n                    // Set d_write or d_read based on tx_cycle or rx_cycle\n                end\n                RECIVE_CMD: begin\n                    // Check cmd_tsf_err and card_status\n                end\n                DATA_TRANSFER: begin\n                    // Handle data transfer based on tx_cycle or rx_cycle\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    // Reset relevant flags\n                end\n                STOP_SEND: begin\n                    // Handle stop command sending\n                end\n                default: begin\n                    // Default case to handle unexpected states\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 9, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    localparam CMD24 = 16'h181A;\n    localparam CMD17 = 16'h111A;\n    localparam CMD12 = 16'hC1A;\n    localparam ACMD13 = 16'hD1A;\n    localparam ACMD51 = 16'h331A;\n    localparam SIZE = 9;\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n    localparam RESEND_MAX_CNT = 3;\n\n    // Internal Signals\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed;\n    reg internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // State Machine Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next State Logic\n    always @(*) begin\n        next_state = state; // Default to hold state\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY && !cmd_busy)\n                    next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY && !cmd_busy)\n                    next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (ack_i_s_tx && bd_cnt >= READ_CYCLE - 1 && !tx_full)\n                    next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (ack_i_s_rx && bd_cnt >= READ_CYCLE - 1)\n                    next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done)\n                    next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done)\n                    next_state = DATA_TRANSFER;\n                else if (rec_failed)\n                    next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done)\n                    next_state = IDLE;\n                else if (trans_failed)\n                    next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done)\n                    next_state = IDLE;\n            end\n        end\n    end\n\n    // Output Logic\n    always @(state) begin\n        // Reset all outputs\n        re_s_tx = 0;\n        a_cmp_tx = 0;\n        re_s_rx = 0;\n        a_cmp_rx = 0;\n        we_req = 0;\n        d_write = 0;\n        d_read = 0;\n        start_tx_fifo = 0;\n        start_rx_fifo = 0;\n        ack_transfer = 0;\n        Dat_Int_Status = 0;\n        CIDAT = 0;\n\n        case (state)\n            GET_TX_BD: begin\n                re_s_tx = 1;\n                if (ack_i_s_tx) begin\n                    sys_adr = dat_in_tx;\n                    cmd_arg = dat_in_tx;\n                    start_tx_fifo = 1;\n                    cmd_set = CMD24;\n                    tx_cycle = 1;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx = 1;\n                if (ack_i_s_rx) begin\n                    sys_adr = dat_in_rx;\n                    cmd_arg = dat_in_rx;\n                    start_rx_fifo = 1;\n                    cmd_set = transfer_type == 2'b00 ? CMD17 : (transfer_type == 2'b01 ? ACMD13 : ACMD51);\n                    rx_cycle = 1;\n                end\n            end\n            SEND_CMD: begin\n                we_req = 1;\n                if (we_ack) begin\n                    send_done = 1;\n                    d_write = tx_cycle;\n                    d_read = rx_cycle;\n                end\n            end\n            RECIVE_CMD: begin\n                if (!cmd_busy) begin\n                    rec_done = 1;\n                    if (cmd_tsf_err) rec_failed = 1;\n                    if (card_status[0] == 1) CIDAT = 1;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete) begin\n                    trans_done = 1;\n                    a_cmp_tx = tx_cycle;\n                    a_cmp_rx = rx_cycle;\n                end\n                if (!crc_ok) trans_failed = 1;\n            end\n            STOP_SEND: begin\n                cmd_set = CMD12;\n                resend_try_cnt = resend_try_cnt + 1;\n                if (resend_try_cnt >= RESEND_MAX_CNT) Dat_Int_Status[1] = 1;\n                if (!cmd_busy) we_req = 1;\n                if (we_ack) send_done = 1;\n            end\n        end\n    end\n\n    // Reset internal signals\n    always @(posedge rst) begin\n        if (rst) begin\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            resend_try_cnt <= 0;\n            bd_cnt <= 0;\n        end\n    end\n\n    // Handle Dat_Int_Status reset\n    always @(posedge Dat_Int_Status_rst) begin\n        if (Dat_Int_Status_rst) begin\n            Dat_Int_Status <= 0;\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register address decoding\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1; // Default to high\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the wishbone transaction\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    8'h60: begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                        we_m_rx_bd <= 1'b1;\n                    end\n                    8'h80: begin\n                        dat_in_m_tx_bd <= wb_dat_i;\n                        we_m_tx_bd <= 1'b1;\n                    end\n                    default: ;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'b0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'b0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    8'h4c: wb_dat_o <= {24'b0, clock_divider};\n                    8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 10, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters for commands and states\n    localparam CMD24 = 16'h181A;\n    localparam CMD17 = 16'h111A;\n    localparam CMD12 = 16'hC1A;\n    localparam ACMD13 = 16'hD1A;\n    localparam ACMD51 = 16'h331A;\n    localparam SIZE = 9;\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n    localparam RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed;\n    reg [2:0] bd_cnt;\n\n    // FSM logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            bd_cnt <= 0;\n            Dat_Int_Status <= 0;\n        end else begin\n            state <= next_state;\n            if (state == SEND_CMD && we_ack) begin\n                send_done <= 1;\n            end\n            if (state == RECIVE_CMD && !cmd_busy) begin\n                if (cmd_tsf_err) rec_failed <= 1;\n                else rec_done <= 1;\n            end\n            if (state == DATA_TRANSFER && transm_complete) begin\n                if (!crc_ok) trans_failed <= 1;\n                else trans_done <= 1;\n            end\n            if (state == STOP_SEND && send_done) begin\n                resend_try_cnt <= resend_try_cnt + 1;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state; // Default to stay in current state\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY && !tx_full) next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY && !rx_full) next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (ack_i_s_tx && bd_cnt >= READ_CYCLE - 1) next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (ack_i_s_rx && bd_cnt >= READ_CYCLE - 1) next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done) next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done) next_state = DATA_TRANSFER;\n                else if (rec_failed) next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) next_state = IDLE;\n                else if (trans_failed) next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done && resend_try_cnt < RESEND_MAX_CNT) next_state = SEND_CMD;\n                else next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        re_s_tx = (state == GET_TX_BD);\n        re_s_rx = (state == GET_RX_BD);\n        we_req = (state == SEND_CMD);\n        d_write = (state == SEND_CMD && tx_cycle);\n        d_read = (state == SEND_CMD && rx_cycle);\n        start_tx_fifo = (state == GET_TX_BD && tx_cycle);\n        start_rx_fifo = (state == GET_RX_BD && rx_cycle);\n        ack_transfer = (state == DATA_TRANSFER && trans_done);\n        if (Dat_Int_Status_rst) Dat_Int_Status = 0;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 12, "code": "module sdc_controller (\n    input wb_clk_i,\n    input wb_rst_i,\n    input [3:0] wb_sel_i,\n    input [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input [7:0] wb_adr_i,\n    input wb_we_i,\n    input wb_cyc_i,\n    input wb_stb_i,\n    output reg wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output m_wb_sel_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output m_wb_cti_o,\n    output m_wb_bte_o,\n    input card_detect,\n    input sd_cmd_dat_i,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input [3:0] sd_dat_dat_i,\n    output [3:0] sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_clk_o_pad,\n    input sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c\n);\n\n    // Internal signals\n    reg [31:0] internal_reg;\n    wire [31:0] cmd_arg;\n    wire [15:0] cmd_set;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n\n    // Wishbone slave interface\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            wb_ack_o <= 1'b0;\n            wb_dat_o <= 32'b0;\n        end else begin\n            if (wb_cyc_i && wb_stb_i) begin\n                wb_ack_o <= 1'b1; // Acknowledge the transaction\n                if (wb_we_i) begin\n                    // Write operation\n                    case (wb_adr_i)\n                        8'h00: internal_reg <= wb_dat_i;\n                        // Add other addresses and corresponding actions\n                        default: ;\n                    endcase\n                end else begin\n                    // Read operation\n                    case (wb_adr_i)\n                        8'h00: wb_dat_o <= internal_reg;\n                        // Add other addresses and corresponding actions\n                        default: wb_dat_o <= 32'hDEADBEEF; // Default data\n                    endcase\n                end\n            end else begin\n                wb_ack_o <= 1'b0;\n            end\n        end\n    end\n\n    // Master Wishbone interface logic\n    assign m_wb_adr_o = 32'h00000000; // Example address\n    assign m_wb_sel_o = 1'b1;\n    assign m_wb_we_o = 1'b0;\n    assign m_wb_dat_o = 32'h00000000; // Example data\n    assign m_wb_cyc_o = 1'b0;\n    assign m_wb_stb_o = 1'b0;\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n\n    // SD/MMC command and data interface logic\n    assign sd_cmd_out_o = sd_cmd_dat_i; // Example connection\n    assign sd_cmd_oe_o = 1'b1;\n    assign sd_dat_out_o = {4{sd_dat_dat_i[0]}}; // Example connection\n    assign sd_dat_oe_o = 1'b1;\n    assign sd_clk_o_pad = wb_clk_i; // Example clock connection\n\n    // Interrupt logic\n    assign int_a = normal_int_status_reg[0] & normal_int_signal_enable_reg[0];\n    assign int_b = error_int_status_reg[0] & error_int_signal_enable_reg[0];\n    assign int_c = Bd_isr_reg[0] & Bd_isr_enable_reg[0];\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_fifo_rx_filler", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_fifo_rx_filler(\n    input wire clk,\n    input wire rst,\n    input wire en,\n    input wire [31:0] adr,\n    input wire sd_clk,\n    input wire [SD_BUS_W-1:0] dat_i,\n    input wire wr,\n    output reg full,\n    output reg empty,\n    output reg [31:0] m_wb_adr_o,\n    output reg m_wb_we_o,\n    output reg [31:0] m_wb_dat_o,\n    output reg m_wb_cyc_o,\n    output reg m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output reg [2:0] m_wb_cti_o,\n    output reg [1:0] m_wb_bte_o\n);\n\n    // Internal signals\n    reg [8:0] offset;\n    reg wb_free;\n    reg reset_rx_fifo;\n    reg rd;\n    wire [31:0] dat_o;\n    wire fifo_full;\n    wire fifo_empty;\n    wire [1:0] mem_empty;\n\n    // Submodule: sd_rx_fifo\n    sd_rx_fifo rx_fifo (\n        .d(dat_i),\n        .wr(wr),\n        .wclk(sd_clk),\n        .q(dat_o),\n        .rd(rd),\n        .full(fifo_full),\n        .empty(fifo_empty),\n        .mem_empt(mem_empty),\n        .rclk(clk),\n        .rst(rst)\n    );\n\n    // State definitions\n    localparam IDLE = 0,\n               READ_FIFO = 1,\n               WB_WRITE = 2,\n               WB_WAIT_ACK = 3;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (en && !fifo_empty && wb_free)\n                    next_state = READ_FIFO;\n                else\n                    next_state = IDLE;\n            end\n            READ_FIFO: begin\n                next_state = WB_WRITE;\n            end\n            WB_WRITE: begin\n                if (m_wb_ack_i)\n                    next_state = WB_WAIT_ACK;\n                else\n                    next_state = WB_WRITE;\n            end\n            WB_WAIT_ACK: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic and control signal updates\n    always @(posedge clk) begin\n        if (rst) begin\n            // Reset all outputs and internal registers\n            m_wb_adr_o <= 0;\n            m_wb_we_o <= 0;\n            m_wb_dat_o <= 0;\n            m_wb_cyc_o <= 0;\n            m_wb_stb_o <= 0;\n            m_wb_cti_o <= 0;\n            m_wb_bte_o <= 0;\n            wb_free <= 1;\n            offset <= 0;\n            reset_rx_fifo <= 1;\n            rd <= 0;\n            full <= 0;\n            empty <= 1;\n        end else begin\n            case (state)\n                IDLE: begin\n                    reset_rx_fifo <= 0;\n                    rd <= 0;\n                    wb_free <= 1;\n                end\n                READ_FIFO: begin\n                    rd <= 1;\n                    m_wb_dat_o <= dat_o;\n                end\n                WB_WRITE: begin\n                    m_wb_adr_o <= adr + offset;\n                    m_wb_we_o <= 1;\n                    m_wb_cyc_o <= 1;\n                    m_wb_stb_o <= 1;\n                    m_wb_cti_o <= 0; // Classic cycle\n                    m_wb_bte_o <= 0; // Linear burst\n                    wb_free <= 0;\n                end\n                WB_WAIT_ACK: begin\n                    m_wb_we_o <= 0;\n                    m_wb_cyc_o <= 0;\n                    m_wb_stb_o <= 0;\n                    offset <= offset + MEM_OFFSET;\n                    wb_free <= 1;\n                end\n            endcase\n        end\n    end\n\n    // Update FIFO full and empty flags\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            full <= 0;\n            empty <= 1;\n        end else begin\n            full <= fifo_full;\n            empty <= fifo_empty;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 13, "code": "module sdc_controller (\n    input wb_clk_i,\n    input wb_rst_i,\n    input [3:0] wb_sel_i,\n    input [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input [7:0] wb_adr_i,\n    input wb_we_i,\n    input wb_cyc_i,\n    input wb_stb_i,\n    output reg wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output m_wb_sel_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output m_wb_cti_o,\n    output m_wb_bte_o,\n    input card_detect,\n    input sd_cmd_dat_i,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input [3:0] sd_dat_dat_i,\n    output [3:0] sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_clk_o_pad,\n    input sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c\n);\n\n    // Internal signals\n    wire sd_clk;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n\n    // Instantiate submodules\n    sd_controller_wb wb_controller (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Clock divider\n    sd_clock_divider clk_div (\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk)\n    );\n\n    // SD Command Master\n    sd_cmd_master cmd_master (\n        .CLK_PAD_IO(sd_clk),\n        .RST_PAD_I(wb_rst_i),\n        .New_CMD(new_cmd),\n        .data_write(data_write),\n        .data_read(data_read),\n        .ARG_REG(argument_reg),\n        .CMD_SET_REG(cmd_setting_reg),\n        .TIMEOUT_REG(time_out_reg),\n        .STATUS_REG(status_reg),\n        .RESP_1_REG(resp_1_reg),\n        .ERR_INT_REG(err_int_reg),\n        .NORMAL_INT_REG(normal_int_reg),\n        .ERR_INT_RST(err_int_reset),\n        .NORMAL_INT_RST(normal_int_reset),\n        .settings(settings),\n        .go_idle_o(go_idle_o),\n        .cmd_out(cmd_out),\n        .req_out(req_out),\n        .ack_out(ack_out),\n        .req_in(req_in),\n        .ack_in(ack_in),\n        .cmd_in(cmd_in),\n        .serial_status(serial_status),\n        .card_detect(card_detect)\n    );\n\n    // SD Command Serial Host\n    sd_cmd_serial_host cmd_serial_host (\n        .SD_CLK_IN(sd_clk),\n        .RST_IN(wb_rst_i),\n        .SETTING_IN(settings),\n        .CMD_IN(cmd_out),\n        .REQ_IN(req_out),\n        .ACK_IN(ack_in),\n        .cmd_dat_i(sd_cmd_dat_i),\n        .CMD_OUT(cmd_in),\n        .ACK_OUT(ack_out),\n        .REQ_OUT(req_in),\n        .STATUS(serial_status),\n        .cmd_oe_o(sd_cmd_oe_o),\n        .cmd_out_o(sd_cmd_out_o),\n        .st_dat_t(st_dat_t)\n    );\n\n    // Additional logic and connections as needed\n    // ...\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 11, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    localparam CMD24 = 16'h181A;\n    localparam CMD17 = 16'h111A;\n    localparam CMD12 = 16'hC1A;\n    localparam ACMD13 = 16'hD1A;\n    localparam ACMD51 = 16'h331A;\n    localparam SIZE = 9;\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n    localparam RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed;\n    reg [2:0] bd_cnt;\n\n    // FSM Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            bd_cnt <= 0;\n        end else begin\n            state <= next_state;\n            if (state == SEND_CMD && we_ack) begin\n                send_done <= 1;\n            end\n            if (state == RECIVE_CMD && !cmd_busy && cmd_tsf_err) begin\n                rec_failed <= 1;\n            end\n            if (state == DATA_TRANSFER && transm_complete && crc_ok) begin\n                trans_done <= 1;\n            end\n            if (state == DATA_TRANSFER && !crc_ok) begin\n                trans_failed <= 1;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state; // Default to hold state\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY) next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full) next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done) next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done) next_state = DATA_TRANSFER;\n                else if (rec_failed) next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) next_state = IDLE;\n                else if (trans_failed) next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(state) begin\n        // Reset all outputs\n        re_s_tx = 0;\n        a_cmp_tx = 0;\n        re_s_rx = 0;\n        a_cmp_rx = 0;\n        we_req = 0;\n        d_write = 0;\n        d_read = 0;\n        start_tx_fifo = 0;\n        start_rx_fifo = 0;\n        ack_transfer = 0;\n        Dat_Int_Status = 0;\n        CIDAT = 0;\n\n        case (state)\n            GET_TX_BD: begin\n                re_s_tx = 1;\n                if (ack_i_s_tx) begin\n                    sys_adr = dat_in_tx;\n                    cmd_arg = dat_in_tx;\n                    start_tx_fifo = 1;\n                    cmd_set = CMD24;\n                    tx_cycle = 1;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx = 1;\n                if (ack_i_s_rx) begin\n                    sys_adr = dat_in_rx;\n                    cmd_arg = dat_in_rx;\n                    start_rx_fifo = 1;\n                    cmd_set = (transfer_type == 2'b00) ? CMD17 : (transfer_type == 2'b01) ? ACMD13 : ACMD51;\n                    rx_cycle = 1;\n                end\n            end\n            SEND_CMD: begin\n                we_req = 1;\n                if (tx_cycle) d_write = 1;\n                if (rx_cycle) d_read = 1;\n            end\n            RECIVE_CMD: begin\n                if (rx_cycle) start_rx_fifo = 1;\n            end\n            DATA_TRANSFER: begin\n                if (tx_cycle && !tx_empt) start_tx_fifo = 1;\n                if (rx_cycle && !rx_full) start_rx_fifo = 1;\n                if (transm_complete) ack_transfer = 1;\n            end\n            STOP_SEND: begin\n                cmd_set = CMD12;\n                we_req = 1;\n            end\n        endcase\n    end\n\n    // Interrupt Status Reset\n    always @(posedge Dat_Int_Status_rst) begin\n        if (Dat_Int_Status_rst) Dat_Int_Status = 0;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM states\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q, Req_internal_in;\n    reg q1, Ack_internal_in;\n\n    // REQ_SYNC and ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            CRC_Check_On <= 0;\n            Delay_Cycler <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n            In_Buff <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 1;\n        end else begin\n            DECODER_ACK <= 0;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = (Write_Read) ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN) begin\n        case (state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                CMD_OUT <= 0;\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS <= 0;\n            end\n            WRITE_WR: begin\n                cmd_oe_o <= 1;\n                CMD_OUT <= In_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n                STATUS[3:0] <= 4'b0001;\n            end\n            WRITE_WO: begin\n                cmd_oe_o <= 1;\n                CMD_OUT <= In_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n                STATUS[3:0] <= 4'b0010;\n            end\n            DLY_WR: begin\n                cmd_oe_o <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS[3:0] <= 4'b0011;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            DLY_WO: begin\n                cmd_oe_o <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS[3:0] <= 4'b0100;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            READ_WR: begin\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                ACK_OUT <= 0;\n                REQ_OUT <= 1;\n                STATUS[3:0] <= 4'b0101;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                cmd_oe_o <= 0;\n                ACK_OUT <= 0;\n                REQ_OUT <= 0;\n                STATUS[3:0] <= 4'b0110;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            ACK_WO: begin\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS[3:0] <= 4'b0111;\n            end\n            ACK_WR: begin\n                ACK_OUT <= 1;\n                REQ_OUT <= 0;\n                STATUS[3:0] <= 4'b1000;\n            end\n        endcase\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 14, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output wire wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire sd_clk;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [31:0] cmd_resp_1;\n    wire [15:0] status_reg;\n    wire [8:0] Bd_Status_reg;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .status_reg(status_reg),\n        .Bd_Status_reg(Bd_Status_reg),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional logic for interrupts and other control signals\n    assign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) != 0;\n    assign int_b = (error_int_status_reg & error_int_signal_enable_reg) != 0;\n    assign int_c = (Bd_isr_reg & Bd_isr_enable_reg) != 0;\n\n    // Clock and reset logic\n    assign sd_clk = (SDC_CLK_SEP) ? sd_clk_i_pad : wb_clk_i;\n    assign sd_clk_o_pad = sd_clk;\n\n    // Master Wishbone Interface Control\n    assign m_wb_adr_o = (start_tx_fifo) ? tx_adr : ((start_rx_fifo) ? rx_adr : 32'b0);\n    assign m_wb_we_o = (start_tx_fifo) ? tx_we : ((start_rx_fifo) ? rx_we : 1'b0);\n    assign m_wb_dat_o = (start_tx_fifo) ? tx_dat : ((start_rx_fifo) ? rx_dat : 32'b0);\n    assign m_wb_cyc_o = (start_tx_fifo || start_rx_fifo);\n    assign m_wb_stb_o = (start_tx_fifo || start_rx_fifo);\n    assign m_wb_cti_o = 3'b000; // Classic cycle\n    assign m_wb_bte_o = 2'b00;  // Linear burst\n\n    // Additional logic for optional IO\n    `ifdef SDC_IRQ_ENABLE\n        assign int_a = 1'b1;\n        assign int_b = 1'b1;\n        assign int_c = 1'b1;\n    `endif\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 12, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // FSM state definitions\n    localparam IDLE          = 9'b000000001;\n    localparam GET_TX_BD     = 9'b000000010;\n    localparam GET_RX_BD     = 9'b000000100;\n    localparam SEND_CMD      = 9'b000001000;\n    localparam RECIVE_CMD    = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP          = 9'b001000000;\n    localparam STOP_SEND     = 9'b010000000;\n\n    // Command definitions\n    localparam CMD24 = 16'h181A; // Write single block\n    localparam CMD17 = 16'h111A; // Read single block\n    localparam CMD12 = 16'hC1A;  // Stop transmission\n    localparam ACMD13 = 16'hD1A; // SD status\n    localparam ACMD51 = 16'h331A; // Read SCR\n\n    // Internal registers\n    reg [8:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed;\n    reg [2:0] bd_cnt; // Adjust size based on RAM_MEM_WIDTH\n\n    // Reset and clock management\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            bd_cnt <= 0;\n            sys_adr <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            ack_transfer <= 0;\n        end else begin\n            state <= next_state;\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n        end\n    end\n\n    // FSM logic\n    always @(*) begin\n        next_state = state; // Default to hold state\n        re_s_tx = 0;\n        a_cmp_tx = 0;\n        re_s_rx = 0;\n        a_cmp_rx = 0;\n        we_req = 0;\n        d_write = 0;\n        d_read = 0;\n        start_tx_fifo = 0;\n        start_rx_fifo = 0;\n        ack_transfer = 0;\n\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY) next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                re_s_tx = 1;\n                if (ack_i_s_tx) begin\n                    sys_adr = dat_in_tx; // Simplified for example\n                    cmd_arg = dat_in_tx; // Simplified for example\n                    cmd_set = CMD24;\n                    next_state = SEND_CMD;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx = 1;\n                if (ack_i_s_rx) begin\n                    sys_adr = dat_in_rx; // Simplified for example\n                    cmd_arg = dat_in_rx; // Simplified for example\n                    cmd_set = CMD17;\n                    next_state = SEND_CMD;\n                end\n            end\n            SEND_CMD: begin\n                if (!cmd_busy) begin\n                    we_req = 1;\n                    if (we_ack) begin\n                        send_done = 1;\n                        next_state = RECIVE_CMD;\n                    end\n                end\n            end\n            RECIVE_CMD: begin\n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) rec_failed = 1;\n                    else rec_done = 1;\n                    next_state = DATA_TRANSFER;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete) begin\n                    trans_done = 1;\n                    next_state = IDLE;\n                end else if (!crc_ok) begin\n                    trans_failed = 1;\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                cmd_set = CMD12;\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (!cmd_busy) begin\n                    we_req = 1;\n                    if (we_ack) send_done = 1;\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 13, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n\n    // Internal Registers\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed;\n    reg [2:0] bd_cnt; // Adjust size based on RAM_MEM_WIDTH\n\n    // State Machine Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            bd_cnt <= 0;\n            Dat_Int_Status <= 0;\n        end else begin\n            state <= next_state;\n            if (state == SEND_CMD && we_ack) begin\n                send_done <= 1;\n            end\n            if (state == RECIVE_CMD && !cmd_busy) begin\n                if (cmd_tsf_err || card_status != 5'b00001) begin\n                    rec_failed <= 1;\n                end else begin\n                    rec_done <= 1;\n                end\n            end\n            if (state == DATA_TRANSFER && transm_complete) begin\n                if (crc_ok) begin\n                    trans_done <= 1;\n                end else begin\n                    trans_failed <= 1;\n                end\n            end\n            if (state == STOP_SEND && send_done) begin\n                resend_try_cnt <= resend_try_cnt + 1;\n            end\n        end\n    end\n\n    // Next State Logic\n    always @(*) begin\n        next_state = state; // Default to hold state\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY) next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && tx_full) next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done) next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done) next_state = DATA_TRANSFER;\n                else if (rec_failed) next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) next_state = IDLE;\n                else if (trans_failed) next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) next_state = IDLE;\n            end\n        end\n    end\n\n    // Output Logic\n    always @(*) begin\n        re_s_tx = (state == GET_TX_BD);\n        re_s_rx = (state == GET_RX_BD);\n        we_req = (state == SEND_CMD && !cmd_busy);\n        d_write = (state == SEND_CMD && tx_cycle);\n        d_read = (state == SEND_CMD && rx_cycle);\n        start_tx_fifo = (state == GET_TX_BD && bd_cnt >= READ_CYCLE - 1);\n        start_rx_fifo = (state == GET_RX_BD && bd_cnt >= READ_CYCLE - 1);\n        ack_transfer = (state == DATA_TRANSFER && trans_done);\n        if (Dat_Int_Status_rst) Dat_Int_Status = 0;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [7:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register addresses\n    localparam ADDR_ARGUMENT           = 8'h00;\n    localparam ADDR_COMMAND_SETTING    = 8'h04;\n    localparam ADDR_CARD_STATUS        = 8'h08;\n    localparam ADDR_RESPONSE           = 8'h0C;\n    localparam ADDR_SOFTWARE_RESET     = 8'h28;\n    localparam ADDR_TIMEOUT            = 8'h2C;\n    localparam ADDR_NORMAL_INT_STATUS  = 8'h30;\n    localparam ADDR_ERROR_INT_STATUS   = 8'h34;\n    localparam ADDR_NORMAL_INT_ENABLE  = 8'h38;\n    localparam ADDR_ERROR_INT_ENABLE   = 8'h3C;\n    localparam ADDR_CLOCK_DIVIDER      = 8'h4C;\n    localparam ADDR_BD_BUFFER_STATUS   = 8'h50;\n    localparam ADDR_DAT_INT_STATUS     = 8'h54;\n    localparam ADDR_DAT_INT_ENABLE     = 8'h58;\n    localparam ADDR_BD_RX              = 8'h60;\n    localparam ADDR_BD_TX              = 8'h80;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1; // Default to high\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the Wishbone transaction\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: argument_reg <= wb_dat_i;\n                    ADDR_COMMAND_SETTING: cmd_setting_reg <= wb_dat_i[15:0];\n                    ADDR_SOFTWARE_RESET: software_reset_reg <= wb_dat_i[7:0];\n                    ADDR_TIMEOUT: time_out_reg <= wb_dat_i[15:0];\n                    ADDR_NORMAL_INT_ENABLE: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_ERROR_INT_ENABLE: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_CLOCK_DIVIDER: clock_divider <= wb_dat_i[7:0];\n                    ADDR_DAT_INT_ENABLE: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    ADDR_BD_RX, ADDR_BD_TX: begin\n                        // Handle block descriptor operations\n                        if (wb_adr_i == ADDR_BD_RX) dat_in_m_rx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        else dat_in_m_tx_bd <= wb_dat_i[RAM_MEM_WIDTH-1:0];\n                        we_m_rx_bd <= 1'b1;\n                        we_m_tx_bd <= 1'b1;\n                        int_ack <= 1'b0; // Start the operation\n                    end\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: wb_dat_o <= argument_reg;\n                    ADDR_COMMAND_SETTING: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    ADDR_CARD_STATUS: wb_dat_o <= {16'b0, status_reg};\n                    ADDR_RESPONSE: wb_dat_o <= cmd_resp_1;\n                    ADDR_SOFTWARE_RESET: wb_dat_o <= {24'b0, software_reset_reg};\n                    ADDR_TIMEOUT: wb_dat_o <= {16'b0, time_out_reg};\n                    ADDR_NORMAL_INT_STATUS: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    ADDR_ERROR_INT_STATUS: wb_dat_o <= {16'b0, error_int_status_reg};\n                    ADDR_NORMAL_INT_ENABLE: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    ADDR_ERROR_INT_ENABLE: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    ADDR_CLOCK_DIVIDER: wb_dat_o <= {24'b0, clock_divider};\n                    ADDR_BD_BUFFER_STATUS: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    ADDR_DAT_INT_STATUS: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    ADDR_DAT_INT_ENABLE: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            int_ack <= 1'b1; // Complete the operation\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input wire sd_clk,\n    input wire rst,\n    input wire [31:0] data_in,\n    input wire [1:0] start_dat,\n    input wire ack_transfer,\n    input wire [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    reg [15:0] crc_out[SD_BUS_W-1:0];\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int, ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // State Definitions\n    localparam IDLE        = 6'b000001;\n    localparam WRITE_DAT   = 6'b000010;\n    localparam WRITE_CRC   = 6'b000100;\n    localparam WRITE_BUSY  = 6'b001000;\n    localparam READ_WAIT   = 6'b010000;\n    localparam READ_DAT    = 6'b100000;\n\n    // Submodule Instances\n    // CRC Generation Block\n    genvar i;\n    generate\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_unit (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[i])\n            );\n        end\n    endgenerate\n\n    // Synchronization of ack_transfer\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM Combo Logic\n    always @(*) begin\n        next_state = state; // Default to hold current state\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b10) next_state = WRITE_DAT;\n                else if (start_dat == 2'b01) next_state = READ_WAIT;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = WRITE_CRC;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111) next_state = WRITE_BUSY;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int) next_state = IDLE;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0]) next_state = READ_DAT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W) next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM Sequential Logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) state <= IDLE;\n        else state <= next_state;\n    end\n\n    // FSM Output Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset all outputs and internal registers\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 7;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            // Normal operation based on state\n            case (state)\n                WRITE_DAT: begin\n                    // Handle data writing logic\n                end\n                WRITE_CRC: begin\n                    // Handle CRC writing logic\n                end\n                WRITE_BUSY: begin\n                    // Handle busy state logic\n                end\n                READ_WAIT: begin\n                    // Handle read wait logic\n                end\n                READ_DAT: begin\n                    // Handle data reading logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 14, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    localparam CMD24 = 16'h181A;\n    localparam CMD17 = 16'h111A;\n    localparam CMD12 = 16'hC1A;\n    localparam ACMD13 = 16'hD1A;\n    localparam ACMD51 = 16'h331A;\n    localparam SIZE = 9;\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n    localparam RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed, internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt;\n\n    // FSM logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state; // Default to hold state\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY && !cmd_busy) next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY && !cmd_busy) next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (ack_i_s_tx && bd_cnt >= READ_CYCLE - 1 && !tx_full) next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (ack_i_s_rx && bd_cnt >= READ_CYCLE - 1) next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done) next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done) next_state = DATA_TRANSFER;\n                else if (rec_failed) next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) next_state = IDLE;\n                else if (trans_failed) next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) next_state = IDLE;\n            end\n        end\n    end\n\n    // Output logic based on state\n    always @(posedge clk) begin\n        if (rst) begin\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            sys_adr <= 0;\n            ack_transfer <= 0;\n            Dat_Int_Status <= 0;\n            CIDAT <= 0;\n        end else begin\n            case (state)\n                GET_TX_BD: begin\n                    re_s_tx <= 1;\n                    sys_adr <= dat_in_tx; // Example assignment\n                    cmd_arg <= dat_in_tx; // Example assignment\n                    cmd_set <= CMD24;\n                end\n                GET_RX_BD: begin\n                    re_s_rx <= 1;\n                    sys_adr <= dat_in_rx; // Example assignment\n                    cmd_arg <= dat_in_rx; // Example assignment\n                    cmd_set <= CMD17;\n                end\n                SEND_CMD: begin\n                    we_req <= 1;\n                    d_write <= tx_cycle;\n                    d_read <= rx_cycle;\n                end\n                RECIVE_CMD: begin\n                    start_rx_fifo <= rx_cycle;\n                end\n                DATA_TRANSFER: begin\n                    start_tx_fifo <= tx_cycle;\n                    ack_transfer <= transm_complete;\n                end\n                STOP_SEND: begin\n                    cmd_set <= CMD12;\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 15, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire clk;\n    wire rst;\n    wire [31:0] dat_i;\n    wire [31:0] dat_o;\n    wire [7:0] adr_i;\n    wire we_i;\n    wire cyc_i;\n    wire stb_i;\n    reg ack_o;\n    wire [31:0] m_adr_o;\n    wire m_sel_o;\n    wire m_we_o;\n    wire [31:0] m_dat_o;\n    wire [31:0] m_dat_i;\n    wire m_cyc_o;\n    wire m_stb_o;\n    wire m_ack_i;\n    wire m_cti_o;\n    wire m_bte_o;\n    wire card_det;\n    wire cmd_dat_i;\n    wire cmd_out_o;\n    wire cmd_oe_o;\n    wire [3:0] dat_dat_i;\n    wire [3:0] dat_out_o;\n    wire dat_oe_o;\n    wire clk_o_pad;\n    wire clk_i_pad;\n    wire int_a_o;\n    wire int_b_o;\n    wire int_c_o;\n\n    // Assignments\n    assign clk = wb_clk_i;\n    assign rst = wb_rst_i;\n    assign dat_i = wb_dat_i;\n    assign adr_i = wb_adr_i[7:0];\n    assign we_i = wb_we_i;\n    assign cyc_i = wb_cyc_i;\n    assign stb_i = wb_stb_i;\n    assign m_adr_o = m_wb_adr_o;\n    assign m_sel_o = m_wb_sel_o;\n    assign m_we_o = m_wb_we_o;\n    assign m_dat_o = m_wb_dat_o;\n    assign m_dat_i = m_wb_dat_i;\n    assign m_cyc_o = m_wb_cyc_o;\n    assign m_stb_o = m_wb_stb_o;\n    assign m_ack_i = m_wb_ack_i;\n    assign m_cti_o = m_wb_cti_o;\n    assign m_bte_o = m_wb_bte_o;\n    assign card_det = card_detect;\n    assign cmd_dat_i = sd_cmd_dat_i;\n    assign cmd_out_o = sd_cmd_out_o;\n    assign cmd_oe_o = sd_cmd_oe_o;\n    assign dat_dat_i = sd_dat_dat_i;\n    assign dat_out_o = sd_dat_out_o;\n    assign dat_oe_o = sd_dat_oe_o;\n    assign clk_o_pad = sd_clk_o_pad;\n    assign clk_i_pad = sd_clk_i_pad;\n    assign int_a_o = int_a;\n    assign int_b_o = int_b;\n    assign int_c_o = int_c;\n\n    // Wishbone slave interface\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n        end else begin\n            wb_ack_o <= 1'b0;\n            if (cyc_i && stb_i && !ack_o) begin\n                wb_ack_o <= 1'b1;\n                if (we_i) begin\n                    // Write operation\n                    case (adr_i)\n                        // Address decoding for write operations\n                        default: ;\n                    endcase\n                end else begin\n                    // Read operation\n                    case (adr_i)\n                        // Address decoding for read operations\n                        default: wb_dat_o <= 32'b0;\n                    endcase\n                end\n            end\n        end\n    end\n\n    // Master Wishbone interface control logic\n    assign m_wb_adr_o = 32'b0; // Example assignment\n    assign m_wb_sel_o = 1'b1;\n    assign m_wb_we_o = 1'b0;\n    assign m_wb_dat_o = 32'b0;\n    assign m_wb_cyc_o = 1'b0;\n    assign m_wb_stb_o = 1'b0;\n    assign m_wb_cti_o = 3'b000;\n    assign m_wb_bte_o = 2'b00;\n\n    // Additional logic for interrupts, clock generation, etc., can be added here\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_serial_host", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_serial_host (\n    input sd_clk,\n    input rst,\n    input [31:0] data_in,\n    input [1:0] start_dat,\n    input ack_transfer,\n    input [SD_BUS_W-1:0] DAT_dat_i,\n    output reg rd,\n    output reg [SD_BUS_W-1:0] data_out,\n    output reg we,\n    output reg DAT_oe_o,\n    output reg [SD_BUS_W-1:0] DAT_dat_o,\n    output reg busy_n,\n    output reg transm_complete,\n    output reg crc_ok\n);\n\n    // Internal Registers\n    reg [SD_BUS_W-1:0] crc_in;\n    reg crc_en;\n    reg crc_rst;\n    wire [15:0] crc_out[SD_BUS_W-1:0];\n    reg [SD_BUS_W-1:0] temp_in;\n    reg [10:0] transf_cnt;\n    reg [5:0] state, next_state;\n    reg [2:0] crc_status;\n    reg busy_int;\n    reg ack_transfer_int;\n    reg ack_q;\n    reg q_start_bit;\n    reg [4:0] crc_c;\n    reg [3:0] last_din;\n    reg [2:0] crc_s;\n    reg [31:0] write_buf_0, write_buf_1;\n    reg [31:0] sd_data_out;\n    reg out_buff_ptr, in_buff_ptr;\n    reg [2:0] data_send_index;\n\n    // State Definitions\n    localparam IDLE = 6'b000001;\n    localparam WRITE_DAT = 6'b000010;\n    localparam WRITE_CRC = 6'b000100;\n    localparam WRITE_BUSY = 6'b001000;\n    localparam READ_WAIT = 6'b010000;\n    localparam READ_DAT = 6'b100000;\n\n    // CRC Generation Block\n    genvar i;\n    generate\n        for (i = 0; i < SD_BUS_W; i = i + 1) begin : crc_gen\n            sd_crc_16 crc_module (\n                .BITVAL(crc_in[i]),\n                .Enable(crc_en),\n                .CLK(sd_clk),\n                .RST(crc_rst),\n                .CRC(crc_out[i])\n            );\n        end\n    endgenerate\n\n    // ACK Synchronization\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            ack_q <= 0;\n            ack_transfer_int <= 0;\n        end else begin\n            ack_q <= ack_transfer;\n            ack_transfer_int <= ack_q;\n        end\n    end\n\n    // FSM_COMBO Logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (start_dat == 2'b01)\n                    next_state = READ_WAIT;\n                else if (start_dat == 2'b10)\n                    next_state = WRITE_DAT;\n                else\n                    next_state = IDLE;\n            end\n            WRITE_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = WRITE_CRC;\n                else\n                    next_state = WRITE_DAT;\n            end\n            WRITE_CRC: begin\n                if (crc_status == 3'b111)\n                    next_state = WRITE_BUSY;\n                else\n                    next_state = WRITE_CRC;\n            end\n            WRITE_BUSY: begin\n                if (!busy_int)\n                    next_state = IDLE;\n                else\n                    next_state = WRITE_BUSY;\n            end\n            READ_WAIT: begin\n                if (!DAT_dat_i[0])\n                    next_state = READ_DAT;\n                else\n                    next_state = READ_WAIT;\n            end\n            READ_DAT: begin\n                if (transf_cnt == SD_BUS_W)\n                    next_state = IDLE;\n                else\n                    next_state = READ_DAT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // FSM_SEQ Logic\n    always @(posedge sd_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT Logic\n    always @(posedge sd_clk) begin\n        if (rst) begin\n            // Reset all outputs and internal registers\n            write_buf_0 <= 0;\n            write_buf_1 <= 0;\n            DAT_oe_o <= 0;\n            crc_en <= 0;\n            crc_rst <= 1;\n            transf_cnt <= 0;\n            rd <= 0;\n            last_din <= 0;\n            crc_c <= 0;\n            crc_in <= 0;\n            DAT_dat_o <= 0;\n            crc_status <= 3'b111;\n            crc_s <= 0;\n            transm_complete <= 0;\n            busy_n <= 1;\n            we <= 0;\n            data_out <= 0;\n            crc_ok <= 0;\n            busy_int <= 0;\n            data_send_index <= 0;\n            out_buff_ptr <= 0;\n            in_buff_ptr <= 0;\n        end else begin\n            case (state)\n                WRITE_DAT: begin\n                    // Implement WRITE_DAT logic\n                end\n                WRITE_CRC: begin\n                    // Implement WRITE_CRC logic\n                end\n                WRITE_BUSY: begin\n                    // Implement WRITE_BUSY logic\n                end\n                READ_WAIT: begin\n                    // Implement READ_WAIT logic\n                end\n                READ_DAT: begin\n                    // Implement READ_DAT logic\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 16, "code": "module sdc_controller (\n    // Wishbone Slave Interface\n    input wb_clk_i,\n    input wb_rst_i,\n    input [3:0] wb_sel_i,\n    input [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input [7:0] wb_adr_i,\n    input wb_we_i,\n    input wb_cyc_i,\n    input wb_stb_i,\n    output reg wb_ack_o,\n\n    // Master Wishbone Interface\n    output [31:0] m_wb_adr_o,\n    output m_wb_sel_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output [2:0] m_wb_cti_o,\n    output [1:0] m_wb_bte_o,\n\n    // SDC IO\n    input sd_cmd_dat_i,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input [3:0] sd_dat_dat_i,\n    output [3:0] sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_clk_o_pad,\n    input sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c,\n\n    // Optional IO\n    input card_detect\n);\n\n// Optional features based on definitions\n`ifdef SDC_IRQ_ENABLE\n    assign int_a = (normal_int_status_reg & normal_int_signal_enable_reg) != 0;\n    assign int_b = (error_int_status_reg & error_int_signal_enable_reg) != 0;\n    assign int_c = (Bd_isr_reg & Bd_isr_enable_reg) != 0;\n`endif\n\n// Internal signals\nreg [31:0] argument_reg;\nreg [15:0] cmd_setting_reg;\nreg [15:0] normal_int_status_reg;\nreg [15:0] error_int_status_reg;\nreg [7:0] software_reset_reg;\nreg [15:0] time_out_reg;\nreg [7:0] clock_divider;\nreg [7:0] Bd_isr_reg;\nreg [7:0] Bd_isr_enable_reg;\nreg [15:0] normal_int_signal_enable_reg;\nreg [15:0] error_int_signal_enable_reg;\n\n// Clock and reset\nwire internal_reset;\nassign internal_reset = wb_rst_i | software_reset_reg[0];\n\n// Wishbone slave interface logic\nalways @(posedge wb_clk_i or posedge internal_reset) begin\n    if (internal_reset) begin\n        wb_ack_o <= 1'b0;\n        wb_dat_o <= 32'b0;\n    end else begin\n        wb_ack_o <= wb_cyc_i & wb_stb_i & ~wb_ack_o; // Simple handshake\n        if (wb_we_i & wb_ack_o) begin\n            // Handle writes to registers\n            case (wb_adr_i)\n                8'h00: argument_reg <= wb_dat_i;\n                8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                8'h08: time_out_reg <= wb_dat_i[15:0];\n                8'h0C: software_reset_reg <= wb_dat_i[7:0];\n                8'h10: clock_divider <= wb_dat_i[7:0];\n                8'h14: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h18: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h1C: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                // Add more registers as needed\n            endcase\n        end else if (~wb_we_i & wb_ack_o) begin\n            // Handle reads from registers\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= argument_reg;\n                8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                8'h08: wb_dat_o <= {16'b0, time_out_reg};\n                8'h0C: wb_dat_o <= {24'b0, software_reset_reg};\n                8'h10: wb_dat_o <= {24'b0, clock_divider};\n                8'h14: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                8'h18: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                8'h1C: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                // Add more registers as needed\n            endcase\n        end\n    end\nend\n\n// Master Wishbone Interface\n// Assuming some control logic to generate these signals\nassign m_wb_adr_o = ...;\nassign m_wb_sel_o = 4'b1111; // Assuming all bytes are always valid\nassign m_wb_we_o = ...;\nassign m_wb_dat_o = ...;\nassign m_wb_cyc_o = ...;\nassign m_wb_stb_o = ...;\nassign m_wb_cti_o = ...;\nassign m_wb_bte_o = ...;\n\n// SDC IO logic\n// Assuming some control logic to generate these signals\nassign sd_cmd_out_o = ...;\nassign sd_cmd_oe_o = ...;\nassign sd_dat_out_o = ...;\nassign sd_dat_oe_o = ...;\nassign sd_clk_o_pad = ...;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [8:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register definitions based on address\n    always @(posedge wb_clk_i or posedge wb_rst_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1; // Default to high\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 8'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i & wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the Wishbone transaction\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    8'h00: argument_reg <= wb_dat_i;\n                    8'h04: cmd_setting_reg <= wb_dat_i[15:0];\n                    8'h28: software_reset_reg <= wb_dat_i[7:0];\n                    8'h2c: time_out_reg <= wb_dat_i[15:0];\n                    8'h38: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h3c: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    8'h4c: clock_divider <= wb_dat_i[7:0];\n                    8'h58: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    // Handle other addresses and potentially complex operations\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    8'h00: wb_dat_o <= argument_reg;\n                    8'h04: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    8'h08: wb_dat_o <= {16'b0, status_reg};\n                    8'h0c: wb_dat_o <= cmd_resp_1;\n                    8'h28: wb_dat_o <= {24'b0, software_reset_reg};\n                    8'h2c: wb_dat_o <= {16'b0, time_out_reg};\n                    8'h30: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    8'h34: wb_dat_o <= {16'b0, error_int_status_reg};\n                    8'h38: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    8'h3c: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    8'h4c: wb_dat_o <= {24'b0, clock_divider};\n                    8'h50: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    8'h54: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    8'h58: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    // Handle other addresses\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0; // De-assert ack when not in a valid cycle\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 17, "code": "module sdc_controller (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [3:0] wb_sel_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output wire [31:0] m_wb_adr_o,\n    output wire m_wb_sel_o,\n    output wire m_wb_we_o,\n    output wire [31:0] m_wb_dat_o,\n    input wire [31:0] m_wb_dat_i,\n    output wire m_wb_cyc_o,\n    output wire m_wb_stb_o,\n    input wire m_wb_ack_i,\n    output wire m_wb_cti_o,\n    output wire m_wb_bte_o,\n    input wire card_detect,\n    input wire sd_cmd_dat_i,\n    output wire sd_cmd_out_o,\n    output wire sd_cmd_oe_o,\n    input wire [3:0] sd_dat_dat_i,\n    output wire [3:0] sd_dat_out_o,\n    output wire sd_dat_oe_o,\n    output wire sd_clk_o_pad,\n    input wire sd_clk_i_pad,\n    output wire int_a,\n    output wire int_b,\n    output wire int_c\n);\n\n    // Internal signals\n    wire sd_clk;\n    wire reset;\n    wire [31:0] command_argument;\n    wire [15:0] command_settings;\n    wire [15:0] status_register;\n    wire [31:0] response_register;\n    wire [15:0] error_interrupt_status;\n    wire [15:0] normal_interrupt_status;\n    wire [15:0] error_interrupt_enable;\n    wire [15:0] normal_interrupt_enable;\n    wire [7:0] clock_divider;\n    wire [15:0] timeout_register;\n    wire [7:0] software_reset_register;\n    wire [15:0] bd_status_register;\n    wire [7:0] bd_isr_register;\n    wire [7:0] bd_isr_enable_register;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n\n    // Assignments for outputs\n    assign m_wb_sel_o = 1'b1; // Assuming always selecting all data width\n    assign m_wb_we_o = wb_we_i;\n    assign m_wb_adr_o = wb_adr_i;\n    assign m_wb_dat_o = wb_dat_i;\n    assign m_wb_cyc_o = wb_cyc_i;\n    assign m_wb_stb_o = wb_stb_i;\n    assign m_wb_cti_o = 3'b000; // Classic cycle\n    assign m_wb_bte_o = 2'b00; // Linear burst\n\n    // Clock and reset logic\n    assign sd_clk = (SD_CLK_SEP) ? sd_clk_i_pad : wb_clk_i;\n    assign reset = wb_rst_i | (software_reset_register[0]);\n\n    // Module instantiations\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(reset),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional modules would be instantiated here following similar pattern\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 15, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    localparam CMD24 = 16'h181A;\n    localparam CMD17 = 16'h111A;\n    localparam CMD12 = 16'hC1A;\n    localparam ACMD13 = 16'hD1A;\n    localparam ACMD51 = 16'h331A;\n    localparam SIZE = 9;\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n    localparam RESEND_MAX_CNT = 3;\n\n    // Internal Signals\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, trans_done, trans_failed;\n    reg tx_cycle, rx_cycle;\n\n    // FSM Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n        end else begin\n            state <= next_state;\n            if (state == SEND_CMD && send_done)\n                resend_try_cnt <= 0;\n            else if (state == STOP_SEND && !send_done)\n                resend_try_cnt <= resend_try_cnt + 1;\n        end\n    end\n\n    // Next State Logic\n    always @(*) begin\n        next_state = state; // Default to hold state\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY)\n                    next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY)\n                    next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (ack_i_s_tx && !tx_full)\n                    next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (ack_i_s_rx && !rx_full)\n                    next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done)\n                    next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done)\n                    next_state = DATA_TRANSFER;\n                else if (rec_failed)\n                    next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done)\n                    next_state = IDLE;\n                else if (trans_failed)\n                    next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output Logic\n    always @(*) begin\n        // Reset all outputs\n        re_s_tx = 0;\n        a_cmp_tx = 0;\n        re_s_rx = 0;\n        a_cmp_rx = 0;\n        we_req = 0;\n        d_write = 0;\n        d_read = 0;\n        cmd_arg = 0;\n        cmd_set = 0;\n        start_tx_fifo = 0;\n        start_rx_fifo = 0;\n        sys_adr = 0;\n        ack_transfer = 0;\n        Dat_Int_Status = 0;\n        CIDAT = 0;\n\n        case (state)\n            GET_TX_BD: begin\n                re_s_tx = 1;\n                if (ack_i_s_tx) begin\n                    sys_adr = dat_in_tx;\n                    cmd_arg = dat_in_tx;\n                    start_tx_fifo = 1;\n                    cmd_set = CMD24;\n                    tx_cycle = 1;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx = 1;\n                if (ack_i_s_rx) begin\n                    sys_adr = dat_in_rx;\n                    cmd_arg = dat_in_rx;\n                    start_rx_fifo = 1;\n                    cmd_set = CMD17;\n                    rx_cycle = 1;\n                end\n            end\n            SEND_CMD: begin\n                if (!cmd_busy) begin\n                    we_req = 1;\n                    if (we_ack) begin\n                        if (tx_cycle)\n                            d_write = 1;\n                        else if (rx_cycle)\n                            d_read = 1;\n                        send_done = 1;\n                    end\n                end\n            end\n            RECIVE_CMD: begin\n                if (!cmd_busy) begin\n                    if (cmd_tsf_err)\n                        rec_failed = 1;\n                    else\n                        rec_done = 1;\n                end\n            end\n            DATA_TRANSFER: begin\n                if (transm_complete && crc_ok) begin\n                    if (tx_cycle)\n                        a_cmp_tx = 1;\n                    else if (rx_cycle)\n                        a_cmp_rx = 1;\n                    trans_done = 1;\n                end else if (!crc_ok) {\n                    trans_failed = 1;\n                end\n            end\n            STOP_SEND: begin\n                if (!cmd_busy) begin\n                    we_req = 1;\n                    if (we_ack) {\n                        cmd_set = CMD12;\n                        send_done = 1;\n                    end\n                end\n            end\n        endcase\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, trans_done, trans_failed;\n    reg tx_cycle, rx_cycle;\n    reg [2:0] bd_cnt; // Adjust size based on RAM_MEM_WIDTH\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            bd_cnt <= 0;\n            Dat_Int_Status <= 0;\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            ack_transfer <= 0;\n            CIDAT <= 0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    if (free_tx_bd != BD_EMPTY && !tx_full) begin\n                        next_state <= GET_TX_BD;\n                        tx_cycle <= 1;\n                        rx_cycle <= 0;\n                    end else if (free_rx_bd != BD_EMPTY && !rx_full) begin\n                        next_state <= GET_RX_BD;\n                        rx_cycle <= 1;\n                        tx_cycle <= 0;\n                    end\n                end\n                GET_TX_BD: begin\n                    if (ack_i_s_tx) begin\n                        sys_adr <= dat_in_tx; // Simplified for example\n                        cmd_arg <= dat_in_tx; // Simplified for example\n                        next_state <= SEND_CMD;\n                        cmd_set <= CMD24; // Assume CMD24 for write\n                    end\n                end\n                GET_RX_BD: begin\n                    if (ack_i_s_rx) begin\n                        sys_adr <= dat_in_rx; // Simplified for example\n                        cmd_arg <= dat_in_rx; // Simplified for example\n                        next_state <= SEND_CMD;\n                        cmd_set <= CMD17; // Assume CMD17 for read\n                    end\n                end\n                SEND_CMD: begin\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                            next_state <= RECIVE_CMD;\n                        end\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (!cmd_busy && cmd_tsf_err) begin\n                        rec_failed <= 1;\n                        next_state <= SEND_CMD;\n                    end else if (!cmd_busy) begin\n                        rec_done <= 1;\n                        next_state <= DATA_TRANSFER;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (transm_complete && crc_ok) begin\n                        trans_done <= 1;\n                        next_state <= IDLE;\n                    end else if (!transm_complete || !crc_ok) begin\n                        trans_failed <= 1;\n                        next_state <= STOP;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12; // Stop command\n                    next_state <= STOP_SEND;\n                end\n                STOP_SEND: begin\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                            next_state <= IDLE;\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 16, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // State definitions\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff;\n    reg [39:0] Out_Buff;\n    reg Write_Read;\n    reg Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST;\n    reg [6:0] CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable;\n    reg CRC_OUT;\n    reg CRC_Check_On;\n    reg Crc_Buffering;\n    reg CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg block_write;\n    reg block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK;\n    reg DECODER_ACK;\n    reg q, Req_internal_in;\n    reg q1, Ack_internal_in;\n\n    // REQ_SYNC and ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            In_Buff <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = Write_Read ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN) begin\n        case (state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                Cmd_Cnt <= 0;\n                Delay_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                st_dat_t <= 0;\n                word_select_counter <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[Cmd_Cnt];\n                        if (Cmd_Cnt > 9) CRC_OUT <= CRC_VAL[Cmd_Cnt - 10];\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_VAL[Cmd_Cnt - 2];\n                        st_dat_t <= {block_read, block_write};\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[Cmd_Cnt];\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= In_Buff[Cmd_Cnt];\n                    if (Cmd_Cnt > 8) CRC_OUT <= CRC_VAL[Cmd_Cnt - 9];\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[Cmd_Cnt];\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN[Cmd_Cnt - Response_Size] <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    st_dat_t <= {block_read, block_write};\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\n\n    // CRC module instantiation\n    sd_crc_7 crc_module (\n        .BITVAL(CRC_IN),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    parameter CMD24 = 16'h181A;\n    parameter CMD17 = 16'h111A;\n    parameter CMD12 = 16'hC1A;\n    parameter ACMD13 = 16'hD1A;\n    parameter ACMD51 = 16'h331A;\n    parameter SIZE = 9;\n    parameter IDLE = 9'b000000001;\n    parameter GET_TX_BD = 9'b000000010;\n    parameter GET_RX_BD = 9'b000000100;\n    parameter SEND_CMD = 9'b000001000;\n    parameter RECIVE_CMD = 9'b000010000;\n    parameter DATA_TRANSFER = 9'b000100000;\n    parameter STOP = 9'b001000000;\n    parameter STOP_SEND = 9'b010000000;\n    parameter RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed, internal_transm_complete;\n    reg [2:0] bd_cnt;\n\n    // State Machine Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            bd_cnt <= 0;\n            Dat_Int_Status <= 0;\n        end else begin\n            state <= next_state;\n            if (state == SEND_CMD && we_ack) begin\n                send_done <= 1;\n            end\n            if (state == RECIVE_CMD && !cmd_busy) begin\n                if (cmd_tsf_err || card_status[0] == 0) begin\n                    rec_failed <= 1;\n                end else begin\n                    rec_done <= 1;\n                end\n            end\n            if (state == DATA_TRANSFER && transm_complete) begin\n                if (crc_ok) begin\n                    trans_done <= 1;\n                end else begin\n                    trans_failed <= 1;\n                end\n            end\n            if (state == STOP_SEND && send_done) begin\n                resend_try_cnt <= resend_try_cnt + 1;\n                if (resend_try_cnt >= RESEND_MAX_CNT) begin\n                    Dat_Int_Status[1] <= 1; // Error status\n                end\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state; // Default to hold current state\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY) next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt > READ_CYCLE - 1 && tx_full) next_state = SEND_CMD;\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1) next_state = SEND_CMD;\n            end\n            SEND_CMD: begin\n                if (send_done) next_state = RECIVE_CMD;\n            end\n            RECIVE_CMD: begin\n                if (rec_done) next_state = DATA_TRANSFER;\n                else if (rec_failed) next_state = SEND_CMD;\n            end\n            DATA_TRANSFER: begin\n                if (trans_done) next_state = IDLE;\n                else if (trans_failed) next_state = STOP;\n            end\n            STOP: begin\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (send_done) next_state = IDLE;\n            end\n        end\n    end\n\n    // Output logic\n    always @(state) begin\n        re_s_tx = 0;\n        a_cmp_tx = 0;\n        re_s_rx = 0;\n        a_cmp_rx = 0;\n        we_req = 0;\n        d_write = 0;\n        d_read = 0;\n        start_tx_fifo = 0;\n        start_rx_fifo = 0;\n        ack_transfer = 0;\n        CIDAT = 0;\n\n        case (state)\n            GET_TX_BD: begin\n                re_s_tx = 1;\n                if (ack_i_s_tx) begin\n                    sys_adr = dat_in_tx;\n                    cmd_arg = dat_in_tx;\n                    start_tx_fifo = 1;\n                    cmd_set = CMD24;\n                    tx_cycle = 1;\n                end\n            end\n            GET_RX_BD: begin\n                re_s_rx = 1;\n                if (ack_i_s_rx) begin\n                    sys_adr = dat_in_rx;\n                    cmd_arg = dat_in_rx;\n                    start_rx_fifo = 1;\n                    cmd_set = CMD17;\n                    rx_cycle = 1;\n                end\n            end\n            SEND_CMD: begin\n                if (tx_cycle) d_write = 1;\n                if (rx_cycle) d_read = 1;\n                we_req = 1;\n            end\n            DATA_TRANSFER: begin\n                if (tx_cycle && !tx_empt) start_tx_fifo = 1;\n                if (rx_cycle && !rx_full) start_rx_fifo = 1;\n                if (transm_complete) ack_transfer = 1;\n            end\n            STOP_SEND: begin\n                cmd_set = CMD12;\n                we_req = 1;\n            end\n        end\n    end\n\n    // Reset Dat_Int_Status\n    always @(posedge Dat_Int_Status_rst) begin\n        Dat_Int_Status <= 0;\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 17, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM states\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_Enable, CRC_OUT, CRC_Check_On, Crc_Buffering, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in, q1, Ack_internal_in;\n\n    // Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // FSM_COMBO logic\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = Write_Read ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // COMMAND_DECODER logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 1;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                end\n                WRITE_WR, WRITE_WO: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= In_Buff[39 - Cmd_Cnt];\n                    CMD_OUT <= In_Buff;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_WR, DLY_WO: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                READ_WR: begin\n                    cmd_oe_o <= 0;\n                    Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                DLY_READ: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WR, ACK_WO: begin\n                    ACK_OUT <= 0;\n                end\n                default: begin\n                    cmd_oe_o <= 0;\n                    cmd_out_o <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 18, "code": "module sdc_controller (\n    input wb_clk_i,\n    input wb_rst_i,\n    input [3:0] wb_sel_i,\n    input [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input [7:0] wb_adr_i,\n    input wb_we_i,\n    input wb_cyc_i,\n    input wb_stb_i,\n    output reg wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output m_wb_sel_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output m_wb_cti_o,\n    output m_wb_bte_o,\n    input card_detect,\n    input sd_cmd_dat_i,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input [3:0] sd_dat_dat_i,\n    output [3:0] sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_clk_o_pad,\n    input sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c\n);\n\n    // Internal signals\n    wire sd_clk;\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [31:0] cmd_resp_1;\n    wire [15:0] status_reg;\n    wire [7:0] clock_divider;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [15:0] Bd_Status_reg;\n\n    // Instantiate sub-modules here\n    // Example instantiation for sd_controller_wb\n    sd_controller_wb sd_controller_wb_inst (\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Additional sub-modules should be instantiated similarly\n\n    // Logic for interrupts and other outputs\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n\n    // Clock and reset logic\n    assign sd_clk = (SDC_CLK_SEP) ? sd_clk_i_pad : wb_clk_i;\n    assign sd_clk_o_pad = sd_clk;\n\n    // Master Wishbone Interface Control\n    assign m_wb_adr_o = (start_tx_fifo) ? /* address from tx module */ :\n                        (start_rx_fifo) ? /* address from rx module */ : 32'b0;\n    assign m_wb_we_o = (start_tx_fifo || start_rx_fifo) ? 1'b1 : 1'b0;\n    assign m_wb_dat_o = (start_tx_fifo) ? /* data from tx module */ :\n                        (start_rx_fifo) ? /* data from rx module */ : 32'b0;\n    assign m_wb_cyc_o = (start_tx_fifo || start_rx_fifo) ? 1'b1 : 1'b0;\n    assign m_wb_stb_o = (start_tx_fifo || start_rx_fifo) ? 1'b1 : 1'b0;\n    assign m_wb_cti_o = 3'b000; // Classic cycle\n    assign m_wb_bte_o = 2'b00;  // Linear burst\n\n    // Additional logic as required for data handling, state machines, etc.\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    localparam CMD24 = 16'h181A;\n    localparam CMD17 = 16'h111A;\n    localparam CMD12 = 16'hC1A;\n    localparam ACMD13 = 16'hD1A;\n    localparam ACMD51 = 16'h331A;\n    localparam SIZE = 9;\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n    localparam RESEND_MAX_CNT = 3;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [2:0] resend_try_cnt;\n    reg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed;\n    reg internal_transm_complete, transm_complete_q;\n    reg [2:0] bd_cnt; // Adjust size based on RAM_MEM_WIDTH\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n            sys_adr <= 0;\n            cmd_arg <= 0;\n            cmd_set <= 0;\n            CIDAT <= 0;\n            Dat_Int_Status <= 0;\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            ack_transfer <= 0;\n        end else begin\n            state <= next_state;\n            transm_complete_q <= transm_complete;\n            if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n            if (transm_complete && !transm_complete_q) internal_transm_complete <= 1;\n        end\n    end\n\n    always @(*) begin\n        next_state = state; // Default to hold state\n        re_s_tx = 0;\n        a_cmp_tx = 0;\n        re_s_rx = 0;\n        a_cmp_rx = 0;\n        we_req = 0;\n        d_write = 0;\n        d_read = 0;\n        start_tx_fifo = 0;\n        start_rx_fifo = 0;\n        ack_transfer = 0;\n        CIDAT = 0;\n\n        case (state)\n            IDLE: begin\n                if (free_tx_bd != BD_EMPTY) next_state = GET_TX_BD;\n                else if (free_rx_bd != BD_EMPTY) next_state = GET_RX_BD;\n            end\n            GET_TX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && !tx_full) begin\n                    re_s_tx = 1;\n                    if (ack_i_s_tx) begin\n                        sys_adr = dat_in_tx; // Simplified for example\n                        cmd_arg = dat_in_tx; // Simplified for example\n                        cmd_set = CMD24;\n                        start_tx_fifo = 1;\n                        tx_cycle = 1;\n                        next_state = SEND_CMD;\n                    end\n                end else begin\n                    bd_cnt = bd_cnt + 1;\n                end\n            end\n            GET_RX_BD: begin\n                if (bd_cnt >= READ_CYCLE - 1 && !rx_full) begin\n                    re_s_rx = 1;\n                    if (ack_i_s_rx) begin\n                        sys_adr = dat_in_rx; // Simplified for example\n                        cmd_arg = dat_in_rx; // Simplified for example\n                        cmd_set = CMD17;\n                        start_rx_fifo = 1;\n                        rx_cycle = 1;\n                        next_state = SEND_CMD;\n                    end\n                end else begin\n                    bd_cnt = bd_cnt + 1;\n                end\n            end\n            SEND_CMD: begin\n                if (!cmd_busy) begin\n                    we_req = 1;\n                    if (we_ack) begin\n                        if (tx_cycle) d_write = 1;\n                        if (rx_cycle) d_read = 1;\n                        send_done = 1;\n                        next_state = RECIVE_CMD;\n                    end\n                end\n            end\n            RECIVE_CMD: begin\n                if (!cmd_busy) begin\n                    if (cmd_tsf_err) rec_failed = 1;\n                    else rec_done = 1;\n                    if (card_status[0] && (card_status[4:1] == 4 || card_status[4:1] == 5 || card_status[4:1] == 6)) begin\n                        next_state = DATA_TRANSFER;\n                    end else begin\n                        next_state = SEND_CMD; // Retry sending command\n                    end\n                end\n            end\n            DATA_TRANSFER: begin\n                if (internal_transm_complete) begin\n                    if (crc_ok) begin\n                        trans_done = 1;\n                        ack_transfer = 1;\n                        if (tx_cycle) a_cmp_tx = 1;\n                        if (rx_cycle) a_cmp_rx = 1;\n                        next_state = IDLE;\n                    end else begin\n                        trans_failed = 1;\n                        next_state = STOP;\n                    end\n                end\n            end\n            STOP: begin\n                cmd_set = CMD12;\n                next_state = STOP_SEND;\n            end\n            STOP_SEND: begin\n                if (!cmd_busy) begin\n                    we_req = 1;\n                    if (we_ack) begin\n                        send_done = 1;\n                        next_state = IDLE;\n                    end\n                end\n            end\n        endcase\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 19, "code": "module sdc_controller (\n    input wb_clk_i,\n    input wb_rst_i,\n    input [3:0] wb_sel_i,\n    input [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input [7:0] wb_adr_i,\n    input wb_we_i,\n    input wb_cyc_i,\n    input wb_stb_i,\n    output reg wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output m_wb_sel_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output m_wb_cti_o,\n    output m_wb_bte_o,\n    input card_detect,\n    input sd_cmd_dat_i,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input [3:0] sd_dat_dat_i,\n    output [3:0] sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_clk_o_pad,\n    input sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c\n);\n\n// Internal signals\nreg [31:0] command_reg;\nreg [31:0] response_reg;\nreg [15:0] status_reg;\nreg [15:0] error_int_status_reg;\nreg [15:0] normal_int_status_reg;\nreg [15:0] bd_isr_reg;\nreg [15:0] bd_isr_enable_reg;\nreg [15:0] normal_int_signal_enable_reg;\nreg [15:0] error_int_signal_enable_reg;\nreg cmd_busy;\nreg [31:0] argument_reg;\nreg [15:0] cmd_setting_reg;\nreg [7:0] software_reset_reg;\nreg [15:0] time_out_reg;\nreg [7:0] clock_divider;\nreg [15:0] bd_status_reg;\nreg [7:0] bd_isr_reset;\nreg [7:0] normal_isr_reset;\nreg [7:0] error_isr_reset;\nreg [31:0] dat_in_m_tx_bd;\nreg [31:0] dat_in_m_rx_bd;\n\n// Wishbone slave interface\nalways @(posedge wb_clk_i or posedge wb_rst_i) begin\n    if (wb_rst_i) begin\n        wb_ack_o <= 1'b0;\n        wb_dat_o <= 32'b0;\n    end else if (wb_cyc_i && wb_stb_i && !wb_ack_o) begin\n        wb_ack_o <= 1'b1; // Acknowledge the request\n        if (wb_we_i) begin\n            // Write operation\n            case (wb_adr_i)\n                8'h00: command_reg <= wb_dat_i;\n                8'h04: argument_reg <= wb_dat_i;\n                8'h08: cmd_setting_reg <= wb_dat_i[15:0];\n                8'h0C: software_reset_reg <= wb_dat_i[7:0];\n                8'h10: time_out_reg <= wb_dat_i[15:0];\n                8'h14: clock_divider <= wb_dat_i[7:0];\n                8'h18: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h1C: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                8'h20: bd_isr_reset <= wb_dat_i[7:0];\n                8'h24: normal_isr_reset <= wb_dat_i[7:0];\n                8'h28: error_isr_reset <= wb_dat_i[7:0];\n                8'h2C: dat_in_m_tx_bd <= wb_dat_i;\n                8'h30: dat_in_m_rx_bd <= wb_dat_i;\n                default: ;\n            endcase\n        end else begin\n            // Read operation\n            case (wb_adr_i)\n                8'h00: wb_dat_o <= command_reg;\n                8'h04: wb_dat_o <= argument_reg;\n                8'h08: wb_dat_o <= {16'b0, cmd_setting_reg};\n                8'h0C: wb_dat_o <= {24'b0, software_reset_reg};\n                8'h10: wb_dat_o <= {16'b0, time_out_reg};\n                8'h14: wb_dat_o <= {24'b0, clock_divider};\n                8'h18: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                8'h1C: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                8'h20: wb_dat_o <= {24'b0, bd_isr_reset};\n                8'h24: wb_dat_o <= {24'b0, normal_isr_reset};\n                8'h28: wb_dat_o <= {24'b0, error_isr_reset};\n                8'h2C: wb_dat_o <= dat_in_m_tx_bd;\n                8'h30: wb_dat_o <= dat_in_m_rx_bd;\n                default: wb_dat_o <= 32'b0;\n            endcase\n        end\n    end else begin\n        wb_ack_o <= 1'b0;\n    end\nend\n\n// Master Wishbone Interface Control\nassign m_wb_adr_o = (start_tx_fifo) ? sd_fifo_tx_filler_adr : \n                    (start_rx_fifo) ? sd_fifo_rx_filler_adr : 32'b0;\nassign m_wb_we_o = (start_tx_fifo) ? sd_fifo_tx_filler_we : \n                   (start_rx_fifo) ? sd_fifo_rx_filler_we : 1'b0;\nassign m_wb_dat_o = (start_tx_fifo) ? sd_fifo_tx_filler_dat : \n                    (start_rx_fifo) ? sd_fifo_rx_filler_dat : 32'b0;\nassign m_wb_cyc_o = (start_tx_fifo || start_rx_fifo);\nassign m_wb_stb_o = (start_tx_fifo || start_rx_fifo);\nassign m_wb_cti_o = 3'b000; // Classic cycle\nassign m_wb_bte_o = 2'b00; // Linear burst\n\n// Interrupts\nassign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\nassign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\nassign int_c = |(bd_isr_reg & bd_isr_enable_reg);\n\n// SD/MMC Command and Data Interfaces\nassign sd_cmd_out_o = cmd_busy ? command_reg[31] : 1'b0;\nassign sd_cmd_oe_o = cmd_busy;\nassign sd_dat_out_o = {4{cmd_busy}} & sd_dat_dat_i;\nassign sd_dat_oe_o = cmd_busy;\n\n// Clock output\nassign sd_clk_o_pad = sd_clk_i_pad;\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_master", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_master (\n    input CLK_PAD_IO,\n    input RST_PAD_I,\n    input New_CMD,\n    input data_write,\n    input data_read,\n    input [31:0] ARG_REG,\n    input [13:0] CMD_SET_REG,\n    input [15:0] TIMEOUT_REG,\n    output reg [15:0] STATUS_REG,\n    output reg [31:0] RESP_1_REG,\n    output reg [4:0] ERR_INT_REG,\n    output reg [15:0] NORMAL_INT_REG,\n    input ERR_INT_RST,\n    input NORMAL_INT_RST,\n    output reg [15:0] settings,\n    output reg go_idle_o,\n    output reg [39:0] cmd_out,\n    output reg req_out,\n    output reg ack_out,\n    input req_in,\n    input ack_in,\n    input [39:0] cmd_in,\n    input [7:0] serial_status,\n    input card_detect\n);\n\n    // State definitions\n    localparam IDLE = 3'b001, SETUP = 3'b010, EXECUTE = 3'b100;\n\n    // Registers for state machine\n    reg [2:0] state, next_state;\n\n    // Registers for debounce logic\n    reg [3:0] debounce;\n    reg card_present;\n\n    // Registers for synchronization\n    reg req_in_int, ack_in_int;\n    reg req_q, ack_q;\n\n    // Registers for FSM operation\n    reg [15:0] Watchdog_Cnt;\n    reg complete;\n    reg index_check_enable, CRC_check_enable;\n    reg [6:0] response_size;\n\n    // Debounce Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            debounce <= 4'b0000;\n            card_present <= 1'b0;\n        end else begin\n            if (!card_detect) begin\n                if (debounce != 4'b1111)\n                    debounce <= debounce + 1;\n                if (debounce == 4'b1110)\n                    card_present <= 1'b1;\n            end else begin\n                debounce <= 4'b0000;\n                card_present <= 1'b0;\n            end\n        end\n    end\n\n    // Synchronization Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            req_q <= 1'b0;\n            ack_q <= 1'b0;\n            req_in_int <= 1'b0;\n            ack_in_int <= 1'b0;\n        end else begin\n            req_q <= req_in;\n            ack_q <= ack_in;\n            req_in_int <= req_q;\n            ack_in_int <= ack_q;\n        end\n    end\n\n    // FSM Logic\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = New_CMD ? SETUP : IDLE;\n            SETUP: next_state = ack_in_int ? EXECUTE : SETUP;\n            EXECUTE: next_state = complete ? IDLE : EXECUTE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic based on state\n    always @(posedge CLK_PAD_IO or posedge RST_PAD_I) begin\n        if (RST_PAD_I) begin\n            go_idle_o <= 1'b0;\n            req_out <= 1'b0;\n            ack_out <= 1'b0;\n            STATUS_REG <= 16'b0;\n            RESP_1_REG <= 32'b0;\n            ERR_INT_REG <= 5'b0;\n            NORMAL_INT_REG <= 16'b0;\n            settings <= 16'b0;\n            cmd_out <= 40'b0;\n            Watchdog_Cnt <= 16'b0;\n            complete <= 1'b0;\n            index_check_enable <= 1'b0;\n            CRC_check_enable <= 1'b0;\n            response_size <= 7'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    go_idle_o <= 1'b0;\n                    req_out <= 1'b0;\n                    ack_out <= 1'b0;\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1'b1;\n                    end\n                end\n                SETUP: begin\n                    NORMAL_INT_REG <= 16'b0;\n                    ERR_INT_REG <= 5'b0;\n                    index_check_enable <= CMD_SET_REG[4];\n                    CRC_check_enable <= CMD_SET_REG[3];\n                    cmd_out[39:38] <= 2'b01;\n                    cmd_out[37:32] <= CMD_SET_REG[13:8];\n                    cmd_out[31:0] <= ARG_REG;\n                    response_size <= (CMD_SET_REG[1:0] == 2'b10 || CMD_SET_REG[1:0] == 2'b11) ? 7'b0101000 :\n                                     (CMD_SET_REG[1:0] == 2'b01) ? 7'b1111111 : 7'b0;\n                    settings[14:13] <= CMD_SET_REG[7:6];\n                    settings[12] <= data_read;\n                    settings[11] <= data_write;\n                    settings[10:8] <= 3'b111;\n                    settings[7] <= CMD_SET_REG[3];\n                    settings[6:0] <= response_size;\n                    Watchdog_Cnt <= 16'b0;\n                end\n                EXECUTE: begin\n                    Watchdog_Cnt <= Watchdog_Cnt + 1;\n                    if (Watchdog_Cnt > TIMEOUT_REG) begin\n                        ERR_INT_REG[0] <= 1'b1; // CTE\n                        NORMAL_INT_REG[15] <= 1'b1; // EI\n                        go_idle_o <= 1'b1;\n                    end\n                    if (ack_in_int) begin\n                        req_out <= 1'b1;\n                    end\n                    if (req_in_int) begin\n                        STATUS_REG <= serial_status;\n                        ack_out <= 1'b1;\n                        if (serial_status[6]) begin\n                            complete <= 1'b1;\n                            NORMAL_INT_REG[0] <= 1'b1; // CC\n                            if (CRC_check_enable && !serial_status[5]) begin\n                                ERR_INT_REG[1] <= 1'b1; // CCRCE\n                                NORMAL_INT_REG[15] <= 1'b1; // EI\n                            end\n                            if (index_check_enable && (cmd_out[37:32] != cmd_in[37:32])) begin\n                                ERR_INT_REG[3] <= 1'b1; // CIE\n                                NORMAL_INT_REG[15] <= 1'b1; // EI\n                            end\n                            if (response_size != 0) begin\n                                RESP_1_REG <= cmd_in[31:0];\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master (\n    input wire clk,\n    input wire rst,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input wire [BD_WIDTH-1:0] free_tx_bd,\n    input wire ack_i_s_tx,\n    input wire [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input wire [BD_WIDTH-1:0] free_rx_bd,\n    input wire ack_i_s_rx,\n    input wire cmd_busy,\n    input wire we_ack,\n    input wire cmd_tsf_err,\n    input wire [4:0] card_status,\n    input wire tx_empt,\n    input wire tx_full,\n    input wire rx_full,\n    input wire busy_n,\n    input wire transm_complete,\n    input wire crc_ok,\n    input wire Dat_Int_Status_rst,\n    input wire [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n// Parameters\nparameter CMD24 = 16'h181A;\nparameter CMD17 = 16'h111A;\nparameter CMD12 = 16'hC1A;\nparameter ACMD13 = 16'hD1A;\nparameter ACMD51 = 16'h331A;\nparameter SIZE = 9;\nparameter IDLE = 9'b000000001;\nparameter GET_TX_BD = 9'b000000010;\nparameter GET_RX_BD = 9'b000000100;\nparameter SEND_CMD = 9'b000001000;\nparameter RECIVE_CMD = 9'b000010000;\nparameter DATA_TRANSFER = 9'b000100000;\nparameter STOP = 9'b001000000;\nparameter STOP_SEND = 9'b010000000;\nparameter RESEND_MAX_CNT = 3;\n\n// Internal signals\nreg [SIZE-1:0] state, next_state;\nreg [2:0] resend_try_cnt;\nreg send_done, rec_done, rec_failed, tx_cycle, rx_cycle, trans_done, trans_failed;\nreg [2:0] bd_cnt;\n\n// FSM logic\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= IDLE;\n        resend_try_cnt <= 0;\n        send_done <= 0;\n        rec_done <= 0;\n        rec_failed <= 0;\n        tx_cycle <= 0;\n        rx_cycle <= 0;\n        trans_done <= 0;\n        trans_failed <= 0;\n        bd_cnt <= 0;\n        Dat_Int_Status <= 0;\n    end else begin\n        state <= next_state;\n        if (state == SEND_CMD && we_ack) send_done <= 1;\n        if (state == RECIVE_CMD && !cmd_busy && !cmd_tsf_err && card_status[0]) rec_done <= 1;\n        if (state == RECIVE_CMD && (cmd_tsf_err || !card_status[0])) rec_failed <= 1;\n        if (state == DATA_TRANSFER && transm_complete && crc_ok) trans_done <= 1;\n        if (state == DATA_TRANSFER && (!transm_complete || !crc_ok)) trans_failed <= 1;\n        if (Dat_Int_Status_rst) Dat_Int_Status <= 0;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    next_state = state; // Default to stay in current state\n    case (state)\n        IDLE: begin\n            if (free_tx_bd != BD_EMPTY) next_state = GET_TX_BD;\n            else if (free_rx_bd != BD_EMPTY) next_state = GET_RX_BD;\n        end\n        GET_TX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1 && tx_full) next_state = SEND_CMD;\n        end\n        GET_RX_BD: begin\n            if (bd_cnt >= READ_CYCLE - 1) next_state = SEND_CMD;\n        end\n        SEND_CMD: begin\n            if (send_done) next_state = RECIVE_CMD;\n        end\n        RECIVE_CMD: begin\n            if (rec_done) next_state = DATA_TRANSFER;\n            else if (rec_failed) next_state = SEND_CMD;\n        end\n        DATA_TRANSFER: begin\n            if (trans_done) next_state = IDLE;\n            else if (trans_failed) next_state = STOP;\n        end\n        STOP: begin\n            next_state = STOP_SEND;\n        end\n        STOP_SEND: begin\n            if (send_done) next_state = IDLE;\n        end\n    endcase\nend\n\n// Output logic\nalways @(*) begin\n    // Reset outputs\n    re_s_tx = 0;\n    a_cmp_tx = 0;\n    re_s_rx = 0;\n    a_cmp_rx = 0;\n    we_req = 0;\n    d_write = 0;\n    d_read = 0;\n    start_tx_fifo = 0;\n    start_rx_fifo = 0;\n    ack_transfer = 0;\n    CIDAT = 0;\n\n    case (state)\n        GET_TX_BD: begin\n            re_s_tx = 1;\n            if (ack_i_s_tx) begin\n                sys_adr = dat_in_tx;\n                cmd_arg = dat_in_tx;\n                start_tx_fifo = 1;\n                cmd_set = CMD24;\n                tx_cycle = 1;\n            end\n        end\n        GET_RX_BD: begin\n            re_s_rx = 1;\n            if (ack_i_s_rx) begin\n                sys_adr = dat_in_rx;\n                cmd_arg = dat_in_rx;\n                start_rx_fifo = 1;\n                cmd_set = (transfer_type == 2'b00) ? CMD17 : (transfer_type == 2'b01) ? ACMD13 : ACMD51;\n                rx_cycle = 1;\n            end\n        end\n        SEND_CMD: begin\n            if (!cmd_busy) begin\n                we_req = 1;\n                if (tx_cycle) d_write = 1;\n                if (rx_cycle) d_read = 1;\n            end\n        end\n        RECIVE_CMD: begin\n            if (rx_cycle) start_rx_fifo = 1;\n        end\n        DATA_TRANSFER: begin\n            if (transm_complete) begin\n                ack_transfer = 1;\n                a_cmp_tx = tx_cycle;\n                a_cmp_rx = rx_cycle;\n            end\n        end\n        STOP_SEND: begin\n            cmd_set = CMD12;\n            if (!cmd_busy) we_req = 1;\n        end\n    endcase\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_controller_wb", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_controller_wb (\n    input wire wb_clk_i,\n    input wire wb_rst_i,\n    input wire [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input wire [7:0] wb_adr_i,\n    input wire [3:0] wb_sel_i,\n    input wire wb_we_i,\n    input wire wb_cyc_i,\n    input wire wb_stb_i,\n    output reg wb_ack_o,\n    output reg we_m_tx_bd,\n    output reg we_m_rx_bd,\n    output reg new_cmd,\n    output reg we_ack,\n    output reg int_ack,\n    output reg cmd_int_busy,\n    output reg int_busy,\n    input wire write_req_s,\n    input wire [15:0] cmd_set_s,\n    input wire [31:0] cmd_arg_s,\n    output reg [31:0] argument_reg,\n    output reg [15:0] cmd_setting_reg,\n    input wire [15:0] status_reg,\n    input wire [31:0] cmd_resp_1,\n    output reg [8:0] software_reset_reg,\n    output reg [15:0] time_out_reg,\n    input wire [15:0] normal_int_status_reg,\n    input wire [15:0] error_int_status_reg,\n    output reg [15:0] normal_int_signal_enable_reg,\n    output reg [15:0] error_int_signal_enable_reg,\n    output reg [7:0] clock_divider,\n    input wire [15:0] Bd_Status_reg,\n    input wire [7:0] Bd_isr_reg,\n    output reg [7:0] Bd_isr_enable_reg,\n    output reg Bd_isr_reset,\n    output reg normal_isr_reset,\n    output reg error_isr_reset,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_tx_bd,\n    output reg [RAM_MEM_WIDTH-1:0] dat_in_m_rx_bd\n);\n\n    // Register addresses\n    localparam ADDR_ARGUMENT           = 8'h00;\n    localparam ADDR_CMD_SETTING        = 8'h04;\n    localparam ADDR_CARD_STATUS        = 8'h08;\n    localparam ADDR_RESPONSE           = 8'h0C;\n    localparam ADDR_SOFTWARE_RESET     = 8'h28;\n    localparam ADDR_TIMEOUT            = 8'h2C;\n    localparam ADDR_NORMAL_INT_STATUS  = 8'h30;\n    localparam ADDR_ERROR_INT_STATUS   = 8'h34;\n    localparam ADDR_NORMAL_INT_ENABLE  = 8'h38;\n    localparam ADDR_ERROR_INT_ENABLE   = 8'h3C;\n    localparam ADDR_CLOCK_DIVIDER      = 8'h4C;\n    localparam ADDR_BD_STATUS          = 8'h50;\n    localparam ADDR_DAT_INT_STATUS     = 8'h54;\n    localparam ADDR_DAT_INT_ENABLE     = 8'h58;\n    localparam ADDR_BD_RX              = 8'h60;\n    localparam ADDR_BD_TX              = 8'h80;\n\n    always @(posedge wb_clk_i) begin\n        if (wb_rst_i) begin\n            // Reset all registers and outputs\n            wb_dat_o <= 32'b0;\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n            new_cmd <= 1'b0;\n            we_ack <= 1'b0;\n            int_ack <= 1'b1; // Default to high\n            cmd_int_busy <= 1'b0;\n            int_busy <= 1'b0;\n            argument_reg <= 32'b0;\n            cmd_setting_reg <= 16'b0;\n            software_reset_reg <= 9'b0;\n            time_out_reg <= 16'b0;\n            normal_int_signal_enable_reg <= 16'b0;\n            error_int_signal_enable_reg <= 16'b0;\n            clock_divider <= 8'b0;\n            Bd_isr_enable_reg <= 8'b0;\n            Bd_isr_reset <= 1'b0;\n            normal_isr_reset <= 1'b0;\n            error_isr_reset <= 1'b0;\n            dat_in_m_tx_bd <= {RAM_MEM_WIDTH{1'b0}};\n            dat_in_m_rx_bd <= {RAM_MEM_WIDTH{1'b0}};\n        end else if (wb_cyc_i && wb_stb_i) begin\n            wb_ack_o <= 1'b1; // Acknowledge the wishbone transaction\n            if (wb_we_i) begin\n                // Write operation\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: argument_reg <= wb_dat_i;\n                    ADDR_CMD_SETTING: cmd_setting_reg <= wb_dat_i[15:0];\n                    ADDR_SOFTWARE_RESET: software_reset_reg <= wb_dat_i[8:0];\n                    ADDR_TIMEOUT: time_out_reg <= wb_dat_i[15:0];\n                    ADDR_NORMAL_INT_ENABLE: normal_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_ERROR_INT_ENABLE: error_int_signal_enable_reg <= wb_dat_i[15:0];\n                    ADDR_CLOCK_DIVIDER: clock_divider <= wb_dat_i[7:0];\n                    ADDR_DAT_INT_ENABLE: Bd_isr_enable_reg <= wb_dat_i[7:0];\n                    ADDR_BD_RX: begin\n                        dat_in_m_rx_bd <= wb_dat_i;\n                        we_m_rx_bd <= 1'b1;\n                    end\n                    ADDR_BD_TX: begin\n                        dat_in_m_tx_bd <= wb_dat_i;\n                        we_m_tx_bd <= 1'b1;\n                    end\n                    default: ;\n                endcase\n            end else begin\n                // Read operation\n                case (wb_adr_i)\n                    ADDR_ARGUMENT: wb_dat_o <= argument_reg;\n                    ADDR_CMD_SETTING: wb_dat_o <= {16'b0, cmd_setting_reg};\n                    ADDR_CARD_STATUS: wb_dat_o <= {16'b0, status_reg};\n                    ADDR_RESPONSE: wb_dat_o <= cmd_resp_1;\n                    ADDR_SOFTWARE_RESET: wb_dat_o <= {23'b0, software_reset_reg};\n                    ADDR_TIMEOUT: wb_dat_o <= {16'b0, time_out_reg};\n                    ADDR_NORMAL_INT_STATUS: wb_dat_o <= {16'b0, normal_int_status_reg};\n                    ADDR_ERROR_INT_STATUS: wb_dat_o <= {16'b0, error_int_status_reg};\n                    ADDR_NORMAL_INT_ENABLE: wb_dat_o <= {16'b0, normal_int_signal_enable_reg};\n                    ADDR_ERROR_INT_ENABLE: wb_dat_o <= {16'b0, error_int_signal_enable_reg};\n                    ADDR_CLOCK_DIVIDER: wb_dat_o <= {24'b0, clock_divider};\n                    ADDR_BD_STATUS: wb_dat_o <= {16'b0, Bd_Status_reg};\n                    ADDR_DAT_INT_STATUS: wb_dat_o <= {24'b0, Bd_isr_reg};\n                    ADDR_DAT_INT_ENABLE: wb_dat_o <= {24'b0, Bd_isr_enable_reg};\n                    default: wb_dat_o <= 32'b0;\n                endcase\n            end\n        end else begin\n            wb_ack_o <= 1'b0;\n            we_m_tx_bd <= 1'b0;\n            we_m_rx_bd <= 1'b0;\n        end\n    end\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sdc_controller", "codeid": 20, "code": "module sdc_controller(\n    input wb_clk_i,\n    input wb_rst_i,\n    input [3:0] wb_sel_i,\n    input [31:0] wb_dat_i,\n    output reg [31:0] wb_dat_o,\n    input [7:0] wb_adr_i,\n    input wb_we_i,\n    input wb_cyc_i,\n    input wb_stb_i,\n    output reg wb_ack_o,\n    output [31:0] m_wb_adr_o,\n    output m_wb_sel_o,\n    output m_wb_we_o,\n    output [31:0] m_wb_dat_o,\n    input [31:0] m_wb_dat_i,\n    output m_wb_cyc_o,\n    output m_wb_stb_o,\n    input m_wb_ack_i,\n    output m_wb_cti_o,\n    output m_wb_bte_o,\n    input card_detect,\n    input sd_cmd_dat_i,\n    output sd_cmd_out_o,\n    output sd_cmd_oe_o,\n    input [3:0] sd_dat_dat_i,\n    output [3:0] sd_dat_out_o,\n    output sd_dat_oe_o,\n    output sd_clk_o_pad,\n    input sd_clk_i_pad,\n    output int_a,\n    output int_b,\n    output int_c\n);\n\n    // Internal signals\n    wire [31:0] argument_reg;\n    wire [15:0] cmd_setting_reg;\n    wire [7:0] software_reset_reg;\n    wire [15:0] time_out_reg;\n    wire [15:0] normal_int_status_reg;\n    wire [15:0] error_int_status_reg;\n    wire [15:0] normal_int_signal_enable_reg;\n    wire [15:0] error_int_signal_enable_reg;\n    wire [7:0] clock_divider;\n    wire [15:0] Bd_Status_reg;\n    wire [7:0] Bd_isr_reg;\n    wire [7:0] Bd_isr_enable_reg;\n    wire bd_isr_reset;\n    wire normal_isr_reset;\n    wire error_isr_reset;\n    wire [31:0] dat_in_m_tx_bd;\n    wire [31:0] dat_in_m_rx_bd;\n    wire we_m_tx_bd;\n    wire we_m_rx_bd;\n    wire new_cmd;\n    wire we_ack;\n    wire int_ack;\n    wire cmd_int_busy;\n    wire int_busy;\n    wire write_req_s;\n    wire [15:0] cmd_set_s;\n    wire [31:0] cmd_arg_s;\n    wire [15:0] status_reg;\n    wire [31:0] cmd_resp_1;\n    wire [7:0] clock_divider_out;\n    wire sd_clk_out;\n\n    // Instantiate sub-modules\n    sd_controller_wb sd_controller_wb_inst(\n        .wb_clk_i(wb_clk_i),\n        .wb_rst_i(wb_rst_i),\n        .wb_dat_i(wb_dat_i),\n        .wb_dat_o(wb_dat_o),\n        .wb_adr_i(wb_adr_i),\n        .wb_sel_i(wb_sel_i),\n        .wb_we_i(wb_we_i),\n        .wb_cyc_i(wb_cyc_i),\n        .wb_stb_i(wb_stb_i),\n        .wb_ack_o(wb_ack_o),\n        .we_m_tx_bd(we_m_tx_bd),\n        .we_m_rx_bd(we_m_rx_bd),\n        .new_cmd(new_cmd),\n        .we_ack(we_ack),\n        .int_ack(int_ack),\n        .cmd_int_busy(cmd_int_busy),\n        .int_busy(int_busy),\n        .write_req_s(write_req_s),\n        .cmd_set_s(cmd_set_s),\n        .cmd_arg_s(cmd_arg_s),\n        .argument_reg(argument_reg),\n        .cmd_setting_reg(cmd_setting_reg),\n        .status_reg(status_reg),\n        .cmd_resp_1(cmd_resp_1),\n        .software_reset_reg(software_reset_reg),\n        .time_out_reg(time_out_reg),\n        .normal_int_status_reg(normal_int_status_reg),\n        .error_int_status_reg(error_int_status_reg),\n        .normal_int_signal_enable_reg(normal_int_signal_enable_reg),\n        .error_int_signal_enable_reg(error_int_signal_enable_reg),\n        .clock_divider(clock_divider),\n        .Bd_Status_reg(Bd_Status_reg),\n        .Bd_isr_reg(Bd_isr_reg),\n        .Bd_isr_enable_reg(Bd_isr_enable_reg),\n        .bd_isr_reset(bd_isr_reset),\n        .normal_isr_reset(normal_isr_reset),\n        .error_isr_reset(error_isr_reset),\n        .dat_in_m_tx_bd(dat_in_m_tx_bd),\n        .dat_in_m_rx_bd(dat_in_m_rx_bd)\n    );\n\n    // Clock divider\n    sd_clock_divider sd_clock_divider_inst(\n        .CLK(wb_clk_i),\n        .DIVIDER(clock_divider),\n        .RST(wb_rst_i),\n        .SD_CLK(sd_clk_out)\n    );\n\n    // Connect clock output to sd_clk_o_pad\n    assign sd_clk_o_pad = sd_clk_out;\n\n    // Master Wishbone Interface Control\n    assign m_wb_cyc_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_cyc_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_cyc_o : 1'b0);\n    assign m_wb_stb_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_stb_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_stb_o : 1'b0);\n    assign m_wb_cti_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_cti_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_cti_o : 3'b000);\n    assign m_wb_bte_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_bte_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_bte_o : 2'b00);\n    assign m_wb_we_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_we_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_we_o : 1'b0);\n    assign m_wb_adr_o = start_tx_fifo ? sd_fifo_tx_filler.m_wb_adr_o : (start_rx_fifo ? sd_fifo_rx_filler.m_wb_adr_o : 32'b0);\n\n    // Interrupt logic\n    assign int_a = |(normal_int_status_reg & normal_int_signal_enable_reg);\n    assign int_b = |(error_int_status_reg & error_int_signal_enable_reg);\n    assign int_c = |(Bd_isr_reg & Bd_isr_enable_reg);\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 18, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal Constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // FSM States\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal Signals\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_IN;\n    wire [6:0] CRC_VAL;\n    reg CRC_Enable, CRC_OUT, CRC_Check_On, Crc_Buffering, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg [SIZE-1:0] state, next_state;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in;\n    reg q1, Ack_internal_in;\n\n    // REQ_SYNC and ACK_SYNC\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 1'b0;\n            Req_internal_in <= 1'b0;\n            q1 <= 1'b0;\n            Ack_internal_in <= 1'b0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // COMMAND_DECODER\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            CRC_Check_On <= 0;\n            Delay_Cycler <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n            In_Buff <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 1;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 0;\n        end\n    end\n\n    // FSM_COMBO\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = (Write_Read) ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = (Ack_internal_in) ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // FSM_OUT\n    always @(posedge SD_CLK_IN) begin\n        case (state)\n            INIT: begin\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            IDLE: begin\n                cmd_oe_o <= 0;\n                cmd_out_o <= 1;\n                Cmd_Cnt <= 0;\n                Delay_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                CMD_OUT <= 0;\n                Crc_Buffering <= 0;\n                STATUS <= 0;\n                CRC_Valid <= 0;\n                Cmd_Cnt <= 0;\n                st_dat_t <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        CMD_OUT <= In_Buff[39 - Cmd_Cnt];\n                        if (Cmd_Cnt > 9) CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        CRC_OUT <= CRC_VAL[Cmd_Cnt - 2];\n                        st_dat_t <= {block_read, block_write};\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    CMD_OUT <= In_Buff[39 - Cmd_Cnt];\n                    CRC_OUT <= CRC_VAL[Cmd_Cnt - 2];\n                    st_dat_t <= {block_read, block_write};\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[39 - Cmd_Cnt];\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                cmd_oe_o <= 0;\n                if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[39 - Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    st_dat_t <= {block_read, block_write};\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                cmd_oe_o <= 0;\n                CMD_OUT <= Out_Buff;\n                Delay_Cnt <= Delay_Cnt + 1;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\n\n    // CRC Module Instance\n    sd_crc_7 crc_module (\n        .BITVAL(CRC_IN),\n        .Enable(CRC_Enable),\n        .CLK(SD_CLK_IN),\n        .RST(CRC_RST),\n        .CRC(CRC_VAL)\n    );\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_data_master", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_data_master(\n    input clk,\n    input rst,\n    input [RAM_MEM_WIDTH-1:0] dat_in_tx,\n    input [BD_WIDTH-1:0] free_tx_bd,\n    input ack_i_s_tx,\n    input [RAM_MEM_WIDTH-1:0] dat_in_rx,\n    input [BD_WIDTH-1:0] free_rx_bd,\n    input ack_i_s_rx,\n    input cmd_busy,\n    input we_ack,\n    input cmd_tsf_err,\n    input [4:0] card_status,\n    input tx_empt,\n    input tx_full,\n    input rx_full,\n    input busy_n,\n    input transm_complete,\n    input crc_ok,\n    input Dat_Int_Status_rst,\n    input [1:0] transfer_type,\n    output reg re_s_tx,\n    output reg a_cmp_tx,\n    output reg re_s_rx,\n    output reg a_cmp_rx,\n    output reg we_req,\n    output reg d_write,\n    output reg d_read,\n    output reg [31:0] cmd_arg,\n    output reg [15:0] cmd_set,\n    output reg start_tx_fifo,\n    output reg start_rx_fifo,\n    output reg [31:0] sys_adr,\n    output reg ack_transfer,\n    output reg [7:0] Dat_Int_Status,\n    output reg CIDAT\n);\n\n    // Parameters\n    localparam CMD24 = 16'h181A;\n    localparam CMD17 = 16'h111A;\n    localparam CMD12 = 16'hC1A;\n    localparam ACMD13 = 16'hD1A;\n    localparam ACMD51 = 16'h331A;\n    localparam SIZE = 9;\n    localparam IDLE = 9'b000000001;\n    localparam GET_TX_BD = 9'b000000010;\n    localparam GET_RX_BD = 9'b000000100;\n    localparam SEND_CMD = 9'b000001000;\n    localparam RECIVE_CMD = 9'b000010000;\n    localparam DATA_TRANSFER = 9'b000100000;\n    localparam STOP = 9'b001000000;\n    localparam STOP_SEND = 9'b010000000;\n    localparam RESEND_MAX_CNT = 3;\n\n    // State Registers\n    reg [SIZE-1:0] state = IDLE;\n    reg [SIZE-1:0] next_state = IDLE;\n\n    // Internal Registers\n    reg [2:0] resend_try_cnt = 0;\n    reg send_done = 0;\n    reg rec_done = 0;\n    reg rec_failed = 0;\n    reg tx_cycle = 0;\n    reg rx_cycle = 0;\n    reg trans_done = 0;\n    reg trans_failed = 0;\n    reg internal_transm_complete = 0;\n    reg transm_complete_q = 0;\n    reg [2:0] bd_cnt = 0;\n\n    // FSM Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            resend_try_cnt <= 0;\n            send_done <= 0;\n            rec_done <= 0;\n            rec_failed <= 0;\n            tx_cycle <= 0;\n            rx_cycle <= 0;\n            trans_done <= 0;\n            trans_failed <= 0;\n            internal_transm_complete <= 0;\n            transm_complete_q <= 0;\n            bd_cnt <= 0;\n            Dat_Int_Status <= 0;\n            re_s_tx <= 0;\n            a_cmp_tx <= 0;\n            re_s_rx <= 0;\n            a_cmp_rx <= 0;\n            we_req <= 0;\n            d_write <= 0;\n            d_read <= 0;\n            start_tx_fifo <= 0;\n            start_rx_fifo <= 0;\n            ack_transfer <= 0;\n            CIDAT <= 0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    if (free_tx_bd != BD_EMPTY && free_rx_bd != BD_EMPTY) begin\n                        if (free_tx_bd > free_rx_bd) begin\n                            next_state <= GET_TX_BD;\n                        end else begin\n                            next_state <= GET_RX_BD;\n                        end\n                    end else if (free_tx_bd != BD_EMPTY) begin\n                        next_state <= GET_TX_BD;\n                    end else if (free_rx_bd != BD_EMPTY) begin\n                        next_state <= GET_RX_BD;\n                    end else begin\n                        next_state <= IDLE;\n                    end\n                end\n                GET_TX_BD: begin\n                    if (ack_i_s_tx) begin\n                        sys_adr <= dat_in_tx;\n                        cmd_arg <= dat_in_tx;\n                        start_tx_fifo <= 1;\n                        cmd_set <= CMD24;\n                        tx_cycle <= 1;\n                        next_state <= SEND_CMD;\n                    end else begin\n                        re_s_tx <= 1;\n                        next_state <= GET_TX_BD;\n                    end\n                end\n                GET_RX_BD: begin\n                    if (ack_i_s_rx) begin\n                        sys_adr <= dat_in_rx;\n                        cmd_arg <= dat_in_rx;\n                        start_rx_fifo <= 1;\n                        cmd_set <= CMD17;\n                        rx_cycle <= 1;\n                        next_state <= SEND_CMD;\n                    end else begin\n                        re_s_rx <= 1;\n                        next_state <= GET_RX_BD;\n                    end\n                end\n                SEND_CMD: begin\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            if (tx_cycle) d_write <= 1;\n                            if (rx_cycle) d_read <= 1;\n                            send_done <= 1;\n                            next_state <= RECIVE_CMD;\n                        end else begin\n                            next_state <= SEND_CMD;\n                        end\n                    end else begin\n                        next_state <= SEND_CMD;\n                    end\n                end\n                RECIVE_CMD: begin\n                    if (!cmd_busy) begin\n                        if (cmd_tsf_err) begin\n                            rec_failed <= 1;\n                            next_state <= SEND_CMD;\n                        end else if (card_status[0] == 1) begin\n                            rec_done <= 1;\n                            next_state <= DATA_TRANSFER;\n                        end else begin\n                            next_state <= RECIVE_CMD;\n                        end\n                    end else begin\n                        next_state <= RECIVE_CMD;\n                    end\n                end\n                DATA_TRANSFER: begin\n                    if (transm_complete) begin\n                        if (crc_ok) begin\n                            trans_done <= 1;\n                            next_state <= IDLE;\n                        end else begin\n                            trans_failed <= 1;\n                            next_state <= STOP;\n                        end\n                    end else begin\n                        next_state <= DATA_TRANSFER;\n                    end\n                end\n                STOP: begin\n                    cmd_set <= CMD12;\n                    next_state <= STOP_SEND;\n                end\n                STOP_SEND: begin\n                    if (!cmd_busy) begin\n                        we_req <= 1;\n                        if (we_ack) begin\n                            send_done <= 1;\n                            next_state <= IDLE;\n                        end else begin\n                            next_state <= STOP_SEND;\n                        end\n                    end else begin\n                        next_state <= STOP_SEND;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output Logic\n    always @(state) begin\n        case (state)\n            IDLE: begin\n                re_s_tx <= 0;\n                a_cmp_tx <= 0;\n                re_s_rx <= 0;\n                a_cmp_rx <= 0;\n                we_req <= 0;\n                d_write <= 0;\n                d_read <= 0;\n                start_tx_fifo <= 0;\n                start_rx_fifo <= 0;\n                ack_transfer <= 0;\n                CIDAT <= 0;\n            end\n            GET_TX_BD: begin\n                re_s_tx <= 1;\n            end\n            GET_RX_BD: begin\n                re_s_rx <= 1;\n            end\n            SEND_CMD: begin\n                we_req <= 1;\n            end\n            RECIVE_CMD: begin\n                if (rx_cycle) start_rx_fifo <= 1;\n            end\n            DATA_TRANSFER: begin\n                if (tx_cycle) start_tx_fifo <= 1;\n            end\n            STOP: begin\n                // No specific output actions needed for STOP state\n            end\n            STOP_SEND: begin\n                we_req <= 1;\n            end\n        endcase\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 19, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host (\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n    // Internal constants\n    localparam INIT_DELAY = `SIM ? 2 : 64;\n    localparam NCR = 2;\n    localparam SEND_SIZE = 48;\n    localparam SIZE = 10;\n    localparam CONTENT_SIZE = 40;\n    localparam Read_Delay = 7;\n    localparam EIGHT_PAD = 8;\n\n    // State definitions\n    localparam INIT = 10'b0000000001;\n    localparam IDLE = 10'b0000000010;\n    localparam WRITE_WR = 10'b0000000100;\n    localparam DLY_WR = 10'b0000001000;\n    localparam READ_WR = 10'b0000010000;\n    localparam DLY_READ = 10'b0000100000;\n    localparam ACK_WR = 10'b0001000000;\n    localparam WRITE_WO = 10'b0010000000;\n    localparam DLY_WO = 10'b0100000000;\n    localparam ACK_WO = 10'b1000000000;\n\n    // Internal signals\n    reg [SIZE-1:0] state, next_state;\n    reg [6:0] Response_Size;\n    reg [2:0] Delay_Cycler;\n    reg [39:0] In_Buff, Out_Buff;\n    reg Write_Read, Write_Only;\n    reg [4:0] word_select_counter;\n    reg CRC_RST, CRC_Enable, CRC_OUT, CRC_Check_On, Crc_Buffering, CRC_Valid;\n    reg [7:0] Cmd_Cnt;\n    reg [2:0] Delay_Cnt;\n    reg block_write, block_read;\n    reg [1:0] word_select;\n    reg FSM_ACK, DECODER_ACK;\n    reg q, Req_internal_in, q1, Ack_internal_in;\n\n    // Synchronize REQ_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q <= 0;\n            Req_internal_in <= 0;\n        end else begin\n            q <= REQ_IN;\n            Req_internal_in <= q;\n        end\n    end\n\n    // Synchronize ACK_IN\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            q1 <= 0;\n            Ack_internal_in <= 0;\n        end else begin\n            q1 <= ACK_IN;\n            Ack_internal_in <= q1;\n        end\n    end\n\n    // FSM_COMBO logic\n    always @(*) begin\n        case (state)\n            INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n            IDLE: next_state = Write_Read ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n            WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n            WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n            DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n            DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n            READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n            DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n            ACK_WO: next_state = IDLE;\n            ACK_WR: next_state = IDLE;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // FSM_SEQ logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            state <= INIT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // COMMAND_DECODER logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            Response_Size <= 0;\n            Delay_Cycler <= 0;\n            DECODER_ACK <= 0;\n            Write_Read <= 0;\n            Write_Only <= 0;\n            CRC_Check_On <= 0;\n            In_Buff <= 0;\n            block_write <= 0;\n            block_read <= 0;\n            word_select <= 0;\n        end else if (Req_internal_in) begin\n            Response_Size <= SETTING_IN[6:0];\n            CRC_Check_On <= SETTING_IN[7];\n            Delay_Cycler <= SETTING_IN[10:8];\n            block_write <= SETTING_IN[11];\n            block_read <= SETTING_IN[12];\n            word_select <= SETTING_IN[14:13];\n            In_Buff <= CMD_IN;\n            if (SETTING_IN[6:0] > 0) begin\n                Write_Read <= 1;\n                Write_Only <= 0;\n            end else begin\n                Write_Read <= 0;\n                Write_Only <= 1;\n            end\n            DECODER_ACK <= 0;\n        end else begin\n            Write_Read <= 0;\n            Write_Only <= 0;\n            DECODER_ACK <= 1;\n        end\n    end\n\n    // FSM_OUT logic\n    always @(posedge SD_CLK_IN or posedge RST_IN) begin\n        if (RST_IN) begin\n            CMD_OUT <= 0;\n            ACK_OUT <= 0;\n            REQ_OUT <= 0;\n            STATUS <= 0;\n            cmd_oe_o <= 1;\n            cmd_out_o <= 1;\n            st_dat_t <= 0;\n        end else begin\n            case (state)\n                INIT: begin\n                    cmd_oe_o <= 1;\n                    cmd_out_o <= 1;\n                    if (Cmd_Cnt < INIT_DELAY) Cmd_Cnt <= Cmd_Cnt + 1;\n                end\n                IDLE: begin\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= 0;\n                    Cmd_Cnt <= 0;\n                    CRC_RST <= 1;\n                    CRC_Enable <= 0;\n                    CMD_OUT <= 0;\n                    st_dat_t <= 0;\n                    word_select_counter <= 0;\n                end\n                WRITE_WR: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS <= 16'b0000_0000_0000_0001;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[Cmd_Cnt];\n                            if (Cmd_Cnt > 9) CRC_OUT <= In_Buff[Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= block_read ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[Cmd_Cnt];\n                    end\n                end\n                WRITE_WO: begin\n                    FSM_ACK <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    if (Cmd_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0010;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Crc_Buffering) begin\n                        cmd_oe_o <= 1;\n                        if (Cmd_Cnt > 8) begin\n                            cmd_out_o <= In_Buff[Cmd_Cnt];\n                            if (Cmd_Cnt > 9) CRC_OUT <= In_Buff[Cmd_Cnt];\n                        end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                            cmd_out_o <= CRC_OUT;\n                            st_dat_t <= block_read ? 2'b10 : 2'b01;\n                        end else begin\n                            cmd_out_o <= 1;\n                        end\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end else begin\n                        Crc_Buffering <= 1;\n                        CRC_OUT <= In_Buff[Cmd_Cnt];\n                    end\n                end\n                DLY_WR: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0011;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 1;\n                    cmd_oe_o <= 0;\n                    if (Delay_Cnt < 3'b111) Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                DLY_WO: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0100;\n                        STATUS[5] <= 0;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                    Crc_Buffering <= 0;\n                end\n                READ_WR: begin\n                    Delay_Cnt <= 0;\n                    CRC_RST <= 0;\n                    CRC_Enable <= 1;\n                    cmd_oe_o <= 0;\n                    if (Cmd_Cnt == 1) begin\n                        STATUS[3:0] <= 4'b0101;\n                        REQ_OUT <= 1;\n                        Out_Buff[39] <= 0;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    if (Cmd_Cnt < Response_Size) begin\n                        Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                        CRC_OUT <= cmd_dat_i;\n                    end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                        CRC_IN <= cmd_dat_i;\n                        CRC_Enable <= 0;\n                    end else begin\n                        if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                            CRC_Valid <= 0;\n                            CRC_Enable <= 0;\n                        end else begin\n                            CRC_Valid <= 1;\n                            CRC_Enable <= 0;\n                        end\n                        st_dat_t <= block_read && block_write ? 2'b11 : (block_write ? 2'b01 : 2'b10);\n                        Cmd_Cnt <= Cmd_Cnt + 1;\n                    end\n                end\n                DLY_READ: begin\n                    if (Delay_Cnt == 0) begin\n                        STATUS[3:0] <= 4'b0110;\n                        STATUS[5] <= CRC_Valid;\n                        STATUS[6] <= 1;\n                        REQ_OUT <= 1;\n                    end else if (Ack_internal_in) begin\n                        REQ_OUT <= 0;\n                    end\n                    CRC_Enable <= 0;\n                    CRC_RST <= 1;\n                    Cmd_Cnt <= 0;\n                    cmd_oe_o <= 0;\n                    CMD_OUT <= Out_Buff;\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                ACK_WO: begin\n                    FSM_ACK <= 1;\n                end\n                ACK_WR: begin\n                    FSM_ACK <= 1;\n                    REQ_OUT <= 0;\n                end\n            endcase\n        end\n    end\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
{"task": "sd_cmd_serial_host", "codeid": 20, "code": "`include \"sd_defines.v\"\n\nmodule sd_cmd_serial_host(\n    input wire SD_CLK_IN,\n    input wire RST_IN,\n    input wire [15:0] SETTING_IN,\n    input wire [39:0] CMD_IN,\n    input wire REQ_IN,\n    input wire ACK_IN,\n    input wire cmd_dat_i,\n    output reg [39:0] CMD_OUT,\n    output reg ACK_OUT,\n    output reg REQ_OUT,\n    output reg [7:0] STATUS,\n    output reg cmd_oe_o,\n    output reg cmd_out_o,\n    output reg [1:0] st_dat_t\n);\n\n// Internal Constants\nlocalparam INIT_DELAY = `SIM ? 2 : 64;\nlocalparam NCR = 2;\nlocalparam SEND_SIZE = 48;\nlocalparam SIZE = 10;\nlocalparam CONTENT_SIZE = 40;\nlocalparam Read_Delay = 7;\nlocalparam EIGHT_PAD = 8;\n\n// FSM States\nlocalparam INIT = 10'b0000000001;\nlocalparam IDLE = 10'b0000000010;\nlocalparam WRITE_WR = 10'b0000000100;\nlocalparam DLY_WR = 10'b0000001000;\nlocalparam READ_WR = 10'b0000010000;\nlocalparam DLY_READ = 10'b0000100000;\nlocalparam ACK_WR = 10'b0001000000;\nlocalparam WRITE_WO = 10'b0010000000;\nlocalparam DLY_WO = 10'b0100000000;\nlocalparam ACK_WO = 10'b1000000000;\n\n// Internal Signals\nreg [6:0] Response_Size;\nreg [2:0] Delay_Cycler;\nreg [39:0] In_Buff, Out_Buff;\nreg Write_Read, Write_Only;\nreg [4:0] word_select_counter;\nreg CRC_RST, CRC_Enable, CRC_OUT, CRC_Check_On, Crc_Buffering, CRC_Valid;\nreg [7:0] Cmd_Cnt;\nreg [2:0] Delay_Cnt;\nreg [9:0] state, next_state;\nreg block_write, block_read;\nreg [1:0] word_select;\nreg FSM_ACK, DECODER_ACK;\nreg q, Req_internal_in, q1, Ack_internal_in;\n\n// REQ_SYNC and ACK_SYNC\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        q <= 0;\n        Req_internal_in <= 0;\n        q1 <= 0;\n        Ack_internal_in <= 0;\n    end else begin\n        q <= REQ_IN;\n        Req_internal_in <= q;\n        q1 <= ACK_IN;\n        Ack_internal_in <= q1;\n    end\nend\n\n// COMMAND_DECODER\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        Response_Size <= 0;\n        CRC_Check_On <= 0;\n        Delay_Cycler <= 0;\n        block_write <= 0;\n        block_read <= 0;\n        word_select <= 0;\n        In_Buff <= 0;\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 0;\n    end else if (Req_internal_in) begin\n        Response_Size <= SETTING_IN[6:0];\n        CRC_Check_On <= SETTING_IN[7];\n        Delay_Cycler <= SETTING_IN[10:8];\n        block_write <= SETTING_IN[11];\n        block_read <= SETTING_IN[12];\n        word_select <= SETTING_IN[14:13];\n        In_Buff <= CMD_IN;\n        Write_Read <= SETTING_IN[6:0] > 0;\n        Write_Only <= SETTING_IN[6:0] == 0;\n        DECODER_ACK <= 1;\n    end else begin\n        Write_Read <= 0;\n        Write_Only <= 0;\n        DECODER_ACK <= 0;\n    end\nend\n\n// FSM_COMBO\nalways @(*) begin\n    case (state)\n        INIT: next_state = (Cmd_Cnt >= INIT_DELAY) ? IDLE : INIT;\n        IDLE: next_state = Write_Read ? WRITE_WR : (Write_Only ? WRITE_WO : IDLE);\n        WRITE_WR: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WR : WRITE_WR;\n        WRITE_WO: next_state = (Cmd_Cnt >= SEND_SIZE - 1) ? DLY_WO : WRITE_WO;\n        DLY_WR: next_state = (Delay_Cnt >= NCR && !cmd_dat_i) ? READ_WR : DLY_WR;\n        DLY_WO: next_state = (Delay_Cnt >= Delay_Cycler) ? ACK_WO : DLY_WO;\n        READ_WR: next_state = (Cmd_Cnt >= (Response_Size + EIGHT_PAD)) ? DLY_READ : READ_WR;\n        DLY_READ: next_state = Ack_internal_in ? ACK_WR : DLY_READ;\n        ACK_WO: next_state = IDLE;\n        ACK_WR: next_state = IDLE;\n        default: next_state = INIT;\n    endcase\nend\n\n// FSM_SEQ\nalways @(posedge SD_CLK_IN or posedge RST_IN) begin\n    if (RST_IN) begin\n        state <= INIT;\n        Cmd_Cnt <= 0;\n        Delay_Cnt <= 0;\n        CRC_RST <= 1;\n        CRC_Enable <= 0;\n        CRC_OUT <= 0;\n        cmd_oe_o <= 1;\n        cmd_out_o <= 1;\n        Out_Buff <= 0;\n        FSM_ACK <= 1;\n        REQ_OUT <= 0;\n        ACK_OUT <= 1;\n        STATUS <= 0;\n        CRC_Valid <= 0;\n        Crc_Buffering <= 0;\n    end else begin\n        state <= next_state;\n        case (state)\n            INIT: begin\n                Cmd_Cnt <= Cmd_Cnt + 1;\n                cmd_oe_o <= 1;\n                cmd_out_o <= 1;\n            end\n            IDLE: begin\n                Cmd_Cnt <= 0;\n                Delay_Cnt <= 0;\n                CRC_RST <= 1;\n                CRC_Enable <= 0;\n                cmd_oe_o <= 0;\n                cmd_out_o <= 1;\n                Out_Buff <= 0;\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n                ACK_OUT <= 1;\n                STATUS <= 0;\n                CRC_Valid <= 0;\n                Crc_Buffering <= 0;\n            end\n            WRITE_WR: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS <= 16'b0000_0000_0000_0001;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[Cmd_Cnt - 9];\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_OUT;\n                        st_dat_t <= {block_read, block_write};\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[Cmd_Cnt];\n                end\n            end\n            WRITE_WO: begin\n                FSM_ACK <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                if (Cmd_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0010;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Crc_Buffering) begin\n                    cmd_oe_o <= 1;\n                    if (Cmd_Cnt > 8) begin\n                        cmd_out_o <= In_Buff[Cmd_Cnt - 9];\n                    end else if (Cmd_Cnt <= 8 && Cmd_Cnt >= 2) begin\n                        cmd_out_o <= CRC_OUT;\n                        st_dat_t <= {block_read, block_write};\n                    end else begin\n                        cmd_out_o <= 1;\n                    end\n                    Cmd_Cnt <= Cmd_Cnt + 1;\n                end else begin\n                    Crc_Buffering <= 1;\n                    CRC_OUT <= In_Buff[Cmd_Cnt];\n                end\n            end\n            DLY_WR: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0011;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 1;\n                cmd_oe_o <= 0;\n                if (Delay_Cnt < 3'b111) begin\n                    Delay_Cnt <= Delay_Cnt + 1;\n                end\n                Crc_Buffering <= 0;\n            end\n            DLY_WO: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0100;\n                    STATUS[5] <= 0;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                Crc_Buffering <= 0;\n            end\n            READ_WR: begin\n                Delay_Cnt <= 0;\n                CRC_RST <= 0;\n                CRC_Enable <= 1;\n                cmd_oe_o <= 0;\n                if (Cmd_Cnt == 1) begin\n                    STATUS[3:0] <= 4'b0101;\n                    REQ_OUT <= 1;\n                    Out_Buff[39] <= 0;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                if (Cmd_Cnt < Response_Size) begin\n                    Out_Buff[Cmd_Cnt] <= cmd_dat_i;\n                    CRC_OUT <= cmd_dat_i;\n                end else if ((Cmd_Cnt - Response_Size) <= 6) begin\n                    CRC_IN <= cmd_dat_i;\n                    CRC_Enable <= 0;\n                end else begin\n                    if ((CRC_IN != CRC_VAL) && CRC_Check_On) begin\n                        CRC_Valid <= 0;\n                        CRC_Enable <= 0;\n                    end else begin\n                        CRC_Valid <= 1;\n                        CRC_Enable <= 0;\n                    end\n                    st_dat_t <= {block_read, block_write};\n                end\n                Cmd_Cnt <= Cmd_Cnt + 1;\n            end\n            DLY_READ: begin\n                if (Delay_Cnt == 0) begin\n                    STATUS[3:0] <= 4'b0110;\n                    STATUS[5] <= CRC_Valid;\n                    STATUS[6] <= 1;\n                    REQ_OUT <= 1;\n                end else if (Ack_internal_in) begin\n                    REQ_OUT <= 0;\n                end\n                CRC_Enable <= 0;\n                CRC_RST <= 1;\n                Cmd_Cnt <= 0;\n                cmd_oe_o <= 0;\n                Delay_Cnt <= Delay_Cnt + 1;\n                CMD_OUT <= Out_Buff;\n            end\n            ACK_WO: begin\n                FSM_ACK <= 1;\n            end\n            ACK_WR: begin\n                FSM_ACK <= 1;\n                REQ_OUT <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule", "syntax": -2, "function": -2, "formal": -2, "syntax_info": null, "function_info": null, "formal_info": null}
